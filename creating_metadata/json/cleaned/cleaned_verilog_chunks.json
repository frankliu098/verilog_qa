[
    {
        "file_name": "ffetch.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/formal/ffetch.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: ffetch.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A set of memory properties, with the goal that if any memory // can meet these properties, then the ZipCPU should be able to // interact with that memory properly. // // This particular property set",
            "reg ards the instruction fetch. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module ffetch #( // {{{ // Address width -- from the CPU's perspective, not the bus'es",
            "parameter ADDRESS_WIDTH = 30, parameter [0:0] OPT_ALIGNED = 1'b0, parameter [0:0] OPT_CONTRACT = 1'b1, parameter INSN_WIDTH = 32, // Number of bits in an instruction",
            "parameter [0:0] F_OPT_ASYNC_RESET = 1'b0, localparam AW=ADDRESS_WIDTH, // Shorthand for ADDRESS_WIDTH",
            "localparam BW=AW + $clog2(INSN_WIDTH/8) // Byte addr wid // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // // The interface with the rest of the CPU",
            "input wire cpu_new_pc, input wire cpu_clear_cache, input wire [BW-1:0] cpu_pc, input wire pf_valid, input wire cpu_ready, input wire [BW-1:0] pf_pc, input wire [(INSN_WIDTH-1):0] pf_insn, // // o_illegal will be true if this instruction was the result of // a bus error (This is also part of the CPU interface)",
            "input wire pf_illegal, // output wire [BW-1:0] fc_pc, output wire fc_illegal, output wire [INSN_WIDTH-1:0] fc_insn, output reg [BW-1:0] f_address // }}} ); // Declarations // {{{ `ifdef ZIPCPU `define CPU_ASSUME assume `define CPU_ASSERT assert `else `define CPU_ASSUME assert `define CPU_ASSERT assume `endif",
            "localparam INSN_LSB = $clog2(INSN_WIDTH/8);",
            "reg [BW-1:0] f_next_address;",
            "reg f_past_valid;",
            "reg need_new_pc, past_stalled, past_illegal;",
            "reg [INSN_WIDTH-1:0] past_insn; // Verilator lint_off UNDRIVEN (* anyconst *)",
            "reg [BW-1:0] r_fc_pc; (* anyconst *)",
            "reg r_fc_illegal; (* anyconst *)",
            "reg [INSN_WIDTH-1:0] r_fc_insn; // Verilator lint_on UNDRIVEN",
            "assign fc_pc = r_fc_pc;",
            "assign fc_illegal = r_fc_illegal;",
            "assign fc_insn = r_fc_insn; // }}} // f_address, f_next_address -- address tracking // {{{",
            "always @(posedge i_clk) if (cpu_new_pc) f_address <= cpu_pc; else if (pf_valid && cpu_ready) begin f_address[BW-1:INSN_LSB] <= f_address[BW-1:INSN_LSB] + 1'b1; if (INSN_LSB > 0) f_address[((INSN_LSB>0) ? INSN_LSB:1)-1:0] <= 0; end",
            "always @(*) begin f_next_address = f_address + (1<<INSN_LSB); if (INSN_LSB > 0) f_next_address[((INSN_LSB>0) ? INSN_LSB : 1)-1:0] <= 0; end // }}} // f_past_valid // {{{ // Keep track of a flag telling us whether or not $past() // will return valid results",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; // }}} //////////////////////////////////////////////////////////////////////// // // Reset // {{{ //////////////////////////////////////////////////////////////////////// // // // Assume we start from a reset condition",
            "initial `CPU_ASSERT(i_reset);",
            "always @(*) if (!f_past_valid) `CPU_ASSERT(i_reset); // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about our return responses to the CPU // {{{ //////////////////////////////////////////////////////////////////////// // // // pf_pc, and cpu_pc alignment // {{{ generate if (OPT_ALIGNED && INSN_LSB > 0) begin : F_CHECK_ALIGNMENT",
            "always @(*) if (cpu_new_pc) `CPU_ASSERT(cpu_pc[INSN_LSB-1:0] == 0);",
            "always @(*) if (pf_valid) `CPU_ASSUME(pf_pc[INSN_LSB-1:0] == 0); end endgenerate // }}} // Some things to know from the CPU ... there will",
            "always be a // i_new_pc request following any reset or clear cache request",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset)) begin `CPU_ASSUME(!pf_valid); `CPU_ASSUME(!pf_illegal); end",
            "initial need_new_pc = 1'b1;",
            "always @(posedge i_clk) need_new_pc <= (i_reset || cpu_clear_cache);",
            "initial past_stalled = 1'b1;",
            "always @(posedge i_clk) past_stalled <= pf_valid && !cpu_ready && !cpu_new_pc;",
            "initial past_illegal = 1'b0;",
            "always @(posedge i_clk) past_illegal <= pf_illegal;",
            "always @(posedge i_clk) past_insn <= pf_insn;",
            "always @(*) if (!F_OPT_ASYNC_RESET || !i_reset) begin if (need_new_pc) begin `CPU_ASSERT(i_reset || cpu_clear_cache || cpu_new_pc); `CPU_ASSUME(!pf_valid); `CPU_ASSUME(!pf_illegal); end else if (past_stalled) begin `CPU_ASSUME(past_illegal == pf_illegal); `CPU_ASSUME(pf_illegal || (past_insn == pf_insn)); if (!cpu_new_pc) `CPU_ASSERT(cpu_pc[BW-1:INSN_LSB]== f_next_address[BW-1:INSN_LSB]); end else if (!cpu_new_pc && !i_reset && !cpu_clear_cache) begin `CPU_ASSERT(cpu_pc[BW-1:INSN_LSB]== f_next_address[BW-1:INSN_LSB]); end end",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset || cpu_clear_cache) || (F_OPT_ASYNC_RESET && i_reset)) begin if (!F_OPT_ASYNC_RESET || !i_reset) begin assert(need_new_pc); `CPU_ASSERT(cpu_new_pc || i_reset || cpu_clear_cache); `CPU_ASSUME(!pf_valid); `CPU_ASSUME(!pf_illegal); end end else if (!$past(cpu_new_pc) && $past(pf_valid && !cpu_ready)) begin // // Once an instruction has been presented, it must hold valid // until accepted assert(!need_new_pc); `CPU_ASSUME(pf_valid); `CPU_ASSUME($stable(pf_pc)); `CPU_ASSUME(pf_illegal || $stable(pf_insn)); `CPU_ASSUME($stable(pf_illegal)); end else if ($past(pf_illegal && !cpu_new_pc)) // Once illegal is raised, it stays raised until a new PC, // reset, or cache clear `CPU_ASSUME(pf_illegal);",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset || cpu_clear_cache)) begin `CPU_ASSUME(!pf_valid); end else if ((f_past_valid)&&(!$past(pf_illegal && !cpu_new_pc))&&(pf_illegal)) // pf_illegal can only rise if pf_valid is true `CPU_ASSUME(pf_valid);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_reset || cpu_new_pc || cpu_clear_cache))) begin `CPU_ASSUME(!pf_illegal || pf_valid); end else if (f_past_valid && $past(pf_illegal)) `CPU_ASSUME(pf_illegal);",
            "always @(*) if (pf_valid && !pf_illegal) `CPU_ASSUME(f_address == pf_pc);",
            "always @(posedge i_clk) if (f_past_valid && !i_reset && !cpu_new_pc && !need_new_pc) `CPU_ASSERT(f_next_address == cpu_pc); // }}} //////////////////////////////////////////////////////////////////////// // // Contract checking // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) assume(fc_pc[1:0] == 2'b00); generate if (OPT_CONTRACT) begin : CHECK_CONTRACT",
            "always @(*) if (pf_valid && fc_pc[BW-1:INSN_LSB] == f_address[BW-1:INSN_LSB]) begin if (fc_illegal) begin `CPU_ASSUME(pf_illegal); end else if (!pf_illegal) `CPU_ASSUME(fc_insn == pf_insn); end",
            "always @(posedge i_clk) if (f_past_valid && !$past(pf_illegal) && pf_valid && fc_pc[BW-1:INSN_LSB] == f_address[BW-1:INSN_LSB]) `CPU_ASSUME(fc_illegal == pf_illegal); end endgenerate // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "fdebug.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/formal/fdebug.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: fdebug.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Formal properties describing the debugging interface of the // ZipCPU core. This is the interface implemented by the // ZipSystem, ZipBones, or any other wrapper to the ZipCPU core. It // controls reset, the halt bit, external stepping control, external // cache clearing, and any",
            "reg ister override bits. // // Ports: // i_clk // i_reset Positive, synchronous, reset everything // i_cpu_reset The CPU is being reset and only the CPU--not the bus. // i_halt A request is being made to halt the CPU // i_halted Signal from the CPU that it has come to a complete halt // i_clear_cache Request to clear the CPU's cache. Can only be issued // with i_halt true, must hold true once set until // i_halted. // i_dbg_we A request to write to a CPU",
            "reg ister. i_halt must // also be true. The request must remain valid until // !i_dbg_stall is also true. // i_dbg_",
            "reg The",
            "reg ister to be written. Registers 0-15 are in the // supervisor set, 16-31 in the user set. Registers // 15 and 31 are program counters, 14 and 30 are flags, // 13 and 29 are (by convention) stack pointers. // i_dbg_data The data to be written to i_dbg_",
            "reg when i_dbg_we is // set. Note that there's no byte enables, strobes, or // any other mechanism for less than 32-bit writes. All // writes are 32-bits. // i_dbg_stall The CPU is not able to handle a write request at this // time. // i_dbg_break The CPU has suffered from a break condition and cannot // continue operating. // i_dbg_cc CPU conditions: // i_bus_err: The supervisor has suffered from a bus error // gie: CPU is in user mode // sleep: CPU is asleep (if in user mode), or halted // if in supervisor mode (gie is clear) // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2020-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module fdebug #( // {{{ // Some FPGA's have no distributed RAM, and so require an extra // clock cycle to access CPU",
            "reg ister data. In such cases, CPU // reads require an extra clock cycle: // 1. Address valid, 2. (wait state), 3. Data available // Set OPT_DISTRIBUTED_RAM to 1'b0 if such a wait state is // required.",
            "parameter [0:0] OPT_DISTRIBUTED_RAM = 1'b1, parameter [0:0] OPT_START_HALTED = 1'b1 // }}} ) ( // {{{",
            "input wire i_clk, input wire i_reset, input wire i_cpu_reset, input wire i_halt, input wire i_halted, input wire i_clear_cache, // input wire i_dbg_we, input wire [4:0] i_dbg_",
            "reg , input wire [31:0] i_dbg_data, // input wire i_dbg_stall, input wire i_dbg_break, input wire [2:0] i_dbg_cc // }}} ); `ifdef ZIPCPU `define CPU_ASSUME assume `define CPU_ASSERT assert `else `define CPU_ASSUME assert `define CPU_ASSERT assume `endif",
            "reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1;",
            "always @(*) if (!f_past_valid) assume(i_reset);",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset && !i_cpu_reset)) `CPU_ASSUME(i_cpu_reset); // Stall checking // {{{",
            "always @(posedge i_clk) if (f_past_valid && $past(!i_reset && !i_cpu_reset && i_dbg_we && i_dbg_stall)) begin `CPU_ASSUME(i_dbg_we); `CPU_ASSUME($stable(i_dbg_",
            "reg )); `CPU_ASSUME($stable(i_dbg_data)); end",
            "always @(posedge i_clk) if (f_past_valid && $past(!i_reset && !i_cpu_reset && i_clear_cache && i_dbg_stall)) `CPU_ASSUME(i_clear_cache); // }}} // Writes will only ever be attempted if/when the CPU is halted // {{{",
            "always @(*) if (i_dbg_we) `CPU_ASSUME(i_halt);",
            "always @(posedge i_clk) if (f_past_valid && (!i_reset && !i_cpu_reset) && $past(!i_reset && !i_cpu_reset) && $past(i_dbg_we)) `CPU_ASSUME(i_halt); generate if (!OPT_DISTRIBUTED_RAM) begin",
            "always @(posedge i_clk) if (f_past_valid && $past(f_past_valid) && $past(i_dbg_we,2)) `CPU_ASSUME(i_halt); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Clear cache checking // {{{ //////////////////////////////////////////////////////////////////////// // // // The clear cache signal will only ever be applied if/when the // CPU is halted // {{{",
            "always @(*) if (!i_halt && !i_reset && !i_cpu_reset) `CPU_ASSUME(!i_clear_cache);",
            "always @(posedge i_clk) if (f_past_valid && $past(!i_reset && !i_cpu_reset && i_clear_cache)) `CPU_ASSUME(i_halt); // }}} // }}} // Writes to the program counter will",
            "always be aligned // always @(posedge i_clk) // if (i_dbg_we && i_dbg_",
            "reg [3:0] == 4'hf) // `CPU_ASSUME(i_dbg_data[1:0] == 2'b00); // The CPU will",
            "always come to a halt on a break",
            "always @(posedge i_clk) if (f_past_valid && $past(!i_reset && !i_cpu_reset && i_dbg_break)) `CPU_ASSUME(i_halt || i_reset || i_cpu_reset); //////////////////////////////////////////////////////////////////////// // // Complete halt assertions // {{{ //////////////////////////////////////////////////////////////////////// // // If the CPU isn't halted, stall will be asserted // {{{",
            "always @(*) if (!i_halted) `CPU_ASSERT(i_dbg_stall); // }}} // A halted CPU won't restart without being released // {{{",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset)) begin `CPU_ASSERT(i_halted == OPT_START_HALTED); end else if (f_past_valid && $past(i_halt && i_halted)) `CPU_ASSERT(i_halted); // }}} // Once requested, the halt request will remain active until the CPU // comes to a complete halt // {{{",
            "always @(posedge i_clk) if (f_past_valid && $past(!i_reset && !i_cpu_reset && i_halt && !i_halted)) `CPU_ASSUME(i_halt); // }}} // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "abs_mpy.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/formal/abs_mpy.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: abs_mpy.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This code has been modified from the mpyop.v file so as to // abstract the multiply that formal methods struggle so hard to // deal with. It also simplifies the interface so that (if enabled) // the multiply will return in 1-6 clocks, rather than the specified // number for the given architecture. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module abs_mpy #( // {{{",
            "parameter OPT_MPY = 1, parameter MAXDELAY = 3, // Verilator lint_off UNUSED",
            "parameter [0:0] OPT_LOWPOWER = 1'b0 // Verilator lint_on UNUSED // }}} ) ( // {{{ // The following",
            "parameter selects which multiply algorithm we // use. Timing performance is strictly dependent upon it.",
            "input wire i_clk, i_reset, i_stb, input wire [1:0] i_op, // 2'b00=MPY, 2'b10=MPYUHI, 2'b11=MPYSHI",
            "input wire [31:0] i_a, i_b, output reg o_valid, output wire o_busy, // The multiply is busy if true",
            "output wire [63:0] o_result, output reg o_hi // Rtrn high half of mpy results // }}} ); `define ASSERT assert // i_stb instead of this_is_a_multiply_op // o_result // o_busy // o_done generate if (OPT_MPY == 0) begin // No multiply support. // {{{",
            "assign o_result = 64'h00;",
            "assign o_busy = 1'b0;",
            "always @(*) o_valid = i_stb;",
            "always @(*) o_hi = 1'b0; // Not needed // }}} end else begin : F_MPY // Our single clock option (no extra clocks) // {{{ // Verilator lint_off UNDRIVEN (* anyseq *)",
            "reg [2:0] next_delay_to_valid; (* anyseq *)",
            "reg [63:0] any_result; // Verilator lint_on UNDRIVEN",
            "assign o_result = any_result;",
            "reg [2:0] delay_to_valid;",
            "reg r_busy;",
            "always @(*) assume((MAXDELAY == 0) ||(next_delay_to_valid < MAXDELAY)); // always @(*) // if (OPT_MPY == 1) // assume(next_delay_to_valid == 0);",
            "always @(*) if (OPT_MPY>0) assume(next_delay_to_valid == OPT_MPY-1);",
            "initial delay_to_valid = 3'h0;",
            "always @(posedge i_clk) if (i_reset) delay_to_valid <= 0; else if ((i_stb)&&(next_delay_to_valid != 0)) delay_to_valid <= next_delay_to_valid; else if (delay_to_valid > 0) delay_to_valid <= delay_to_valid - 1'b1;",
            "initial r_busy = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_busy <= 1'b0; else if (i_stb) r_busy <= (next_delay_to_valid != 0); else if (r_busy) r_busy <= (delay_to_valid != 3'h1);",
            "initial o_valid = 0;",
            "always @(posedge i_clk) if (i_reset) o_valid <= 1'b0; else if ((i_stb)&&(next_delay_to_valid == 0)) o_valid <= 1'b1; else o_valid <= (o_busy)&&(delay_to_valid == 3'h1);",
            "always @(posedge i_clk) if (i_stb) o_hi <= i_op[1];",
            "assign o_busy = r_busy; // }}} end endgenerate // All possible multiply results have been determined // Keep Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_op, i_a, i_b }; // Verilator lint_on UNUSED // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "abs_div.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/formal/abs_div.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: abs_div.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: The original divide",
            "module provides an Integer divide // capability to the Zip CPU. This",
            "module is an abstract // divide",
            "module . It *might* produce a valid integer divide, either signed // or unsigned, result. It might instead do somethin else. It is designed // to be easier for the formal tools to work with. // // Steps: // i_reset The DIVide unit starts in idle. It can also be placed into an // idle by asserting the reset",
            "input . // // i_wr When i_reset is asserted, a divide begins. On the next clock: // // o_busy is set high so everyone else knows we are at work and they can // wait for us to complete. // // pre_sign is set to true if we need to do a signed divide. In this // case, we take a clock cycle to turn the divide into an unsigned // divide. // // o_quotient, a place to store our result, is",
            "initial ized to all zeros. // // r_dividend is set to the numerator // // r_divisor is set to 2^31 * the denominator (shift left by 31, or add // 31 zeros to the right of the number. // // pre_sign When true (clock cycle after i_wr), a clock cycle is used // to take the absolute value of the various arguments (r_dividend // and r_divisor), and to calculate what sign the",
            "output result // should be. // // // At this point, the divide is has started. The divide works by walking // through every shift of the // // DIVIDEND over the // DIVISOR // // If the DIVISOR is bigger than the dividend, the divisor is shifted // right, and nothing is done to the",
            "output quotient. // // DIVIDEND // DIVISOR // // This repeats, until DIVISOR is less than or equal to the divident, as in // // DIVIDEND // DIVISOR // // At this point, if the DIVISOR is less than the dividend, the // divisor is subtracted from the dividend, and the DIVISOR is again // shifted to the right. Further, a '1' bit gets set in the",
            "output // quotient. // // Once we've done this for 32 clocks, we've accumulated our answer into // the",
            "output quotient, and we can proceed to the next step. If the // result will be signed, the next step negates the quotient, otherwise // it returns the result. // // On the clock when we are done, o_busy is set to false, and o_valid set // to true. (It is a violation of the ZipCPU internal protocol for both // busy and valid to ever be true on the same clock. It is also a // violation for busy to be false with valid true thereafter.) // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module abs_div #( // {{{",
            "parameter BW=32, LGBW = 5, // Verilator lint_off UNUSED",
            "parameter [0:0] OPT_LOWPOWER = 1'b0, // Verilator lint_on UNUSED",
            "parameter [4:0] MAXDELAY = 3 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Input",
            "parameter s",
            "input wire i_wr, i_signed, input wire [(BW-1):0] i_numerator, i_denominator, // Output",
            "parameter s",
            "output wire o_busy, output reg o_valid, o_err, output reg [(BW-1):0] o_quotient, output wire [3:0] o_flags // }}} ); // Declarations // {{{ // Verilator lint_off UNDRIVEN (* anyseq *)",
            "reg any_err; (* anyseq *)",
            "reg [(BW-1):0] any_quotient; (* anyseq *)",
            "reg [5:0] wait_time; (* anyseq *)",
            "reg [3:0] any_flags; // Verilator lint_on UNDRIVEN",
            "reg [5:0] r_busy_counter; // }}}",
            "always @(*) o_err = any_err;",
            "always @(*) o_quotient = any_quotient;",
            "always @(*) assume(wait_time > 5'h1);",
            "always @(*) assume((MAXDELAY == 0)||(wait_time < MAXDELAY)); // r_busy_counter // {{{",
            "initial r_busy_counter = 0;",
            "always @(posedge i_clk) if (i_reset) r_busy_counter <= 0; else if ((i_wr)&&(!o_busy)) r_busy_counter <= wait_time; else if (r_busy_counter > 0) r_busy_counter <= r_busy_counter - 1'b1; // }}}",
            "always @(*) assert((MAXDELAY == 0)||(r_busy_counter < MAXDELAY));",
            "assign o_busy = (r_busy_counter != 0); // o_valid // {{{",
            "initial o_valid = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_valid <= 1'b0; else o_valid <= (r_busy_counter == 1); // }}}",
            "assign o_flags = (o_valid) ? { 1'b0, o_quotient[31], any_flags[1], (o_quotient == 0) } : any_flags; //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "always @(posedge i_clk) if (!f_past_valid) assert((!o_busy)&&(!o_valid)); `define ASSUME assert",
            "initial `ASSUME(i_reset);",
            "always @(*) if (!f_past_valid) `ASSUME(i_reset);",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) `ASSUME(!i_wr);",
            "always @(*) if (o_busy) `ASSUME(!i_wr);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(o_busy))&&(!o_busy)) assume(o_valid);",
            "always @(*) if (o_err) assume(o_valid);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_wr))) assert(o_busy);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_valid))) assume(!o_valid);",
            "always @(*) if ((o_valid)&&(!o_err)) assume(o_flags[3] == ((o_quotient == 0)? 1'b1:1'b0));",
            "always @(*) if ((o_valid)&&(!o_err)) assume(o_flags[1] == o_quotient[BW-1]);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(o_busy))&&(!$past(i_wr))) assume(!o_busy);",
            "always @(posedge i_clk) assume((!o_busy)||(!o_valid)); `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "f_idecode.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/formal/f_idecode.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: f_idecode.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This RTL file is meant to shadow the idecode.v file, but yet // to require no clocks for decoding at all. The purpose is to // help to verify instructions as they go through the ZipCPU pipeline, // and so to know what instructions are supposed to do what when. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2018-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module f_idecode #( // {{{",
            "parameter [0:0] OPT_MPY = 1'b1, parameter [0:0] OPT_SHIFTS = 1'b1, parameter [0:0] OPT_DIVIDE = 1'b1, parameter [0:0] OPT_FPU = 1'b0, parameter [0:0] OPT_CIS = 1'b1, parameter [0:0] OPT_LOCK = 1'b1, parameter [0:0] OPT_OPIPE = 1'b1, parameter [0:0] OPT_SIM = 1'b0, parameter [0:0] OPT_USERMODE = 1'b1, parameter [0:0] OPT_LOWPOWER = 1'b0 // }}} ) ( // {{{",
            "input wire [31:0] i_instruction, input wire i_phase, i_gie, output reg o_illegal, output wire [6:0] o_dcdR, o_dcdA, o_dcdB, output wire [31:0] o_I, output wire [3:0] o_cond, output wire o_wF, output wire [3:0] o_op, output wire o_ALU, o_M, o_DV, o_FP, o_break, output wire o_lock, output wire o_wR, o_rA, o_rB, output wire o_prepipe, output wire o_sim, output wire [22:0] o_sim_immv // }}} ); // Declarations // {{{",
            "localparam [3:0] CPU_SP_REG = 4'hd, CPU_CC_REG = 4'he, CPU_PC_REG = 4'hf;",
            "localparam CISBIT = 31, CISIMMSEL = 23, IMMSEL = 18;",
            "wire [4:0] w_op;",
            "wire w_ldi, w_mov, w_cmptst, w_ldilo, w_ALU, w_brev, w_noop, w_lock, w_sim, w_break, w_special, // w_add, w_mpy;",
            "wire [4:0] w_dcdR, w_dcdB, w_dcdA;",
            "wire w_dcdR_pc, w_dcdR_cc;",
            "wire w_dcdA_pc, w_dcdA_cc;",
            "wire w_dcdB_pc, w_dcdB_cc;",
            "wire [3:0] w_cond;",
            "wire w_wF, w_mem, w_sto, w_div, w_fpu;",
            "wire w_wR, w_rA, w_rB, w_wR_n;",
            "wire illegal_shift;",
            "wire [31:0] iword; // }}} // iword // {{{ generate if (OPT_CIS) begin : SET_IWORD",
            "assign iword = ((!i_instruction[CISBIT])||(i_phase)) ? i_instruction : { 1'b1, i_instruction[14:0], i_instruction[15:0] }; end else begin : CLR_IWORD",
            "assign iword = { 1'b0, i_instruction[30:0] }; end endgenerate // }}}",
            "reg [4:0] w_cis_op; // w_cis_op : Get the opcode // {{{ generate if (OPT_CIS) begin : GEN_CIS_OP",
            "always @(*) if (!iword[CISBIT]) w_cis_op = iword[26:22]; else case(iword[26:24]) 3'h0: w_cis_op = 5'h00; // ADD 3'h1: w_cis_op = 5'h01; // AND 3'h2: w_cis_op = 5'h02; // SUB 3'h3: w_cis_op = 5'h10; // BREV 3'h4: w_cis_op = 5'h12; // LW 3'h5: w_cis_op = 5'h13; // SW 3'h6: w_cis_op = 5'h18; // LDI 3'h7: w_cis_op = 5'h0d; // MOV endcase end else begin : GEN_NOCIS_OP",
            "always @(*) w_cis_op = w_op; end endgenerate // }}} // Decode instructions // {{{",
            "assign w_op= iword[26:22];",
            "assign w_mov = (w_cis_op == 5'h0d);",
            "assign w_ldi = (w_cis_op[4:1] == 4'hc);",
            "assign w_brev = (w_cis_op == 5'h08);",
            "assign w_mpy = (w_cis_op[4:1] == 4'h5)||(w_cis_op[4:0]==5'h0c);",
            "assign w_cmptst = (w_cis_op[4:1] == 4'h8);",
            "assign w_ldilo = (w_cis_op[4:0] == 5'h09);",
            "assign w_ALU = (!w_cis_op[4]) // anything with [4]==0, but ... &&(w_cis_op[3:1] != 3'h7); // not the divide // assign w_add = (w_cis_op[4:0] == 5'h02);",
            "assign w_mem = (w_cis_op[4:3] == 2'b10)&&(w_cis_op[2:1] !=2'b00);",
            "assign w_sto = (w_mem)&&( w_cis_op[0]);",
            "assign w_div = (!iword[CISBIT])&&(w_op[4:1] == 4'h7);",
            "assign w_fpu = (!iword[CISBIT])&&(w_op[4:3] == 2'b11) &&(w_dcdR[3:1] != 3'h7) &&(w_op[2:1] != 2'b00); // If the result",
            "reg ister is either CC or PC, and this would otherwise // be a floating point instruction with floating point opcode of 0, // then this is a NOOP.",
            "assign w_special= (!iword[CISBIT])&&(w_dcdR[3:1]==3'h7) &&(w_op[4:2] == 3'b111);",
            "assign w_break = (w_special)&&(w_op[4:0]==5'h1c);",
            "assign w_lock = (w_special)&&(w_op[4:0]==5'h1d);",
            "assign w_sim = (w_special)&&(w_op[4:0]==5'h1e);",
            "assign w_noop = (w_special)&&(w_op[4:1]==4'hf); // Must include w_sim `ifdef FORMAL",
            "always @(*) assert(!w_special || !w_fpu); `endif // }}} // w_dcdR, w_dcdA // {{{ // What",
            "reg ister will we be placing results into (if at all)? // // Two parts to the result",
            "reg ister: the",
            "reg ister set, given for // moves in iword[18] but only for the supervisor, and the other // four bits encoded in the instruction. // assign w_dcdR = { ((!iword[CISBIT])&&(OPT_USERMODE)&&(w_mov)&&(!i_gie))?iword[IMMSEL]:i_gie, iword[30:27] };",
            "assign w_dcdA = w_dcdR; // on ZipCPU, A is",
            "always result",
            "reg assign w_dcdA_pc = w_dcdR_pc;",
            "assign w_dcdA_cc = w_dcdR_cc;",
            "assign w_dcdR_pc = (w_dcdR == {i_gie, CPU_PC_REG});",
            "assign w_dcdR_cc = (w_dcdR == {i_gie, CPU_CC_REG}); // }}} // dcdB - What",
            "reg ister is used in the opB? // {{{",
            "assign w_dcdB[4] = ((!iword[CISBIT])&&(w_mov)&&(OPT_USERMODE)&&(!i_gie))?iword[13]:i_gie;",
            "assign w_dcdB[3:0]= (iword[CISBIT]) ? (((!iword[CISIMMSEL])&&(iword[26:25]==2'b10)) ? CPU_SP_REG : iword[22:19]) : iword[17:14];",
            "assign w_dcdB_pc = (w_rB)&&(w_dcdB[3:0] == CPU_PC_REG);",
            "assign w_dcdB_cc = (w_rB)&&(w_dcdB[3:0] == CPU_CC_REG); // }}} // w_cond // {{{ // Under what condition will we execute this instruction? Only the // load immediate instruction and the CIS instructions are completely // unconditional. Well ... not quite. The BREAK, LOCK, and SIM/NOOP // instructions are also unconditional. // assign w_cond = ((w_ldi)||(w_special)||(iword[CISBIT])) ? 4'h8 : { (iword[21:19]==3'h0), iword[21:19] }; // }}} // rA - do we need to read",
            "reg ister A? // {{{",
            "assign w_rA = // Floating point reads",
            "reg A (w_fpu) // Divide's read A ||(w_div) // ALU ops read A, // except for MOV's and BREV's which don't ||((w_ALU)&&(!w_brev)&&(!w_mov)) // STO's read A ||(w_sto) // Test/compares ||(w_cmptst); // }}} // rB -- do we read a",
            "reg ister for operand B? // {{{ // Specifically, do we add the",
            "reg isters value to the immediate to // create opB?",
            "assign w_rB = (w_mov) ||((!iword[CISBIT])&&(iword[IMMSEL])&&(!w_ldi)&&(!w_special)) ||(( iword[CISBIT])&&(iword[CISIMMSEL])&&(!w_ldi)) // If using compressed instruction sets, // we *",
            "always * read on memory operands. ||(( iword[CISBIT])&&(w_mem)); // }}} // wR -- will we be writing our result back? // {{{ // wR_n = !wR // All but STO, NOOP/BREAK/LOCK, and CMP/TST write back to w_dcdR",
            "assign w_wR_n = (w_sto) ||(w_special) ||(w_cmptst);",
            "assign w_wR = !w_wR_n; // }}} // // wF -- do we write flags when we are done? // {{{",
            "assign w_wF = (w_cmptst) ||((w_cond[3])&&(w_fpu||w_div ||((w_ALU)&&(!w_mov)&&(!w_ldilo)&&(!w_brev) &&(w_dcdR[3:1] != 3'h7)))); // }}} // w_immsrc - where does the immediate value come from // {{{ // Bottom 13 bits: no LUT's // w_dcd[12: 0] -- no LUTs // w_dcd[ 13] -- 2 LUTs // w_dcd[17:14] -- (5+i0+i1) = 3 LUTs, 1 delay // w_dcd[22:18] : 5 LUTs, 1 delay (assuming high bit is o/w determined)",
            "wire [22:0] w_I, w_fullI; // w_fullI -- extracting the immediate value from the insn word // {{{",
            "assign w_fullI = (w_ldi) ? { iword[22:0] } // LDI // MOVE immediates have one less bit :((w_mov) ?{ {(23-13){iword[12]}}, iword[12:0] } // Normal Op-B immediate ... 18 or 14 bits :((!iword[IMMSEL]) ? { {(23-18){iword[17]}}, iword[17:0] } : { {(23-14){iword[13]}}, iword[13:0] } )); // }}} // w_I and w_Iz: Immediate value decoding // {{{ generate if (OPT_CIS) begin : GEN_CIS_IMMEDIATE",
            "wire [7:0] w_halfbits;",
            "assign w_halfbits = iword[CISIMMSEL:16];",
            "wire [7:0] w_halfI;",
            "assign w_halfI = (iword[26:24]==3'h6) ? w_halfbits[7:0] // 8'b for LDI :(w_halfbits[7])? { {(6){w_halfbits[2]}}, w_halfbits[1:0]} :{ w_halfbits[6], w_halfbits[6:0] };",
            "assign w_I = (iword[CISBIT]) ? {{(23-8){w_halfI[7]}}, w_halfI } : w_fullI; end else begin : GEN_NOCIS_IMMEDIATE",
            "assign w_I = w_fullI; end endgenerate // }}} // }}} // illegal_shift // {{{ generate if (OPT_SHIFTS) begin",
            "assign illegal_shift = 1'b0; end else begin",
            "reg r_illegal_shift;",
            "always @(*) begin r_illegal_shift = 1'b1; if (i_instruction[CISBIT]) r_illegal_shift = 1'b0; else if ((i_instruction[26:22] == 5'h5) ||(i_instruction[26:22] == 5'h6) ||(i_instruction[26:22] == 5'h7)) r_illegal_shift = 1'b0; else if (!i_instruction[18] && i_instruction[17:0] == 18'h1) r_illegal_shift = 1'b0; end",
            "assign illegal_shift = r_illegal_shift; end endgenerate // }}} // o_illegal // {{{",
            "initial o_illegal = 1'b0;",
            "always @(*) begin o_illegal = 1'b0; if (illegal_shift) o_illegal = 1'b1; if ((!OPT_CIS)&&(i_instruction[CISBIT])) o_illegal = 1'b1; if ((!OPT_MPY)&&(w_mpy)) o_illegal = 1'b1; if ((!OPT_DIVIDE)&&(w_div)) o_illegal = 1'b1; else if ((OPT_DIVIDE)&&(w_div)&&(w_dcdR[3:1]==3'h7)) o_illegal = 1'b1; if (!OPT_FPU && w_fpu) o_illegal = 1'b1; if ((!OPT_SIM)&&(w_sim)) // Simulation instructions on real hardware should // always cause an illegal instruction error o_illegal = 1'b1; // There are two (missing) special instructions, after // BREAK, LOCK, SIM, and NOOP. These are special if their // (unused-result)",
            "reg ister is either the PC or CC",
            "reg ister. // // These should cause an illegal instruction error if ((w_dcdR[3:1]==3'h7)&&(w_cis_op[4:1]==4'b1101)) o_illegal = 1'b1; // If the lock function isn't implemented, this should // also cause an illegal instruction error if ((!OPT_LOCK)&&(w_lock)) o_illegal = 1'b1; end // }}} generate if (OPT_OPIPE) begin // o_prepipe is true if a pipelined memory instruction // might follow this one",
            "assign o_prepipe = ((OPT_CIS)||(!i_instruction[CISBIT])) &&(o_M)&&(o_rB) &&(o_dcdB[3:1] != 3'h7) &&(o_dcdR[3:1] != 3'h7) &&((!o_wR)||(o_dcdR != o_dcdB)); end else begin",
            "assign o_prepipe = 1'b0; end endgenerate",
            "assign o_dcdR = { w_dcdR_cc, w_dcdR_pc, w_dcdR};",
            "assign o_dcdA = { w_dcdA_cc, w_dcdA_pc, w_dcdA};",
            "assign o_dcdB = { w_dcdB_cc, w_dcdB_pc, w_dcdB};",
            "assign o_I = { {(32-22){w_I[22]}}, w_I[21:0] };",
            "assign o_cond = w_cond;",
            "assign o_wF = w_wF;",
            "assign o_op = ((w_ldi)||(w_noop))? 4'hd : w_cis_op[3:0];",
            "assign o_ALU = (w_ALU)||(w_ldi)||(w_cmptst)||(w_noop);",
            "assign o_M = w_mem;",
            "assign o_DV = (OPT_DIVIDE)&&(w_div);",
            "assign o_FP = (OPT_FPU)&&(w_fpu);",
            "assign o_break= w_break;",
            "assign o_lock = (OPT_LOCK)&&(w_lock);",
            "assign o_wR = w_wR;",
            "assign o_rA = w_rA;",
            "assign o_rB = w_rB;",
            "assign o_sim = (OPT_SIM) ? ((w_sim)||(w_noop)) : 1'b0;",
            "assign o_sim_immv = (OPT_SIM && (!OPT_LOWPOWER || o_sim)) ? iword[22:0] : 0;",
            "endmodule"
        ]
    },
    {
        "file_name": "fmem.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/formal/fmem.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: fmem.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: To formalize the interface between the CPU and the memory unit. // Memory units that meet these criteria may interact with the // ZipCPU without error. // // Portlist: // i_clk This is a synchronous interface // i_sys_reset A global reset signal. This resets the entire bus. // i_cpu_reset Must be true during a global reset signal. This // resets the CPU. The bus may (or may not) be reset at // the same time. // i_stb The CPU is making a request of the memory unit // i_pipe_stalled The memory unit cannot accept the CPU's request // i_clear_cache The CPU would like to clear any cached memory // i_lock The CPU would like to initiate a locked sequence. // (This will be true from the first read operation, // through one ALU operation, to the strobe associated with // a following write operation.) // i_op The type of memory operation requested // 3'b000: (Illegal/Unused) // 3'b001: (Illegal/Unused) // 3'b010: Load a 32'b word (i.e. a read) // 3'b011: Store a 32'b word (i.e. a write) // 3'b100: Load a 16'b word // 3'b101: Store a 16'b word // 3'b110: Load an 8'b word // 3'b111: Store an 8'b word // i_addr The address to read from or write to. Only valid when // i_stb is also true. // i_data The data to be written during a store operation. // i_a",
            "reg The",
            "reg ister to write the return data back to // i_busy Whether the memory unit is busy doing something or not. // If the memory unit is busy, it may still accept // further reads (during a read cycle), or further writes // (during a write cycle) if i_pipe_stalled is clear. // // Note that just because the memory unit is busy doesn't // mean it's busy doing anything relevant for the CPU. // The CPU may have issued a command, and then been reset. // In that case, the memory unit may still need to complete // the last command. // i_rdbusy Not only is the memory unit busy, but it's busy in a // way where it might write data back to the CPU when it // is done. // i_valid A read has completed, the data for that read is now // available in i_result, to be written to i_w",
            "reg // i_done An operation has completed--either read or write // i_err A bus error has occurred. It may or may not be clear // which instruction caused it. The CPU should begin any // exception handling. // i_w",
            "reg If i_valid is true, this is the",
            "reg ister that the // result needs to be written to. // i_result The result of the last read // // Other ports are useful for synchronizing these formal properties to the // CPU. These include: // // f_outstanding A counter of how many requests are outstanding. This // is incremented on every i_stb, and decremented on every // i_done. // f_pc True if the last read will be written to either the // flags",
            "reg ister or the program counter. // f_gie True if the",
            "reg isters to be read are user mode // reg isters (i.e. the \"Global Interrupt Enable\" for the // ZipCPU is set), requested by the CPU within user mode, // or clear if they are supervisor",
            "reg isters (the Global // Interrupt Enable, or gie bit, is clear). The memory // unit will only do one or the other, never both. // f_read_cycle True if we are in a read cycle (i.e. a load), false // during any store operations. The memory must cease // to be busy before switching directions. // f_axi_write_cycle // True if we are in an AXI exclusive access write cycle. // If this cycle fails, the write will return and require // a write to the program counter. // f_last_",
            "reg The last read",
            "reg ister. Once data is returned to this // reg ister, the current string or reads will be complete. // f_addr_",
            "reg The base address",
            "reg ister. On any string of reads, // the CPU will guarantee that the loads are not stored // into the base address",
            "reg ister unless it is the last // reg ister in any sequence. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2020-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // // License: GPL, v3, as defined and found on www.gnu.org, // http://www.gnu.org/licenses/gpl.html // // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module fmem #( // {{{ // OPT_LOCK // {{{ // If false, forces the i_lock",
            "parameter to be zero and // guarantees no bus locking. Can be set to 1'b1 to test both // with and without bus locking. // }}}",
            "parameter [0:0] OPT_LOCK = 1'b0, // F_LGDEPTH // {{{ // This is the number of bits required to hold our internal // counters. It should have a sufficient number of bits to // hold the OPT_MAXDEPTH. // }}}",
            "parameter F_LGDEPTH = 4, // OPT_MAXDEPTH // {{{ // OPT_MAXDEPTH is the maximum number of requests which may be // outstanding at any given time // }}}",
            "parameter [F_LGDEPTH-1:0] OPT_MAXDEPTH = 1, // OPT_AXI_LOCK // {{{ // AXI locks have special semantics. When a lock takes place // with AXI semantics, there must be a locked read followed by // a locked write. The locked write is treated as a read that // might write back to the program counter of the CPU, and so // rdbusy will be true during the locked write. If you want to // check both the AXI and non-AXI lock semantics, feel free to // set this to one.",
            "parameter OPT_AXI_LOCK = 0 // }}} // }}} ) ( // {{{ // // See above comments for a description of these signals // input wire i_clk, input wire i_sys_reset, input wire i_cpu_reset, // // CPU interface",
            "input wire i_stb, input wire i_pipe_stalled, input wire i_clear_cache, input wire i_lock, input wire [2:0] i_op, input wire [31:0] i_addr, input wire [31:0] i_data, input wire [4:0] i_o",
            "reg , input wire [4:0] i_a",
            "reg , // Base address",
            "reg ister // input wire i_busy, input wire i_rdbusy, input wire i_valid, input wire i_done, input wire i_err, input wire [4:0] i_w",
            "reg , input wire [31:0] i_result, // output reg [F_LGDEPTH-1:0] f_outstanding, output reg f_pc, output reg f_gie, output reg f_read_cycle, output reg f_axi_write_cycle, output reg [4:0] f_last_",
            "reg , output reg [4:0] f_addr_",
            "reg // , output reg f_endpipe, // }}} ); // Declarations and setup // {{{ `ifdef ZIPCPU `define CPU_ASSUME assume `define CPU_ASSERT assert `else `define CPU_ASSUME assert `define CPU_ASSERT assume `endif",
            "reg f_past_valid;",
            "reg past_stb, past_rd, past_busy; // Verilator lint_off UNDRIVEN (* anyconst *)",
            "reg f_check_axi_lock; // Verilator lint_on UNDRIVEN",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1; // }}} //////////////////////////////////////////////////////////////////////// // // Reset checks // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (!f_past_valid) assume(i_sys_reset);",
            "always @(*) if (i_sys_reset) assume(i_cpu_reset);",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_cpu_reset)) begin `CPU_ASSUME(!i_valid); `CPU_ASSUME(!i_done); `CPU_ASSUME(!i_err); end // }}} //////////////////////////////////////////////////////////////////////// // always @(*) if (!f_past_valid || !i_busy) `CPU_ASSUME(!i_rdbusy);",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_sys_reset || i_cpu_reset)) `CPU_ASSUME(!i_rdbusy);",
            "always @(posedge i_clk) if (f_past_valid && !$past(i_busy || i_stb)) `CPU_ASSUME(!i_busy);",
            "always @(*) `CPU_ASSUME(!i_valid || !i_err);",
            "initial f_outstanding = 0;",
            "always @(posedge i_clk) if (i_cpu_reset || i_err) f_outstanding <= 0; else casez({ i_stb, i_done }) 2'b10: f_outstanding <= f_outstanding + 1; 2'b01: f_outstanding <= f_outstanding - 1; default: begin end endcase",
            "always @(*) if (f_outstanding == 0) `CPU_ASSUME(!i_done && !i_err);",
            "always @(*) assert(f_outstanding <= OPT_MAXDEPTH);",
            "always @(*) if (f_outstanding == OPT_MAXDEPTH + ((i_done || i_err) ? 1:0)) `CPU_ASSUME(i_pipe_stalled);",
            "always @(*) if (!i_err && f_outstanding > ((i_done || i_err) ? 1:0)) `CPU_ASSUME(i_busy); // The CPU is not allowed to write to the CC",
            "reg ister while a memory // read operation is ongoing, lest any resulting bus error get returned // to the wrong mode--i.e. user bus error halting the supervisor. What // this means, though, is that the CPU will *never* attempt to clear // any cache while the cache is busy.",
            "always @(*) if (!i_cpu_reset && f_outstanding > 0 && i_rdbusy) `CPU_ASSERT(!i_clear_cache);",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_cpu_reset)) begin `CPU_ASSERT(!i_stb); // If we reset the CPU but not the bus, the bus might still // be busy for a while. Same as if we are using AXI and we // get an error--we still have to flush the rest of what's // on the bus. It's just that ... the CPU doesn't need to wait, // same as if it were writing something to the bus. // `CPU_ASSUME(!i_rdbusy); `CPU_ASSUME(!i_valid); `CPU_ASSUME(!i_err); end else if ($past(i_err)) begin `CPU_ASSERT(!i_stb); end // Stability while stalled // {{{",
            "always @(posedge i_clk) if (f_past_valid && $past(i_stb && i_pipe_stalled && !i_cpu_reset)) begin `CPU_ASSERT(i_stb); `CPU_ASSERT($stable(i_addr)); `CPU_ASSERT($stable(i_data)); `CPU_ASSERT($stable(i_o",
            "reg )); // `CPU_ASSERT($stable(i_lock)); end // }}}",
            "always @(*) if (!OPT_LOCK) `CPU_ASSERT(!i_stb || !i_lock);",
            "always @(posedge i_clk) if (OPT_LOCK && f_past_valid && !$past(i_cpu_reset)) begin // if ($past(!i_lock && (!i_stb || i_busy))) // `CPU_ASSERT(!i_lock); end",
            "always @(*) if (!i_done) begin `CPU_ASSUME(!i_valid); end else if (i_rdbusy) `CPU_ASSUME(i_valid);",
            "always @(posedge i_clk) if (f_past_valid && !$past(i_rdbusy)) begin `CPU_ASSUME(!i_valid); end else if (f_past_valid && $past(i_rdbusy) && f_axi_write_cycle) begin `CPU_ASSUME(f_outstanding == 1); if (i_valid) begin `CPU_ASSUME(i_w",
            "reg [3:0] == 4'hf && i_done); end else `CPU_ASSUME(i_rdbusy || i_done || i_err); end else if (f_past_valid && !i_err && $past(i_rdbusy) && (f_outstanding > (i_valid ? 1:0))) `CPU_ASSUME(i_rdbusy);",
            "initial past_stb = 1'b0;",
            "always @(posedge i_clk) past_stb <= i_stb && !i_cpu_reset && !i_err;",
            "initial past_rd = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || i_err) past_rd <= 1'b0; else if (i_stb && !i_op[0]) past_rd <= 1'b1; else past_rd <= i_rdbusy && (f_outstanding > (i_valid ? 1:0)); // Can only become busy on a CPU reset or a bus request",
            "initial past_busy = 1'b1;",
            "always @(posedge i_clk) if (i_cpu_reset || i_stb) past_busy <= 1'b1; else if (!i_busy) past_busy <= 1'b0;",
            "always @(*) if (!past_busy) `CPU_ASSUME(!i_busy);",
            "always @(*) `CPU_ASSUME(!i_rdbusy || !i_err);",
            "always @(*) if (past_stb) begin `CPU_ASSUME(i_busy || i_valid || i_err); if (i_busy) `CPU_ASSUME(i_err || i_rdbusy == past_rd || f_axi_write_cycle); end else if (!past_rd || !i_busy) `CPU_ASSUME(!i_rdbusy);",
            "always @(posedge i_clk) if (f_past_valid && !$past(i_cpu_reset)) begin // // Will never happen, 'cause i_stb can't be true when i_busy // if ($past(i_stb && i_pipe_stalled) && i_stb) begin `CPU_ASSERT($stable(i_op)); `CPU_ASSERT($stable(i_addr)); `CPU_ASSERT($stable(i_data)); `CPU_ASSERT($stable(i_o",
            "reg )); `CPU_ASSERT($stable(i_lock)); end end",
            "always @(*) if (i_stb) `CPU_ASSERT(i_op[2:1] != 2'b00); // // This is guaranteed by the CPU: No new requests during busy. It // isn't necessarily required by most handshaking interfaces, but the // CPU needs it in order to make certain that it doesn't accidentally // issue instructions. It's part of the CPU pipeline",
            "logic .",
            "always @(*) if (!i_cpu_reset && i_busy && f_outstanding > 0) `CPU_ASSERT(!i_clear_cache);",
            "always @(*) if (i_clear_cache) `CPU_ASSERT(!i_stb);",
            "always @(*) if (i_pipe_stalled) `CPU_ASSERT(!i_stb);",
            "always @(*) if (!i_busy) `CPU_ASSUME(!i_pipe_stalled); // Reads must",
            "always complete before writes, and vice versa",
            "always @(*) if (i_stb && i_busy) `CPU_ASSERT(f_read_cycle == !i_op[0]); // always @(posedge i_clk) // if (f_past_valid && $past(i_busy && !i_pipe_stalled && !i_stb)) // `CPU_ASSERT(!i_stb || i_lock); // // This is also required of the CPU pipeline",
            "logic . Following any // error the pipeline needs to be cleared. That means that, on an // error, you can't have any new requests",
            "always @(*) if (i_err) `CPU_ASSERT(!i_stb);",
            "always @(posedge i_clk) if (f_past_valid && $past(i_cpu_reset || i_err)) `CPU_ASSERT(!i_stb);",
            "always @(*) if (i_rdbusy) `CPU_ASSERT(!i_stb || !i_op[0]);",
            "always @(*) if (i_rdbusy) `CPU_ASSUME(i_busy); //////////////////////////////////////////////////////////////////////// // // f_addr_",
            "reg , f_last_",
            "reg , f_pc properties // {{{ //////////////////////////////////////////////////////////////////////// // // // The last",
            "reg ister // {{{ // For pipeline hazard purposes, it's important to be able to know and // track the last",
            "reg ister that will be returned to the CPU.",
            "always @(posedge i_clk) if (i_stb && !i_pipe_stalled) begin f_last_",
            "reg <= i_o",
            "reg ; if (OPT_LOCK && f_check_axi_lock && i_op[0] && i_lock) f_last_",
            "reg [3:0] <= 4'hf; end",
            "always @(*) if (f_outstanding == 1 && i_valid && !f_axi_write_cycle) `CPU_ASSUME(f_last_",
            "reg == i_w",
            "reg );",
            "always @(*) if (f_axi_write_cycle) begin `CPU_ASSUME(f_last_",
            "reg [3:0] == 4'hf); assert(f_outstanding == 1); end // }}} // // The base address",
            "reg ister // {{{ // In any string of reads, the ZipCPU will only ever use a single // base address. The ZipCPU will *not* read into the base address // reg ister unless that read is the last in the string of reads.",
            "always @(posedge i_clk) if (i_stb) f_addr_",
            "reg <= i_a",
            "reg ;",
            "always @(*) if (i_stb && i_rdbusy) `CPU_ASSERT(i_a",
            "reg == f_addr_",
            "reg );",
            "always @(*) if (i_rdbusy) `CPU_ASSERT(!i_stb || f_last_",
            "reg != i_a",
            "reg );",
            "always @(*) if (i_rdbusy && i_valid) begin if (f_outstanding > 1) `CPU_ASSUME(i_w",
            "reg != f_addr_",
            "reg ); end // }}} // f_pc // {{{ // True if any",
            "reg ister will return a write to either the program // counter or the CC",
            "reg ister. If such a read exists, it must be the // last in a sequence.",
            "initial f_pc = 0;",
            "always @(posedge i_clk) if (i_cpu_reset || i_err) f_pc <= 0; else if (i_stb && !i_op[0] && i_o",
            "reg [3:1] == 3'h7) f_pc <= 1'b1; else if (f_check_axi_lock && i_stb && i_op[0] && i_lock) f_pc <= 1'b1; else if (i_valid && i_w",
            "reg [3:1] == 3'h7) f_pc <= 1'b0; else if (f_axi_write_cycle && i_done) f_pc <= 1'b0; // // Once the CPU issues a request to read into one of the special // reg isters (either CC, or PC), it will not issue another read request // until this request has completed.",
            "always @(*) if (f_pc && f_read_cycle) `CPU_ASSERT(!i_stb);",
            "always @(*) if (f_pc && !f_read_cycle && f_axi_write_cycle && f_outstanding > ((i_done || i_err) ? 1:0)) `CPU_ASSUME(i_pipe_stalled);",
            "always @(*) if (f_last_",
            "reg [3:1] != 3'h7) begin assert(!f_pc || f_axi_write_cycle); end else if (i_rdbusy) assert(f_pc);",
            "always @(*) if (f_pc) begin `CPU_ASSUME(f_read_cycle || f_axi_write_cycle); if (f_axi_write_cycle) begin assert(f_check_axi_lock); `CPU_ASSUME(f_outstanding == 1); end else begin if (f_outstanding > 1 && !i_err) begin `CPU_ASSUME(!i_valid || i_w",
            "reg [3:1] != 3'h7); end else if (f_outstanding == 1 && i_valid) `CPU_ASSUME(i_w",
            "reg [3:1] == 3'h7); `CPU_ASSUME(f_outstanding > 0); end end else if (i_valid) `CPU_ASSUME(!i_valid || i_w",
            "reg [3:1] != 3'h7); // }}} // }}} //////////////////////////////////////////////////////////////////////// // // f_gie properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (i_stb) f_gie <= i_o",
            "reg [4];",
            "always @(*) if (i_stb && f_outstanding > 0) `CPU_ASSERT(f_gie == i_o",
            "reg [4]);",
            "always @(*) if (i_valid) `CPU_ASSUME(f_gie == i_w",
            "reg [4]); // }}} //////////////////////////////////////////////////////////////////////// // // f_axi_write_cycle properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (OPT_AXI_LOCK == 0 || !OPT_LOCK) begin assume(f_check_axi_lock == 1'b0); end else if (OPT_AXI_LOCK == 1) assume(f_check_axi_lock == 1'b1);",
            "initial f_axi_write_cycle = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || i_clear_cache || !f_check_axi_lock) f_axi_write_cycle <= 1'b0; else if (i_stb && i_lock && i_op[0]) f_axi_write_cycle <= 1'b1; else if (i_err || i_valid || !i_rdbusy) f_axi_write_cycle <= 1'b0;",
            "always @(*) if (!f_check_axi_lock) assert(f_axi_write_cycle == 0);",
            "always @(*) if (f_axi_write_cycle) `CPU_ASSUME(i_rdbusy || i_valid || i_err || i_done);",
            "always @(*) if (f_axi_write_cycle) assert(f_pc); // }}} //////////////////////////////////////////////////////////////////////// // // f_read_cycle properties // {{{ //////////////////////////////////////////////////////////////////////// // // initial f_read_cycle = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || i_clear_cache) f_read_cycle <= 1'b0; else if (i_stb) f_read_cycle <= !i_op[0]; else if (!i_busy) f_read_cycle <= 1'b0;",
            "always @(*) if (!f_read_cycle) begin if (!f_axi_write_cycle) begin `CPU_ASSUME(!i_rdbusy); `CPU_ASSUME(!i_valid); end end else if (i_done) begin `CPU_ASSUME(i_valid || i_err); if (!i_err) `CPU_ASSUME((f_outstanding <= (i_valid ? 1:0)) || i_rdbusy); end",
            "always @(*) `CPU_ASSUME(!f_read_cycle || !f_axi_write_cycle); // }}} //////////////////////////////////////////////////////////////////////// // // Address",
            "reg ister checking // {{{ //////////////////////////////////////////////////////////////////////// // // Here's the (to be written) rule: During a string of operations, // there is one address",
            "reg ister. /* always @(posedge i_clk) if (i_reset) f_endpipe <= 1'b1; else if (i_stb) f_endpipe <= i_op[0] || (i_o",
            "reg == i_a",
            "reg );",
            "always @(posedge i_clk) if (i_stb) f_addr_",
            "reg <= i_a",
            "reg ; // // Mid cycle, the CPU can't add a new",
            "reg ister to the end",
            "always @(*) if (f_read_cycle && (i_valid || f_outstanding > 0) && i_stb && !i_op[0]) begin `CPU_ASSERT(!f_endpipe); `CPU_ASSERT(i_o",
            "reg != f_addr_",
            "reg ); end // // Only the last item can write to the address",
            "reg ister, and that only // if f_endpipe is true.",
            "always @(*) if (f_read_cycle && !i_err && i_valid) begin // If we aren't ever writing to the address",
            "reg ister // ... or if we are, the address",
            "reg ister must be the last // reg ister to be returned, then don't allow a write response // to the address",
            "reg ister if (!f_endpipe || f_outstanding > (i_valid ? 1:0)) `CPU_ASSUME(!i_valid || i_w",
            "reg != f_addr_",
            "reg ); end */ // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // reg [3:0] cvr_returns, cvr_errors;",
            "initial cvr_returns = 0;",
            "always @(posedge i_clk) if (i_cpu_reset) cvr_returns <= 0; else if (i_valid && !cvr_returns[3]) cvr_returns <= cvr_returns + 1;",
            "always @(*) cover(cvr_returns > 4);",
            "initial cvr_errors = 0;",
            "always @(posedge i_clk) if (i_cpu_reset) cvr_errors <= 0; else if (i_err && !cvr_errors[3]) cvr_errors <= cvr_errors + 1;",
            "always @(*) cover(cvr_returns > 2); // }}} // Make Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_result }; // Verilator lint_on UNUSED // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipbones.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/mcy/zipcpu/zipbones.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipbones.v // // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: In the spirit of keeping the Zip CPU small, this implements a // Zip System with no peripherals: Any peripherals you wish will // need to be implemented off-",
            "module . // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // // Copyright (C) 2015-2019, Gisselquist Technology, LLC // // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // // License: GPL, v3, as defined and found on www.gnu.org, // http://www.gnu.org/licenses/gpl.html // // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // `include \"cpudefs.v\" // `define RESET_BIT 6 `define STEP_BIT 8 `define HALT_BIT 10 `define CLEAR_CACHE_BIT 11 // module zipbones(i_clk, i_reset, // Wishbone master interface from the CPU o_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, o_wb_sel, i_wb_stall, i_wb_ack, i_wb_data, i_wb_err, // Incoming interrupts i_ext_int, // Our one outgoing interrupt o_ext_int, // Wishbone slave interface for debugging purposes i_dbg_cyc, i_dbg_stb, i_dbg_we, i_dbg_addr, i_dbg_data, o_dbg_stall, o_dbg_ack, o_dbg_data, mutsel `ifdef DEBUG_SCOPE , o_cpu_debug `endif );",
            "parameter RESET_ADDRESS=32'h0100000, ADDRESS_WIDTH=30, LGICACHE=8;",
            "parameter [0:0] START_HALTED=0;",
            "parameter EXTERNAL_INTERRUPTS=1, `ifdef OPT_MULTIPLY IMPLEMENT_MPY = `OPT_MULTIPLY; `else IMPLEMENT_MPY = 0; `endif",
            "parameter [0:0] `ifdef OPT_DIVIDE IMPLEMENT_DIVIDE=1, `else IMPLEMENT_DIVIDE=0, `endif `ifdef OPT_IMPLEMENT_FPU IMPLEMENT_FPU=1, `else IMPLEMENT_FPU=0, `endif IMPLEMENT_LOCK=1;",
            "localparam // Derived",
            "parameter s PHYSICAL_ADDRESS_WIDTH=ADDRESS_WIDTH, PAW=ADDRESS_WIDTH, `ifdef OPT_MMU VIRTUAL_ADDRESS_WIDTH=30, `else VIRTUAL_ADDRESS_WIDTH=PAW, `endif LGTLBSZ = 6, VAW=VIRTUAL_ADDRESS_WIDTH;",
            "localparam AW=ADDRESS_WIDTH;",
            "input wire i_clk, i_reset; // Wishbone master",
            "output wire o_wb_cyc, o_wb_stb, o_wb_we;",
            "output wire [(PAW-1):0] o_wb_addr;",
            "output wire [31:0] o_wb_data;",
            "output wire [3:0] o_wb_sel;",
            "input wire i_wb_stall, i_wb_ack;",
            "input wire [31:0] i_wb_data;",
            "input wire i_wb_err; // Incoming interrupts",
            "input wire i_ext_int; // Outgoing interrupt",
            "output wire o_ext_int; // Wishbone slave",
            "input wire i_dbg_cyc, i_dbg_stb, i_dbg_we, i_dbg_addr;",
            "input wire [31:0] i_dbg_data;",
            "output wire o_dbg_ack;",
            "output wire o_dbg_stall;",
            "output wire [31:0] o_dbg_data; // input wire [7:0] mutsel; // `ifdef DEBUG_SCOPE",
            "output wire [31:0] o_cpu_debug; `endif",
            "wire dbg_cyc, dbg_stb, dbg_we, dbg_addr, dbg_stall;",
            "wire [31:0] dbg_idata, dbg_odata;",
            "reg dbg_ack;",
            "assign dbg_cyc = i_dbg_cyc;",
            "assign dbg_stb = i_dbg_stb;",
            "assign dbg_we = i_dbg_we;",
            "assign dbg_addr = i_dbg_addr;",
            "assign dbg_idata = i_dbg_data;",
            "assign o_dbg_ack = dbg_ack;",
            "assign o_dbg_stall = dbg_stall;",
            "assign o_dbg_data = dbg_odata; // // The external debug interface // // We offer only a limited interface here, requiring a pre-",
            "reg ister // write to set the local address. This interface allows access to // the Zip System on a debug basis only, and not to the rest of the // wishbone bus. Further, to access these",
            "reg isters, the control // reg ister must first be accessed to both stop the CPU and to // set the following address in question. Hence all accesses require // two accesses: write the address to the control",
            "reg ister (and halt // the CPU if not halted), then read/write the data from the data // reg ister. // wire cpu_break, dbg_cmd_write;",
            "reg cmd_reset, cmd_halt, cmd_step, cmd_clear_pf_cache;",
            "reg [4:0] cmd_addr;",
            "wire [3:0] cpu_dbg_cc;",
            "assign dbg_cmd_write = (dbg_stb)&&(dbg_we)&&(!dbg_addr); // // Always start us off with an",
            "initial reset // initial cmd_reset = 1'b1;",
            "always @(posedge i_clk) cmd_reset <= ((dbg_cmd_write)&&(dbg_idata[`RESET_BIT])); // initial cmd_halt = START_HALTED;",
            "always @(posedge i_clk) if (i_reset) cmd_halt <= START_HALTED; else if (cmd_reset) cmd_halt <= START_HALTED; else if (dbg_cmd_write) cmd_halt <= ((dbg_idata[`HALT_BIT])&&(!dbg_idata[`STEP_BIT])); else if ((cmd_step)||(cpu_break)) cmd_halt <= 1'b1;",
            "initial cmd_clear_pf_cache = 1'b1;",
            "always @(posedge i_clk) cmd_clear_pf_cache <= (dbg_cmd_write)&&(dbg_idata[`CLEAR_CACHE_BIT]); // initial cmd_step = 1'b0;",
            "always @(posedge i_clk) cmd_step <= (dbg_cmd_write)&&(dbg_idata[`STEP_BIT]); // initial cmd_addr = 5'h0;",
            "always @(posedge i_clk) if (dbg_cmd_write) cmd_addr <= dbg_idata[4:0];",
            "wire cpu_reset;",
            "assign cpu_reset = (cmd_reset);",
            "wire cpu_halt, cpu_dbg_stall;",
            "assign cpu_halt = (cmd_halt);",
            "wire [31:0] cmd_data; // Values: // 0x0003f -> cmd_addr mask // 0x00040 -> reset // 0x00080 -> PIC interrrupt pending // 0x00100 -> cmd_step // 0x00200 -> cmd_stall // 0x00400 -> cmd_halt // 0x00800 -> cmd_clear_pf_cache // 0x01000 -> cc.sleep // 0x02000 -> cc.gie // 0x10000 -> External interrupt line is high",
            "assign cmd_data = { 7'h00, 8'h00, i_ext_int, cpu_dbg_cc, 1'b0, cmd_halt, (!cpu_dbg_stall), 1'b0, i_ext_int, cpu_reset, 1'b0, cmd_addr }; // // The CPU itself // wire cpu_lcl_cyc, cpu_lcl_stb, cpu_dbg_we, cpu_op_stall, cpu_pf_stall, cpu_i_count;",
            "wire [31:0] cpu_dbg_data;",
            "assign cpu_dbg_we = ((dbg_stb)&&(dbg_we)&&(dbg_addr)); zipcpu /* #(.RESET_ADDRESS(RESET_ADDRESS), .ADDRESS_WIDTH(ADDRESS_WIDTH), .LGICACHE(LGICACHE), .WITH_LOCAL_BUS(0)) */ thecpu(.i_clk(i_clk), .i_reset(cpu_reset), .i_interrupt(i_ext_int), .i_halt(cpu_halt), .i_clear_pf_cache(cmd_clear_pf_cache), .i_dbg_",
            "reg (cmd_addr[4:0]), .i_dbg_we(cpu_dbg_we), .i_dbg_data(dbg_idata), .o_dbg_stall(cpu_dbg_stall), .o_dbg_",
            "reg (cpu_dbg_data), .o_dbg_cc(cpu_dbg_cc), .o_break(cpu_break), .o_wb_gbl_cyc(o_wb_cyc), .o_wb_gbl_stb(o_wb_stb), .o_wb_lcl_cyc(cpu_lcl_cyc), .o_wb_lcl_stb(cpu_lcl_stb), .o_wb_we(o_wb_we), .o_wb_addr(o_wb_addr), .o_wb_data(o_wb_data), .o_wb_sel(o_wb_sel), .i_wb_stall(i_wb_stall), .i_wb_ack(i_wb_ack), .i_wb_data(i_wb_data), .i_wb_err((i_wb_err)||(cpu_lcl_cyc)), .o_op_stall(cpu_op_stall), .o_pf_stall(cpu_pf_stall), .o_i_count(cpu_i_count), .mutsel(mutsel) `ifdef DEBUG_SCOPE , o_cpu_debug `endif ); // Return debug response values",
            "assign dbg_odata = (!dbg_addr)?cmd_data :cpu_dbg_data;",
            "initial dbg_ack = 1'b0;",
            "always @(posedge i_clk) dbg_ack <= (dbg_stb)&&(!o_dbg_stall);",
            "assign dbg_stall= (cpu_dbg_stall)&&(dbg_addr);",
            "assign o_ext_int = (cmd_halt) && (!i_wb_stall); // Make Verilator happy // verilator lint_off UNUSED",
            "wire [4:0] unused;",
            "assign unused = { dbg_cyc, cpu_lcl_stb, cpu_op_stall, cpu_pf_stall, cpu_i_count }; // verilator lint_on UNUSED",
            "endmodule"
        ]
    },
    {
        "file_name": "zipmmu_tb.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/rtl/zipmmu_tb.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipmmu_tb.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This is a test-bench wrapper for the MMU. It's used to // test whether or not the MMU works independent of the ZipCPU // itself. The rest of the test bench is a C++ Verilator-enabled program. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // // }}}",
            "module zipmmu_tb #( // {{{",
            "parameter CPU_ADDRESS_WIDTH=30, MEMORY_ADDRESS_WIDTH=15, localparam AW= CPU_ADDRESS_WIDTH, MAW= MEMORY_ADDRESS_WIDTH, LGTBL = 6, LGPGSZB=12 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // input wire i_ctrl_cyc_stb, // input wire i_wbm_cyc, i_wbm_stb, // input wire i_wb_we, input wire i_exe, input wire [(32-3):0] i_wb_addr, input wire [(32-1):0] i_wb_data, input wire [(32/8-1):0] i_wb_sel, input wire i_gie, // // Here's where we return information on either our // slave/control bus, or the memory bus we are controlled // from. Note that we share these",
            "wire s ...",
            "output wire o_rtn_stall, o_rtn_ack, o_rtn_err, o_rtn_miss, output wire [(32-1):0] o_rtn_data `ifdef VZIPMMU_TB , output wire r_valid, wr_vtable, wr_ptable, wr_control, z_context, output wire [15:0] r_context_word, output wire r_pending, r_we, output wire [29:0] r_addr, output wire [31:0] r_data, output wire mem_cyc, mem_stb, mem_we, output wire [31:0] mem_odata, output wire [(CPU_ADDRESS_WIDTH-1):0] mem_addr, output reg mem_err, output wire kernel_context, output wire [5:0] s_tlb_addr, output wire s_pending, output wire s_tlb_hit, s_tlb_miss, ro_flag, simple_miss, ro_miss, exe_miss, table_err, output wire tlb_valid, output wire [19:0] tlb_pdata, output wire [19:0] tlb_vdata, output wire [15:0] tlb_cdata `endif // }}} ); `ifndef VZIPMMU_TB",
            "wire mem_cyc, mem_stb, mem_we;",
            "wire [(CPU_ADDRESS_WIDTH-1):0] mem_addr;",
            "reg mem_err;",
            "wire [31:0] mem_odata; `endif",
            "wire mem_ack, mem_stall;",
            "wire [31:0] mem_idata;",
            "wire [(32/8-1):0] mem_sel;",
            "wire mmus_ack, mmus_stall;",
            "wire [31:0] mmus_data;",
            "wire rtn_ack, rtn_stall;",
            "wire [31:0] rtn_data;",
            "wire ign_stb, ign_we, ign_cache;",
            "wire [(32-LGPGSZB-1):0] ign_p;",
            "wire [(32-LGPGSZB-1):0] ign_v; // // mut = Module Under Test // zipmmu #( .ADDRESS_WIDTH(CPU_ADDRESS_WIDTH), .LGTBL(LGTBL),.PLGPGSZB(LGPGSZB) ) mut ( // {{{ i_clk, i_reset, // Slave access i_ctrl_cyc_stb, i_wb_we, i_wb_addr[(LGTBL+1):0], i_wb_data, mmus_ack, mmus_stall, mmus_data, i_wbm_cyc, i_wbm_stb, i_wb_we, i_exe, i_wb_addr, i_wb_data, i_wb_sel, i_gie, mem_cyc, mem_stb, mem_we, mem_addr, mem_idata, mem_sel, mem_stall, (mem_ack)&&(!mem_err), mem_err, mem_odata, rtn_stall, rtn_ack, o_rtn_err, o_rtn_miss, rtn_data, ign_stb, ign_we, ign_p, ign_v, ign_cache // }}} ); memdev #(MAW+2) ram(i_clk, mem_cyc, mem_stb, mem_we, mem_addr[(MAW-1):0], mem_idata, mem_sel, mem_ack, mem_stall, mem_odata);",
            "always @(posedge i_clk) if (i_reset) mem_err <= 1'b0; else if (!mem_cyc) mem_err <= 1'b0; else mem_err <= (mem_err)||((mem_stb)&&(mem_addr[(AW-1):MAW] != {{(AW-MAW-1){1'b0}}, 1'b1}));",
            "assign o_rtn_stall = (i_wbm_cyc)&&(rtn_stall);",
            "assign o_rtn_ack = (i_wbm_cyc)?(rtn_ack) :mmus_ack;",
            "assign o_rtn_data = (i_wbm_cyc)?(rtn_data):mmus_data; `ifdef VZIPMMU_TB",
            "reg [5:0] last_index, r_last_index;",
            "wire [63:0] pre_valid, shifted_valid;",
            "assign r_we = mut.r_we;",
            "assign r_valid = mut.r_valid;",
            "assign wr_vtable = mut.wr_vtable;",
            "assign wr_ptable = mut.wr_ptable;",
            "assign wr_control = mut.wr_control;",
            "assign z_context = mut.z_context ;",
            "assign r_context_word = mut.r_context_word;",
            "assign r_pending = mut.r_pending;",
            "assign r_we = mut.r_we;",
            "assign r_addr = mut.r_addr;",
            "assign r_data = mut.r_data;",
            "assign kernel_context = mut.kernel_context;",
            "assign s_tlb_addr = mut.s_tlb_addr;",
            "assign s_pending = mut.s_pending;",
            "assign s_tlb_hit = mut.s_tlb_hit;",
            "assign s_tlb_miss = mut.s_tlb_miss;",
            "assign ro_flag = mut.ro_flag;",
            "assign simple_miss = mut.simple_miss;",
            "assign ro_miss = mut.ro_miss;",
            "assign exe_miss = mut.exe_miss;",
            "assign table_err = mut.table_err;",
            "assign pre_valid = mut.tlb_valid;",
            "assign shifted_valid = pre_valid >> last_index;",
            "assign tlb_valid = shifted_valid[0];",
            "assign tlb_pdata = mut.tlb_pdata[last_index];",
            "assign tlb_vdata = mut.tlb_vdata[last_index];",
            "assign tlb_cdata = mut.tlb_cdata[last_index];",
            "always @(*) if (i_ctrl_cyc_stb && i_wb_we && i_wb_addr[7]) last_index = i_wb_addr[6:1]; else last_index = r_last_index;",
            "always @(posedge i_clk) if (i_ctrl_cyc_stb && i_wb_we && i_wb_addr[7]) r_last_index <= i_wb_addr[6:1]; // Make Verilator happy // verilator lint_off UNUSED",
            "wire unused_vbench;",
            "assign unused_vbench = &{ 1'b0, shifted_valid[63:1] }; // verilator lint_on UNUSED `endif // Make Verilator happy // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, ign_stb, ign_we, ign_p, ign_v, ign_cache, mmus_stall }; // verilator lint_on UNUSED",
            "endmodule"
        ]
    },
    {
        "file_name": "memdev.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/rtl/memdev.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: bench/rtl/memdev.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This file is really simple: it creates an on-chip memory, // accessible via the wishbone bus, that can be used in this // project. The memory has single cycle pipeline access, although the // memory pipeline here still costs a cycle and there may be other cycles // lost between the ZipCPU (or whatever is the master of the bus) and this, // thus costing more cycles in access. Either way, operations can be // pipelined for single cycle access on subsequent transactions. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module memdev #( // {{{",
            "parameter LGMEMSZ=15, DW=32, EXTRACLOCK= 1, parameter HEXFILE=\"\", parameter [0:0] OPT_ROM = 1'b0, localparam AW = LGMEMSZ - $clog2(DW/8) // }}} ) ( // {{{",
            "input wire i_clk, i_reset, input wire i_wb_cyc, i_wb_stb, i_wb_we, input wire [(AW-1):0] i_wb_addr, input wire [(DW-1):0] i_wb_data, input wire [(DW/8-1):0] i_wb_sel, output wire o_wb_stall, output reg o_wb_ack, output reg [(DW-1):0] o_wb_data // }}} ); // Local declarations // {{{",
            "wire w_wstb, w_stb;",
            "wire [(DW-1):0] w_data;",
            "wire [(AW-1):0] w_addr;",
            "wire [(DW/8-1):0] w_sel;",
            "reg [(DW-1):0] mem [0:((1<<AW)-1)]; // }}} // Pre-load the memory // {{{ generate if (HEXFILE != 0) begin : PRELOAD_MEMORY",
            "initial $readmemh(HEXFILE, mem); end endgenerate // }}} // Delay request if necessary // {{{ generate if (EXTRACLOCK == 0) begin : NO_EXTRA_CLOCK // {{{",
            "assign w_wstb = (i_wb_stb)&&(i_wb_we);",
            "assign w_stb = i_wb_stb;",
            "assign w_addr = i_wb_addr;",
            "assign w_data = i_wb_data;",
            "assign w_sel = i_wb_sel; // }}} end else begin : EXTRA_MEM_CLOCK_CYCLE // {{{",
            "reg last_wstb, last_stb;",
            "reg [(AW-1):0] last_addr;",
            "reg [(DW-1):0] last_data;",
            "reg [(DW/8-1):0] last_sel;",
            "initial last_wstb = 0;",
            "always @(posedge i_clk) if (i_reset) last_wstb <= 0; else last_wstb <= (i_wb_stb)&&(i_wb_we);",
            "initial last_stb = 1'b0;",
            "always @(posedge i_clk) if (i_reset) last_stb <= 1'b0; else last_stb <= (i_wb_stb);",
            "always @(posedge i_clk) last_data <= i_wb_data;",
            "always @(posedge i_clk) last_addr <= i_wb_addr;",
            "always @(posedge i_clk) last_sel <= i_wb_sel;",
            "assign w_wstb = last_wstb;",
            "assign w_stb = last_stb;",
            "assign w_addr = last_addr;",
            "assign w_data = last_data;",
            "assign w_sel = last_sel; // }}} end endgenerate // }}} // Read from memory // {{{",
            "always @(posedge i_clk) o_wb_data <= mem[w_addr]; // }}} // Write to memory (if not a ROM) // {{{ generate if (!OPT_ROM) begin : WRITE_TO_MEMORY // {{{ integer ik;",
            "always @(posedge i_clk) if (w_wstb) begin for(ik=0; ik<DW/8; ik=ik+1) if (w_sel[ik]) mem[w_addr][ik*8 +: 8] <= w_data[ik*8 +: 8]; end `ifdef VERILATOR end else begin : VERILATOR_ROM // Make Verilator happy // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire rom_unused;",
            "assign rom_unused = &{ 1'b0, w_wstb, w_data, w_sel }; // Verilator lint_on UNUSED // Verilator coverage_on `endif // }}} end endgenerate // }}} // o_wb_ack // {{{",
            "initial o_wb_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_wb_ack <= 1'b0; else o_wb_ack <= (w_stb)&&(i_wb_cyc); // }}}",
            "assign o_wb_stall = 1'b0; // Make verilator happy // {{{ // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = { 1'b0 }; // verilator lint_on UNUSED // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "localparam F_LGDEPTH = 2;",
            "reg f_past_valid;",
            "wire [F_LGDEPTH-1:0] f_nreqs, f_nacks, f_outstanding;",
            "wire [(AW-1):0] f_addr;",
            "reg [31:0] f_data;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "always @(*) if (!f_past_valid) assume(i_reset); fwb_slave #( .AW(AW), .DW(DW), .F_MAX_STALL(1), .F_MAX_ACK_DELAY(2), .F_OPT_DISCONTINUOUS(1), .F_LGDEPTH(F_LGDEPTH) ) fwb(i_clk, i_reset, i_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel, o_wb_ack, o_wb_stall, o_wb_data, 1'b0, f_nreqs, f_nacks, f_outstanding); generate if (EXTRACLOCK) begin",
            "always @(posedge i_clk) if ((f_past_valid)&&(!i_reset)&&(i_wb_cyc)&&($past(i_wb_cyc))) assert((f_outstanding == 0) == ((!$past(w_stb))&&(!$past(i_wb_stb))));",
            "always @(posedge i_clk) if ((f_past_valid)&&(!i_reset)&&(i_wb_cyc)) assert((f_outstanding == 1) == ( (($past(w_stb))&&($past(i_wb_cyc))) ^($past(i_wb_stb))));",
            "always @(posedge i_clk) if ((f_past_valid)&&(!i_reset)&&(i_wb_cyc)) assert((f_outstanding == 2'h2) == (($past(w_stb))&&($past(i_wb_cyc)) &&($past(i_wb_stb))));",
            "always @(posedge i_clk) assert(f_outstanding <= 2); end else begin",
            "always @(posedge i_clk) if (f_outstanding > 0) assert(o_wb_ack);",
            "always @(posedge i_clk) assert(f_outstanding <= 1);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!i_reset)&&(i_wb_cyc)&&($past(i_wb_stb))) assert(f_outstanding == 1); end endgenerate",
            "always @(*) assert(!o_wb_stall);",
            "wire [(AW-1):0] f_addr;",
            "reg [31:0] f_data;",
            "assign f_addr = $anyconst;",
            "initial assume(mem[f_addr] == f_data); generate if (!OPT_ROM) begin : F_MATCH_WRITES integer ik;",
            "always @(posedge i_clk) if (w_wstb && f_addr == w_addr) for(ik=0; ik < DW/8; ik=ik+1) if (w_sel[ik]) f_data[ik * 8 +: 8] <= w_data[ik*8 +: 8]; end endgenerate",
            "always @(*) assert(mem[f_addr] == f_data);",
            "always @(posedge i_clk) if ((f_past_valid)&&(OPT_ROM)) assert($stable(f_data)); `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipaxil.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipaxil.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipaxil.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A potential top level",
            "module holding the core of the Zip CPU // together--this one with AXI-lite instruction, data, and debug // interfaces. In general, the Zip CPU is designed to be as simple as // possible. (actual implementation aside ...) The instruction set is // about as RISC as you can get, with only 26 instruction types currently // supported. (There are still 8-instruction Op-Codes reserved for // floating point, and 5 which can be used for transactions not requiring // reg isters.) Please see the accompanying spec.pdf file for a description // of these instructions. // // This version is bus width agnostic for both instruction and data buses, // although the debug bus must still be 32-bits. Instruction and data // buses must be at least 32-bits wide. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipaxil #( // {{{",
            "parameter C_DBG_ADDR_WIDTH = 8, parameter ADDRESS_WIDTH = 32, parameter C_AXI_DATA_WIDTH = 32, parameter OPT_LGICACHE = 0, parameter OPT_LGDCACHE = 0, parameter [0:0] OPT_PIPELINED = 1'b1, parameter [ADDRESS_WIDTH-1:0] RESET_ADDRESS={(ADDRESS_WIDTH){1'b0}}, parameter [0:0] START_HALTED = 1'b0, parameter [0:0] SWAP_WSTRB = 1'b1, parameter OPT_MPY = 3, parameter [0:0] OPT_DIV = 1'b1, parameter [0:0] OPT_SHIFTS = 1'b1, parameter [0:0] OPT_LOCK = 1'b1, parameter [0:0] OPT_FPU = 0, parameter [0:0] OPT_EARLY_BRANCHING = 1, parameter [0:0] OPT_CIS = 1'b1, parameter [0:0] OPT_LOWPOWER = 1'b0, parameter [0:0] OPT_DISTRIBUTED_REGS = 1'b1, parameter [0:0] OPT_DBGPORT = START_HALTED, parameter [0:0] OPT_TRACE_PORT = 1'b0, parameter [0:0] OPT_PROFILER = 1'b0, parameter [0:0] OPT_USERMODE = 1'b1, parameter RESET_DURATION = 10, // localparam [0:0] WITH_LOCAL_BUS = 1'b0, `ifdef VERILATOR",
            "parameter [0:0] OPT_SIM = 1'b1, parameter [0:0] OPT_CLKGATE = OPT_LOWPOWER `else",
            "parameter [0:0] OPT_SIM = 1'b0, parameter [0:0] OPT_CLKGATE = 1'b0 `endif `ifdef FORMAL , parameter F_LGDEPTH=8 `endif // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, S_AXI_ARESETN, i_interrupt, i_cpu_reset, // Debug interface // {{{ // Debug interface --",
            "input s // input wire i_halt, i_clear_cache, // input wire [4:0] i_dbg_w",
            "reg , // input wire i_dbg_we, // input wire [31:0] i_dbg_data, // input wire [4:0] i_dbg_r",
            "reg , // Debug interface --",
            "output s // output wire cpu_dbg_stall, // output reg [31:0] o_dbg_",
            "reg , // output reg [2:0] o_dbg_cc, // output wire o_break, input wire S_DBG_AWVALID, output wire S_DBG_AWREADY, input wire [C_DBG_ADDR_WIDTH-1:0] S_DBG_AWADDR, // Verilator coverage_off",
            "input wire [2:0] S_DBG_AWPROT, // Verilator coverage_on // input wire S_DBG_WVALID, output wire S_DBG_WREADY, input wire [31:0] S_DBG_WDATA, input wire [3:0] S_DBG_WSTRB, // output reg S_DBG_BVALID, input wire S_DBG_BREADY, // Verilator coverage_off",
            "output wire [1:0] S_DBG_BRESP, // Verilator coverage_on // input wire S_DBG_ARVALID, output wire S_DBG_ARREADY, input wire [7:0] S_DBG_ARADDR, // Verilator coverage_off",
            "input wire [2:0] S_DBG_ARPROT, // Verilator coverage_on // output reg S_DBG_RVALID, input wire S_DBG_RREADY, output reg [31:0] S_DBG_RDATA, // Verilator coverage_off",
            "output wire [1:0] S_DBG_RRESP, // Verilator coverage_on // // }}} // Instruction bus (master) // {{{ // Verilator coverage_off",
            "output wire M_INSN_AWVALID, input wire M_INSN_AWREADY, output wire [ADDRESS_WIDTH-1:0] M_INSN_AWADDR, output wire [2:0] M_INSN_AWPROT, // output wire M_INSN_WVALID, input wire M_INSN_WREADY, output wire [C_AXI_DATA_WIDTH-1:0] M_INSN_WDATA, output wire [C_AXI_DATA_WIDTH/8-1:0] M_INSN_WSTRB, // input wire M_INSN_BVALID, output wire M_INSN_BREADY, input wire [1:0] M_INSN_BRESP, // Verilator coverage_on // output wire M_INSN_ARVALID, input wire M_INSN_ARREADY, output wire [ADDRESS_WIDTH-1:0] M_INSN_ARADDR, output wire [2:0] M_INSN_ARPROT, // input wire M_INSN_RVALID, output wire M_INSN_RREADY, input wire [C_AXI_DATA_WIDTH-1:0] M_INSN_RDATA, input wire [1:0] M_INSN_RRESP, // }}} // Data bus (master) // {{{",
            "output wire M_DATA_AWVALID, input wire M_DATA_AWREADY, output wire [ADDRESS_WIDTH-1:0] M_DATA_AWADDR, // Verilator coverage_off",
            "output wire [2:0] M_DATA_AWPROT, // Verilator coverage_on // output wire M_DATA_WVALID, input wire M_DATA_WREADY, output wire [C_AXI_DATA_WIDTH-1:0] M_DATA_WDATA, output wire [C_AXI_DATA_WIDTH/8-1:0] M_DATA_WSTRB, // input wire M_DATA_BVALID, output wire M_DATA_BREADY, input wire [1:0] M_DATA_BRESP, // output wire M_DATA_ARVALID, input wire M_DATA_ARREADY, output wire [ADDRESS_WIDTH-1:0] M_DATA_ARADDR, // Verilator coverage_off",
            "output wire [2:0] M_DATA_ARPROT, // Verilator coverage_on // input wire M_DATA_RVALID, output wire M_DATA_RREADY, input wire [C_AXI_DATA_WIDTH-1:0] M_DATA_RDATA, input wire [1:0] M_DATA_RRESP, // }}} // Accounting",
            "output s ... to help us count stalls and usage",
            "output wire o_cmd_reset, output wire o_halted, output wire o_gie, output wire o_op_stall, output wire o_pf_stall, output wire o_i_count, // output wire [31:0] o_cpu_debug, // `ifdef VBENCH_TB // {{{ // output wire cpu_halt, // cmd_reset, // cmd_step, output wire early_branch, output wire [31:0] early_branch_pc, output wire [6:0] dcdA, dcdB, output wire new_pc, output wire [31:0] cpu_ipc, cpu_upc, pf_pc, // output wire pf_cyc, pf_stb, pf_we, // output wire [31:0] pf_addr, // output wire pf_ack, output wire pf_valid, pf_illegal, // pf_vmask, pf_r_v, pf_tagsrc, pf_tagipc, pf_tagvallst, // output wire [31:0] pf_lastpc, output wire [31:0] pf_instruction, output wire [31:0] pf_instruction_pc, // output wire dcd_ce, dcd_stalled, dcd_gie, dcd_valid, dcd_illegal, dcd_phase, dcd_break, dcd_pipe, output wire [3:0] dcd_opn, output wire dcd_rA, dcd_rB, dcd_wR, dcd_wF, output wire [4:0] dcdR, output wire dcdRpc, dcdRcc, output wire [31:0] dcd_pc, output wire dcd_M, // output wire op_ce, op_illegal, op_valid, op_valid_mem, op_valid_alu, op_stall, op_wR, op_wF, op_phase, op_gie, output wire [4:0] op_R, op_Aid, op_Bid, output wire [31:0] op_Av, op_Bv, op_pc, output wire master_stall, // output wire alu_ce, adf_ce_unconditional, alu_valid, alu_wR, alu_wF, alu_pc_valid, alu_illegal, alu_gie, set_cond, alu_phase, output wire [3:0] alu_flags, output wire [31:0] alu_pc, // output wire mem_valid, mem_pc_valid, mem_ce, mem_busy, mem_rdbusy, output wire [4:0] mem_w",
            "reg , // output wire div_valid, div_ce, div_busy, // output wire [4:0] wr_",
            "reg _id, output wire wr_",
            "reg _ce, wr_flags_ce, output wire [31:0] wr_gp",
            "reg _vl, wr_sp",
            "reg _vl, output wire [15:0] w_iflags, w_uflags, // output wire cpu_sim, r_sleep, master_ce, op_break, r_gie, output wire [22:0] cpu_sim_immv, output wire [7:0] op_F, // // // ZipSystem peripherals",
            "output wire [31:0] watchbus, watchdog, pic_data, wdbus_data, output wire [15:0] int_state, alt_int_state, output wire [31:0] timer_a, timer_b, timer_c, jiffies, utc_data, uoc_data, uic_data, upc_data, mtc_data, moc_data, mpc_data, mic_data, output wire [31:0] mem_data, mem_addr, mem_result, output wire op_pipe, // op_A_alu, op_B_alu, // op_A_mem, op_B_mem, output wire [3:0] op_opn, output wire [31:0] alu_result, output wire alu_busy, output wire [4:0] alu_",
            "reg , output wire switch_to_interrupt, release_from_interrupt, break_en, // }}} `endif",
            "output wire o_prof_stb, output wire [ADDRESS_WIDTH-1:0] o_prof_addr, output wire [31:0] o_prof_ticks // }}} ); // Declarations // {{{",
            "localparam [0:0] DBG_ADDR_CTRL = 1'b0, DBG_ADDR_CPU = 1'b1;",
            "localparam C_DBG_DATA_WIDTH = 32;",
            "localparam DBGLSB = $clog2(C_DBG_DATA_WIDTH/8);",
            "localparam AW=ADDRESS_WIDTH-2;",
            "localparam [0:0] OPT_PIPELINED_BUS_ACCESS = (OPT_PIPELINED)&&(OPT_LGDCACHE > 1);",
            "localparam [0:0] OPT_MEMPIPE = OPT_PIPELINED_BUS_ACCESS;",
            "localparam [0:0] OPT_DCACHE = (OPT_LGDCACHE > 4);",
            "localparam FETCH_LIMIT = (OPT_LGICACHE < 4) ? (1 << OPT_LGICACHE) : 16; // Debug bit allocations // {{{ // DBGCTRL // 5 DBG Catch -- Catch exceptions/fautls w/ debugger // 4 Clear cache // 3 RESET_FLAG // 2 STEP (W=1 steps, and returns to halted) // 1 HALT(ED) // 0 HALT // DBGDATA // read/writes internal",
            "reg isters // localparam HALT_BIT = 0, STEP_BIT = 2, RESET_BIT = 3, CLEAR_CACHE_BIT = 4, CATCH_BIT = 5; // }}}",
            "localparam [0:0] OPT_ALIGNMENT_ERR = 1'b0;",
            "localparam [0:0] SWAP_ENDIANNESS = 1'b0; // AXI-lite signal handling // {{{",
            "wire awskd_valid, wskd_valid, arskd_valid;",
            "wire dbg_write_ready, dbg_read_ready;",
            "wire [C_DBG_ADDR_WIDTH-DBGLSB-1:0] awskd_addr, arskd_addr;",
            "wire [31:0] wskd_data;",
            "wire [3:0] wskd_strb;",
            "reg dbg_write_valid, dbg_read_valid;",
            "wire dbg_blkram_stall;",
            "reg [4:0] dbg_write_",
            "reg ;",
            "wire [4:0] dbg_read_",
            "reg ;",
            "reg [31:0] dbg_write_data;",
            "wire [31:0] dbg_read_data;",
            "wire cpu_dbg_stall, cpu_break, dbg_write_stall;",
            "wire [2:0] cpu_dbg_cc; // }}}",
            "wire reset_hold, halt_on_fault, dbg_catch;",
            "wire cpu_clken, cpu_clock, clk_gate;",
            "wire reset_request, release_request, halt_request, step_request, clear_cache_request;",
            "wire cpu_has_halted; // CPU control",
            "reg isters // {{{",
            "reg cmd_halt, cmd_reset, cmd_step, cmd_clear_cache;",
            "wire [31:0] cpu_status;",
            "wire dbg_cmd_write, dbg_cpu_write;",
            "wire [31:0] dbg_cmd_data;",
            "wire [3:0] dbg_cmd_strb; // }}} // Fetch // {{{",
            "wire pf_new_pc, clear_icache, pf_ready;",
            "wire [AW+1:0] pf_request_address; `ifndef VBENCH_TB",
            "wire [31:0] pf_instruction;",
            "wire [AW+1:0] pf_instruction_pc;",
            "wire pf_valid, pf_illegal; `endif // }}} // Memory // {{{",
            "wire clear_dcache, bus_lock;",
            "wire [2:0] mem_op;",
            "wire [31:0] mem_cpu_addr;",
            "wire [AW+1:0] mem_lock_pc;",
            "wire [31:0] mem_wdata;",
            "wire [4:0] mem_",
            "reg ;",
            "wire mem_pipe_stalled, mem_bus_err; `ifndef VBENCH_TB",
            "wire mem_ce, mem_valid, mem_busy, mem_rdbusy;",
            "wire [4:0] mem_w",
            "reg ;",
            "wire [31:0] mem_result; `endif // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Debug signal handling // {{{ //////////////////////////////////////////////////////////////////////// // // // // Write signaling // {{{ skidbuffer #( // {{{ .OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(C_DBG_ADDR_WIDTH-DBGLSB) // }}} ) dbgawskd( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(S_DBG_AWVALID), .o_ready(S_DBG_AWREADY), .i_data(S_DBG_AWADDR[C_DBG_ADDR_WIDTH-1:DBGLSB]), .o_valid(awskd_valid), .i_ready(dbg_write_ready), .o_data(awskd_addr) // }}} ); skidbuffer #( // {{{ .OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(C_DBG_DATA_WIDTH+C_DBG_DATA_WIDTH/8) // }}} ) dbgwskd( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(S_DBG_WVALID), .o_ready(S_DBG_WREADY), .i_data({ S_DBG_WSTRB, S_DBG_WDATA }), .o_valid(wskd_valid), .i_ready(dbg_write_ready), .o_data({ wskd_strb, wskd_data }) // }}} );",
            "assign dbg_write_ready = awskd_valid && wskd_valid && ((wskd_strb==0) || awskd_addr[5] != DBG_ADDR_CPU || !dbg_write_stall) && (!S_DBG_BVALID || S_DBG_BREADY); // dbg_write_valid // {{{",
            "initial dbg_write_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !OPT_DBGPORT) dbg_write_valid <= 1'b0; else if (!dbg_write_stall) dbg_write_valid <= dbg_cpu_write; // }}} // dbg_write_",
            "reg // {{{",
            "always @(posedge S_AXI_ACLK) if (!dbg_write_stall) begin dbg_write_",
            "reg <= awskd_addr[4:0]; if (OPT_LOWPOWER && !dbg_cpu_write) dbg_write_",
            "reg <= 0; end // }}} // dbg_write_data // {{{",
            "always @(posedge S_AXI_ACLK) if (!dbg_write_stall) begin dbg_write_data <= wskd_data; if (OPT_LOWPOWER && !dbg_cpu_write) dbg_write_data <= 0; end // }}} // S_DBG_BVALID // {{{",
            "initial S_DBG_BVALID = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) S_DBG_BVALID <= 1'b0; else if (dbg_write_ready) S_DBG_BVALID <= 1'b1; else if (S_DBG_BREADY) S_DBG_BVALID <= 1'b0; // }}} // S_DBG_BRESP // {{{",
            "assign S_DBG_BRESP = 2'b00; // }}} // }}} // // Read signaling // {{{ skidbuffer #( // {{{ .OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(C_DBG_ADDR_WIDTH-DBGLSB) // }}} ) dbgarskd( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(S_DBG_ARVALID), .o_ready(S_DBG_ARREADY), .i_data(S_DBG_ARADDR[C_DBG_ADDR_WIDTH-1:DBGLSB]), .o_valid(arskd_valid), .i_ready(dbg_read_ready), .o_data(arskd_addr) // }}} );",
            "assign dbg_read_ready = arskd_valid && !dbg_blkram_stall && (!S_DBG_RVALID || S_DBG_RREADY);",
            "assign dbg_read_",
            "reg = (OPT_LOWPOWER && !dbg_read_ready) ? 5'h0 : arskd_addr[4:0]; // dbg_read_valid // {{{",
            "reg [1:0] r_blkram_stall;",
            "initial r_blkram_stall = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !OPT_DBGPORT) r_blkram_stall <= 0; else if (dbg_read_ready && arskd_addr[5] == DBG_ADDR_CPU) r_blkram_stall <= 2 + (OPT_DISTRIBUTED_REGS ? 0:1); else if (r_blkram_stall > 0) r_blkram_stall <= r_blkram_stall - 1;",
            "initial dbg_read_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !OPT_DBGPORT) dbg_read_valid <= 0; else dbg_read_valid <= (r_blkram_stall == 1);",
            "assign dbg_blkram_stall = (r_blkram_stall != 0); `ifdef FORMAL",
            "always @(*) if (S_AXI_ARESETN && (dbg_read_valid || dbg_blkram_stall)) assert(!S_DBG_RVALID); `endif // }}} // S_DBG_RVALID // {{{",
            "initial S_DBG_RVALID = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) S_DBG_RVALID <= 0; else if (!S_DBG_RVALID || S_DBG_RREADY) S_DBG_RVALID <= (dbg_read_ready && (!OPT_DBGPORT || arskd_addr[5] == DBG_ADDR_CTRL)) || dbg_read_valid; // }}} // S_DBG_RDATA // {{{",
            "initial S_DBG_RDATA = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) S_DBG_RDATA <= 0; else if (!S_DBG_RVALID || S_DBG_RREADY) begin // {{{ if (OPT_DBGPORT && dbg_read_valid) S_DBG_RDATA <= dbg_read_data; else S_DBG_RDATA <= cpu_status; if (OPT_LOWPOWER && (!OPT_DBGPORT || !dbg_read_valid) && !dbg_read_ready) S_DBG_RDATA <= 0; // }}} end // }}}",
            "assign S_DBG_RRESP = 2'b00; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Reset, halt, clear-cache, and step controls // {{{ //////////////////////////////////////////////////////////////////////// // // assign dbg_cpu_write = OPT_DBGPORT && dbg_write_ready && awskd_addr[5] == DBG_ADDR_CPU && wskd_strb == 4'hf;",
            "assign dbg_cmd_write = dbg_write_ready && awskd_addr[5] == DBG_ADDR_CTRL;",
            "assign dbg_cmd_data = wskd_data;",
            "assign dbg_cmd_strb = wskd_strb;",
            "assign reset_request = dbg_cmd_write && dbg_cmd_strb[RESET_BIT/8] && dbg_cmd_data[RESET_BIT];",
            "assign release_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8] && !dbg_cmd_data[HALT_BIT];",
            "assign halt_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8] && dbg_cmd_data[HALT_BIT];",
            "assign step_request = dbg_cmd_write && dbg_cmd_strb[STEP_BIT/8] && dbg_cmd_data[STEP_BIT];",
            "assign clear_cache_request = dbg_cmd_write && dbg_cmd_strb[CLEAR_CACHE_BIT/8] && dbg_cmd_data[CLEAR_CACHE_BIT]; // // reset_hold: Always start us off with an",
            "initial reset // {{{ generate if (RESET_DURATION > 0) begin : INITIAL_RESET_HOLD // {{{",
            "reg [$clog2(RESET_DURATION)-1:0] reset_counter;",
            "reg r_reset_hold;",
            "initial reset_counter = RESET_DURATION;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || i_cpu_reset) reset_counter <= RESET_DURATION; else if (reset_counter > 0) reset_counter <= reset_counter - 1;",
            "initial r_reset_hold = 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || i_cpu_reset) r_reset_hold <= 1; else r_reset_hold <= (reset_counter > 1);",
            "assign reset_hold = r_reset_hold; `ifdef FORMAL",
            "always @(*) assert(reset_hold == (reset_counter != 0)); `endif // }}} end else begin : NO_RESET_HOLD",
            "assign reset_hold = 0; end endgenerate // }}}",
            "assign halt_on_fault = dbg_catch; // cmd_reset // {{{ // Always start us off with an",
            "initial reset",
            "initial cmd_reset = 1'b1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || i_cpu_reset) cmd_reset <= 1'b1; else if (reset_hold) cmd_reset <= 1'b1; else if (cpu_break && !halt_on_fault) cmd_reset <= 1'b1; else cmd_reset <= reset_request; // }}} // cmd_halt // {{{",
            "initial cmd_halt = START_HALTED;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) cmd_halt <= START_HALTED; else if (i_cpu_reset && !dbg_write_ready && !dbg_write_stall) cmd_halt <= START_HALTED; else if (cmd_reset && START_HALTED) cmd_halt <= START_HALTED; else begin // {{{ // When shall we release from a halt? Only if we have // come to a full and complete stop. Even then, we only // release if we aren't being given a command to step the CPU. // if (!dbg_write_valid && cpu_has_halted && dbg_cmd_write && (release_request || step_request)) cmd_halt <= 1'b0; // Reasons to halt // 1. Halt on any unhandled CPU exception. The cause of the // exception must be cured before we can (re)start. // If the CPU is configured to start immediately on power // up, we leave it to reset on any exception instead. if (cpu_break && halt_on_fault) cmd_halt <= 1'b1; // 2. Halt on any user request to halt. (Only valid if the // STEP bit isn't also set) if (dbg_cmd_write && halt_request && !step_request) cmd_halt <= 1'b1; // 3. Halt on any user request to write to a CPU",
            "reg ister if (dbg_cpu_write) cmd_halt <= 1'b1; // 4. Halt following any step command if (cmd_step && !step_request) cmd_halt <= 1'b1; // 5. Halt following any clear cache if (cmd_clear_cache) cmd_halt <= 1'b1; // 6. Halt on any clear cache bit--independent of any step bit if (clear_cache_request) cmd_halt <= 1'b1; // }}} end // }}} // cmd_clear_cache // {{{",
            "initial cmd_clear_cache = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || cmd_reset) cmd_clear_cache <= 1'b0; else if (dbg_cmd_write && clear_cache_request && halt_request) cmd_clear_cache <= 1'b1; else if (cmd_halt && !cpu_dbg_stall) cmd_clear_cache <= 1'b0; // }}} // cmd_step // {{{",
            "initial cmd_step = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || i_cpu_reset) cmd_step <= 1'b0; else if (cmd_reset || cpu_break || reset_request || clear_cache_request || cmd_clear_cache || halt_request || dbg_cpu_write) cmd_step <= 1'b0; else if (!dbg_write_valid && cpu_has_halted && step_request) cmd_step <= 1'b1; else // if (cpu_dbg_stall) cmd_step <= 1'b0; `ifdef FORMAL // While STEP is true, we can't halt",
            "always @(*) if (S_AXI_ARESETN && cmd_step) assert(!cmd_halt); `endif // }}} // dbg_catch // {{{ generate if (!OPT_DBGPORT) begin : NO_DBG_CATCH",
            "assign dbg_catch = START_HALTED; end else begin : GEN_DBG_CATCH",
            "reg r_dbg_catch;",
            "initial r_dbg_catch = START_HALTED;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_dbg_catch <= START_HALTED; else if (dbg_cmd_write && dbg_cmd_strb[CATCH_BIT/8]) r_dbg_catch <= dbg_cmd_data[CATCH_BIT];",
            "assign dbg_catch = r_dbg_catch; end endgenerate // }}} // cpu_status // {{{ // 0xffff_f000 -> (Unused / reserved) // // 0x0000_0800 -> cpu_break // 0x0000_0400 -> Interrupt pending // 0x0000_0200 -> User mode // 0x0000_0100 -> Sleep (CPU is sleeping) // // 0x0000_00c0 -> (Unused/reserved) // 0x0000_0020 -> dbg_catch // 0x0000_0010 -> cmd_clear_cache // // 0x0000_0008 -> Reset // 0x0000_0004 -> Step (auto clearing, write only) // 0x0000_0002 -> Halt (status) // 0x0000_0001 -> Halt (request)",
            "assign cpu_status = { 16'h0, 4'h0, cpu_break, i_interrupt, cpu_dbg_cc[1:0], 2'h0, dbg_catch, 1'b0, cmd_reset, 1'b0, !cpu_dbg_stall, cmd_halt }; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // The ZipCPU Core // {{{ //////////////////////////////////////////////////////////////////////// // // `ifdef FORMAL // {{{ (* anyseq *)",
            "reg f_cpu_halted, f_cpu_data, f_cpu_stall, f_cpu_break; (* anyseq *)",
            "reg [2:0] f_cpu_dbg_cc; (* anyseq *)",
            "reg [2:0] f_cpu_dbg_read_data;",
            "assign cpu_dbg_stall = f_cpu_stall && !f_cpu_halted;",
            "assign cpu_break = f_cpu_break;",
            "assign cpu_dbg_cc = f_cpu_dbg_cc;",
            "assign dbg_read_data = f_cpu_dbg_read_data; fdebug #( // {{{ .OPT_START_HALTED(START_HALTED), .OPT_DISTRIBUTED_RAM(OPT_DISTRIBUTED_REGS) // }}} ) fdbg ( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_cpu_reset(cmd_reset || i_cpu_reset), .i_halt(cmd_halt), .i_halted(f_cpu_halted), .i_clear_cache(cmd_clear_cache), .i_dbg_we(dbg_write_valid), .i_dbg_",
            "reg (dbg_write_",
            "reg ), .i_dbg_data(dbg_write_data), .i_dbg_stall(cpu_dbg_stall), .i_dbg_break(cpu_break), .i_dbg_cc(cpu_dbg_cc) // }}} ); // }}} `else zipcore #( // {{{ .RESET_ADDRESS({ {(32-ADDRESS_WIDTH){1'b0}}, RESET_ADDRESS }), .ADDRESS_WIDTH(ADDRESS_WIDTH-2), .OPT_PIPELINED(OPT_PIPELINED), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_DCACHE(OPT_DCACHE), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .IMPLEMENT_FPU(OPT_FPU), .OPT_CIS(OPT_CIS), .OPT_LOCK(OPT_LOCK), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_START_HALTED(START_HALTED), .OPT_SIM(OPT_SIM), .OPT_PIPELINED_BUS_ACCESS(OPT_MEMPIPE), // localparam [0:0] OPT_MEMPIPE = OPT_PIPELINED_BUS_ACCESS; .OPT_DBGPORT(OPT_DBGPORT), .OPT_TRACE_PORT(OPT_TRACE_PORT), .OPT_PROFILER(OPT_PROFILER), .OPT_CLKGATE(OPT_CLKGATE), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_USERMODE(OPT_USERMODE) `ifdef FORMAL , .F_LGDEPTH(F_LGDEPTH) `endif // }}} ) core ( // {{{ .i_clk(cpu_clock), .i_reset(cmd_reset), .i_interrupt(i_interrupt), .o_clken(cpu_clken), // Debug interface // {{{ .i_halt(cmd_halt), .i_clear_cache(cmd_clear_cache), .i_dbg_w",
            "reg (dbg_write_",
            "reg ), .i_dbg_we(dbg_write_valid), .i_dbg_data(dbg_write_data),.i_dbg_r",
            "reg (dbg_read_",
            "reg ), .o_dbg_stall(cpu_dbg_stall),.o_dbg_",
            "reg (dbg_read_data), .o_dbg_cc(cpu_dbg_cc), .o_break(cpu_break), // }}} // Instruction fetch interface // {{{ .o_pf_new_pc(pf_new_pc), .o_clear_icache(clear_icache), .o_pf_ready(pf_ready), .o_pf_request_address(pf_request_address), .i_pf_valid(pf_valid), .i_pf_illegal(pf_illegal), .i_pf_instruction(pf_instruction), .i_pf_instruction_pc(pf_instruction_pc), // }}} // Memory unit interface // {{{ .o_clear_dcache(clear_dcache), .o_mem_ce(mem_ce), .o_bus_lock(bus_lock), .o_mem_op(mem_op), .o_mem_addr(mem_cpu_addr), .o_mem_data(mem_wdata), .o_mem_lock_pc(mem_lock_pc), .o_mem_",
            "reg (mem_",
            "reg ), .i_mem_busy(mem_busy), .i_mem_rdbusy(mem_rdbusy), .i_mem_pipe_stalled(mem_pipe_stalled), .i_mem_valid(mem_valid), .i_bus_err(mem_bus_err), .i_mem_w",
            "reg (mem_w",
            "reg ), .i_mem_result(mem_result), // }}} // Accounting/CPU usage interface .o_op_stall(o_op_stall), .o_pf_stall(o_pf_stall), .o_i_count(o_i_count), // .o_debug(o_cpu_debug), // .o_prof_stb( o_prof_stb), .o_prof_addr( o_prof_addr), .o_prof_ticks(o_prof_ticks) // }}} ); `endif",
            "assign o_cmd_reset = cmd_reset;",
            "assign o_gie = cpu_dbg_cc[1];",
            "assign dbg_write_stall = dbg_write_valid && cpu_dbg_stall;",
            "assign cpu_has_halted = !cpu_dbg_stall;",
            "assign o_halted = cpu_has_halted; // }}} //////////////////////////////////////////////////////////////////////// // // Instruction Fetch // {{{ //////////////////////////////////////////////////////////////////////// // `ifndef FORMAL axilfetch #( // {{{ .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .FETCH_LIMIT(FETCH_LIMIT), .SWAP_ENDIANNESS(SWAP_ENDIANNESS) // }}} ) pf ( // {{{ .S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN), // CPU signals // {{{ .i_cpu_reset(cmd_reset), .i_new_pc(pf_new_pc), .i_clear_cache(clear_icache), .i_ready(pf_ready && clk_gate), .i_pc(pf_request_address), .o_insn(pf_instruction), .o_pc(pf_instruction_pc), .o_valid(pf_valid), .o_illegal(pf_illegal), // }}} // AXI-lite bus signals // {{{ .M_AXI_ARVALID(M_INSN_ARVALID), .M_AXI_ARREADY(M_INSN_ARREADY), .M_AXI_ARADDR(M_INSN_ARADDR), .M_AXI_ARPROT(M_INSN_ARPROT), // .M_AXI_RVALID(M_INSN_RVALID), .M_AXI_RREADY(M_INSN_RREADY), .M_AXI_RDATA(M_INSN_RDATA), .M_AXI_RRESP(M_INSN_RRESP) // }}} // }}} ); `endif // Assign values to the (unused) M_INSN_* write ports // {{{",
            "assign M_INSN_AWVALID = 0;",
            "assign M_INSN_AWADDR = 0;",
            "assign M_INSN_AWPROT = 0; // assign M_INSN_WVALID = 0;",
            "assign M_INSN_WDATA = 0;",
            "assign M_INSN_WSTRB = 0; // assign M_INSN_BREADY = 1'b1; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Memory Unit // {{{ //////////////////////////////////////////////////////////////////////// // `ifndef FORMAL",
            "wire [C_AXI_DATA_WIDTH-1:0] i_bus_data, o_bus_data;",
            "wire [C_AXI_DATA_WIDTH/8-1:0] o_bus_strb; generate if (SWAP_WSTRB && C_AXI_DATA_WIDTH > 32 && !OPT_DCACHE) begin : SWAP_BUS_WORD_ORDER genvar gk; for(gk=0; gk<C_AXI_DATA_WIDTH/32; gk=gk+1) begin",
            "assign i_bus_data[(C_AXI_DATA_WIDTH-32-gk*32) +: 32] = M_DATA_RDATA[gk*32 +: 32];",
            "assign M_DATA_WDATA[gk*32 +: 32] = o_bus_data[(C_AXI_DATA_WIDTH-32-gk*32) +: 32];",
            "assign M_DATA_WSTRB[gk* 4 +: 4] = o_bus_strb[(C_AXI_DATA_WIDTH/8-4-gk*4) +: 4]; end end else begin : KEEP_BUS_WORD_ORDER // {{{",
            "assign i_bus_data = M_DATA_RDATA;",
            "assign M_DATA_WDATA = o_bus_data;",
            "assign M_DATA_WSTRB = o_bus_strb; // }}} end endgenerate generate if (OPT_PIPELINED_BUS_ACCESS) begin : PIPELINED_MEM axilpipe #( // {{{ .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .OPT_ALIGNMENT_ERR(OPT_ALIGNMENT_ERR), .SWAP_WSTRB(SWAP_WSTRB), .OPT_LOWPOWER(OPT_LOWPOWER) // .OPT_SIGN_EXTEND(OPT_SIGN_EXTEND) // }}} ) domem( // {{{ .S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN), .i_cpu_reset(cmd_reset), // CPU interface // {{{ .i_stb(mem_ce), .i_lock(bus_lock), .i_op(mem_op), .i_addr(mem_cpu_addr), .i_data(mem_wdata), .i_o",
            "reg (mem_",
            "reg ), .o_busy(mem_busy), .o_pipe_stalled(mem_pipe_stalled), .o_rdbusy(mem_rdbusy), .o_valid(mem_valid), .o_err(mem_bus_err), .o_w",
            "reg (mem_w",
            "reg ), .o_result(mem_result), // }}} // AXI-lite // Write interface // {{{ .M_AXI_AWVALID(M_DATA_AWVALID), .M_AXI_AWREADY(M_DATA_AWREADY), .M_AXI_AWADDR( M_DATA_AWADDR), .M_AXI_AWPROT( M_DATA_AWPROT), // .M_AXI_WVALID(M_DATA_WVALID), .M_AXI_WREADY(M_DATA_WREADY), .M_AXI_WDATA(o_bus_data), .M_AXI_WSTRB(o_bus_strb), // .M_AXI_BVALID(M_DATA_BVALID), .M_AXI_BREADY(M_DATA_BREADY), .M_AXI_BRESP( M_DATA_BRESP), // }}} // Read interface // {{{ .M_AXI_ARVALID(M_DATA_ARVALID), .M_AXI_ARREADY(M_DATA_ARREADY), .M_AXI_ARADDR( M_DATA_ARADDR), .M_AXI_ARPROT( M_DATA_ARPROT), // .M_AXI_RVALID(M_DATA_RVALID), .M_AXI_RREADY(M_DATA_RREADY), .M_AXI_RDATA( i_bus_data), .M_AXI_RRESP( M_DATA_RRESP) // }}} // }}} ); end else begin : BARE_MEM axilops #( // {{{ .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .SWAP_ENDIANNESS(SWAP_ENDIANNESS), .SWAP_WSTRB(SWAP_WSTRB), .OPT_ALIGNMENT_ERR(OPT_ALIGNMENT_ERR), .OPT_LOWPOWER(OPT_LOWPOWER) // }}} ) domem( // {{{ .S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN), .i_cpu_reset(cmd_reset), // CPU interface // {{{ .i_stb(mem_ce), .i_lock(bus_lock), .i_op(mem_op), .i_addr(mem_cpu_addr[ADDRESS_WIDTH-1:0]), .i_data(mem_wdata), .i_o",
            "reg (mem_",
            "reg ), .o_busy(mem_busy), .o_rdbusy(mem_rdbusy), .o_valid(mem_valid), .o_err(mem_bus_err), .o_w",
            "reg (mem_w",
            "reg ), .o_result(mem_result), // }}} // AXI-lite // Write interface // {{{ .M_AXI_AWVALID(M_DATA_AWVALID), .M_AXI_AWREADY(M_DATA_AWREADY), .M_AXI_AWADDR( M_DATA_AWADDR), .M_AXI_AWPROT( M_DATA_AWPROT), // .M_AXI_WVALID(M_DATA_WVALID), .M_AXI_WREADY(M_DATA_WREADY), .M_AXI_WDATA(o_bus_data), .M_AXI_WSTRB(o_bus_strb), // .M_AXI_BVALID(M_DATA_BVALID), .M_AXI_BREADY(M_DATA_BREADY), .M_AXI_BRESP( M_DATA_BRESP), // }}} // Read interface // {{{ .M_AXI_ARVALID(M_DATA_ARVALID), .M_AXI_ARREADY(M_DATA_ARREADY), .M_AXI_ARADDR( M_DATA_ARADDR), .M_AXI_ARPROT( M_DATA_ARPROT), // .M_AXI_RVALID(M_DATA_RVALID), .M_AXI_RREADY(M_DATA_RREADY), .M_AXI_RDATA( i_bus_data), .M_AXI_RRESP( M_DATA_RRESP) // }}} // }}} );",
            "assign mem_pipe_stalled = mem_busy; end endgenerate `endif // }}} //////////////////////////////////////////////////////////////////////// // // (Optional) Clock gate // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_CLKGATE) begin : GATE_CPU_CLOCK",
            "reg gatep;",
            "reg gaten /* verilator clock_enable */;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) gatep <= 1'b1; else gatep <= cpu_clken || arskd_valid || dbg_write_valid || dbg_blkram_stall;",
            "always @(negedge S_AXI_ACLK) if (!S_AXI_ARESETN) gaten <= 1'b1; else gaten <= gatep;",
            "assign cpu_clock = S_AXI_ACLK && gaten;",
            "assign clk_gate = gatep; end else begin : NO_CLOCK_GATE",
            "assign cpu_clock = S_AXI_ACLK;",
            "assign clk_gate = 1'b1; end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Simulation only accesses, to make the simulation display work // {{{ //////////////////////////////////////////////////////////////////////// // // `ifdef VBENCH_TB",
            "assign early_branch = core.dcd_early_branch;",
            "assign early_branch_pc = core.dcd_branch_pc;",
            "assign dcdA = core.dcd_full_A;",
            "assign dcdB = core.dcd_full_B;",
            "assign new_pc = core.new_pc;",
            "assign cpu_ipc= core.ipc;",
            "assign cpu_upc= core.upc;",
            "assign pf_pc = core.pf_pc; // assign pf_cyc = thecpu.pf_cyc; // assign pf_stb = thecpu.pf_stb; // assign pf_we = thecpu.pf_we; // assign pf_addr= { thecpu.pf_addr, 2'b00 }; // assign pf_ack = thecpu.pf_ack; // assign pf_valid = core.i_pf_valid; // assign pf_illegal = core.i_pf_illegal; // assign cpu_idata = core.i_wb_data; // assign pf_instruction = core.i_pf_instruction; // assign pf_instruction_pc = core.i_pf_instruction_pc; // // Peeking into the decode stage // {{{",
            "assign dcd_ce = core.dcd_ce;",
            "assign dcd_stalled = core.dcd_stalled;",
            "assign dcd_gie = core.dcd_gie;",
            "assign dcd_valid = core.dcd_valid;",
            "assign dcd_illegal = core.dcd_illegal;",
            "assign dcd_phase = core.dcd_phase;",
            "assign dcd_break = core.dcd_break;",
            "assign dcd_pipe = core.dcd_pipe; // assign dcd_opn = core.dcd_opn;",
            "assign dcd_rA = core.dcd_rA;",
            "assign dcd_rB = core.dcd_rB;",
            "assign dcd_wR = core.dcd_wR;",
            "assign dcd_wF = core.dcd_wF;",
            "assign dcdR = core.instruction_decoder.w_dcdR;",
            "assign dcdRpc = core.instruction_decoder.w_dcdR_pc;",
            "assign dcdRcc = core.instruction_decoder.w_dcdR_cc;",
            "assign dcd_pc = core.dcd_pc;",
            "assign dcd_M = core.dcd_M; // }}} // Peeking into the op stage // {{{",
            "assign op_ce = core.op_ce;",
            "assign op_illegal = core.op_illegal;",
            "assign op_valid = core.op_valid;",
            "assign op_valid_mem = core.op_valid_mem;",
            "assign op_valid_alu = core.op_valid_alu;",
            "assign op_stall = core.op_stall;",
            "assign op_wR = core.op_wR;",
            "assign op_wF = core.op_wF;",
            "assign op_phase = core.op_phase;",
            "assign op_gie = core.op_gie;",
            "assign op_pipe = core.op_pipe;",
            "assign op_R = core.op_R;",
            "assign op_Aid = core.op_Aid;",
            "assign op_Bid = core.op_Bid;",
            "assign op_Av = core.op_Av;",
            "assign op_Bv = core.op_Bv;",
            "assign op_pc = core.op_pc;",
            "assign master_stall = core.master_stall;",
            "assign op_F = core.op_F;",
            "assign op_pipe = core.op_pipe;",
            "assign op_opn = core.op_opn; // }}} // Peeking into the ALU stage // {{{",
            "assign alu_ce = core.alu_ce;",
            "assign adf_ce_unconditional = core.adf_ce_unconditional;",
            "assign alu_valid = core.alu_valid;",
            "assign alu_wR = core.alu_wR;",
            "assign alu_wF = core.alu_wF;",
            "assign alu_pc_valid = core.alu_pc_valid;",
            "assign alu_illegal = core.alu_illegal;",
            "assign alu_gie = core.alu_gie;",
            "assign set_cond = core.set_cond;",
            "assign alu_phase = core.alu_phase;",
            "assign alu_flags = core.alu_flags;",
            "assign alu_pc = core.alu_pc;",
            "assign alu_result = core.alu_result;",
            "assign alu_busy = core.alu_busy;",
            "assign alu_",
            "reg = core.alu_",
            "reg ; // }}} // Peeking into the MEM stage // {{{ // // assign mem_valid = core.i_mem_valid;",
            "assign mem_pc_valid = core.mem_pc_valid; // assign mem_ce = core.o_mem_ce; // assign mem_busy = core.i_mem_busy; // assign mem_rdbusy = core.i_mem_rdbusy; // assign mem_w",
            "reg = core.i_mem_w",
            "reg ; // }}} // Peeking into the divide stage // {{{",
            "assign div_valid = core.div_valid;",
            "assign div_ce = core.div_ce;",
            "assign div_busy = core.div_busy; // }}} // Writeback stage // {{{",
            "assign wr_",
            "reg _id = core.wr_",
            "reg _id;",
            "assign wr_",
            "reg _ce = core.wr_",
            "reg _ce;",
            "assign wr_flags_ce = core.wr_flags_ce;",
            "assign wr_gp",
            "reg _vl = core.wr_gp",
            "reg _vl;",
            "assign wr_sp",
            "reg _vl = core.wr_sp",
            "reg _vl;",
            "assign w_iflags = core.w_iflags;",
            "assign w_uflags = core.w_uflags; // }}} // Miscellaneous // {{{",
            "assign cpu_sim = core.cpu_sim;",
            "assign cpu_sim_immv = core.op_sim_immv;",
            "assign r_sleep = core.sleep;",
            "assign master_ce = core.master_ce;",
            "assign op_break = core.op_break;",
            "assign r_gie = core.gie; // }}} // // ZipSystem peripherals // {{{",
            "assign watchbus = 32'h0;",
            "assign watchdog = 32'h0;",
            "assign timer_a = 32'h0;",
            "assign timer_b = 32'h0;",
            "assign timer_c = 32'h0;",
            "assign jiffies = 32'h0;",
            "assign wdbus_data = 32'h0;",
            "assign pic_data = 32'h0;",
            "assign utc_data = 32'h0;",
            "assign uoc_data = 32'h0;",
            "assign upc_data = 32'h0;",
            "assign uic_data = 32'h0;",
            "assign mtc_data = 32'h0;",
            "assign moc_data = 32'h0;",
            "assign mpc_data = 32'h0;",
            "assign mic_data = 32'h0; // assign int_state = 16'h0;",
            "assign alt_int_state = 16'h0; // assign wb_cyc_gbl = mem_cyc_gbl; // assign wb_stb_gbl = mem_stb_gbl; // assign wb_cyc_lcl = mem_cyc_lcl; // assign wb_stb_lcl = mem_stb_lcl; // assign mem_stb_gbl = mem_stb_gbl; // assign mem_stb_lcl = mem_stb_lcl; // assign mem_we = mem_we; // assign mem_ack = mem_ack; // assign mem_stall = mem_stall;",
            "assign mem_data = mem_wdata;",
            "assign mem_addr = { core.o_mem_addr }; // assign mem_result = core.i_mem_result;",
            "assign switch_to_interrupt = core.w_switch_to_interrupt;",
            "assign release_from_interrupt = core.w_release_from_interrupt;",
            "assign break_en = core.break_en; // }}} `endif // }}} // Make Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, cpu_clken, cpu_dbg_cc[2], S_DBG_AWADDR[DBGLSB-1:0], mem_lock_pc, clear_dcache, S_DBG_ARADDR[DBGLSB-1:0], S_DBG_ARPROT, S_DBG_AWPROT, M_INSN_AWREADY, M_INSN_WREADY, M_INSN_BVALID, M_INSN_BRESP }; generate if (32 > ADDRESS_WIDTH) begin : GEN_UNUSED_ADDR",
            "wire unused_addr;",
            "assign unused_addr = &{ 1'b0, mem_cpu_addr[31:ADDRESS_WIDTH] }; end endgenerate // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "wire [F_LGDEPTH-1:0] faxil_rd_outstanding, faxil_wr_outstanding, faxil_awr_outstanding; //////////////////////////////////////////////////////////////////////// // // AXI-lite debug interface // {{{ //////////////////////////////////////////////////////////////////////// // // faxil_slave #( // {{{ .C_AXI_DATA_WIDTH(C_DBG_DATA_WIDTH), .C_AXI_ADDR_WIDTH(C_DBG_ADDR_WIDTH), .F_LGDEPTH(F_LGDEPTH), .F_AXI_MAXWAIT(0), .F_AXI_MAXDELAY(0) // }}} ) faxil ( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // AXI-lite debug writes // {{{ .i_axi_awvalid(S_DBG_AWVALID), .i_axi_awready(S_DBG_AWREADY), .i_axi_awaddr(S_DBG_AWADDR), .i_axi_awprot(S_DBG_AWPROT), // .i_axi_wvalid(S_DBG_WVALID), .i_axi_wready(S_DBG_WREADY), .i_axi_wdata(S_DBG_WDATA), .i_axi_wstrb(S_DBG_WSTRB), // .i_axi_bvalid(S_DBG_BVALID), .i_axi_bready(S_DBG_BREADY), .i_axi_bresp(S_DBG_BRESP), // }}} // AXI-lite debug reads // {{{ .i_axi_arvalid(S_DBG_ARVALID), .i_axi_arready(S_DBG_ARREADY), .i_axi_araddr(S_DBG_ARADDR), .i_axi_arprot(S_DBG_ARPROT), // .i_axi_rvalid(S_DBG_RVALID), .i_axi_rready(S_DBG_RREADY), .i_axi_rdata(S_DBG_RDATA), .i_axi_rresp(S_DBG_RRESP), // }}} // Induction // {{{ .f_axi_rd_outstanding(faxil_rd_outstanding), .f_axi_wr_outstanding(faxil_wr_outstanding), .f_axi_awr_outstanding(faxil_awr_outstanding) // }}} // }}} );",
            "always @(*) if (S_AXI_ARESETN) begin assert(faxil_rd_outstanding == (S_DBG_ARREADY ? 0:1) +(dbg_read_valid ? 1:0) + (S_DBG_RVALID ? 1:0)); assert(!dbg_read_valid || !S_DBG_RVALID); assert(faxil_wr_outstanding == (S_DBG_WREADY ? 0:1) +(S_DBG_BVALID ? 1:0)); assert(faxil_awr_outstanding == (S_DBG_AWREADY ? 0:1) +(S_DBG_BVALID ? 1:0)); end // }}} //////////////////////////////////////////////////////////////////////// // // CPU's debug interface // {{{ //////////////////////////////////////////////////////////////////////// // // // Captured above // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipsystem.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipsystem.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipsystem.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This portion of the ZIP CPU implements a number of soft // peripherals to the CPU nearby its CORE. The functionality // sits on the data bus, and does not include any true external hardware // peripherals. The peripherals included here include: // // Local interrupt controller--for any/all of the interrupts generated // here. This would include a pin for interrupts generated // elsewhere, so this interrupt controller could be a master // handling all interrupts. My interrupt controller would work // for this purpose. // // The ZIP-CPU supports only one interrupt because, as I understand // modern systems (Linux), they tend to send all interrupts to the // same interrupt vector anyway. Hence, that's what we do here. // // Interval timer(s) (Count down from fixed value, and either stop on // zero, or issue an interrupt and restart automatically on zero) // These can be implemented as watchdog timers if desired--the // only difference is that a watchdog timer's interrupt feeds the // reset line instead of the processor interrupt line. // // Watch-dog timer: this is the same as an interval timer, only it's // interrupt/time-out line is",
            "wire d to the reset line instead of // the interrupt line of the CPU. // // Direct Memory Access Controller: This controller allows you to command // automatic memory moves. Such memory moves will take place // without the CPU's involvement until they are done. See the // DMA specification for more information. (Currently contained // w/in the ZipCPU spec.) // // (Potentially an eventual floating point co-processor ...?) // // Busses: The ZipSystem implements a series of busses to make this take // place. These busses are identified by their prefix: // // cpu This is the bus as the CPU sees it. Since the CPU controls // two busses (a local and a global one), it uses _gbl_ to indicate // the external bus (going through the MMU if necessary) and // _lcl_ to indicate a peripheral bus seen here. // // mmu Sits between the CPU's wishbone interface and the external // bus. Has no access to peripherals. // // sys A local bus implemented here within this space. This is how the // CPU talks to the ZipSystem peripherals. However, this bus // can also be accessed from the external debug bus. // // io_dbg // io_wb // // dbg This is identical to the io_dbg bus, but separated by a clock // dc The",
            "output of the DMA controller // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}} // // Debug address space: // {{{ // 0-15 0x0? Supervisors",
            "reg isters // 16-31 0x1? User",
            "reg isters // 32-63 0x2? CPU command",
            "reg ister (singular, one",
            "reg ister only) // 64 0x40 Interrupt controller // 65 0x41 Watchdog // 66 0x42 Bus watchdog // 67 0x43 CTRINT // 68 0x44 Timer A // 69 0x45 Timer B // 70 0x46 Timer C // 71 0x47 Jiffies // 72 0x48 Master task counter // 73 0x49 Master task counter // 74 0x4a Master task counter // 75 0x4b Master instruction counter // 76 0x4c User task counter // 77 0x4d User task counter // 78 0x4e User task counter // 79 0x4f User instruction counter // 80 0x50 DMAC Control/Status",
            "reg ister // 81 0x51 DMAC Length // 82 0x52 DMAC Read (source) address // 83 0x53 DMAC Write (destination) address // /////// /////// /////// /////// // // (MMU ... is not available via debug bus) // }}}",
            "module zipsystem #( // {{{",
            "parameter RESET_ADDRESS=32'h1000_0000, ADDRESS_WIDTH=32, parameter BUS_WIDTH=32, // Bus data width",
            "localparam DBG_WIDTH=32, // CPU options // {{{",
            "parameter [0:0] OPT_PIPELINED=1, parameter [0:0] OPT_EARLY_BRANCHING=OPT_PIPELINED, // OPT_LGICACHE // {{{",
            "parameter OPT_LGICACHE=10, // }}} // OPT_LGDCACHE // {{{ // Set to zero for no data cache",
            "parameter OPT_LGDCACHE=10, // }}}",
            "parameter [0:0] START_HALTED=1, parameter [0:0] OPT_DISTRIBUTED_REGS=1, parameter EXTERNAL_INTERRUPTS=1, // OPT_MPY // {{{",
            "parameter OPT_MPY = 3, // }}} // OPT_DIV // {{{",
            "parameter [0:0] OPT_DIV=1, // }}} // OPT_SHIFTS // {{{",
            "parameter [0:0] OPT_SHIFTS = 1, // }}} // OPT_FPU // {{{",
            "parameter [0:0] OPT_FPU = 0, // }}}",
            "parameter [0:0] OPT_CIS=1, parameter [0:0] OPT_LOCK=1, parameter [0:0] OPT_USERMODE=1, parameter [0:0] OPT_DBGPORT=START_HALTED, parameter [0:0] OPT_TRACE_PORT=1, parameter [0:0] OPT_PROFILER=0, parameter [0:0] OPT_LOWPOWER=0, // }}} // Local bus options // {{{ // OPT_DMA // {{{",
            "parameter [0:0] OPT_DMA=1, parameter DMA_LGMEM = 10, // }}} // OPT_ACCOUNTING // {{{",
            "parameter [0:0] OPT_ACCOUNTING = 1'b1, // }}} // Bus delay options // {{{ // While I hate adding delays to any bus access, this next // delay is required to make timing close in my Basys-3 design.",
            "parameter [0:0] DELAY_DBG_BUS = 1'b1, // parameter [0:0] DELAY_EXT_BUS = 1'b0, // }}} `ifdef VERILATOR",
            "parameter [0:0] OPT_SIM=1'b1, parameter [0:0] OPT_CLKGATE = OPT_LOWPOWER, `else",
            "parameter [0:0] OPT_SIM=1'b0, parameter [0:0] OPT_CLKGATE = 1'b0, `endif // }}}",
            "parameter RESET_DURATION = 0, // Short-cut names // {{{",
            "localparam // Derived",
            "parameter s // PHYSICAL_ADDRESS_WIDTH=ADDRESS_WIDTH, PAW=ADDRESS_WIDTH-$clog2(BUS_WIDTH/8) // }}} // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Wishbone master interface from the CPU // {{{",
            "output wire o_wb_cyc, o_wb_stb, o_wb_we, output wire [PAW-1:0] o_wb_addr, output wire [BUS_WIDTH-1:0] o_wb_data, output wire [BUS_WIDTH/8-1:0] o_wb_sel, input wire i_wb_stall, i_wb_ack, input wire [BUS_WIDTH-1:0] i_wb_data, input wire i_wb_err, // }}} // Incoming interrupts",
            "input wire [(EXTERNAL_INTERRUPTS-1):0] i_ext_int, // Our one outgoing interrupt",
            "output wire o_ext_int, // Wishbone slave interface for debugging purposes // {{{",
            "input wire i_dbg_cyc, i_dbg_stb, i_dbg_we, input wire [6:0] i_dbg_addr, input wire [DBG_WIDTH-1:0] i_dbg_data, input wire [DBG_WIDTH/8-1:0] i_dbg_sel, output wire o_dbg_stall, output wire o_dbg_ack, output wire [DBG_WIDTH-1:0] o_dbg_data, // }}}",
            "output wire [31:0] o_cpu_debug, // `ifdef VBENCH_TB // {{{ // output wire cpu_halt, // cmd_reset, // cmd_step, output wire early_branch, output wire [31:0] early_branch_pc, output wire [6:0] dcdA, dcdB, output wire new_pc, output wire [31:0] cpu_ipc, cpu_upc, pf_pc, output wire pf_cyc, pf_stb, pf_we, output wire [31:0] pf_addr, output wire pf_ack, output wire pf_valid, pf_illegal, // pf_vmask, pf_r_v, pf_tagsrc, pf_tagipc, pf_tagvallst, // output wire [31:0] pf_lastpc, output wire [31:0] pf_instruction, output wire [31:0] pf_instruction_pc, // output wire dcd_ce, dcd_stalled, dcd_gie, dcd_valid, dcd_illegal, dcd_phase, dcd_break, dcd_pipe, output wire [3:0] dcd_opn, output wire dcd_rA, dcd_rB, dcd_wR, dcd_wF, output wire [4:0] dcdR, output wire dcdRpc, dcdRcc, output wire [31:0] dcd_pc, output wire dcd_M, // output wire op_ce, op_illegal, op_valid, op_valid_mem, op_valid_alu, op_stall, op_wR, op_wF, op_phase, op_gie, output wire [4:0] op_R, op_Aid, op_Bid, output wire [31:0] op_Av, op_Bv, op_pc, output wire master_stall, // output wire alu_ce, adf_ce_unconditional, alu_valid, alu_wR, alu_wF, alu_pc_valid, alu_illegal, alu_gie, set_cond, alu_phase, output wire [3:0] alu_flags, output wire [31:0] alu_pc, // output wire mem_valid, mem_pc_valid, mem_ce, mem_busy, mem_rdbusy, output wire [4:0] mem_w",
            "reg , // output wire div_valid, div_ce, div_busy, // output wire [4:0] wr_",
            "reg _id, output wire wr_",
            "reg _ce, wr_flags_ce, output wire [31:0] wr_gp",
            "reg _vl, wr_sp",
            "reg _vl, output wire [15:0] w_iflags, w_uflags, // output wire cpu_sim, r_sleep, master_ce, op_break, r_gie, output wire [22:0] cpu_sim_immv, output wire [7:0] op_F, // output wire dbg_cyc, dbg_stb, dbg_we, output wire [6:0] dbg_addr, output reg dbg_ack, output wire [DBG_WIDTH-1:0] dbg_idata, output wire sys_cyc, sys_stb, sys_we, output wire [7:0] sys_addr, output wire [DBG_WIDTH-1:0] sys_data, // output wire [BUS_WIDTH-1:0] cpu_idata, output wire cpu_stall, output wire cpu_interrupt, // // ZipSystem peripherals",
            "output wire [31:0] watchbus, watchdog, pic_data, wdbus_data, output wire [15:0] int_state, alt_int_state, output wire [31:0] timer_a, timer_b, timer_c, jiffies, utc_data, uoc_data, uic_data, upc_data, mtc_data, moc_data, mpc_data, mic_data, output wire wb_cyc_gbl, wb_cyc_lcl, wb_stb_gbl, wb_stb_lcl, mem_stb_gbl, mem_stb_lcl, mem_we, mem_ack, mem_stall, output wire [31:0] mem_data, mem_addr, mem_result, output wire op_pipe, // op_A_alu, op_B_alu, // op_A_mem, op_B_mem, output wire [3:0] op_opn, output wire [31:0] alu_result, output wire alu_busy, output wire [4:0] alu_",
            "reg , output wire switch_to_interrupt, release_from_interrupt, break_en, output wire pformem_owner, // }}} `endif",
            "output wire o_prof_stb, output wire [ADDRESS_WIDTH-1:0] o_prof_addr, output wire [31:0] o_prof_ticks // }}} ); // Local declarations // {{{ // Local",
            "parameter declarations // {{{",
            "localparam DW=BUS_WIDTH; // Peripheral addresses // {{{ // Verilator lint_off UNUSED // These values may (or may not) be used, depending on whether or not // the respective peripheral is included in the CPU.",
            "localparam [31:0] PERIPHBASE = 32'hc0000000;",
            "localparam [7:0] INTCTRL = 8'h0, WATCHDOG = 8'h1, // Interrupt generates reset signal BUSWATCHDOG = 8'h2, // Sets IVEC[0] CTRINT = 8'h3, // Sets IVEC[5] TIMER_A = 8'h4, // Sets IVEC[4] TIMER_B = 8'h5, // Sets IVEC[3] TIMER_C = 8'h6, // Sets IVEC[2] JIFFIES = 8'h7, // Sets IVEC[1] // Accounting counter addresses MSTR_TASK_CTR = 8'h08, MSTR_MSTL_CTR = 8'h09, MSTR_PSTL_CTR = 8'h0a, MSTR_INST_CTR = 8'h0b, USER_TASK_CTR = 8'h0c, USER_MSTL_CTR = 8'h0d, USER_PSTL_CTR = 8'h0e, USER_INST_CTR = 8'h0f, // The MMU MMU_ADDR = 8'h80, // DMA controller (DMAC) // Although I have a hole at 5'h2, the DMA controller // requires four wishbone addresses, therefore we place // it by itself and expand our address bus width here // by another bit. DMAC_ADDR = 8'h10; // Verilator lint_on UNUSED // }}} // Debug bit allocations // {{{ // DBGCTRL // 5 DBG Catch -- Catch exceptions/fautls w/ debugger // 4 Clear cache // 3 RESET_FLAG // 2 STEP (W=1 steps, and returns to halted) // 1 HALT(ED) // 0 HALT // DBGDATA // read/writes internal",
            "reg isters // localparam HALT_BIT = 0, STEP_BIT = 2, RESET_BIT = 3, CLEAR_CACHE_BIT = 4, CATCH_BIT = 5; // }}} // Virtual address width (unused) // {{{",
            "localparam `ifdef OPT_MMU VIRTUAL_ADDRESS_WIDTH=30; `else VIRTUAL_ADDRESS_WIDTH=PAW; `endif // LGTLBSZ = 6, // Log TLB size // VAW=VIRTUAL_ADDRESS_WIDTH, // }}}",
            "localparam [1:0] DBG_ADDR_CTRL= 2'b00, DBG_ADDR_CPU = 2'b01, DBG_ADDR_SYS = 2'b10; // }}}",
            "wire [14:0] main_int_vector, alt_int_vector;",
            "wire ctri_int, tma_int, tmb_int, tmc_int, jif_int, dmac_int;",
            "wire mtc_int, moc_int, mpc_int, mic_int, utc_int, uoc_int, upc_int, uic_int;",
            "wire [DBG_WIDTH-1:0] actr_data;",
            "wire actr_ack, actr_stall;",
            "wire cpu_clken; // // `ifndef VBENCH_TB",
            "wire sys_cyc, sys_stb, sys_we;",
            "wire [7:0] sys_addr;",
            "wire [DBG_WIDTH-1:0] sys_data; `endif",
            "wire [PAW-1:0] cpu_addr;",
            "reg [DBG_WIDTH-1:0] sys_idata;",
            "reg sys_ack;",
            "wire sys_stall;",
            "wire sel_counter, sel_timer, sel_pic, sel_apic, sel_watchdog, sel_bus_watchdog, sel_dmac, sel_mmus; `ifndef VBENCH_TB",
            "wire dbg_cyc, dbg_stb, dbg_we;",
            "wire [6:0] dbg_addr;",
            "wire [DBG_WIDTH-1:0] dbg_idata;",
            "reg dbg_ack; `endif",
            "wire dbg_stall;",
            "reg [DBG_WIDTH-1:0] dbg_odata;",
            "wire [DBG_WIDTH/8-1:0] dbg_sel;",
            "wire no_dbg_err;",
            "wire cpu_break, dbg_cmd_write, dbg_cpu_write, dbg_cpu_read;",
            "wire [DBG_WIDTH-1:0] dbg_cmd_data;",
            "wire [DBG_WIDTH/8-1:0] dbg_cmd_strb;",
            "wire reset_hold, halt_on_fault, dbg_catch;",
            "wire reset_request, release_request, halt_request, step_request, clear_cache_request;",
            "reg cmd_reset, cmd_halt, cmd_step, cmd_clear_cache, cmd_write, cmd_read;",
            "reg [4:0] cmd_waddr;",
            "reg [DBG_WIDTH-1:0] cmd_wdata;",
            "wire [2:0] cpu_dbg_cc;",
            "wire cpu_reset, cpu_halt, cpu_has_halted;",
            "wire cpu_dbg_stall;",
            "wire [DBG_WIDTH-1:0] cpu_status;",
            "wire cpu_gie;",
            "wire wdt_stall, wdt_ack, wdt_reset;",
            "wire [DBG_WIDTH-1:0] wdt_data;",
            "reg wdbus_ack;",
            "reg [PAW-1:0] r_wdbus_data; `ifndef VBENCH_TB",
            "wire [DBG_WIDTH-1:0] pic_data;",
            "wire [DBG_WIDTH-1:0] wdbus_data; `endif",
            "wire reset_wdbus_timer, wdbus_int;",
            "wire cpu_op_stall, cpu_pf_stall, cpu_i_count;",
            "wire dmac_stb, dc_err;",
            "wire [DBG_WIDTH-1:0] dmac_data;",
            "wire dmac_stall, dmac_ack;",
            "wire dc_cyc, dc_stb, dc_we, dc_stall, dc_ack;",
            "wire [PAW-1:0] dc_addr;",
            "wire [BUS_WIDTH-1:0] dc_data;",
            "wire [BUS_WIDTH/8-1:0] dc_sel;",
            "wire cpu_gbl_cyc;",
            "wire [31:0] dmac_int_vec;",
            "wire ctri_sel, ctri_stall, ctri_ack;",
            "wire [DBG_WIDTH-1:0] ctri_data;",
            "wire tma_stall, tma_ack;",
            "wire tmb_stall, tmb_ack;",
            "wire tmc_stall, tmc_ack;",
            "wire jif_stall, jif_ack;",
            "wire [DBG_WIDTH-1:0] tma_data;",
            "wire [DBG_WIDTH-1:0] tmb_data;",
            "wire [DBG_WIDTH-1:0] tmc_data;",
            "wire [DBG_WIDTH-1:0] jif_data;",
            "wire pic_stall, pic_ack;",
            "wire cpu_gbl_stb, cpu_lcl_cyc, cpu_lcl_stb, cpu_we;",
            "wire [BUS_WIDTH-1:0] cpu_data;",
            "wire [BUS_WIDTH/8-1:0] cpu_sel, mmu_sel; `ifndef VBENCH_TB",
            "wire [BUS_WIDTH-1:0] cpu_idata;",
            "wire cpu_stall; `endif",
            "wire pic_interrupt;",
            "wire cpu_ack, cpu_err;",
            "wire [DBG_WIDTH-1:0] cpu_dbg_data;",
            "wire ext_stall, ext_ack;",
            "wire mmu_cyc, mmu_stb, mmu_we, mmu_stall, mmu_ack, mmu_err, mmus_stall, mmus_ack;",
            "wire [PAW-1:0] mmu_addr;",
            "wire [BUS_WIDTH-1:0] mmu_data, mmu_idata;",
            "wire [DBG_WIDTH-1:0] mmus_data;",
            "wire cpu_miss;",
            "wire mmu_cpu_stall, mmu_cpu_ack;",
            "wire [BUS_WIDTH-1:0] mmu_cpu_idata; // The",
            "wire s associated with cache snooping",
            "wire pf_return_stb, pf_return_we, pf_return_cachable;",
            "wire [19:0] pf_return_v, pf_return_p;",
            "wire ext_cyc, ext_stb, ext_we, ext_err;",
            "wire [PAW-1:0] ext_addr;",
            "wire [BUS_WIDTH-1:0] ext_odata;",
            "wire [BUS_WIDTH/8-1:0] ext_sel;",
            "wire [BUS_WIDTH-1:0] ext_idata;",
            "reg [DBG_WIDTH-1:0] tmr_data;",
            "reg [2:0] w_ack_idx, ack_idx;",
            "reg last_sys_stb; // }}} //////////////////////////////////////////////////////////////////////// // // Handle our interrupt vector generation/coordination // {{{ //////////////////////////////////////////////////////////////////////// // // // Main interrupt vector // {{{",
            "assign main_int_vector[5:0] = { ctri_int, tma_int, tmb_int, tmc_int, jif_int, dmac_int }; generate if (EXTERNAL_INTERRUPTS < 9) begin : TRIM_MAIN_INTS",
            "assign main_int_vector[14:6] = { {(9-EXTERNAL_INTERRUPTS){1'b0}}, i_ext_int }; end else begin : NO_TRIM_MAIN_INTS",
            "assign main_int_vector[14:6] = i_ext_int[8:0]; end endgenerate // }}} // The alternate interrupt vector // {{{ generate if (EXTERNAL_INTERRUPTS <= 9 && OPT_ACCOUNTING) begin : ALT_ACCOUNTING_INTS",
            "assign alt_int_vector = { 7'h00, mtc_int, moc_int, mpc_int, mic_int, utc_int, uoc_int, upc_int, uic_int }; end else if (EXTERNAL_INTERRUPTS <= 9) // && !OPT_ACCOUNTING begin : ALT_NO_INTS",
            "assign alt_int_vector = { 15'h00 }; end else if (OPT_ACCOUNTING && EXTERNAL_INTERRUPTS >= 15) begin : ALT_ACCT_PLUS_INTS",
            "assign alt_int_vector = { i_ext_int[14:8], mtc_int, moc_int, mpc_int, mic_int, utc_int, uoc_int, upc_int, uic_int }; end else if (OPT_ACCOUNTING) begin : ALT_ACCT_SOME_INTS",
            "assign alt_int_vector = { {(7-(EXTERNAL_INTERRUPTS-9)){1'b0}}, i_ext_int[(EXTERNAL_INTERRUPTS-1):9], mtc_int, moc_int, mpc_int, mic_int, utc_int, uoc_int, upc_int, uic_int }; end else if (!OPT_ACCOUNTING && EXTERNAL_INTERRUPTS >= 24) begin : ALT_NO_ACCOUNTING_INTS",
            "assign alt_int_vector = { i_ext_int[(EXTERNAL_INTERRUPTS-1):9] }; end else begin : ALT_TRIM_INTS",
            "assign alt_int_vector = { {(15-(EXTERNAL_INTERRUPTS-9)){1'b0}}, i_ext_int[(EXTERNAL_INTERRUPTS-1):9] }; end endgenerate // }}} // Make Verilator happy // {{{ generate if (!OPT_ACCOUNTING) begin : UNUSED_ACCOUNTING // Verilator lint_off UNUSED",
            "wire unused_ctrs;",
            "assign unused_ctrs = &{ 1'b0, moc_int, mpc_int, mic_int, mtc_int, uoc_int, upc_int, uic_int, utc_int, cpu_gie, cpu_op_stall, cpu_pf_stall, cpu_i_count }; // Verilator lint_on UNUSED end endgenerate // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Delay the debug port by one clock, to meet timing requirements // {{{ //////////////////////////////////////////////////////////////////////// // generate if (DELAY_DBG_BUS) begin : DELAY_THE_DEBUG_BUS // {{{",
            "wire dbg_err;",
            "assign dbg_err = 1'b0; busdelay #( // {{{ .AW(7),.DW(32) // }}} ) wbdelay( // {{{ i_clk, i_reset, i_dbg_cyc, i_dbg_stb, i_dbg_we, i_dbg_addr, i_dbg_data, 4'hf, o_dbg_stall, o_dbg_ack, o_dbg_data, no_dbg_err, dbg_cyc, dbg_stb, dbg_we, dbg_addr, dbg_idata, dbg_sel, dbg_stall, dbg_ack, dbg_odata, dbg_err // }}} ); // }}} end else begin : NO_DEBUG_BUS_DELAY // {{{",
            "assign dbg_cyc = i_dbg_cyc;",
            "assign dbg_stb = i_dbg_stb;",
            "assign dbg_we = i_dbg_we;",
            "assign dbg_addr = i_dbg_addr;",
            "assign dbg_idata = i_dbg_data;",
            "assign o_dbg_ack = dbg_ack;",
            "assign o_dbg_stall = dbg_stall;",
            "assign o_dbg_data = dbg_odata;",
            "assign dbg_sel = 4'b1111;",
            "assign no_dbg_err = 1'b0; // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Bus decoding, sel_* // {{{ //////////////////////////////////////////////////////////////////////// // // assign sel_pic = (sys_stb)&&(sys_addr == INTCTRL);",
            "assign sel_watchdog = (sys_stb)&&(sys_addr == WATCHDOG);",
            "assign sel_bus_watchdog= (sys_stb)&&(sys_addr == BUSWATCHDOG);",
            "assign sel_apic = (sys_stb)&&(sys_addr == CTRINT);",
            "assign sel_timer = (sys_stb)&&(sys_addr[7:2]==TIMER_A[7:2]);",
            "assign sel_counter = (sys_stb)&&(sys_addr[7:3]==MSTR_TASK_CTR[7:3]);",
            "assign sel_dmac = (sys_stb)&&(sys_addr[7:4] ==DMAC_ADDR[7:4]);",
            "assign sel_mmus = (sys_stb)&&(sys_addr[7]); // }}} //////////////////////////////////////////////////////////////////////// // // The external debug interface // {{{ //////////////////////////////////////////////////////////////////////// // // assign dbg_cpu_write = OPT_DBGPORT && (dbg_stb && !dbg_stall && dbg_we) && (dbg_addr[6:5] == DBG_ADDR_CPU) && dbg_sel == 4'hf;",
            "assign dbg_cpu_read = (dbg_stb && !dbg_stall && !dbg_we && dbg_addr[6:5] == DBG_ADDR_CPU);",
            "assign dbg_cmd_write = (dbg_stb)&&(dbg_we) &&(dbg_addr[6:5] == DBG_ADDR_CTRL);",
            "assign dbg_cmd_data = dbg_idata;",
            "assign dbg_cmd_strb = dbg_sel;",
            "assign reset_request = dbg_cmd_write && dbg_cmd_strb[RESET_BIT/8] && dbg_cmd_data[RESET_BIT];",
            "assign release_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8] && !dbg_cmd_data[HALT_BIT];",
            "assign halt_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8] && dbg_cmd_data[HALT_BIT];",
            "assign step_request = dbg_cmd_write && dbg_cmd_strb[STEP_BIT/8] && dbg_cmd_data[STEP_BIT];",
            "assign clear_cache_request = dbg_cmd_write && dbg_cmd_strb[CLEAR_CACHE_BIT/8] && dbg_cmd_data[CLEAR_CACHE_BIT]; // // reset_hold: Always start us off with an",
            "initial reset // {{{ generate if (RESET_DURATION > 0) begin : INITIAL_RESET_HOLD // {{{",
            "reg [$clog2(RESET_DURATION)-1:0] reset_counter;",
            "reg r_reset_hold;",
            "initial reset_counter = RESET_DURATION;",
            "always @(posedge i_clk) if (i_reset) reset_counter <= RESET_DURATION; else if (reset_counter > 0) reset_counter <= reset_counter - 1;",
            "initial r_reset_hold = 1;",
            "always @(posedge i_clk) if (i_reset) r_reset_hold <= 1; else r_reset_hold <= (reset_counter > 1);",
            "assign reset_hold = r_reset_hold; `ifdef FORMAL",
            "always @(*) assert(reset_hold == (reset_counter != 0)); `endif // }}} end else begin : NO_RESET_HOLD",
            "assign reset_hold = 0; end endgenerate // }}}",
            "assign halt_on_fault = dbg_catch; // cmd_reset // {{{ // Always start us off with an",
            "initial reset",
            "initial cmd_reset = 1'b1;",
            "always @(posedge i_clk) if (i_reset) cmd_reset <= 1'b1; else if (reset_hold || wdt_reset) cmd_reset <= 1'b1; else if (cpu_break && !halt_on_fault) cmd_reset <= 1'b1; else cmd_reset <= reset_request; // }}} // cmd_halt // {{{",
            "initial cmd_halt = START_HALTED;",
            "always @(posedge i_clk) if (i_reset) cmd_halt <= START_HALTED; else if (cmd_reset && START_HALTED) cmd_halt <= START_HALTED; else begin // {{{ // When shall we release from a halt? Only if we have // come to a full and complete stop. Even then, we only // release if we aren't being given a command to step the CPU. // if (!cmd_write && cpu_has_halted && dbg_cmd_write && (release_request || step_request)) cmd_halt <= 1'b0; // Reasons to halt // 1. Halt on any unhandled CPU exception. The cause of the // exception must be cured before we can (re)start. // If the CPU is configured to start immediately on power // up, we leave it to reset on any exception instead. if (cpu_break && halt_on_fault) cmd_halt <= 1'b1; // 2. Halt on any user request to halt. (Only valid if the // STEP bit isn't also set) if (dbg_cmd_write && halt_request && !step_request) cmd_halt <= 1'b1; // 3. Halt on any user request to write to a CPU",
            "reg ister if (dbg_cpu_write) cmd_halt <= 1'b1; // 4. Halt following any step command if (cmd_step && !step_request) cmd_halt <= 1'b1; // 5. Halt following any clear cache if (cmd_clear_cache) cmd_halt <= 1'b1; // 6. Halt on any clear cache bit--independent of any step bit if (clear_cache_request) cmd_halt <= 1'b1; // }}} end // }}} // cmd_clear_cache // {{{",
            "initial cmd_clear_cache = 1'b0;",
            "always @(posedge i_clk) if (i_reset || cpu_reset) cmd_clear_cache <= 1'b0; else if (dbg_cmd_write && clear_cache_request && halt_request) cmd_clear_cache <= 1'b1; else if (cmd_halt && !cpu_dbg_stall) cmd_clear_cache <= 1'b0; // }}} // cmd_step // {{{",
            "initial cmd_step = 1'b0;",
            "always @(posedge i_clk) if (i_reset) cmd_step <= 1'b0; else if (cmd_reset || cpu_break || reset_request || clear_cache_request || cmd_clear_cache || halt_request || dbg_cpu_write) cmd_step <= 1'b0; else if (!cmd_write && cpu_has_halted && step_request) cmd_step <= 1'b1; else // if (cpu_dbg_stall) cmd_step <= 1'b0; `ifdef FORMAL // While STEP is true, we can't halt",
            "always @(*) if (!i_reset && cmd_step) assert(!cmd_halt); `endif // }}} // dbg_catch // {{{ generate if (!OPT_DBGPORT) begin : NO_DBG_CATCH",
            "assign dbg_catch = START_HALTED; end else begin : GEN_DBG_CATCH",
            "reg r_dbg_catch;",
            "initial r_dbg_catch = START_HALTED;",
            "always @(posedge i_clk) if (i_reset) r_dbg_catch <= START_HALTED; else if (dbg_cmd_write && dbg_cmd_strb[CATCH_BIT/8]) r_dbg_catch <= dbg_cmd_data[CATCH_BIT];",
            "assign dbg_catch = r_dbg_catch; end endgenerate // }}}",
            "assign cpu_reset = (cmd_reset);",
            "assign cpu_halt = (cmd_halt); // cpu_status // {{{ // Values: // 0xxxxx_0000 -> External interrupt lines // // 0xffff_f000 -> (Unused / reserved) // // 0x0000_0800 -> cpu_break // 0x0000_0400 -> Interrupt pending // 0x0000_0200 -> User mode // 0x0000_0100 -> Sleep (CPU is sleeping) // // 0x0000_00c0 -> (Unused/reserved) // 0x0000_0020 -> dbg_catch // 0x0000_0010 -> cmd_clear_cache // // 0x0000_0008 -> Reset // 0x0000_0004 -> Step (auto clearing, write only) // 0x0000_0002 -> Halt (status) // 0x0000_0001 -> Halt (request) generate if (EXTERNAL_INTERRUPTS < 20) begin : CPU_STATUS_NO_EXTRA_INTERRUPTS",
            "assign cpu_status = { {(20-EXTERNAL_INTERRUPTS){1'b0}}, i_ext_int, cpu_break, pic_interrupt, cpu_dbg_cc[1:0], 2'h0, dbg_catch, 1'b0, cmd_reset, 1'b0, !cpu_dbg_stall, cmd_halt }; end else begin : CPU_STATUS_MAX_INTERRUPTS",
            "assign cpu_status = { i_ext_int[19:0], cpu_break, pic_interrupt, cpu_dbg_cc[1:0], 2'h0, dbg_catch, 1'b0, cmd_reset, 1'b0, !cpu_dbg_stall, cmd_halt }; end endgenerate // }}}",
            "assign cpu_gie = cpu_dbg_cc[1]; // cmd_write // {{{",
            "initial cmd_write = 0;",
            "always @(posedge i_clk) if (i_reset || cpu_reset) cmd_write <= 1'b0; else if (!cmd_write || cpu_has_halted) cmd_write <= dbg_cpu_write; // }}} // cmd_read // {{{",
            "reg cmd_read_ack;",
            "initial cmd_read = 0;",
            "always @(posedge i_clk) if (i_reset || !dbg_cyc || !OPT_DBGPORT) cmd_read <= 1'b0; else if (dbg_cpu_read) cmd_read <= 1'b1; else if (cmd_read) // cmd_read_ack == 1) cmd_read <= 1'b0; generate if (OPT_DISTRIBUTED_REGS) begin : GEN_CMD_READ_ACK",
            "initial cmd_read_ack = 0;",
            "always @(posedge i_clk) if (i_reset || !dbg_cyc || !OPT_DBGPORT) cmd_read_ack <= 0; else if (dbg_cpu_read) cmd_read_ack <= 1; else if (cmd_read_ack != 0) cmd_read_ack <= 0; end else begin : GEN_FWD_CMDREAD_ACK",
            "always @(*) cmd_read_ack = cmd_read; end endgenerate // }}} // cmd_waddr, cmd_wdata // {{{",
            "always @(posedge i_clk) if ((!cmd_write || cpu_has_halted) && dbg_cpu_write) begin cmd_waddr <= dbg_addr[4:0]; cmd_wdata <= dbg_idata; end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // The WATCHDOG Timer // {{{ //////////////////////////////////////////////////////////////////////// // // ziptimer #( .BW(32),.VW(31),.RELOADABLE(0) ) u_watchdog ( // {{{ .i_clk(i_clk), .i_reset(cpu_reset), .i_ce(!cmd_halt), .i_wb_cyc(sys_cyc), .i_wb_stb((sys_stb)&&(sel_watchdog)), .i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf), .o_wb_stall(wdt_stall), .o_wb_ack(wdt_ack), .o_wb_data(wdt_data), .o_int(wdt_reset) // }}} ); // // Position two, a second watchdog timer--this time for the wishbone // bus, in order to tell/find wishbone bus lockups. In its current // configuration, it cannot be configured and all bus accesses must // take less than the number written to this",
            "reg ister. // assign reset_wdbus_timer = (!o_wb_cyc)||(o_wb_stb)||(i_wb_ack); wbwatchdog #(14) u_watchbus( // {{{ i_clk,(cpu_reset)||(reset_wdbus_timer), 14'h2000, wdbus_int // }}} );",
            "initial r_wdbus_data = 0;",
            "always @(posedge i_clk) if ((wdbus_int)||(cpu_err)) r_wdbus_data <= o_wb_addr;",
            "assign wdbus_data = { {(32-PAW){1'b0}}, r_wdbus_data };",
            "initial wdbus_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !sys_cyc) wdbus_ack <= 1'b0; else wdbus_ack <= (sys_stb)&&(sel_bus_watchdog); // }}} //////////////////////////////////////////////////////////////////////// // // Performance counters // {{{ //////////////////////////////////////////////////////////////////////// // // // Here's the stuff we'll be counting .... // generate if (OPT_ACCOUNTING) begin : ACCOUNTING_COUNTERS // {{{ // Local definitions // {{{ // Verilator lint_off UNUSED",
            "wire mtc_stall, mtc_ack;",
            "wire moc_stall, moc_ack;",
            "wire mpc_stall, mpc_ack;",
            "wire mic_stall, mic_ack;",
            "wire utc_stall, utc_ack;",
            "wire uoc_stall, uoc_ack;",
            "wire upc_stall, upc_ack;",
            "wire uic_stall, uic_ack; // Verilator lint_on UNUSED `ifndef VBENCH_TB",
            "wire [DBG_WIDTH-1:0] mtc_data;",
            "wire [DBG_WIDTH-1:0] moc_data;",
            "wire [DBG_WIDTH-1:0] mpc_data;",
            "wire [DBG_WIDTH-1:0] mic_data;",
            "wire [DBG_WIDTH-1:0] utc_data;",
            "wire [DBG_WIDTH-1:0] uoc_data;",
            "wire [DBG_WIDTH-1:0] upc_data;",
            "wire [DBG_WIDTH-1:0] uic_data; `endif",
            "reg [DBG_WIDTH-1:0] r_actr_data; // }}} // Master counters // {{{ // The master counters will, in general, not be reset. They'll // be used for an overall counter. // // Master task counter zipcounter mtask_ctr( // {{{ i_clk, 1'b0, (!cmd_halt), sys_cyc, (sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b000), sys_we, sys_data, mtc_stall, mtc_ack, mtc_data, mtc_int // }}} ); // Master Operand Stall counter zipcounter mmstall_ctr( // {{{ i_clk,1'b0, (cpu_op_stall), sys_cyc, (sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b001), sys_we, sys_data, moc_stall, moc_ack, moc_data, moc_int // }}} ); // Master PreFetch-Stall counter zipcounter mpstall_ctr( // {{{ i_clk,1'b0, (cpu_pf_stall), sys_cyc, (sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b010), sys_we, sys_data, mpc_stall, mpc_ack, mpc_data, mpc_int // }}} ); // Master Instruction counter zipcounter mins_ctr( // {{{ i_clk,1'b0, (cpu_i_count), sys_cyc, (sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b011), sys_we, sys_data, mic_stall, mic_ack, mic_data, mic_int // }}} ); // }}} // User counters // {{{ // The user counters are different from those of the master. // They will be reset any time a task is given control of the // CPU. // // User task counter zipcounter utask_ctr( // {{{ i_clk,1'b0, (!cmd_halt)&&(cpu_gie), sys_cyc, (sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b100), sys_we, sys_data, utc_stall, utc_ack, utc_data, utc_int // }}} ); // User Op-Stall counter zipcounter umstall_ctr( // {{{ i_clk,1'b0, (cpu_op_stall)&&(cpu_gie), sys_cyc, (sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b101), sys_we, sys_data, uoc_stall, uoc_ack, uoc_data, uoc_int // }}} ); // User PreFetch-Stall counter zipcounter upstall_ctr( // {{{ i_clk,1'b0, (cpu_pf_stall)&&(cpu_gie), sys_cyc, (sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b110), sys_we, sys_data, upc_stall, upc_ack, upc_data, upc_int // }}} ); // User instruction counter zipcounter uins_ctr( // {{{ i_clk,1'b0, (cpu_i_count)&&(cpu_gie), sys_cyc, (sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b111), sys_we, sys_data, uic_stall, uic_ack, uic_data, uic_int // }}} ); // }}} // A little bit of pre-cleanup (actr = accounting counters)",
            "assign actr_ack = sel_counter;",
            "assign actr_stall = 1'b0; // actr_data // {{{",
            "always @(*) begin case(sys_addr[2:0]) 3'h0: r_actr_data = mtc_data; 3'h1: r_actr_data = moc_data; 3'h2: r_actr_data = mpc_data; 3'h3: r_actr_data = mic_data; 3'h4: r_actr_data = utc_data; 3'h5: r_actr_data = uoc_data; 3'h6: r_actr_data = upc_data; 3'h7: r_actr_data = uic_data; endcase end",
            "assign actr_data = r_actr_data; // }}} // }}} end else begin : NO_ACCOUNTING_COUNTERS // {{{",
            "assign actr_stall = 1'b0;",
            "assign actr_data = 32'h0000;",
            "assign mtc_int = 1'b0;",
            "assign moc_int = 1'b0;",
            "assign mpc_int = 1'b0;",
            "assign mic_int = 1'b0;",
            "assign utc_int = 1'b0;",
            "assign uoc_int = 1'b0;",
            "assign upc_int = 1'b0;",
            "assign uic_int = 1'b0;",
            "assign actr_ack = sel_counter; // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // The DMA Controller // {{{ //////////////////////////////////////////////////////////////////////// // // assign dmac_int_vec = { 1'b0, alt_int_vector, 1'b0, main_int_vector[14:1], 1'b0 };",
            "assign dmac_stb = (sys_stb)&&(sel_dmac); generate if (OPT_DMA) begin : DMA // {{{ zipdma #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH), .LGMEMLEN(DMA_LGMEM), .OPT_REGISTER_RAM(!OPT_DISTRIBUTED_REGS), .BUS_WIDTH(DW), .OPT_LITTLE_ENDIAN(1'b0) // }}} ) dma_controller( // {{{ .i_clk(i_clk), .i_reset(cpu_reset), .i_swb_cyc(sys_cyc), .i_swb_stb(dmac_stb), .i_swb_we(sys_we), .i_swb_addr(sys_addr[1:0]), .i_swb_data(sys_data), .i_swb_sel(4'hf), .o_swb_stall(dmac_stall), .o_swb_ack(dmac_ack), .o_swb_data(dmac_data), // Need the outgoing DMAC wishbone bus .o_mwb_cyc(dc_cyc), .o_mwb_stb(dc_stb), .o_mwb_we(dc_we), .o_mwb_addr(dc_addr), .o_mwb_data(dc_data), .o_mwb_sel(dc_sel), .i_mwb_stall(dc_stall), .i_mwb_ack(dc_ack), .i_mwb_data(ext_idata), .i_mwb_err(dc_err), // External device interrupts .i_dev_ints(dmac_int_vec), // DMAC interrupt, for upon completion .o_interrupt(dmac_int) // }}} ); // }}} end else begin : NO_DMA // {{{",
            "reg r_dmac_ack;",
            "initial r_dmac_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_dmac_ack <= 1'b0; else r_dmac_ack <= (sys_cyc)&&(dmac_stb);",
            "assign dmac_ack = r_dmac_ack;",
            "assign dmac_data = 32'h000;",
            "assign dmac_stall = 1'b0;",
            "assign dc_cyc = 1'b0;",
            "assign dc_stb = 1'b0;",
            "assign dc_we = 1'b0;",
            "assign dc_addr = { (PAW) {1'b0} };",
            "assign dc_data = 32'h00;",
            "assign dc_sel = 4'h0;",
            "assign dmac_int = 1'b0; // Make Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused_dmac;",
            "assign unused_dmac = &{ 1'b0, dc_err, dc_ack, dc_stall, dmac_int_vec }; // Verilator lint_on UNUSED // }}} // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // The alternate interrupt controller // {{{ //////////////////////////////////////////////////////////////////////// // // assign ctri_sel = (sys_stb)&&(sel_apic); generate if (OPT_ACCOUNTING) begin : PIC_WITH_ACCOUNTING // // Interrupt controller // if (EXTERNAL_INTERRUPTS <= 9) begin : ALT_PIC icontrol #(8) ctri( // {{{ .i_clk(i_clk), .i_reset(cpu_reset), .i_wb_cyc(sys_cyc), .i_wb_stb(ctri_sel), .i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf), .o_wb_stall(ctri_stall), .o_wb_ack(ctri_ack), .o_wb_data(ctri_data), .i_brd_ints(alt_int_vector[7:0]), .o_interrupt(ctri_int) // }}} ); `ifdef VBENCH_TB",
            "assign alt_int_state = { 8'h0, ctri.r_int_state }; `endif end else begin : ALT_PIC icontrol #(8+(EXTERNAL_INTERRUPTS-9)) ctri( // {{{ .i_clk(i_clk), .i_reset(cpu_reset), .i_wb_cyc(sys_cyc), .i_wb_stb(ctri_sel), .i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf), .o_wb_stall(ctri_stall), .o_wb_ack(ctri_ack), .o_wb_data(ctri_data), .i_brd_ints(alt_int_vector[(EXTERNAL_INTERRUPTS-2):0]), .o_interrupt(ctri_int) // }}} ); `ifdef VBENCH_TB",
            "assign alt_int_state = { {(17-EXTERNAL_INTERRUPTS){1'b0}}, ctri.r_int_state }; `endif end end else begin : PIC_WITHOUT_ACCOUNTING if (EXTERNAL_INTERRUPTS <= 9) begin : ALT_PIC",
            "assign ctri_stall = 1'b0;",
            "assign ctri_data = 32'h0000;",
            "assign ctri_int = 1'b0; `ifdef VBENCH_TB",
            "assign alt_int_state = 16'h0; `endif end else begin : ALT_PIC icontrol #(EXTERNAL_INTERRUPTS-9) ctri( // {{{ .i_clk(i_clk), .i_reset(cpu_reset), .i_wb_cyc(sys_cyc), .i_wb_stb(ctri_sel), .i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf), .o_wb_stall(ctri_stall), .o_wb_ack(ctri_ack), .o_wb_data(ctri_data), .i_brd_ints(alt_int_vector[(EXTERNAL_INTERRUPTS-10):0]), .o_interrupt(ctri_int) // }}} ); `ifdef VBENCH_TB",
            "assign alt_int_state = { {(25-EXTERNAL_INTERRUPTS){1'b0}}, ctri.r_int_state }; `endif end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Timers // {{{ //////////////////////////////////////////////////////////////////////// // // // Timer A // ziptimer u_timer_a( // {{{ .i_clk(i_clk), .i_reset(cpu_reset), .i_ce(!cmd_halt), .i_wb_cyc(sys_cyc), .i_wb_stb((sys_stb)&&(sel_timer)&&(sys_addr[1:0] == 2'b00)), .i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf), .o_wb_stall(tma_stall), .o_wb_ack(tma_ack), .o_wb_data(tma_data), .o_int(tma_int) // }}} ); // // Timer B // ziptimer u_timer_b( // {{{ .i_clk(i_clk), .i_reset(cpu_reset), .i_ce(!cmd_halt), .i_wb_cyc(sys_cyc), .i_wb_stb((sys_stb)&&(sel_timer)&&(sys_addr[1:0] == 2'b01)), .i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf), .o_wb_stall(tmb_stall), .o_wb_ack(tmb_ack), .o_wb_data(tmb_data), .o_int(tmb_int) // }}} ); // // Timer C // ziptimer u_timer_c( // {{{ .i_clk(i_clk), .i_reset(cpu_reset), .i_ce(!cmd_halt), .i_wb_cyc(sys_cyc), .i_wb_stb((sys_stb)&&(sel_timer)&&(sys_addr[1:0] == 2'b10)), .i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf), .o_wb_stall(tmc_stall), .o_wb_ack(tmc_ack), .o_wb_data(tmc_data), .o_int(tmc_int) // }}} ); // // JIFFIES // zipjiffies u_jiffies( // {{{ .i_clk(i_clk), .i_reset(cpu_reset), .i_ce(!cmd_halt), .i_wb_cyc(sys_cyc), .i_wb_stb((sys_stb)&&(sel_timer)&&(sys_addr[1:0] == 2'b11)), .i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf), .o_wb_stall(jif_stall), .o_wb_ack(jif_ack), .o_wb_data(jif_data), .o_int(jif_int) // }}} ); // }}} //////////////////////////////////////////////////////////////////////// // // The main (programmable) interrupt controller peripheral // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (EXTERNAL_INTERRUPTS < 9) begin : MAIN_PIC icontrol #(6+EXTERNAL_INTERRUPTS) pic( // {{{ i_clk, cpu_reset, sys_cyc, (sys_cyc)&&(sys_stb)&&(sel_pic),sys_we, sys_data, 4'hf, pic_stall, pic_ack, pic_data, main_int_vector[(6+EXTERNAL_INTERRUPTS-1):0], pic_interrupt // }}} ); `ifdef VBENCH_TB",
            "assign int_state = { {(10-EXTERNAL_INTERRUPTS){1'b0}}, pic.r_int_state }; `endif end else begin : MAIN_PIC icontrol #(15) pic( // {{{ i_clk, cpu_reset, sys_cyc, (sys_cyc)&&(sys_stb)&&(sel_pic),sys_we, sys_data, 4'hf, pic_stall, pic_ack, pic_data, main_int_vector[14:0], pic_interrupt // }}} ); `ifdef VBENCH_TB",
            "assign int_state = { 1'b0, pic.r_int_state }; `endif end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // The CPU itself // {{{ //////////////////////////////////////////////////////////////////////// // // assign cpu_clken = cmd_write || cmd_read || (dbg_stb && dbg_addr[6] == DBG_ADDR_CPU[1]); `ifdef FORMAL // {{{ (* anyseq *)",
            "reg f_cpu_halted, f_cpu_data, f_cpu_stall, f_cpu_break; (* anyseq *)",
            "reg [1:0] f_cpu_dbg_cc; (* anyseq *)",
            "reg [31:0] f_cpu_dbg_data;",
            "wire cpu_dbg_we;",
            "assign cpu_dbg_we = ((dbg_stb)&&(dbg_we) &&(dbg_addr[6:5] == DBG_ADDR_CPU));",
            "assign cpu_dbg_stall = f_cpu_stall && !f_cpu_halted;",
            "assign cpu_break = f_cpu_break;",
            "assign cpu_dbg_cc = f_cpu_dbg_cc;",
            "assign cpu_dbg_data = f_cpu_dbg_data;",
            "assign cpu_has_halted= f_cpu_halted; fdebug #( // {{{ .OPT_START_HALTED(START_HALTED), .OPT_DISTRIBUTED_RAM(OPT_DISTRIBUTED_REGS) // }}} ) fdbg ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_cpu_reset(cpu_reset), .i_halt(cpu_halt), .i_halted(f_cpu_halted), .i_clear_cache(cmd_clear_cache), .i_dbg_we(cmd_write), .i_dbg_",
            "reg (cmd_waddr), .i_dbg_data(cmd_wdata), .i_dbg_stall(cpu_dbg_stall), .i_dbg_break(cpu_break), .i_dbg_cc(cpu_dbg_cc) // }}} );",
            "always @(*) if (f_cpu_halted) assume(!cpu_gbl_cyc && !cpu_gbl_stb); // }}} `else zipwb #( // {{{ .RESET_ADDRESS(RESET_ADDRESS), .ADDRESS_WIDTH(VIRTUAL_ADDRESS_WIDTH), .BUS_WIDTH(BUS_WIDTH), .OPT_PIPELINED(OPT_PIPELINED), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_LGICACHE(OPT_LGICACHE), .OPT_LGDCACHE(OPT_LGDCACHE), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .IMPLEMENT_FPU(OPT_FPU), .OPT_CIS(OPT_CIS), .OPT_LOCK(OPT_LOCK), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_START_HALTED(START_HALTED), .OPT_SIM(OPT_SIM), .OPT_DBGPORT(OPT_DBGPORT), .OPT_TRACE_PORT(OPT_TRACE_PORT), .OPT_PROFILER(OPT_PROFILER), .OPT_CLKGATE(OPT_CLKGATE), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_USERMODE(OPT_USERMODE), .WITH_LOCAL_BUS(1'b1) // }}} ) thecpu( // {{{ .i_clk(i_clk), .i_reset(cpu_reset), .i_interrupt(pic_interrupt), .i_cpu_clken(cpu_clken), // Debug interface // {{{ .i_halt(cpu_halt), .i_clear_cache(cmd_clear_cache), .i_dbg_w",
            "reg (cmd_waddr), .i_dbg_we(cmd_write), .i_dbg_data(cmd_wdata), .i_dbg_r",
            "reg (dbg_addr[4:0]), .o_dbg_stall(cpu_dbg_stall), .o_halted(cpu_has_halted), .o_dbg_",
            "reg (cpu_dbg_data), .o_dbg_cc(cpu_dbg_cc), .o_break(cpu_break), // }}} // Wishbone bus interface // {{{ .o_wb_gbl_cyc(cpu_gbl_cyc), .o_wb_gbl_stb(cpu_gbl_stb), .o_wb_lcl_cyc(cpu_lcl_cyc), .o_wb_lcl_stb(cpu_lcl_stb), .o_wb_we(cpu_we), .o_wb_addr(cpu_addr), .o_wb_data(cpu_data), .o_wb_sel(cpu_sel), // Return values from the Wishbone bus .i_wb_stall(cpu_stall), .i_wb_ack(cpu_ack), .i_wb_data(cpu_idata), .i_wb_err(cpu_err), // }}} .o_op_stall(cpu_op_stall), .o_pf_stall(cpu_pf_stall), .o_i_count(cpu_i_count), .o_debug(o_cpu_debug), // .o_prof_stb(o_prof_stb), .o_prof_addr(o_prof_addr), .o_prof_ticks(o_prof_ticks) // }}} ); `endif // }}} //////////////////////////////////////////////////////////////////////// // // The (unused) MMU // {{{ //////////////////////////////////////////////////////////////////////// // // // The mmu_cpu_ lines are the return bus lines from the MMU. They // are separate from the cpu_'s lines simply because either the sys_ // (local) bus or the mmu_cpu_ (global) bus might return a response to // the CPU, and the responses haven't been merged back together again // yet. `ifdef OPT_MMU // Ok ... here's the MMU zipmmu #( // {{{ .LGTBL(LGTLBSZ), .ADDRESS_WIDTH(PHYSICAL_ADDRESS_WIDTH) // }}} ) themmu( // {{{ i_clk, cpu_reset, // Slave interface (sys_stb)&&(sel_mmus), sys_we, sys_addr[7:0], sys_data, mmus_stall, mmus_ack, mmus_data, // CPU global bus master lines cpu_gbl_cyc, cpu_gbl_stb, cpu_we, cpu_addr, cpu_data, cpu_sel, // MMU bus master outgoing lines mmu_cyc, mmu_stb, mmu_we, mmu_addr, mmu_data, mmu_sel, // .... and the return from the slave(s) mmu_stall, mmu_ack, mmu_err, mmu_idata, // CPU gobal bus master return lines mmu_cpu_stall, mmu_cpu_ack, cpu_err, cpu_miss, mmu_cpu_idata, pf_return_stb, pf_return_we, pf_return_p, pf_return_v, pf_return_cachable // }}} ); `else",
            "reg r_mmus_ack;",
            "assign mmu_cyc = cpu_gbl_cyc;",
            "assign mmu_stb = cpu_gbl_stb;",
            "assign mmu_we = cpu_we;",
            "assign mmu_addr = cpu_addr;",
            "assign mmu_data = cpu_data;",
            "assign mmu_sel = cpu_sel;",
            "assign cpu_miss = 1'b0;",
            "assign cpu_err = (mmu_err)&&(cpu_gbl_cyc);",
            "assign mmu_cpu_idata = mmu_idata;",
            "assign mmu_cpu_stall = mmu_stall;",
            "assign mmu_cpu_ack = mmu_ack;",
            "initial r_mmus_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_mmus_ack <= 1'b0; else r_mmus_ack <= (sys_stb)&&(sys_addr[7]);",
            "assign mmus_ack = r_mmus_ack;",
            "assign mmus_stall = 1'b0;",
            "assign mmus_data = 32'h0;",
            "assign pf_return_stb = 0;",
            "assign pf_return_v = 0;",
            "assign pf_return_p = 0;",
            "assign pf_return_we = 0;",
            "assign pf_return_cachable = 0; `endif // // Responses from the MMU still need to be merged/muxed back together // with the responses from the local bus",
            "assign cpu_ack = ((cpu_lcl_cyc)&&(sys_ack)) ||((cpu_gbl_cyc)&&(mmu_cpu_ack));",
            "assign cpu_stall = ((cpu_lcl_cyc)&&(sys_stall)) ||((cpu_gbl_cyc)&&(mmu_cpu_stall));",
            "assign cpu_idata = (cpu_gbl_cyc)?mmu_cpu_idata : { {(BUS_WIDTH-DBG_WIDTH){1'b0}}, sys_idata }; // The following lines (will be/) are used to allow the prefetch to // snoop on any external interaction. Until this capability is // integrated into the CPU, they are unused. Here we tell Verilator // not to be surprised that these lines are unused: // }}} //////////////////////////////////////////////////////////////////////// // // The internal sys bus // {{{ //////////////////////////////////////////////////////////////////////// // // // Now, arbitrate the bus ... first for the local peripherals // For the debugger to have access to the local system bus, the // following must be true: // (dbg_cyc) The debugger must request the bus // (!cpu_lcl_cyc) The CPU cannot be using it (CPU gets priority) // (dbg_addr) The debugger must be requesting its data // reg ister, not just the control",
            "reg ister // and one of two other things. Either // ((cpu_halt)&&(!cpu_dbg_stall)) the CPU is completely halted, // or // (dbg_addr[6:5]==2'b01) we are trying to read a CPU",
            "reg ister // while in motion. Let the user beware that, // by not waiting for the CPU to fully halt, // his results may not be what he expects. // assign sys_cyc = (cpu_lcl_cyc)||(dbg_cyc);",
            "assign sys_stb = (cpu_lcl_cyc) ? (cpu_lcl_stb) : ((dbg_stb)&&(dbg_addr[6:5]==DBG_ADDR_SYS));",
            "assign sys_we = (cpu_lcl_cyc) ? cpu_we : dbg_we;",
            "assign sys_addr= (cpu_lcl_cyc) ? cpu_addr[7:0] : { 3'h0, dbg_addr[4:0]};",
            "assign sys_data= (cpu_lcl_cyc) ? cpu_data[DBG_WIDTH-1:0] : dbg_idata; // tmr_data // {{{",
            "always @(*) begin case(sys_addr[1:0]) 2'b00: tmr_data = tma_data; 2'b01: tmr_data = tmb_data; 2'b10: tmr_data = tmc_data; 2'b11: tmr_data = jif_data; endcase // tmr_ack == sys_stb && sel_timer end // }}} // last_sys_stb // {{{",
            "initial last_sys_stb = 0;",
            "always @(posedge i_clk) if (i_reset) last_sys_stb <= 0; else last_sys_stb <= sys_stb; // }}} // sys_ack, sys_idata // {{{",
            "always @(posedge i_clk) begin case(ack_idx) 3'h0: { sys_ack, sys_idata } <= { mmus_ack, mmus_data }; 3'h1: { sys_ack, sys_idata } <= { last_sys_stb, wdt_data }; 3'h2: { sys_ack, sys_idata } <= { last_sys_stb, wdbus_data }; 3'h3: { sys_ack, sys_idata } <= { last_sys_stb, ctri_data };// A-PIC 3'h4: { sys_ack, sys_idata } <= { last_sys_stb, tmr_data }; 3'h5: { sys_ack, sys_idata } <= { last_sys_stb, actr_data };//countr 3'h6: { sys_ack, sys_idata } <= { dmac_ack, dmac_data }; 3'h7: { sys_ack, sys_idata } <= { last_sys_stb, pic_data }; endcase if (i_reset || !sys_cyc) sys_ack <= 1'b0; end // }}} // w_ack_idx // {{{",
            "always @(*) begin w_ack_idx = 0; if (sel_mmus) w_ack_idx = w_ack_idx | 3'h0; if (sel_watchdog) w_ack_idx = w_ack_idx | 3'h1; if (sel_bus_watchdog) w_ack_idx = w_ack_idx | 3'h2; if (sel_apic) w_ack_idx = w_ack_idx | 3'h3; if (sel_timer) w_ack_idx = w_ack_idx | 3'h4; if (sel_counter) w_ack_idx = w_ack_idx | 3'h5; if (sel_dmac) w_ack_idx = w_ack_idx | 3'h6; if (sel_pic) w_ack_idx = w_ack_idx | 3'h7; end // }}} // ack_idx // {{{",
            "always @(posedge i_clk) if (sys_stb) ack_idx <= w_ack_idx; // }}}",
            "assign sys_stall = 1'b0; // }}} //////////////////////////////////////////////////////////////////////// // // Return debug response values // {{{ //////////////////////////////////////////////////////////////////////// // // reg dbg_pre_ack;",
            "reg [1:0] dbg_pre_addr;",
            "reg [DBG_WIDTH-1:0] dbg_cpu_status;",
            "always @(posedge i_clk) dbg_pre_addr <= dbg_addr[6:5];",
            "always @(posedge i_clk) dbg_cpu_status <= cpu_status;",
            "initial dbg_pre_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !i_dbg_cyc) dbg_pre_ack <= 1'b0; else dbg_pre_ack <= dbg_stb && !dbg_stall && !dbg_cpu_read; // A return from one of three busses: // CMD giving command instructions to the CPU (step, halt, etc) // CPU-DBG-DATA internal",
            "reg ister responses from within the CPU // sys Responses from the front-side bus here in the ZipSystem // assign dbg_odata = (!dbg_addr) ? cpu_status // :((!cmd_addr[5])?cpu_dbg_data : sys_idata);",
            "initial dbg_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !dbg_cyc) dbg_ack <= 1'b0; else dbg_ack <= dbg_pre_ack || cmd_read_ack;",
            "always @(posedge i_clk) if (!OPT_LOWPOWER || (dbg_cyc && (dbg_pre_ack || cmd_read))) casez(dbg_pre_addr) DBG_ADDR_CPU: dbg_odata <= cpu_dbg_data; DBG_ADDR_CTRL: dbg_odata <= dbg_cpu_status; // DBG_ADDR_SYS: default: dbg_odata <= sys_idata; endcase",
            "assign dbg_stall = cmd_read || (cmd_write && cpu_dbg_stall && dbg_addr[6:5] == DBG_ADDR_CPU) ||(dbg_addr[6]==DBG_ADDR_SYS[1] && cpu_lcl_cyc); // }}} //////////////////////////////////////////////////////////////////////// // // Arbitrate between CPU and DMA // {{{ //////////////////////////////////////////////////////////////////////// // // // Now for the external wishbone bus // Need to arbitrate between the flash cache and the CPU // The way this works, though, the CPU will stall once the flash // cache gets access to the bus--the CPU will be stuck until the // flash cache is finished with the bus. wbpriarbiter #( // {{{ .DW(BUS_WIDTH), .AW(PAW) // }}} ) dmacvcpu( // {{{ i_clk, mmu_cyc, mmu_stb, mmu_we, mmu_addr, mmu_data, mmu_sel, mmu_stall, mmu_ack, mmu_err, dc_cyc, dc_stb, dc_we, dc_addr, dc_data, dc_sel, dc_stall, dc_ack, dc_err, ext_cyc, ext_stb, ext_we, ext_addr, ext_odata, ext_sel, ext_stall, ext_ack, ext_err // }}} );",
            "assign mmu_idata = ext_idata; /* assign ext_cyc = mmu_cyc;",
            "assign ext_stb = mmu_stb;",
            "assign ext_we = mmu_we;",
            "assign ext_odata= mmu_data;",
            "assign ext_addr = mmu_addr;",
            "assign ext_sel = mmu_sel;",
            "assign mmu_ack = ext_ack;",
            "assign mmu_stall= ext_stall;",
            "assign mmu_err = ext_err; */ // }}} //////////////////////////////////////////////////////////////////////// // // Delay access to the external bus by one clock (if necessary) // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (DELAY_EXT_BUS) begin : DELAY_EXTERNAL_BUS // {{{ busdelay #( // {{{ .AW(PAW), .DW(BUS_WIDTH), .DELAY_STALL(0) // }}} ) extbus( // {{{ i_clk, i_reset, ext_cyc, ext_stb, ext_we, ext_addr, ext_odata, ext_sel, ext_stall, ext_ack, ext_idata, ext_err, o_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, o_wb_sel, i_wb_stall, i_wb_ack, i_wb_data, (i_wb_err)||(wdbus_int) // }}} ); // }}} end else begin : NO_EXTERNAL_BUS_DELAY // {{{",
            "assign o_wb_cyc = ext_cyc;",
            "assign o_wb_stb = ext_stb;",
            "assign o_wb_we = ext_we;",
            "assign o_wb_addr = ext_addr;",
            "assign o_wb_data = ext_odata;",
            "assign o_wb_sel = ext_sel;",
            "assign ext_stall = i_wb_stall;",
            "assign ext_ack = i_wb_ack;",
            "assign ext_idata = i_wb_data;",
            "assign ext_err = (i_wb_err)||(wdbus_int); // }}} end endgenerate // }}}",
            "assign o_ext_int = (cmd_halt) && (!cpu_stall); //////////////////////////////////////////////////////////////////////// // // Simulation only accesses, to make the simulation display work // {{{ //////////////////////////////////////////////////////////////////////// // // `ifdef VBENCH_TB // {{{",
            "assign early_branch = thecpu.core.dcd_early_branch;",
            "assign early_branch_pc = thecpu.core.dcd_branch_pc;",
            "assign dcdA = thecpu.core.dcd_full_A;",
            "assign dcdB = thecpu.core.dcd_full_B;",
            "assign new_pc = thecpu.core.new_pc;",
            "assign cpu_ipc= thecpu.core.ipc;",
            "assign cpu_upc= thecpu.core.upc;",
            "assign pf_pc = thecpu.core.pf_pc;",
            "assign cpu_interrupt = pic_interrupt;",
            "assign pf_cyc = thecpu.pf_cyc;",
            "assign pf_stb = thecpu.pf_stb;",
            "assign pf_we = thecpu.pf_we;",
            "assign pf_addr= { thecpu.pf_addr, 2'b00 };",
            "assign pf_ack = thecpu.pf_ack;",
            "assign pf_valid = thecpu.pf_valid;",
            "assign pf_illegal = thecpu.pf_illegal; // assign cpu_idata = thecpu.i_wb_data;",
            "assign pf_instruction = thecpu.pf_instruction;",
            "assign pf_instruction_pc = thecpu.pf_instruction_pc; generate if (OPT_PIPELINED) begin : GEN_PFORMEM_OWNER_PIPE",
            "assign pformem_owner = thecpu.PRIORITY_DATA.pformem.r_a_owner; end else begin : GEN_PFORMEM_OWNER",
            "assign pformem_owner = thecpu.PRIORITY_PREFETCH.pformem.r_a_owner; end endgenerate // // // Peeking into the decode stage // {{{",
            "assign dcd_ce = thecpu.core.dcd_ce;",
            "assign dcd_stalled = thecpu.core.dcd_stalled;",
            "assign dcd_gie = thecpu.core.dcd_gie;",
            "assign dcd_valid = thecpu.core.dcd_valid;",
            "assign dcd_illegal = thecpu.core.dcd_illegal;",
            "assign dcd_phase = thecpu.core.dcd_phase;",
            "assign dcd_break = thecpu.core.dcd_break;",
            "assign dcd_pipe = thecpu.core.dcd_pipe; // assign dcd_opn = thecpu.core.dcd_opn;",
            "assign dcd_rA = thecpu.core.dcd_rA;",
            "assign dcd_rB = thecpu.core.dcd_rB;",
            "assign dcd_wR = thecpu.core.dcd_wR;",
            "assign dcd_wF = thecpu.core.dcd_wF;",
            "assign dcdR = thecpu.core.instruction_decoder.w_dcdR;",
            "assign dcdRpc = thecpu.core.instruction_decoder.w_dcdR_pc;",
            "assign dcdRcc = thecpu.core.instruction_decoder.w_dcdR_cc;",
            "assign dcd_pc = thecpu.core.dcd_pc;",
            "assign dcd_M = thecpu.core.dcd_M; // }}} // Peeking into the op stage // {{{",
            "assign op_ce = thecpu.core.op_ce;",
            "assign op_illegal = thecpu.core.op_illegal;",
            "assign op_valid = thecpu.core.op_valid;",
            "assign op_valid_mem = thecpu.core.op_valid_mem;",
            "assign op_valid_alu = thecpu.core.op_valid_alu;",
            "assign op_stall = thecpu.core.op_stall;",
            "assign op_wR = thecpu.core.op_wR;",
            "assign op_wF = thecpu.core.op_wF;",
            "assign op_phase = thecpu.core.op_phase;",
            "assign op_gie = thecpu.core.op_gie;",
            "assign op_pipe = thecpu.core.op_pipe;",
            "assign op_R = thecpu.core.op_R;",
            "assign op_Aid = thecpu.core.op_Aid;",
            "assign op_Bid = thecpu.core.op_Bid;",
            "assign op_Av = thecpu.core.op_Av;",
            "assign op_Bv = thecpu.core.op_Bv;",
            "assign op_pc = thecpu.core.op_pc;",
            "assign master_stall = thecpu.core.master_stall;",
            "assign op_F = thecpu.core.op_F;",
            "assign op_pipe = thecpu.core.op_pipe;",
            "assign op_opn = thecpu.core.op_opn; // }}} // Peeking into the ALU stage // {{{",
            "assign alu_ce = thecpu.core.alu_ce;",
            "assign adf_ce_unconditional = thecpu.core.adf_ce_unconditional;",
            "assign alu_valid = thecpu.core.alu_valid;",
            "assign alu_wR = thecpu.core.alu_wR;",
            "assign alu_wF = thecpu.core.alu_wF;",
            "assign alu_pc_valid = thecpu.core.alu_pc_valid;",
            "assign alu_illegal = thecpu.core.alu_illegal;",
            "assign alu_gie = thecpu.core.alu_gie;",
            "assign set_cond = thecpu.core.set_cond;",
            "assign alu_phase = thecpu.core.alu_phase;",
            "assign alu_flags = thecpu.core.alu_flags;",
            "assign alu_pc = thecpu.core.alu_pc;",
            "assign alu_result = thecpu.core.alu_result;",
            "assign alu_busy = thecpu.core.alu_busy;",
            "assign alu_",
            "reg = thecpu.core.alu_",
            "reg ; // }}} // Peeking into the MEM stage // {{{ // assign mem_valid = thecpu.mem_valid;",
            "assign mem_pc_valid = thecpu.core.mem_pc_valid;",
            "assign mem_ce = thecpu.core.o_mem_ce;",
            "assign mem_busy = thecpu.core.i_mem_busy;",
            "assign mem_rdbusy = thecpu.core.i_mem_rdbusy;",
            "assign mem_w",
            "reg = thecpu.core.i_mem_w",
            "reg ; // }}} // Peeking into the divide stage // {{{",
            "assign div_valid = thecpu.core.div_valid;",
            "assign div_ce = thecpu.core.div_ce;",
            "assign div_busy = thecpu.core.div_busy; // }}} // Writeback stage // {{{",
            "assign wr_",
            "reg _id = thecpu.core.wr_",
            "reg _id;",
            "assign wr_",
            "reg _ce = thecpu.core.wr_",
            "reg _ce;",
            "assign wr_flags_ce = thecpu.core.wr_flags_ce;",
            "assign wr_gp",
            "reg _vl = thecpu.core.wr_gp",
            "reg _vl;",
            "assign wr_sp",
            "reg _vl = thecpu.core.wr_sp",
            "reg _vl;",
            "assign w_iflags = thecpu.core.w_iflags;",
            "assign w_uflags = thecpu.core.w_uflags; // }}} // Miscellaneous // {{{",
            "assign cpu_sim = thecpu.core.cpu_sim;",
            "assign cpu_sim_immv = thecpu.core.op_sim_immv;",
            "assign r_sleep = thecpu.core.sleep;",
            "assign master_ce = thecpu.core.master_ce;",
            "assign op_break = thecpu.core.op_break;",
            "assign r_gie = thecpu.core.gie; // }}} // // ZipSystem peripherals // {{{",
            "assign watchbus = { 18'h0, u_watchbus.r_value };",
            "assign watchdog = { 1'b0, u_watchdog.r_value };",
            "assign timer_a = tma_data;",
            "assign timer_b = tmb_data;",
            "assign timer_c = tmc_data;",
            "assign jiffies = jif_data; // assign wb_cyc_gbl = thecpu.mem_cyc_gbl;",
            "assign wb_stb_gbl = thecpu.mem_stb_gbl;",
            "assign wb_cyc_lcl = thecpu.mem_cyc_lcl;",
            "assign wb_stb_lcl = thecpu.mem_stb_lcl;",
            "assign mem_stb_gbl = thecpu.mem_stb_gbl;",
            "assign mem_stb_lcl = thecpu.mem_stb_lcl;",
            "assign mem_we = thecpu.mem_we;",
            "assign mem_ack = thecpu.mem_ack;",
            "assign mem_stall = thecpu.mem_stall;",
            "assign mem_data = thecpu.mem_data;",
            "assign mem_addr = { thecpu.core.o_mem_addr };",
            "assign mem_result = thecpu.mem_result;",
            "assign switch_to_interrupt = thecpu.core.w_switch_to_interrupt;",
            "assign release_from_interrupt = thecpu.core.w_release_from_interrupt;",
            "assign break_en = thecpu.core.break_en; // }}} `endif // }}} // Make Verilator happy // {{{ // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, cpu_dbg_cc[2], pic_ack, pic_stall, cpu_clken, tma_ack, tma_stall, tmb_ack, tmb_stall, tmc_ack, tmc_stall, jif_ack, jif_stall, no_dbg_err, dbg_sel, sel_mmus, ctri_ack, ctri_stall, mmus_stall, dmac_stall, wdt_ack, wdt_stall, actr_ack, actr_stall, wdbus_ack, i_dbg_sel, // moc_ack, mtc_ack, mic_ack, mpc_ack, // uoc_ack, utc_ack, uic_ack, upc_ack, // moc_stall, mtc_stall, mic_stall, mpc_stall, // uoc_stall, utc_stall, uic_stall, upc_stall, // Unused MMU pins pf_return_stb, pf_return_we, pf_return_p, pf_return_v, pf_return_cachable, cpu_miss }; // verilator lint_on UNUSED // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "wire [2:0] fdbg_nreqs, fdbg_nacks, fdbg_outstanding; fwb_slave #( // {{{ .AW(7), .DW(32), .F_LGDEPTH(3) // }}} ) dbg ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_wb_cyc(i_dbg_cyc), .i_wb_stb(i_dbg_stb), .i_wb_we(i_dbg_we), .i_wb_addr(i_dbg_addr), .i_wb_data(i_dbg_data), .i_wb_sel(i_dbg_sel), .i_wb_ack(o_dbg_ack), .i_wb_stall(o_dbg_stall), .i_wb_idata(o_dbg_data), .i_wb_err(1'b0), .f_nreqs(fdbg_nreqs), .f_nacks(fdbg_nacks), .f_outstanding(fdbg_outstanding) // }}} ); fwb_slave #( // {{{ .AW(32), .DW(32), .F_LGDEPTH(3) // }}} ) fwb_cpu ( // {{{ .i_clk(i_clk), .i_reset(cpu_reset), // .i_wb_cyc(i_dbg_cyc), .i_wb_stb(i_dbg_stb), .i_wb_we(i_dbg_we), .i_wb_addr(i_dbg_addr), .i_wb_data(i_dbg_data), .i_wb_sel(i_dbg_sel), .i_wb_ack(o_dbg_ack), .i_wb_stall(o_dbg_stall), .i_wb_idata(o_dbg_data), .i_wb_err(1'b0), .f_nreqs(fdbg_nreqs), .f_nacks(fdbg_nacks), .f_outstanding(fdbg_outstanding) // }}} ); fwb_master #( ) fsys ( .i_clk(i_clk), .i_reset(i_reset), ); `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipbones.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipbones.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipbones.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: In the spirit of keeping the Zip CPU small, this implements a // Zip System with no peripherals: Any peripherals you wish will // need to be implemented off-",
            "module . // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipbones #( // {{{",
            "parameter RESET_ADDRESS=32'h1000_0000, ADDRESS_WIDTH=32, parameter BUS_WIDTH=32, // Bus data width // CPU options // {{{",
            "parameter [0:0] OPT_PIPELINED=1, parameter [0:0] OPT_EARLY_BRANCHING=OPT_PIPELINED, // OPT_LGICACHE // {{{",
            "parameter OPT_LGICACHE = 2, // }}} // OPT_LGDCACHE // {{{ // Set to zero for no data cache",
            "parameter OPT_LGDCACHE = 0, // }}}",
            "parameter [0:0] START_HALTED=1, parameter [0:0] OPT_DISTRIBUTED_REGS=1, // OPT_MPY // {{{",
            "parameter OPT_MPY = 3, // }}} // OPT_DIV // {{{",
            "parameter [0:0] OPT_DIV=1, // }}} // OPT_SHIFTS // {{{",
            "parameter [0:0] OPT_SHIFTS = 1, // }}} // OPT_FPU // {{{",
            "parameter [0:0] OPT_FPU = 0, // }}}",
            "parameter [0:0] OPT_CIS=1, parameter [0:0] OPT_LOCK=1, parameter [0:0] OPT_USERMODE=1, parameter [0:0] OPT_DBGPORT=START_HALTED, parameter [0:0] OPT_TRACE_PORT=1, parameter [0:0] OPT_PROFILER=0, parameter [0:0] OPT_LOWPOWER=0, `ifdef VERILATOR",
            "parameter [0:0] OPT_SIM=1'b1, parameter [0:0] OPT_CLKGATE = OPT_LOWPOWER, `else",
            "parameter [0:0] OPT_SIM=1'b0, parameter [0:0] OPT_CLKGATE = 1'b0, `endif // }}}",
            "parameter RESET_DURATION = 10, // Short-cut names // {{{ // localparam AW=ADDRESS_WIDTH, localparam DBG_WIDTH=32, // Debug bus data width",
            "localparam // Derived",
            "parameter s // PHYSICAL_ADDRESS_WIDTH=ADDRESS_WIDTH, PAW=ADDRESS_WIDTH-$clog2(BUS_WIDTH/8) `ifdef OPT_MMU // VIRTUAL_ADDRESS_WIDTH=30, `else // VIRTUAL_ADDRESS_WIDTH=PAW, `endif // LGTLBSZ = 6, // VAW=VIRTUAL_ADDRESS_WIDTH, // }}} // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Wishbone master interface from the CPU // {{{",
            "output wire o_wb_cyc, o_wb_stb, o_wb_we, output wire [PAW-1:0] o_wb_addr, output wire [BUS_WIDTH-1:0] o_wb_data, output wire [BUS_WIDTH/8-1:0] o_wb_sel, input wire i_wb_stall, i_wb_ack, input wire [BUS_WIDTH-1:0] i_wb_data, input wire i_wb_err, // }}} // Incoming interrupts",
            "input wire i_ext_int, // Our one outgoing interrupt",
            "output wire o_ext_int, // Wishbone slave interface for debugging purposes // {{{",
            "input wire i_dbg_cyc, i_dbg_stb, i_dbg_we, input wire [5:0] i_dbg_addr, input wire [DBG_WIDTH-1:0] i_dbg_data, input wire [DBG_WIDTH/8-1:0] i_dbg_sel, output wire o_dbg_stall, output wire o_dbg_ack, output wire [DBG_WIDTH-1:0] o_dbg_data, // }}}",
            "output wire [31:0] o_cpu_debug, // `ifdef VBENCH_TB // {{{ // output wire cpu_halt, // cmd_reset, // cmd_step, output wire early_branch, output wire [31:0] early_branch_pc, output wire [6:0] dcdA, dcdB, output wire new_pc, output wire [31:0] cpu_ipc, cpu_upc, pf_pc, output wire pf_cyc, pf_stb, pf_we, output wire [31:0] pf_addr, output wire pf_ack, output wire pf_valid, pf_illegal, // pf_vmask, pf_r_v, pf_tagsrc, pf_tagipc, pf_tagvallst, // output wire [31:0] pf_lastpc, output wire [31:0] pf_instruction, output wire [31:0] pf_instruction_pc, // output wire dcd_ce, dcd_stalled, dcd_gie, dcd_valid, dcd_illegal, dcd_phase, dcd_break, dcd_pipe, output wire [3:0] dcd_opn, output wire dcd_rA, dcd_rB, dcd_wR, dcd_wF, output wire [4:0] dcdR, output wire dcdRpc, dcdRcc, output wire [31:0] dcd_pc, output wire dcd_M, // output wire op_ce, op_illegal, op_valid, op_valid_mem, op_valid_alu, op_stall, op_wR, op_wF, op_phase, op_gie, output wire [4:0] op_R, op_Aid, op_Bid, output wire [31:0] op_Av, op_Bv, op_pc, output wire master_stall, // output wire alu_ce, adf_ce_unconditional, alu_valid, alu_wR, alu_wF, alu_pc_valid, alu_illegal, alu_gie, set_cond, alu_phase, output wire [3:0] alu_flags, output wire [31:0] alu_pc, // output wire mem_valid, mem_pc_valid, mem_ce, mem_busy, mem_rdbusy, output wire [4:0] mem_w",
            "reg , // output wire div_valid, div_ce, div_busy, // output wire [4:0] wr_",
            "reg _id, output wire wr_",
            "reg _ce, wr_flags_ce, output wire [31:0] wr_gp",
            "reg _vl, wr_sp",
            "reg _vl, output wire [15:0] w_iflags, w_uflags, // output wire cpu_sim, r_sleep, master_ce, op_break, r_gie, output wire [22:0] cpu_sim_immv, output wire [7:0] op_F, // // // ZipSystem peripherals",
            "output wire [31:0] watchbus, watchdog, pic_data, wdbus_data, output wire [15:0] int_state, alt_int_state, output wire [31:0] timer_a, timer_b, timer_c, jiffies, utc_data, uoc_data, uic_data, upc_data, mtc_data, moc_data, mpc_data, mic_data, output wire wb_cyc_gbl, wb_cyc_lcl, wb_stb_gbl, wb_stb_lcl, mem_stb_gbl, mem_stb_lcl, mem_we, mem_ack, mem_stall, output wire [31:0] mem_data, mem_addr, mem_result, output wire op_pipe, // op_A_alu, op_B_alu, // op_A_mem, op_B_mem, output wire [3:0] op_opn, output wire [31:0] alu_result, output wire alu_busy, output wire [4:0] alu_",
            "reg , output wire switch_to_interrupt, release_from_interrupt, break_en, output wire pformem_owner, // }}} `endif",
            "output wire o_prof_stb, output wire [ADDRESS_WIDTH-1:0] o_prof_addr, output wire [31:0] o_prof_ticks // }}} ); // Declarations // {{{",
            "localparam [0:0] DBG_ADDR_CTRL = 1'b0, DBG_ADDR_CPU = 1'b1; // Debug bit allocations // {{{ // DBGCTRL // 5 DBG Catch -- Catch exceptions/fautls w/ debugger // 4 Clear cache // 3 RESET_FLAG // 2 STEP (W=1 steps, and returns to halted) // 1 HALT(ED) // 0 HALT // DBGDATA // read/writes internal",
            "reg isters // localparam HALT_BIT = 0, STEP_BIT = 2, RESET_BIT = 3, CLEAR_CACHE_BIT = 4, CATCH_BIT = 5; // }}}",
            "wire cpu_clken;",
            "wire dbg_cyc, dbg_stb, dbg_we, dbg_stall;",
            "wire [5:0] dbg_addr;",
            "wire [DBG_WIDTH-1:0] dbg_idata;",
            "wire [DBG_WIDTH/8-1:0] dbg_sel;",
            "reg [DBG_WIDTH-1:0] dbg_odata;",
            "reg dbg_ack;",
            "wire cpu_break, dbg_cmd_write, dbg_cpu_write, dbg_cpu_read;",
            "wire reset_hold, halt_on_fault, dbg_catch;",
            "wire reset_request, release_request, halt_request, step_request, clear_cache_request;",
            "reg cmd_reset, cmd_halt, cmd_step, cmd_clear_cache, cmd_write, cmd_read;",
            "reg [2:0] cmd_read_ack;",
            "reg [4:0] cmd_waddr;",
            "reg [DBG_WIDTH-1:0] cmd_wdata;",
            "wire [2:0] cpu_dbg_cc;",
            "wire cpu_reset, cpu_halt, cpu_dbg_stall, cpu_has_halted;",
            "wire cpu_lcl_cyc, cpu_lcl_stb, cpu_op_stall, cpu_pf_stall, cpu_i_count;",
            "wire [DBG_WIDTH-1:0] cpu_dbg_data;",
            "wire [DBG_WIDTH-1:0] cpu_status;",
            "wire [DBG_WIDTH-1:0] dbg_cmd_data;",
            "wire [DBG_WIDTH/8-1:0] dbg_cmd_strb;",
            "reg dbg_pre_ack;",
            "reg [DBG_WIDTH-1:0] dbg_cpu_status; // }}} //////////////////////////////////////////////////////////////////////// // // Debug bus signal renaming // {{{ //////////////////////////////////////////////////////////////////////// // // assign dbg_cyc = i_dbg_cyc;",
            "assign dbg_stb = i_dbg_stb;",
            "assign dbg_we = i_dbg_we;",
            "assign dbg_addr = i_dbg_addr;",
            "assign dbg_idata = i_dbg_data;",
            "assign dbg_sel = i_dbg_sel;",
            "assign o_dbg_ack = dbg_ack;",
            "assign o_dbg_stall = dbg_stall;",
            "assign o_dbg_data = dbg_odata; // }}} //////////////////////////////////////////////////////////////////////// // // The external debug interface // {{{ //////////////////////////////////////////////////////////////////////// // // assign dbg_cpu_write = OPT_DBGPORT && (dbg_stb && !dbg_stall && dbg_we) && (dbg_addr[5] == DBG_ADDR_CPU) && dbg_sel == 4'hf;",
            "assign dbg_cpu_read = (dbg_stb && !dbg_stall && !dbg_we && dbg_addr[5] == DBG_ADDR_CPU);",
            "assign dbg_cmd_write = (dbg_stb && !dbg_stall && dbg_we) &&(dbg_addr[5] == DBG_ADDR_CTRL);",
            "assign dbg_cmd_data = dbg_idata;",
            "assign dbg_cmd_strb = dbg_sel;",
            "assign reset_request = dbg_cmd_write && dbg_cmd_strb[RESET_BIT/8] && dbg_cmd_data[RESET_BIT];",
            "assign release_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8] && !dbg_cmd_data[HALT_BIT];",
            "assign halt_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8] && dbg_cmd_data[HALT_BIT];",
            "assign step_request = dbg_cmd_write && dbg_cmd_strb[STEP_BIT/8] && dbg_cmd_data[STEP_BIT];",
            "assign clear_cache_request = dbg_cmd_write && dbg_cmd_strb[CLEAR_CACHE_BIT/8] && dbg_cmd_data[CLEAR_CACHE_BIT]; // // reset_hold: Always start us off with an",
            "initial reset // {{{ generate if (RESET_DURATION > 0) begin : INITIAL_RESET_HOLD // {{{",
            "reg [$clog2(RESET_DURATION)-1:0] reset_counter;",
            "reg r_reset_hold;",
            "initial reset_counter = RESET_DURATION;",
            "always @(posedge i_clk) if (i_reset) reset_counter <= RESET_DURATION; else if (reset_counter > 0) reset_counter <= reset_counter - 1;",
            "initial r_reset_hold = 1;",
            "always @(posedge i_clk) if (i_reset) r_reset_hold <= 1; else r_reset_hold <= (reset_counter > 1);",
            "assign reset_hold = r_reset_hold; `ifdef FORMAL",
            "always @(*) assert(reset_hold == (reset_counter != 0)); `endif // }}} end else begin : NO_RESET_HOLD",
            "assign reset_hold = 0; end endgenerate // }}}",
            "assign halt_on_fault = dbg_catch; // cmd_reset // {{{ // Always start us off with an",
            "initial reset",
            "initial cmd_reset = 1'b1;",
            "always @(posedge i_clk) if (i_reset) cmd_reset <= 1'b1; else if (reset_hold) cmd_reset <= 1'b1; else if (cpu_break && !halt_on_fault) cmd_reset <= 1'b1; else cmd_reset <= reset_request; // }}} // cmd_halt // {{{",
            "initial cmd_halt = START_HALTED;",
            "always @(posedge i_clk) if (i_reset) cmd_halt <= START_HALTED; else if (cmd_reset && START_HALTED) cmd_halt <= START_HALTED; else begin // {{{ // When shall we release from a halt? Only if we have // come to a full and complete stop. Even then, we only // release if we aren't being given a command to step the CPU. // if (!cmd_write && cpu_has_halted && dbg_cmd_write && (release_request || step_request)) cmd_halt <= 1'b0; // Reasons to halt // 1. Halt on any unhandled CPU exception. The cause of the // exception must be cured before we can (re)start. // If the CPU is configured to start immediately on power // up, we leave it to reset on any exception instead. if (cpu_break && halt_on_fault) cmd_halt <= 1'b1; // 2. Halt on any user request to halt. (Only valid if the // STEP bit isn't also set) if (dbg_cmd_write && halt_request && !step_request) cmd_halt <= 1'b1; // 3. Halt on any user request to write to a CPU",
            "reg ister if (dbg_cpu_write) cmd_halt <= 1'b1; // 4. Halt following any step command if (cmd_step && !step_request) cmd_halt <= 1'b1; // 5. Halt following any clear cache if (cmd_clear_cache) cmd_halt <= 1'b1; // 6. Halt on any clear cache bit--independent of any step bit if (clear_cache_request) cmd_halt <= 1'b1; // }}} end // }}} // cmd_clear_cache // {{{",
            "initial cmd_clear_cache = 1'b0;",
            "always @(posedge i_clk) if (i_reset || cpu_reset) cmd_clear_cache <= 1'b0; else if (dbg_cmd_write && clear_cache_request && halt_request) cmd_clear_cache <= 1'b1; else if (cmd_halt && !cpu_dbg_stall) cmd_clear_cache <= 1'b0; // }}} // cmd_step // {{{",
            "initial cmd_step = 1'b0;",
            "always @(posedge i_clk) if (i_reset) cmd_step <= 1'b0; else if (cmd_reset || cpu_break || reset_request || clear_cache_request || cmd_clear_cache || halt_request || dbg_cpu_write) cmd_step <= 1'b0; else if (!cmd_write && cpu_has_halted && step_request) cmd_step <= 1'b1; else // if (cpu_dbg_stall) cmd_step <= 1'b0; `ifdef FORMAL // While STEP is true, we can't halt",
            "always @(*) if (!i_reset && cmd_step) assert(!cmd_halt); `endif // }}} // dbg_catch // {{{ generate if (!OPT_DBGPORT) begin : NO_DBG_CATCH",
            "assign dbg_catch = START_HALTED; end else begin : GEN_DBG_CATCH",
            "reg r_dbg_catch;",
            "initial r_dbg_catch = START_HALTED;",
            "always @(posedge i_clk) if (i_reset) r_dbg_catch <= START_HALTED; else if (dbg_cmd_write && dbg_cmd_strb[CATCH_BIT/8]) r_dbg_catch <= dbg_cmd_data[CATCH_BIT];",
            "assign dbg_catch = r_dbg_catch; end endgenerate // }}}",
            "assign cpu_reset = (cmd_reset);",
            "assign cpu_halt = (cmd_halt); // cpu_status // {{{ // 0xffff_f000 -> (Unused / reserved) // // 0x0000_0800 -> cpu_break // 0x0000_0400 -> Interrupt pending // 0x0000_0200 -> User mode // 0x0000_0100 -> Sleep (CPU is sleeping) // // 0x0000_00c0 -> (Unused/reserved) // 0x0000_0020 -> dbg_catch // 0x0000_0010 -> cmd_clear_cache // // 0x0000_0008 -> Reset // 0x0000_0004 -> Step (auto clearing, write only) // 0x0000_0002 -> Halt (status) // 0x0000_0001 -> Halt (request)",
            "assign cpu_status = { 16'h0, 4'h0, cpu_break, i_ext_int, cpu_dbg_cc[1:0], 2'h0, dbg_catch, 1'b0, cmd_reset, 1'b0, !cpu_dbg_stall, cmd_halt }; // }}} // cmd_write // {{{",
            "initial cmd_write = 0;",
            "always @(posedge i_clk) if (i_reset || cpu_reset) cmd_write <= 1'b0; else if (!cmd_write || cpu_has_halted) cmd_write <= dbg_cpu_write; // }}} // cmd_read // {{{",
            "initial cmd_read = 0;",
            "always @(posedge i_clk) if (i_reset || !dbg_cyc || !OPT_DBGPORT) cmd_read <= 1'b0; else if (dbg_cpu_read) cmd_read <= 1'b1; else if (cmd_read_ack == 1) cmd_read <= 1'b0;",
            "initial cmd_read_ack = 0;",
            "always @(posedge i_clk) if (i_reset || !dbg_cyc || !OPT_DBGPORT) cmd_read_ack <= 0; else if (dbg_cpu_read) cmd_read_ack <= 2 + (OPT_DISTRIBUTED_REGS ? 0:1); else if (cmd_read_ack > 0) cmd_read_ack <= cmd_read_ack - 1; // }}} // cmd_waddr, cmd_wdata // {{{",
            "always @(posedge i_clk) if ((!cmd_write || cpu_has_halted) && dbg_cpu_write) begin cmd_waddr <= dbg_addr[4:0]; cmd_wdata <= dbg_idata; end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // The CPU itself // {{{ //////////////////////////////////////////////////////////////////////// // // assign cpu_clken = cmd_write || cmd_read || dbg_cyc; `ifdef FORMAL // {{{ (* anyseq *)",
            "reg f_cpu_halted, f_cpu_data, f_cpu_stall, f_cpu_break; (* anyseq *)",
            "reg [2:0] f_cpu_dbg_cc; (* anyseq *)",
            "reg [31:0] f_cpu_dbg_data;",
            "assign cpu_dbg_stall = f_cpu_stall && !f_cpu_halted;",
            "assign cpu_break = f_cpu_break;",
            "assign cpu_dbg_cc = f_cpu_dbg_cc;",
            "assign cpu_dbg_data = f_cpu_dbg_data;",
            "assign cpu_has_halted= f_cpu_halted; fdebug #( // {{{ .OPT_START_HALTED(START_HALTED), .OPT_DISTRIBUTED_RAM(OPT_DISTRIBUTED_REGS) // }}} ) fdbg ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_cpu_reset(cpu_reset), .i_halt(cpu_halt), .i_halted(f_cpu_halted), .i_clear_cache(cmd_clear_cache), .i_dbg_we(cmd_write), .i_dbg_",
            "reg (cmd_waddr), .i_dbg_data(cmd_wdata), .i_dbg_stall(cpu_dbg_stall), .i_dbg_break(cpu_break), .i_dbg_cc(cpu_dbg_cc) // }}} ); // }}} `else zipwb #( // {{{ .RESET_ADDRESS(RESET_ADDRESS), .ADDRESS_WIDTH(ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)), .BUS_WIDTH(BUS_WIDTH), .OPT_PIPELINED(OPT_PIPELINED), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_LGICACHE(OPT_LGICACHE), .OPT_LGDCACHE(OPT_LGDCACHE), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .IMPLEMENT_FPU(OPT_FPU), .OPT_CIS(OPT_CIS), .OPT_LOCK(OPT_LOCK), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_START_HALTED(START_HALTED), .OPT_SIM(OPT_SIM), .OPT_DBGPORT(OPT_DBGPORT), .OPT_TRACE_PORT(OPT_TRACE_PORT), .OPT_PROFILER(OPT_PROFILER), .OPT_CLKGATE(OPT_CLKGATE), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_USERMODE(OPT_USERMODE), .WITH_LOCAL_BUS(0) // }}} ) thecpu( // {{{ .i_clk(i_clk), .i_reset(cpu_reset), .i_interrupt(i_ext_int), .i_cpu_clken(cpu_clken), // Debug interface // {{{ .i_halt(cpu_halt), .i_clear_cache(cmd_clear_cache), .i_dbg_w",
            "reg (cmd_waddr), .i_dbg_we(cmd_write), .i_dbg_data(cmd_wdata), .i_dbg_r",
            "reg (dbg_addr[4:0]), .o_dbg_stall(cpu_dbg_stall), .o_halted(cpu_has_halted), .o_dbg_",
            "reg (cpu_dbg_data), .o_dbg_cc(cpu_dbg_cc), .o_break(cpu_break), // }}} // Wishbone bus interface // {{{ .o_wb_gbl_cyc(o_wb_cyc), .o_wb_gbl_stb(o_wb_stb), .o_wb_lcl_cyc(cpu_lcl_cyc), .o_wb_lcl_stb(cpu_lcl_stb), .o_wb_we(o_wb_we), .o_wb_addr(o_wb_addr), .o_wb_data(o_wb_data), .o_wb_sel(o_wb_sel), // Return values from the Wishbone bus .i_wb_stall(i_wb_stall), .i_wb_ack(i_wb_ack), .i_wb_data(i_wb_data), .i_wb_err((i_wb_err)||(cpu_lcl_cyc)), // }}} .o_op_stall(cpu_op_stall), .o_pf_stall(cpu_pf_stall), .o_i_count(cpu_i_count), .o_debug(o_cpu_debug), // .o_prof_stb(o_prof_stb), .o_prof_addr(o_prof_addr), .o_prof_ticks(o_prof_ticks) // }}} ); `endif // }}} //////////////////////////////////////////////////////////////////////// // // Return debug response values // {{{ //////////////////////////////////////////////////////////////////////// // // // always @(posedge i_clk) // dbg_pre_addr <= dbg_addr[5];",
            "always @(posedge i_clk) dbg_cpu_status <= cpu_status;",
            "initial dbg_pre_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !i_dbg_cyc) dbg_pre_ack <= 1'b0; else dbg_pre_ack <= dbg_stb && !dbg_stall && !dbg_cpu_read;",
            "initial dbg_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !i_dbg_cyc) dbg_ack <= 1'b0; else dbg_ack <= dbg_pre_ack || (cmd_read_ack == 1);",
            "always @(posedge i_clk) if (!OPT_LOWPOWER || dbg_pre_ack || cmd_read) begin if (cmd_read) dbg_odata <= cpu_dbg_data; else dbg_odata <= dbg_cpu_status; end",
            "assign dbg_stall = cmd_read || (cmd_write && cpu_dbg_stall && dbg_addr[5] == DBG_ADDR_CPU); // }}}",
            "assign o_ext_int = (cmd_halt) && (!i_wb_stall); //////////////////////////////////////////////////////////////////////// // // Simulation only accesses, to make the simulation display work // {{{ //////////////////////////////////////////////////////////////////////// // // `ifdef VBENCH_TB",
            "assign early_branch = thecpu.core.dcd_early_branch;",
            "assign early_branch_pc = thecpu.core.dcd_branch_pc;",
            "assign dcdA = thecpu.core.dcd_full_A;",
            "assign dcdB = thecpu.core.dcd_full_B;",
            "assign new_pc = thecpu.core.new_pc;",
            "assign cpu_ipc= thecpu.core.ipc;",
            "assign cpu_upc= thecpu.core.upc;",
            "assign pf_pc = thecpu.core.pf_pc;",
            "assign pf_cyc = thecpu.pf_cyc;",
            "assign pf_stb = thecpu.pf_stb;",
            "assign pf_we = thecpu.pf_we;",
            "assign pf_addr= { thecpu.pf_addr, 2'b00 };",
            "assign pf_ack = thecpu.pf_ack;",
            "assign pf_valid = thecpu.pf_valid;",
            "assign pf_illegal = thecpu.pf_illegal; // assign cpu_idata = thecpu.i_wb_data;",
            "assign pf_instruction = thecpu.pf_instruction;",
            "assign pf_instruction_pc = thecpu.pf_instruction_pc; generate if (OPT_PIPELINED) begin : GEN_PFORMEM_OWNER_DATA",
            "assign pformem_owner = thecpu.PRIORITY_DATA.pformem.r_a_owner; end else begin : GEN_PFORMEM_OWNER_FETCH",
            "assign pformem_owner = thecpu.PRIORITY_PREFETCH.pformem.r_a_owner; end endgenerate // // Peeking into the decode stage // {{{",
            "assign dcd_ce = thecpu.core.dcd_ce;",
            "assign dcd_stalled = thecpu.core.dcd_stalled;",
            "assign dcd_gie = thecpu.core.dcd_gie;",
            "assign dcd_valid = thecpu.core.dcd_valid;",
            "assign dcd_illegal = thecpu.core.dcd_illegal;",
            "assign dcd_phase = thecpu.core.dcd_phase;",
            "assign dcd_break = thecpu.core.dcd_break;",
            "assign dcd_pipe = thecpu.core.dcd_pipe; // assign dcd_opn = thecpu.core.dcd_opn;",
            "assign dcd_rA = thecpu.core.dcd_rA;",
            "assign dcd_rB = thecpu.core.dcd_rB;",
            "assign dcd_wR = thecpu.core.dcd_wR;",
            "assign dcd_wF = thecpu.core.dcd_wF;",
            "assign dcdR = thecpu.core.instruction_decoder.w_dcdR;",
            "assign dcdRpc = thecpu.core.instruction_decoder.w_dcdR_pc;",
            "assign dcdRcc = thecpu.core.instruction_decoder.w_dcdR_cc;",
            "assign dcd_pc = thecpu.core.dcd_pc;",
            "assign dcd_M = thecpu.core.dcd_M; // }}} // Peeking into the op stage // {{{",
            "assign op_ce = thecpu.core.op_ce;",
            "assign op_illegal = thecpu.core.op_illegal;",
            "assign op_valid = thecpu.core.op_valid;",
            "assign op_valid_mem = thecpu.core.op_valid_mem;",
            "assign op_valid_alu = thecpu.core.op_valid_alu;",
            "assign op_stall = thecpu.core.op_stall;",
            "assign op_wR = thecpu.core.op_wR;",
            "assign op_wF = thecpu.core.op_wF;",
            "assign op_phase = thecpu.core.op_phase;",
            "assign op_gie = thecpu.core.op_gie;",
            "assign op_pipe = thecpu.core.op_pipe;",
            "assign op_R = thecpu.core.op_R;",
            "assign op_Aid = thecpu.core.op_Aid;",
            "assign op_Bid = thecpu.core.op_Bid;",
            "assign op_Av = thecpu.core.op_Av;",
            "assign op_Bv = thecpu.core.op_Bv;",
            "assign op_pc = thecpu.core.op_pc;",
            "assign master_stall = thecpu.core.master_stall;",
            "assign op_F = thecpu.core.op_F;",
            "assign op_pipe = thecpu.core.op_pipe;",
            "assign op_opn = thecpu.core.op_opn; // }}} // Peeking into the ALU stage // {{{",
            "assign alu_ce = thecpu.core.alu_ce;",
            "assign adf_ce_unconditional = thecpu.core.adf_ce_unconditional;",
            "assign alu_valid = thecpu.core.alu_valid;",
            "assign alu_wR = thecpu.core.alu_wR;",
            "assign alu_wF = thecpu.core.alu_wF;",
            "assign alu_pc_valid = thecpu.core.alu_pc_valid;",
            "assign alu_illegal = thecpu.core.alu_illegal;",
            "assign alu_gie = thecpu.core.alu_gie;",
            "assign set_cond = thecpu.core.set_cond;",
            "assign alu_phase = thecpu.core.alu_phase;",
            "assign alu_flags = thecpu.core.alu_flags;",
            "assign alu_pc = thecpu.core.alu_pc;",
            "assign alu_result = thecpu.core.alu_result;",
            "assign alu_busy = thecpu.core.alu_busy;",
            "assign alu_",
            "reg = thecpu.core.alu_",
            "reg ; // }}} // Peeking into the MEM stage // {{{ // assign mem_valid = thecpu.mem_valid;",
            "assign mem_pc_valid = thecpu.core.mem_pc_valid;",
            "assign mem_ce = thecpu.core.o_mem_ce;",
            "assign mem_busy = thecpu.core.i_mem_busy;",
            "assign mem_rdbusy = thecpu.core.i_mem_rdbusy;",
            "assign mem_w",
            "reg = thecpu.core.i_mem_w",
            "reg ; // }}} // Peeking into the divide stage // {{{",
            "assign div_valid = thecpu.core.div_valid;",
            "assign div_ce = thecpu.core.div_ce;",
            "assign div_busy = thecpu.core.div_busy; // }}} // Writeback stage // {{{",
            "assign wr_",
            "reg _id = thecpu.core.wr_",
            "reg _id;",
            "assign wr_",
            "reg _ce = thecpu.core.wr_",
            "reg _ce;",
            "assign wr_flags_ce = thecpu.core.wr_flags_ce;",
            "assign wr_gp",
            "reg _vl = thecpu.core.wr_gp",
            "reg _vl;",
            "assign wr_sp",
            "reg _vl = thecpu.core.wr_sp",
            "reg _vl;",
            "assign w_iflags = thecpu.core.w_iflags;",
            "assign w_uflags = thecpu.core.w_uflags; // }}} // Miscellaneous // {{{",
            "assign cpu_sim = thecpu.core.cpu_sim;",
            "assign cpu_sim_immv = thecpu.core.op_sim_immv;",
            "assign r_sleep = thecpu.core.sleep;",
            "assign master_ce = thecpu.core.master_ce;",
            "assign op_break = thecpu.core.op_break;",
            "assign r_gie = thecpu.core.gie; // }}} // // ZipSystem peripherals // {{{",
            "assign watchbus = 32'h0;",
            "assign watchdog = 32'h0;",
            "assign timer_a = 32'h0;",
            "assign timer_b = 32'h0;",
            "assign timer_c = 32'h0;",
            "assign jiffies = 32'h0;",
            "assign wdbus_data = 32'h0;",
            "assign pic_data = 32'h0;",
            "assign utc_data = 32'h0;",
            "assign uoc_data = 32'h0;",
            "assign upc_data = 32'h0;",
            "assign uic_data = 32'h0;",
            "assign mtc_data = 32'h0;",
            "assign moc_data = 32'h0;",
            "assign mpc_data = 32'h0;",
            "assign mic_data = 32'h0; // assign int_state = 16'h0;",
            "assign alt_int_state = 16'h0;",
            "assign wb_cyc_gbl = thecpu.mem_cyc_gbl;",
            "assign wb_stb_gbl = thecpu.mem_stb_gbl;",
            "assign wb_cyc_lcl = thecpu.mem_cyc_lcl;",
            "assign wb_stb_lcl = thecpu.mem_stb_lcl;",
            "assign mem_stb_gbl = thecpu.mem_stb_gbl;",
            "assign mem_stb_lcl = thecpu.mem_stb_lcl;",
            "assign mem_we = thecpu.mem_we;",
            "assign mem_ack = thecpu.mem_ack;",
            "assign mem_stall = thecpu.mem_stall;",
            "assign mem_data = thecpu.mem_data;",
            "assign mem_addr = { thecpu.core.o_mem_addr };",
            "assign mem_result = thecpu.mem_result;",
            "assign switch_to_interrupt = thecpu.core.w_switch_to_interrupt;",
            "assign release_from_interrupt = thecpu.core.w_release_from_interrupt;",
            "assign break_en = thecpu.core.break_en; // }}} `endif // }}} // Make Verilator happy // {{{ // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, dbg_cyc, cpu_lcl_stb, cpu_op_stall, cpu_dbg_cc[2], cpu_pf_stall, cpu_i_count }; // verilator lint_on UNUSED // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "localparam F_LGDEPTH = 3;",
            "reg [F_LGDEPTH-1:0] fwb_nreqs, fwb_nacks, fwb_outstanding;",
            "wire cpu_dbg_we;",
            "assign cpu_dbg_we = (dbg_stb && !dbg_stall && dbg_we &&(dbg_addr[5] == DBG_ADDR_CPU)); fwb_slave #( .AW(6), .DW(DBG_WIDTH), .F_LGDEPTH(F_LGDEPTH) ) fwb( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_wb_cyc(i_dbg_cyc), .i_wb_stb(i_dbg_stb && !o_dbg_stall), .i_wb_we(i_dbg_we), .i_wb_addr(i_dbg_addr), .i_wb_data(i_dbg_data), .i_wb_ack(o_dbg_ack), .i_wb_stall(o_dbg_stall), .i_wb_idata(o_dbg_data), .i_wb_err(1'b0), .f_nreqs(fwb_nreqs), .f_nacks(fwb_nacks), .f_outstanding(fwb_outstanding) // }}} );",
            "always @(*) if (i_dbg_cyc) begin if (cmd_read_ack > 0) begin assert(!dbg_pre_ack); assert(fwb_outstanding == 1 + (o_dbg_ack ? 1:0)); end else assert(fwb_outstanding == dbg_pre_ack + o_dbg_ack); end",
            "always @(posedge i_clk) if ($past(i_dbg_cyc && cpu_dbg_we)) assume(i_dbg_cyc); `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipaxi.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipaxi.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipaxi.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A potential top level",
            "module holding the core of the Zip CPU // together--this one with AXI4 instruction and data interfaces, // and an AXI-lite debug interfaces. In general, the Zip CPU is designed // to be as simple as possible. (actual implementation aside ...) The // instruction set is about as RISC as you can get, with only 26 // instruction types currently supported. (There are still 8-instruction // Op-Codes reserved for floating point, and 5 which can be used for // transactions not requiring",
            "reg isters.) Please see the accompanying // spec.pdf file for a description of these instructions. // // This version is bus width agnostic for both instruction and data buses, // although the debug bus must still be 32-bits. Instruction and data // buses must be at least 32-bits wide. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipaxi #( // {{{",
            "parameter C_DBG_ADDR_WIDTH = 8, localparam C_DBG_DATA_WIDTH = 32, localparam DBGLSB = $clog2(C_DBG_DATA_WIDTH/8), parameter ADDRESS_WIDTH = 32, parameter C_AXI_DATA_WIDTH = 32, parameter C_AXI_ID_WIDTH = 1, parameter INSN_ID = 0, parameter DATA_ID = 0, localparam AXILSB = $clog2(C_AXI_DATA_WIDTH/8), parameter OPT_LGICACHE = 0, parameter OPT_LGDCACHE = 0, parameter [0:0] OPT_PIPELINED = (OPT_LGICACHE>0), parameter [ADDRESS_WIDTH-1:0] RESET_ADDRESS={(ADDRESS_WIDTH){1'b0}}, parameter [0:0] START_HALTED = 1'b0, parameter [0:0] OPT_WRAP = 1'b1, parameter [0:0] SWAP_WSTRB = 1'b1, parameter OPT_MPY = 3, parameter [0:0] OPT_DIV = 1'b1, parameter [0:0] OPT_SHIFTS = 1'b1, parameter [0:0] OPT_LOCK = 1'b1, parameter [0:0] OPT_FPU = 0, parameter [0:0] OPT_EARLY_BRANCHING = 1, parameter [0:0] OPT_CIS = 1'b1, parameter [0:0] OPT_LOWPOWER = 1'b0, parameter [0:0] OPT_DISTRIBUTED_REGS = 1'b1, parameter [0:0] OPT_DBGPORT = START_HALTED, parameter [0:0] OPT_TRACE_PORT = 1'b0, parameter [0:0] OPT_PROFILER = 1'b0, parameter [0:0] OPT_USERMODE = 1'b1, parameter LGILINESZ= 3, parameter OPT_LGDLINESZ = 3, parameter RESET_DURATION = 10, // localparam [0:0] WITH_LOCAL_BUS = 1'b0, localparam AW=ADDRESS_WIDTH-2, `ifdef VERILATOR",
            "parameter [0:0] OPT_SIM = 1'b1, parameter [0:0] OPT_CLKGATE = OPT_LOWPOWER `else",
            "parameter [0:0] OPT_SIM = 1'b0, parameter [0:0] OPT_CLKGATE = 1'b0 `endif `ifdef FORMAL , parameter F_LGDEPTH=8 `endif // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, S_AXI_ARESETN, i_interrupt, i_cpu_reset, // Debug interface // {{{ // Debug interface --",
            "input s // input wire i_halt, i_clear_cache, // input wire [4:0] i_dbg_w",
            "reg , // input wire i_dbg_we, // input wire [31:0] i_dbg_data, // input wire [4:0] i_dbg_r",
            "reg , // Debug interface --",
            "output s // output wire cpu_dbg_stall, // output reg [31:0] o_dbg_",
            "reg , // output reg [2:0] o_dbg_cc, // output wire o_break, input wire S_DBG_AWVALID, output wire S_DBG_AWREADY, input wire [C_DBG_ADDR_WIDTH-1:0] S_DBG_AWADDR, // Verilator coverage_off",
            "input wire [2:0] S_DBG_AWPROT, // Verilator coverage_on // input wire S_DBG_WVALID, output wire S_DBG_WREADY, input wire [31:0] S_DBG_WDATA, input wire [3:0] S_DBG_WSTRB, // output reg S_DBG_BVALID, input wire S_DBG_BREADY, // Verilator coverage_off",
            "output wire [1:0] S_DBG_BRESP, // Verilator coverage_on // input wire S_DBG_ARVALID, output wire S_DBG_ARREADY, input wire [7:0] S_DBG_ARADDR, // Verilator coverage_off",
            "input wire [2:0] S_DBG_ARPROT, // Verilator coverage_on // output reg S_DBG_RVALID, input wire S_DBG_RREADY, output reg [31:0] S_DBG_RDATA, // Verilator coverage_off",
            "output wire [1:0] S_DBG_RRESP, // Verilator coverage_on // // }}} // Instruction bus (master) // {{{ // Verilator coverage_off",
            "output wire M_INSN_AWVALID, input wire M_INSN_AWREADY, output wire [C_AXI_ID_WIDTH-1:0] M_INSN_AWID, output wire [ADDRESS_WIDTH-1:0] M_INSN_AWADDR, output wire [7:0] M_INSN_AWLEN, output wire [2:0] M_INSN_AWSIZE, output wire [1:0] M_INSN_AWBURST, output wire M_INSN_AWLOCK, output wire [3:0] M_INSN_AWCACHE, output wire [2:0] M_INSN_AWPROT, output wire [3:0] M_INSN_AWQOS, // output wire M_INSN_WVALID, input wire M_INSN_WREADY, output wire [C_AXI_DATA_WIDTH-1:0] M_INSN_WDATA, output wire [C_AXI_DATA_WIDTH/8-1:0] M_INSN_WSTRB, output wire M_INSN_WLAST, // input wire M_INSN_BVALID, output wire M_INSN_BREADY, input wire [C_AXI_ID_WIDTH-1:0] M_INSN_BID, input wire [1:0] M_INSN_BRESP, // Verilator coverage_on // output wire M_INSN_ARVALID, input wire M_INSN_ARREADY, output wire [C_AXI_ID_WIDTH-1:0] M_INSN_ARID, output wire [ADDRESS_WIDTH-1:0] M_INSN_ARADDR, output wire [7:0] M_INSN_ARLEN, output wire [2:0] M_INSN_ARSIZE, output wire [1:0] M_INSN_ARBURST, output wire M_INSN_ARLOCK, output wire [3:0] M_INSN_ARCACHE, output wire [2:0] M_INSN_ARPROT, output wire [3:0] M_INSN_ARQOS, // input wire M_INSN_RVALID, output wire M_INSN_RREADY, input wire [C_AXI_ID_WIDTH-1:0] M_INSN_RID, input wire [C_AXI_DATA_WIDTH-1:0] M_INSN_RDATA, input wire M_INSN_RLAST, input wire [1:0] M_INSN_RRESP, // }}} // Data bus (master) // {{{",
            "output wire M_DATA_AWVALID, input wire M_DATA_AWREADY, output wire [C_AXI_ID_WIDTH-1:0] M_DATA_AWID, output wire [ADDRESS_WIDTH-1:0] M_DATA_AWADDR, output wire [7:0] M_DATA_AWLEN, output wire [2:0] M_DATA_AWSIZE, output wire [1:0] M_DATA_AWBURST, output wire M_DATA_AWLOCK, output wire [3:0] M_DATA_AWCACHE, // Verilator coverage_off",
            "output wire [2:0] M_DATA_AWPROT, // Verilator coverage_on",
            "output wire [3:0] M_DATA_AWQOS, // output wire M_DATA_WVALID, input wire M_DATA_WREADY, output wire [C_AXI_DATA_WIDTH-1:0] M_DATA_WDATA, output wire [C_AXI_DATA_WIDTH/8-1:0] M_DATA_WSTRB, output wire M_DATA_WLAST, // input wire M_DATA_BVALID, output wire M_DATA_BREADY, input wire [C_AXI_ID_WIDTH-1:0] M_DATA_BID, input wire [1:0] M_DATA_BRESP, // output wire M_DATA_ARVALID, input wire M_DATA_ARREADY, output wire [C_AXI_ID_WIDTH-1:0] M_DATA_ARID, output wire [ADDRESS_WIDTH-1:0] M_DATA_ARADDR, output wire [7:0] M_DATA_ARLEN, output wire [2:0] M_DATA_ARSIZE, output wire [1:0] M_DATA_ARBURST, output wire M_DATA_ARLOCK, output wire [3:0] M_DATA_ARCACHE, // Verilator coverage_off",
            "output wire [2:0] M_DATA_ARPROT, // Verilator coverage_on",
            "output wire [3:0] M_DATA_ARQOS, // input wire M_DATA_RVALID, output wire M_DATA_RREADY, input wire [C_AXI_ID_WIDTH-1:0] M_DATA_RID, input wire [C_AXI_DATA_WIDTH-1:0] M_DATA_RDATA, input wire M_DATA_RLAST, input wire [1:0] M_DATA_RRESP, // }}} // Accounting",
            "output s ... to help us count stalls and usage",
            "output wire o_cmd_reset, output wire o_halted, output wire o_gie, output wire o_op_stall, output wire o_pf_stall, output wire o_i_count, // output wire [31:0] o_cpu_debug, // output wire o_prof_stb, output wire [ADDRESS_WIDTH-1:0] o_prof_addr, output wire [31:0] o_prof_ticks // }}} ); // Declarations // {{{",
            "localparam [0:0] DBG_ADDR_CTRL = 1'b0, DBG_ADDR_CPU = 1'b1;",
            "localparam [0:0] OPT_PIPELINED_BUS_ACCESS = (OPT_PIPELINED)&&(OPT_LGDCACHE > 1);",
            "localparam [0:0] OPT_MEMPIPE = OPT_PIPELINED_BUS_ACCESS;",
            "localparam [0:0] OPT_DCACHE = (OPT_LGDCACHE > 4);",
            "localparam FETCH_LIMIT = (OPT_LGICACHE < 4) ? (1 << OPT_LGICACHE) : 16; // Debug bit allocations // {{{ // DBGCTRL // 5 DBG Catch -- Catch exceptions/faults w/ debugger // 4 Clear cache // 3 RESET_FLAG // 2 STEP (W=1 steps, and returns to halted) // 1 HALT(ED) // 0 HALT // DBGDATA // read/writes internal",
            "reg isters // localparam HALT_BIT = 0, STEP_BIT = 2, RESET_BIT = 3, CLEAR_CACHE_BIT = 4, CATCH_BIT = 5; // }}}",
            "localparam [0:0] OPT_ALIGNMENT_ERR = 1'b0;",
            "localparam [0:0] SWAP_ENDIANNESS = 1'b0; // AXI-lite signal handling // {{{",
            "wire awskd_valid, wskd_valid, arskd_valid;",
            "wire dbg_write_ready, dbg_read_ready;",
            "wire [C_DBG_ADDR_WIDTH-DBGLSB-1:0] awskd_addr, arskd_addr;",
            "wire [31:0] wskd_data;",
            "wire [3:0] wskd_strb;",
            "reg dbg_write_valid, dbg_read_valid;",
            "wire dbg_blkram_stall;",
            "reg [4:0] dbg_write_",
            "reg ;",
            "wire [4:0] dbg_read_",
            "reg ;",
            "reg [31:0] dbg_write_data;",
            "wire [31:0] dbg_read_data;",
            "wire cpu_dbg_stall, cpu_break, dbg_write_stall;",
            "wire [2:0] cpu_dbg_cc; // }}}",
            "wire reset_hold, halt_on_fault, dbg_catch;",
            "wire cpu_clken, cpu_clock, clk_gate;",
            "wire reset_request, release_request, halt_request, step_request, clear_cache_request;",
            "wire cpu_has_halted; // CPU control",
            "reg isters // {{{",
            "reg cmd_halt, cmd_reset, cmd_step, cmd_clear_cache;",
            "wire [31:0] cpu_status;",
            "wire dbg_cmd_write, dbg_cpu_write;",
            "wire [31:0] dbg_cmd_data;",
            "wire [3:0] dbg_cmd_strb; // }}} // Fetch // {{{",
            "wire pf_new_pc, clear_icache, pf_ready;",
            "wire [AW+1:0] pf_request_address;",
            "wire [31:0] pf_instruction;",
            "wire [AW+1:0] pf_instruction_pc;",
            "wire pf_valid, pf_illegal; // }}} // Memory // {{{",
            "wire clear_dcache, mem_ce, bus_lock;",
            "wire [2:0] mem_op;",
            "wire [31:0] mem_cpu_addr;",
            "wire [AW+1:0] mem_lock_pc;",
            "wire [31:0] mem_wdata;",
            "wire [4:0] mem_",
            "reg ;",
            "wire mem_busy, mem_rdbusy, mem_pipe_stalled, mem_valid, mem_bus_err;",
            "wire [4:0] mem_w",
            "reg ;",
            "wire [31:0] mem_result; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Debug signal handling // {{{ //////////////////////////////////////////////////////////////////////// // // // // Write signaling // {{{ skidbuffer #( // {{{ .OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(C_DBG_ADDR_WIDTH-DBGLSB) // }}} ) dbgawskd( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(S_DBG_AWVALID), .o_ready(S_DBG_AWREADY), .i_data(S_DBG_AWADDR[C_DBG_ADDR_WIDTH-1:DBGLSB]), .o_valid(awskd_valid), .i_ready(dbg_write_ready), .o_data(awskd_addr) // }}} ); skidbuffer #( // {{{ .OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(C_DBG_DATA_WIDTH+C_DBG_DATA_WIDTH/8) // }}} ) dbgwskd( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(S_DBG_WVALID), .o_ready(S_DBG_WREADY), .i_data({ S_DBG_WSTRB, S_DBG_WDATA }), .o_valid(wskd_valid), .i_ready(dbg_write_ready), .o_data({ wskd_strb, wskd_data }) // }}} );",
            "assign dbg_write_ready = awskd_valid && wskd_valid && ((wskd_strb==0) || awskd_addr[5] != DBG_ADDR_CPU || !dbg_write_stall) && (!S_DBG_BVALID || S_DBG_BREADY); // dbg_write_valid // {{{",
            "initial dbg_write_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !OPT_DBGPORT) dbg_write_valid <= 1'b0; else if (!dbg_write_stall) dbg_write_valid <= dbg_cpu_write; // }}} // dbg_write_",
            "reg // {{{",
            "always @(posedge S_AXI_ACLK) if (!dbg_write_stall) begin dbg_write_",
            "reg <= awskd_addr[4:0]; if (OPT_LOWPOWER && !dbg_cpu_write) dbg_write_",
            "reg <= 0; end // }}} // dbg_write_data // {{{",
            "always @(posedge S_AXI_ACLK) if (!dbg_write_stall) begin dbg_write_data <= wskd_data; if (OPT_LOWPOWER && !dbg_cpu_write) dbg_write_data <= 0; end // }}} // S_DBG_BVALID // {{{",
            "initial S_DBG_BVALID = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) S_DBG_BVALID <= 1'b0; else if (dbg_write_ready) S_DBG_BVALID <= 1'b1; else if (S_DBG_BREADY) S_DBG_BVALID <= 1'b0; // }}} // S_DBG_BRESP // {{{",
            "assign S_DBG_BRESP = 2'b00; // }}} // }}} // // Read signaling // {{{ skidbuffer #( // {{{ .OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(C_DBG_ADDR_WIDTH-DBGLSB) // }}} ) dbgarskd( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(S_DBG_ARVALID), .o_ready(S_DBG_ARREADY), .i_data(S_DBG_ARADDR[C_DBG_ADDR_WIDTH-1:DBGLSB]), .o_valid(arskd_valid), .i_ready(dbg_read_ready), .o_data(arskd_addr) // }}} );",
            "assign dbg_read_ready = arskd_valid && !dbg_blkram_stall && (!S_DBG_RVALID || S_DBG_RREADY);",
            "assign dbg_read_",
            "reg = (OPT_LOWPOWER && !dbg_read_ready) ? 5'h0 : arskd_addr[4:0]; // dbg_read_valid",
            "reg [1:0] r_blkram_stall;",
            "initial r_blkram_stall = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !OPT_DBGPORT) r_blkram_stall <= 0; else if (dbg_read_ready && arskd_addr[5] == DBG_ADDR_CPU) r_blkram_stall <= 2 + (OPT_DISTRIBUTED_REGS ? 0:1); else if (r_blkram_stall > 0) r_blkram_stall <= r_blkram_stall - 1; // {{{",
            "initial dbg_read_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !OPT_DBGPORT) dbg_read_valid <= 0; else dbg_read_valid <= (r_blkram_stall == 1);",
            "assign dbg_blkram_stall = (r_blkram_stall != 0); `ifdef FORMAL",
            "always @(*) if (S_AXI_ARESETN && (dbg_read_valid || dbg_blkram_stall)) assert(!S_DBG_RVALID); `endif // }}} // S_DBG_RVALID // {{{",
            "initial S_DBG_RVALID = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) S_DBG_RVALID <= 0; else if (!S_DBG_RVALID || S_DBG_RREADY) S_DBG_RVALID <= (dbg_read_ready && (!OPT_DBGPORT || arskd_addr[5] == DBG_ADDR_CTRL)) || dbg_read_valid; // }}} // S_DBG_RDATA // {{{",
            "initial S_DBG_RDATA = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) S_DBG_RDATA <= 0; else if (!S_DBG_RVALID || S_DBG_RREADY) begin // {{{ if (OPT_DBGPORT && dbg_read_valid) S_DBG_RDATA <= dbg_read_data; else S_DBG_RDATA <= cpu_status; if (OPT_LOWPOWER && (!OPT_DBGPORT || !dbg_read_valid) && !dbg_read_ready) S_DBG_RDATA <= 0; // }}} end // }}}",
            "assign S_DBG_RRESP = 2'b00; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Reset, halt, clear-cache, and step controls // {{{ //////////////////////////////////////////////////////////////////////// // // assign dbg_cpu_write = OPT_DBGPORT && dbg_write_ready && awskd_addr[5] == DBG_ADDR_CPU && wskd_strb == 4'hf;",
            "assign dbg_cmd_write = dbg_write_ready && awskd_addr[5] == DBG_ADDR_CTRL;",
            "assign dbg_cmd_data = wskd_data;",
            "assign dbg_cmd_strb = wskd_strb;",
            "assign reset_request = dbg_cmd_write && dbg_cmd_strb[RESET_BIT/8] && dbg_cmd_data[RESET_BIT];",
            "assign release_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8] && !dbg_cmd_data[HALT_BIT];",
            "assign halt_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8] && dbg_cmd_data[HALT_BIT];",
            "assign step_request = dbg_cmd_write && dbg_cmd_strb[STEP_BIT/8] && dbg_cmd_data[STEP_BIT];",
            "assign clear_cache_request = dbg_cmd_write && dbg_cmd_strb[CLEAR_CACHE_BIT/8] && dbg_cmd_data[CLEAR_CACHE_BIT]; // // reset_hold: Always start us off with an",
            "initial reset // {{{ generate if (RESET_DURATION > 0) begin : INITIAL_RESET_HOLD // {{{",
            "reg [$clog2(RESET_DURATION)-1:0] reset_counter;",
            "reg r_reset_hold;",
            "initial reset_counter = RESET_DURATION;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || i_cpu_reset) reset_counter <= RESET_DURATION; else if (reset_counter > 0) reset_counter <= reset_counter - 1;",
            "initial r_reset_hold = 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || i_cpu_reset) r_reset_hold <= 1; else r_reset_hold <= (reset_counter > 1);",
            "assign reset_hold = r_reset_hold; `ifdef FORMAL",
            "always @(*) assert(reset_hold == (reset_counter != 0)); `endif // }}} end else begin : NO_RESET_HOLD",
            "assign reset_hold = 0; end endgenerate // }}}",
            "assign halt_on_fault = dbg_catch; // cmd_reset // {{{ // Always start us off with an",
            "initial reset",
            "initial cmd_reset = 1'b1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || i_cpu_reset) cmd_reset <= 1'b1; else if (reset_hold) cmd_reset <= 1'b1; else if (cpu_break && !halt_on_fault) cmd_reset <= 1'b1; else cmd_reset <= reset_request; // }}} // cmd_halt // {{{",
            "initial cmd_halt = START_HALTED;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) cmd_halt <= START_HALTED; else if (i_cpu_reset && !dbg_write_ready && !dbg_write_stall) cmd_halt <= START_HALTED; else if (cmd_reset && START_HALTED) cmd_halt <= START_HALTED; else begin // {{{ // When shall we release from a halt? Only if we have // come to a full and complete stop. Even then, we only // release if we aren't being given a command to step the CPU. // if (!dbg_write_valid && cpu_has_halted && dbg_cmd_write && (release_request || step_request)) cmd_halt <= 1'b0; // Reasons to halt // 1. Halt on any unhandled CPU exception. The cause of the // exception must be cured before we can (re)start. // If the CPU is configured to start immediately on power // up, we leave it to reset on any exception instead. if (cpu_break && halt_on_fault) cmd_halt <= 1'b1; // 2. Halt on any user request to halt. (Only valid if the // STEP bit isn't also set) if (dbg_cmd_write && halt_request && !step_request) cmd_halt <= 1'b1; // 3. Halt on any user request to write to a CPU",
            "reg ister if (dbg_cpu_write) cmd_halt <= 1'b1; // 4. Halt following any step command if (cmd_step && !step_request) cmd_halt <= 1'b1; // 5. Halt following any clear cache if (cmd_clear_cache) cmd_halt <= 1'b1; // 6. Halt on any clear cache bit--independent of any step bit if (clear_cache_request) cmd_halt <= 1'b1; // }}} end // }}} // cmd_clear_cache // {{{",
            "initial cmd_clear_cache = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || cmd_reset) cmd_clear_cache <= 1'b0; else if (dbg_cmd_write && clear_cache_request && halt_request) cmd_clear_cache <= 1'b1; else if (cmd_halt && !cpu_dbg_stall) cmd_clear_cache <= 1'b0; // }}} // cmd_step // {{{",
            "initial cmd_step = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || i_cpu_reset) cmd_step <= 1'b0; else if (cmd_reset || cpu_break || reset_request || clear_cache_request || cmd_clear_cache || halt_request || dbg_cpu_write) cmd_step <= 1'b0; else if (!dbg_write_valid && cpu_has_halted && step_request) cmd_step <= 1'b1; else // if (cpu_dbg_stall) cmd_step <= 1'b0; `ifdef FORMAL // While STEP is true, we can't halt",
            "always @(*) if (S_AXI_ARESETN && cmd_step) assert(!cmd_halt); `endif // }}} // dbg_catch // {{{ generate if (!OPT_DBGPORT) begin : NO_DBG_CATCH",
            "assign dbg_catch = START_HALTED; end else begin : GEN_DBG_CATCH",
            "reg r_dbg_catch;",
            "initial r_dbg_catch = START_HALTED;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_dbg_catch <= START_HALTED; else if (dbg_cmd_write && dbg_cmd_strb[CATCH_BIT/8]) r_dbg_catch <= dbg_cmd_data[CATCH_BIT];",
            "assign dbg_catch = r_dbg_catch; end endgenerate // }}} // cpu_status // {{{ // 0xffff_f000 -> (Unused / reserved) // // 0x0000_0800 -> cpu_break // 0x0000_0400 -> Interrupt pending // 0x0000_0200 -> User mode // 0x0000_0100 -> Sleep (CPU is sleeping) // // 0x0000_00c0 -> (Unused/reserved) // 0x0000_0020 -> dbg_catch // 0x0000_0010 -> cmd_clear_cache // // 0x0000_0008 -> Reset // 0x0000_0004 -> Step (auto clearing, write only) // 0x0000_0002 -> Halt (status) // 0x0000_0001 -> Halt (request)",
            "assign cpu_status = { 16'h0, 4'h0, cpu_break, i_interrupt, cpu_dbg_cc[1:0], 2'h0, dbg_catch, 1'b0, cmd_reset, 1'b0, !cpu_dbg_stall, cmd_halt }; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // The ZipCPU Core // {{{ //////////////////////////////////////////////////////////////////////// // // `ifdef FORMAL // {{{ (* anyseq *)",
            "reg f_cpu_halted, f_cpu_data, f_cpu_stall, f_cpu_break; (* anyseq *)",
            "reg [2:0] f_cpu_dbg_cc; (* anyseq *)",
            "reg [2:0] f_cpu_dbg_read_data;",
            "assign cpu_dbg_stall = f_cpu_stall && !f_cpu_halted;",
            "assign cpu_break = f_cpu_break;",
            "assign cpu_dbg_cc = f_cpu_dbg_cc;",
            "assign dbg_read_data = f_cpu_dbg_read_data; fdebug #( // {{{ .OPT_START_HALTED(START_HALTED), .OPT_DISTRIBUTED_RAM(OPT_DISTRIBUTED_REGS) // }}} ) fdbg ( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_cpu_reset(cmd_reset || i_cpu_reset), .i_halt(cmd_halt), .i_halted(f_cpu_halted), .i_clear_cache(cmd_clear_cache), .i_dbg_we(dbg_write_valid), .i_dbg_",
            "reg (dbg_write_",
            "reg ), .i_dbg_data(dbg_write_data), .i_dbg_stall(cpu_dbg_stall), .i_dbg_break(cpu_break), .i_dbg_cc(cpu_dbg_cc) // }}} ); // }}} `else zipcore #( // {{{ .RESET_ADDRESS({ {(32-ADDRESS_WIDTH){1'b0}}, RESET_ADDRESS }), .ADDRESS_WIDTH(ADDRESS_WIDTH-2), .OPT_PIPELINED(OPT_PIPELINED), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_DCACHE(OPT_DCACHE), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .IMPLEMENT_FPU(OPT_FPU), .OPT_CIS(OPT_CIS), .OPT_LOCK(OPT_LOCK), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_START_HALTED(START_HALTED), .OPT_SIM(OPT_SIM), .OPT_PIPELINED_BUS_ACCESS(OPT_MEMPIPE), // localparam [0:0] OPT_MEMPIPE = OPT_PIPELINED_BUS_ACCESS; .OPT_DBGPORT(OPT_DBGPORT), .OPT_TRACE_PORT(OPT_TRACE_PORT), .OPT_PROFILER(OPT_PROFILER), // localparam [0:0] OPT_LOCK=(IMPLEMENT_LOCK)&&(OPT_PIPELINED); // parameter [0:0] WITH_LOCAL_BUS = 1'b1; .OPT_CLKGATE(OPT_CLKGATE), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_USERMODE(OPT_USERMODE) `ifdef FORMAL , .F_LGDEPTH(F_LGDEPTH) `endif // }}} ) core ( // {{{ .i_clk(cpu_clock), .i_reset(cmd_reset), .i_interrupt(i_interrupt), .o_clken(cpu_clken), // Debug interface // {{{ .i_halt(cmd_halt), .i_clear_cache(cmd_clear_cache), .i_dbg_w",
            "reg (dbg_write_",
            "reg ), .i_dbg_we(dbg_write_valid), .i_dbg_data(dbg_write_data),.i_dbg_r",
            "reg (dbg_read_",
            "reg ), .o_dbg_stall(cpu_dbg_stall),.o_dbg_",
            "reg (dbg_read_data), .o_dbg_cc(cpu_dbg_cc), .o_break(cpu_break), // }}} // Instruction fetch interface // {{{ .o_pf_new_pc(pf_new_pc), .o_clear_icache(clear_icache), .o_pf_ready(pf_ready), .o_pf_request_address(pf_request_address), .i_pf_valid(pf_valid), .i_pf_illegal(pf_illegal), .i_pf_instruction(pf_instruction), .i_pf_instruction_pc(pf_instruction_pc), // }}} // Memory unit interface // {{{ .o_clear_dcache(clear_dcache), .o_mem_ce(mem_ce), .o_bus_lock(bus_lock), .o_mem_op(mem_op), .o_mem_addr(mem_cpu_addr), .o_mem_data(mem_wdata), .o_mem_lock_pc(mem_lock_pc), .o_mem_",
            "reg (mem_",
            "reg ), .i_mem_busy(mem_busy), .i_mem_rdbusy(mem_rdbusy), .i_mem_pipe_stalled(mem_pipe_stalled), .i_mem_valid(mem_valid), .i_bus_err(mem_bus_err), .i_mem_w",
            "reg (mem_w",
            "reg ), .i_mem_result(mem_result), // }}} // Accounting/CPU usage interface .o_op_stall(o_op_stall), .o_pf_stall(o_pf_stall), .o_i_count(o_i_count), // .o_debug(o_cpu_debug), // .o_prof_stb( o_prof_stb), .o_prof_addr( o_prof_addr), .o_prof_ticks(o_prof_ticks) // }}} ); `endif",
            "assign o_cmd_reset = cmd_reset;",
            "assign o_gie = cpu_dbg_cc[1];",
            "assign dbg_write_stall = dbg_write_valid && cpu_dbg_stall;",
            "assign cpu_has_halted = !cpu_dbg_stall;",
            "assign o_halted = cpu_has_halted; // }}} //////////////////////////////////////////////////////////////////////// // // Instruction Fetch // {{{ //////////////////////////////////////////////////////////////////////// // `ifndef FORMAL generate if (OPT_LGICACHE > 4) begin : INSN_CACHE axiicache #( // {{{ .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH), .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .AXI_ID(INSN_ID), .LGCACHESZ(OPT_LGICACHE), .LGLINESZ(LGILINESZ), .OPT_WRAP(OPT_WRAP), .OPT_LOWPOWER(OPT_LOWPOWER), // Instruction fetches don't need subword access, // so SWAPWSTRB doesn't make any sense here. // .SWAP_WSTRB(SWAP_WSTRB), .SWAP_ENDIANNESS(SWAP_ENDIANNESS) // }}} ) pf ( // {{{ .S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN), // CPU signals // {{{ .i_cpu_reset(cmd_reset), .i_new_pc(pf_new_pc), .i_clear_cache(clear_icache), .i_ready(pf_ready && clk_gate), .i_pc(pf_request_address), .o_insn(pf_instruction), .o_pc(pf_instruction_pc), .o_valid(pf_valid), .o_illegal(pf_illegal), // }}} // AXI4 (full) bus signals // {{{ .M_AXI_ARVALID(M_INSN_ARVALID), .M_AXI_ARREADY(M_INSN_ARREADY), .M_AXI_ARID( M_INSN_ARID), .M_AXI_ARADDR( M_INSN_ARADDR), .M_AXI_ARLEN( M_INSN_ARLEN), .M_AXI_ARSIZE( M_INSN_ARSIZE), .M_AXI_ARBURST(M_INSN_ARBURST), .M_AXI_ARLOCK( M_INSN_ARLOCK), .M_AXI_ARCACHE(M_INSN_ARCACHE), .M_AXI_ARPROT( M_INSN_ARPROT), .M_AXI_ARQOS( M_INSN_ARQOS), // .M_AXI_RVALID(M_INSN_RVALID), .M_AXI_RREADY(M_INSN_RREADY), .M_AXI_RID( M_INSN_RID), .M_AXI_RDATA( M_INSN_RDATA), .M_AXI_RLAST( M_INSN_RLAST), .M_AXI_RRESP( M_INSN_RRESP) // }}} // }}} ); end else begin : AXILFETCH axilfetch #( // {{{ .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .FETCH_LIMIT(FETCH_LIMIT), // .SWAP_WSTRB(SWAP_WSTRB), .SWAP_ENDIANNESS(SWAP_ENDIANNESS) // }}} ) pf ( // {{{ .S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN), // CPU signals // {{{ .i_cpu_reset(cmd_reset), .i_new_pc(pf_new_pc), .i_clear_cache(clear_icache), .i_ready(pf_ready && clk_gate), .i_pc(pf_request_address), .o_insn(pf_instruction), .o_pc(pf_instruction_pc), .o_valid(pf_valid), .o_illegal(pf_illegal), // }}} // AXI-lite bus signals // {{{ .M_AXI_ARVALID(M_INSN_ARVALID), .M_AXI_ARREADY(M_INSN_ARREADY), .M_AXI_ARADDR(M_INSN_ARADDR), .M_AXI_ARPROT(M_INSN_ARPROT), // .M_AXI_RVALID(M_INSN_RVALID), .M_AXI_RREADY(M_INSN_RREADY), .M_AXI_RDATA(M_INSN_RDATA), .M_AXI_RRESP(M_INSN_RRESP) // }}} // }}} );",
            "assign M_INSN_ARID = INSN_ID; // ARADDR",
            "assign M_INSN_ARLEN = 0;",
            "assign M_INSN_ARSIZE = AXILSB[2:0];",
            "assign M_INSN_ARBURST = 2'b01;",
            "assign M_INSN_ARLOCK = 1'b0;",
            "assign M_INSN_ARCACHE = 4'h3; // PROT",
            "assign M_INSN_ARQOS = 4'h0; // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_insn_axi;",
            "assign unused_insn_axi = &{ 1'b0, M_INSN_RID, M_INSN_RLAST }; // Verilator lint_on UNUSED // Verilator coverage_on end endgenerate `endif // Assign values to the (unused) M_INSN_* write ports // {{{",
            "assign M_INSN_AWVALID = 0;",
            "assign M_INSN_AWVALID = 0;",
            "assign M_INSN_AWID = INSN_ID;",
            "assign M_INSN_AWADDR = 0;",
            "assign M_INSN_AWLEN = 0;",
            "assign M_INSN_AWSIZE = 0;",
            "assign M_INSN_AWBURST = 0;",
            "assign M_INSN_AWLOCK = 0;",
            "assign M_INSN_AWCACHE = 0;",
            "assign M_INSN_AWPROT = 0;",
            "assign M_INSN_AWQOS = 0; // assign M_INSN_WVALID = 0;",
            "assign M_INSN_WDATA = 0;",
            "assign M_INSN_WSTRB = 0;",
            "assign M_INSN_WLAST = 0; // assign M_INSN_BREADY = 1'b1; // // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Memory Unit // {{{ //////////////////////////////////////////////////////////////////////// // `ifndef FORMAL",
            "wire [C_AXI_DATA_WIDTH-1:0] i_bus_data, o_bus_data;",
            "wire [C_AXI_DATA_WIDTH/8-1:0] o_bus_strb; generate if (SWAP_WSTRB && C_AXI_DATA_WIDTH > 32 && !OPT_DCACHE) begin : SWAP_BUS_WORD_ORDER genvar gk; for(gk=0; gk<C_AXI_DATA_WIDTH/32; gk=gk+1) begin",
            "assign i_bus_data[(C_AXI_DATA_WIDTH-32-gk*32) +: 32] = M_DATA_RDATA[gk*32 +: 32];",
            "assign M_DATA_WDATA[gk*32 +: 32] = o_bus_data[(C_AXI_DATA_WIDTH-32-gk*32) +: 32];",
            "assign M_DATA_WSTRB[gk* 4 +: 4] = o_bus_strb[(C_AXI_DATA_WIDTH/8-4-gk*4) +: 4]; end end else begin : KEEP_BUS_WORD_ORDER // {{{",
            "assign i_bus_data = M_DATA_RDATA;",
            "assign M_DATA_WDATA = o_bus_data;",
            "assign M_DATA_WSTRB = o_bus_strb; // }}} end endgenerate generate if (OPT_DCACHE) begin : DATA_CACHE axidcache #( // {{{ .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH), .AXI_ID(DATA_ID), .LGCACHELEN(OPT_LGDCACHE), .LGNLINES(OPT_LGDCACHE-$clog2(C_AXI_DATA_WIDTH/8)-OPT_LGDLINESZ), // .SWAP_ENDIANNESS(SWAP_ENDIANNESS), .SWAP_WSTRB(SWAP_WSTRB), // .OPT_SIGN_EXTEND(OPT_SIGN_EXTEND), .OPT_LOWPOWER(OPT_LOWPOWER), // .OPT_LOCAL_BUS(WITH_LOCAL_BUS), .OPT_WRAP(OPT_WRAP), .OPT_PIPE(OPT_MEMPIPE), .OPT_LOCK(OPT_LOCK) // `ifdef FORMAL // Used with OPT_PIPE, not yet enabled // , .OPT_FIFO_DEPTH(2) // , .F_LGDEPTH(F_LGDEPTH) // `endif // }}} ) mem( // {{{ .S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN), .i_cpu_reset(cmd_reset), .i_clear(clear_dcache), // CPU interface // {{{ .i_pipe_stb(mem_ce), .i_lock(bus_lock), .i_op(mem_op), .i_addr(mem_cpu_addr[AW+1:0]), .i_restart_pc(mem_lock_pc), .i_data(mem_wdata), .i_o",
            "reg (mem_",
            "reg ), .o_busy(mem_busy), .o_pipe_stalled(mem_pipe_stalled), .o_rdbusy(mem_rdbusy), .o_valid(mem_valid), .o_err(mem_bus_err), .o_w",
            "reg (mem_w",
            "reg ), .o_data(mem_result), // }}} // Write interface // {{{ .M_AXI_AWVALID(M_DATA_AWVALID), .M_AXI_AWREADY(M_DATA_AWREADY), .M_AXI_AWID( M_DATA_AWID), .M_AXI_AWADDR( M_DATA_AWADDR), .M_AXI_AWLEN( M_DATA_AWLEN), .M_AXI_AWSIZE( M_DATA_AWSIZE), .M_AXI_AWBURST(M_DATA_AWBURST), .M_AXI_AWLOCK( M_DATA_AWLOCK), .M_AXI_AWCACHE(M_DATA_AWCACHE), .M_AXI_AWPROT( M_DATA_AWPROT), .M_AXI_AWQOS( M_DATA_AWQOS), // .M_AXI_WVALID(M_DATA_WVALID), .M_AXI_WREADY(M_DATA_WREADY), .M_AXI_WDATA(o_bus_data), .M_AXI_WSTRB(o_bus_strb), .M_AXI_WLAST(M_DATA_WLAST), // .M_AXI_BVALID(M_DATA_BVALID), .M_AXI_BREADY(M_DATA_BREADY), .M_AXI_BID( M_DATA_BID), .M_AXI_BRESP( M_DATA_BRESP), // }}} // Read interface // {{{ .M_AXI_ARVALID(M_DATA_ARVALID), .M_AXI_ARREADY(M_DATA_ARREADY), .M_AXI_ARID( M_DATA_ARID), .M_AXI_ARADDR( M_DATA_ARADDR), .M_AXI_ARLEN( M_DATA_ARLEN), .M_AXI_ARSIZE( M_DATA_ARSIZE), .M_AXI_ARBURST(M_DATA_ARBURST), .M_AXI_ARLOCK( M_DATA_ARLOCK), .M_AXI_ARCACHE(M_DATA_ARCACHE), .M_AXI_ARPROT( M_DATA_ARPROT), .M_AXI_ARQOS( M_DATA_ARQOS), // .M_AXI_RVALID(M_DATA_RVALID), .M_AXI_RREADY(M_DATA_RREADY), .M_AXI_RID( M_DATA_RID), .M_AXI_RDATA( i_bus_data), .M_AXI_RLAST( M_DATA_RLAST), .M_AXI_RRESP( M_DATA_RRESP) // }}} // }}} ); end else if (OPT_PIPELINED_BUS_ACCESS && OPT_LGDCACHE > 0) begin : PIPELINED_MEM axipipe #( // {{{ .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH), .AXI_ID(DATA_ID), .OPT_LOCK(OPT_LOCK), .OPT_ALIGNMENT_ERR(OPT_ALIGNMENT_ERR), .SWAP_WSTRB(SWAP_WSTRB), .OPT_LOWPOWER(OPT_LOWPOWER) // .OPT_SIGN_EXTEND(OPT_SIGN_EXTEND) // }}} ) domem( // {{{ .S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN), .i_cpu_reset(cmd_reset), // CPU interface // {{{ .i_stb(mem_ce), .i_lock(bus_lock), .i_op(mem_op), .i_addr(mem_cpu_addr[AW+1:0]), .i_restart_pc(mem_lock_pc), .i_data(mem_wdata), .i_o",
            "reg (mem_",
            "reg ), .o_busy(mem_busy), .o_pipe_stalled(mem_pipe_stalled), .o_rdbusy(mem_rdbusy), .o_valid(mem_valid), .o_err(mem_bus_err), .o_w",
            "reg (mem_w",
            "reg ), .o_result(mem_result), // }}} // AXI // Write interface // {{{ .M_AXI_AWVALID(M_DATA_AWVALID), .M_AXI_AWREADY(M_DATA_AWREADY), .M_AXI_AWID( M_DATA_AWID), .M_AXI_AWADDR( M_DATA_AWADDR), .M_AXI_AWLEN( M_DATA_AWLEN), .M_AXI_AWSIZE( M_DATA_AWSIZE), .M_AXI_AWBURST(M_DATA_AWBURST), .M_AXI_AWLOCK( M_DATA_AWLOCK), .M_AXI_AWCACHE(M_DATA_AWCACHE), .M_AXI_AWPROT( M_DATA_AWPROT), .M_AXI_AWQOS( M_DATA_AWQOS), // .M_AXI_WVALID(M_DATA_WVALID), .M_AXI_WREADY(M_DATA_WREADY), .M_AXI_WDATA(o_bus_data), .M_AXI_WSTRB(o_bus_strb), .M_AXI_WLAST(M_DATA_WLAST), // .M_AXI_BVALID(M_DATA_BVALID), .M_AXI_BREADY(M_DATA_BREADY), .M_AXI_BID( M_DATA_BID), .M_AXI_BRESP( M_DATA_BRESP), // }}} // Read interface // {{{ .M_AXI_ARVALID(M_DATA_ARVALID), .M_AXI_ARREADY(M_DATA_ARREADY), .M_AXI_ARID( M_DATA_ARID), .M_AXI_ARADDR( M_DATA_ARADDR), .M_AXI_ARLEN( M_DATA_ARLEN), .M_AXI_ARSIZE( M_DATA_ARSIZE), .M_AXI_ARBURST(M_DATA_ARBURST), .M_AXI_ARLOCK( M_DATA_ARLOCK), .M_AXI_ARCACHE(M_DATA_ARCACHE), .M_AXI_ARPROT( M_DATA_ARPROT), .M_AXI_ARQOS( M_DATA_ARQOS), // .M_AXI_RVALID(M_DATA_RVALID), .M_AXI_RREADY(M_DATA_RREADY), .M_AXI_RID( M_DATA_RID), .M_AXI_RDATA( i_bus_data), .M_AXI_RLAST( M_DATA_RLAST), .M_AXI_RRESP( M_DATA_RRESP) // }}} // }}} ); // Make Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_pipe;",
            "assign unused_pipe = &{ 1'b0, clear_dcache }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} end else begin : BARE_MEM axiops #( // {{{ .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH), .AXI_ID(DATA_ID), .SWAP_ENDIANNESS(SWAP_ENDIANNESS), .SWAP_WSTRB(SWAP_WSTRB), // .OPT_SIGN_EXTEND(OPT_SIGN_EXTEND), .OPT_LOCK(OPT_LOCK), .OPT_ALIGNMENT_ERR(OPT_ALIGNMENT_ERR), .OPT_LOWPOWER(OPT_LOWPOWER) // }}} ) domem( // {{{ .S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN), .i_cpu_reset(cmd_reset), // CPU interface // {{{ .i_stb(mem_ce), .i_lock(bus_lock), .i_op(mem_op), .i_addr(mem_cpu_addr[ADDRESS_WIDTH-1:0]), .i_restart_pc(mem_lock_pc), .i_data(mem_wdata), .i_o",
            "reg (mem_",
            "reg ), .o_busy(mem_busy), .o_rdbusy(mem_rdbusy), .o_valid(mem_valid), .o_err(mem_bus_err), .o_w",
            "reg (mem_w",
            "reg ), .o_result(mem_result), // }}} // AXI4 (full) // Write interface // {{{ .M_AXI_AWVALID(M_DATA_AWVALID), .M_AXI_AWREADY(M_DATA_AWREADY), .M_AXI_AWID( M_DATA_AWID), .M_AXI_AWADDR( M_DATA_AWADDR), .M_AXI_AWLEN( M_DATA_AWLEN), .M_AXI_AWSIZE( M_DATA_AWSIZE), .M_AXI_AWBURST(M_DATA_AWBURST), .M_AXI_AWLOCK( M_DATA_AWLOCK), .M_AXI_AWCACHE(M_DATA_AWCACHE), .M_AXI_AWPROT( M_DATA_AWPROT), .M_AXI_AWQOS( M_DATA_AWQOS), // .M_AXI_WVALID(M_DATA_WVALID), .M_AXI_WREADY(M_DATA_WREADY), .M_AXI_WDATA(o_bus_data), .M_AXI_WSTRB(o_bus_strb), .M_AXI_WLAST(M_DATA_WLAST), // .M_AXI_BVALID(M_DATA_BVALID), .M_AXI_BREADY(M_DATA_BREADY), .M_AXI_BID( M_DATA_BID), .M_AXI_BRESP( M_DATA_BRESP), // }}} // Read interface // {{{ .M_AXI_ARVALID(M_DATA_ARVALID), .M_AXI_ARREADY(M_DATA_ARREADY), .M_AXI_ARID( M_DATA_ARID), .M_AXI_ARADDR( M_DATA_ARADDR), .M_AXI_ARLEN( M_DATA_ARLEN), .M_AXI_ARSIZE( M_DATA_ARSIZE), .M_AXI_ARBURST(M_DATA_ARBURST), .M_AXI_ARLOCK( M_DATA_ARLOCK), .M_AXI_ARCACHE(M_DATA_ARCACHE), .M_AXI_ARPROT( M_DATA_ARPROT), .M_AXI_ARQOS( M_DATA_ARQOS), // .M_AXI_RVALID(M_DATA_RVALID), .M_AXI_RREADY(M_DATA_RREADY), .M_AXI_RID( M_DATA_RID), .M_AXI_RDATA( i_bus_data), .M_AXI_RLAST( M_DATA_RLAST), .M_AXI_RRESP( M_DATA_RRESP) // }}} // }}} );",
            "assign mem_pipe_stalled = mem_busy; // Make Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_bare;",
            "assign unused_bare = &{ 1'b0, clear_dcache }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} end endgenerate `endif // }}} //////////////////////////////////////////////////////////////////////// // // (Optional) Clock gate // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_CLKGATE) begin : GATE_CPU_CLOCK",
            "reg gatep;",
            "reg gaten /* verilator clock_enable */;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) gatep <= 1'b1; else gatep <= cpu_clken || arskd_valid || dbg_write_valid || dbg_blkram_stall;",
            "always @(negedge S_AXI_ACLK) if (!S_AXI_ARESETN) gaten <= 1'b1; else gaten <= gatep;",
            "assign cpu_clock = S_AXI_ACLK && gaten;",
            "assign clk_gate = gatep; end else begin : NO_CLOCK_GATE",
            "assign cpu_clock = S_AXI_ACLK;",
            "assign clk_gate = 1'b1; end endgenerate // }}} // Make Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, cpu_clken, cpu_dbg_cc[2], S_DBG_AWADDR[DBGLSB-1:0], S_DBG_ARADDR[DBGLSB-1:0], S_DBG_ARPROT, S_DBG_AWPROT, M_INSN_AWREADY, M_INSN_WREADY, M_INSN_BVALID, M_INSN_BID, M_INSN_BRESP }; generate if (32 > ADDRESS_WIDTH) begin : UNUSED_ADDR",
            "wire unused_addr;",
            "assign unused_addr = &{ 1'b0, mem_cpu_addr[31:ADDRESS_WIDTH] }; end endgenerate // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "wire [F_LGDEPTH-1:0] faxil_rd_outstanding, faxil_wr_outstanding, faxil_awr_outstanding; //////////////////////////////////////////////////////////////////////// // // AXI-lite debug interface // {{{ //////////////////////////////////////////////////////////////////////// // // faxil_slave #( // {{{ .C_AXI_DATA_WIDTH(C_DBG_DATA_WIDTH), .C_AXI_ADDR_WIDTH(C_DBG_ADDR_WIDTH), .F_LGDEPTH(F_LGDEPTH), .F_AXI_MAXWAIT(0), .F_AXI_MAXDELAY(0) // }}} ) faxil ( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // AXI-lite debug writes // {{{ .i_axi_awvalid(S_DBG_AWVALID), .i_axi_awready(S_DBG_AWREADY), .i_axi_awaddr(S_DBG_AWADDR), .i_axi_awprot(S_DBG_AWPROT), // .i_axi_wvalid(S_DBG_WVALID), .i_axi_wready(S_DBG_WREADY), .i_axi_wdata(S_DBG_WDATA), .i_axi_wstrb(S_DBG_WSTRB), // .i_axi_bvalid(S_DBG_BVALID), .i_axi_bready(S_DBG_BREADY), .i_axi_bresp(S_DBG_BRESP), // }}} // AXI-lite debug reads // {{{ .i_axi_arvalid(S_DBG_ARVALID), .i_axi_arready(S_DBG_ARREADY), .i_axi_araddr(S_DBG_ARADDR), .i_axi_arprot(S_DBG_ARPROT), // .i_axi_rvalid(S_DBG_RVALID), .i_axi_rready(S_DBG_RREADY), .i_axi_rdata(S_DBG_RDATA), .i_axi_rresp(S_DBG_RRESP), // }}} // Induction // {{{ .f_axi_rd_outstanding(faxil_rd_outstanding), .f_axi_wr_outstanding(faxil_wr_outstanding), .f_axi_awr_outstanding(faxil_awr_outstanding) // }}} // }}} );",
            "always @(*) if (S_AXI_ARESETN) begin assert(faxil_rd_outstanding == (S_DBG_ARREADY ? 0:1) +(dbg_read_valid ? 1:0) + (S_DBG_RVALID ? 1:0)); assert(!dbg_read_valid || !S_DBG_RVALID); assert(faxil_wr_outstanding == (S_DBG_WREADY ? 0:1) +(S_DBG_BVALID ? 1:0)); assert(faxil_awr_outstanding == (S_DBG_AWREADY ? 0:1) +(S_DBG_BVALID ? 1:0)); end // }}} //////////////////////////////////////////////////////////////////////// // // CPU's debug interface // {{{ //////////////////////////////////////////////////////////////////////// // // // Captured above // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipdma_s2mm.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma_s2mm.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipdma_s2mm.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: ZipDMA -- Writes data, having gone through the realignment // pipeline, back to the bus. This data will be written either // 1, 2, or 4 bytes at a time, or at the full width of the bus. // // When writing 2 or 4 bytes at a time, the address must (currently) be // aligned. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2022-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipdma_s2mm #( // {{{",
            "parameter ADDRESS_WIDTH=30, parameter BUS_WIDTH = 64, parameter [0:0] OPT_LITTLE_ENDIAN = 1'b0, parameter LGPIPE = 10, // Abbreviations",
            "localparam DW = BUS_WIDTH, localparam AW = ADDRESS_WIDTH-$clog2(DW/8) // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Configuration // {{{",
            "input wire i_request, output reg o_busy, o_err, input wire i_inc, input wire [1:0] i_size, // input wire [LGLENGTH:0] i_transferlen, input wire [ADDRESS_WIDTH-1:0] i_addr, // Byte address // }}} // Incoming Stream interface // {{{",
            "input wire S_VALID, output wire S_READY, input wire [DW-1:0] S_DATA, // How many bytes are valid?",
            "input wire [$clog2(DW/8):0] S_BYTES, input wire S_LAST, // }}} // Outgoing Wishbone interface // {{{",
            "output reg o_wr_cyc, o_wr_stb, output wire o_wr_we, output reg [AW-1:0] o_wr_addr, output reg [DW-1:0] o_wr_data, output reg [DW/8-1:0] o_wr_sel, input wire i_wr_stall, input wire i_wr_ack, // Verilator coverage_off",
            "input wire [DW-1:0] i_wr_data, // UNUSED",
            "input wire i_wr_err // Verilator coverage_on // }}} // }}} ); // Local decalarations // {{{",
            "localparam [1:0] SZ_BYTE = 2'b11, SZ_16B = 2'b10, SZ_32B = 2'b01, SZ_BUS = 2'b00;",
            "localparam WBLSB = $clog2(DW/8); integer ik; // reg r_inc;",
            "reg [1:0] r_size; // reg [ADDRESS_WIDTH:0] next_addr;",
            "reg [WBLSB-1:0] subaddr;",
            "reg [2*DW-1:0] next_data;",
            "reg [DW-1:0] r_data;",
            "reg [2*DW/8-1:0] next_sel, pre_sel;",
            "reg [DW/8-1:0] r_sel;",
            "reg r_last;",
            "reg [LGPIPE-1:0] wb_outstanding;",
            "reg wb_pipeline_full;",
            "reg addr_overflow; // }}}",
            "assign o_wr_we = 1'b1; // Copy config: r_inc, r_size(, r_addr) // {{{",
            "always @(posedge i_clk) if (i_request && !o_busy) begin r_inc <= i_inc; r_size <= i_size; // r_addr <= i_addr; end // }}} // next_addr // {{{",
            "always @(*) begin next_addr = { 1'b0, o_wr_addr, subaddr }; if (o_wr_stb && !i_wr_stall) case(r_size) SZ_BYTE: if (r_inc) next_addr = next_addr + 1; SZ_16B: begin // 16-bit addressing if (r_inc) next_addr = next_addr + 2; else next_addr[ 0] = 0; end SZ_32B: begin // 32-bit addressing if (r_inc) next_addr = next_addr + 4; else next_addr[1:0] = 0; end SZ_BUS: begin // Full word addressing if (r_inc) next_addr = next_addr + { {(AW-1){1'b0}}, 1'b1, {(WBLSB){1'b0}} }; else next_addr[WBLSB-1:0] = 0; end endcase end",
            "always @(*) addr_overflow = next_addr[ADDRESS_WIDTH]; `ifdef FORMAL",
            "always @(posedge i_clk) if (!i_reset && o_busy && !r_inc) case(r_size) SZ_BYTE: begin end SZ_16B: assert(next_addr[0] == 0); SZ_32B: assert(next_addr[1:0] == 0); SZ_BUS: assert(next_addr[WBLSB-1:0] == 0); endcase `endif // }}} // next_data // {{{",
            "always @(*) if (OPT_LITTLE_ENDIAN) begin next_data = { {(DW){1'b0}}, r_data }; // Zero out unused data for(ik=0; ik<DW/8; ik=ik+1) if (!r_sel[ik]) next_data[ik * 8 +: 8] = 8'h0; if (S_VALID && !r_last) next_data = next_data | ({{(DW){1'b0}}, S_DATA } << (next_addr[WBLSB-1:0]*8)); end else begin next_data = { r_data, {(DW){1'b0}} }; // Zero out unused data for(ik=0; ik<DW/8; ik=ik+1) if (!r_sel[ik]) next_data[DW + ik * 8 +: 8] = 8'h0; if (S_VALID && !r_last) next_data = next_data | ({ S_DATA, {(DW){1'b0}} } >> (next_addr[WBLSB-1:0]*8)); end // }}} // next_sel // {{{",
            "always @(*) begin pre_sel = 0; if (OPT_LITTLE_ENDIAN) begin for(ik=0; ik<DW/8; ik=ik+1) if (ik < S_BYTES) pre_sel[ik] = 1'b1; next_sel = { {(DW/8){1'b0}}, r_sel }; if (S_VALID && !r_last) next_sel = next_sel | (pre_sel << (next_addr[WBLSB-1:0])); end else begin for(ik=0; ik<DW/8; ik=ik+1) if (ik < S_BYTES) pre_sel[2*DW/8-1-ik] = 1'b1; next_sel = { r_sel, {(DW/8){1'b0}} }; if (S_VALID && !r_last) next_sel = next_sel | (pre_sel >> (next_addr[WBLSB-1:0])); end end // }}} // wb_pipeline_full, wb_outstanding // {{{",
            "initial wb_pipeline_full = 1'b0;",
            "initial wb_outstanding = 0;",
            "always @(posedge i_clk) if (i_reset || !o_wr_cyc || i_wr_err) begin wb_pipeline_full <= 1'b0; wb_outstanding <= 0; end else case({ (o_wr_stb && !i_wr_stall), i_wr_ack }) 2'b10: begin wb_pipeline_full <= (&wb_outstanding[LGPIPE-1:2]) && (|wb_outstanding[1:0]); wb_outstanding <= wb_outstanding + 1; end 2'b01: begin wb_pipeline_full <= (&wb_outstanding[LGPIPE-1:0]); wb_outstanding <= wb_outstanding - 1; end default: begin end endcase `ifdef FORMAL",
            "always @(*) if (!i_reset || !o_wr_cyc) assert(wb_pipeline_full == (&wb_outstanding[LGPIPE-1:1]));",
            "always @(*) if (!i_reset && o_wr_cyc && (&wb_outstanding)) assert(!o_wr_stb); `endif // }}} // crc, stb, o_wr_addr, o_wr_sel, o_busy, o_err, subaddr // {{{",
            "initial o_wr_cyc = 1'b0;",
            "initial o_wr_stb = 1'b0;",
            "initial o_busy = 1'b0;",
            "initial o_err = 1'b0;",
            "always @(posedge i_clk) if (i_reset) begin // {{{ o_wr_cyc <= 0; o_wr_stb <= 0; o_wr_addr <= 0; o_busy <= 1'b0; o_err <= 1'b0; { o_wr_addr, subaddr } <= {(ADDRESS_WIDTH){1'b0}}; r_last <= 1'b0; // }}} end else if (!o_busy || o_err || (o_wr_cyc && i_wr_err)) begin // {{{ o_wr_cyc <= 0; o_wr_stb <= 0; o_wr_addr <= 0; o_busy <= i_request && !o_busy; o_err <= o_wr_cyc && i_wr_err; if (o_wr_cyc && i_wr_err) o_busy <= 1'b0; o_wr_addr <= i_addr[ADDRESS_WIDTH-1:WBLSB]; subaddr <= i_addr[WBLSB-1:0]; r_last <= 1'b0; // }}} end else if (!o_wr_stb || !i_wr_stall) begin // {{{ o_wr_stb <= 1'b0; if (o_wr_stb) { o_wr_addr, subaddr } <= next_addr[ADDRESS_WIDTH-1:0]; if (addr_overflow) { o_err, o_wr_cyc, o_wr_stb } <= 3'b100; else if (!wb_pipeline_full) begin if ((r_last && (|r_sel)) || (S_VALID && !r_last)) begin // Need to flush our last result out { o_wr_cyc, o_wr_stb } <= 2'b11; end else if (wb_outstanding + (o_wr_stb ? 1:0) == (i_wr_ack ? 1:0)) begin // We are all done writing o_wr_cyc <= 1'b0; o_busy <= !r_last; end end if (S_VALID && !r_last) r_last <= S_LAST; // }}} end `ifdef FORMAL",
            "always @(posedge i_clk) if (i_reset || !o_busy || o_err || (o_wr_cyc && i_wr_err)) begin end else if (!o_wr_stb || !i_wr_stall) begin // {{{ if (addr_overflow) begin end else if (!wb_pipeline_full) begin if (r_last && (|r_sel)) begin // Need to flush our last result out assert(!S_READY); end else if (S_VALID && !r_last) begin assert(S_VALID && S_READY); end else begin assert(!S_VALID || !S_READY); end end else begin assert(!S_READY); end // }}} end else begin assert(!S_READY); end",
            "always @(*) if (!i_reset && !o_busy) assert(!o_wr_cyc); `endif // }}} // o_wr_data, o_wr_sel // {{{",
            "always @(posedge i_clk) if (!o_busy) // i_reset || !o_busy || o_err || (o_wr_cyc && i_wr_err)) begin // {{{ { r_data, o_wr_data } <= {(2*DW ){1'b0}}; { r_sel, o_wr_sel } <= {(2*DW/8){1'b0}}; // }}} end else if ((!o_wr_stb || !i_wr_stall) && !wb_pipeline_full && (r_last || S_VALID)) begin // {{{ if (OPT_LITTLE_ENDIAN) begin { r_data, o_wr_data } <= next_data; { r_sel, o_wr_sel } <= next_sel; end else begin { o_wr_data, r_data } <= next_data; { o_wr_sel, r_sel } <= next_sel; end // }}} end // }}}",
            "assign S_READY = !r_last && o_busy && (!o_wr_stb || !i_wr_stall) && !wb_pipeline_full; // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_wr_data }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "localparam F_LGDEPTH = LGPIPE+1;",
            "reg f_past_valid; (* anyconst *)",
            "reg [ADDRESS_WIDTH-1:0] f_cfg_addr; (* anyconst *)",
            "reg [1:0] f_cfg_size; (* anyconst *)",
            "reg f_cfg_inc;",
            "wire [F_LGDEPTH-1:0] fwb_nreqs, fwb_nacks, fwb_outstanding;",
            "reg [ADDRESS_WIDTH:0] f_posn, fwb_addr, fwb_posn;",
            "reg [WBLSB-1:0] fr_sel_count, fr_sel_count_past;",
            "reg [ADDRESS_WIDTH-1:0] r_addr;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1;",
            "always @(*) if (!f_past_valid) assume(i_reset); //////////////////////////////////////////////////////////////////////// // // Control interface properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (!f_past_valid || $past(i_reset)) assume(!i_request); else if ($past(i_request && o_busy)) begin assume(i_request); assume($stable(i_inc)); assume($stable(i_size)); assume($stable(i_addr)); end",
            "always @(posedge i_clk) if (i_request && !o_busy) begin // r_inc <= i_inc; // r_size <= i_size; r_addr <= i_addr; end",
            "always @(*) if (!f_cfg_inc) case(f_cfg_size) SZ_BYTE: begin end SZ_16B: assume(f_cfg_addr[0] == 1'b0); SZ_32B: assume(f_cfg_addr[1:0] == 2'b0); SZ_BUS: assume(f_cfg_addr[WBLSB-1:0] == 0); endcase",
            "always @(*) if (i_request && !o_busy) begin assume(i_inc == f_cfg_inc); assume(i_size == f_cfg_size); assume(i_addr == f_cfg_addr); end",
            "always @(*) if (!i_reset && o_busy) begin assert(r_addr == f_cfg_addr); assert(r_size == f_cfg_size); assert(r_inc == f_cfg_inc); if (!r_inc) case(r_size) SZ_BYTE: begin end SZ_16B: assert(r_addr[0] == 1'b0); SZ_32B: assert(r_addr[1:0] == 2'b0); SZ_BUS: assert(r_addr[WBLSB-1:0] == 0); endcase end // }}} //////////////////////////////////////////////////////////////////////// // // Stream properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (!f_past_valid || $past(i_reset)) begin assume(!S_VALID); end else if ($past(S_VALID && !S_READY)) begin assume(S_VALID); assume($stable(S_DATA)); assume($stable(S_BYTES)); assume($stable(S_LAST)); end",
            "always @(*) if (S_VALID) begin assume(S_BYTES <= DW/8); assume(S_BYTES > 0); if (!S_LAST) case(f_cfg_size) 2'b11: assume(S_BYTES == 1); 2'b10: assume(S_BYTES == 2); 2'b01: assume(S_BYTES == 4); 2'b00: assume(S_BYTES == (DW/8)); endcase else case(f_cfg_size) 2'b11: assume(S_BYTES == 1); 2'b10: assume(S_BYTES <= 2); 2'b01: assume(S_BYTES <= 4); 2'b00: assume(S_BYTES <= (DW/8)); endcase end",
            "always @(posedge i_clk) if (i_reset || !o_busy) f_posn <= 0; else if (S_VALID && S_READY) f_posn <= f_posn + S_BYTES;",
            "always @(*) if (o_busy) assume(!f_posn[ADDRESS_WIDTH] || (f_posn[ADDRESS_WIDTH-1:0]==0 && r_last));",
            "always @(*) if (!i_reset && o_busy) begin if (r_last) begin end else case(f_cfg_size) 2'b11: begin end 2'b10: assert(f_posn[0] == 1'b0); 2'b01: assert(f_posn[1:0] == 2'b0); 2'b00: assert(f_posn[WBLSB-1:0] == 0); endcase end // }}} //////////////////////////////////////////////////////////////////////// // // Wishbone properties // {{{ //////////////////////////////////////////////////////////////////////// // // fwb_master #( .AW(AW), .DW(DW), .F_LGDEPTH(F_LGDEPTH), .F_OPT_DISCONTINUOUS(1'b1), .F_MAX_STALL(2), .F_MAX_ACK_DELAY(2) ) fwb ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_wb_cyc( o_wr_cyc), .i_wb_stb( o_wr_stb), .i_wb_we( o_wr_we), .i_wb_addr(o_wr_addr), .i_wb_data(o_wr_data), .i_wb_sel( o_wr_sel), // .i_wb_stall(i_wr_stall), .i_wb_ack( i_wr_ack), .i_wb_idata(i_wr_data), .i_wb_err( i_wr_err), // .f_nreqs(fwb_nreqs), .f_nacks(fwb_nacks), .f_outstanding(fwb_outstanding) // }}} );",
            "always @(*) if (!i_reset && o_wr_stb) assert(|o_wr_sel);",
            "always @(*) if (o_wr_cyc) assert(fwb_outstanding == wb_outstanding);",
            "initial fwb_posn = 0;",
            "always @(posedge i_clk) if (i_reset || !o_busy) fwb_posn <= 0; else if (o_wr_stb && !i_wr_stall) fwb_posn <= fwb_posn + $countones(o_wr_sel);",
            "always @(*) if (!i_reset && o_busy && !o_err) assert(f_posn == fwb_posn + $countones(r_sel) + (o_wr_stb ? $countones(o_wr_sel) : 0));",
            "always @(*) if (r_inc) begin fwb_addr = r_addr + fwb_posn; if (fwb_posn > 0) case(r_size) SZ_16B: fwb_addr[ 0] = 0; SZ_32B: fwb_addr[1:0] = 0; SZ_BUS: fwb_addr[WBLSB-1:0] = 0; default: begin end endcase end else begin // fwb_addr = r_addr + fwb_posn; fwb_addr = r_addr; case(r_size) SZ_BYTE: begin end SZ_16B: fwb_addr[0] = 0; SZ_32B: fwb_addr[1:0] = 0; SZ_BUS: fwb_addr[WBLSB-1:0] = 0; endcase end",
            "always @(*) if (!i_reset && o_busy && !r_last && !o_err) // && (o_wr_stb || !fwb_addr[ADDRESS_WIDTH]) && !r_last) begin assert({ 1'b0, o_wr_addr } == fwb_addr[ADDRESS_WIDTH:WBLSB]); case(r_size) SZ_BUS: assert(subaddr == r_addr[WBLSB-1:0]); SZ_16B: assert(subaddr == { fwb_addr[WBLSB-1:1], r_addr[0] }); SZ_32B: assert(subaddr == { fwb_addr[WBLSB-1:2], r_addr[1:0] }); default: assert(subaddr == fwb_addr[WBLSB-1:0]); endcase end",
            "always @(*) if (o_busy && fwb_addr[ADDRESS_WIDTH] && !r_last) begin assert(o_err); // assert(fwb_addr[ADDRESS_WIDTH-1:0] <= DW/8); end",
            "always @(*) if (!o_busy || o_err) assert(!o_wr_cyc);",
            "always @(*) if (!i_reset && o_busy) begin if (!r_inc) case(r_size) SZ_BYTE: begin end SZ_16B: assert(subaddr[0] == 1'b0); SZ_32B: assert(subaddr[1:0] == 2'b00); SZ_BUS: assert(subaddr == 0); endcase else case(r_size) SZ_BYTE: begin end SZ_16B: assert(subaddr[0] == r_addr[0]); SZ_32B: assert(subaddr[1:0] == r_addr[1:0]); SZ_BUS: assert(subaddr == r_addr[WBLSB-1:0]); endcase end",
            "always @(*) fr_sel_count = $countones(r_sel);",
            "always @(posedge i_clk) if (!o_wr_sel || !i_wr_stall) fr_sel_count_past <= fr_sel_count;",
            "always @(posedge i_clk) if(!i_reset && o_busy && !o_err && !r_last && $past(S_VALID && S_READY)) begin assert(o_wr_stb); assert($countones({ r_sel, o_wr_sel }) == $past(S_BYTES + fr_sel_count)); end",
            "always @(*) if (!i_reset && o_busy) begin if (o_err) assert(!o_wr_cyc); if (f_posn == 0) begin assert(r_sel == 0); assert(!o_wr_cyc); assert(wb_outstanding == 0); end else case(r_size) SZ_BYTE: assert(r_sel == 0); SZ_16B: begin if (OPT_LITTLE_ENDIAN) begin assert(r_sel[DW/8-1:1] == 0); end else begin assert(r_sel[DW/8-2:0] == 0); end if (!o_wr_stb) begin end else if (subaddr + 2 <= DW/8) begin assert(r_sel == 0); end else if (!r_last) begin assert(r_sel[(OPT_LITTLE_ENDIAN) ? 0 : (DW/8-1)] == (subaddr+2 > DW/8)); end else begin assert(r_sel[(OPT_LITTLE_ENDIAN) ? 0 : (DW/8-1)] <= (subaddr+2 > DW/8)); end end SZ_32B: begin if (OPT_LITTLE_ENDIAN) begin assert(r_sel[DW/8-1:3] == 0); end else begin assert(r_sel[DW/8-4:0] == 0); end if (!o_wr_stb) begin end else if (subaddr + 4 <= DW/8) begin assert(r_sel == 0); /* end else if (!r_last) begin assert($countones(r_sel) == subaddr+4-DW/8); end else begin assert($countones(r_sel) <= subaddr+4-DW/8); */ end end SZ_BUS: begin assert(!(&r_sel)); if (subaddr == 0) assert(r_sel == 0); end default: begin end endcase if (OPT_LITTLE_ENDIAN) begin if (!o_wr_sel[DW/8-1]) assert(!r_sel[0]); end else begin if (!o_wr_sel[0]) assert(!r_sel[DW/8-1]); end for(ik=0; ik<DW/8; ik=ik+1) if (OPT_LITTLE_ENDIAN) begin case(r_size) SZ_32B: if (ik > 2) assert(!r_sel[ik]); SZ_BUS: if (ik >= r_addr[DW/8-1:0]) assert(!r_sel[ik]); default: begin end endcase end else begin if (ik > 0 && !r_sel[DW/8-ik]) begin assert(!r_sel[DW/8-1-ik]); end case(r_size) SZ_32B: begin /*if (ik >= 4 || subaddr + ik < DW/8 || subaddr + ik - DW/8 >= 4) // assert(!r_sel[subaddr+ik-DW/8]); assert(!r_sel[DW/5-1-ik-subaddr]); */ end SZ_BUS: begin /* if (ik > DW/8-1-i_addr[DW/8-1:0]) assert(!r_sel[ik]); */ end default: begin end endcase end end",
            "always @(*) if (!i_reset && o_busy && !r_inc) assert(r_sel == 0);",
            "reg [WBLSB-1:0] f_sum;",
            "always @(*) if (r_inc) f_sum = fwb_posn[WBLSB-1:0] + r_addr[WBLSB-1:0]; else f_sum = fwb_posn[WBLSB-1:0];",
            "always @(*) if (!i_reset && o_busy && fwb_posn > 0) begin if (!r_last) case(r_size) SZ_16B: assert(f_sum[ 0] == 0); SZ_32B: assert(f_sum[1:0] == 0); SZ_BUS: assert(f_sum[WBLSB-1:0] == 0); default: begin end endcase end // }}} //////////////////////////////////////////////////////////////////////// // // Contract properties // {{{ //////////////////////////////////////////////////////////////////////// // // (* anyconst *)",
            "reg fc_check; (* anyconst *)",
            "reg [ADDRESS_WIDTH:0] fc_posn; (* anyconst *)",
            "reg [7:0] fc_byte;",
            "reg [ADDRESS_WIDTH:0] f_shift, fwb_shift;",
            "reg [DW-1:0] fc_partial;",
            "reg [2*DW-1:0] fc_partial_wb;",
            "reg [2*DW/8-1:0] fc_partial_sel;",
            "wire [DW-1:0] fz_data;",
            "wire [DW/8-1:0] fz_sel;",
            "assign fz_data = 0;",
            "assign fz_sel = 0;",
            "always @(*) begin f_shift = (fc_posn - f_posn); f_shift[ADDRESS_WIDTH:WBLSB] = 0; end",
            "always @(*) if (OPT_LITTLE_ENDIAN) fc_partial = S_DATA >> (8*f_shift); else fc_partial = S_DATA << (8*f_shift);",
            "wire fin_check, fwb_check;",
            "assign fin_check = fc_check && S_VALID && (f_posn <= fc_posn) && (fc_posn < f_posn + S_BYTES);",
            "assign fwb_check = fc_check && o_busy && !o_err && (fwb_posn <= fc_posn) &&((o_wr_stb && fc_posn < fwb_posn + $countones(o_wr_sel)) ||(!o_wr_stb && fc_posn < fwb_posn + $countones(r_sel)));",
            "always @(*) if (fin_check) begin if (OPT_LITTLE_ENDIAN) assume(fc_partial[7:0] == fc_byte); else assume(fc_partial[DW-1:DW-8] == fc_byte); end",
            "always @(*) begin fwb_shift = 0; if (r_inc) begin fwb_shift[WBLSB-1:0] = fc_posn[WBLSB-1:0] - fwb_posn[WBLSB-1:0]; if (o_wr_stb) fwb_shift[WBLSB-1:0] = fwb_shift[WBLSB-1:0] + fwb_addr[WBLSB-1:0]; end else fwb_shift[WBLSB-1:0] = fc_posn[WBLSB-1:0] - fwb_posn[WBLSB-1:0] + r_addr[WBLSB-1:0]; end",
            "always @(*) if (OPT_LITTLE_ENDIAN) begin if (o_wr_stb) begin fc_partial_wb ={ r_data, o_wr_data} >> (8*fwb_shift); fc_partial_sel={ r_sel, o_wr_sel } >> fwb_shift; end else begin fc_partial_wb ={ fz_data, r_data} >> (8*fwb_shift); fc_partial_sel={ fz_sel, r_sel } >> fwb_shift; end end else begin if (o_wr_stb) begin fc_partial_wb ={ o_wr_data, r_data }<< (8*fwb_shift); fc_partial_sel={ o_wr_sel, r_sel } << fwb_shift; end else begin fc_partial_wb ={ r_data,fz_data } << (8*fwb_shift); fc_partial_sel={ r_sel, fz_sel } << fwb_shift; end end",
            "always @(*) if (o_busy) assert(fwb_posn <= f_posn);",
            "always @(*) if (fwb_check) begin if (OPT_LITTLE_ENDIAN) begin assert(fc_partial_wb[7:0] == fc_byte); assert(fc_partial_sel[0]); end else begin assert(fc_partial_wb[2*DW-1:2*DW-8] == fc_byte); assert(fc_partial_sel[2*DW/8-1]); end end // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (!i_reset && !$past(i_reset)) cover(i_request);",
            "always @(posedge i_clk) if (!i_reset && !$past(i_reset)) cover(o_busy);",
            "always @(posedge i_clk) if (!i_reset && !$past(i_reset) && $past(o_busy)) begin cover(!o_busy); if (!o_busy) begin case({ r_inc, r_size }) 3'b000: cover(f_posn > DW/8); 3'b001: cover(f_posn > DW/8); 3'b010: cover(f_posn > DW/8); 3'b011: cover(f_posn > DW/8); 3'b100: cover(f_posn > DW/8); 3'b101: cover(f_posn > DW/8); 3'b110: cover(f_posn > DW/8); 3'b111: cover(f_posn > DW/8); endcase end end // }}} //////////////////////////////////////////////////////////////////////// // // \"Careless\" assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) case(f_cfg_size) SZ_BYTE: begin end SZ_BUS: begin end SZ_16B: assume(f_cfg_addr[0] == 1'b0); SZ_32B: assume(f_cfg_addr[1:0] == 2'b0); endcase // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipdma_rxgears.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma_rxgears.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipdma_rxgears.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: ZipDMA -- A gearbox to pack received data. This is part of our // alignment process. Data comes in, gets read, gets packed, goes // into the FIFO, gets unpacked, and eventually written back to the bus. // Here, we simply pack words prior to stuffing them into the FIFO. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2022-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipdma_rxgears #( // {{{",
            "parameter BUS_WIDTH = 64, parameter [0:0] OPT_LITTLE_ENDIAN = 1'b0, // Abbreviations",
            "localparam DW = BUS_WIDTH // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Configuration // {{{",
            "input wire i_soft_reset, // }}} // Incoming Stream interface // {{{",
            "input wire S_VALID, output wire S_READY, input wire [DW-1:0] S_DATA, // How many bytes are valid?",
            "input wire [$clog2(DW/8):0] S_BYTES, input wire S_LAST, // }}} // Outgoing Stream interface // {{{",
            "output wire M_VALID, input wire M_READY, output wire [DW-1:0] M_DATA, // How many bytes are valid?",
            "output wire [$clog2(DW/8):0] M_BYTES, output wire M_LAST // }}} // }}} ); // Local declarations // {{{",
            "localparam WBLSB = $clog2(DW/8);",
            "reg [2*DW-1:0] s",
            "reg ;",
            "reg [WBLSB+1:0] next_fill, fill;",
            "reg m_valid, m_last, next_last, r_last, r_full;",
            "reg [WBLSB:0] m_bytes;",
            "reg [WBLSB-1:0] shift;",
            "reg [DW-1:0] s_data; integer ik; // }}} // next_fill, next_last // {{{",
            "always @(*) begin next_fill = fill; if (M_VALID && M_READY) begin if (M_LAST) next_fill = 0; else next_fill[WBLSB+1:WBLSB] = next_fill[WBLSB+1:WBLSB] - 1; end if (S_VALID && S_READY) next_fill = next_fill + S_BYTES; next_last = 0; if (S_VALID && S_READY && S_LAST) next_last = (next_fill[WBLSB+1:WBLSB] == 2'b00) ||((next_fill[WBLSB+1:WBLSB] == 2'b01) &&(next_fill[WBLSB-1:0] == 0)); // Was next_fill <= DW/8); end // }}} // fill // {{{",
            "initial fill = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) fill <= 0; else fill <= next_fill; `ifdef FORMAL",
            "always @(*) assert(fill < 2*DW/8); `endif // }}} // r_full // {{{ /* // This isn't necessary, since r_full == fill[WBLSB];",
            "initial r_full = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) r_full <= 0; else if (M_VALID && M_READY) r_full <= 1'b0; else if (S_VALID && S_READY) r_full <= (next_fill >= (DW/8)); */",
            "always @(*) // Verilator lint_off WIDTH r_full = (fill >= (DW/8)); // Verilator lint_on WIDTH // }}} // m_valid // {{{",
            "initial m_valid = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) m_valid <= 0; else if (!M_VALID || M_READY) m_valid <= r_last || (S_VALID && S_READY && S_LAST) || (|next_fill[WBLSB+1:WBLSB]); `ifdef FORMAL",
            "always @(*) if (fill >= (DW/8) || r_last || m_last) assert(m_valid);",
            "always @(*) if (m_last) assert(m_bytes == fill); `endif // }}} // m_bytes // {{{",
            "initial m_bytes = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) m_bytes <= 0; else if (!M_VALID || M_READY) m_bytes <= (|next_fill[WBLSB+1:WBLSB]) ? { 1'b1, {(WBLSB){1'b0}} } // DW/8 : { 1'b0, next_fill[WBLSB-1:0] }; // m_bytes <= (next_fill > (DW/8)) ? DW/8 : next_fill; // }}} // r_last, m_last // {{{",
            "initial { r_last, m_last } = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) { r_last, m_last } <= 0; else if (S_VALID && S_READY && S_LAST) { r_last, m_last } <= { !next_last, next_last }; else if (M_VALID && M_READY) { r_last, m_last } <= { 1'b0, r_last }; // }}} // s",
            "reg // {{{",
            "always @(*) begin s_data = 0; for(ik=0; ik<DW/8; ik=ik+1) if (ik < S_BYTES) begin if (OPT_LITTLE_ENDIAN) s_data[ik*8 +: 8] = S_DATA[ik*8 +: 8]; else s_data[(DW/8-1-ik)*8 +: 8] = S_DATA[(DW/8-1-ik)*8 +: 8]; end end",
            "always @(*) begin shift = fill[WBLSB-1:0]; if (M_VALID && M_READY) // Verilator lint_off WIDTH shift = fill - DW/8; // Verilator lint_on WIDTH end",
            "initial s",
            "reg = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) s",
            "reg <= 0; else if (M_VALID && M_READY && M_LAST) s",
            "reg <= 0; else if (OPT_LITTLE_ENDIAN) begin // {{{ if (M_VALID && M_READY) begin if (S_VALID && S_READY) // Verilator lint_off WIDTH s",
            "reg <= { {(DW){1'b0}}, s",
            "reg [2*DW-1:DW] } | ({{(DW){1'b0}}, s_data } << (shift*8)); // Verilator lint_on WIDTH else s",
            "reg <= { {(DW){1'b0}}, s",
            "reg [2*DW-1:DW] }; end else if (S_VALID && S_READY) s",
            "reg <= s",
            "reg | ({ {(DW){1'b0}}, s_data } << shift*8); // }}} end else begin if (M_VALID && M_READY) begin if (S_VALID && S_READY) // Verilator lint_off WIDTH s",
            "reg <= { s",
            "reg [DW-1:0], {(DW){1'b0}} } | ({s_data, {(DW){1'b0}} } >>(shift*8)); // Verilator lint_on WIDTH else s",
            "reg <= { s",
            "reg [DW-1:0], {(DW){1'b0}} }; end else if (S_VALID && S_READY) // Verilator lint_off WIDTH s",
            "reg <= s",
            "reg | ({ s_data, {(DW){1'b0}} } >> (shift*8)); // Verilator lint_on WIDTH end // Verilator lint_on WIDTH // }}}",
            "assign M_VALID = m_valid;",
            "assign M_DATA = (OPT_LITTLE_ENDIAN) ? s",
            "reg [DW-1:0] : s",
            "reg [2*DW-1:DW];",
            "assign M_BYTES = m_bytes;",
            "assign M_LAST = m_last;",
            "assign S_READY = (!M_LAST && !r_last) && (!M_VALID || (M_READY || !r_full)); // || (S_BYTES + fill < 2*DW/8)))); // Keep Verilator happy // {{{ // wire unused; // assign unused = &{ 1'b0, ... }; // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "localparam F_LGCOUNT = 16;",
            "reg f_past_valid;",
            "reg [F_LGCOUNT-1:0] f_rcvd, f_sent;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1;",
            "always @(*) if (!f_past_valid) assume(i_reset); //////////////////////////////////////////////////////////////////////// // // Incoming stream properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (!f_past_valid || $past(i_reset || i_soft_reset)) assume(!S_VALID); else if ($past(S_VALID && !S_READY)) begin assume(S_VALID); assume($stable(S_DATA)); assume($stable(S_BYTES)); assume($stable(S_LAST)); end",
            "always @(*) if (!i_reset && S_VALID) begin assume(S_BYTES <= (DW/8)); assume(S_BYTES > 0); end",
            "initial f_rcvd = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) f_rcvd <= 0; else if (S_VALID && S_READY) begin if (S_LAST) f_rcvd <= 0; else f_rcvd <= f_rcvd + S_BYTES; end",
            "always @(*) begin assume(!f_rcvd[F_LGCOUNT-1]); assume({ 1'b0, f_rcvd } + (S_VALID ? S_BYTES : 0) < (1<<(F_LGCOUNT-1))); end // }}} //////////////////////////////////////////////////////////////////////// // // Outgoing stream properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (!f_past_valid || $past(i_reset || i_soft_reset)) begin assert(!M_VALID); assert(!r_last); assert(!M_LAST); end else if ($past(M_VALID && !M_READY)) begin assert(M_VALID); assert($stable(M_DATA)); assert($stable(M_BYTES)); assert($stable(M_LAST)); end",
            "always @(*) if (!i_reset && M_VALID) begin assert(M_BYTES <= (DW/8)); assert(M_BYTES > 0); if (!M_LAST) assert(M_BYTES == (DW/8)); end",
            "initial f_sent = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) f_sent <= 0; else if (M_VALID && M_READY) begin if (M_LAST) f_sent <= 0; else f_sent <= f_sent + M_BYTES; end",
            "reg [F_LGCOUNT-1:0] f_buffered;",
            "always @(*) begin f_buffered = f_sent + fill; assert(!f_sent[F_LGCOUNT-1]); assert(!f_buffered[F_LGCOUNT-1]); assert(f_buffered >= f_sent); assert(f_sent[WBLSB-1:0] == 0); end",
            "always @(*) if (!i_reset) begin if (!m_last && !r_last) begin assert(f_sent + fill == f_rcvd); assert(f_sent <= f_rcvd); end end // }}} //////////////////////////////////////////////////////////////////////// // // Induction properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (!i_reset) begin assert(!r_last || !M_LAST); if (r_last) assert(M_VALID && fill > (DW/8)); end",
            "always @(*) if (!i_reset) begin if (fill > (DW/8)) assert(M_BYTES == (DW/8)); else assert(M_BYTES == fill); end",
            "always @(*) if (!i_reset && (r_last || M_LAST)) assert(f_rcvd == 0); else if (!i_reset) assert(fill[WBLSB-1:0] == f_rcvd[WBLSB-1:0]); // }}} //////////////////////////////////////////////////////////////////////// // // Contract properties // {{{ //////////////////////////////////////////////////////////////////////// // // (* anyconst *)",
            "reg fc_check; (* anyconst *)",
            "reg [F_LGCOUNT-1:0] fc_posn; (* anyconst *)",
            "reg [7:0] fc_byte;",
            "wire frx_check, ftx_check;",
            "reg [WBLSB-1:0] frx_shift;",
            "reg [WBLSB+1:0] ftx_shift;",
            "reg [DW-1:0] frx_shifted;",
            "reg [2*DW-1:0] ftx_shifted;",
            "always @(*) frx_shift = fc_posn [WBLSB-1:0]- f_rcvd[WBLSB-1:0];",
            "always @(*) if (OPT_LITTLE_ENDIAN) frx_shifted = S_DATA >> (8*frx_shift); else frx_shifted = S_DATA << (8*frx_shift);",
            "assign frx_check = fc_check && S_VALID && f_rcvd <= fc_posn && (fc_posn < f_rcvd + S_BYTES);",
            "always @(*) if (!i_reset && frx_check) begin if (OPT_LITTLE_ENDIAN) begin assume(frx_shifted[7:0] == fc_byte); end else begin assume(frx_shifted[DW-1:DW-8] == fc_byte); end end",
            "always @(*) begin ftx_shift = fc_posn[WBLSB:0]- f_sent[WBLSB:0]; ftx_shift[WBLSB+1] = 0; end",
            "always @(*) if (OPT_LITTLE_ENDIAN) ftx_shifted = s",
            "reg >> (8*ftx_shift); else ftx_shifted = s",
            "reg << (8*ftx_shift);",
            "assign ftx_check = fc_check && f_sent <= fc_posn && (fc_posn < f_sent + fill);",
            "always @(*) if (!i_reset && ftx_check) begin if (OPT_LITTLE_ENDIAN) begin assert(ftx_shifted[7:0] == fc_byte); end else begin assert(ftx_shifted[2*DW-1:2*DW-8] == fc_byte); end end",
            "always @(*) if (!i_reset) begin for(ik=0; ik<2*DW/8; ik=ik+1) if (fill <= ik) begin if (OPT_LITTLE_ENDIAN) assert(s",
            "reg [8*ik +: 8] == 8'h00); else assert(s",
            "reg [2*DW-8-8*ik +: 8] == 8'h00); end end // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // // }}} //////////////////////////////////////////////////////////////////////// // // \"Careless\" assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipdma_mm2s.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma_mm2s.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipdma_mm2s.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: ZipDMA -- Read values from memory // // This is the first component of the DMA sequence. It reads values from // memory, and aligns them with an outgoing data stream. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2022-2023, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipdma_mm2s #( // {{{",
            "parameter ADDRESS_WIDTH = 30, parameter BUS_WIDTH = 64, parameter LGLENGTH = 10, parameter [0:0] OPT_LITTLE_ENDIAN = 1'b0, parameter [0:0] OPT_LOWPOWER = 1'b0, parameter [0:0] OPT_FIRSTBEAT_TRIM = 1'b0, // Abbreviations",
            "localparam DW = BUS_WIDTH, localparam AW = ADDRESS_WIDTH-$clog2(DW/8) // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Configuration // {{{",
            "input wire i_request, output reg o_busy, o_err, input wire i_inc, // # of transferred byte per beat",
            "input wire [1:0] i_size, input wire [LGLENGTH:0] i_transferlen, input wire [ADDRESS_WIDTH-1:0] i_addr, // Byte address // }}} // Wishbone master interface // {{{",
            "output reg o_rd_cyc, o_rd_stb, // Verilator coverage_off",
            "output wire o_rd_we, // Verilator coverage_on",
            "output reg [AW-1:0] o_rd_addr, // Verilator coverage_off",
            "output wire [DW-1:0] o_rd_data, // Verilator coverage_on",
            "output reg [DW/8-1:0] o_rd_sel, input wire i_rd_stall, input wire i_rd_ack, input wire [DW-1:0] i_rd_data, input wire i_rd_err, // }}} // Outgoing Stream interface // {{{",
            "output wire M_VALID, input wire M_READY, // *MUST* be 1",
            "output wire [DW-1:0] M_DATA, // How many bytes are valid?",
            "output wire [$clog2(DW/8):0] M_BYTES, output wire M_LAST // }}} // }}} ); // Local declarations // {{{ // size prefix is # of valid bytes in the beat (one clk cycle) // difference between _size and _len is that \"size\" references the // current beat, whereas _len references the whole transfer. _sel // references which data byte lanes are valid (like WSTRB from AXI // interface) // localparam [1:0] SZ_BYTE = 2'b11, SZ_16B = 2'b10, SZ_32B = 2'b01, SZ_BUS = 2'b00;",
            "localparam WBLSB = $clog2(DW/8);",
            "reg [WBLSB:0] nxtstb_size, rdstb_size, rdack_size, first_size, last_size;",
            "reg r_wrap;",
            "reg [ADDRESS_WIDTH:0] next_addr;",
            "reg [ADDRESS_WIDTH-1:0] last_request_addr;",
            "reg [WBLSB-1:0] subaddr, rdack_subaddr;",
            "reg [DW/8-1:0] nxtstb_sel, first_sel, first_sel_no_shift, base_sel, ibase_sel;",
            "reg [LGLENGTH:0] wb_outstanding;",
            "reg [WBLSB+1:0] fill, next_fill;",
            "reg m_valid, m_last;",
            "reg [DW-1:0] s",
            "reg ;",
            "reg [WBLSB:0] m_bytes;",
            "reg [LGLENGTH:0] rdstb_len, rdack_len;",
            "reg [WBLSB-1:0] pre_shift;",
            "reg [DW-1:0] pre_shifted_data;",
            "reg r_inc;",
            "reg [1:0] r_size;",
            "reg [LGLENGTH:0] r_transferlen;",
            "reg [ADDRESS_WIDTH-1:0] r_addr; // }}}",
            "assign o_rd_we = 1'b0;",
            "assign o_rd_data = {(DW){1'b0}}; // Copy the configuration whenever i_request && !o_busy // {{{",
            "always @(posedge i_clk) if (!o_busy && (!OPT_LOWPOWER || i_request)) begin r_inc <= i_inc; r_size <= i_size; r_transferlen <= i_transferlen; r_addr <= i_addr; end // }}} // nxtstb_size // {{{ generate if (BUS_WIDTH > 32) begin : GEN_NXTSTB_SIZE // {{{",
            "always @(*) begin first_size = 0; case(i_size) SZ_BYTE: first_size = 1; SZ_16B: first_size = (i_addr[0]) ? 1 : 2; // Verilator lint_off WIDTH SZ_32B: first_size = 4 - i_addr[1:0]; SZ_BUS: first_size = (DW/8)-i_addr[WBLSB-1:0]; // Verilator lint_on WIDTH endcase if ({{ (LGLENGTH-WBLSB){1'b0}}, first_size } > i_transferlen) first_size = i_transferlen[WBLSB:0]; end",
            "always @(*) begin nxtstb_size = rdstb_size; last_size = r_addr[WBLSB-1:0]+ r_transferlen[WBLSB-1:0]; case(r_size) SZ_BYTE: nxtstb_size = 1; // Verilator lint_off WIDTH SZ_16B: if (r_transferlen == 2) nxtstb_size = 2 - r_addr[0]; else if (r_transferlen == 3) nxtstb_size = r_addr[0] + 1; else nxtstb_size = (rdstb_len == 3) ? 1 : 2; SZ_32B: begin last_size[WBLSB:2] = 0; if (r_transferlen < 8) begin if (r_transferlen[1:0] + r_addr[1:0] == 0) nxtstb_size = 4; else nxtstb_size = (4 > rdstb_len - rdstb_size) ? last_size : 4; end else nxtstb_size = (rdstb_len >= 4 && rdstb_len < 8) ? (rdstb_len - 4) : 4; end SZ_BUS: begin nxtstb_size = (DW/8); if (DW/8 > rdstb_len - rdstb_size) nxtstb_size= { 1'b0,rdstb_len[WBLSB:0] } - { 1'b0, rdstb_size[WBLSB:0]}; end // Verilator lint_on WIDTH endcase end // }}} end else begin : STD_NXTSTB_SIZE // {{{",
            "always @(*) begin first_size = 0; case(i_size) SZ_BYTE: first_size = 1; SZ_16B: first_size = (i_addr[0]) ? 1:2; // Verilator lint_off WIDTH default: first_size = (DW/8)-i_addr[WBLSB-1:0]; endcase if (first_size > i_transferlen) first_size = i_transferlen; // Verilator lint_on WIDTH end",
            "always @(*) begin nxtstb_size = rdstb_size; last_size = r_addr[WBLSB-1:0]+r_transferlen[WBLSB-1:0]; casez(r_size) SZ_BYTE: nxtstb_size = 1; // Verilator lint_off WIDTH SZ_16B: if (r_transferlen == 2) nxtstb_size = 2 - r_addr[0]; else if (r_transferlen == 3) nxtstb_size = r_addr[0] + 1; else nxtstb_size = (rdstb_len == 3) ? 1 : 2; default: begin last_size[WBLSB:2] = 0; if (r_transferlen < 8) begin if (r_transferlen[1:0] + r_addr[1:0] == 0) nxtstb_size = 4; else nxtstb_size = (4 > rdstb_len - rdstb_size) ? last_size : 4; end else nxtstb_size = (rdstb_len >= 4 && rdstb_len < 8) ? (rdstb_len - 4) : 4; end // Verilator lint_on WIDTH endcase end // }}} end endgenerate // }}} // next_addr // {{{",
            "always @(*) begin next_addr = { 1'b0, o_rd_addr, subaddr }; if (o_rd_stb && !i_rd_stall && r_inc) next_addr = next_addr + { {(ADDRESS_WIDTH-WBLSB-1){1'b0}}, rdstb_size }; end // }}} // o_rd_cyc, o_rd_stb, o_busy, o_err, rdstb_len, rdstb_size // {{{",
            "initial { o_rd_cyc, o_rd_stb } = 2'b00;",
            "initial { o_busy, o_err } = 2'b00;",
            "always @(posedge i_clk) if (i_reset) begin // {{{ o_rd_cyc <= 1'b0; o_rd_stb <= 1'b0; { o_rd_addr, subaddr } <= 0; rdstb_size <= 0; rdstb_len <= 0; o_busy <= 0; o_err <= 0; // }}} end else if ((o_rd_cyc && i_rd_err) || o_err) begin // {{{ o_rd_cyc <= 1'b0; o_rd_stb <= 1'b0; { o_rd_addr, subaddr } <= 0; rdstb_size <= 0; rdstb_len <= 0; o_busy <= o_rd_cyc && i_rd_err; o_err <= o_rd_cyc && i_rd_err; // }}} end else if (!o_busy) begin // {{{ o_rd_cyc <= i_request; o_rd_stb <= i_request; o_busy <= i_request; o_err <= 0; rdstb_size <= 0; rdstb_len <= 0; if (!OPT_LOWPOWER || i_request) begin { o_rd_addr, subaddr } <= i_addr; // rdstb_size rdstb_size <= first_size; // rdstb_len rdstb_len <= i_transferlen; end // }}} end else begin if (!i_rd_stall) o_rd_stb <= 1'b0; if (rdstb_len > { {(LGLENGTH-WBLSB){1'b0}}, rdstb_size }) begin if (r_wrap || next_addr[ADDRESS_WIDTH]) { o_err, o_rd_cyc, o_rd_stb } <= 3'b100; else o_rd_stb <= 1'b1; end if (o_rd_stb && !i_rd_stall) begin // {{{ if (rdstb_len <= { {(LGLENGTH-WBLSB){1'b0}}, rdstb_size }) begin rdstb_len <= 0; end else begin rdstb_len <= rdstb_len - { {(LGLENGTH-WBLSB){1'b0}}, rdstb_size }; end // rdstb_size rdstb_size <= nxtstb_size; { o_rd_addr, subaddr } <= next_addr[ADDRESS_WIDTH-1:0]; // }}} end if (wb_outstanding == (i_rd_ack ? 1:0) && !o_rd_stb) o_rd_cyc <= 1'b0; if (m_valid && m_last) o_busy <= 0; end",
            "initial r_wrap = 1'b0;",
            "always @(posedge i_clk) if (i_reset || (o_rd_cyc && i_rd_err) || o_err || !o_busy) r_wrap <= 1'b0; else if (o_rd_stb && !i_rd_stall) r_wrap <= next_addr[ADDRESS_WIDTH]; `ifdef FORMAL",
            "always @(*) if (o_busy && m_valid && m_last) begin assert(rdack_len == 0); assert(fill == m_bytes); end `endif // }}} // o_rd_sel // {{{ // ibase_sel generate if (BUS_WIDTH > 32) begin : GEN_STRB // {{{",
            "always @(*) begin ibase_sel = 0; if (OPT_LITTLE_ENDIAN) begin // {{{ // Verilator coverage_off case(i_size) SZ_BYTE: ibase_sel = {{(DW/8-1){1'b0}}, 1'b1} << i_addr[WBLSB-1:0]; SZ_16B: ibase_sel = {{(DW/8-2){1'b0}}, 2'h3} << {i_addr[WBLSB-1:1], 1'b0 }; SZ_32B: ibase_sel = {{(DW/8-4){1'b0}}, 4'b1111} << {i_addr[WBLSB-1:2], 2'b0 }; SZ_BUS: ibase_sel = {(DW/8){1'b1}}; endcase // Verilator coverage_on // }}} end else begin // {{{ case(i_size) SZ_BYTE: ibase_sel = {1'h1, {(DW/8-1){1'b0}} } >> i_addr[WBLSB-1:0]; SZ_16B: ibase_sel = {2'h3, {(DW/8-2){1'b0}} } >> {i_addr[WBLSB-1:1], 1'b0 }; SZ_32B: ibase_sel = {4'hf, {(DW/8-4){1'b0}} } >> {i_addr[WBLSB-1:2], 2'b0 }; SZ_BUS: ibase_sel = {(DW/8){1'b1}}; endcase // }}} end end // }}} end else begin : MIN_STRB // {{{",
            "always @(*) if (OPT_LITTLE_ENDIAN) begin // {{{ // Verilator coverage_off case(i_size) SZ_BYTE: ibase_sel = {{(DW/8-1){1'b0}}, 1'b1} << i_addr[WBLSB-1:0]; SZ_16B: ibase_sel = {{(DW/8-2){1'b0}}, 2'h3} << {i_addr[WBLSB-1:1], 1'b0 }; default: ibase_sel = {(DW/8){1'b1}}; endcase // Verilator coverage_on // }}} end else begin // {{{ case(i_size) SZ_BYTE: ibase_sel= {1'h1, {(DW/8-1){1'b0}} } << i_addr[WBLSB-1:0]; SZ_16B: ibase_sel = {2'h3, {(DW/8-2){1'b0}} } << {i_addr[WBLSB-1:1], 1'b0 }; default: ibase_sel = {(DW/8){1'b1}}; endcase // }}} end // }}} end endgenerate",
            "always @(posedge i_clk) if (i_reset || (o_rd_cyc && i_rd_err)) begin base_sel <= 0; end else if (!o_busy) begin base_sel <= 0; if (i_request || !OPT_LOWPOWER) base_sel <= ibase_sel; end else if (o_rd_stb && !i_rd_stall) base_sel <= nxtstb_sel; // nxtstb_sel // {{{ generate if (DW == 32) begin : GEN_NXTSTB_SEL // {{{",
            "always @(*) if (OPT_LITTLE_ENDIAN) begin // Verilator coverage_off case(r_size) SZ_BYTE: nxtstb_sel = { base_sel[DW/8-2:0], base_sel[DW/8-1] }; SZ_16B: nxtstb_sel = { base_sel[DW/8-3:0], base_sel[DW/8-1:DW/8-2] }; default: nxtstb_sel = {(DW/8){1'b1}}; endcase if (!r_inc) nxtstb_sel = base_sel; // Verilator coverage_on end else begin case(r_size) SZ_BYTE: nxtstb_sel = { base_sel[0:0], base_sel[DW/8-1:1] }; SZ_16B: nxtstb_sel = { base_sel[1:0], base_sel[DW/8-1:2] }; default: nxtstb_sel = {(DW/8){1'b1}}; endcase if (!r_inc) nxtstb_sel = base_sel; end // }}} end else begin : GEN_WIDE_NXTSTB_SEL",
            "always @(*) if (OPT_LITTLE_ENDIAN) begin // Verilator coverage_off case(r_size) SZ_BYTE: nxtstb_sel = { base_sel[DW/8-2:0], base_sel[DW/8-1] }; SZ_16B: nxtstb_sel = { base_sel[DW/8-3:0], base_sel[DW/8-1:DW/8-2] }; SZ_32B: nxtstb_sel = { base_sel[DW/8-5:0], base_sel[DW/8-1:DW/8-4] }; SZ_BUS: nxtstb_sel = {(DW/8){1'b1}}; endcase if (!r_inc) nxtstb_sel = base_sel; // Verilator coverage_on end else begin case(r_size) SZ_BYTE: nxtstb_sel = { base_sel[0:0], base_sel[DW/8-1:1] }; SZ_16B: nxtstb_sel = { base_sel[1:0], base_sel[DW/8-1:2] }; SZ_32B: nxtstb_sel = { base_sel[3:0], base_sel[DW/8-1:4] }; SZ_BUS: nxtstb_sel = {(DW/8){1'b1}}; endcase if (!r_inc) nxtstb_sel = base_sel; end end endgenerate // }}} // first_sel generate if (BUS_WIDTH > 32) begin : GEN_FIRST_SEL // {{{",
            "always @(*) begin first_sel_no_shift = 0; first_sel = 0; // Verilator lint_off WIDTH if (!OPT_FIRSTBEAT_TRIM || i_transferlen >= DW/8) first_sel_no_shift = -1; else if (OPT_LITTLE_ENDIAN) first_sel_no_shift = (1 << i_transferlen) - 1; else first_sel_no_shift = ({(DW/8){1'b1}} << (DW/8 - i_transferlen)); // Verilator lint_on WIDTH if (OPT_LITTLE_ENDIAN) begin // {{{ // Verilator coverage_off case(i_size) SZ_BYTE: first_sel = {{(DW/8-1){1'b0}}, 1'b1} << i_addr[WBLSB-1:0]; SZ_16B: begin first_sel_no_shift = first_sel_no_shift << i_addr[0]; first_sel_no_shift[DW/8-1:2] = 0; first_sel = first_sel_no_shift << {i_addr[WBLSB-1:1], 1'b0 }; end SZ_32B: begin first_sel_no_shift = first_sel_no_shift << i_addr[1:0]; first_sel_no_shift[DW/8-1:4] = 0; first_sel = first_sel_no_shift << {i_addr[WBLSB-1:2], 2'b00 }; end SZ_BUS: first_sel = first_sel_no_shift << i_addr[WBLSB-1:0]; endcase // Verilator coverage_on // }}} end else begin // {{{ case(i_size) SZ_BYTE: first_sel = {1'b1, {(DW/8-1){1'b0}} } >> i_addr[WBLSB-1:0]; SZ_16B: begin first_sel_no_shift = first_sel_no_shift >> i_addr[0]; first_sel_no_shift[DW/8-3:0] = 0; first_sel = first_sel_no_shift >> {i_addr[WBLSB-1:1], 1'b0 }; end SZ_32B: begin first_sel_no_shift = first_sel_no_shift >> i_addr[1:0]; first_sel_no_shift[DW/8-5:0] = 0; first_sel = first_sel_no_shift >> {i_addr[WBLSB-1:2], 2'b00 }; end SZ_BUS: first_sel = first_sel_no_shift >> i_addr[WBLSB-1:0]; endcase // }}} end end // }}} end else begin : MIN_FIRST_SEL // {{{",
            "always @(*) begin first_sel_no_shift = 0; first_sel = 0; if (!OPT_FIRSTBEAT_TRIM || i_transferlen >= DW/8) first_sel_no_shift = -1; else if (OPT_LITTLE_ENDIAN) first_sel_no_shift = (1 << i_transferlen) - 1; else first_sel_no_shift = ({(DW/8){1'b1}} << (DW/8 - i_transferlen)); if (OPT_LITTLE_ENDIAN) begin // {{{ // Verilator coverage_off case(i_size) SZ_BYTE: first_sel = {{(DW/8-1){1'b0}}, 1'b1} << i_addr[WBLSB-1:0]; SZ_16B: begin first_sel_no_shift = first_sel_no_shift << i_addr[0]; first_sel_no_shift[DW/8-1:2] = 0; first_sel = first_sel_no_shift << {i_addr[WBLSB-1:1], 1'b0 }; end default: first_sel = first_sel_no_shift << i_addr[WBLSB-1:0]; endcase // Verilator coverage_on // }}} end else begin // {{{ case(i_size) SZ_BYTE: first_sel = {1'b1, {(DW/8-1){1'b0}} } >> i_addr[WBLSB-1:0]; SZ_16B: begin first_sel_no_shift = first_sel_no_shift >> i_addr[0]; first_sel_no_shift[DW/8-3:0] = 0; first_sel = first_sel_no_shift >> {i_addr[WBLSB-1:1], 1'b0 }; end default: first_sel = first_sel_no_shift >> i_addr[WBLSB-1:0]; endcase // }}} end end // }}} end endgenerate // o_rd_sel",
            "always @(posedge i_clk) if (i_reset || (o_rd_cyc && i_rd_err)) begin o_rd_sel <= 0; end else if (!o_busy) begin // {{{ o_rd_sel <= {(DW/8){1'b0}}; if (!OPT_LOWPOWER || i_request) o_rd_sel <= first_sel; // }}} end else if (o_rd_stb && !i_rd_stall) o_rd_sel <= nxtstb_sel; // }}} // wb_outstanding // {{{",
            "initial wb_outstanding = 0;",
            "always @(posedge i_clk) if (i_reset || !o_rd_cyc || i_rd_err) wb_outstanding <= 0; // wb_pipeline_full <= 1'b0; else case({ (o_rd_stb && !i_rd_stall), i_rd_ack }) 2'b10: wb_outstanding <= wb_outstanding + 1; 2'b01: wb_outstanding <= wb_outstanding - 1; default: begin end endcase // }}} // rdack_subaddr // {{{",
            "always @(posedge i_clk) if (!o_busy) begin if (!OPT_LOWPOWER || i_request) rdack_subaddr <= i_addr[WBLSB-1:0]; end else if (i_rd_ack) begin // Verilator lint_off WIDTH if (r_inc) rdack_subaddr <= rdack_subaddr + rdack_size; else case(r_size) SZ_BYTE: begin end SZ_16B: rdack_subaddr[ 0] <= 1'b0; SZ_32B: rdack_subaddr[1:0] <= 2'b0; SZ_BUS: rdack_subaddr[WBLSB-1:0] <= {(WBLSB){1'b0}}; endcase // Verilator lint_on WIDTH end // }}} // rdack_len // {{{ // Total length remaining, from the perspective of the bus return. // Hence, on any bus return, we drop by the number of bytes valid // in that return, or minus rdack_size.",
            "always @(posedge i_clk) if (!o_busy) begin if (!OPT_LOWPOWER || i_request) rdack_len <= i_transferlen; end else if (i_rd_ack) begin rdack_len <= rdack_len-{ {(LGLENGTH-WBLSB){1'b0}}, rdack_size }; if (rdack_len <= { {(LGLENGTH-WBLSB){1'b0}}, rdack_size }) rdack_len <= 0; end // }}} // rdack_size // {{{",
            "always @(posedge i_clk) if (!o_busy) begin if (!OPT_LOWPOWER || i_request) rdack_size <= first_size; end else if (i_rd_ack) begin case(r_size) SZ_BYTE:rdack_size <= 1; // Verilator lint_off WIDTH SZ_16B: if (rdack_len > 2 + rdack_size) rdack_size <= 2; else rdack_size <= rdack_len - rdack_size; SZ_32B: if (rdack_len > 4 + rdack_size) rdack_size <= 4; else rdack_size <= rdack_len - rdack_size; SZ_BUS: if (rdack_len > DW/8 + rdack_size) rdack_size <= DW/8; else rdack_size <= rdack_len - rdack_size; // Verilator lint_on WIDTH endcase end // }}} // fill, next_fill (depends on rdack_size) // {{{",
            "always @(*) begin next_fill = (M_VALID) ? 0 : fill; if (i_rd_ack) next_fill = next_fill + { 1'b0, rdack_size }; end",
            "always @(posedge i_clk) if (!o_busy) fill <= 0; else fill <= next_fill; // }}} // m_valid // {{{",
            "initial m_valid = 0;",
            "always @(posedge i_clk) if (i_reset || !o_busy) m_valid <= 1'b0; else begin m_valid <= 0; if ((!m_valid || !m_last) && rdack_len == 0 && fill > 0) m_valid <= 1; else if (o_rd_cyc && i_rd_ack) m_valid <= 1'b1; end // }}} // s",
            "reg // {{{",
            "initial pre_shift = 0;",
            "always @(posedge i_clk) if (!o_busy) begin pre_shift <= 0; if (!OPT_LOWPOWER || i_request) pre_shift <= i_addr[WBLSB-1:0]; end else if (o_rd_cyc && i_rd_ack) begin case(r_size) SZ_BYTE: pre_shift <= pre_shift + (r_inc ? 1 : 0); SZ_16B: begin // {{{ pre_shift <= pre_shift + (r_inc ? 2 : 0); pre_shift[0] <= 1'b0; end // }}} SZ_32B: begin // {{{ // Verilator lint_off WIDTH pre_shift <= pre_shift + (r_inc ? 4 : 0); // Verilator lint_on WIDTH pre_shift[1:0] <= 2'b0; end // }}} SZ_BUS: pre_shift <= 0; endcase end",
            "always @(*) if (OPT_LITTLE_ENDIAN) pre_shifted_data = i_rd_data >> (8*pre_shift); else pre_shifted_data = i_rd_data << (8*pre_shift);",
            "initial s",
            "reg = 0;",
            "always @(posedge i_clk) if (!o_busy) s",
            "reg <= 0; else if (o_rd_cyc && i_rd_ack) begin // {{{ // Verilator lint_off WIDTH s",
            "reg <= pre_shifted_data; // Verilator lint_on WIDTH // }}} end else if (m_valid) begin // {{{ s",
            "reg <= {(DW){1'b0}}; // }}} end // }}} // m_bytes // {{{",
            "initial m_bytes = 0;",
            "always @(posedge i_clk) if (!o_busy) begin m_bytes <= 0; end else if (i_rd_ack) begin if (|next_fill[WBLSB+1:WBLSB]) // if next_fill >= DW/8) // Verilator lint_off WIDTH m_bytes <= DW/8; // Verilator lint_on WIDTH else m_bytes <= { 1'b0, next_fill[WBLSB-1:0] }; end else if (rdack_len == 0) m_bytes <= next_fill[WBLSB:0]; // }}} // m_last // {{{",
            "always @(*) begin last_request_addr = i_addr; if (r_inc) // Verilator lint_off WIDTH last_request_addr = i_addr + i_transferlen - 1; // Verilator lint_on WIDTH end",
            "initial m_last = 0;",
            "always @(posedge i_clk) if (i_reset) m_last <= 1'b0; else if (!o_busy) begin m_last <= 1'b0; if (!OPT_LOWPOWER || i_request) case(i_size) SZ_BYTE: m_last <= (i_transferlen <= 1); SZ_16B: m_last <= (last_request_addr[ADDRESS_WIDTH-1:1] != i_addr[ADDRESS_WIDTH-1:1]); SZ_32B: m_last <= (last_request_addr[ADDRESS_WIDTH-1:2] != i_addr[ADDRESS_WIDTH-1:2]); SZ_BUS: m_last <= (last_request_addr[ADDRESS_WIDTH-1:WBLSB] != i_addr[ADDRESS_WIDTH-1:WBLSB]); endcase end else if (i_rd_ack) begin // Verilator lint_off WIDTH m_last <= (rdack_len <= rdack_size) && (next_fill <= DW/8); // Verilator lint_on WIDTH end else if (rdack_len == 0) m_last <= 1; // }}}",
            "assign M_VALID = m_valid;",
            "assign M_DATA = s",
            "reg ;",
            "assign M_BYTES= m_bytes;",
            "assign M_LAST = m_last; // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, M_READY, last_request_addr[0], r_addr[ADDRESS_WIDTH-1:WBLSB] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // localparam [0:0] CONTRACT = 1'b1;",
            "localparam F_LGDEPTH = LGLENGTH+1-WBLSB;",
            "localparam F_LGCOUNT = LGLENGTH+1;",
            "reg f_past_valid;",
            "wire [F_LGDEPTH-1:0] fwb_nreqs, fwb_nacks, fwb_outstanding; (* anyconst *)",
            "reg f_cfg_inc; (* anyconst *)",
            "reg [1:0] f_cfg_size; (* anyconst *)",
            "reg [ADDRESS_WIDTH-1:0] f_cfg_addr; (* anyconst *)",
            "reg [LGLENGTH:0] f_cfg_len;",
            "reg [DW/8-1:0] f_base_sel;",
            "reg [F_LGCOUNT-1:0] f_rcvd, f_sent;",
            "reg [WBLSB:0] f_ack_size, f_stb_size;",
            "reg [F_LGCOUNT-1:0] f_outstanding_bytes;",
            "reg f_stb_first, f_stb_last, f_ack_first, f_ack_last; (* keep *)",
            "reg [WBLSB-1:0] f_excess_last_return, lower_len_bits;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1;",
            "always @(*) if (!f_past_valid) assume(i_reset); //////////////////////////////////////////////////////////////////////// // // Configuration properties // {{{ //////////////////////////////////////////////////////////////////////// // // // Handshake property",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset) || $past(o_err)) begin assume(!i_request); end else if ($past(o_busy || i_request)) begin assume(i_request); assume($stable(i_inc)); assume($stable(i_size)); assume($stable(i_addr)); assume($stable(i_transferlen)); end // Assume the DMA request is for an arbitrary value we can track",
            "always @(*) begin assume(f_cfg_len > 0); if (i_request && !o_busy) begin assume(i_inc == f_cfg_inc); assume(i_size == f_cfg_size); assume(i_addr == f_cfg_addr); assume(i_transferlen == f_cfg_len); end else if (o_busy) begin assert(r_inc == f_cfg_inc); assert(r_size == f_cfg_size); assert(r_addr == f_cfg_addr); assert(r_transferlen == f_cfg_len); end end // }}} //////////////////////////////////////////////////////////////////////// // // f_stb_first, f_stb_last, f_ack_first, f_ack_last // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) f_stb_first = (rdstb_len == f_cfg_len);",
            "always @(*) if (rdstb_len == 0) f_stb_last <= 1'b0; else case(r_size) SZ_BYTE: f_stb_last <= (rdstb_len == 1); SZ_16B: f_stb_last <= (rdstb_len + f_excess_last_return[0] == 2); SZ_32B: f_stb_last <= (rdstb_len + f_excess_last_return[1:0] == 4); SZ_BUS: f_stb_last <= (rdstb_len + f_excess_last_return[WBLSB-1:0] == DW/8); endcase",
            "always @(*) f_ack_first = (f_rcvd == 0);",
            "always @(*) if (rdack_len == 0) f_ack_last <= 1'b0; else case(r_size) SZ_BYTE: f_ack_last <= (rdack_len == 1); SZ_16B: f_ack_last <= (rdack_len + f_excess_last_return[0] == 2); SZ_32B: f_ack_last <= (rdack_len + f_excess_last_return[1:0] == 4); SZ_BUS: f_ack_last <= (rdack_len + f_excess_last_return[WBLSB-1:0] == DW/8); endcase // }}} //////////////////////////////////////////////////////////////////////// // // f_excess_last_return // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) begin f_excess_last_return = f_cfg_addr + f_cfg_len; case(r_size) SZ_BYTE: f_excess_last_return = 0; SZ_16B: begin f_excess_last_return = 2 - f_excess_last_return[0]; f_excess_last_return[WBLSB-1:1] = 0; end SZ_32B: begin f_excess_last_return = 4 - f_excess_last_return[1:0]; f_excess_last_return[WBLSB-1:2] = 0; end SZ_BUS: f_excess_last_return = (DW/8) - f_excess_last_return[WBLSB-1:0]; endcase end // }}} //////////////////////////////////////////////////////////////////////// // // first_size // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (!i_reset && o_busy && !o_err) begin case(r_size) SZ_BYTE: assert(first_size == 1); SZ_16B: assert(first_size == (f_cfg_addr[0]) ? 1 : 2); SZ_32B: assert(first_size == 4 - f_cfg_addr[1:0]); SZ_BUS: assert(first_size == (DW/8) - f_cfg_addr[WBLSB-1:0]); endcase if (first_size > f_cfg_len) assert(first_size == f_cfg_len); end // }}} //////////////////////////////////////////////////////////////////////// // // o_rd_addr, subaddr // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if(!i_reset && o_busy && !o_err) begin if (!r_inc) begin assert({ o_rd_addr, subaddr } == f_cfg_addr); end else if (rdstb_len != 0) assert({ o_rd_addr, subaddr } == f_cfg_addr + f_rcvd + f_outstanding_bytes); end",
            "always @(*) if (!i_reset && o_busy && !o_err && r_inc && r_size == SZ_BUS && (wb_outstanding > 0 || f_rcvd > 0) && rdstb_len != 0) assert(subaddr == 0);",
            "always @(*) if (!i_reset && o_busy && r_inc) assert( {1'b0, f_cfg_addr} + f_rcvd <= { 1'b1, { (ADDRESS_WIDTH){1'b0} }}); // }}} //////////////////////////////////////////////////////////////////////// // // Wishbone properties // {{{ //////////////////////////////////////////////////////////////////////// // // fwb_master #( // {{{ .AW(AW), .DW(DW), .F_LGDEPTH(F_LGDEPTH), .F_OPT_RMW_BUS_OPTION(1'b0), .F_OPT_DISCONTINUOUS(1'b0), .F_OPT_SOURCE(1'b1), .F_OPT_MINCLOCK_DELAY(1'b1) // }}} ) fwb ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // .i_wb_cyc(o_rd_cyc), .i_wb_stb(o_rd_stb), .i_wb_we(o_rd_we), .i_wb_addr(o_rd_addr), .i_wb_data(o_rd_data), .i_wb_sel(o_rd_sel), // .i_wb_stall(i_rd_stall), .i_wb_ack(i_rd_ack), .i_wb_idata(i_rd_data), .i_wb_err(i_rd_err), // .f_nreqs(fwb_nreqs), .f_nacks(fwb_nacks), .f_outstanding(fwb_outstanding) // }}} );",
            "always @(*) assert(!o_rd_we);",
            "always @(*) if (!i_reset && !o_busy) assert(!o_rd_cyc); // }}} //////////////////////////////////////////////////////////////////////// // // wb_outstanding // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (!i_reset && f_past_valid && o_rd_cyc) assert(fwb_outstanding == wb_outstanding);",
            "always @(*) if (wb_outstanding == 0) f_outstanding_bytes = 0; else case(r_size) SZ_BYTE: f_outstanding_bytes = wb_outstanding; SZ_16B: if (!f_ack_first) f_outstanding_bytes = wb_outstanding * 2; else f_outstanding_bytes = wb_outstanding * 2 - f_cfg_addr[0]; SZ_32B: if (!f_ack_first) f_outstanding_bytes = wb_outstanding * 4; else f_outstanding_bytes = wb_outstanding * 4 - f_cfg_addr[1:0]; SZ_BUS: if (!f_ack_first) f_outstanding_bytes = wb_outstanding * (DW/8); else f_outstanding_bytes = wb_outstanding * (DW/8) - f_cfg_addr[WBLSB-1:0]; endcase",
            "always @(*) if (!i_reset && o_busy && !o_err) assert(f_outstanding_bytes <= f_cfg_len + ((rdstb_len == 0) ? f_excess_last_return : 0)); // }}} //////////////////////////////////////////////////////////////////////// // // base_sel // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (!i_reset && $past(o_busy) && o_busy && !o_err) assert(base_sel != 0);",
            "always @(*) if (OPT_LITTLE_ENDIAN) begin case(r_size) SZ_BYTE: f_base_sel = { {(DW/8-1){1'b0}}, 1'h1 } << subaddr; SZ_16B: f_base_sel = { {(DW/8-2){1'b0}}, 2'h3 } << { subaddr[WBLSB-1:1], 1'b0 }; SZ_32B: f_base_sel = { {(DW/8-4){1'b0}}, 4'hf } << { subaddr[WBLSB-1:1], 2'b00 }; SZ_BUS: if (r_inc || (!r_inc && f_stb_first)) f_base_sel = { (DW/8){1'b1} } << subaddr; else f_base_sel = { (DW/8){1'b1} }; endcase end else begin case(r_size) SZ_BYTE: f_base_sel = { 1'h1, {(DW/8-1){1'b0}} } >> subaddr; SZ_16B: f_base_sel = { 2'h3, {(DW/8-2){1'b0}} } >> { subaddr[WBLSB-1:1], 1'b0 }; SZ_32B: f_base_sel = { 4'hf, {(DW/8-4){1'b0}} } >> { subaddr[WBLSB-1:2], 2'b00 }; SZ_BUS: if (r_inc || (!r_inc && f_stb_first)) f_base_sel = { (DW/8){1'b1} } >> subaddr; else f_base_sel = { (DW/8){1'b1} }; endcase end",
            "always @(posedge i_clk) if (!i_reset && $past(o_busy) && o_busy && !o_err && rdstb_len > 0) begin if (r_size == SZ_BUS) begin assert(base_sel == { (DW/8){1'b1} }); end else begin assert(base_sel == f_base_sel); end end // }}} //////////////////////////////////////////////////////////////////////// // // o_rd_sel // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (!i_reset && o_busy && !o_err) begin assert(fill < (DW/8) + (M_VALID ? DW/8 : 0)); if (rdstb_len != 0 || rdstb_len != rdstb_size) assert(rdstb_size <= $countones(o_rd_sel)); if (!r_inc) case(r_size) SZ_BYTE: assert(o_rd_sel == base_sel); SZ_16B: assert(o_rd_sel == (f_cfg_len < 2) ? first_sel : base_sel); SZ_32B: assert(o_rd_sel == (f_cfg_len < 4) ? first_sel : base_sel); SZ_BUS: assert(o_rd_sel == (f_cfg_len < DW/8) ? first_sel : base_sel); endcase end",
            "always @(*) if (!i_reset && f_past_valid && o_rd_stb && r_inc && !f_stb_last) begin assert(o_rd_sel != 0); if (OPT_LITTLE_ENDIAN) begin case(r_size) SZ_BYTE:assert(o_rd_sel == { {(DW/8-1){1'b0}}, 1'b1 } << subaddr); SZ_16B: if (f_cfg_len < 2) begin if (i_addr[0]) begin assert(o_rd_sel == { {(DW/8-2){1'b0}}, 2'b01 } << { subaddr[WBLSB-1:1], 1'b0 }); end else begin assert(o_rd_sel == { {(DW/8-2){1'b0}}, 2'b10 } << { subaddr[WBLSB-1:1], 1'b0 }); end end else if (i_addr[0]) begin assert(o_rd_sel == { {(DW/8-2){1'b0}}, 2'b01 } << { subaddr[WBLSB-1:1], 1'b0 }); end else begin assert(o_rd_sel == { {(DW/8-2){1'b0}}, 2'b11 } << { subaddr[WBLSB-1:1], 1'b0 }); end SZ_32B: if (f_cfg_len < 4) begin assert(o_rd_sel == { {(DW/8-4){1'b0}}, (4'b1111 << (4 - f_cfg_len)) } << { subaddr[WBLSB-1:2], 2'b00 }); end else begin assert(o_rd_sel == { {(DW/8-4){1'b0}}, 4'b1111 } << { subaddr[WBLSB-1:2], 2'b00 }); end SZ_BUS: if (f_cfg_len < DW/8) begin assert(o_rd_sel == { (DW/8){1'b1} } << (DW/8 - f_cfg_len)); end else if (rdstb_len == f_cfg_len) begin assert(o_rd_sel == { (DW/8){1'b1} } << subaddr); end else begin assert(o_rd_sel == { (DW/8){1'b1} }); end endcase end else case(r_size) SZ_BYTE:assert(o_rd_sel == { 1'b1, {(DW/8-1){1'b0}} } >> subaddr); SZ_16B: if (f_cfg_len < 2) begin if (i_addr[0]) begin assert(o_rd_sel == { 2'b01, {(DW/8-2){1'b0}} } >> { subaddr[WBLSB-1:1], 1'b0 }); end else begin assert(o_rd_sel == { 2'b10, {(DW/8-2){1'b0}} } >> { subaddr[WBLSB-1:1], 1'b0 }); end end else if (subaddr[0]) begin assert(o_rd_sel == { 2'b01, {(DW/8-2){1'b0}} } >> { subaddr[WBLSB-1:1], 1'b0 }); end else begin assert(o_rd_sel == { 2'b11, {(DW/8-2){1'b0}} } >> { subaddr[WBLSB-1:1], 1'b0 }); end SZ_32B: if (f_cfg_len < 4) begin if (i_addr[1:0] == 2'b00) begin assert(o_rd_sel == {(4'b1111 >> (4 - f_cfg_len)), {(DW/8-4){1'b0}} } >> { subaddr[WBLSB-1:2], 2'b00 }); end else if (f_cfg_len[1:0] < (4 - subaddr[1:0])) begin assert(o_rd_sel == {(4'b1111 >> (4 - f_cfg_len)), {(DW/8-4){1'b0}} } >> { subaddr[WBLSB-1:2], 2'b00 }); end else begin assert(o_rd_sel == {(4'b1111 >> (subaddr[1:0])), {(DW/8-4){1'b0}} } >> { subaddr[WBLSB-1:2], 2'b00 }); end end else if (subaddr[1:0] == 2'b00) begin assert(o_rd_sel == { 4'b1111, {(DW/8-4){1'b0}} } >> { subaddr[WBLSB-1:2], 2'b00 }); end else begin assert(o_rd_sel == { (4'b1111 >> subaddr[1:0]), {(DW/8-4){1'b0}} } >> { subaddr[WBLSB-1:2], 2'b00 }); end SZ_BUS: if (f_cfg_len < DW/8) begin if (i_addr[WBLSB-1:0] == 0) begin assert(o_rd_sel == { (DW/8){1'b1} } >> (DW/8 - f_cfg_len - subaddr)); end else if (f_cfg_len[WBLSB-1:0] < (DW/8 - subaddr)) begin assert(o_rd_sel == { (DW/8){1'b1} } >> (DW/8 - f_cfg_len)); end else begin assert(o_rd_sel == { (DW/8){1'b1} } >> (subaddr)); end end else if (f_stb_first) begin assert(o_rd_sel == { (DW/8){1'b1} } >> subaddr); end else begin assert(o_rd_sel == { (DW/8){1'b1} }); end endcase end // }}} //////////////////////////////////////////////////////////////////////// // // rdstb_size // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) begin case(r_size) SZ_BYTE: f_stb_size = 1; SZ_16B: f_stb_size = 2; SZ_32B: f_stb_size = 4; SZ_BUS: f_stb_size = DW/8; endcase if (rdstb_len == f_cfg_len) case(r_size) SZ_BYTE: f_stb_size = 1; SZ_16B: f_stb_size = (2 - r_addr[ 0]); SZ_32B: f_stb_size = (4 - r_addr[1:0]); SZ_BUS: f_stb_size = (DW/8 - r_addr[WBLSB-1:0]); endcase end",
            "always @(*) if (!i_reset && o_busy && !o_err && o_rd_cyc && o_rd_stb) begin if (f_stb_first && f_stb_last) begin // means that packet is one word only assert(rdstb_size == f_cfg_len); end else if (f_stb_last) begin assert(rdstb_size == rdstb_len); end else begin assert(rdstb_size == f_stb_size); end end",
            "always @(*) if(!i_reset && o_busy && !o_err && rdstb_len > 0) assert(rdstb_size <= rdstb_len); // }}} //////////////////////////////////////////////////////////////////////// // // rdack_size // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) begin case(r_size) SZ_BYTE: f_ack_size = 1; SZ_16B: f_ack_size = 2; SZ_32B: f_ack_size = 4; SZ_BUS: f_ack_size = DW/8; endcase if (f_rcvd == 0) case(r_size) SZ_BYTE: f_ack_size = 1; SZ_16B: f_ack_size = (2 - r_addr[ 0]); SZ_32B: f_ack_size = (4 - r_addr[1:0]); SZ_BUS: f_ack_size = (DW/8 - r_addr[WBLSB-1:0]); endcase if (f_rcvd + f_ack_size > r_transferlen) f_ack_size = r_transferlen - f_rcvd; end",
            "always @(*) if (!i_reset && o_busy && !o_err && o_rd_cyc) begin if (f_ack_first && f_ack_last) begin // means that packet is one word only assert(rdack_size == f_cfg_len); end else if (f_ack_last) begin assert(rdack_size == rdack_len); end else begin assert(rdack_size == f_ack_size); end end // }}} //////////////////////////////////////////////////////////////////////// // // rdstb_len, rdack_len // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (!i_reset && o_busy && !o_err && o_rd_cyc) begin if (!f_stb_first) begin case(r_size) // Check the rdstb_len whether is odd or even SZ_16B: if (f_cfg_len > 2 && rdstb_len != 0) begin assert(rdstb_len[0] == (f_cfg_addr[0] ^ f_cfg_len[0])); end SZ_32B: if (f_cfg_len > 4 && rdstb_len != 0) begin lower_len_bits = f_cfg_len - (4 - f_cfg_addr[1:0]); assert(rdstb_len[1:0] == ((f_cfg_addr[1:0] == 2'b00) ? f_cfg_len[1:0] : lower_len_bits[1:0])); end SZ_BUS: if (f_cfg_len > DW/8 && rdstb_len != 0) begin lower_len_bits = f_cfg_len - (DW/8 - f_cfg_addr[WBLSB-1:0]); assert(rdstb_len[WBLSB-1:0] == ((f_cfg_addr[WBLSB-1:0] == 0) ? f_cfg_len[WBLSB-1:0] : lower_len_bits[WBLSB-1:0])); end endcase if (f_stb_last) begin case(r_size) SZ_BYTE: assert(rdstb_len == 1); SZ_16B: assert(rdstb_len == 2 - f_excess_last_return[0]); SZ_32B: assert(rdstb_len == 4 - f_excess_last_return[1:0]); SZ_BUS: assert(rdstb_len == (DW/8) - f_excess_last_return[WBLSB-1:0]); endcase end if (!f_ack_first) begin if (r_size != 2'b11) begin assert(rdack_len[0] == (f_cfg_addr[0] ^ f_cfg_len[0])); end if (f_ack_last) begin case(r_size) SZ_BYTE: assert(rdack_len == 1); SZ_16B: assert(rdack_len == 2 - f_excess_last_return[0]); SZ_32B: assert(rdack_len == 4 - f_excess_last_return[1:0]); SZ_BUS: assert(rdack_len == (DW/8) - f_excess_last_return[WBLSB-1:0]); endcase end end end end",
            "always @(*) if(!i_reset && o_busy && !o_err && !f_ack_first) begin assert(f_rcvd <= f_cfg_len + DW/8 - 1); if(rdstb_len != 0) assert(f_cfg_len == f_rcvd + f_outstanding_bytes + rdstb_len); end",
            "always @(*) if(!i_reset && o_busy && !o_err) begin assert(rdack_len <= f_cfg_len); assert(rdstb_len <= rdack_len); if(rdstb_len != 0) begin assert(rdack_len == rdstb_len + f_outstanding_bytes); end else begin assert(f_outstanding_bytes == rdack_len + ((rdstb_len == 0 && rdack_len != 0) ? f_excess_last_return : 0)); end end",
            "always @(*) if(!i_reset && o_busy && !o_err) assert(rdstb_len != 0 || !o_rd_stb); // }}} //////////////////////////////////////////////////////////////////////// // // f_rcvd // {{{ //////////////////////////////////////////////////////////////////////// // // initial f_rcvd = 0;",
            "always @(posedge i_clk) if (i_reset || !o_busy || (o_rd_cyc && i_rd_err)) f_rcvd <= 0; else if (o_rd_cyc && i_rd_ack) begin if (f_rcvd == 0) begin case(r_size) SZ_BYTE: f_rcvd <= f_rcvd + 1; SZ_16B: f_rcvd <= f_rcvd + (f_cfg_len < 2) ? 1 : (2 - f_cfg_addr[0]); SZ_32B: f_rcvd <= f_rcvd + (f_cfg_len < (4 - f_cfg_addr[1:0])) ? f_cfg_len : (4 - f_cfg_addr[1:0]); SZ_BUS: f_rcvd <= f_rcvd + (f_cfg_len < (DW/8 - f_cfg_addr[WBLSB-1:0])) ? f_cfg_len : (DW/8 - f_cfg_addr[WBLSB-1:0]); endcase end else if (f_ack_last) begin case(r_size) SZ_BYTE: f_rcvd <= f_rcvd + 1; SZ_16B: f_rcvd <= f_rcvd + (2 - f_excess_last_return[0]); SZ_32B: f_rcvd <= f_rcvd + (4 - f_excess_last_return[1:0]); SZ_BUS: f_rcvd <= f_rcvd + (DW/8 - f_excess_last_return[WBLSB-1:0]); endcase end else begin case(r_size) SZ_BYTE: f_rcvd <= f_rcvd + 1; SZ_16B: f_rcvd <= f_rcvd + 2; SZ_32B: f_rcvd <= f_rcvd + 4; SZ_BUS: f_rcvd <= f_rcvd + DW/8; endcase end end",
            "always @(*) if (!i_reset && o_busy && !o_err && rdack_len != 0) assert(f_rcvd == f_cfg_len - rdack_len); // }}} //////////////////////////////////////////////////////////////////////// // // Outgoing stream properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (!f_past_valid || $past(i_reset)) assert(!M_VALID);",
            "always @(*) if (!i_reset && o_busy && !o_err && !M_VALID) assert(fill == 0);",
            "always @(*) if (!i_reset && o_busy && M_VALID) begin assert(M_BYTES > 0); assert(M_BYTES <= (DW/8)); if (M_LAST) assert(!o_rd_stb); end",
            "always @(*) if (!i_reset && o_busy) assert(f_sent <= r_transferlen);",
            "always @(*) if (!i_reset && o_busy) begin if (!M_VALID) begin assert(f_rcvd == f_sent); end else assert(f_rcvd == f_sent + M_BYTES); end",
            "always @(*) if (!i_reset && o_busy && !o_rd_stb && !o_err) assert(rdstb_len == 0);",
            "initial f_sent = 0;",
            "always @(posedge i_clk) if (i_reset || !o_busy || (o_rd_cyc && i_rd_err)) f_sent <= 0; else if (M_VALID && M_READY) begin if (M_LAST) f_sent <= 0; else f_sent <= f_sent + M_BYTES; end // }}} //////////////////////////////////////////////////////////////////////// // // \"Contract\" properties // {{{ //////////////////////////////////////////////////////////////////////// // // // `define CONTRACT `ifdef CONTRACT (* anyconst *)",
            "reg fc_check; (* anyconst *)",
            "reg [F_LGCOUNT-1:0] fc_posn; (* anyconst *)",
            "reg [7:0] fc_byte;",
            "wire fwb_check, fm_check; (* keep *)",
            "reg [WBLSB-1:0] fwb_shift, fm_shift; (* keep *)",
            "reg [DW-1:0] fwb_shifted, fm_shifted; // Assume a known response from the bus // {{{",
            "assign fwb_check = fc_check && (o_rd_cyc && i_rd_ack) && (f_rcvd <= fc_posn) && (fc_posn < f_rcvd + f_ack_size);",
            "always @(*) if (!i_reset && o_busy && !o_err && rdstb_len != f_cfg_len && rdstb_len > rdstb_size && !r_inc) assert(pre_shift == r_addr[WBLSB-1:0]);",
            "always @(*) begin fwb_shift = fc_posn - f_rcvd; fwb_shift = fwb_shift + pre_shift; end",
            "always @(*) if (OPT_LITTLE_ENDIAN) fwb_shifted = i_rd_data >> (8*fwb_shift); else fwb_shifted = i_rd_data << (8*fwb_shift);",
            "always @(*) if (!i_reset && fwb_check) begin if (OPT_LITTLE_ENDIAN) begin assume(fwb_shifted[7:0] == fc_byte); end else begin assume(fwb_shifted[DW-1:DW-8] == fc_byte); end end // }}} // Assert a specific",
            "output // {{{",
            "assign fm_check = fc_check && M_VALID && (f_sent <= fc_posn) && (fc_posn < f_sent + fill);",
            "always @(*) fm_shift = fc_posn - f_sent;",
            "always @(*) if (OPT_LITTLE_ENDIAN) fm_shifted = s",
            "reg >> (8*fm_shift); else fm_shifted = s",
            "reg << (8*fm_shift);",
            "always @(*) if (!i_reset && fm_check) begin if (OPT_LITTLE_ENDIAN) begin assert(fm_shifted[7:0] == fc_byte); end else begin assert(fm_shifted[DW-1:DW-8] == fc_byte); end end // }}} `endif // CONTRACT // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) begin cover(!i_reset && i_request); cover(o_busy); cover(o_rd_cyc); cover(o_rd_cyc && i_rd_ack); end `ifdef CONTRACT",
            "always @(*) cover(!i_reset && fm_check); `endif // }}} //////////////////////////////////////////////////////////////////////// // // \"Careless\" assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // // The outgoing stream isn't quite an AXI stream master interface, // since WB doesn't have backpressure. Therefore, we assume M_READY // is",
            "always high when we need it to be.",
            "always @(*) if (!OPT_FIRSTBEAT_TRIM) case(f_cfg_size) SZ_16B: assume(f_cfg_len + f_cfg_addr[0] >= 2); SZ_32B: assume(f_cfg_len + f_cfg_addr[1:0] >= 4); SZ_BUS: assume(f_cfg_len + f_cfg_addr[WBLSB-1:0] >= BUS_WIDTH/8); endcase",
            "always @(*) if (!i_reset && M_VALID) assume(M_READY);",
            "always @(*) if (!i_reset && o_busy && !o_err) assume(r_transferlen + f_cfg_addr < (1 << ADDRESS_WIDTH)); // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipdma_txgears.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma_txgears.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipdma_txgears.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: ZipDMA -- Unpack bus words into 1, 2, 4, or more bytes per // outgong word. This is to support peripherals which require // 1, 2, or 4 byte transfers (only), as well as peripherals like memory // with no such restrictions. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2022-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipdma_txgears #( // {{{",
            "parameter BUS_WIDTH = 512, parameter [0:0] OPT_LITTLE_ENDIAN = 1'b0, // Abbreviations",
            "localparam DW = BUS_WIDTH // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Configuration // {{{",
            "input wire i_soft_reset, input wire [1:0] i_size, // }}} // Incoming Stream interface // {{{",
            "input wire S_VALID, output wire S_READY, input wire [DW-1:0] S_DATA, // How many bytes are valid?",
            "input wire [$clog2(DW/8):0] S_BYTES, input wire S_LAST, // }}} // Outgoing Stream interface // {{{",
            "output wire M_VALID, input wire M_READY, output wire [DW-1:0] M_DATA, // How many bytes are valid?",
            "output wire [$clog2(DW/8):0] M_BYTES, output wire M_LAST // }}} // }}} ); // Local declarations // {{{",
            "localparam WBLSB = $clog2(DW/8);",
            "localparam [1:0] SZ_BYTE = 2'b11, SZ_16B = 2'b10, SZ_32B = 2'b01, SZ_BUS = 2'b00;",
            "reg m_valid, m_last, r_last, r_next;",
            "reg [DW-1:0] s",
            "reg ;",
            "reg [WBLSB:0] m_bytes, fill; // }}} // s",
            "reg , fill // {{{",
            "initial {s",
            "reg , fill } = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) begin s",
            "reg <= 0; fill <= 0; end else if (S_VALID && S_READY) begin s",
            "reg <= S_DATA; fill <= S_BYTES; end else if (M_VALID && M_READY) begin if (M_LAST) { s",
            "reg , fill } <= 0; else if (OPT_LITTLE_ENDIAN) begin // Verilator coverage_off case(i_size) SZ_BYTE: begin s",
            "reg <= s",
            "reg >> 8; fill <= fill - 1; end SZ_16B: begin s",
            "reg <= s",
            "reg >> 16; fill <= fill - 2; end SZ_32B: begin s",
            "reg <= s",
            "reg >> 32; fill <= fill - 4; end SZ_BUS: begin s",
            "reg <= 0; fill <= 0; end endcase // Verilator coverage_on end else begin case(i_size) SZ_BYTE: begin s",
            "reg <= s",
            "reg << 8; fill <= fill - 1; end SZ_16B: begin s",
            "reg <= s",
            "reg << 16; fill <= fill - 2; end SZ_32B: begin s",
            "reg <= s",
            "reg << 32; fill <= fill - 4; end SZ_BUS: begin s",
            "reg <= 0; fill <= 0; end endcase end end `ifdef FORMAL",
            "always @(*) if (!i_reset) assert(fill <= (DW/8)); `endif // }}} // m_valid // {{{",
            "initial m_valid = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) m_valid <= 0; else if (!M_VALID || M_READY) begin if (S_VALID && S_READY) m_valid <= 1'b1; else case(i_size) SZ_BYTE: m_valid <= (fill > 1); SZ_16B: m_valid <= (fill > 2); SZ_32B: m_valid <= (fill > 4); SZ_BUS: m_valid <= 0; endcase end `ifdef FORMAL",
            "always @(*) if (m_valid) assert(m_bytes <= fill); `endif // }}} // m_bytes // {{{ generate if (BUS_WIDTH > 32) begin : GEN_MBYTES // {{{",
            "initial m_bytes = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) m_bytes <= 0; else if (S_VALID && S_READY) begin case(i_size) SZ_BYTE: m_bytes <= 1; SZ_16B: m_bytes <= (S_BYTES > 2) ? 2 : S_BYTES; SZ_32B: m_bytes <= (S_BYTES > 4) ? 4 : S_BYTES; SZ_BUS: m_bytes <= S_BYTES; endcase end else if (!M_VALID || M_READY) begin case(i_size) SZ_BYTE: m_bytes <= 1; SZ_16B: m_bytes <= (fill >= 4) ? 2 : (&fill[1:0]) ? 1 : 0; SZ_32B: m_bytes <= (fill >= 8) ? 4 : (fill[2]) ? ({ {(WBLSB-1){1'b0}}, fill[1:0] }) : 0; SZ_BUS: m_bytes <= 0; endcase end // }}} end else begin : MIN_MBYTES // {{{",
            "initial m_bytes = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) m_bytes <= 0; else if (S_VALID && S_READY) begin casez(i_size) SZ_BYTE: m_bytes <= 1; SZ_16B: m_bytes <= (S_BYTES > 2) ? 2 : S_BYTES; default: m_bytes <= S_BYTES; endcase end else if (!M_VALID || M_READY) begin casez(i_size) SZ_BYTE: m_bytes <= 1; SZ_16B: m_bytes <= (fill >= 4) ? 2 : (&fill[1:0]) ? 1 : 0; default: m_bytes <= 0; endcase end // }}} end endgenerate `ifdef FORMAL // {{{",
            "always @(*) if (!i_reset && M_VALID) begin assert(m_bytes > 0); assert(m_bytes <= fill); if (M_LAST) assert(m_bytes == fill); case(i_size) SZ_BYTE: assert(m_bytes == 1); SZ_16B: begin assert(m_bytes <= 2); if (m_bytes < 2) assert(M_LAST && m_bytes == fill); end SZ_32B: begin assert(m_bytes <= 4); if (m_bytes < 4) assert(M_LAST && m_bytes == fill); end SZ_BUS: begin assert(m_bytes <= DW/8); if (m_bytes < (DW/8)) assert(M_LAST && m_bytes == fill); end endcase end // }}} `endif // }}} // r_next -- Are we on our last word? // {{{ // Only allow S_READY if r_next is true, so r_next must be true when // we",
            "output the last word of the shift",
            "reg ister. generate if (BUS_WIDTH > 32) begin : GEN_NEXT // {{{",
            "initial r_next = 1;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) r_next <= 1; else if (M_VALID && M_READY && M_LAST) r_next <= 1; else if (S_VALID && S_READY) begin case(i_size) SZ_BYTE:r_next <= (S_BYTES == 1); SZ_16B: r_next <= (S_BYTES <= 2); SZ_32B: r_next <= (S_BYTES <= 4); SZ_BUS: r_next <= 1; endcase if (S_LAST) r_next <= 0; end else if (M_VALID && M_READY) begin case(i_size) SZ_BYTE:r_next <= (fill <= 2); SZ_16B: r_next <= (fill <= 4); SZ_32B: r_next <= (fill <= 8); SZ_BUS: r_next <= 1; endcase if (r_last) r_next <= 0; end // }}} end else begin : MIN_NEXT // {{{",
            "initial r_next = 1;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) r_next <= 1; else if (M_VALID && M_READY && M_LAST) r_next <= 1; else if (S_VALID && S_READY) begin casez(i_size) SZ_BYTE: r_next <= (S_BYTES == 1); SZ_16B: r_next <= (S_BYTES <= 2); default: r_next <= 1; endcase if (S_LAST) r_next <= 0; end else if (M_VALID && M_READY) begin casez(i_size) SZ_BYTE: r_next <= (fill <= 2); SZ_16B: r_next <= (fill <= 4); default: r_next <= 1; endcase if (r_last) r_next <= 0; end // }}} end endgenerate `ifdef FORMAL // {{{",
            "reg [1:0] f_mid_packet; // f_mid_packet // {{{",
            "initial f_mid_packet = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) f_mid_packet <= 0; else if (S_VALID && S_READY) f_mid_packet <= (S_LAST) ? 2'b10 : 2'b01; else if (M_VALID && M_READY && M_LAST) f_mid_packet <= 2'b00;",
            "always @(*) assert(f_mid_packet != 2'b11); // }}}",
            "always @(*) if (!i_reset) begin assert(f_mid_packet[1] == (r_last || m_last)); if (f_mid_packet[1]) begin assert(!r_next); end else case(i_size) SZ_BYTE:assert(r_next == (fill <= 1)); SZ_16B: assert(r_next == (fill <= 2)); SZ_32B: assert(r_next == (fill <= 4)); SZ_BUS: assert(r_next); endcase end // }}} `endif // }}} // r_last, m_last // {{{ generate if (BUS_WIDTH > 32) begin : GEN_LAST // {{{",
            "initial { r_last, m_last } = 2'b00;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) { r_last, m_last } <= 0; else if (S_VALID && S_READY) begin case(i_size) SZ_BYTE: { r_last, m_last } <= { (S_BYTES > 1), (S_BYTES == 1) }; SZ_16B: { r_last, m_last } <= { (S_BYTES > 2), (S_BYTES <= 2) }; SZ_32B: { r_last, m_last } <= { (S_BYTES > 4), (S_BYTES <= 4) }; SZ_BUS: { r_last, m_last } <= { 1'b0, S_LAST }; endcase if (!S_LAST) { r_last, m_last } <= 2'b00; end else if (M_VALID && M_READY) begin case(i_size) SZ_BYTE:m_last <= r_last && (fill <= 2); SZ_16B: m_last <= r_last && (fill <= 4); SZ_32B: m_last <= r_last && (fill <= 8); SZ_BUS: m_last <= 0; endcase case(i_size) SZ_BYTE:r_last <= r_last && (fill > 2); SZ_16B: r_last <= r_last && (fill > 4); SZ_32B: r_last <= r_last && (fill > 8); SZ_BUS: r_last <= 0; endcase // if (M_LAST) // { r_last, m_last } <= 2'b00; end // }}} end else begin : MIN_LAST // {{{",
            "initial { r_last, m_last } = 2'b00;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) { r_last, m_last } <= 0; else if (S_VALID && S_READY) begin casez(i_size) SZ_BYTE: { r_last, m_last } <= { (S_BYTES > 1), (S_BYTES == 1) }; SZ_16B: { r_last, m_last } <= { (S_BYTES > 2), (S_BYTES <= 2) }; default: { r_last, m_last } <= { (S_BYTES > 4), (S_BYTES <= 4) }; endcase if (!S_LAST) { r_last, m_last } <= 2'b00; end else if (!M_VALID || M_READY) begin casez(i_size) SZ_BYTE: m_last <= r_last && (fill <= 2); SZ_16B: m_last <= r_last && (fill <= 4); default: m_last <= 0; endcase casez(i_size) SZ_BYTE: r_last <= r_last && (fill > 2); SZ_16B: r_last <= r_last && (fill > 4); default: r_last <= 0; endcase // if (M_LAST) // { r_last, m_last } <= 2'b00; end // }}} end endgenerate `ifdef FORMAL",
            "always @(posedge i_clk) if (f_past_valid && $past(!i_reset && M_VALID && M_READY && M_LAST)) assert({ r_last, m_last } == 2'b00); `endif // }}}",
            "assign M_VALID = m_valid;",
            "assign M_DATA = s",
            "reg ;",
            "assign M_BYTES = m_bytes;",
            "assign M_LAST = m_last;",
            "assign S_READY = !M_VALID || (M_READY && r_next); //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "localparam F_LGCOUNT = 16;",
            "reg f_past_valid; (* anyconst *)",
            "reg [1:0] f_cfg_size;",
            "reg [F_LGCOUNT-1:0] f_rcvd, f_sent;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1;",
            "always @(*) if (!f_past_valid) assume(i_reset);",
            "always @(*) if (!i_reset) assume(i_size == f_cfg_size); //////////////////////////////////////////////////////////////////////// // // Incoming stream properties // {{{ //////////////////////////////////////////////////////////////////////// // // // Basic stream properties // {{{",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset || i_soft_reset)) assume(!S_VALID); else if ($past(S_VALID && !S_READY)) begin assume(S_VALID); assume($stable(S_DATA)); assume($stable(S_BYTES)); assume($stable(S_LAST)); end // }}} // Properties of S_BYTES: incoming words are packed // {{{",
            "always @(*) if (!i_reset && S_VALID) begin assume(S_BYTES > 0); assume(S_BYTES <= (DW/8)); if (!S_LAST) assume(S_BYTES == (DW/8)); end // }}} // f_rcvd // {{{",
            "initial f_rcvd = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) f_rcvd = 0; else if (S_VALID && S_READY) begin if (S_LAST) f_rcvd <= 0; else f_rcvd <= f_rcvd + S_BYTES; end",
            "always @(*) assume(!f_rcvd[F_LGCOUNT-1]);",
            "always @(*) if (f_mid_packet == 2'b00 || f_mid_packet == 2'b10) begin assert(f_rcvd == 0); end else assert(f_rcvd > 0); // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Outgoing stream properties // {{{ //////////////////////////////////////////////////////////////////////// // // // Basic stream property // {{{",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset || i_soft_reset)) assert(!M_VALID); else if ($past(M_VALID && !M_READY)) begin assert(M_VALID); assert($stable(M_DATA)); assert($stable(M_BYTES)); assert($stable(M_LAST)); end // }}} // Bounding/checking M_LAST // {{{",
            "always @(*) if (!i_reset && M_VALID) begin assert(M_BYTES > 0); assert(M_BYTES <= (DW/8)); if (!M_LAST) case(f_cfg_size) SZ_BYTE: assert(M_BYTES == 1); SZ_16B: assert(M_BYTES == 2); SZ_32B: assert(M_BYTES == 4); SZ_BUS: assert(M_BYTES == (DW/8)); endcase else case(f_cfg_size) SZ_BYTE: assert(M_BYTES == 1); SZ_16B: assert(M_BYTES <= 2); SZ_32B: assert(M_BYTES <= 4); SZ_BUS: assert(M_BYTES <= (DW/8)); endcase end // }}} // Bounding/checking fill // {{{",
            "always @(*) if (!i_reset) begin assert(!r_last || !M_LAST); if (r_last || M_LAST) assert(M_VALID); if (r_last) case(f_cfg_size) SZ_BYTE: assert(fill > 1); SZ_16B: assert(fill > 2); SZ_32B: assert(fill > 4); SZ_BUS: assert(0); endcase if (M_LAST) begin assert(fill > 0); case(f_cfg_size) 2'b11: assert(fill == 1); SZ_16B: assert(fill <= 2); SZ_32B: assert(fill <= 4); SZ_BUS: begin end endcase end end",
            "always @(*) if (!i_reset) begin assert(fill <= (DW/8)); assert(M_VALID == (fill > 0)); if (M_LAST) assert(fill == M_BYTES); if (!M_LAST && !r_last) case(f_cfg_size) SZ_BYTE: begin end // assert(fill > 0); SZ_16B: assert(fill[0] == 1'b0); SZ_32B: assert(fill[1:0] == 2'b00); SZ_BUS: assert(fill[WBLSB-1:0] == 0); endcase end // }}} // f_sent // {{{",
            "initial f_sent = 0;",
            "always @(posedge i_clk) if (i_reset || i_soft_reset) f_sent <= 0; else if (M_VALID && M_READY) begin if (M_LAST) f_sent <= 0; else f_sent <= f_sent + M_BYTES; end",
            "always @(*) begin assume(!f_sent[F_LGCOUNT-1]); if (!r_last && !m_last) begin assert(f_sent + fill == f_rcvd); assert(f_sent <= f_rcvd); end end",
            "always @(*) if (f_mid_packet == 2'b00) begin assert(f_sent == 0); end else if (f_mid_packet == 2'b10) assert(M_VALID || f_sent > 0); // }}} // }}} //////////////////////////////////////////////////////////////////////// // // \"Contract\" properties // {{{ //////////////////////////////////////////////////////////////////////// // // (* anyconst *)",
            "reg fc_check; (* anyconst *)",
            "reg [F_LGCOUNT-1:0] fc_posn; (* anyconst *)",
            "reg [7:0] fc_byte;",
            "wire fs_check, fm_check;",
            "reg [WBLSB-1:0] fs_shift, fm_shift;",
            "reg [DW-1:0] fs_shifted, fm_shifted; // Slave assumption // {{{",
            "assign fs_check = fc_check && S_VALID && f_rcvd <= fc_posn && (fc_posn < f_rcvd + S_BYTES);",
            "always @(*) fs_shift = fc_posn - f_rcvd;",
            "always @(*) if (OPT_LITTLE_ENDIAN) fs_shifted = S_DATA >> (8*fs_shift); else fs_shifted = S_DATA << (8*fs_shift);",
            "always @(*) if (!i_reset && fs_check) begin if (OPT_LITTLE_ENDIAN) assume(fs_shifted[7:0] == fc_byte); else assume(fs_shifted[DW-1:DW-8] == fc_byte); end // }}} // Master assertion // {{{",
            "assign fm_check = fc_check && f_sent <= fc_posn && (fc_posn < f_sent + fill);",
            "always @(*) fm_shift = fc_posn - f_sent;",
            "always @(*) if (OPT_LITTLE_ENDIAN) fm_shifted = s",
            "reg >> (8*fm_shift); else fm_shifted = s",
            "reg << (8*fm_shift);",
            "always @(*) if (!i_reset && fm_check) begin if (OPT_LITTLE_ENDIAN) begin assert(fm_shifted[7:0] == fc_byte); end else begin assert(fm_shifted[DW-1:DW-8] == fc_byte); end end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (!i_reset && M_VALID && M_READY && M_LAST) begin cover(i_size == SZ_BYTE && f_sent > DW/8); cover(i_size == SZ_16B && f_sent > DW/8); cover(i_size == SZ_32B && f_sent > DW/8); cover(i_size == SZ_BUS && f_sent > DW/8); cover(i_size == SZ_BYTE && f_sent > 2*DW/8+1); cover(i_size == SZ_16B && f_sent > 2*DW/8+1); cover(i_size == SZ_32B && f_sent > 2*DW/8+1); cover(i_size == SZ_BUS && f_sent > 2*DW/8+1); cover(i_size == SZ_BUS && f_sent > 2*DW/8+2); cover(i_size == SZ_BUS && f_sent > 2*DW/8+3); cover(i_size == SZ_BUS && f_sent > 2*DW/8+4); end // }}} //////////////////////////////////////////////////////////////////////// // // \"Careless\" assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipdma_ctrl.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma_ctrl.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipdma_ctrl.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: ZipDMA -- Simply handles the control requests for the ZipDMA. // Status reads and control writes using a 32-bit Wishbone bus // interface are handled here. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2022-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipdma_ctrl #( // {{{",
            "parameter ADDRESS_WIDTH=30, LGMEMLEN = 10, parameter SLV_WIDTH=32, // BUS_WIDTH=512, parameter LGDMALENGTH = ADDRESS_WIDTH, parameter ABORT_KEY = 32'h41425254, parameter [0:0] OPT_LOWPOWER = 1'b0, // == { 8'd65, 8'd66, 8'd82, 8'd84 }, \"ABRT\", localparam AW = ADDRESS_WIDTH // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Slave / control port // {{{",
            "input wire i_cyc, i_stb, i_we, input wire [1:0] i_addr, input wire [SLV_WIDTH-1:0] i_data, input wire [SLV_WIDTH/8-1:0] i_sel, // // Verilator coverage_off",
            "output wire o_stall, // Verilator coverage_on",
            "output reg o_ack, output reg [SLV_WIDTH-1:0] o_data, // }}} // DMA control",
            "wire s and feedback // {{{",
            "output reg o_dma_request, output reg o_dma_abort, input wire i_dma_busy, i_dma_err, output reg [AW-1:0] o_src_addr, output reg [AW-1:0] o_dst_addr, output reg [LGDMALENGTH-1:0] o_length, output reg [LGMEMLEN:0] o_transferlen, output reg o_mm2s_inc, o_s2mm_inc, output reg [1:0] o_mm2s_size,o_s2mm_size, // output reg o_trigger, // input wire [AW-1:0] i_current_src, input wire [AW-1:0] i_current_dst, input wire [LGDMALENGTH-1:0] i_remaining_len, // }}}",
            "input wire [31:0] i_dma_int, output reg o_interrupt // }}} ); // Local declarations // {{{",
            "reg int_trigger, r_err, r_zero_len, r_busy;",
            "reg [4:0] int_sel;",
            "reg [SLV_WIDTH-1:0] next_src, next_dst, next_len, next_tlen, w_control_",
            "reg ; // }}} // o_ack // {{{",
            "initial o_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_ack <= 1'b0; else o_ack <= i_stb; // }}}",
            "assign o_stall = 1'b0; // w_control_",
            "reg // {{{",
            "always @(*) begin w_control_",
            "reg = 0; w_control_",
            "reg [31] = i_dma_busy; w_control_",
            "reg [30] = r_err || i_dma_err; w_control_",
            "reg [29] = int_trigger; w_control_",
            "reg [28:24] = int_sel; // w_control_",
            "reg [LGMEMLEN:0] = o_transferlen; // w_control_",
            "reg [22] = !o_s2mm_inc; w_control_",
            "reg [21:20] = o_s2mm_size; // w_control_",
            "reg [18] = !o_mm2s_inc; w_control_",
            "reg [17:16] = o_mm2s_size; end // }}} // o_data // {{{",
            "always @(posedge i_clk) if (!OPT_LOWPOWER || (i_stb && !o_stall && !i_we)) begin o_data <= 0; case(i_addr) 2'b00: o_data <= w_control_",
            "reg ; 2'b01: o_data[AW-1:0] <= (i_dma_busy) ? i_current_src : o_src_addr; 2'b10: o_data[AW-1:0] <= (i_dma_busy) ? i_current_dst : o_dst_addr; 2'b11: o_data[LGDMALENGTH-1:0] <= (i_dma_busy) ? i_remaining_len : o_length; endcase end // }}} // o_trigger // {{{",
            "always @(posedge i_clk) if (i_reset || o_dma_abort || i_dma_err || !i_dma_busy) o_trigger <= 1'b0; else if (!int_trigger) o_trigger <= 1'b1; else o_trigger <= i_dma_int[int_sel]; // }}} // next_src // {{{",
            "always @(*) begin next_src = 32'h00; next_src[AW-1:0] = o_src_addr; if (i_sel[0]) next_src[ 7: 0] = i_data[ 7: 0]; if (i_sel[1]) next_src[15: 8] = i_data[15: 8]; if (i_sel[2]) next_src[23:16] = i_data[23:16]; if (i_sel[3]) next_src[31:24] = i_data[31:24]; end // }}} // next_dst // {{{",
            "always @(*) begin next_dst = 32'h00; next_dst[AW-1:0] = o_dst_addr; if (i_sel[0]) next_dst[ 7: 0] = i_data[ 7: 0]; if (i_sel[1]) next_dst[15: 8] = i_data[15: 8]; if (i_sel[2]) next_dst[23:16] = i_data[23:16]; if (i_sel[3]) next_dst[31:24] = i_data[31:24]; end // }}} // next_len // {{{",
            "always @(*) begin next_len = 32'h00; next_len[LGDMALENGTH-1:0] = o_length; if (i_sel[0]) next_len[ 7: 0] = i_data[ 7: 0]; if (i_sel[1]) next_len[15: 8] = i_data[15: 8]; if (i_sel[2]) next_len[23:16] = i_data[23:16]; if (i_sel[3]) next_len[31:24] = i_data[31:24]; end // }}} // next_tlen // {{{",
            "always @(*) begin next_tlen = 32'h00; next_tlen[LGMEMLEN-1:0] = o_transferlen[LGMEMLEN-1:0]; if (i_sel[0]) next_tlen[ 7: 0] = i_data[ 7: 0]; if (i_sel[1]) next_tlen[15: 8] = i_data[15: 8]; if (i_sel[2]) next_tlen[23:16] = i_data[23:16]; if (i_sel[3]) next_tlen[31:24] = i_data[31:24]; next_tlen[SLV_WIDTH-1:LGMEMLEN] = 0; next_tlen[LGMEMLEN] = (next_tlen[LGMEMLEN-1:0] == 0); end // }}} // Process i_data writes // {{{",
            "always @(posedge i_clk) if (i_reset) begin // {{{ o_src_addr <= {(AW){1'b0}}; o_dst_addr <= {(AW){1'b0}}; o_length <= {(LGDMALENGTH){1'b0}}; r_zero_len <= 1'b1; o_transferlen <= { 1'b1, {(LGMEMLEN){1'b0}} }; o_s2mm_inc <= 1'b0; o_s2mm_size <= 2'b0; o_mm2s_inc <= 1'b0; o_mm2s_size <= 2'b0; int_trigger <= 1'b0; int_sel <= 5'h0; // }}} end else if (i_stb && !o_stall && i_we && !o_dma_request && !i_dma_busy) begin // Register write, DMA is idle // {{{ case(i_addr) 2'b00: begin // Control",
            "reg isters // {{{ o_transferlen[LGMEMLEN:0] <= next_tlen[LGMEMLEN:0]; if (i_sel[2]) begin o_s2mm_inc <= !i_data[22]; o_s2mm_size <= i_data[21:20]; // o_mm2s_inc <= !i_data[18]; o_mm2s_size <= i_data[17:16]; end if (i_sel[3]) begin int_trigger <= i_data[29]; int_sel <= i_data[28:24]; end end // }}} 2'b01: o_src_addr <= next_src[AW-1:0]; 2'b10: o_dst_addr <= next_dst[AW-1:0]; 2'b11: begin // o_length // {{{ o_length <= next_len[LGDMALENGTH-1:0]; r_zero_len <= (next_len[LGDMALENGTH-1:0] == 0); end // }}} endcase // }}} end else if (i_dma_busy) begin o_src_addr <= i_current_src; o_dst_addr <= i_current_dst; end // }}} // o_dma_request, o_dma_abort, o_interrupt, r_err // {{{",
            "always @(posedge i_clk) if (i_reset) begin // {{{ o_dma_request <= 1'b0; o_dma_abort <= 1'b0; r_err <= 1'b0; o_interrupt <= 1'b0; // }}} end else begin r_busy <= i_dma_busy; if (!i_dma_busy) begin o_dma_request <= 1'b0; o_dma_abort <= 1'b0; end if (i_dma_err) r_err <= 1'b1; if (r_busy && (!i_dma_busy || i_dma_err)) o_interrupt <= 1'b1; if (i_stb && !o_stall && i_we && i_addr == 2'b00) begin // {{{ if (o_dma_request || i_dma_busy) begin // Deal with abort requests if ((&i_sel) && i_data == ABORT_KEY) { o_dma_request, o_dma_abort } <= 2'b01; end else if (i_sel[3]) begin // Clear interrupts, errors, and potentially // restart the DMA if (i_data[29] || !i_data[30]) o_interrupt <= 1'b0; if (i_data[30]) r_err <= 1'b0; if (!i_data[31] && (!r_err || i_data[30])) o_dma_request <= !r_zero_len; end // }}} end end // }}} // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_cyc, next_tlen[SLV_WIDTH-1:LGMEMLEN] }; generate if (SLV_WIDTH > AW) begin : UNUSED_WIDE_ADDR",
            "wire unused_addr;",
            "assign unused_addr = &{ 1'b0, next_src[SLV_WIDTH-1:AW], next_dst[SLV_WIDTH-1:AW] }; end if (SLV_WIDTH > LGDMALENGTH) begin : UNUSED_LEN",
            "wire unused_len;",
            "assign unused_len = &{ 1'b0, next_len[SLV_WIDTH-1:LGDMALENGTH] }; end endgenerate // Verilator lint_on UNUSED // Verilator coverage_on // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipdma_fsm.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma_fsm.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipdma_fsm.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: ZipDMA's control FSM // // Since the Wishbone bus can only accommodate either a read or a write // transaction, large DMA transfers need to be broken up between reads // and writes. This function accomplishes that purpose--issuing read // requests of the zipdma_mm2s controller, followed by write requests // of the zipdma_s2mm controller. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2022-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipdma_fsm #( // {{{",
            "parameter ADDRESS_WIDTH = 32, // Byte ADDR width",
            "parameter LGDMALENGTH = ADDRESS_WIDTH, parameter LGSUBLENGTH = 10 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, input wire i_soft_reset, // DMA control // {{{",
            "input wire i_dma_request, output reg o_dma_busy, output reg o_dma_err, input wire [ADDRESS_WIDTH-1:0] i_src_addr, input wire [ADDRESS_WIDTH-1:0] i_dst_addr, input wire [LGDMALENGTH-1:0] i_length, input wire [LGSUBLENGTH:0] i_transferlen, output wire [LGDMALENGTH-1:0] o_remaining_len, // }}}",
            "input wire i_trigger, // MM2S control // {{{",
            "output reg o_mm2s_request, input wire i_mm2s_busy, input wire i_mm2s_err, input wire i_mm2s_inc, // input wire [1:0] i_mm2s_size, output reg [ADDRESS_WIDTH-1:0] o_mm2s_addr, output wire [LGSUBLENGTH:0] o_mm2s_transferlen, // }}} // S2MM control // {{{",
            "output reg o_s2mm_request, input wire i_s2mm_busy, input wire i_s2mm_err, input wire i_s2mm_inc, // input wire [1:0] i_s2mm_size, output reg [ADDRESS_WIDTH-1:0] o_s2mm_addr, output wire [LGSUBLENGTH:0] o_s2mm_transferlen // }}} // }}} ); // Local declarations // {{{",
            "localparam [1:0] S_IDLE = 2'b00, S_WAIT = 2'b01, S_READ = 2'b10, S_WRITE = 2'b11;",
            "reg [LGDMALENGTH-1:0] r_length;",
            "reg [LGSUBLENGTH:0] r_transferlen;",
            "reg [1:0] fsm_state; // }}}",
            "always @(posedge i_clk) if (i_reset || i_soft_reset || i_mm2s_err || i_s2mm_err) begin // {{{ o_dma_busy <= 0; r_length <= 0; r_transferlen <= 0; o_mm2s_request <= 0; o_s2mm_request <= 0; o_mm2s_addr <= 0; o_s2mm_addr <= 0; fsm_state <= S_IDLE; // }}} end else if (!o_dma_busy) begin // {{{ o_dma_busy <= 1'b0; r_length <= 0; // Verilator lint_off WIDTH r_transferlen <= (i_length < i_transferlen) ? i_length : i_transferlen; // Verilator lint_on WIDTH fsm_state <= S_IDLE; o_mm2s_request <= 0; o_s2mm_request <= 0; if (i_dma_request) begin o_dma_busy <= 1'b1; fsm_state <= (i_trigger) ? S_READ : S_WAIT; o_mm2s_request <= i_trigger; o_mm2s_addr <= i_src_addr; o_s2mm_addr <= i_dst_addr; r_length <= i_length; end `ifdef FORMAL assert(fsm_state == S_IDLE); `endif // }}} end else case(fsm_state) S_WAIT: begin // {{{ if (r_length == 0) o_dma_busy <= 0; else if (i_trigger) begin fsm_state <= S_READ; o_mm2s_request <= 1'b1; end end // }}} S_READ: begin // {{{ if (o_mm2s_request && !i_mm2s_busy) // VALID && READY o_mm2s_request <= 1'b0; if (!i_mm2s_busy && !o_mm2s_request) begin fsm_state <= S_WRITE; o_s2mm_request <= 1'b1; if (i_mm2s_inc) // Verilator lint_off WIDTH o_mm2s_addr <= o_mm2s_addr + r_transferlen; // Verilator lint_on WIDTH // Verilator lint_off WIDTH r_length <= (r_length > r_transferlen) ? r_length - r_transferlen : 0; // Verilator lint_on WIDTH end end // }}} S_WRITE: begin // {{{ if (o_s2mm_request && !i_s2mm_busy) // VALID && READY o_s2mm_request <= 1'b0; if (!i_s2mm_busy && !o_s2mm_request) begin fsm_state <= (i_trigger) ? S_READ : S_WAIT; o_mm2s_request <= (i_trigger); // Verilator lint_off WIDTH if (r_transferlen > r_length) // Verilator lint_on WIDTH r_transferlen <= r_length[LGSUBLENGTH:0]; if (i_s2mm_inc) // Verilator lint_off WIDTH o_s2mm_addr <= o_s2mm_addr + r_transferlen; // Verilator lint_on WIDTH if (r_length == 0) begin fsm_state <= S_IDLE; o_mm2s_request <= 1'b0; o_dma_busy <= 1'b0; end end end // }}} // Verilator coverage_off default: begin end // Verilator coverage_on endcase",
            "assign o_s2mm_transferlen = r_transferlen;",
            "assign o_mm2s_transferlen = r_transferlen;",
            "assign o_remaining_len = r_length; // o_dma_err // {{{",
            "always @(posedge i_clk) if (i_reset || i_soft_reset || !o_dma_busy) o_dma_err <= 1'b0; else o_dma_err <= (i_mm2s_busy && i_mm2s_err) || (i_s2mm_busy && i_s2mm_err); // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipdma.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipdma.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: (Upgraded) Wishbone DMA controller for the ZipCPU // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2022-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipdma #( // {{{",
            "parameter ADDRESS_WIDTH=30, LGMEMLEN = 10, parameter LGDMALENGTH=ADDRESS_WIDTH, parameter SLV_WIDTH=32, parameter BUS_WIDTH=512, parameter [0:0] OPT_LITTLE_ENDIAN = 1'b0, parameter [0:0] OPT_LOWPOWER = 1'b0, parameter [0:0] OPT_REGISTER_RAM = 1'b0, localparam AW=ADDRESS_WIDTH-$clog2(BUS_WIDTH/8) // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Slave port // {{{ // Slave/control wishbone",
            "input s",
            "input wire i_swb_cyc, i_swb_stb, i_swb_we, input wire [1:0] i_swb_addr, input wire [SLV_WIDTH-1:0] i_swb_data, input wire [SLV_WIDTH/8-1:0] i_swb_sel, // Slave/control wishbone",
            "output s // Verilator coverage_off",
            "output wire o_swb_stall, // Verilator coverage_on",
            "output wire o_swb_ack, output wire [SLV_WIDTH-1:0] o_swb_data, // }}} // Master/DMA port // {{{",
            "output wire o_mwb_cyc, o_mwb_stb, o_mwb_we, output wire [AW-1:0] o_mwb_addr, output wire [BUS_WIDTH-1:0] o_mwb_data, output wire [BUS_WIDTH/8-1:0] o_mwb_sel, // Master/DMA wishbone responses from the bus",
            "input wire i_mwb_stall, i_mwb_ack, input wire [BUS_WIDTH-1:0] i_mwb_data, input wire i_mwb_err, // }}} // The interrupt device interrupt lines",
            "input wire [31:0] i_dev_ints, // An interrupt to be set upon completion",
            "output wire o_interrupt // }}} ); // Local declarations // {{{",
            "localparam FIFO_WIDTH = BUS_WIDTH+$clog2(BUS_WIDTH/8)+2;",
            "localparam LGFIFO = LGMEMLEN-$clog2(BUS_WIDTH/8);",
            "wire dma_request, dma_abort, dma_busy, dma_err;",
            "wire [ADDRESS_WIDTH-1:0] dma_src, dma_dst, read_addr, write_addr;",
            "wire [LGDMALENGTH-1:0] dma_length, remaining_len;",
            "wire [LGMEMLEN:0] dma_transferlen;",
            "wire dma_trigger;",
            "wire mm2s_request, s2mm_request;",
            "wire mm2s_busy, s2mm_busy;",
            "wire mm2s_err, s2mm_err;",
            "wire mm2s_inc, s2mm_inc;",
            "wire [1:0] mm2s_size, s2mm_size;",
            "wire [ADDRESS_WIDTH-1:0] mm2s_addr, s2mm_addr;",
            "wire [LGMEMLEN:0] mm2s_transferlen, s2mm_transferlen;",
            "wire mm2s_rd_cyc, mm2s_rd_stb, mm2s_rd_we, mm2s_rd_stall, mm2s_rd_ack, mm2s_rd_err;",
            "wire [AW-1:0] mm2s_rd_addr;",
            "wire [BUS_WIDTH-1:0] mm2s_rd_data;",
            "wire [BUS_WIDTH/8-1:0] mm2s_rd_sel;",
            "wire mm2s_valid, mm2s_ready, mm2s_last;",
            "wire [BUS_WIDTH-1:0] mm2s_data;",
            "wire [$clog2(BUS_WIDTH/8):0] mm2s_bytes;",
            "wire rx_valid, rx_ready, rx_last;",
            "wire [BUS_WIDTH-1:0] rx_data;",
            "wire [$clog2(BUS_WIDTH/8):0] rx_bytes;",
            "wire tx_valid, tx_ready, tx_last;",
            "wire [BUS_WIDTH-1:0] tx_data;",
            "wire [$clog2(BUS_WIDTH/8):0] tx_bytes;",
            "wire sfifo_full, sfifo_empty;",
            "wire [LGFIFO:0] ign_sfifo_fill;",
            "wire s2mm_valid, s2mm_ready, s2mm_last;",
            "wire [BUS_WIDTH-1:0] s2mm_data;",
            "wire [$clog2(BUS_WIDTH/8):0] s2mm_bytes;",
            "wire s2mm_wr_cyc, s2mm_wr_stb, s2mm_wr_we, s2mm_wr_stall, s2mm_wr_ack, s2mm_wr_err;",
            "wire [AW-1:0] s2mm_wr_addr;",
            "wire [BUS_WIDTH-1:0] s2mm_wr_data;",
            "wire [BUS_WIDTH/8-1:0] s2mm_wr_sel;",
            "wire wb_cyc, wb_stb, wb_we, wb_stall, wb_ack, wb_err;",
            "wire [AW-1:0] wb_addr;",
            "wire [BUS_WIDTH-1:0] wb_data, wb_idata;",
            "wire [BUS_WIDTH/8-1:0] wb_sel; // }}} zipdma_ctrl #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH), .LGMEMLEN(LGMEMLEN), .LGDMALENGTH(ADDRESS_WIDTH), .OPT_LOWPOWER(OPT_LOWPOWER) // }}} ) u_controller ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // Slave WB control port // {{{ // Slave/control wishbone",
            "input s .i_cyc(i_swb_cyc), .i_stb(i_swb_stb), .i_we(i_swb_we), .i_addr(i_swb_addr), .i_data(i_swb_data), .i_sel(i_swb_sel), // Slave/control wishbone",
            "output s .o_stall(o_swb_stall), .o_ack(o_swb_ack), .o_data(o_swb_data), // }}} // Internal DMA controls // {{{ .o_dma_request(dma_request), .o_dma_abort(dma_abort), .i_dma_busy(dma_busy), .i_dma_err(dma_err), .o_src_addr(dma_src), .o_dst_addr(dma_dst), .o_length(dma_length), .o_transferlen(dma_transferlen), .o_mm2s_inc(mm2s_inc), .o_mm2s_size(mm2s_size), .o_s2mm_inc(s2mm_inc), .o_s2mm_size(s2mm_size), // .o_trigger(dma_trigger), // .i_current_src(read_addr), .i_current_dst(write_addr), .i_remaining_len(remaining_len), // }}} .i_dma_int(i_dev_ints), .o_interrupt(o_interrupt) // }}} ); zipdma_fsm #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH), .LGDMALENGTH(ADDRESS_WIDTH), .LGSUBLENGTH(LGMEMLEN) // }}} ) u_dma_fsm ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_soft_reset(dma_abort), // DMA control // {{{ .i_dma_request(dma_request), .o_dma_busy(dma_busy), .o_dma_err(dma_err), .i_src_addr(dma_src), .i_dst_addr(dma_dst), .i_length(dma_length), .i_transferlen(dma_transferlen), .i_trigger(dma_trigger), .o_remaining_len(remaining_len), // }}} // Downstream MM2S configuration // {{{ .o_mm2s_request(mm2s_request), .i_mm2s_busy(mm2s_busy), .i_mm2s_err(mm2s_err), .i_mm2s_inc(mm2s_inc), .o_mm2s_addr(mm2s_addr), .o_mm2s_transferlen(mm2s_transferlen), // }}} // Downstream S2MM configuration // {{{ .o_s2mm_request(s2mm_request), .i_s2mm_busy(s2mm_busy), .i_s2mm_err(s2mm_err), .i_s2mm_inc(s2mm_inc), .o_s2mm_addr(s2mm_addr), .o_s2mm_transferlen(s2mm_transferlen) // }}} // }}} ); zipdma_mm2s #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH), .BUS_WIDTH(BUS_WIDTH), .LGLENGTH(LGMEMLEN), .OPT_LITTLE_ENDIAN(OPT_LITTLE_ENDIAN), .OPT_LOWPOWER(OPT_LOWPOWER) // }}} ) u_mm2s ( // {{{ .i_clk(i_clk), .i_reset(i_reset || dma_abort), // DMA control // {{{ .i_request(mm2s_request), .o_busy(mm2s_busy), .o_err(mm2s_err), .i_inc(mm2s_inc), .i_size(mm2s_size), .i_transferlen(mm2s_transferlen), .i_addr(mm2s_addr), // }}} // Wishbone master interface // {{{ .o_rd_cyc(mm2s_rd_cyc), .o_rd_stb(mm2s_rd_stb), .o_rd_we(mm2s_rd_we), .o_rd_addr(mm2s_rd_addr), .o_rd_data(mm2s_rd_data), .o_rd_sel(mm2s_rd_sel), // .i_rd_stall(mm2s_rd_stall), .i_rd_ack(mm2s_rd_ack), .i_rd_data(wb_idata), .i_rd_err(mm2s_rd_err), // }}} // MM2S Stream interface // {{{ .M_VALID(mm2s_valid), .M_READY(mm2s_ready), .M_DATA(mm2s_data), .M_BYTES(mm2s_bytes), .M_LAST(mm2s_last) // }}} // }}} ); zipdma_rxgears #( // {{{ .BUS_WIDTH(BUS_WIDTH), .OPT_LITTLE_ENDIAN(OPT_LITTLE_ENDIAN) // }}} ) u_rxgears ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_soft_reset(dma_abort), // .S_VALID(mm2s_valid), .S_READY(mm2s_ready), .S_DATA(mm2s_data), .S_BYTES(mm2s_bytes), .S_LAST(mm2s_last), // .M_VALID(rx_valid), .M_READY(rx_ready), .M_DATA(rx_data), .M_BYTES(rx_bytes), .M_LAST(rx_last) // }}} ); sfifo #( // {{{ .BW(FIFO_WIDTH), .LGFLEN(LGFIFO), .OPT_ASYNC_READ(!OPT_REGISTER_RAM), .OPT_WRITE_ON_FULL(1'b0), .OPT_READ_ON_EMPTY(1'b0) // }}} ) u_sfifo ( // {{{ .i_clk(i_clk), .i_reset(i_reset || dma_abort), // .i_wr(rx_valid), .i_data({ rx_last, rx_bytes, rx_data }), .o_full(sfifo_full), .o_fill(ign_sfifo_fill), // .i_rd(tx_ready), .o_data({ tx_last, tx_bytes, tx_data }), .o_empty(sfifo_empty) // }}} );",
            "assign rx_ready = !sfifo_full;",
            "assign tx_valid = !sfifo_empty; zipdma_txgears #( // {{{ .BUS_WIDTH(BUS_WIDTH), .OPT_LITTLE_ENDIAN(OPT_LITTLE_ENDIAN) // }}} ) u_txgears ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_soft_reset(dma_abort), .i_size(s2mm_size), // Incoming stream // {{{ .S_VALID(tx_valid), .S_READY(tx_ready), .S_DATA(tx_data), .S_BYTES(tx_bytes), .S_LAST(tx_last), // }}} // Outgoing stream to S2MM // {{{ .M_VALID(s2mm_valid), .M_READY(s2mm_ready), .M_DATA(s2mm_data), .M_BYTES(s2mm_bytes), .M_LAST(s2mm_last) // }}} // }}} ); zipdma_s2mm #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH), .BUS_WIDTH(BUS_WIDTH), .OPT_LITTLE_ENDIAN(OPT_LITTLE_ENDIAN), .LGPIPE(LGMEMLEN) // }}} ) u_s2mm ( // {{{ .i_clk(i_clk), .i_reset(i_reset || dma_abort), // S2MM configuration // {{{ .i_request(s2mm_request), .o_busy(s2mm_busy), .o_err(s2mm_err), .i_inc(s2mm_inc), .i_size(s2mm_size), .i_addr(s2mm_addr), // }}} // Stream data source // {{{ .S_VALID(s2mm_valid), .S_READY(s2mm_ready), .S_DATA(s2mm_data), .S_BYTES(s2mm_bytes), .S_LAST(s2mm_last), // }}} // Outgoing Wishbone interface // {{{ .o_wr_cyc(s2mm_wr_cyc), .o_wr_stb(s2mm_wr_stb), .o_wr_we(s2mm_wr_we), .o_wr_addr(s2mm_wr_addr), .o_wr_data(s2mm_wr_data), .o_wr_sel(s2mm_wr_sel), // .i_wr_stall(s2mm_wr_stall), .i_wr_ack(s2mm_wr_ack), .i_wr_data({(BUS_WIDTH){1'b0}}), .i_wr_err(s2mm_wr_err) // }}} // }}} ); wbarbiter #( // {{{ .DW(BUS_WIDTH), .AW(AW), .OPT_ZERO_ON_IDLE(OPT_LOWPOWER) // }}} ) u_arbiter ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // .i_a_cyc(mm2s_rd_cyc), .i_a_stb(mm2s_rd_stb), .i_a_we(mm2s_rd_we), .i_a_adr(mm2s_rd_addr), .i_a_dat((OPT_LOWPOWER) ? mm2s_rd_data : s2mm_wr_data), .i_a_sel(mm2s_rd_sel), .o_a_stall(mm2s_rd_stall), .o_a_ack(mm2s_rd_ack), .o_a_err(mm2s_rd_err), // .i_b_cyc(s2mm_wr_cyc), .i_b_stb(s2mm_wr_stb), .i_b_we(s2mm_wr_we), .i_b_adr(s2mm_wr_addr), .i_b_dat(s2mm_wr_data), .i_b_sel(s2mm_wr_sel), .o_b_stall(s2mm_wr_stall), .o_b_ack(s2mm_wr_ack), .o_b_err(s2mm_wr_err), // .o_cyc(wb_cyc), .o_stb(wb_stb), .o_we(wb_we), .o_adr(wb_addr), .o_dat(wb_data), .o_sel(wb_sel), .i_stall(wb_stall), .i_ack(wb_ack), .i_err(wb_err) // }}} );",
            "assign o_mwb_cyc = wb_cyc;",
            "assign o_mwb_stb = wb_stb;",
            "assign o_mwb_we = wb_we;",
            "assign o_mwb_addr = wb_addr;",
            "assign o_mwb_data = wb_data;",
            "assign o_mwb_sel = wb_sel;",
            "assign wb_stall = i_mwb_stall;",
            "assign wb_ack = i_mwb_ack;",
            "assign wb_idata = i_mwb_data;",
            "assign wb_err = i_mwb_err;",
            "assign read_addr = { mm2s_rd_addr, {($clog2(BUS_WIDTH/8)){1'b0}} };",
            "assign write_addr = { s2mm_wr_addr, {($clog2(BUS_WIDTH/8)){1'b0}} }; // Make verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, ign_sfifo_fill, mm2s_rd_data, rx_ready, s2mm_transferlen }; // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "always @(*) if (!f_past_valid) assume(i_reset); `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "cpuops.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/cpuops.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: cpuops.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This is the ZipCPU ALU function. It handles all of the // instruction opcodes 0-13. (14-15 are divide opcodes). // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module cpuops #( // {{{",
            "parameter OPT_MPY = 3, // == 0 (no mpy),1-4,36",
            "parameter [0:0] OPT_SHIFTS = 1'b1, parameter [0:0] OPT_LOWPOWER = 1'b1 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, i_stb, input wire [3:0] i_op, input wire [31:0] i_a, i_b, output reg [31:0] o_c, output wire [3:0] o_f, output reg o_valid, `ifdef VMPY_TB // {{{ // Define some",
            "wire s used to peek at internal values during // simulation. These are *ONLY* used by the ZipCPU mpy_tb // simulation testbench. They are *NOT* used during synthesis, // and not intended to be used outside of the ZipCPU setup. // output wire [5:0] OPT_MULTIPLY, output wire [31:0] mpy_a_",
            "input , mpy_b_",
            "input , output wire [63:0] mpy_",
            "output , output wire [2:0] mpy_pipe, // }}} `endif",
            "output wire o_busy // }}} ); // Declarations // {{{",
            "wire [31:0] w_brev_result;",
            "wire z, n, v, vx;",
            "reg c, pre_sign, set_ovfl, keep_sgn_on_ovfl;",
            "wire [32:0] w_lsr_result, w_asr_result, w_lsl_result;",
            "wire [63:0] mpy_result; // Where we dump the multiply result",
            "wire mpyhi; // Return the high half of the multiply",
            "wire mpybusy; // The multiply is busy if true",
            "wire mpydone; // True if we'll be valid on the next clock;",
            "wire this_is_a_multiply_op;",
            "reg r_busy; genvar k; // }}} // Shift",
            "reg ister pre-",
            "logic // {{{ generate if (OPT_SHIFTS) begin : IMPLEMENT_SHIFTS",
            "wire signed [32:0] w_pre_asr_",
            "input , w_pre_asr_shifted;",
            "assign w_pre_asr_",
            "input = { i_a, 1'b0 };",
            "assign w_pre_asr_shifted = w_pre_asr_",
            "input >>> i_b[4:0];",
            "assign w_asr_result = (|i_b[31:5])? {(33){i_a[31]}} : w_pre_asr_shifted;// ASR",
            "assign w_lsr_result = ((|i_b[31:6])||(i_b[5]&&(i_b[4:0]!=0)))? 33'h00 :((i_b[5])?{32'h0,i_a[31]} : ( { i_a, 1'b0 } >> (i_b[4:0]) ));// LSR",
            "assign w_lsl_result = ((|i_b[31:6])||(i_b[5]&&(i_b[4:0]!=0)))? 33'h00 :((i_b[5])?{i_a[0], 32'h0} : ({1'b0, i_a } << i_b[4:0])); // LSL end else begin : NO_SHIFTS",
            "assign w_asr_result = { i_a[31], i_a[31:0] };",
            "assign w_lsr_result = { 1'b0, i_a[31:0] };",
            "assign w_lsl_result = { i_a[31:0], 1'b0 }; end endgenerate // }}} // // Bit reversal pre-",
            "logic // {{{ generate for(k=0; k<32; k=k+1) begin : bit_reversal_cpuop",
            "assign w_brev_result[k] = i_b[31-k]; end endgenerate // }}} // Pre",
            "logic for our flags",
            "reg isters : set_ovfl and keep_sgn_on_ovfl // {{{",
            "always @(posedge i_clk) if (i_stb) // 1 LUT set_ovfl<=(((i_op==4'h0)&&(i_a[31] != i_b[31]))//SUB&CMP ||((i_op==4'h2)&&(i_a[31] == i_b[31])) // ADD ||(i_op == 4'h6) // LSL ||(i_op == 4'h5)); // LSR",
            "always @(posedge i_clk) if (i_stb) // 1 LUT keep_sgn_on_ovfl<= (((i_op==4'h0)&&(i_a[31] != i_b[31]))//SUB&CMP ||((i_op==4'h2)&&(i_a[31] == i_b[31]))); // ADD // }}} //////////////////////////////////////////////////////////////////////// // // Multiply handling // {{{ //////////////////////////////////////////////////////////////////////// // // // A 4-way multiplexer can be done in one 6-LUT. // A 16-way multiplexer can therefore be done in 4x 6-LUT's with // the Xilinx multiplexer fabric that follows. // Given that we wish to apply this multiplexer approach to 33-bits, // this will cost a minimum of 132 6-LUTs.",
            "assign this_is_a_multiply_op = (i_stb)&&((i_op[3:1]==3'h5)||(i_op[3:0]==4'hc)); `ifdef FORMAL `define MPYOP abs_mpy `else `define MPYOP mpyop `endif `MPYOP #( // {{{ .OPT_MPY(OPT_MPY), .OPT_LOWPOWER(OPT_LOWPOWER) // }}} ) thempy( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_stb(this_is_a_multiply_op), .i_op(i_op[1:0]), .i_a(i_a), .i_b(i_b), .o_valid(mpydone), .o_busy(mpybusy), .o_result(mpy_result), .o_hi(mpyhi) // }}} ); // }}} //////////////////////////////////////////////////////////////////////// // // The master ALU case statement // {{{",
            "always @(posedge i_clk) if (i_stb) begin pre_sign <= (i_a[31]); c <= 1'b0; casez(i_op) 4'b0000:{c,o_c } <= {1'b0,i_a}-{1'b0,i_b};// CMP/SUB 4'b0001: o_c <= i_a & i_b; // BTST/And 4'b0010:{c,o_c } <= i_a + i_b; // Add 4'b0011: o_c <= i_a | i_b; // Or 4'b0100: o_c <= i_a ^ i_b; // Xor 4'b0101:{o_c,c } <= w_lsr_result[32:0]; // LSR 4'b0110:{c,o_c } <= w_lsl_result[32:0]; // LSL 4'b0111:{o_c,c } <= w_asr_result[32:0]; // ASR 4'b1000: o_c <= w_brev_result; // BREV 4'b1001: o_c <= { i_a[31:16], i_b[15:0] }; // LODILO 4'b1010: o_c <= mpy_result[63:32]; // MPYHU 4'b1011: o_c <= mpy_result[63:32]; // MPYHS 4'b1100: o_c <= mpy_result[31:0]; // MPY default: o_c <= i_b; // MOV, LDI endcase end else if (!OPT_LOWPOWER || mpydone) // set the",
            "output based upon the multiply result o_c <= (mpyhi)?mpy_result[63:32]:mpy_result[31:0]; // }}} // o_busy, r_busy // {{{",
            "initial r_busy = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_busy <= 1'b0; else if (OPT_MPY > 1) r_busy <= ((i_stb)&&(this_is_a_multiply_op))||mpybusy; else r_busy <= 1'b0;",
            "assign o_busy = (r_busy); // ||((OPT_MPY>1)&&(this_is_a_multiply_op)); // }}} // Flags",
            "assign ment and determination // {{{",
            "assign z = (o_c == 32'h0000);",
            "assign n = (o_c[31]);",
            "assign v = (set_ovfl)&&(pre_sign != o_c[31]);",
            "assign vx = (keep_sgn_on_ovfl)&&(pre_sign != o_c[31]);",
            "assign o_f = { v, n^vx, c, z }; // }}} // o_valid // {{{",
            "initial o_valid = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_valid <= 1'b0; else if (OPT_MPY <= 1) o_valid <= (i_stb); else o_valid <=((i_stb)&&(!this_is_a_multiply_op))||(mpydone); // }}} `ifdef VMPY_TB // {{{",
            "assign OPT_MULTIPLY = OPT_MPY; generate if (OPT_MPY == 0) begin : VGEN0",
            "assign mpy_a_",
            "input = 0;",
            "assign mpy_b_",
            "input = 0;",
            "assign mpy_pipe = 1'b0; end else if (OPT_MPY == 1) begin : VGEN1",
            "assign mpy_a_",
            "input = thempy.IMPY.MPY1CK.w_mpy_a_",
            "input [31:0];",
            "assign mpy_b_",
            "input = thempy.IMPY.MPY1CK.w_mpy_b_",
            "input [31:0];",
            "assign mpy_pipe = 3'b0; end else if (OPT_MPY == 2) begin : VGEN2",
            "assign mpy_a_",
            "input = thempy.IMPY.MPN1.MPY2CK.r_mpy_a_",
            "input [31:0];",
            "assign mpy_b_",
            "input = thempy.IMPY.MPN1.MPY2CK.r_mpy_b_",
            "input [31:0];",
            "assign mpy_pipe = { 2'b0, thempy.IMPY.MPN1.MPY2CK.mpypipe }; end else if (OPT_MPY == 3) begin : VGEN_NORMAL",
            "assign mpy_a_",
            "input = thempy.IMPY.MPN1.MPN2.MPY3CK.r_mpy_a_",
            "input ;",
            "assign mpy_b_",
            "input = thempy.IMPY.MPN1.MPN2.MPY3CK.r_mpy_b_",
            "input ;",
            "assign mpy_pipe = { 1'b0, thempy.IMPY.MPN1.MPN2.MPY3CK.mpypipe }; end else if (OPT_MPY == 4) begin : VGEN_PARTIAL",
            "assign mpy_a_",
            "input = thempy.IMPY.MPN1.MPN2.MPN3.MPY4CK.r_mpy_a_",
            "input ;",
            "assign mpy_b_",
            "input = thempy.IMPY.MPN1.MPN2.MPN3.MPY4CK.r_mpy_b_",
            "input ;",
            "assign mpy_pipe = thempy.IMPY.MPN1.MPN2.MPN3.MPY4CK.mpypipe; end else begin : VGEN_SLOW",
            "assign mpy_a_",
            "input = thempy.IMPY.MPN1.MPN2.MPN3.MPYSLOW.slowmpyi.i_a[31:0];",
            "assign mpy_b_",
            "input = thempy.IMPY.MPN1.MPN2.MPN3.MPYSLOW.slowmpyi.i_b[31:0];",
            "assign mpy_pipe = {(3){mpybusy}}; end endgenerate",
            "assign mpy_",
            "output = mpy_result; // }}} `endif //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Declarations // {{{",
            "initial assume(i_reset);",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; // }}} `define ASSERT assert `ifdef CPUOPS `define ASSUME assume `else `define ASSUME assert `endif // No request should be given us if/while we are busy // {{{",
            "always @(posedge i_clk) if (o_busy) `ASSUME(!i_stb); // }}} // Following any request other than a multiply request, we should // respond in the next cycle // {{{",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(o_busy))&&(!$past(this_is_a_multiply_op))) `ASSERT(!o_busy); // }}} // Valid and busy can never both be asserted // {{{",
            "always @(posedge i_clk) `ASSERT((!o_valid)||(!r_busy)); // }}} // Following any busy, we should",
            "always become valid // {{{",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_busy))&&(!o_busy)) `ASSERT($past(i_reset) || o_valid); // }}} // Check the shift values // {{{",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_stb))) begin if (($past(|i_b[31:6]))||($past(i_b[5:0])>6'd32)) begin assert(($past(i_op)!=4'h5) ||({o_c,c}=={(33){1'b0}})); assert(($past(i_op)!=4'h6) ||({c,o_c}=={(33){1'b0}})); assert(($past(i_op)!=4'h7) ||({o_c,c}=={(33){$past(i_a[31])}})); end else if ($past(i_b[5:0]==6'd32)) begin assert(($past(i_op)!=4'h5) ||(o_c=={(32){1'b0}})); assert(($past(i_op)!=4'h6) ||(o_c=={(32){1'b0}})); assert(($past(i_op)!=4'h7) ||(o_c=={(32){$past(i_a[31])}})); end if ($past(i_b)==0) begin assert(($past(i_op)!=4'h5) ||({o_c,c}=={$past(i_a), 1'b0})); assert(($past(i_op)!=4'h6) ||({c,o_c}=={1'b0, $past(i_a)})); assert(($past(i_op)!=4'h7) ||({o_c,c}=={$past(i_a), 1'b0})); end if ($past(i_b)==1) begin assert(($past(i_op)!=4'h5) ||({o_c,c}=={1'b0, $past(i_a)})); assert(($past(i_op)!=4'h6) ||({c,o_c}=={$past(i_a),1'b0})); assert(($past(i_op)!=4'h7) ||({o_c,c}=={$past(i_a[31]),$past(i_a)})); end if ($past(i_b)==2) begin assert(($past(i_op)!=4'h5) ||({o_c,c}=={2'b0, $past(i_a[31:1])})); assert(($past(i_op)!=4'h6) ||({c,o_c}=={$past(i_a[30:0]),2'b0})); assert(($past(i_op)!=4'h7) ||({o_c,c}=={{(2){$past(i_a[31])}},$past(i_a[31:1])})); end if ($past(i_b)==31) begin assert(($past(i_op)!=4'h5) ||({o_c,c}=={31'b0, $past(i_a[31:30])})); assert(($past(i_op)!=4'h6) ||({c,o_c}=={$past(i_a[1:0]),31'b0})); assert(($past(i_op)!=4'h7) ||({o_c,c}=={{(31){$past(i_a[31])}},$past(i_a[31:30])})); end end // }}} `endif // }}}",
            "endmodule // // iCE40 NoMPY,w/Shift NoMPY,w/o Shift // SB_CARRY 64 64 // SB_DFFE 3 3 // SB_DFFESR 1 1 // SB_DFFSR 33 33 // SB_LUT4 748 323"
        ]
    },
    {
        "file_name": "axilpipe.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axilpipe.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: axilpipe.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A memory unit to support a CPU based upon AXI-lite. Unlike the // axilops core, this one will permit multiple requests to be // outstanding at any given time. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2020-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module axilpipe #( // {{{",
            "parameter ADDRESS_WIDTH=30, parameter C_AXI_ADDR_WIDTH = ADDRESS_WIDTH, parameter C_AXI_DATA_WIDTH = 32, localparam AW = C_AXI_ADDR_WIDTH, localparam DW = C_AXI_DATA_WIDTH, // // AXI locks are a challenge, and require support from the // CPU. Specifically, we have to be able to unroll and re-do // the load instruction on any atomic access failure. For that // reason, we'll ignore the lock request",
            "initial ly.",
            "parameter [0:0] OPT_ALIGNMENT_ERR = 1'b1, // Verilator lint_off UNUSED // This *should* be used -- need to rewrite so that it is",
            "parameter [0:0] OPT_LOWPOWER = 1'b0, // Verilator lint_on UNUSED",
            "parameter [0:0] SWAP_WSTRB = 0, parameter [0:0] OPT_SIGN_EXTEND = 0 // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, input wire i_cpu_reset, // // CPU interface // {{{",
            "input wire i_stb, input wire i_lock, input wire [2:0] i_op, input wire [31:0] i_addr, input wire [31:0] i_data, input wire [4:0] i_o",
            "reg , output reg o_busy, output reg o_pipe_stalled, output reg o_rdbusy, output reg o_valid, output reg o_err, output reg [4:0] o_w",
            "reg , output reg [31:0] o_result, // }}} // // AXI-Lite bus interface // {{{ // Writes // {{{",
            "output reg M_AXI_AWVALID, input wire M_AXI_AWREADY, output reg [AW-1:0] M_AXI_AWADDR, // verilator coverage_off",
            "output wire [2:0] M_AXI_AWPROT, // verilator coverage_on // output reg M_AXI_WVALID, input wire M_AXI_WREADY, output reg [DW-1:0] M_AXI_WDATA, output reg [DW/8-1:0] M_AXI_WSTRB, // input wire M_AXI_BVALID, output wire M_AXI_BREADY, input wire [1:0] M_AXI_BRESP, // }}} // Reads // {{{",
            "output reg M_AXI_ARVALID, input wire M_AXI_ARREADY, output reg [AW-1:0] M_AXI_ARADDR, // verilator coverage_off",
            "output wire [2:0] M_AXI_ARPROT, // verilator coverage_on // input wire M_AXI_RVALID, output wire M_AXI_RREADY, input wire [DW-1:0] M_AXI_RDATA, input wire [1:0] M_AXI_RRESP // }}} // }}} // }}} ); // Declarations // {{{",
            "localparam AXILLSB = $clog2(C_AXI_DATA_WIDTH/8);",
            "localparam AXILSB = $clog2(C_AXI_DATA_WIDTH/8);",
            "localparam LGPIPE = 4;",
            "localparam FIFO_WIDTH = AXILLSB+1+2+5 + 1;",
            "wire i_clk = S_AXI_ACLK;",
            "reg w_misaligned;",
            "wire misaligned_request, misaligned_aw_request, pending_err, w_misalignment_err;",
            "reg [C_AXI_DATA_WIDTH-1:0] next_wdata;",
            "reg [C_AXI_DATA_WIDTH/8-1:0] next_wstrb;",
            "reg none_outstanding, bus_abort, read_abort, write_abort;",
            "reg [LGPIPE:0] beats_outstanding;",
            "reg r_flushing, flush_request, r_pipe_stalled;",
            "reg [LGPIPE:0] flushcount, new_flushcount;",
            "reg [LGPIPE:0] wraddr, rdaddr;",
            "reg [4:0] ar_o",
            "reg ;",
            "reg [1:0] ar_op;",
            "reg [AXILSB-1:0] adr_lsb;",
            "reg [FIFO_WIDTH-1:0] fifo_data [0:((1<<LGPIPE)-1)];",
            "reg [FIFO_WIDTH-1:0] fifo_read_data;",
            "wire fifo_read_op, fifo_misaligned;",
            "wire [1:0] fifo_op;",
            "wire [4:0] fifo_return_",
            "reg ;",
            "wire [AXILSB-1:0] fifo_lsb;",
            "reg [2*C_AXI_DATA_WIDTH-1:0] wide_return, wide_wdata;",
            "reg [31:0] pre_result;",
            "reg [2*C_AXI_DATA_WIDTH/8-1:0] wide_wstrb;",
            "reg [C_AXI_DATA_WIDTH-1:0] misdata; // }}} //////////////////////////////////////////////////////////////////////// // // Transaction issue // {{{ //////////////////////////////////////////////////////////////////////// // // // AWVALID // {{{",
            "initial M_AXI_AWVALID = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) M_AXI_AWVALID <= 0; else if (!M_AXI_AWVALID || M_AXI_AWREADY) begin if (i_stb && i_op[0]) M_AXI_AWVALID <= 1; else M_AXI_AWVALID <= M_AXI_AWVALID && misaligned_aw_request; if ((write_abort && !misaligned_aw_request)||w_misalignment_err) M_AXI_AWVALID <= 0; end // }}} // WVALID // {{{",
            "initial M_AXI_WVALID = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) M_AXI_WVALID <= 0; else if (!M_AXI_WVALID || M_AXI_WREADY) begin if (i_stb && i_op[0]) M_AXI_WVALID <= 1; else M_AXI_WVALID <= M_AXI_WVALID && misaligned_request; if ((write_abort && !misaligned_request)||w_misalignment_err) M_AXI_WVALID <= 0; end // }}} // ARVALID // {{{",
            "initial M_AXI_ARVALID = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) M_AXI_ARVALID <= 0; else if (!M_AXI_ARVALID || M_AXI_ARREADY) begin if (i_stb && !i_op[0]) M_AXI_ARVALID <= 1; else M_AXI_ARVALID <= M_AXI_ARVALID && misaligned_request; if ((read_abort && !misaligned_request)||w_misalignment_err) M_AXI_ARVALID <= 0; end // }}} // o_busy, // {{{ // True if the bus is busy doing ... something, whatever it might be. // If the bus is busy, the CPU will avoid issuing further interactions // to the bus other than pipelined interactions.",
            "initial o_busy = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) o_busy <= 0; else if (i_stb && !w_misalignment_err && !bus_abort) o_busy <= 1; else if (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) o_busy <= 1; else if (beats_outstanding > ((M_AXI_RVALID || M_AXI_BVALID) ? 1:0)) o_busy <= 1; else o_busy <= 0; `ifdef FORMAL",
            "always @(*) assert(o_busy == (!none_outstanding || M_AXI_ARVALID || M_AXI_AWVALID || M_AXI_WVALID)); `endif // }}} // Read busy // {{{ // True if the CPU should expect some kind of pending response from a // read, and so should stall for that purpose. False otherwise.",
            "initial o_rdbusy = 0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset || r_flushing) o_rdbusy <= 0; else if ((i_stb && w_misalignment_err) || bus_abort) o_rdbusy <= 0; else if (i_stb && !i_op[0]) o_rdbusy <= 1; else if (o_rdbusy && !M_AXI_ARVALID) o_rdbusy <= (beats_outstanding > (M_AXI_RVALID ? 1:0)); `ifdef FORMAL",
            "reg writing;",
            "always @(posedge S_AXI_ACLK) if (i_stb && !o_busy) writing <= i_op[0];",
            "always @(*) begin if (writing) assert(!o_rdbusy); if (r_flushing) assert(!o_rdbusy); if (!o_busy) assert(!o_rdbusy); end `endif // }}} // o_pipe_stalled, r_pipe_stalled // {{{ // True if the CPU should expect some kind of pending response from a // read, and so should stall for that purpose. False otherwise. generate if (OPT_ALIGNMENT_ERR) begin : FULL_PIPE_STALL // {{{ // Here, we stall if the FIFO is ever full. In this case, // any new beat will count as only one item to the FIFO, and // so we can run all the way to full.",
            "reg [LGPIPE:0] beats_committed;",
            "always @(*) beats_committed = beats_outstanding + ((i_stb && !w_misalignment_err) ? 1:0) + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0);",
            "initial r_pipe_stalled = 0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset) r_pipe_stalled <= 0; else if (M_AXI_RVALID || M_AXI_BVALID) r_pipe_stalled <= 0; else // if (!r_pipe_stalled) r_pipe_stalled <= (beats_committed >= (1<<LGPIPE)); `ifdef FORMAL",
            "always @(*) if (beats_outstanding + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0) >= (1<<LGPIPE)) begin assert(r_pipe_stalled || r_flushing); end else if (beats_outstanding + (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) < (1<<LGPIPE)-1) assert(!r_pipe_stalled); `endif // }}} end else begin : PENULTIMATE_FULL_STALL // {{{ // If we allow for misaligned reads and writes, than we have // to stall the CPU just before the FIFO is full, lest the // CPU send us a value that needs two items to be placed into // the FIO.",
            "reg [LGPIPE:0] beats_committed;",
            "always @(*) begin beats_committed = beats_outstanding + (i_stb ? 1:0) + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0) - ((M_AXI_BVALID || M_AXI_RVALID) ? 1:0); end",
            "initial r_pipe_stalled = 0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset || bus_abort) r_pipe_stalled <= 0; else begin r_pipe_stalled <= 0; if (i_stb && w_misaligned && !o_pipe_stalled) r_pipe_stalled <= 1'b1; if (misaligned_request && (M_AXI_WVALID && !M_AXI_WREADY)) r_pipe_stalled <= 1'b1; if (misaligned_request && (M_AXI_ARVALID && !M_AXI_ARREADY)) r_pipe_stalled <= 1'b1; if (misaligned_aw_request && (M_AXI_AWVALID && !M_AXI_AWREADY)) r_pipe_stalled <= 1'b1; if (beats_committed >= (1<<LGPIPE)-2) r_pipe_stalled <= 1'b1; end `ifdef FORMAL",
            "always @(*) if (!r_flushing && (beats_outstanding + (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) + (misaligned_aw_request || misaligned_request) >= (1<<LGPIPE))) begin assert(r_pipe_stalled); end else if (!r_flushing && !o_err && !M_AXI_AWVALID && !M_AXI_WVALID && !M_AXI_ARVALID && beats_outstanding <= ((1<<LGPIPE)-4)) assert(!r_pipe_stalled);",
            "always @(*) assert(beats_committed + ((i_stb && w_misaligned && !r_pipe_stalled) ? 1:0) <= (1<<LGPIPE)); `endif // }}} end endgenerate",
            "always @(*) begin o_pipe_stalled = r_pipe_stalled || r_flushing; if (M_AXI_AWVALID && (!M_AXI_AWREADY || misaligned_aw_request)) o_pipe_stalled = 1; if (M_AXI_WVALID && (!M_AXI_WREADY || misaligned_request)) o_pipe_stalled = 1; if (M_AXI_ARVALID && (!M_AXI_ARREADY || misaligned_request)) o_pipe_stalled = 1; end `ifdef FORMAL",
            "always @(*) if (misaligned_request) assert(M_AXI_WVALID || M_AXI_ARVALID);",
            "always @(*) if (misaligned_aw_request) assert(M_AXI_AWVALID); `endif // }}} // Count the number of outstanding beats // {{{ // This is the true count. It is not affected by the number of // items the CPU believes is on the bus or not.",
            "initial beats_outstanding = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) beats_outstanding <= 0; else casez({M_AXI_AWVALID && M_AXI_AWREADY, M_AXI_WVALID && M_AXI_WREADY, M_AXI_ARVALID && M_AXI_ARREADY, M_AXI_RVALID || M_AXI_BVALID}) 4'b0001: beats_outstanding <= beats_outstanding - 1; 4'b??10: beats_outstanding <= beats_outstanding + 1; 4'b1100: beats_outstanding <= beats_outstanding + 1; 4'b1000: if (!M_AXI_WVALID || (misaligned_aw_request && !misaligned_request)) beats_outstanding <= beats_outstanding + 1; 4'b0100: if (!M_AXI_AWVALID || (misaligned_request && !misaligned_aw_request)) beats_outstanding <= beats_outstanding + 1; 4'b10?1: if ((M_AXI_WVALID && (OPT_ALIGNMENT_ERR || (misaligned_request == misaligned_aw_request))) || (!misaligned_aw_request && misaligned_request)) beats_outstanding <= beats_outstanding - 1; 4'b0101: if ((M_AXI_AWVALID && (OPT_ALIGNMENT_ERR || (misaligned_request == misaligned_aw_request))) || (!misaligned_request && misaligned_aw_request)) beats_outstanding <= beats_outstanding - 1; default: begin end endcase",
            "initial none_outstanding = 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) none_outstanding <= 1; else casez({M_AXI_AWVALID && M_AXI_AWREADY, M_AXI_WVALID && M_AXI_WREADY, M_AXI_ARVALID && M_AXI_ARREADY, M_AXI_RVALID || M_AXI_BVALID}) 4'b0001: none_outstanding <= (beats_outstanding <= 1); 4'b??10: none_outstanding <= 0; 4'b1100: none_outstanding <= 0; 4'b1000: if (!M_AXI_WVALID || (misaligned_aw_request && !misaligned_request)) none_outstanding <= 0; 4'b0100: if (!M_AXI_AWVALID || (misaligned_request && !misaligned_aw_request)) none_outstanding <= 0; 4'b10?1: if ((M_AXI_WVALID && (OPT_ALIGNMENT_ERR || (misaligned_request == misaligned_aw_request))) || (!misaligned_aw_request && misaligned_request)) none_outstanding <= (beats_outstanding <= 1); 4'b0101: if ((M_AXI_AWVALID && (OPT_ALIGNMENT_ERR || (misaligned_request == misaligned_aw_request))) || (!misaligned_request && misaligned_aw_request)) none_outstanding <= (beats_outstanding <= 1); default: begin end endcase `ifdef FORMAL",
            "always @(*) assert(none_outstanding == (beats_outstanding == 0)); `endif // }}} // bus_abort // {{{ // When do we abandon everything and start aborting bus transactions?",
            "always @(*) begin bus_abort = 0; if (i_cpu_reset || o_err) bus_abort = 1; if (M_AXI_BVALID && M_AXI_BRESP[1]) bus_abort = 1; if (M_AXI_RVALID && M_AXI_RRESP[1]) bus_abort = 1; write_abort = 0; if (i_cpu_reset || o_err) write_abort = 1; if (M_AXI_BVALID && M_AXI_BRESP[1]) write_abort = 1; read_abort = 0; if (i_cpu_reset || o_err) read_abort = 1; if (M_AXI_RVALID && M_AXI_RRESP[1]) read_abort = 1; end // }}} // Flushing // {{{ // new_flushcount // {{{",
            "always @(*) begin case({((M_AXI_AWVALID || M_AXI_WVALID) || M_AXI_ARVALID), (M_AXI_BVALID || M_AXI_RVALID) }) 2'b01: new_flushcount = beats_outstanding - 1; 2'b10: new_flushcount = beats_outstanding + 1; default: new_flushcount = beats_outstanding; endcase if (!OPT_ALIGNMENT_ERR && (misaligned_request || misaligned_aw_request)) new_flushcount = new_flushcount + 1; end // }}}",
            "initial r_flushing = 1'b0;",
            "initial flushcount = 0;",
            "initial flush_request = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) begin // {{{ r_flushing <= 1'b0; flush_request <= 0; flushcount <= 0; // }}} end else if (i_cpu_reset || bus_abort || (i_stb && w_misalignment_err)) begin // {{{ r_flushing <= (new_flushcount != 0); flushcount <= new_flushcount; flush_request <= (M_AXI_ARVALID && (!M_AXI_ARREADY || misaligned_request)) || (M_AXI_AWVALID && (!M_AXI_AWREADY || misaligned_aw_request)) || (M_AXI_WVALID && (!M_AXI_WREADY || misaligned_request)); // }}} end else if (r_flushing) begin // {{{ if (M_AXI_BVALID || M_AXI_RVALID) begin flushcount <= flushcount - 1; r_flushing <= (flushcount > 1); end casez({M_AXI_AWVALID && (M_AXI_AWREADY && !misaligned_aw_request), (M_AXI_WVALID && M_AXI_WREADY && !misaligned_request), (M_AXI_ARVALID && M_AXI_ARREADY && !misaligned_request) }) 3'b001: flush_request <= 0; 3'b10?: flush_request <= M_AXI_WVALID; 3'b01?: flush_request <= M_AXI_AWVALID; 3'b11?: flush_request <= 0; default: begin end endcase // }}} end `ifdef FORMAL",
            "always @(*) begin assert(r_flushing == (flushcount > 0)); if (!r_flushing) begin assert(!flush_request); end else assert(flush_request == (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID)); if (r_flushing && !flush_request) begin assert(!misaligned_request); assert(!misaligned_aw_request); end if (flush_request) begin assert(flushcount == beats_outstanding + 1 + ((misaligned_request || misaligned_aw_request) ? 1:0)); // else if (faxil_rd_outstanding > 0 || M_AXI_ARVALID) end else if (r_flushing) begin assert(beats_outstanding == flushcount); end else assert(beats_outstanding >= flushcount); end `endif // }}} // Bus addressing // {{{",
            "initial M_AXI_AWADDR = 0;",
            "always @(posedge i_clk) if (i_stb) begin M_AXI_AWADDR <= i_addr[AW-1:0]; if (SWAP_WSTRB) M_AXI_AWADDR[AXILSB-1:0] <= 0; end else if (!OPT_ALIGNMENT_ERR && ((M_AXI_AWVALID && M_AXI_AWREADY) // && misaligned_aw_request || (M_AXI_ARVALID && M_AXI_ARREADY))) // && misaligned_request)) begin M_AXI_AWADDR[AW-1:AXILSB] <= M_AXI_AWADDR[AW-1:AXILSB] + 1; M_AXI_AWADDR[AXILSB-1:0] <= 0; end",
            "always @(*) M_AXI_ARADDR = M_AXI_AWADDR; // }}} // Is this request misaligned? // {{{",
            "always @(*) casez(i_op[2:1]) // Full word 2'b0?: w_misaligned = (i_addr[AXILSB-1:0]+3) >= (1<<AXILSB); // Half word 2'b10: w_misaligned = (i_addr[AXILSB-1:0]+1) >= (1<<AXILSB); // Bytes are",
            "always aligned 2'b11: w_misaligned = 1'b0; endcase",
            "assign w_misalignment_err = w_misaligned && OPT_ALIGNMENT_ERR; // }}} // wide_wdata, wide_wstrb // {{{",
            "always @(*) if (SWAP_WSTRB) begin : BACKWARDS_ORDER // {{{ casez(i_op[2:1]) 2'b10: wide_wdata = { i_data[15:0], {(2*C_AXI_DATA_WIDTH-16){1'b0}} } >> (i_addr[AXILSB-1:0] * 8); 2'b11: wide_wdata = { i_data[7:0], {(2*C_AXI_DATA_WIDTH-8){1'b0}} } >> (i_addr[AXILSB-1:0] * 8); default: wide_wdata = ({ i_data, {(2*C_AXI_DATA_WIDTH-32){ 1'b0 }} } >> (i_addr[AXILSB-1:0] * 8)); endcase casez(i_op[2:1]) 2'b0?: wide_wstrb = { 4'b1111, {(2*C_AXI_DATA_WIDTH/8-4){1'b0}} } >> i_addr[AXILSB-1:0]; 2'b10: wide_wstrb = { 2'b11, {(2*C_AXI_DATA_WIDTH/8-2){1'b0}} } >> i_addr[AXILSB-1:0]; 2'b11: wide_wstrb = { 1'b1, {(2*C_AXI_DATA_WIDTH/8-1){1'b0}} } >> i_addr[AXILSB-1:0]; endcase // }}} end else begin : LITTLE_ENDIAN_DATA // {{{ casez(i_op[2:1]) 2'b10: wide_wdata = { {(2*C_AXI_DATA_WIDTH-16){1'b0}}, i_data[15:0] } << (8*i_addr[AXILSB-1:0]); 2'b11: wide_wdata = { {(2*C_AXI_DATA_WIDTH-8){1'b0}}, i_data[7:0] } << (8*i_addr[AXILSB-1:0]); default: wide_wdata = { {(2*C_AXI_DATA_WIDTH-32){1'b0}}, i_data } << (8*i_addr[AXILSB-1:0]); endcase casez(i_op[2:1]) 2'b0?: wide_wstrb = { {(2*C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b1111} << i_addr[AXILSB-1:0]; 2'b10: wide_wstrb = { {(2*C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b0011} << i_addr[AXILSB-1:0]; 2'b11: wide_wstrb = { {(2*C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b0001} << i_addr[AXILSB-1:0]; endcase // }}} end // }}} // WDATA and WSTRB // {{{",
            "initial M_AXI_WDATA = 0;",
            "initial M_AXI_WSTRB = 0;",
            "initial next_wdata = 0;",
            "initial next_wstrb = 0;",
            "always @(posedge i_clk) if (i_stb) begin if (SWAP_WSTRB) begin : BACKWARDS_ORDER_REG // {{{ { M_AXI_WDATA, next_wdata } <= wide_wdata; { M_AXI_WSTRB, next_wstrb } <= wide_wstrb; // }}} end else begin // {{{ { next_wdata, M_AXI_WDATA } <= wide_wdata; { next_wstrb, M_AXI_WSTRB } <= wide_wstrb; // }}} end if (OPT_ALIGNMENT_ERR) { next_wstrb, next_wdata } <= 0; end else if ((OPT_LOWPOWER || !OPT_ALIGNMENT_ERR) && M_AXI_WREADY) begin M_AXI_WDATA <= next_wdata; M_AXI_WSTRB <= next_wstrb; if (OPT_LOWPOWER) { next_wdata, next_wstrb } <= 0; end // }}} generate if (OPT_ALIGNMENT_ERR) begin : GEN_ALIGNMENT_ERR // {{{ // Generate an error on any misaligned request",
            "assign misaligned_request = 1'b0;",
            "assign misaligned_aw_request = 1'b0;",
            "assign pending_err = 1'b0; // }}} end else begin : GEN_REALIGNMENT // {{{",
            "reg r_misaligned_request, r_misaligned_aw_request, r_pending_err; // misaligned_request // {{{",
            "initial r_misaligned_request = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) r_misaligned_request <= 0; else if (i_stb && !o_err && !i_cpu_reset && !bus_abort) r_misaligned_request <= w_misaligned; else if ((M_AXI_WVALID && M_AXI_WREADY) || (M_AXI_ARVALID && M_AXI_ARREADY)) r_misaligned_request <= 1'b0;",
            "assign misaligned_request = r_misaligned_request; // }}} // misaligned_aw_request // {{{",
            "initial r_misaligned_aw_request = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) r_misaligned_aw_request <= 0; else if (i_stb && !o_err && !i_cpu_reset && !write_abort) r_misaligned_aw_request <= w_misaligned && i_op[0]; else if (M_AXI_AWREADY) r_misaligned_aw_request <= 1'b0;",
            "assign misaligned_aw_request = r_misaligned_aw_request; // }}} // pending_err // {{{",
            "initial r_pending_err = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || i_stb || o_err || r_flushing) r_pending_err <= 1'b0; else if ((M_AXI_BVALID && M_AXI_BRESP[1]) || (M_AXI_RVALID && M_AXI_RRESP[1])) r_pending_err <= 1'b1;",
            "assign pending_err = r_pending_err; // }}} `ifdef FORMAL",
            "always @(*) if (pending_err) assert(r_flushing || o_err); `endif // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Read transaction FIFO // {{{ //////////////////////////////////////////////////////////////////////// // // // wraddr // {{{",
            "initial wraddr = 0;",
            "always @(posedge S_AXI_ACLK) if (bus_abort || flush_request) // bus_abort includes i_cpu_reset wraddr <= 0; else if ((M_AXI_ARVALID && M_AXI_ARREADY) || (M_AXI_WVALID && M_AXI_WREADY)) wraddr <= wraddr + 1; // }}} // rdaddr // {{{",
            "initial rdaddr = 0;",
            "always @(posedge S_AXI_ACLK) if (bus_abort || r_flushing) rdaddr <= 0; else if (M_AXI_RVALID||M_AXI_BVALID) rdaddr <= rdaddr + 1; // }}} // ar_o",
            "reg , ar_op, adr_lsb // {{{",
            "always @(posedge S_AXI_ACLK) if (i_stb) { ar_o",
            "reg , ar_op, adr_lsb } <= { i_o",
            "reg , i_op[2:1], i_addr[AXILSB-1:0] }; else if ((M_AXI_ARVALID && M_AXI_ARREADY)||(M_AXI_WVALID && M_AXI_WREADY)) adr_lsb <= 0; // }}} // fifo_data // {{{",
            "always @(posedge S_AXI_ACLK) if ((M_AXI_ARVALID && M_AXI_ARREADY) || (M_AXI_WVALID && M_AXI_WREADY)) fifo_data[wraddr[LGPIPE-1:0]] <= { M_AXI_ARVALID, ar_o",
            "reg ,ar_op, misaligned_request, adr_lsb };",
            "always @(*) fifo_read_data = fifo_data[rdaddr[LGPIPE-1:0]];",
            "assign { fifo_read_op, fifo_return_",
            "reg , fifo_op, fifo_misaligned, fifo_lsb } = fifo_read_data; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Read return generation // {{{ //////////////////////////////////////////////////////////////////////// // // // o_valid // {{{",
            "initial o_valid = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || r_flushing) o_valid <= 1'b0; else if (OPT_ALIGNMENT_ERR && i_stb && w_misaligned) o_valid <= 1'b0; else o_valid <= M_AXI_RVALID && !M_AXI_RRESP[1] // && !pending_err && !fifo_misaligned; // }}} // o_w",
            "reg // {{{",
            "always @(posedge i_clk) o_w",
            "reg <= fifo_return_",
            "reg ; // }}} // o_result, misdata // {{{ // Need to realign any returning data // wide_return // {{{",
            "always @(*) begin if (SWAP_WSTRB) begin if (fifo_misaligned && !OPT_ALIGNMENT_ERR) wide_return = { misdata, M_AXI_RDATA } << (8*fifo_lsb); else wide_return = { M_AXI_RDATA, {(DW){1'b0}} } << (8*fifo_lsb); end else begin if (fifo_misaligned && !OPT_ALIGNMENT_ERR) wide_return = { M_AXI_RDATA, misdata } >> (8*fifo_lsb); else wide_return = { {(C_AXI_DATA_WIDTH){1'b0}}, M_AXI_RDATA } >> (8*fifo_lsb); end if (OPT_LOWPOWER && (!M_AXI_RVALID || M_AXI_RRESP[1])) wide_return = 0; end",
            "always @(*) begin if (SWAP_WSTRB) begin pre_result = 0; casez(fifo_op) 2'b10: pre_result[15:0] = { wide_return[(2*DW)-1:(2*DW)-16] }; 2'b11: pre_result[7:0] = { wide_return[(2*DW)-1:(2*DW)-8] }; default: pre_result[31:0] = wide_return[(2*DW-1):(2*DW-32)]; endcase end else pre_result = wide_return[31:0]; end // }}} // misdata // {{{",
            "always @(posedge i_clk) if (OPT_ALIGNMENT_ERR) misdata <= 0; else if (M_AXI_RVALID) begin if (fifo_misaligned) misdata <= M_AXI_RDATA; else misdata <= 0; end // }}} // o_result // {{{",
            "always @(posedge i_clk) if (OPT_LOWPOWER && (!S_AXI_ARESETN || r_flushing || i_cpu_reset)) begin o_result <= 0; end else if (!OPT_LOWPOWER || M_AXI_RVALID) begin o_result <= pre_result[31:0]; if (OPT_SIGN_EXTEND) begin // {{{ // Optionally sign extend the return result. case(fifo_op) 2'b10: o_result[31:16] <= {(16){pre_result[15]}}; 2'b11: o_result[31: 8] <= {(24){pre_result[7]}}; default: begin end endcase // }}} end else if (fifo_op[1]) begin // {{{ if (fifo_op[0]) o_result[31: 8] <= 0; else o_result[31:16] <= 0; // }}} end end // }}} // }}} // o_err - report bus errors back to the CPU // {{{",
            "initial o_err = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || r_flushing || o_err) o_err <= 1'b0; else if (OPT_ALIGNMENT_ERR && i_stb && w_misaligned) o_err <= 1'b1; else if (M_AXI_BVALID || M_AXI_RVALID) o_err <= (M_AXI_BVALID && M_AXI_BRESP[1]) || (M_AXI_RVALID && M_AXI_RRESP[1]); else o_err <= 1'b0; // }}} // Return xREADY --",
            "always ready // {{{",
            "assign M_AXI_RREADY = 1;",
            "assign M_AXI_BREADY = 1; // }}} // AxPROT -- CPU data // {{{",
            "assign M_AXI_AWPROT = 3'b000;",
            "assign M_AXI_ARPROT = 3'b000; // }}} // }}} // Make verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, M_AXI_RRESP[0], M_AXI_BRESP[0], i_lock, // i_addr[31:C_AXI_ADDR_WIDTH], (&i_addr), pending_err, adr_lsb, fifo_read_op, none_outstanding }; generate if (SWAP_WSTRB) begin : GEN_UNUSED",
            "wire wide_unused; if (SWAP_WSTRB) begin : UNUSED_SWAP",
            "assign wide_unused = &{ 1'b0, wide_return[2*DW-32-1:0] }; end else begin : UNUSED",
            "assign wide_unused = &{ 1'b0, wide_return[2*DW-1:32] }; end end endgenerate // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal property section // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Declarations // {{{ `define ASSERT assert `ifndef BMC_ASSERT `define BMC_ASSERT assume `endif `ifdef AXILPIPE `define ASSUME assume `else `define ASSUME assert `endif",
            "localparam F_LGDEPTH = LGPIPE+1;",
            "wire [F_LGDEPTH-1:0] faxil_rd_outstanding, faxil_wr_outstanding, faxil_awr_outstanding;",
            "reg [LGPIPE:0] f_fifo_fill;",
            "reg f_clrfifo, f_wrfifo, f_rdfifo;",
            "wire misaligned_response_pending;",
            "reg [1:0] f_fsmfifo; (* anyconst *)",
            "reg [LGPIPE:0] f_first_addr;",
            "reg [LGPIPE:0] f_next_addr, f_penu_addr, f_last_written, f_distance_to_first, f_distance_to_next;",
            "reg [FIFO_WIDTH-1:0] f_first_data, f_next_data, f_penu_data;",
            "reg [4:0] f_first_return_",
            "reg , f_next_return_",
            "reg , f_return_",
            "reg , f_penu_return_",
            "reg ;",
            "reg f_first_in_fifo, f_next_in_fifo, f_first_misaligned, f_next_misaligned, f_this_misaligned, f_penu_misaligned, f_first_read_cycle, f_next_read_cycle, f_this_read_cycle, f_penu_read_cycle;",
            "wire [LGPIPE:0] cpu_outstanding;",
            "wire cpu_gie, cpu_pc, cpu_read_cycle;",
            "wire [4:0] cpu_last_",
            "reg , cpu_addr_",
            "reg ;",
            "reg [4:0] f_ar_a",
            "reg ; (* anyseq *)",
            "reg [4:0] f_a",
            "reg ;",
            "reg f_done;",
            "reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid = 1'b1;",
            "always @(*) if (!f_past_valid) `ASSUME(!S_AXI_ARESETN); // }}} //////////////////////////////////////////////////////////////////////// // // Bus property checking // {{{ //////////////////////////////////////////////////////////////////////// // // faxil_master #( // {{{ .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH), .F_OPT_ASSUME_RESET(1'b1), .F_LGDEPTH(F_LGDEPTH) // }}} ) faxil( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // .i_axi_awvalid(M_AXI_AWVALID), .i_axi_awready(M_AXI_AWREADY), .i_axi_awaddr( M_AXI_AWADDR), .i_axi_awprot( M_AXI_AWPROT), // .i_axi_wvalid(M_AXI_WVALID), .i_axi_wready(M_AXI_WREADY), .i_axi_wdata( M_AXI_WDATA), .i_axi_wstrb( M_AXI_WSTRB), // .i_axi_bvalid(M_AXI_BVALID), .i_axi_bready(M_AXI_BREADY), .i_axi_bresp( M_AXI_BRESP), // .i_axi_arvalid(M_AXI_ARVALID), .i_axi_arready(M_AXI_ARREADY), .i_axi_araddr( M_AXI_ARADDR), .i_axi_arprot( M_AXI_ARPROT), // .i_axi_rvalid(M_AXI_RVALID), .i_axi_rready(M_AXI_RREADY), .i_axi_rdata( M_AXI_RDATA), .i_axi_rresp( M_AXI_RRESP), // .f_axi_rd_outstanding(faxil_rd_outstanding), .f_axi_wr_outstanding(faxil_wr_outstanding), .f_axi_awr_outstanding(faxil_awr_outstanding) // }}} );",
            "always @(*) f_fifo_fill = wraddr - rdaddr;",
            "always @(*) begin if (misaligned_request) `ASSERT(M_AXI_WVALID || M_AXI_ARVALID); if (misaligned_aw_request) `ASSERT(M_AXI_AWVALID); if (M_AXI_ARVALID || faxil_rd_outstanding > 0) begin assert(faxil_wr_outstanding == 0 && faxil_awr_outstanding == 0); assert(!M_AXI_AWVALID); assert(!M_AXI_WVALID); end if (faxil_wr_outstanding > 0 || faxil_awr_outstanding > 0 || M_AXI_AWVALID || M_AXI_WVALID) begin assert(faxil_rd_outstanding == 0); assert(!M_AXI_ARVALID); end // Rule: Only one of the two VALID's may be valid, never both `ASSERT(!M_AXI_RVALID || (!M_AXI_AWVALID && !M_AXI_WVALID)); assert(beats_outstanding + ((misaligned_request && !misaligned_aw_request && M_AXI_WVALID) ? 1:0) + ((M_AXI_WVALID && !M_AXI_AWVALID) ? 1:0) == faxil_rd_outstanding + faxil_awr_outstanding); assert(beats_outstanding + ((misaligned_aw_request && !misaligned_request) ? 1:0) + ((M_AXI_AWVALID && !M_AXI_WVALID) ? 1:0) == faxil_rd_outstanding + faxil_wr_outstanding); if (OPT_ALIGNMENT_ERR && !r_flushing && (faxil_rd_outstanding > 0 || M_AXI_ARVALID)) begin assert(f_fifo_fill == faxil_rd_outstanding); end else if (OPT_ALIGNMENT_ERR && !r_flushing && (faxil_wr_outstanding > 0 || M_AXI_WVALID)) assert(f_fifo_fill == faxil_wr_outstanding); if (faxil_rd_outstanding == 0 && faxil_wr_outstanding == 0) assert(f_fifo_fill == 0); end",
            "always @(*) if (!o_busy) `ASSERT(!r_flushing); // Following any i_stb request, assuming we are idle, immediately // begin a bus transaction",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_stb && !o_err)) &&(!$past(o_busy))&&($past(!i_cpu_reset))) begin `ASSERT(o_busy || (OPT_ALIGNMENT_ERR && o_err)); end",
            "always @(*) if (o_busy && !misaligned_request && OPT_LOWPOWER) begin assert(next_wdata == 0); assert(next_wstrb == 0); end // o_err checking // {{{ // If a transaction ends in an error, send o_err on the",
            "output port.",
            "always @(posedge i_clk) if (f_past_valid) begin if ($past(i_cpu_reset || r_flushing || o_err)) begin `ASSERT(!o_err); end else if ($past(M_AXI_BVALID && M_AXI_BRESP[1])) begin `ASSERT(o_err); end else if ($past(M_AXI_RVALID && M_AXI_RRESP[1])) begin `ASSERT(o_err); end else if (OPT_ALIGNMENT_ERR && $past(i_stb && w_misaligned)) begin `ASSERT(o_err); end else if (!$past(pending_err)) `ASSERT(!o_err); end // }}}",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(!i_cpu_reset))&&($past(i_stb))) begin // On a write, assert o_wb_we should be true assert($past(i_op[0] && !o_err && (!M_AXI_BVALID || !M_AXI_BRESP[1]) && (!OPT_ALIGNMENT_ERR || !w_misaligned)) == (M_AXI_AWVALID && M_AXI_WVALID)); end",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_cpu_reset))) `ASSUME(!i_stb);",
            "always @(*) if (!S_AXI_ARESETN) `ASSUME(i_cpu_reset); // misaligned_response_pending // {{{ generate if (OPT_ALIGNMENT_ERR) begin : NO_MISALIGNED_RESPONSES",
            "assign misaligned_response_pending = 0; end else begin : MISALIGNED_RESPONSE_PENDING",
            "reg r_misaligned_response_pending;",
            "always @(*) begin r_misaligned_response_pending = fifo_misaligned; if (wraddr == rdaddr) r_misaligned_response_pending = 0; end",
            "assign misaligned_response_pending = r_misaligned_response_pending; end endgenerate // }}}",
            "always @(*) if (o_busy) begin cover(i_stb); cover(o_valid); cover(o_err); end else begin cover(o_valid); cover(o_err); end // }}} //////////////////////////////////////////////////////////////////////// // // Zero on idle checks // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_LOWPOWER) begin",
            "always @(*) if (!M_AXI_AWVALID && !M_AXI_ARVALID) `ASSERT(M_AXI_AWADDR == 0);",
            "always @(*) if (!M_AXI_WVALID) begin `ASSERT(M_AXI_WDATA == 0); `ASSERT(M_AXI_WSTRB == 0); `ASSERT(next_wdata == 0); `ASSERT(next_wstrb == 0); end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // FIFO property checking // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) begin // {{{ f_next_addr = f_first_addr + 1; f_last_written = wraddr - 1; f_penu_addr = rdaddr + 1; f_penu_data = fifo_data[f_penu_addr[LGPIPE-1:0]]; f_clrfifo = (!S_AXI_ARESETN || bus_abort || flush_request); f_wrfifo = (!f_clrfifo) && ((M_AXI_ARVALID && M_AXI_ARREADY) || (M_AXI_WVALID && M_AXI_WREADY)); f_rdfifo = (!f_clrfifo) && ((M_AXI_RVALID && M_AXI_RREADY) || (M_AXI_BVALID && M_AXI_BREADY)); f_distance_to_first = f_first_addr - rdaddr; f_distance_to_next = f_next_addr - rdaddr; f_first_in_fifo = (f_distance_to_first < f_fifo_fill) && (f_fifo_fill > 0); f_next_in_fifo = (f_distance_to_next < f_fifo_fill) && (f_fifo_fill > 0); f_return_",
            "reg = fifo_return_",
            "reg ; f_first_return_",
            "reg = f_first_data[AXILLSB+3 +: 5]; f_next_return_",
            "reg = f_next_data[AXILLSB+3 +: 5]; f_penu_return_",
            "reg = f_penu_data[AXILLSB+3 +: 5]; f_first_misaligned = f_first_data[AXILLSB]; f_next_misaligned = f_next_data[AXILLSB]; f_this_misaligned = fifo_read_data[AXILLSB]; f_penu_misaligned = f_penu_data[AXILLSB]; f_first_read_cycle = f_first_data[FIFO_WIDTH-1]; f_next_read_cycle = f_next_data[FIFO_WIDTH-1]; f_this_read_cycle = fifo_read_data[FIFO_WIDTH-1]; f_penu_read_cycle = f_penu_data[FIFO_WIDTH-1]; // }}} end",
            "always @(*) if (r_flushing && !f_clrfifo) assert(rdaddr == wraddr);",
            "always @(*) if (!f_clrfifo) begin if (f_first_in_fifo) `ASSERT(f_first_data == fifo_data[f_first_addr]); if (f_next_in_fifo) `ASSERT(f_next_data == fifo_data[f_next_addr]); end",
            "always @(posedge S_AXI_ACLK) if (f_wrfifo && wraddr == f_first_addr) f_first_data <= { M_AXI_ARVALID, ar_o",
            "reg , ar_op, misaligned_request, adr_lsb };",
            "always @(posedge S_AXI_ACLK) if (f_wrfifo && wraddr == f_next_addr) f_next_data <= { M_AXI_ARVALID, ar_o",
            "reg , ar_op, misaligned_request, adr_lsb }; // f_fsmfifo // {{{",
            "initial f_fsmfifo = 2'b00;",
            "always @(posedge S_AXI_ACLK) if (f_clrfifo) f_fsmfifo <= 2'b00; else case(f_fsmfifo) 2'b00: if (f_wrfifo && wraddr == f_first_addr) f_fsmfifo <= 2'b01; 2'b01: if (f_rdfifo && rdaddr == f_first_addr) f_fsmfifo <= 2'b00; else if (f_wrfifo && wraddr == f_next_addr) f_fsmfifo <= 2'b10; 2'b10: if (f_rdfifo && rdaddr == f_first_addr) f_fsmfifo <= 2'b11; 2'b11: if (f_rdfifo) f_fsmfifo <= 2'b00; endcase",
            "always @(*) if (!f_clrfifo) case(f_fsmfifo) 2'b00: begin // {{{ `ASSERT(!f_first_in_fifo); end // }}} 2'b01: begin // {{{ `ASSERT(f_fifo_fill >= 1); `ASSERT(f_first_in_fifo); end // }}} 2'b10: begin // {{{ `ASSERT(f_fifo_fill >= 2); `ASSERT(f_first_in_fifo); `ASSERT(f_next_in_fifo); end // }}} 2'b11: begin // {{{ `ASSERT(f_fifo_fill >= 1); `ASSERT(f_next_in_fifo); end // }}} endcase // }}} // { ar_o",
            "reg , ar_op, misaligned_request, M_AXI_ARADDR[AXILLSB-1:0] }; // cpu_gie checks // {{{",
            "always @(*) if (M_AXI_ARVALID) `ASSERT(cpu_gie == ar_o",
            "reg [4]);",
            "always @(*) if (!f_clrfifo && f_fifo_fill != 0) begin if (M_AXI_ARVALID || M_AXI_WVALID || M_AXI_AWVALID) `ASSERT(cpu_gie == ar_o",
            "reg [4]); if ((!f_first_in_fifo || rdaddr != f_first_addr) && (!f_next_in_fifo || rdaddr != f_next_addr) && (f_fifo_fill > 0)) `ASSUME(cpu_gie == f_return_",
            "reg [4]); if (f_first_in_fifo) `ASSERT(cpu_gie == f_first_return_",
            "reg [4]); if (f_next_in_fifo) `ASSERT(cpu_gie == f_next_return_",
            "reg [4]); end // }}} // cpu_pc checks // {{{",
            "always @(*) if (M_AXI_ARVALID) `ASSERT(cpu_pc == ((&ar_o",
            "reg [3:1]) && (o_err || !flush_request)));",
            "always @(*) if (!f_clrfifo && f_fifo_fill != 0) begin if ((M_AXI_ARVALID || (rdaddr != f_last_written))) begin `ASSERT(f_this_misaligned || !cpu_read_cycle || !(&f_return_",
            "reg [3:1])); end else if (f_fifo_fill > 0 && !M_AXI_ARVALID) `ASSERT(f_this_misaligned || !cpu_read_cycle || cpu_pc == (&f_return_",
            "reg [3:1])); if ((!f_first_in_fifo || rdaddr != f_first_addr) && (!f_next_in_fifo || rdaddr != f_next_addr) && cpu_read_cycle) begin if (M_AXI_ARVALID) // && (&ar_o",
            "reg [3:1])) begin `ASSUME(!(&f_return_",
            "reg [3:1])); end else if (rdaddr != f_last_written) begin `ASSUME(!(&f_return_",
            "reg [3:1])); end else if (!M_AXI_ARVALID && !o_err) `ASSUME(cpu_pc == (&f_return_",
            "reg [3:1])); // Not last written end if (f_first_in_fifo && cpu_read_cycle) begin if (!cpu_pc || M_AXI_ARVALID || (f_last_written != f_first_addr)) begin `ASSERT(f_first_misaligned || !cpu_read_cycle || !(&f_first_return_",
            "reg [3:1])); end else if (!M_AXI_ARVALID && !o_err) `ASSERT(&f_first_return_",
            "reg [3:1]); end if (f_next_in_fifo && cpu_read_cycle) begin if (!cpu_pc || M_AXI_ARVALID || (f_last_written != f_next_addr)) begin `ASSERT(f_next_misaligned || !(&f_next_return_",
            "reg [3:1])); end else if (!M_AXI_ARVALID && !o_err) `ASSERT(&f_next_return_",
            "reg [3:1]); end if (M_AXI_ARVALID) `ASSERT(cpu_pc == (&ar_o",
            "reg [3:1])); end // }}}",
            "always @(*) if (cpu_read_cycle && !r_flushing) assert(o_rdbusy==((rdaddr != wraddr)||(M_AXI_ARVALID)));",
            "always @(*) if (cpu_read_cycle) assert(!M_AXI_AWVALID && !M_AXI_WVALID && faxil_awr_outstanding == 0); // Verifying the alignment flags // {{{",
            "always @(*) if (M_AXI_ARVALID && OPT_ALIGNMENT_ERR) assert(!misaligned_request);",
            "always @(*) if (!f_clrfifo && f_fifo_fill != 0) begin if (OPT_ALIGNMENT_ERR) begin // {{{ if (f_first_in_fifo) `ASSERT(!f_first_misaligned); if (f_next_in_fifo) `ASSERT(!f_next_misaligned); if ((!f_first_in_fifo || rdaddr != f_first_addr) && (!f_next_in_fifo || rdaddr != f_next_addr)) `ASSUME(!f_this_misaligned); // }}} end else begin // {{{ if (f_first_in_fifo && f_first_misaligned) begin if (f_next_in_fifo) begin `ASSERT(!f_next_misaligned); end else begin `ASSERT(!misaligned_request); `ASSERT(M_AXI_ARVALID || M_AXI_WVALID); end end if (misaligned_response_pending && (!f_first_in_fifo || rdaddr != f_first_addr)) begin if (f_fifo_fill > 1) begin `BMC_ASSERT(!f_penu_misaligned); end else if (f_fifo_fill == 1) `BMC_ASSERT(!misaligned_request); end // }}} end end // }}} // Verifying unaligned",
            "reg isters remain the same // {{{",
            "always @(*) if (!f_clrfifo && f_fifo_fill != 0 && !OPT_ALIGNMENT_ERR) begin if (f_first_in_fifo && f_first_misaligned) begin if (f_next_in_fifo) begin `ASSERT(f_first_return_",
            "reg == f_next_return_",
            "reg ); end else begin `ASSERT(M_AXI_ARVALID || M_AXI_WVALID); `ASSERT(!misaligned_request); `ASSERT(f_first_return_",
            "reg == ar_o",
            "reg ); end end if (misaligned_response_pending && (!f_first_in_fifo || rdaddr != f_first_addr)) begin if (f_fifo_fill == 1) begin `BMC_ASSERT(M_AXI_ARVALID || M_AXI_WVALID); `BMC_ASSERT(!misaligned_request); `BMC_ASSERT(f_first_return_",
            "reg == ar_o",
            "reg ); end else `BMC_ASSERT(fifo_return_",
            "reg == f_penu_return_",
            "reg ); end end // }}}",
            "always @(*) assert(f_fifo_fill <= (1<<LGPIPE));",
            "always @(*) assert(beats_outstanding <= (1<<LGPIPE)); // Verifying the cpu_read_cycle flags // {{{",
            "always @(*) if (!r_flushing && f_fifo_fill > 0) begin if (f_first_in_fifo) `ASSERT(cpu_read_cycle == f_first_read_cycle); if (f_next_in_fifo) `ASSERT(cpu_read_cycle == f_next_read_cycle); if (// f_fifo_fill > 0 && // Redundant (!f_first_in_fifo || rdaddr != f_first_addr) && (!f_next_in_fifo || rdaddr != f_next_addr)) begin `BMC_ASSERT(cpu_read_cycle == f_this_read_cycle); end if (f_fifo_fill > 1 && (!f_first_in_fifo || f_penu_addr != f_first_addr) && (!f_next_in_fifo || f_penu_addr != f_next_addr)) begin `BMC_ASSERT(cpu_read_cycle == f_penu_read_cycle); end if (cpu_read_cycle) begin `ASSERT(!M_AXI_AWVALID && !M_AXI_WVALID); `ASSERT(faxil_awr_outstanding == 0); `ASSERT(faxil_wr_outstanding == 0); end end // }}} // Verifying the cpu_last_",
            "reg // {{{",
            "always @(*) if (M_AXI_WVALID || M_AXI_ARVALID) begin assert(cpu_last_",
            "reg == ar_o",
            "reg ); end else if (!f_clrfifo && f_fifo_fill > 0) begin if (f_first_in_fifo && f_first_addr == f_last_written) assert(f_first_return_",
            "reg == cpu_last_",
            "reg ); if (f_next_in_fifo && f_next_addr == f_last_written) assert(f_next_return_",
            "reg == cpu_last_",
            "reg ); if (rdaddr == f_last_written && (rdaddr != f_first_addr) && (rdaddr != f_next_addr)) `BMC_ASSERT(fifo_return_",
            "reg == cpu_last_",
            "reg ); end // }}} // Verifying the cpu_addr_",
            "reg // {{{",
            "always @(posedge S_AXI_ACLK) if (i_stb) f_ar_a",
            "reg <= f_a",
            "reg ;",
            "always @(*) if (o_rdbusy) `ASSERT(f_ar_a",
            "reg == cpu_addr_",
            "reg );",
            "always @(*) if (!f_clrfifo && o_rdbusy && f_fifo_fill > 0) begin if (f_first_in_fifo && f_first_addr != f_last_written) assert(f_first_return_",
            "reg != cpu_addr_",
            "reg || f_first_misaligned); if (f_next_in_fifo && f_next_addr != f_last_written) assert(f_next_return_",
            "reg != cpu_addr_",
            "reg || f_next_misaligned); // If the base address",
            "reg ister exists in the FIFO, then it // can't be part of any current requests. if ((f_first_in_fifo && (f_first_return_",
            "reg == cpu_addr_",
            "reg ) && !f_first_misaligned) ||(f_next_in_fifo && (f_next_return_",
            "reg == cpu_addr_",
            "reg ) && !f_next_misaligned)) assert(!M_AXI_WVALID && !M_AXI_ARVALID); if ((rdaddr != f_last_written || M_AXI_WVALID || M_AXI_ARVALID) && !misaligned_response_pending && (cpu_outstanding > (o_valid ? 1:0)) && (rdaddr != f_first_addr) && (rdaddr != f_next_addr)) `BMC_ASSERT(fifo_return_",
            "reg != cpu_addr_",
            "reg ); end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Contract properties // {{{ //////////////////////////////////////////////////////////////////////// // // initial f_done = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || r_flushing) f_done <= 1'b0; else f_done <= (M_AXI_RVALID && !M_AXI_RRESP[1] || M_AXI_BVALID && !M_AXI_BRESP[1]) && !pending_err && !misaligned_response_pending; fmem #( // {{{ .F_LGDEPTH(LGPIPE+1), .OPT_MAXDEPTH(1<<LGPIPE) // }}} ) fcheck( // {{{ .i_clk(S_AXI_ACLK), .i_sys_reset(!S_AXI_ARESETN), .i_cpu_reset(i_cpu_reset), .i_stb(i_stb), .i_pipe_stalled(o_pipe_stalled), .i_clear_cache(1'b0), .i_lock(i_lock), .i_op(i_op), .i_addr(i_addr), .i_data(i_data), .i_o",
            "reg (i_o",
            "reg ), .i_busy(o_busy), .i_a",
            "reg (f_a",
            "reg ), .i_rdbusy(o_rdbusy), .i_valid(o_valid), .i_done(f_done), .i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_result), .f_outstanding(cpu_outstanding), .f_pc(cpu_pc), .f_gie(cpu_gie), .f_read_cycle(cpu_read_cycle), .f_last_",
            "reg (cpu_last_",
            "reg ), .f_addr_",
            "reg (cpu_addr_",
            "reg ) // }}} );",
            "always @(*) if (flush_request) begin `ASSERT(cpu_outstanding == 0 || o_err); end else if (r_flushing) begin `ASSERT(o_err || cpu_outstanding == 0); end else if (OPT_ALIGNMENT_ERR) begin if (!o_err) `ASSERT(cpu_outstanding == (beats_outstanding - flushcount) + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0) + ((o_valid || f_done) ? 1:0)); // else `ASSERT(cpu_outstanding == flushcount); end",
            "always @(*) if (o_err && beats_outstanding > 0) `ASSERT(r_flushing);",
            "always @(*) if (!o_err && cpu_outstanding > 0) begin if (faxil_rd_outstanding > 0 || M_AXI_ARVALID || o_rdbusy) begin assert(cpu_read_cycle); end else if (faxil_awr_outstanding > 0 || faxil_wr_outstanding > 0 || M_AXI_AWVALID || M_AXI_WVALID) assert(!cpu_read_cycle); end // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // reg [LGPIPE:0] cvr_writes, cvr_reads, cvr_valids;",
            "reg cvr_idle;",
            "always @(*) begin cvr_idle = 1; if (i_cpu_reset || o_err || f_done) cvr_idle = 1'b0; if (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) cvr_idle = 1'b0; if (faxil_awr_outstanding > 0) cvr_idle = 1'b0; if (faxil_wr_outstanding > 0) cvr_idle = 1'b0; if (faxil_rd_outstanding > 0) cvr_idle = 1'b0; end",
            "initial cvr_writes = 0;",
            "always @(posedge i_clk) if (i_cpu_reset || o_err) cvr_writes <= 0; else if (M_AXI_BVALID&& !misaligned_response_pending && !(&cvr_writes)) cvr_writes <= cvr_writes + 1;",
            "initial cvr_reads = 0;",
            "always @(posedge i_clk) if (i_cpu_reset || o_err) cvr_reads <= 0; else if (M_AXI_RVALID && !misaligned_response_pending && !(&cvr_reads)) cvr_reads <= cvr_reads + 1;",
            "initial cvr_valids = 0;",
            "always @(posedge i_clk) if (i_cpu_reset || o_err) cvr_valids <= 0; else if (o_valid) cvr_valids <= cvr_valids + 1; // Cover a write response",
            "always @(posedge i_clk) cover(M_AXI_BVALID && !M_AXI_BRESP[1]);",
            "always @(posedge i_clk) cover(M_AXI_BVALID && M_AXI_BRESP[1]);",
            "always @(posedge i_clk) cover(M_AXI_RVALID && !M_AXI_RRESP[1]);",
            "always @(posedge i_clk) cover(M_AXI_RVALID && M_AXI_RRESP[1]);",
            "always @(posedge i_clk) if (cvr_idle) begin cover(cvr_writes > 3); cover(cvr_reads > 3); cover(cvr_valids > 3); cover(cvr_writes > (1<<LGPIPE)); cover(cvr_reads > (1<<LGPIPE)); cover(cvr_valids > (1<<LGPIPE)); cover(cvr_writes > (1<<LGPIPE)+2); cover(cvr_reads > (1<<LGPIPE)+2); cover(cvr_valids > (1<<LGPIPE)+2); end generate if (!OPT_ALIGNMENT_ERR) begin",
            "reg [LGPIPE:0] cvr_unaligned_writes, cvr_unaligned_reads;",
            "initial cvr_writes = 0;",
            "always @(posedge i_clk) if (i_cpu_reset || o_err) cvr_unaligned_writes <= 0; else if (i_stb && i_op[0] && w_misaligned) cvr_unaligned_writes <= cvr_unaligned_writes + 1;",
            "initial cvr_reads = 0;",
            "always @(posedge i_clk) if (i_cpu_reset || o_err) cvr_unaligned_reads <= 0; else if (i_stb && !i_op[0] && w_misaligned) cvr_unaligned_reads <= cvr_unaligned_reads + 1;",
            "always @(posedge i_clk) if (cvr_idle) begin cover(cvr_unaligned_writes > 3); cover(cvr_unaligned_reads > 3); cover(cvr_unaligned_writes > (1<<LGPIPE)); cover(cvr_unaligned_reads > (1<<LGPIPE)); end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Careless assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (!OPT_ALIGNMENT_ERR) begin if (!r_flushing && !o_err) `BMC_ASSERT(cpu_outstanding <= beats_outstanding + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0) + ((o_valid || f_done) ? 1:0)); if (!r_flushing && cpu_read_cycle) `BMC_ASSERT(cpu_outstanding >= (f_done ? 1:0) + faxil_rd_outstanding[F_LGDEPTH-1:1]); else if (!r_flushing) `BMC_ASSERT(cpu_outstanding >= (f_done ? 1:0) + faxil_wr_outstanding[F_LGDEPTH-1:1]); if (!r_flushing && !o_err) assert(f_fifo_fill == beats_outstanding + ((misaligned_aw_request && !misaligned_request) ? 1:0) + (M_AXI_AWVALID && !M_AXI_WVALID)); if (!r_flushing && !o_err) `BMC_ASSERT((cpu_outstanding == 0) == (!M_AXI_AWVALID && !M_AXI_WVALID && !M_AXI_ARVALID && (beats_outstanding + (f_done ? 1:0) == 0))); else if (o_err) `BMC_ASSERT(cpu_outstanding > 0); if (!r_flushing && !o_err && cpu_outstanding == (f_done ? 1:0)) `BMC_ASSERT(beats_outstanding == 0 && !M_AXI_AWVALID && !M_AXI_WVALID && !M_AXI_ARVALID); end // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "axidcache.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axidcache.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: axidcache.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A data cache built using AXI as the underlying protocol // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2020-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module axidcache #( // {{{ // AXI Setup: address width, data width, ID width, and ID // {{{",
            "parameter C_AXI_ADDR_WIDTH = 32, parameter C_AXI_DATA_WIDTH = 64, parameter C_AXI_ID_WIDTH = 1, parameter [C_AXI_ID_WIDTH-1:0] AXI_ID = 0, // }}} // LGCACHELEN // {{{ // The log (base 2) of the cache size in bytes.",
            "parameter LGCACHELEN = 8 + $clog2(C_AXI_DATA_WIDTH/8), localparam LGCACHEWORDS= LGCACHELEN-$clog2(C_AXI_DATA_WIDTH/8), // }}} // LGNLINES // {{{ // The log (base 2) of the number of cache lines. A cache line // is the minimum amount of data read on a miss. Each cache // line has a valid signal and a tag associated with it.",
            "parameter LGNLINES = (LGCACHEWORDS-3), // }}}",
            "parameter [0:0] SWAP_WSTRB = 1'b0, // OPT_SIGN_EXTEND: When returning values to the CPU that are // {{{ // less than word sized in length, if OPT_SIGN_EXTEND is true // these values will be sign extended.",
            "parameter [0:0] OPT_SIGN_EXTEND = 1'b0, // }}}",
            "parameter NAUX = 5, // OPT_PIPE: Set to 1 to allow multiple outstanding transactions // {{{ // This is primarily used by write requests. Read requests // will only ever read one cache line at a time. Non-cache // reads are only ever done (at present) as singletons.",
            "parameter [0:0] OPT_PIPE = 1'b0, // }}} // OPT_WRAP: True if using AXI WRAP mode. With AXI WRAP mode, // {{{ // a cache read result will return its value before the entire // cache line read has been completed",
            "parameter [0:0] OPT_WRAP = 1'b0, // }}} // OPT_LOWPOWER: If true, sets unused AXI values to all zeros, // {{{ // or, in the case of AxSIZE, to 3'd2. This is to keep things // from toggling if they don't need to.",
            "parameter [0:0] OPT_LOWPOWER = 1'b0, // }}} // OPT_LOCK: Set to 1 in order to support exclusive access. // {{{",
            "parameter [0:0] OPT_LOCK = 1'b0, // }}} // Local",
            "parameter s, mostly abbreviations // {{{ // Verilator lint_off UNUSED",
            "localparam LGPIPE = (OPT_PIPE) ? 4:2, // Verilator lint_on UNUSED",
            "localparam [0:0] OPT_DUAL_READ_PORT = 1'b1, localparam [1:0] DC_IDLE = 2'b00, DC_WRITE = 2'b01, DC_READS = 2'b10, DC_READC = 2'b11, localparam AW = C_AXI_ADDR_WIDTH, localparam DW = C_AXI_DATA_WIDTH, localparam IW = C_AXI_ID_WIDTH, localparam AXILSB = $clog2(C_AXI_DATA_WIDTH/8), localparam CS = LGCACHELEN - AXILSB, // Cache size, in wrds",
            "localparam LS = CS-LGNLINES, // Cache lines, lg_2",
            "localparam TW = AW-(CS+AXILSB) // Tag width // }}} // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, S_AXI_ARESETN, input wire i_cpu_reset, i_clear, // Interface from the CPU // {{{",
            "input wire i_pipe_stb, i_lock, input wire [2:0] i_op, input wire [AW-1:0] i_addr, input wire [AW-1:0] i_restart_pc, input wire [31:0] i_data, input wire [NAUX-1:0] i_o",
            "reg , // Outputs, going back to the CPU",
            "output reg o_busy, o_rdbusy, output wire o_pipe_stalled, output reg o_valid, o_err, output reg [NAUX-1:0] o_w",
            "reg , output reg [31:0] o_data, // }}} // AXI bus interface // {{{ // Write address // {{{",
            "output wire M_AXI_AWVALID, input wire M_AXI_AWREADY, // verilator coverage_off",
            "output wire [IW-1:0] M_AXI_AWID, // = constant // verilator coverage_on",
            "output wire [AW-1:0] M_AXI_AWADDR, // verilator coverage_off",
            "output wire [7:0] M_AXI_AWLEN, // = const 0 // verilator coverage_on",
            "output wire [2:0] M_AXI_AWSIZE, output wire [1:0] M_AXI_AWBURST, output wire M_AXI_AWLOCK, output wire [3:0] M_AXI_AWCACHE, // verilator coverage_off",
            "output wire [2:0] M_AXI_AWPROT, output wire [3:0] M_AXI_AWQOS, // verilator coverage_on // }}} // Write data // {{{",
            "output wire M_AXI_WVALID, input wire M_AXI_WREADY, output wire [DW-1:0] M_AXI_WDATA, output wire [DW/8-1:0] M_AXI_WSTRB, output wire M_AXI_WLAST, // }}} // Write return // {{{",
            "input wire M_AXI_BVALID, output wire M_AXI_BREADY, // verilator coverage_off",
            "input wire [IW-1:0] M_AXI_BID, // verilator coverage_on",
            "input wire [1:0] M_AXI_BRESP, // }}} // Read address // {{{",
            "output wire M_AXI_ARVALID, input wire M_AXI_ARREADY, // verilator coverage_off",
            "output wire [IW-1:0] M_AXI_ARID, // verilator coverage_on",
            "output wire [AW-1:0] M_AXI_ARADDR, output wire [7:0] M_AXI_ARLEN, output wire [2:0] M_AXI_ARSIZE, output wire [1:0] M_AXI_ARBURST, output wire M_AXI_ARLOCK, output wire [3:0] M_AXI_ARCACHE, // verilator coverage_off",
            "output wire [2:0] M_AXI_ARPROT, output wire [3:0] M_AXI_ARQOS, // verilator coverage_on // }}} // Read data returned // {{{",
            "input wire M_AXI_RVALID, output wire M_AXI_RREADY, // verilator coverage_off",
            "input wire [IW-1:0] M_AXI_RID, // verilator coverage_on",
            "input wire [DW-1:0] M_AXI_RDATA, input wire M_AXI_RLAST, input wire [1:0] M_AXI_RRESP // }}} // }}} // }}} ); // Declarations // {{{",
            "localparam [1:0] INCR = 2'b01, WRAP = 2'b10;",
            "localparam [1:0] OKAY = 2'b00, EXOKAY = 2'b01; // Verilator lint_off UNUSED",
            "localparam DSZ = 2; // Verilator lint_on UNUSED // The cache itself // {{{",
            "reg [(1<<(CS-LS))-1:0] cache_valid;",
            "reg [TW-1:0] cache_tag [0:(1<<LGNLINES)-1];",
            "reg [DW-1:0] cache_mem [0:(1<<CS)-1];",
            "reg [DW-1:0] cached_iword, cached_rword; // }}}",
            "reg misaligned;",
            "wire cache_miss_inow, address_is_cachable;",
            "wire cachable_request, cachable_read_request;",
            "wire i_read, i_write;",
            "reg [AW-AXILSB-1:0] r_addr;",
            "wire [CS-LS-1:0] i_cline, r_cline;",
            "wire [CS-1:0] i_caddr, r_caddr;",
            "reg [TW-1:0] last_tag, r_itag, r_rtag, w_tag;",
            "reg [CS-LS-1:0] last_tag_line;",
            "wire [TW-1:0] r_ctag, i_ctag, axi_tag;",
            "wire [CS-LS-1:0] axi_line;",
            "reg r_iv, r_rv, r_check, w_v, set_vflag;",
            "reg zero_noutstanding, last_ack, full_pipe, nearly_full_pipe;",
            "wire w_pipe_stalled;",
            "reg [LGPIPE-1:0] noutstanding;",
            "reg [CS-1:0] wcache_addr;",
            "reg [DW-1:0] wcache_data;",
            "reg [DW/8-1:0] wcache_strb;",
            "reg [TW-1:0] wcache_tag; integer ik;",
            "reg good_cache_read;",
            "reg [1:0] state;",
            "reg r_dvalid, r_svalid, r_cachable, r_cache_miss, flushing, r_rd_pending, last_tag_valid, w_cache_miss;",
            "reg [DW-1:0] pre_data, shifted_data;",
            "reg [AXILSB+1:0] req_data;",
            "wire [AXILSB-1:0] req_lsb;",
            "wire [1:0] req_op;",
            "reg [1:0] suppress_miss;",
            "reg [CS-1:0] read_addr;",
            "assign i_write = i_op[0];",
            "assign i_read = !i_op[0]; // AXI",
            "reg isters // {{{",
            "reg axi_awvalid, axi_wvalid;",
            "reg [AW-1:0] axi_awaddr;",
            "reg [2:0] axi_awsize;",
            "reg [DW-1:0] axi_wdata;",
            "reg [DW/8-1:0] axi_wstrb;",
            "wire [DW-1:0] axi_rdata;",
            "wire axi_awlock;",
            "reg axi_arvalid;",
            "reg [AW-1:0] axi_araddr;",
            "reg [7:0] axi_arlen;",
            "reg [2:0] axi_arsize;",
            "wire [1:0] axi_arburst;",
            "wire axi_arlock; // }}} // LOCK handling declarations // {{{",
            "wire [AW-1:0] restart_pc;",
            "wire locked_write_in_progress, locked_read_in_progress, locked_read_in_cache; // }}} // }}} // Fixed AXI",
            "output s that aren't changing // {{{",
            "assign M_AXI_AWID = AXI_ID;",
            "assign M_AXI_ARID = AXI_ID;",
            "assign M_AXI_AWLEN = 0; // All writes are one beat only",
            "assign M_AXI_AWBURST = INCR; // INCR addressing only",
            "assign M_AXI_ARBURST = axi_arburst;",
            "assign M_AXI_AWLOCK = OPT_LOCK && axi_awlock;",
            "assign M_AXI_ARLOCK = OPT_LOCK && axi_arlock;",
            "assign M_AXI_AWCACHE = M_AXI_AWLOCK ? 0 : 4'b011;",
            "assign M_AXI_ARCACHE = M_AXI_ARLOCK ? 0 : 4'b011;",
            "assign M_AXI_AWPROT = 3'b0; // == 3'b001 if GIE is clear, 3'b000 if",
            "assign M_AXI_ARPROT = 3'b0; // not",
            "assign M_AXI_AWQOS = 0;",
            "assign M_AXI_ARQOS = 0;",
            "assign M_AXI_WLAST = 1;",
            "assign M_AXI_BREADY = 1;",
            "assign M_AXI_RREADY = 1; // }}} // Misalignment detection // {{{",
            "always @(*) begin misaligned = checklsb(i_op[2:1], i_addr[1:0]); end function checklsb;",
            "input [1:0] op;",
            "input [1:0] addr; casez(op[1:0]) 2'b0?: checklsb = (addr[1:0] != 2'b00); // 32'bit words 2'b10: checklsb = addr[0]; // 16-bit words 2'b11: checklsb = 1'b0; // Bytes are never misaligned endcase endfunction // }}} // Address decoding // {{{",
            "assign i_cline = i_addr[LS+AXILSB +: (CS-LS)]; // Cache line",
            "assign i_caddr = i_addr[AXILSB +: CS]; // Cache address",
            "assign i_ctag = i_addr[AW-1:CS+AXILSB]; // Associated tag // Unlike i_addr, r_addr doesn't include the AXI LSB's",
            "assign r_cline = r_addr[CS-1:LS]; // Cache line",
            "assign r_caddr = r_addr[CS-1:0]; // Cache address",
            "assign r_ctag = r_addr[AW-AXILSB-1 : CS]; // Associated tag",
            "assign cache_miss_inow = (!last_tag_valid || last_tag != i_ctag || last_tag_line != i_cline); // }}} // Cache lookup // {{{",
            "always @(posedge S_AXI_ACLK) r_check <= i_pipe_stb;",
            "always @(posedge S_AXI_ACLK) if (i_pipe_stb) r_itag <= cache_tag[i_cline];",
            "always @(posedge S_AXI_ACLK) if (o_pipe_stalled) r_rtag <= cache_tag[r_cline];",
            "always @(posedge S_AXI_ACLK) if (i_pipe_stb) r_iv <= cache_valid[i_cline];",
            "always @(posedge S_AXI_ACLK) r_rv <= cache_valid[r_cline] && r_rd_pending;",
            "always @(*) w_v = (r_check) ? r_iv : r_rv;",
            "always @(*) w_tag = (r_check) ? r_itag : r_rtag; // Cachability checking // {{{ // Note that the correct address width must be built-in to the // iscachable routine. It is *not*",
            "parameter izable. iscachable must // be rewritten if the address width changes because, of necessity, that // also means the address map is changing and therefore what is and // isn't cachable. etc. iscachable chkaddress( i_addr[AW-1:0], address_is_cachable ); // }}} // Locked requests are *not* cachable, but *must* go to the bus",
            "assign cachable_request = address_is_cachable&& (!OPT_LOCK || !i_lock);",
            "assign cachable_read_request = i_pipe_stb && i_read && cachable_request;",
            "initial r_rd_pending = 0;",
            "initial r_cache_miss = 0;",
            "initial last_tag_valid = 0;",
            "initial r_dvalid = 0;",
            "always @(posedge S_AXI_ACLK) begin r_svalid <= cachable_read_request && !misaligned && !cache_miss_inow && (wcache_strb == 0); if (!o_pipe_stalled) r_addr <= i_addr[AW-1:AXILSB]; if (!o_pipe_stalled && !r_rd_pending) begin r_cachable <= cachable_read_request; r_rd_pending <= cachable_read_request && !misaligned && (cache_miss_inow || (|wcache_strb)); end else if (r_rd_pending) begin r_rd_pending <= (w_tag != r_ctag || !w_v); if (OPT_WRAP && M_AXI_RVALID) r_rd_pending <= 0; end if (M_AXI_RVALID && M_AXI_RRESP[1]) r_rd_pending <= 1'b0; // r_rd <= (i_pipe_stb && !i_read); r_dvalid <= !r_svalid && !r_dvalid && (w_tag == r_ctag) && w_v && r_cachable && r_rd_pending; if (w_tag == r_ctag && w_v && r_cachable && r_rd_pending) begin last_tag_valid <= 1'b1; last_tag_line <= r_cline; last_tag <= r_ctag; end else if (state == DC_READC) // && (last_tag == r_ctag) // && (M_AXI_RVALID)) last_tag_valid <= 1'b0; r_cache_miss <= (r_cachable && !r_svalid && (r_rd_pending && !r_svalid) && (w_tag != r_ctag || !w_v)); if (i_clear) last_tag_valid <= 0; if (OPT_PIPE && M_AXI_BVALID && M_AXI_BRESP[1]) last_tag_valid <= 0; if (!S_AXI_ARESETN || i_cpu_reset) begin r_cachable <= 1'b0; r_svalid <= 1'b0; r_dvalid <= 1'b0; r_cache_miss <= 1'b0; r_rd_pending <= 0; last_tag_valid <= 0; end end // }}} // Transaction counting // {{{",
            "initial noutstanding = 0;",
            "initial zero_noutstanding = 1;",
            "initial nearly_full_pipe = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin noutstanding <= 0; zero_noutstanding <= 1; nearly_full_pipe <= 0; end else case( { ((M_AXI_AWVALID && M_AXI_AWREADY) ||(M_AXI_ARVALID && M_AXI_ARREADY)), ((M_AXI_RVALID && M_AXI_RLAST) || M_AXI_BVALID) }) 2'b10: begin noutstanding <= noutstanding + 1; zero_noutstanding <= 1'b0; nearly_full_pipe <= (noutstanding >= (1<<LGPIPE)-3); end 2'b01: begin noutstanding <= noutstanding - 1; zero_noutstanding <= (noutstanding == 1); nearly_full_pipe <= (&noutstanding); end default: begin end endcase `ifdef FORMAL",
            "always @(*) begin assert(zero_noutstanding == (noutstanding == 0)); assert(nearly_full_pipe == (noutstanding >= (1<<LGPIPE)-2)); end `endif",
            "always @(*) begin full_pipe = 1'b0; if (nearly_full_pipe) full_pipe = noutstanding[0] || (M_AXI_AWVALID || M_AXI_WVALID); end",
            "always @(*) last_ack = (noutstanding <= 1)&&(!M_AXI_ARVALID && !M_AXI_AWVALID);",
            "initial flushing = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) flushing <= 0; else if (flushing) begin // Can we clear flushing? if (zero_noutstanding) flushing <= 1'b0; if (last_ack && (M_AXI_BVALID || (M_AXI_RVALID && M_AXI_RLAST))) flushing <= 1'b0; if (M_AXI_AWVALID || M_AXI_ARVALID || M_AXI_WVALID) flushing <= 1'b1; end else if (i_cpu_reset || (M_AXI_RVALID && M_AXI_RRESP[1]) || (M_AXI_BVALID && M_AXI_BRESP[1]) || (OPT_PIPE && i_pipe_stb && misaligned)) begin // Flushing causes flushing <= 1'b0; if (M_AXI_ARVALID || M_AXI_AWVALID || M_AXI_WVALID) flushing <= 1'b1; if (!last_ack) flushing <= 1'b1; if ((noutstanding >= 1) && !M_AXI_BVALID && (!M_AXI_RVALID || !M_AXI_RLAST)) flushing <= 1'b1; end // }}} // Read handling // {{{ // Read state machine // {{{",
            "initial state = DC_IDLE;",
            "initial set_vflag = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin // {{{ cache_valid <= 0; // end_of_line <= 1'b0; // last_line_stb <= 1'b0; state <= DC_IDLE; set_vflag <= 1'b0; // }}} end else begin // {{{ set_vflag <= 1'b0; if (set_vflag) cache_valid[r_cline] <= 1'b1; case(state) DC_IDLE: begin // {{{ good_cache_read <= 1'b1; if (i_pipe_stb && i_write && !misaligned) state <= DC_WRITE; else if (w_cache_miss) state <= DC_READC; else if (i_pipe_stb && i_read && !cachable_request && !misaligned) state <= DC_READS; if (i_cpu_reset) state <= DC_IDLE; end // }}} DC_READC: begin // Read cache line // {{{ if (M_AXI_RVALID) begin good_cache_read <= good_cache_read && !M_AXI_RRESP[1]; cache_valid[r_cline] <= 1'b0; end if (M_AXI_RVALID && M_AXI_RLAST) begin state <= DC_IDLE; set_vflag <= !i_cpu_reset && !i_clear && !flushing && !M_AXI_RRESP[1] && good_cache_read; end end // }}} DC_READS: begin // Read single value // {{{ if (M_AXI_RVALID && last_ack) state <= DC_IDLE; end // }}} DC_WRITE: begin // {{{ if (M_AXI_BVALID && M_AXI_BREADY && (!OPT_PIPE || (last_ack && !i_pipe_stb))) state <= DC_IDLE; end // }}} endcase if (i_clear || i_cpu_reset) cache_valid <= 0; if (OPT_PIPE && M_AXI_BVALID && M_AXI_BRESP[1]) cache_valid <= 0; // }}} end // }}} // axi_axlock // {{{ generate if (OPT_LOCK) begin : GEN_AXLOCK",
            "reg r_arlock, r_awlock;",
            "reg [2:0] r_read_in_cache;",
            "initial r_arlock = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_arlock <= 1'b0; else if (i_pipe_stb) begin r_arlock <= i_lock; if (misaligned || i_write) r_arlock <= 1'b0; end else if (M_AXI_RVALID) r_arlock <= 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || r_rd_pending || M_AXI_RVALID) r_read_in_cache <= 3'b00; else if (i_pipe_stb) begin r_read_in_cache <= 3'b00; r_read_in_cache[0] <= address_is_cachable && i_read && i_lock; end else if (r_read_in_cache != 0) begin r_read_in_cache[2:1] <= { r_read_in_cache[1:0] }; if (r_read_in_cache[1] && ((w_tag != r_ctag) || !w_v)) r_read_in_cache <= 0; // && (w_tag == r_ctag) && w_v end",
            "initial r_awlock = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_awlock <= 1'b0; else if (i_pipe_stb) begin r_awlock <= i_lock; if (misaligned || i_read) r_awlock <= 1'b0; end else if (M_AXI_BVALID) r_awlock <= 1'b0;",
            "assign locked_write_in_progress = r_awlock;",
            "assign locked_read_in_progress = r_arlock;",
            "assign locked_read_in_cache = r_read_in_cache[2];",
            "assign axi_awlock = r_awlock;",
            "assign axi_arlock = r_arlock; end else begin : NO_LOCK",
            "assign axi_awlock = 1'b0;",
            "assign axi_arlock = 1'b0;",
            "assign locked_write_in_progress = 1'b0;",
            "assign locked_read_in_progress = 1'b0;",
            "assign locked_read_in_cache = 1'b0; end endgenerate // }}} // M_AXI_ARVALID, axi_arvalid // {{{",
            "always @(posedge S_AXI_ACLK) suppress_miss <= { suppress_miss[0] || set_vflag, set_vflag };",
            "always @(*) w_cache_miss = r_cache_miss && state == DC_IDLE && !r_dvalid && !o_err && wcache_strb == 0 && !suppress_miss[1];",
            "initial axi_arvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_arvalid <= 0; else if (!M_AXI_ARVALID || M_AXI_ARREADY) begin axi_arvalid <= 1'b0; if (i_pipe_stb && i_read && !misaligned && ((OPT_LOCK && i_lock) || !address_is_cachable)) axi_arvalid <= 1; if (w_cache_miss) axi_arvalid <= 1; if (i_cpu_reset) axi_arvalid <= 0; end",
            "assign M_AXI_ARVALID = axi_arvalid; // }}} // M_AXI_ARADDR, M_AXI_ARSIZE, M_AXI_ARLEN // {{{",
            "initial axi_araddr = 0;",
            "initial axi_arsize = 3'd2;",
            "initial axi_arlen = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) begin // {{{ axi_araddr <= 0; axi_arsize <= 3'd2; axi_arlen <= 0; // }}} end else if (!M_AXI_ARVALID || M_AXI_ARREADY) begin axi_arlen <= 0; if (r_cache_miss) begin // {{{ if (OPT_WRAP) axi_araddr <= { r_ctag, r_caddr[CS-1:0], {(AXILSB){1'b0}} }; else axi_araddr <= { r_ctag, r_cline, {(LS+AXILSB){1'b0}} }; axi_arlen <= (1 << LS) - 1; axi_arsize <= AXILSB[2:0]; // }}} end else begin // {{{ axi_araddr <= i_addr; axi_arlen <= 0; casez(i_op[2:1]) 2'b0?: axi_arsize <= 3'd2; 2'b10: axi_arsize <= 3'd1; 2'b11: axi_arsize <= 3'd0; // default: axi_arsize <= 3'd2; (Messes w/ coverage) endcase if (SWAP_WSTRB) begin // axi_araddr[AXILSB-1:0] <= ~i_addr[AXILSB-1:0]; axi_araddr[1:0] <= 0; axi_arsize <= 3'b010; end // }}} end if (OPT_LOWPOWER && (i_cpu_reset || (!w_cache_miss && (!i_pipe_stb || i_op[0] || misaligned || (address_is_cachable && !i_lock))))) begin // {{{ axi_araddr <= 0; axi_arlen <= 0; axi_arsize <= 3'd2; // }}} end end",
            "assign axi_tag = axi_araddr[AW-1:AW-TW];",
            "assign axi_line = axi_araddr[AXILSB+LS +: CS-LS];",
            "assign M_AXI_ARADDR = axi_araddr;",
            "assign M_AXI_ARLEN = axi_arlen;",
            "assign M_AXI_ARSIZE = axi_arsize; // }}} // M_AXI_ARBURST // {{{ generate if (OPT_WRAP) begin : GEN_ARBURST",
            "reg r_wrap;",
            "initial r_wrap = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) begin // {{{ r_wrap <= 1'b0; // }}} end else if (!M_AXI_ARVALID || M_AXI_ARREADY) begin // {{{ r_wrap <= 1'b0; if (r_cache_miss) r_wrap <= 1'b1; // }}} end",
            "assign axi_arburst = r_wrap ? WRAP : INCR; end else begin : NO_WRAPBURST",
            "assign axi_arburst = INCR; end endgenerate // }}} // }}} // Writes",
            "always go straight to the bus // {{{ // M_AXI_AWVALID, axi_awvalid // {{{",
            "initial axi_awvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_awvalid <= 1'b0; else if (!M_AXI_AWVALID || M_AXI_AWREADY) begin axi_awvalid <= i_pipe_stb && i_op[0] && !misaligned; if (M_AXI_BVALID && M_AXI_BRESP[1]) axi_awvalid <= 1'b0; if (i_cpu_reset || flushing) axi_awvalid <= 1'b0; end",
            "assign M_AXI_AWVALID = axi_awvalid; // }}} // M_AXI_AWADDR // {{{",
            "initial axi_awaddr = 0;",
            "initial axi_awsize = 3'd2;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN && OPT_LOWPOWER) begin axi_awaddr <= 0; axi_awsize <= 3'd2; end else if (!M_AXI_AWVALID || M_AXI_AWREADY) begin axi_awaddr <= i_addr; casez(i_op[2:1]) 2'b0?: axi_awsize <= 3'd2; 2'b10: axi_awsize <= 3'd1; 2'b11: axi_awsize <= 3'd0; // default: axi_awsize <= 3'd2; (Unused, messes w/ covr) endcase if (SWAP_WSTRB) begin // axi_awaddr[AXILSB-1:0] <= ~i_addr[AXILSB-1:0]; axi_awaddr[1:0] <= 0; axi_awsize <= 3'd2; end if (OPT_LOWPOWER && (!i_pipe_stb || !i_op[0] || misaligned || i_cpu_reset || flushing || (M_AXI_BVALID && M_AXI_BRESP[1]))) begin axi_awaddr <= 0; axi_awsize <= 3'd2; end end",
            "assign M_AXI_AWADDR = axi_awaddr;",
            "assign M_AXI_AWSIZE = axi_awsize; // }}} // M_AXI_WVALID // {{{",
            "initial axi_wvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_wvalid <= 0; else if (!M_AXI_WVALID || M_AXI_WREADY) begin axi_wvalid <= i_pipe_stb && i_op[0] && !misaligned; if (M_AXI_BVALID && M_AXI_BRESP[1]) axi_wvalid <= 1'b0; if (i_cpu_reset || flushing) axi_wvalid <= 1'b0; end",
            "assign M_AXI_WVALID = axi_wvalid; // }}} // M_AXI_WDATA, M_AXI_WSTRB // {{{",
            "initial axi_wdata = 0;",
            "initial axi_wstrb = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN && OPT_LOWPOWER) begin axi_wdata <= 0; axi_wstrb <= 0; end else if (!M_AXI_WVALID || M_AXI_WREADY) begin // WDATA // {{{ if (SWAP_WSTRB) begin // {{{ casez(i_op[2:1]) // Write a 16b half-word 2'b10: axi_wdata <= { i_data[15:0], {(C_AXI_DATA_WIDTH-16){1'b0}} } >> (8*i_addr[AXILSB-1:0]); // Write an 8b half-word 2'b11: axi_wdata <= { i_data[7:0], {(C_AXI_DATA_WIDTH-8){1'b0}} } >> (8*i_addr[AXILSB-1:0]); default: axi_wdata <= { i_data, {(C_AXI_DATA_WIDTH-32){1'b0}} } >> (8*i_addr[AXILSB-1:0]); endcase // }}} end else begin // {{{ casez(i_op[2:1]) // Write a 16b half-word 2'b10: axi_wdata <= { {(C_AXI_DATA_WIDTH-16){1'b0}}, i_data[15:0] } << (8*i_addr[AXILSB-1:0]); // Write an 8b half-word 2'b11: axi_wdata <= { {(C_AXI_DATA_WIDTH-8){1'b0}}, i_data[7:0] } << (8*i_addr[AXILSB-1:0]); default: axi_wdata <= { {(C_AXI_DATA_WIDTH-32){1'b0}}, i_data } << (8*i_addr[AXILSB-1:0]); endcase // }}} end // }}} // WSTRB // {{{ if (SWAP_WSTRB) begin // {{{ casez(i_op[2:1]) // Write a 16b half-word 2'b10: axi_wstrb <= { 2'b11, {(C_AXI_DATA_WIDTH/8-2){1'b0}} } >> (i_addr[AXILSB-1:0]); // Write an 8b half-word 2'b11: axi_wstrb <= { 1'b1, {(C_AXI_DATA_WIDTH/8-1){1'b0}} } >> (i_addr[AXILSB-1:0]); default: axi_wstrb <= { 4'b1111, {(C_AXI_DATA_WIDTH/8-4){1'b0}} } >> (i_addr[AXILSB-1:0]); endcase // }}} end else begin // {{{ casez(i_op[2:1]) // Write a 16b half-word 2'b10: axi_wstrb <= { {(C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b0011 } << (i_addr[AXILSB-1:0]); // Write an 8b half-word 2'b11: axi_wstrb <= { {(C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b0001 } << (i_addr[AXILSB-1:0]); default: axi_wstrb <= { {(C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b1111 } << (i_addr[AXILSB-1:0]); endcase // }}} end // }}} // OPT_LOWPOWER: Clear if nothing is being used // {{{ if (OPT_LOWPOWER && ((!i_pipe_stb || !i_op[0] || misaligned) || (M_AXI_BVALID && M_AXI_BRESP[1]) || (i_cpu_reset || flushing))) begin axi_wdata <= 0; axi_wstrb <= 0; end // }}} end genvar gk; generate if (!SWAP_WSTRB) begin : NO_SWAP_WSTRB",
            "assign M_AXI_WDATA = axi_wdata;",
            "assign M_AXI_WSTRB = axi_wstrb;",
            "assign axi_rdata = M_AXI_RDATA; end else begin : J for(gk=0; gk<C_AXI_DATA_WIDTH/32; gk=gk+1) begin : GEN_SWAP_WSTRB",
            "assign M_AXI_WDATA[32*gk +: 32] = axi_wdata[C_AXI_DATA_WIDTH - (gk+1)*32 +: 32];",
            "assign M_AXI_WSTRB[ 4*gk +: 4] = axi_wstrb[C_AXI_DATA_WIDTH/8 - (gk+1)*4 +: 4];",
            "assign axi_rdata[32*gk +: 32] = M_AXI_RDATA[C_AXI_DATA_WIDTH - (gk+1)*32 +: 32]; end end endgenerate // }}} // }}} // Writes take a clock to go to the cache // {{{",
            "reg [AW-1:0] rev_addr;",
            "always @(*) begin rev_addr = i_addr; /* if (SWAP_WSTRB && C_AXI_DATA_WIDTH != 32) begin rev_addr[AXILSB-1:0] = ~i_addr[AXILSB-1:0]; rev_addr[1:0] = i_addr[1:0]; end */ end",
            "always @(posedge S_AXI_ACLK) begin wcache_strb <= 0; if (i_pipe_stb && (!OPT_LOWPOWER || i_read)) begin if (i_lock && OPT_LOCK) read_addr <= i_addr[LGCACHELEN-1:AXILSB]; else if (OPT_WRAP) read_addr <= i_addr[LGCACHELEN-1:AXILSB]; else read_addr <= { i_addr[LGCACHELEN-1:AXILSB+LS], {(LS){1'b0}} }; end if (state == DC_READC) begin // {{{ // Write returning read data to the cache if (M_AXI_RVALID) read_addr[LS-1:0] <= read_addr[LS-1:0] + 1; read_addr[CS-1:LS] <= r_cline; wcache_addr <= read_addr; wcache_data <= axi_rdata; wcache_strb <= -1; if (!M_AXI_RVALID || flushing || i_cpu_reset || M_AXI_RRESP[1]) wcache_strb <= 0; wcache_tag <= w_tag; // }}} end else begin // {{{ if (i_pipe_stb) { wcache_tag, wcache_addr } <= i_addr[AW-1:AXILSB]; else if (locked_read_in_progress) wcache_addr <= read_addr; else wcache_addr[LS-1:0] <= 0; // wcache_data // {{{ if (SWAP_WSTRB) begin casez(i_op[2:1]) // Write a 16b half-word 2'b10: wcache_data <= { i_data[15:0], {(DW-16){1'b0}} } >> (8*i_addr[AXILSB-1:0]); // Write an 8b half-word 2'b11: wcache_data <= { i_data[7:0], {(DW-8){1'b0}} } >> (8*i_addr[AXILSB-1:0]); default: wcache_data <= { i_data, {(DW-32){1'b0}} } >> (8*i_addr[AXILSB-1:0]); endcase end else begin casez(i_op[2:1]) // Write a 16b half-word 2'b10: wcache_data <= { {(DW-16){1'b0}}, i_data[15:0] } << (8*i_addr[AXILSB-1:0]); // Write an 8b half-word 2'b11: wcache_data <= { {(DW-8){1'b0}}, i_data[7:0] } << (8*i_addr[AXILSB-1:0]); default: wcache_data <= { {(DW-32){1'b0}}, i_data } << (8*i_addr[AXILSB-1:0]); endcase end if (locked_read_in_progress) wcache_data <= axi_rdata; // }}} // wcache_strb // {{{ if (SWAP_WSTRB) begin case(i_op[2:1]) // Write a 16b half-word 2'b10: wcache_strb<= { 2'h3, {(C_AXI_DATA_WIDTH/8-2){1'b0}} } >> (i_addr[AXILSB-1:0]); // Write an 8b byte 2'b11: wcache_strb<= { 1'b1, {(C_AXI_DATA_WIDTH/8-1){1'b0}} } >> (i_addr[AXILSB-1:0]); default: wcache_strb<= { 4'hf, {(C_AXI_DATA_WIDTH/8-4){1'b0}} } >> (i_addr[AXILSB-1:0]); endcase end else begin case(i_op[2:1]) // Write a 16b half-word 2'b10: wcache_strb<= { {(C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'h3 } << (i_addr[AXILSB-1:0]); // Write an 8b byte 2'b11: wcache_strb<= { {(C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'h1 } << (i_addr[AXILSB-1:0]); default: wcache_strb<= {{(C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'hf } << (i_addr[AXILSB-1:0]); endcase end // }}} if (locked_read_in_progress) begin if (!locked_read_in_cache || !M_AXI_RVALID || M_AXI_RRESP != EXOKAY) wcache_strb <= 0; end else if (!i_pipe_stb || !i_op[0] || misaligned) wcache_strb <= 0; // }}} end end // }}} // Actually write to the cache // {{{",
            "always @(posedge S_AXI_ACLK) if (state != DC_WRITE || (r_iv && wcache_tag == r_itag)) begin for(ik=0; ik<DW/8; ik=ik+1) if (wcache_strb[ik]) cache_mem[wcache_addr][8*ik +: 8] <= wcache_data[8*ik +: 8]; end // }}} // Update the cache tag // {{{",
            "always @(posedge S_AXI_ACLK) if (!flushing && M_AXI_RVALID && state == DC_READC) cache_tag[r_cline] <= r_ctag; // }}} // o_busy // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) o_busy <= 1'b0; else if (flushing || (i_pipe_stb && !misaligned)) o_busy <= 1'b1; else if (state == DC_READS && M_AXI_RVALID && last_ack) o_busy <= 1'b0; else if (OPT_WRAP // && state == DC_READC && M_AXI_RVALID && M_AXI_RLAST && state == DC_IDLE && !r_rd_pending) o_busy <= 1'b0; else if ((r_dvalid || r_svalid) && (!OPT_WRAP || state == DC_IDLE)) o_busy <= 1'b0; else if (M_AXI_BVALID && last_ack && (!OPT_PIPE || !i_pipe_stb)) o_busy <= 1'b0; // }}} // o_rdbusy // {{{",
            "initial o_rdbusy = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) o_rdbusy <= 1'b0; else if (i_cpu_reset) o_rdbusy <= 1'b0; else if (i_pipe_stb && (i_read || (i_lock && OPT_LOCK))&& !misaligned) o_rdbusy <= 1'b1; else if (state == DC_READS && M_AXI_RVALID) o_rdbusy <= 1'b0; else if (state == DC_READC && M_AXI_RVALID && (OPT_WRAP || M_AXI_RRESP[1])) o_rdbusy <= 1'b0; else if (locked_write_in_progress && M_AXI_BVALID) o_rdbusy <= 1'b0; else if (r_svalid || r_dvalid) o_rdbusy <= 1'b0; // }}} // o_pipe_stalled // {{{ generate if (OPT_PIPE) begin : GEN_PIPE_STALL",
            "reg r_pipe_stalled, pipe_stalled; (* keep *)",
            "reg [3:0] r_pipe_code; // else case( { ((M_AXI_AWVALID && M_AXI_AWREADY) // ||(M_AXI_ARVALID && M_AXI_ARREADY)), // ((M_AXI_RVALID && M_AXI_RLAST) || M_AXI_BVALID) // }) // 2'b10: noutstanding <= noutstanding + 1; // 2'b01: noutstanding <= noutstanding - 1;",
            "initial r_pipe_stalled = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin r_pipe_stalled <= 1'b0; r_pipe_code <= 4'h0; end else begin // Clear any stall on the last outstanding bus response if ((!OPT_WRAP && r_dvalid) // || (OPT_WRAP && state == DC_READC // && M_AXI_RVALID && M_AXI_RLAST) || (OPT_WRAP && state == DC_IDLE && !r_rd_pending)) begin r_pipe_stalled <= 1'b0; r_pipe_code <= 4'h1; end if (r_svalid) begin r_pipe_stalled <= 1'b0; r_pipe_code <= 4'h2; end if (last_ack && (M_AXI_BVALID ||(OPT_WRAP && state == DC_IDLE && !r_rd_pending) ||(state == DC_READS && M_AXI_RVALID && last_ack) ||(!OPT_WRAP && !r_rd_pending && M_AXI_RVALID && M_AXI_RLAST))) begin r_pipe_stalled <= 1'b0; r_pipe_code <= 4'h3; end // If we have to start flushing, then we have to stall // while flushing if (i_cpu_reset || (M_AXI_RVALID && M_AXI_RRESP[1]) || (M_AXI_BVALID && M_AXI_BRESP[1]) || (i_pipe_stb && misaligned)) begin // {{{ r_pipe_stalled <= 1'b0; r_pipe_code <= 4'ha; // Always stall if we have to start flushing if (M_AXI_ARVALID || M_AXI_AWVALID || M_AXI_WVALID) begin r_pipe_stalled <= 1'b1; r_pipe_code <= 4'h4; end if (!last_ack) begin r_pipe_stalled <= 1'b1; r_pipe_code <= 4'h5; end if ((noutstanding >= 1) && !M_AXI_BVALID && (!M_AXI_RVALID || !M_AXI_RLAST)) begin r_pipe_stalled <= 1'b1; r_pipe_code <= 4'h6; end // }}} end // All cachable read requests will stall our pipeline if (!i_cpu_reset && i_pipe_stb && i_read && !misaligned) begin r_pipe_stalled <= 1'b1; r_pipe_code <= 4'h7; end if (!i_cpu_reset && i_pipe_stb && i_lock && !misaligned) begin r_pipe_stalled <= 1'b1; r_pipe_code <= 4'h8; end if (flushing && (M_AXI_AWVALID || M_AXI_ARVALID || M_AXI_WVALID)) begin r_pipe_stalled <= 1'b1; r_pipe_code <= 4'h9; end end",
            "always @(*) if (r_pipe_stalled) pipe_stalled = 1'b1; else if (M_AXI_AWVALID && !M_AXI_AWREADY) pipe_stalled = 1'b1; else if (M_AXI_WVALID && !M_AXI_WREADY) pipe_stalled = 1'b1; else if (full_pipe) pipe_stalled = 1'b1; else pipe_stalled = 1'b0;",
            "assign w_pipe_stalled = r_pipe_stalled;",
            "assign o_pipe_stalled = pipe_stalled; // Verilator lint_off UNUSED",
            "wire unused_pipe;",
            "assign unused_pipe = &{ 1'b0, r_pipe_code }; // Verilator lint_on UNUSED `ifdef FORMAL",
            "always @(*) if (S_AXI_ARESETN && locked_write_in_progress) begin assert(r_pipe_stalled); end `endif end else begin : PIPE_STALL_ON_BUSY",
            "assign w_pipe_stalled = 1'b0;",
            "assign o_pipe_stalled = o_busy; // Verilator lint_off UNUSED",
            "wire unused_pipe;",
            "assign unused_pipe = &{ 1'b0, full_pipe }; // Verilator lint_on UNUSED end endgenerate // }}} // o_w",
            "reg // {{{ // generate if (!OPT_PIPE)",
            "always @(posedge S_AXI_ACLK) if (i_pipe_stb) begin o_w",
            "reg <= i_o",
            "reg ; if (OPT_LOCK && i_lock && i_op[0]) o_w",
            "reg <= { i_o",
            "reg [4], 4'hf }; end `ifdef FORMAL",
            "always @(*) if (S_AXI_ARESETN && locked_write_in_progress) assert(o_w",
            "reg [3:0] == 4'hf); `endif // }}} // restart_pc // {{{ generate if (OPT_LOCK) begin : GEN_RESTART_PC",
            "reg [AW-1:0] r_pc;",
            "always @(posedge S_AXI_ACLK) if (i_pipe_stb && i_lock && i_op[0]) r_pc <= i_restart_pc;",
            "assign restart_pc = r_pc; end else begin : NO_RESTART_PC",
            "assign restart_pc = 0; // Verilator lint_off UNUSED",
            "wire unused_restart_pc;",
            "assign unused_restart_pc = &{ 1'b0, i_restart_pc }; // Verilator lint_on UNUSED end endgenerate // }}} // req_data // {{{",
            "always @(posedge S_AXI_ACLK) if (i_pipe_stb) req_data <= { i_op[2:1], rev_addr[AXILSB-1:0] };",
            "assign req_lsb = req_data[AXILSB-1:0];",
            "assign req_op = req_data[AXILSB +: 2]; // }}} // o_err // {{{",
            "initial o_err = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) o_err <= 1'b0; else if (i_cpu_reset || flushing) o_err <= 1'b0; else begin o_err <= 1'b0; if (M_AXI_RVALID && M_AXI_RRESP[1] && o_rdbusy && !r_dvalid) o_err <= 1'b1; if (M_AXI_RVALID && locked_read_in_progress && M_AXI_RRESP != EXOKAY) o_err <= 1'b1; if (M_AXI_BVALID && M_AXI_BRESP[1]) o_err <= 1'b1; if (i_pipe_stb && misaligned) o_err <= 1'b1; end // }}} // Read from the cache // {{{ generate if (OPT_DUAL_READ_PORT) begin : GEN_DUALREAD",
            "always @(posedge S_AXI_ACLK) if (!OPT_LOWPOWER || (i_pipe_stb && !i_op[0])) cached_iword <= cache_mem[i_caddr];",
            "always @(posedge S_AXI_ACLK) if (!OPT_LOWPOWER || o_rdbusy) cached_rword <= cache_mem[r_caddr]; end else begin : GEN_SINGLE_READ_PORT",
            "always @(posedge S_AXI_ACLK) cached_rword <= cache_mem[(o_busy) ? r_caddr : i_caddr];",
            "always @(*) cached_iword = cached_rword; end endgenerate // }}} // o_data, pre_data // {{{",
            "always @(*) if (r_svalid) pre_data = cached_iword; else if (state == DC_READS || (OPT_WRAP && state == DC_READC)) pre_data = axi_rdata; else pre_data = cached_rword;",
            "always @(*) if (SWAP_WSTRB) begin shifted_data = pre_data << (8*req_lsb); casez(req_op) 2'b10: shifted_data[31:0] = { 16'h0, shifted_data[DW-1:DW-16] }; 2'b11: shifted_data[31:0] = { 24'h0, shifted_data[DW-1:DW- 8] }; default: shifted_data[31:0] = shifted_data[DW-1:DW-32]; endcase end else shifted_data = pre_data >> (8*req_lsb); // o_data",
            "always @(posedge S_AXI_ACLK) begin o_data <= shifted_data[31:0]; if (OPT_SIGN_EXTEND) begin // verilator coverage_off // Unused, would violate ZipCPU ISA casez(req_op) 2'b10: o_data[31:16] <= {(16){shifted_data[15]}}; 2'b11: o_data[31: 8] <= {(24){shifted_data[ 7]}}; default: begin end endcase // verilator coverage_on end else begin casez(req_op) 2'b10: o_data[31:16] <= 0; 2'b11: o_data[31: 8] <= 0; default: begin end endcase end if (locked_write_in_progress) begin o_data <= 0; o_data[AW-1:0] <= restart_pc; end end // }}} // o_valid // {{{",
            "initial o_valid = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset || flushing) o_valid <= 1'b0; else if (state == DC_READS) begin o_valid <= M_AXI_RVALID && !M_AXI_RRESP[1]; if (OPT_LOCK && locked_read_in_progress && M_AXI_RRESP != EXOKAY) o_valid <= 0; end else if (locked_write_in_progress && M_AXI_BVALID && M_AXI_BRESP == OKAY) o_valid <= 1'b1; else if (OPT_WRAP && r_rd_pending && state == DC_READC) o_valid <= M_AXI_RVALID && !M_AXI_RRESP[1]; else o_valid <= r_svalid || r_dvalid; // }}} // Make Verilator happy // {{{ // verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, M_AXI_BID, M_AXI_RID, r_addr, M_AXI_RRESP[0], M_AXI_BRESP[0], i_lock, shifted_data, w_pipe_stalled, axi_tag, axi_line, rev_addr[C_AXI_ADDR_WIDTH-1:AXILSB] }; // Verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Declarations // {{{",
            "localparam F_LGDEPTH = 10;",
            "wire [F_LGDEPTH-1:0] faxi_awr_nbursts, faxi_rd_nbursts, faxi_rd_outstanding;",
            "wire [8:0] faxi_wr_pending;",
            "wire [IW-1:0] faxi_wr_checkid;",
            "wire faxi_wr_ckvalid;",
            "wire [F_LGDEPTH-1:0] faxi_wrid_nbursts;",
            "wire [AW-1:0] faxi_wr_addr;",
            "wire [7:0] faxi_wr_incr;",
            "wire [1:0] faxi_wr_burst;",
            "wire [2:0] faxi_wr_size;",
            "wire [7:0] faxi_wr_len;",
            "wire faxi_wr_lockd; // wire faxi_rd_checkid;",
            "wire faxi_rd_ckvalid;",
            "wire [8:0] faxi_rd_cklen;",
            "wire [AW-1:0] faxi_rd_ckaddr;",
            "reg [AW-1:0] faxi_rd_lastaddr;",
            "wire [7:0] faxi_rd_ckincr;",
            "wire [1:0] faxi_rd_ckburst;",
            "wire [2:0] faxi_rd_cksize;",
            "wire [7:0] faxi_rd_ckarlen;",
            "wire faxi_rd_cklockd; // wire [F_LGDEPTH-1:0] faxi_rdid_nbursts;",
            "wire [F_LGDEPTH-1:0] faxi_rdid_outstanding;",
            "wire [F_LGDEPTH-1:0] faxi_rdid_ckign_nbursts;",
            "wire [F_LGDEPTH-1:0] faxi_rdid_ckign_outstanding; // Verilator lint_off UNDRIVEN // Verilator lint_off UNUSED",
            "wire [1:0] faxi_ex_state;",
            "wire faxi_ex_checklock;",
            "wire [F_LGDEPTH-1:0] faxi_rdid_bursts_to_lock;",
            "wire [F_LGDEPTH-1:0] faxi_wrid_bursts_to_exwrite;",
            "wire faxi_active_lock;",
            "wire [AW-1:0] faxi_exreq_addr;",
            "wire [7:0] faxi_exlock_len, faxi_exreq_len;",
            "wire [1:0] faxi_exlock_burst, faxi_exreq_burst;",
            "wire [2:0] faxi_exreq_size;",
            "reg [AW-1:0] faxi_exlock_addr;",
            "reg [2:0] faxi_exlock_size;",
            "wire faxi_exreq_return; // Verilator lint_on UNUSED // Verilator lint_on UNDRIVEN",
            "wire [LGPIPE:0] cpu_outstanding;",
            "wire cpu_pc;",
            "wire cpu_gie;",
            "wire cpu_read_cycle, cpu_lockd_write_cycle;",
            "wire [4:0] cpu_last_",
            "reg ;",
            "wire [4:0] cpu_addr_",
            "reg ;",
            "reg f_done;",
            "reg f_was_locked_write; // Verilator lint_off UNDRIVEN (* anyseq *)",
            "reg [4:0] f_a",
            "reg ; // Verilator lint_on UNDRIVEN",
            "wire [1:0] req_size;",
            "assign req_size = req_data[AXILSB +: 2]; // }}} //////////////////////////////////////////////////////////////////////// // // AXI properties // {{{ //////////////////////////////////////////////////////////////////////// // // faxi_master #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_ADDR_WIDTH(AW), .C_AXI_DATA_WIDTH(DW), .OPT_EXCLUSIVE(OPT_LOCK), .F_LGDEPTH(F_LGDEPTH) // }}} ) faxi ( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // AW* // {{{ .i_axi_awvalid(M_AXI_AWVALID), .i_axi_awready(M_AXI_AWREADY), .i_axi_awid(M_AXI_AWID), .i_axi_awaddr(M_AXI_AWADDR), .i_axi_awlen(M_AXI_AWLEN), .i_axi_awsize(M_AXI_AWSIZE), .i_axi_awburst(M_AXI_AWBURST), .i_axi_awlock(M_AXI_AWLOCK), .i_axi_awcache(M_AXI_AWCACHE), .i_axi_awprot(M_AXI_AWPROT), .i_axi_awqos(M_AXI_AWQOS), // }}} // W* // {{{ .i_axi_wvalid(M_AXI_WVALID), .i_axi_wready(M_AXI_WREADY), .i_axi_wdata(M_AXI_WDATA), .i_axi_wstrb(M_AXI_WSTRB), .i_axi_wlast(M_AXI_WLAST), // }}} // B* // {{{ .i_axi_bvalid(M_AXI_BVALID), .i_axi_bready(M_AXI_BREADY), .i_axi_bid(M_AXI_RID), .i_axi_bresp(M_AXI_BRESP), // }}} // AR* // {{{ .i_axi_arvalid( M_AXI_ARVALID), .i_axi_arready( M_AXI_ARREADY), .i_axi_arid( M_AXI_ARID), .i_axi_araddr( M_AXI_ARADDR), .i_axi_arlen( M_AXI_ARLEN), .i_axi_arsize( M_AXI_ARSIZE), .i_axi_arburst( M_AXI_ARBURST), .i_axi_arlock( M_AXI_ARLOCK), .i_axi_arcache( M_AXI_ARCACHE), .i_axi_arprot( M_AXI_ARPROT), .i_axi_arqos( M_AXI_ARQOS), // }}} // R* // {{{ .i_axi_rvalid( M_AXI_RVALID), .i_axi_rready( M_AXI_RREADY), .i_axi_rid( M_AXI_RID), .i_axi_rdata( M_AXI_RDATA), .i_axi_rlast( M_AXI_RLAST), .i_axi_rresp( M_AXI_RRESP), // }}} // Induction // {{{ .f_axi_awr_nbursts(faxi_awr_nbursts), .f_axi_wr_pending(faxi_wr_pending), .f_axi_rd_nbursts(faxi_rd_nbursts), .f_axi_rd_outstanding(faxi_rd_outstanding), // Write checking // {{{ .f_axi_wr_checkid( faxi_wr_checkid), .f_axi_wr_ckvalid( faxi_wr_ckvalid), .f_axi_wrid_nbursts( faxi_wrid_nbursts), .f_axi_wr_addr( faxi_wr_addr), .f_axi_wr_incr( faxi_wr_incr), .f_axi_wr_burst( faxi_wr_burst), .f_axi_wr_size( faxi_wr_size), .f_axi_wr_len( faxi_wr_len), .f_axi_wr_lockd( faxi_wr_lockd), // }}} // Read checking // {{{ .f_axi_rd_checkid( faxi_rd_checkid), .f_axi_rd_ckvalid( faxi_rd_ckvalid), .f_axi_rd_cklen( faxi_rd_cklen), .f_axi_rd_ckaddr( faxi_rd_ckaddr), .f_axi_rd_ckincr( faxi_rd_ckincr), .f_axi_rd_ckburst( faxi_rd_ckburst), .f_axi_rd_cksize( faxi_rd_cksize), .f_axi_rd_ckarlen( faxi_rd_ckarlen), .f_axi_rd_cklockd( faxi_rd_cklockd), // .f_axi_rdid_nbursts( faxi_rdid_nbursts), .f_axi_rdid_outstanding( faxi_rdid_outstanding), .f_axi_rdid_ckign_nbursts( faxi_rdid_ckign_nbursts), .f_axi_rdid_ckign_outstanding( faxi_rdid_ckign_outstanding), // }}} // Exclusive access checking // {{{ .f_axi_ex_state(faxi_ex_state), .f_axi_ex_checklock(faxi_ex_checklock), .f_axi_rdid_bursts_to_lock(faxi_rdid_bursts_to_lock), .f_axi_wrid_bursts_to_exwrite(faxi_wrid_bursts_to_exwrite), .i_active_lock( faxi_active_lock), .i_exlock_addr( faxi_exlock_addr), .i_exlock_len( faxi_exlock_len), .i_exlock_burst(faxi_exlock_burst), .i_exlock_size( faxi_exlock_size), .f_axi_exreq_addr(faxi_exreq_addr), .f_axi_exreq_len(faxi_exreq_len), .f_axi_exreq_burst(faxi_exreq_burst), .f_axi_exreq_size(faxi_exreq_size), .f_axi_exreq_return(faxi_exreq_return) // }}} // }}} // }}} ); // ID checking // {{{",
            "always @(*) begin assume(faxi_rd_checkid == AXI_ID); assert(faxi_rdid_nbursts == faxi_rd_nbursts); assert(faxi_rdid_outstanding == faxi_rd_outstanding); assume(faxi_wr_checkid == AXI_ID); assert(faxi_wrid_nbursts == faxi_awr_nbursts); end // }}} // Never both reads and writes outstanding // {{{",
            "always @(*) if (faxi_rd_outstanding > 0) begin assert(!M_AXI_AWVALID); assert(!M_AXI_WVALID); assert(faxi_awr_nbursts == 0); assert(o_busy); if (r_rd_pending) begin assert(o_rdbusy); end if (flushing) assert(!o_rdbusy); assert(!locked_write_in_progress); end else if (faxi_awr_nbursts > 0) begin assert(!locked_read_in_progress); assert(o_busy); if (locked_write_in_progress) begin assert(o_rdbusy); end else assert(!o_rdbusy); // || OPT_LOCK && LOCKD WRITE assert(!M_AXI_ARVALID); // assert(f_wr_pending == (M_AXI_WVALID ? 1:0)); end // }}} // Read count checking // {{{",
            "always @(*) if (S_AXI_ARESETN) begin if (state == DC_READC) begin assert(faxi_rd_nbursts == (M_AXI_ARVALID ? 0:1)); end else if (state == DC_READS) begin assert(faxi_rd_nbursts == faxi_rd_outstanding); if (!OPT_PIPE) assert(faxi_rd_nbursts == (M_AXI_ARVALID ? 0:1)); end else assert(faxi_rd_nbursts == 0); end // }}} // Write packet checking // {{{",
            "always @(*) if (faxi_wr_ckvalid) begin assert(faxi_wr_burst == M_AXI_AWBURST); assert(faxi_wr_len == 8'h00); assert(faxi_wr_lockd == locked_write_in_progress); // if (SWAP_WSTRB) assert(faxi_wr_size == 3'd2); else casez(f_op[AXILSB+1:AXILSB]) 2'b0?: assert(faxi_wr_size == 3'd2); 2'b10: assert(faxi_wr_size == 3'd1); 2'b11: assert(faxi_wr_size == 3'd0); endcase end // }}} // CPU matching -- write cycle // {{{",
            "always @(*) if (!cpu_read_cycle) begin if (OPT_WRAP && state == DC_READC) begin assert(!r_rd_pending); assert(faxi_rd_nbursts == (M_AXI_ARVALID ? 0:1)); assert(faxi_awr_nbursts == 0); end else begin assert(flushing || (faxi_rd_nbursts == 0)); // Verilator lint_off WIDTH assert(flushing || o_err || (cpu_outstanding == faxi_awr_nbursts + ((OPT_LOCK && f_was_locked_write && !locked_write_in_progress) ? 1:0) + (M_AXI_AWVALID ? 1:0))); // Verilator lint_on WIDTH end end else // if (!flushing) assert(faxi_awr_nbursts == 0); // }}} // Read request checking // {{{",
            "always @(*) if (!S_AXI_ARESETN) begin end else if (state == DC_IDLE || state == DC_WRITE) begin assert(!M_AXI_ARVALID); assert(flushing || faxi_rd_outstanding == 0); end else if (M_AXI_ARVALID && !flushing) begin assert(faxi_rd_outstanding == 0); if (state == DC_READC) begin assert(M_AXI_ARBURST == (OPT_WRAP) ? WRAP : INCR); assert(!M_AXI_ARLOCK); assert(M_AXI_ARLEN == (1 << LS) - 1); if (!OPT_LOWPOWER || M_AXI_ARVALID) begin assert(M_AXI_ARADDR[AW-1:CS+AXILSB] == r_ctag); assert(axi_tag == r_ctag); assert(M_AXI_ARADDR[CS+AXILSB-1:LS+AXILSB] == r_cline); assert(axi_line == r_cline); end assert(M_AXI_ARADDR[AXILSB-1:0] == 0); if (!OPT_WRAP) begin assert(read_addr[LS-1:0] == 0); end assert((OPT_LOWPOWER && !M_AXI_ARVALID) || M_AXI_ARADDR[AXILSB +: CS] == read_addr); end else begin assert(state == DC_READS); assert(M_AXI_ARBURST == INCR); assert(M_AXI_ARLEN == 0); assert(M_AXI_ARLOCK == locked_read_in_progress); if (locked_read_in_progress || OPT_WRAP) assert((OPT_LOWPOWER && !M_AXI_ARVALID) ||M_AXI_ARADDR[AXILSB +: CS] == read_addr); end end // }}} // Read packet checking // {{{",
            "always @(*) begin faxi_rd_lastaddr = faxi_rd_ckaddr; // Verilator lint_off WIDTH faxi_rd_lastaddr = faxi_rd_ckaddr + ((faxi_rd_cklen - 1) << faxi_rd_cksize); // Verilator lint_on WIDTH end",
            "always @(*) if (faxi_rd_ckvalid) begin // .f_axi_rd_cklen( faxi_rd_cklen), // .f_axi_rd_ckaddr( faxi_rd_ckaddr), if (state == DC_READC) begin // Read to cache assert(faxi_rd_ckarlen == (1 << LS) - 1); assert(faxi_rd_nbursts == 1); assert(faxi_rd_cksize == AXILSB[2:0]); if (!OPT_WRAP) begin assert(faxi_rd_lastaddr[AXILSB-1:0] == 0); assert(&faxi_rd_lastaddr[AXILSB +: LS]); end assert(last_ack == (axi_arvalid ? 0:1)); assert(r_ctag == faxi_rd_ckaddr[AW-1:CS+AXILSB]); assert(!faxi_rd_cklockd); assert(faxi_rd_ckburst == (OPT_WRAP) ? WRAP : INCR); // Need to verify wcache_addr end else begin // Single, uncachable reads // assert(!w_v || wcache_tag != r_ctag); assert(faxi_rd_ckarlen == 0); assert(locked_read_in_progress == faxi_rd_cklockd); assert(faxi_rd_ckburst == INCR); if (SWAP_WSTRB) begin assert(faxi_rd_cksize == 3'b010); end else case(req_size) 2'b10: assert(faxi_rd_cksize == 3'd1); 2'b11: assert(faxi_rd_cksize == 3'd0); default: assert(faxi_rd_cksize == 3'd2); endcase end end // }}}",
            "always @(*) if (S_AXI_ARESETN && (state != DC_WRITE || !OPT_LOCK)) assert(!locked_write_in_progress); // }}} //////////////////////////////////////////////////////////////////////// // // CPU/memory interface // {{{ //////////////////////////////////////////////////////////////////////// // // fmem #( // {{{ .OPT_LOCK(OPT_LOCK), .OPT_AXI_LOCK(OPT_LOCK), .F_LGDEPTH(LGPIPE+1), .OPT_MAXDEPTH((OPT_PIPE) ? ((1<<LGPIPE)-1) : 1) // }}} ) fmemp ( // {{{ .i_clk(S_AXI_ACLK), .i_sys_reset(!S_AXI_ARESETN), .i_cpu_reset(i_cpu_reset), .i_stb(i_pipe_stb), .i_pipe_stalled(o_pipe_stalled), .i_clear_cache(i_clear), .i_lock(i_lock), .i_op(i_op), .i_addr(i_addr), .i_data(i_data), .i_o",
            "reg (i_o",
            "reg ), .i_a",
            "reg (f_a",
            "reg ), // .i_busy(o_busy), .i_rdbusy(o_rdbusy), .i_valid(o_valid), .i_done(f_done), .i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_data), // .f_outstanding(cpu_outstanding), .f_pc(cpu_pc), .f_gie(cpu_gie), .f_read_cycle(cpu_read_cycle), .f_axi_write_cycle(cpu_lockd_write_cycle), .f_last_",
            "reg (cpu_last_",
            "reg ), .f_addr_",
            "reg (cpu_addr_",
            "reg ) // }}} );",
            "always @(*) if (o_rdbusy) assert(cpu_outstanding <= 1);",
            "always @(*) if (o_rdbusy && (cpu_outstanding == 1 + ((f_done || o_err) ? 1:0)) && (r_rd_pending)) assert(o_pipe_stalled);",
            "initial f_was_locked_write = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !OPT_LOCK) f_was_locked_write <= 1'b0; else f_was_locked_write <= locked_write_in_progress;",
            "always @(*) begin f_done = 0; if (M_AXI_BVALID && !flushing && !M_AXI_BRESP[1] && (!OPT_LOCK || !locked_write_in_progress)) f_done = 1'b1; if (OPT_LOCK && f_was_locked_write && !locked_write_in_progress) f_done = 1'b1; if (cpu_read_cycle && (o_valid || o_err)) f_done = 1'b1; if (flushing) assert(!o_rdbusy); end",
            "always @(*) if (!OPT_LOCK) assert(!cpu_lockd_write_cycle);",
            "always @(*) if (o_rdbusy) assert(cpu_gie == o_w",
            "reg [4]);",
            "always @(*) if (o_rdbusy && !locked_write_in_progress) begin assert(cpu_gie == o_w",
            "reg [4]); if (locked_write_in_progress) begin assert(o_w",
            "reg [3:0] == 4'hf); end else assert(cpu_last_",
            "reg == o_w",
            "reg ); end",
            "always @(*) if (S_AXI_ARESETN && (locked_write_in_progress || locked_read_in_progress)) begin assert(OPT_LOCK); assert(o_pipe_stalled); end",
            "always @(*) if (S_AXI_ARESETN && OPT_PIPE && (locked_write_in_progress || locked_read_in_progress)) begin assert(w_pipe_stalled); end",
            "always @(*) if (OPT_PIPE && state == DC_READC) assert(w_pipe_stalled);",
            "always @(*) if (OPT_PIPE && flushing) assert(w_pipe_stalled);",
            "always @(posedge S_AXI_ACLK) if (S_AXI_ARESETN && OPT_PIPE && $past(S_AXI_ARESETN)) begin if ($past(!i_cpu_reset && i_pipe_stb && i_read && !misaligned)) assert(w_pipe_stalled); else if (M_AXI_ARVALID) assert(o_pipe_stalled); else if ((faxi_rd_nbursts == 0) && (faxi_awr_nbursts == 0) && !r_rd_pending && !r_svalid && !r_dvalid && (!M_AXI_AWVALID && !M_AXI_WVALID)) begin if ($past(state) != DC_READC) assert(!w_pipe_stalled); end end // }}} //////////////////////////////////////////////////////////////////////// // // Induction properties // {{{ //////////////////////////////////////////////////////////////////////// // // // State checking // {{{",
            "always @(*) if (S_AXI_ARESETN) case(state) DC_IDLE: begin // {{{ assert(!flushing); assert(!M_AXI_AWVALID); assert(!M_AXI_WVALID); assert(!M_AXI_ARVALID); assert(faxi_rd_nbursts == 0); assert(faxi_awr_nbursts == 0); assert(noutstanding == 0); assert(cpu_outstanding <= 1); if (r_rd_pending) assert(o_rdbusy); if (cpu_outstanding > 0) begin if (r_svalid || r_dvalid || o_valid || o_err) assert(!r_rd_pending); if (!r_rd_pending) assert(f_done || o_err || r_svalid || r_dvalid); // else // assert(r_svalid || r_dvalid || o_valid || o_err); // // Older",
            "logic // if (r_svalid || r_dvalid || o_valid || o_err) // assert(!r_rd_pending); // if (!r_svalid && !r_dvalid && !o_err && !o_valid && !f_done) // assert(cpu_outstanding == (r_rd_pending ? 1:0)); end else assert(!r_rd_pending); /* if (cpu_read_cycle && !o_err && o_busy) begin assert(o_rdbusy || o_valid); assert(o_valid || r_rd_pending); // assert(!r_cache_miss); end */ end // }}} DC_WRITE: begin // {{{ assert(!M_AXI_ARVALID); assert(noutstanding == faxi_awr_nbursts); if (!OPT_PIPE) begin assert(faxi_awr_nbursts == (M_AXI_AWVALID ? 0:1)); assert(noutstanding == (M_AXI_AWVALID ? 0:1)); end else begin assert(faxi_awr_nbursts == noutstanding); end assert(o_rdbusy == locked_write_in_progress); assert(!cpu_read_cycle); assert(o_busy); assert(!r_rd_pending); assert(!r_cache_miss); assert(faxi_wr_pending == ((M_AXI_WVALID && !M_AXI_AWVALID) ? 1:0)); if (flushing) assert(o_err || cpu_outstanding == 0); end // }}} DC_READC: begin // {{{ assert(!M_AXI_AWVALID); assert(!M_AXI_WVALID); if (M_AXI_ARVALID) assert(M_AXI_ARLEN == (1 << LS) - 1); // assert(!M_AXI_ARVALID); // assert(faxi_rd_nbursts == 0); assert(noutstanding == (M_AXI_ARVALID ? 0:1)); assert(faxi_awr_nbursts == 0); assert(flushing || (OPT_WRAP || o_rdbusy)); assert(o_busy); assert(faxi_rd_nbursts == (M_AXI_ARVALID ? 0:1)); assert(faxi_rd_outstanding <= (1<<LS)); assert(OPT_WRAP || r_cache_miss || flushing); assert(OPT_WRAP || !r_dvalid); assert(!r_svalid); assert(good_cache_read || flushing); assert(wcache_addr[CS-1:LS] == r_cline); assert(read_addr[CS-1:LS] == r_cline); if (!OPT_WRAP) assert(r_rd_pending || flushing); if (flushing) begin assert(!r_rd_pending); assert(cpu_outstanding == (o_err ? 1:0)); end else assert(OPT_WRAP || r_rd_pending); end // }}} DC_READS: begin // {{{ assert(!M_AXI_AWVALID); assert(!M_AXI_WVALID); assert(noutstanding == (M_AXI_ARVALID ? 0:1)); assert(faxi_awr_nbursts == 0); // assert(!M_AXI_ARVALID); assert(faxi_rd_nbursts == faxi_rd_outstanding); assert(faxi_rd_nbursts == noutstanding); assert(flushing || o_rdbusy); assert(o_busy); assert(!r_rd_pending); assert(!r_cache_miss); if (flushing) begin assert(!o_rdbusy); assert(cpu_outstanding == (o_err ? 1:0)); end end // }}} endcase // }}} /* // Issues with the following: // 1. Can't handle errors // 2. Can't handle the wrong cache read ... // */",
            "reg [3:0] f_read_state; (* anyconst *)",
            "reg f_never_err;",
            "always @(*) if (f_never_err) begin assume(!M_AXI_RVALID || !M_AXI_RRESP[1]); // assume(!M_AXI_BVALID || !M_AXI_BRESP[1]); end",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) // || !f_never_err) f_read_state <= 0; else if (i_cpu_reset) f_read_state <= 0; else case(f_read_state) 4'h0: begin // Idle. What operation do we start? // {{{ assert(!r_rd_pending); assert(!set_vflag); if (!flushing) begin assert(state == DC_IDLE || state == DC_WRITE); assert(faxi_rd_nbursts == 0); if (i_pipe_stb && i_read && !misaligned) begin if (cachable_read_request) f_read_state <= 4'h1; else f_read_state <= 4'h6; end end end // }}} 4'h1: begin // Cachable read request, checking if its in the cache // {{{ assert(r_svalid ^ r_rd_pending); assert(state == DC_IDLE); assert(r_check); assert(!set_vflag); assert(o_rdbusy); assert(o_busy); if (r_svalid) f_read_state <= 4'h7; else f_read_state <= 4'h2; end // }}} 4'h2: begin // Cachable read, checking in the cache step #2 // {{{ assert(!flushing); assert(r_cachable); assert(r_rd_pending ^ r_dvalid); assert(o_rdbusy); assert(!r_check); assert(state == DC_IDLE); assert(!set_vflag); assert(o_busy); if (r_dvalid) f_read_state <= 4'h7; else begin assert(!r_rv || r_rtag != r_ctag); // !!! f_read_state <= 4'h3; end end // }}} 4'h3: begin // Cachable read, now starting the read operation // {{{ assert(faxi_rd_nbursts == (M_AXI_ARVALID ? 0:1)); assert(!flushing); assert(!r_svalid); assert(!r_dvalid); assert(!r_check); assert(!r_rv || r_rtag != r_ctag); assert(r_rd_pending); assert(r_cachable); assert(state == DC_READC); assert(good_cache_read); assert(!set_vflag); assert(o_busy); if (OPT_WRAP && M_AXI_RVALID) f_read_state <= M_AXI_RLAST ? 4'h9 : 4'h8; if (!OPT_WRAP && M_AXI_RVALID && M_AXI_RLAST) f_read_state <= 4'h4; if (M_AXI_RVALID && M_AXI_RRESP[1]) f_read_state <= 4'h0; end // }}} 4'h4: begin // Completed the cachable read operation into the cache // {{{ assert(!OPT_WRAP); assert(!flushing); assert(!r_svalid); assert(r_cachable); assert(r_rd_pending); assert(r_rtag == r_ctag); assert(state == DC_IDLE); assert(set_vflag); assert(o_busy); f_read_state <= 4'h5; // r_dvalid <= !r_svalid && !r_dvalid // && (w_tag == r_ctag) && w_v end // }}} 4'h5: begin // Final step of the cachable read // {{{ assert(!OPT_WRAP); assert(!flushing); assert(r_cachable); assert(r_rd_pending != r_dvalid); // assert(w_v && w_tag == r_ctag); // assert(r_dvalid == $stable(f_read_state)); assert(state == DC_IDLE); assert(!set_vflag); if (r_dvalid) f_read_state <= 4'h7; end // }}} 4'h6: begin // Read single state // {{{ assert(!flushing); assert(faxi_rd_nbursts == (M_AXI_ARVALID ? 0:1)); assert(faxi_rd_outstanding == (M_AXI_ARVALID ? 0:1)); assert(!flushing); assert(state == DC_READS); if (M_AXI_RVALID) f_read_state <= 4'h7; end // }}} 4'h7: begin // {{{ assert(faxi_rd_outstanding == 0); // assert(r_rd_pending); assert(o_valid || o_err); f_read_state <= 4'h000; if (!flushing && i_pipe_stb && !i_op[0] && !misaligned) begin if (address_is_cachable && (!OPT_LOCK || !i_lock)) f_read_state <= 4'h1; else f_read_state <= 4'h6; end end // }}} 4'h8: begin // WRAP Read // {{{ assert(OPT_WRAP); assert(!flushing); assert(faxi_rd_nbursts == 1); assert(!r_rd_pending); assert(!set_vflag); assert(o_busy); if (M_AXI_RVALID && M_AXI_RLAST) f_read_state <= 4'h9; end // }}} 4'h9: begin // Concluding WRAP read // {{{ assert(OPT_WRAP); assert(faxi_rd_nbursts == 0); assert(!r_rd_pending); assert(!flushing); assert(state == DC_IDLE); assert(o_busy); if (!$past(i_clear)) assert(set_vflag || !good_cache_read); f_read_state <= 4'h0; if (!flushing && i_pipe_stb && i_read && !misaligned) begin if (address_is_cachable && (!OPT_LOCK || !i_lock)) f_read_state <= 4'h1; else f_read_state <= 4'h6; end end // }}} default: assert(0); endcase",
            "always @(*) if (S_AXI_ARESETN && faxi_rd_outstanding > 0 && !flushing) assert(f_read_state != 0);",
            "always @(*) if (S_AXI_ARESETN && (state == DC_READS || state == DC_READC)) begin assert(flushing || (f_read_state != 0)); end // DC_READC checks // {{{",
            "always @(posedge S_AXI_ACLK) if (state == DC_READC) begin assert(read_addr[CS-1:LS] == r_cline); if (M_AXI_ARVALID) begin assert(axi_araddr[AW-1:AXILSB+LS] == { r_ctag, r_cline }); if (!OPT_WRAP) begin assert(axi_araddr[AXILSB+LS-1:0] == 0); end assert(axi_araddr[AXILSB +: CS] == read_addr[CS-1:0]); // read_addr <= { i_addr[LGCACHELEN-1:AXILSB+LS], {(LS){1'b0}} }; if (!OPT_WRAP) assert(read_addr[LS-1:0] == 0); end else if (faxi_rd_ckvalid) begin assert(faxi_rd_ckaddr[AW-1:AXILSB+LS] == { r_ctag, r_cline }); assert(faxi_rd_ckaddr[AXILSB-1:0] == 0); assert(faxi_rd_ckaddr[AXILSB +: CS] == read_addr[CS-1:0]); end end // }}} // last_tag_valid checking // {{{",
            "always @(*) if (last_tag_valid) begin assert(cache_tag[last_tag_line] == last_tag); assert(cache_valid[last_tag_line]); end // }}}",
            "always @(*) if (!cpu_read_cycle && S_AXI_ARESETN && !flushing && !o_err) case(state) DC_WRITE: begin if (locked_write_in_progress) begin assert(cpu_outstanding == faxi_awr_nbursts + ((o_valid || f_done) ? 1:0) + (M_AXI_AWVALID ? 1:0)); end else begin assert(cpu_outstanding == faxi_awr_nbursts + (o_valid ? 1:0) + (M_AXI_AWVALID ? 1:0)); end end default: assert(cpu_outstanding == ((o_valid || o_err || f_done) ? 1:0)); endcase",
            "always @(*) if (S_AXI_ARESETN && !flushing && (!f_done && !o_valid && !o_err)) assert(cpu_lockd_write_cycle == locked_write_in_progress);",
            "always @(*) if (S_AXI_ARESETN && locked_write_in_progress) begin assert(state == DC_WRITE); assert(faxi_awr_nbursts + (M_AXI_AWVALID ? 1:0) == 1); end // }}} //////////////////////////////////////////////////////////////////////// // // Lowpower checks // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_LOWPOWER) begin : F_LOWPOWER",
            "always @(*) if (S_AXI_ARESETN && !M_AXI_AWVALID) begin assert(axi_awaddr == 0); end",
            "always @(*) if (S_AXI_ARESETN && !M_AXI_WVALID) begin assert(axi_wdata == 0); assert(axi_wstrb == 0); end",
            "always @(*) if (S_AXI_ARESETN && !M_AXI_ARVALID) begin assert(axi_araddr == 0); assert(axi_arlen == 0); assert(axi_arsize == 3'd2); end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Contract properties // {{{ //////////////////////////////////////////////////////////////////////// // // (* anyconst *)",
            "reg [AW-1:0] f_const_addr; (* anyconst *)",
            "reg f_const_err;",
            "reg [DW-1:0] f_mem_data;",
            "wire [DW-1:0] f_word_swapped_mem_data;",
            "wire [TW-1:0] f_const_tag;",
            "wire [CS-LS-1:0] f_const_line;",
            "wire [LS-1:0] f_const_caddr;",
            "reg f_this_return, f_this_line;",
            "reg [AW-1:0] f_request_addr;",
            "reg f_simple_return;",
            "reg [31:0] f_return;",
            "reg [DW-1:0] f_wide_return;",
            "reg [AXILSB+1:0] f_op;",
            "wire f_special_valid;",
            "wire [DW-1:0] f_special_cached_data;",
            "wire [TW-1:0] f_special_tag;",
            "reg [CS-1:0] f_wcache_addr_diff;",
            "always @(*) assume(f_const_addr[AXILSB-1:0] == 0);",
            "assign { f_const_tag, f_const_line, f_const_caddr } = f_const_addr[AW-1:AXILSB]; // f_this_return // {{{",
            "always @(*) begin f_this_return = r_rd_pending && M_AXI_RVALID; if (OPT_WRAP) f_this_return = (state == DC_READC && M_AXI_RVALID); if (read_addr[CS-1:LS] != f_const_line) f_this_return = 0; if ({ r_ctag, r_cline } != { f_const_tag, f_const_line }) f_this_return = 0; if (faxi_rd_ckvalid) begin if (faxi_rd_ckaddr[AW-1:AXILSB] != f_const_addr[AW-1:AXILSB]) f_this_return = 0; end else begin if (read_addr[CS-1:0] != f_const_addr[AXILSB +: CS]) f_this_return = 0; end if (state != DC_READC) f_this_return = 0; end // }}} // f_simple_return, f_request_addr // {{{",
            "initial f_simple_return = 0;",
            "always @(posedge S_AXI_ACLK) begin if (i_pipe_stb) begin f_request_addr <= rev_addr; f_simple_return = (f_const_addr[AW-1:AXILSB] == i_addr[AW-1:AXILSB]); if (misaligned || i_op[0]) f_simple_return <= 1'b0; if (address_is_cachable && (!OPT_LOCK || !i_lock)) f_simple_return <= 1'b0; end else if (M_AXI_RVALID) f_simple_return <= 1'b0; if (state == DC_READC) begin assert(read_addr[CS-1:LS] == f_request_addr[AXILSB +LS +: (CS-LS)]); if (M_AXI_ARVALID) begin if (!OPT_WRAP) begin assert({ f_request_addr[AW-1:AXILSB+LS], {(LS){1'b0}}, {(AXILSB){1'b0}} } == M_AXI_ARADDR); assert(read_addr[LS-1:0] == 0); assert(axi_araddr == { f_request_addr[AW-1:AXILSB+LS], {(LS+AXILSB){1'b0}} }); end else begin assert({ f_request_addr[AW-1:AXILSB], {(AXILSB){1'b0}} } == M_AXI_ARADDR); assert(read_addr[LS-1:0] == M_AXI_ARADDR[AXILSB+LS-1:AXILSB]); end end else if (faxi_rd_ckvalid) assert(faxi_rd_ckaddr[AW-1:AXILSB+LS] == f_request_addr[AW-1:AXILSB+LS]); end else if (state == DC_READS) assert(read_addr[CS-1:LS] == f_request_addr[AXILSB+LS +: (CS-LS)]); if (i_cpu_reset) f_simple_return <= 0; end // }}} // f_this_line // {{{",
            "always @(*) f_this_line = (f_request_addr[AW-1:AXILSB+LS] == f_const_addr[AW-1:AXILSB+LS]); // }}} // f_op // {{{",
            "always @(posedge S_AXI_ACLK) if (i_pipe_stb) f_op <= { i_op[2:1], rev_addr[AXILSB-1:0] };",
            "always @(*) if (cpu_outstanding > 0) assert(f_op == req_data);",
            "always @(*) if (cpu_outstanding > 0 && !o_err) begin assert(!checklsb(f_op[AXILSB+1:AXILSB], f_op[1:0])); assert(f_op[AXILSB-1:0] == f_request_addr[AXILSB-1:0]); if (!OPT_PIPE) assert(f_request_addr[AW-1:AXILSB] == r_addr); end // }}} // Check f_simple_return and f_request_addr // {{{",
            "always @(posedge S_AXI_ACLK) if (flushing) begin assert(!f_simple_return); end else if (state != DC_READS) begin assert(!f_simple_return); end else if (f_simple_return) begin assert(f_request_addr[AW-1:AXILSB]== f_const_addr[AW-1:AXILSB]); end else assert(f_request_addr[AW-1:AXILSB]!= f_const_addr[AW-1:AXILSB]); // }}} // Update f_mem_data // {{{",
            "always @(posedge S_AXI_ACLK) if (M_AXI_AWVALID && M_AXI_WVALID && M_AXI_AWADDR[AW-1:AXILSB] == f_const_addr[AW-1:AXILSB]) begin for(ik=0; ik<DW/8; ik=ik+1) if (M_AXI_WSTRB[ik]) f_mem_data[ik*8 +: 8] <= M_AXI_WDATA[ik*8 +: 8]; end generate if (!SWAP_WSTRB) begin",
            "assign f_word_swapped_mem_data = f_mem_data; end else for(gk=0; gk<C_AXI_DATA_WIDTH/32; gk=gk+1) begin",
            "assign f_word_swapped_mem_data[32*gk +: 32] =f_mem_data[C_AXI_DATA_WIDTH - (gk+1)*32 +: 32]; end endgenerate // }}} // Property #1: Assume a known return // {{{",
            "always @(*) if (M_AXI_RVALID && (f_simple_return || f_this_return)) begin assume(M_AXI_RRESP[1] == f_const_err); if (!f_const_err) assume(M_AXI_RDATA == f_mem_data); end else if (M_AXI_RVALID && f_this_line) begin if (!f_const_err) assume(!M_AXI_RRESP[1]); end",
            "always @(*) if (M_AXI_BVALID && (f_request_addr[AW-1:AXILSB] == f_const_addr[AW-1:AXILSB])) assume(M_AXI_BRESP[1] == f_const_err); // }}} // Check good_cache_read // {{{",
            "always @(*) if (state == DC_READC && f_this_line) begin if (!f_const_err) begin assert(good_cache_read); end else if (!OPT_WRAP && read_addr[LS-1:0] > f_const_addr[LS+AXILSB-1:AXILSB]) assert(flushing); end // }}} // f_wide_return, f_return // {{{",
            "always @(*) if (SWAP_WSTRB) begin f_wide_return = f_word_swapped_mem_data << (8*f_op[AXILSB-1:0]); casez(f_op[AXILSB +: 2]) 2'b0?: f_wide_return[31:0] = f_wide_return[DW-1:DW-32]; 2'b10: f_wide_return[31:0] = { 16'h0, f_wide_return[DW-1:DW-16] }; 2'b11: f_wide_return[31:0] = { 24'h0, f_wide_return[DW-1:DW- 8] }; endcase end else f_wide_return = f_mem_data >> (8*f_op[AXILSB-1:0]);",
            "always @(*) begin casez(f_op[AXILSB +: 2]) 2'b0?: f_return = f_wide_return[31:0]; 2'b10: f_return = { 16'h0, f_wide_return[15:0] }; 2'b11: f_return = { 24'h0, f_wide_return[ 7:0] }; endcase if (OPT_SIGN_EXTEND) casez(f_op[AXILSB +: 2]) 2'b0?: begin end 2'b10: f_return[31:16] = {(16){f_wide_return[15]}}; 2'b11: f_return[31:24] = {(24){f_wide_return[ 7]}}; endcase end // }}} // Property #2: Assert a known response // {{{",
            "always @(posedge S_AXI_ACLK) if (S_AXI_ARESETN && !OPT_PIPE && (!OPT_LOCK || !f_was_locked_write) && (f_request_addr[AW-1:AXILSB] == f_const_addr[AW-1:AXILSB])) begin if (o_valid) begin assert(!f_const_err); assert(f_return == o_data); end else if (o_err) begin if (!OPT_LOCK) assert(f_const_err || $past(misaligned)); // else if OPT_LOCK // // We might also produce an error if the value isn't // lockable end end // }}} // Property #3: Assert valid cache // {{{",
            "assign f_special_valid = cache_valid[f_const_line] && (cache_tag[f_const_line] == f_const_tag);",
            "assign f_special_tag = cache_tag[f_const_line];",
            "assign f_special_cached_data = cache_mem[{ f_const_line, f_const_caddr }];",
            "always @(*) if (S_AXI_ARESETN // && (!OPT_PIPE || (!flushing && !o_err)) && f_special_valid) begin assert(f_special_cached_data == f_word_swapped_mem_data);// !!! assert(!f_const_err); end",
            "always @(*) if (!OPT_PIPE && last_tag_valid && last_tag_line == f_const_line && last_tag == f_const_tag) assert(!f_const_err);",
            "always @(*) f_wcache_addr_diff = wcache_addr - f_const_addr[LGCACHELEN-1:AXILSB];",
            "always @(*) if (S_AXI_ARESETN && !OPT_PIPE && !flushing && (state == DC_READC || (state == DC_IDLE && !set_vflag && r_rd_pending && r_ctag == f_const_tag && (r_dvalid || r_svalid))) && f_this_line && !f_wcache_addr_diff[CS-1] && f_wcache_addr_diff != 0) begin // The cache read is in progress. Verify any partial results if (f_const_err) begin assert(OPT_WRAP || (!good_cache_read && !r_rd_pending)); end else if (!flushing) assert(OPT_WRAP || (f_special_cached_data == f_word_swapped_mem_data)); end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Exclusive access // {{{ //////////////////////////////////////////////////////////////////////// // // assign faxi_exlock_len = 0;",
            "assign faxi_exlock_burst = INCR;",
            "always @(posedge S_AXI_ACLK) if (M_AXI_ARVALID && M_AXI_ARREADY && M_AXI_ARLOCK) begin faxi_exlock_addr <= M_AXI_ARADDR; faxi_exlock_size <= M_AXI_ARSIZE; end // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // reg cvr_idle;",
            "reg [3:0] cvr_cache_reads, cvr_cache_writes, cvr_cache_misses, cvr_simple_reads, cvr_simple_writes; // cvr_idle // {{{",
            "always @(*) begin cvr_idle = 1; if (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) cvr_idle = 0; if (M_AXI_RVALID || M_AXI_BVALID) cvr_idle = 0; if (faxi_awr_nbursts > 0) cvr_idle = 0; if (faxi_rd_nbursts > 0) cvr_idle = 0; if (o_busy || f_done) cvr_idle = 0; if (i_pipe_stb) cvr_idle = 0; end // }}} // cvr_simple_writes // {{{",
            "initial cvr_simple_writes = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || i_cpu_reset) cvr_simple_writes <= 0; else if (wcache_strb != 0 && w_v && wcache_tag == r_ctag) cvr_simple_writes <= 0; else if (M_AXI_BVALID && !(&cvr_simple_writes)) cvr_simple_writes <= cvr_simple_writes + 1;",
            "always @(*) begin // cover(cvr_idle && cvr_simple_writes > 0); // cover(cvr_idle && cvr_simple_writes > 1); cover(cvr_idle && cvr_simple_writes > 4); end // }}} // cvr_simple_reads // {{{",
            "initial cvr_simple_reads = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || o_err || i_cpu_reset) cvr_simple_reads <= 0; else if (i_pipe_stb && !i_op[0] && !misaligned && !address_is_cachable && !(&cvr_simple_reads)) cvr_simple_reads <= cvr_simple_reads + 1;",
            "always @(*) begin // cover(cvr_idle && cvr_simple_reads > 0); // cover(cvr_idle && cvr_simple_reads > 1); cover(cvr_idle && cvr_simple_reads > 4); end // }}} // cvr_cache_misses // {{{",
            "initial cvr_cache_misses = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || state == DC_READS || i_cpu_reset) cvr_cache_misses <= 0; else if (M_AXI_ARVALID && M_AXI_ARREADY && (state == DC_READC) && !(&cvr_cache_misses)) cvr_cache_misses <= cvr_cache_misses + 1;",
            "always @(*) begin // cover(cvr_idle && cvr_cache_misses > 0); // cover(cvr_idle && cvr_cache_misses > 1); cover(cvr_idle && cvr_cache_misses > 2); end // }}} // cvr_cache_reads // {{{",
            "initial cvr_cache_reads = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || M_AXI_ARVALID || M_AXI_RVALID || i_cpu_reset) cvr_cache_reads <= 0; else if (o_valid && $past(r_dvalid || r_svalid) && !(&cvr_cache_reads)) cvr_cache_reads <= cvr_cache_reads + 1;",
            "always @(*) begin // cover(cvr_idle && cvr_cache_reads > 0); // cover(cvr_idle && cvr_cache_reads > 1); cover(cvr_idle && cvr_cache_reads > 4); end // }}} // cvr_cache_writes // {{{",
            "initial cvr_cache_writes = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || M_AXI_ARVALID || M_AXI_RVALID || i_cpu_reset) cvr_cache_writes <= 0; else if (!(&cvr_cache_writes) && state == DC_WRITE && w_v && wcache_tag == r_ctag && wcache_strb != 0) cvr_cache_writes <= cvr_cache_writes + 1;",
            "always @(*) begin // cover(cvr_idle && cvr_cache_writes > 0); // cover(cvr_idle && cvr_cache_writes > 1); cover(cvr_idle && cvr_cache_writes > 4); end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // \"Careless\" constraining assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (i_pipe_stb && i_write && i_lock) begin assume(i_addr == faxi_exlock_addr); assume(faxi_ex_state == 2'b10); if (SWAP_WSTRB) begin assert(faxi_exlock_size == DSZ); end else casez(i_op[2:1]) 2'b0?: assume(faxi_exlock_size == 3'b010); // Word 2'b10: assume(faxi_exlock_size == 3'b001); // Half-word 2'b11: assume(faxi_exlock_size == 3'b000); // Byte endcase end",
            "always @(*) casez(faxi_ex_state) 2'b01: begin assert(faxi_exreq_len == 0); assert(faxi_exreq_size <= 3'd2); if (faxi_exreq_addr[0]) begin assert(faxi_exreq_size == 3'd0); end else if (faxi_exreq_addr[1]) assert(faxi_exreq_size <= 3'd1); if (SWAP_WSTRB) assert(faxi_exreq_size == 3'd2); // assert(faxi_exlock_size == faxi_exreq_size); end 2'b1?: begin assert(faxi_exlock_addr == faxi_exreq_addr); assert(faxi_exlock_len == faxi_exreq_len); assert(faxi_exlock_size == faxi_exreq_size); assert(faxi_exlock_burst == faxi_exreq_burst); assert(faxi_exlock_size <= 3'd2); if (SWAP_WSTRB) assert(faxi_exlock_size == 3'd2); if (faxi_exlock_addr[0]) begin assert(faxi_exlock_size == 3'd0); end else if (faxi_exlock_addr[1]) assert(faxi_exlock_size <= 3'd1); end default: begin end endcase",
            "always @(*) if (i_pipe_stb && i_lock) assume(!i_cpu_reset);",
            "always @(posedge S_AXI_ACLK) if ($past(i_cpu_reset)) assume((faxi_ex_state == 2'b00) || (faxi_ex_state == 2'b01));",
            "always @(*) if (OPT_WRAP && S_AXI_ARESETN && !i_cpu_reset && !r_rd_pending && state == DC_READC && M_AXI_RVALID) assume(M_AXI_RRESP[1] == !good_cache_read);",
            "always @(*) if (S_AXI_ARESETN && OPT_LOCK && cpu_outstanding > 0) assume(!i_pipe_stb || !i_lock); // }}} // Make Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused_formal;",
            "assign unused_formal = &{ 1'b0, cpu_pc, faxi_rdid_ckign_nbursts, faxi_rdid_ckign_outstanding, faxi_wr_incr, faxi_wr_pending, faxi_wr_addr, cpu_addr_",
            "reg , faxi_rd_ckincr, faxi_rd_lastaddr }; // Verilator lint_on UNUSED // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipcore.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/zipcore.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipcore.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipcore #( // {{{",
            "parameter ADDRESS_WIDTH=30, // 32-b word addr width",
            "parameter [31:0] RESET_ADDRESS=32'h010_0000, parameter OPT_MPY = 0, parameter [0:0] OPT_SHIFTS = 1, parameter [0:0] OPT_DIV = 1, parameter [0:0] IMPLEMENT_FPU = 0, parameter [0:0] OPT_EARLY_BRANCHING = 1, parameter [0:0] OPT_CIS = 1'b1, parameter [0:0] OPT_SIM = 1'b0, parameter [0:0] OPT_DISTRIBUTED_REGS = 1'b1, parameter [0:0] OPT_PIPELINED = 1'b1, parameter [0:0] OPT_PIPELINED_BUS_ACCESS = (OPT_PIPELINED), parameter [0:0] OPT_LOCK=1, parameter [0:0] OPT_DCACHE = 1, parameter [0:0] OPT_USERMODE = 1'b1, parameter [0:0] OPT_LOWPOWER = 1'b0, parameter [0:0] OPT_CLKGATE = 1'b1, parameter [0:0] OPT_START_HALTED = 1'b1, parameter [0:0] OPT_DBGPORT = 1'b1, parameter [0:0] OPT_TRACE_PORT = 1'b0, parameter [0:0] OPT_PROFILER = 1'b0, localparam AW=ADDRESS_WIDTH `ifdef FORMAL , parameter F_LGDEPTH=4 `endif // }}} ) ( // {{{",
            "input wire i_clk, i_reset, i_interrupt, output wire o_clken, // Debug interface // {{{",
            "input wire i_halt, i_clear_cache, input wire [4:0] i_dbg_w",
            "reg , input wire i_dbg_we, input wire [31:0] i_dbg_data, input wire [4:0] i_dbg_r",
            "reg , // output wire o_dbg_stall, output wire [31:0] o_dbg_",
            "reg , output reg [2:0] o_dbg_cc, output wire o_break, // }}} // Instruction fetch interface // {{{",
            "output wire o_pf_new_pc, output wire o_clear_icache, output wire o_pf_ready, output wire [(AW+1):0] o_pf_request_address, input wire i_pf_valid, i_pf_illegal, input wire [31:0] i_pf_instruction, input wire [(AW+1):0] i_pf_instruction_pc, // }}} // Memory unit interface // {{{",
            "output wire o_clear_dcache, output wire o_mem_ce, output wire o_bus_lock, output wire [2:0] o_mem_op, output wire [31:0] o_mem_addr, output wire [31:0] o_mem_data, output wire [AW+1:0] o_mem_lock_pc, output wire [4:0] o_mem_",
            "reg , input wire i_mem_busy, i_mem_rdbusy, i_mem_pipe_stalled, i_mem_valid, input wire i_bus_err, input wire [4:0] i_mem_w",
            "reg , input wire [31:0] i_mem_result, // }}} // Accounting",
            "output s ... to help us count stalls and usage // {{{",
            "output wire o_op_stall, output wire o_pf_stall, output wire o_i_count, // }}} // Debug data for on-line/live tracing // {{{",
            "output wire [31:0] o_debug, //}}} // (Optional) Profiler data // {{{",
            "output wire o_prof_stb, output wire [AW+1:0] o_prof_addr, output wire [31:0] o_prof_ticks // }}} // }}} ); // Local",
            "parameter definitions // {{{ // Verilator lint_off UNUSED",
            "localparam [0:0] OPT_MEMPIPE = OPT_PIPELINED_BUS_ACCESS;",
            "localparam [(AW-1):0] RESET_BUS_ADDRESS = RESET_ADDRESS[AW+1:2];",
            "localparam [3:0] CPU_CC_REG = 4'he, CPU_PC_REG = 4'hf;",
            "localparam [3:0] CPU_SUB_OP = 4'h0,// also a compare instruction CPU_AND_OP = 4'h1,// also a test instruction CPU_BREV_OP= 4'h8, CPU_MOV_OP = 4'hd;",
            "localparam CPU_CLRDCACHE_BIT=15, // Set to clr D-cache,auto clears CPU_CLRICACHE_BIT=14, // Set to clr I-cache,auto clears CPU_PHASE_BIT = 13, // Set on last half of a CIS CPU_FPUERR_BIT = 12, // Set on floating point error CPU_DIVERR_BIT = 11, // Set on divide error CPU_BUSERR_BIT = 10, // Set on bus error CPU_TRAP_BIT = 9, // User TRAP has taken place CPU_ILL_BIT = 8, // Illegal instruction CPU_BREAK_BIT = 7, CPU_STEP_BIT = 6, // Will step one (or two CIS) ins CPU_GIE_BIT = 5, CPU_SLEEP_BIT = 4; // Verilator lint_on UNUSED // }}} // Register declarations // {{{ // The distributed RAM style comment is necessary on the // SPARTAN6 with XST to prevent XST from oversimplifying the",
            "reg ister // set and in the process ruining everything else. It basically // optimizes",
            "logic away, to where it no longer works. The",
            "logic // as described herein will work, this just makes sure XST implements // that",
            "logic . // // (* ram_style = \"distributed\" *)",
            "reg [31:0]",
            "reg set [0:(OPT_USERMODE)? 31:15]; // Condition codes // (BUS, TRAP,ILL,BREAKEN,STEP,GIE,SLEEP ), V, N, C, Z",
            "reg [3:0] flags, iflags;",
            "wire [15:0] w_uflags, w_iflags;",
            "reg break_en, user_step, sleep, r_halted;",
            "wire break_pending, trap, gie, ubreak, pending_interrupt, stepped;",
            "wire step;",
            "wire ill_err_u;",
            "reg ill_err_i;",
            "reg ibus_err_flag;",
            "wire ubus_err_flag;",
            "wire idiv_err_flag, udiv_err_flag; // Verilator coverage_off",
            "wire ifpu_err_flag, ufpu_err_flag; // Verilator coverage_on",
            "wire ihalt_phase, uhalt_phase; // The master chip enable",
            "wire master_ce, master_stall; // // // PIPELINE STAGE #1 :: Prefetch // Variable declarations // // {{{",
            "reg [(AW+1):0] pf_pc;",
            "reg new_pc;",
            "wire clear_pipeline;",
            "reg dcd_stalled; // wire pf_cyc, pf_stb, pf_we, pf_stall, pf_ack, pf_err; // wire [(AW-1):0] pf_addr; // wire pf_valid, pf_gie, pf_illegal;",
            "wire pf_gie; `ifdef FORMAL",
            "wire [31:0] f_dcd_insn_word;",
            "wire f_dcd_insn_gie;",
            "wire f_dcd_insn_is_pipeable;",
            "reg [31:0] f_op_insn_word;",
            "reg [31:0] f_alu_insn_word; `endif",
            "assign clear_pipeline = new_pc; // }}} // // PIPELINE STAGE #2 :: Instruction Decode // Variable declarations // // // {{{",
            "wire [3:0] dcd_opn;",
            "wire dcd_ce, dcd_phase;",
            "wire [4:0] dcd_A, dcd_B, dcd_R, dcd_preA, dcd_preB;",
            "wire dcd_Acc, dcd_Bcc, dcd_Apc, dcd_Bpc, dcd_Rcc, dcd_Rpc;",
            "wire [3:0] dcd_F;",
            "wire dcd_wR, dcd_rA, dcd_rB, dcd_ALU, dcd_M, dcd_DIV, dcd_FP, dcd_wF, dcd_gie, dcd_break, dcd_lock, dcd_pipe, dcd_ljmp;",
            "wire dcd_valid;",
            "wire [AW+1:0] dcd_pc /* verilator public_flat */;",
            "wire [31:0] dcd_I;",
            "wire dcd_zI; // true if dcd_I == 0",
            "wire dcd_A_stall, dcd_B_stall, dcd_F_stall;",
            "wire dcd_illegal;",
            "wire dcd_early_branch, dcd_early_branch_stb;",
            "wire [(AW+1):0] dcd_branch_pc;",
            "wire dcd_sim;",
            "wire [22:0] dcd_sim_immv;",
            "wire prelock_stall, last_lock_insn;",
            "wire cc_invalid_for_dcd;",
            "wire pending_s",
            "reg _write; // }}} // // // PIPELINE STAGE #3 :: Read Operands // Variable declarations // // // // {{{ // Now, let's read our operands",
            "reg op_valid /* verilator public_flat */, op_valid_mem, op_valid_alu;",
            "reg op_valid_div, op_valid_fpu;",
            "wire op_stall;",
            "wire [3:0] op_opn;",
            "wire [4:0] op_R;",
            "reg op_Rcc;",
            "wire [4:0] op_Aid, op_Bid;",
            "wire op_rA, op_rB;",
            "reg [31:0] r_op_Av, r_op_Bv;",
            "wire [AW+1:0] op_pc;",
            "wire [31:0] w_op_Av, w_op_Bv, op_Av, op_Bv;",
            "reg [31:0] w_pcB_v, w_pcA_v;",
            "reg [31:0] w_op_BnI;",
            "wire op_wR;",
            "reg op_wF;",
            "wire op_gie;",
            "wire [3:0] op_Fl;",
            "reg [6:0] r_op_F;",
            "wire [7:0] op_F;",
            "wire op_ce, op_phase, op_pipe;",
            "reg r_op_break;",
            "wire w_op_valid;",
            "wire op_lowpower_clear;",
            "wire [8:0] w_cpu_info; // Some pipeline control",
            "wire s",
            "reg op_illegal;",
            "wire op_break;",
            "wire op_lock;",
            "wire op_sim /* verilator public_flat */;",
            "wire [22:0] op_sim_immv /* verilator public_flat */;",
            "wire alu_sim /* verilator public_flat */;",
            "wire [22:0] alu_sim_immv /* verilator public_flat */; // }}} // // // PIPELINE STAGE #4 :: ALU / Memory // Variable declarations // // // {{{",
            "wire [(AW+1):0] alu_pc;",
            "reg [4:0] alu_",
            "reg ;",
            "reg r_alu_pc_valid, mem_pc_valid;",
            "wire alu_pc_valid;",
            "wire alu_phase;",
            "wire alu_ce /* verilator public_flat */, alu_stall;",
            "wire [31:0] alu_result;",
            "wire [3:0] alu_flags;",
            "wire alu_valid, alu_busy;",
            "wire set_cond;",
            "reg alu_wR, alu_wF;",
            "wire alu_gie, alu_illegal;",
            "wire mem_ce, mem_stalled;",
            "wire div_ce, div_error, div_busy, div_valid;",
            "wire [31:0] div_result;",
            "wire [3:0] div_flags; // Verilator coverage_off",
            "wire fpu_ce, fpu_error, fpu_busy, fpu_valid;",
            "wire [31:0] fpu_result;",
            "wire [3:0] fpu_flags; // Verilator coverage_on",
            "reg adf_ce_unconditional;",
            "reg dbgv, dbg_clear_pipe;",
            "reg [31:0] dbg_val;",
            "reg [31:0] debug_pc;",
            "reg r_dbg_stall;",
            "assign div_ce = (op_valid_div)&&(adf_ce_unconditional)&&(set_cond);",
            "assign fpu_ce = (IMPLEMENT_FPU)&&(op_valid_fpu)&&(adf_ce_unconditional)&&(set_cond); // }}} // // // PIPELINE STAGE #5 :: Write-back // Variable declarations // // {{{",
            "wire wr_write_pc, wr_write_cc, wr_write_scc, wr_write_ucc;",
            "reg wr_",
            "reg _ce, wr_flags_ce;",
            "reg [3:0] wr_flags;",
            "reg [2:0] wr_index;",
            "wire [4:0] wr_",
            "reg _id;",
            "reg [31:0] wr_gp",
            "reg _vl, wr_sp",
            "reg _vl;",
            "wire w_switch_to_interrupt, w_release_from_interrupt;",
            "reg [(AW+1):0] ipc;",
            "wire [(AW+1):0] upc;",
            "reg last_write_to_cc;",
            "wire cc_write_hold;",
            "reg r_clear_icache;",
            "reg pfpcset;",
            "reg [2:0] pfpcsrc;",
            "wire w_clken; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // MASTER: clock enable. // {{{ //////////////////////////////////////////////////////////////////////// // // assign master_ce = (!i_halt || alu_phase) &&(!cc_write_hold)&&(!o_break)&&(!sleep); // }}} //////////////////////////////////////////////////////////////////////// // // Calculate stall conditions // {{{ //////////////////////////////////////////////////////////////////////// // // // PIPELINE STAGE #1 :: Prefetch // These are calculated externally, within the prefetch",
            "module . // // PIPELINE STAGE #2 :: Instruction Decode // {{{",
            "always @(*) if (OPT_PIPELINED) dcd_stalled = (dcd_valid && op_stall); else dcd_stalled = (!master_ce) // Can't step forward when we need to be halted ||(ill_err_i)||(ibus_err_flag)||(idiv_err_flag) ||((dcd_valid || op_valid) && !dcd_early_branch) ||(alu_busy)||(div_busy)||(fpu_busy)||(i_mem_busy); // }}} // // PIPELINE STAGE #3 :: Read Operands // {{{ generate if (OPT_PIPELINED) begin : GEN_OP_STALL",
            "reg r_cc_invalid_for_dcd;",
            "reg r_pending_s",
            "reg _write; // cc_invalid_for_dcd // {{{",
            "initial r_cc_invalid_for_dcd = 1'b0;",
            "always @(posedge i_clk) if (clear_pipeline) r_cc_invalid_for_dcd <= 1'b0; else if ((alu_ce || mem_ce)&&(set_cond)&&(op_valid) &&((op_wF) ||((op_wR)&&(op_R[4:0] == { op_gie, CPU_CC_REG })))) // If an instruction in the pipeline will write to the // CC",
            "reg ister, then we can't be allowed to release // any instruction depending upon the CC",
            "reg ister // (for other than conditional execution) into the // pipeline. r_cc_invalid_for_dcd <= 1'b1; else if (r_cc_invalid_for_dcd) // While the pipeline is busy, keep r_cc_invalid_for_dcd // high. r_cc_invalid_for_dcd <= ((alu_busy)||(i_mem_rdbusy)||(div_busy)||(fpu_busy)); else r_cc_invalid_for_dcd <= 1'b0;",
            "assign cc_invalid_for_dcd = r_cc_invalid_for_dcd; // }}} // pending_s",
            "reg _write // {{{ // Used to determine if we need to stall for flags to be ready",
            "initial r_pending_s",
            "reg _write = 1'b0;",
            "always @(posedge i_clk) if (clear_pipeline) r_pending_s",
            "reg _write <= 1'b0; else if (((adf_ce_unconditional)||(mem_ce)) &&(set_cond)&&(!op_illegal) &&(op_wR) &&(op_R[3:1] == 3'h7) &&(op_R[4:0] != { gie, 4'hf })) r_pending_s",
            "reg _write <= 1'b1; else if ((!i_mem_rdbusy)&&(!alu_busy)) r_pending_s",
            "reg _write <= 1'b0;",
            "assign pending_s",
            "reg _write = r_pending_s",
            "reg _write; // }}}",
            "assign op_stall = (op_valid)&&( // {{{ // Only stall if we're loaded w/valid insns and the // next stage is accepting our instruction (!adf_ce_unconditional)&&(!mem_ce) ) ||(dcd_valid)&&( // If we are halted, then accepting anything // into the Op stage might accept a",
            "reg ister // that then gets modified by the debugging // interface so as to be invalid. i_halt // Stall if we need to wait for an operand A // to be ready to read || (dcd_A_stall) // Likewise for B, also includes",
            "logic // reg arding immediate offset (",
            "reg ister must // be in",
            "reg ister file if we need to add to // an immediate) ||(dcd_B_stall) // Or if we need to wait on flags to work on the // CC",
            "reg ister ||(dcd_F_stall) ); // }}}",
            "assign op_ce = ((dcd_valid)||(dcd_illegal)||(dcd_early_branch))&&(!op_stall); end else begin : NO_OP_STALLS // !OPT_PIPELINED // {{{",
            "assign op_stall = 1'b0; // (o_break)||(pending_interrupt);",
            "assign op_ce = ((dcd_valid)||(dcd_early_branch))&&(!op_stall);",
            "assign pending_s",
            "reg _write = 1'b0;",
            "assign cc_invalid_for_dcd = 1'b0; // verilator coverage_off // Verilator lint_off UNUSED",
            "wire pipe_unused;",
            "assign pipe_unused = &{ 1'b0, cc_invalid_for_dcd, pending_s",
            "reg _write }; // Verilator lint_on UNUSED // verilator coverage_on // }}} end endgenerate // BUT ... op_ce is too complex for many of the data operations. So // let's make their circuit enable code simpler. In particular, if // op_ doesn't need to be preserved, we can change it all we want // ... right? The clear_pipeline code, for example, really only needs // to determine whether op_valid is true. // assign op_change_data_ce = (!op_stall); // }}} // // PIPELINE STAGE #4 :: ALU / Memory // {{{ // 1. Basic stall is if the previous stage is valid and the next is // busy. // 2. Also stall if the prior stage is valid and the master clock enable // is de-selected // 3. Stall if someone on the other end is writing the CC",
            "reg ister, // since we don't know if it'll put us to sleep or not. // 4. Last case: Stall if we would otherwise move a break instruction // through the ALU. Break instructions are not allowed through // the ALU. generate if (OPT_PIPELINED) begin : GEN_ALU_STALL // alu_stall, alu_ce // {{{",
            "assign alu_stall = (((master_stall)||(i_mem_rdbusy))&&(op_valid_alu)) //Case 1&2 ||(wr_",
            "reg _ce)&&(wr_write_cc); // assign // alu_ce = (master_ce)&&(op_valid_alu)&&(!alu_stall) // &&(!clear_pipeline)&&(!op_illegal) // &&(!pending_s",
            "reg _write) // &&(!alu_s",
            "reg _stall);",
            "assign alu_ce = (adf_ce_unconditional)&&(op_valid_alu); // verilator coverage_off // Verilator lint_off unused",
            "wire unused_alu_stall = &{ 1'b0, alu_stall }; // Verilator lint_on unused // verilator coverage_on // }}} end else begin : NO_ALU_STALLS // alu_stall, alu_ce // {{{",
            "assign alu_stall = (master_stall); // assign alu_ce = (master_ce)&&(op_valid_alu) // &&(!clear_pipeline) // &&(!alu_stall);",
            "assign alu_ce = (adf_ce_unconditional)&&(op_valid_alu); // verilator coverage_off // Verilator lint_off unused",
            "wire unused_alu_stall = &{ 1'b0, alu_stall }; // Verilator lint_on unused // verilator coverage_on // }}} end endgenerate // // mem_ce // {{{ // Note: if you change the conditions for mem_ce, you must also change // alu_pc_valid. // assign mem_ce = (master_ce)&&(op_valid_mem)&&(!mem_stalled) &&(!clear_pipeline); // }}} // mem_stalled // {{{ generate if (OPT_PIPELINED_BUS_ACCESS) begin : GEN_PIPELINE_MEM_STALL // {{{",
            "assign mem_stalled = (master_stall)||((op_valid_mem)&&( (i_mem_pipe_stalled) ||(i_bus_err)||(div_error) ||(!op_pipe && i_mem_busy) // Stall waiting for flags to be valid // Or waiting for a write to the PC",
            "reg ister // Or CC",
            "reg ister, since that can change the // PC as well ||((wr_",
            "reg _ce) &&((wr_write_pc)||(wr_write_cc))))); // }}} end else if (OPT_PIPELINED) begin : GEN_MEM_STALL // {{{",
            "assign mem_stalled = (master_stall)||((op_valid_mem)&&( (i_bus_err)||(div_error)||(i_mem_busy) // Stall waiting for flags to be valid // Or waiting for a write to the PC",
            "reg ister // Or CC",
            "reg ister, since that can change the // PC as well ||((wr_",
            "reg _ce) &&((wr_write_pc)||(wr_write_cc))))); // }}} end else begin : NO_MEM_STALL // {{{",
            "assign mem_stalled = master_stall || i_mem_busy; // }}} end endgenerate // }}} // }}} // // Master stall condition // {{{",
            "assign master_stall = (!master_ce)||(!op_valid)||(ill_err_i) ||(step && stepped) ||(ibus_err_flag)||(idiv_err_flag) ||(pending_interrupt && !o_bus_lock)&&(!alu_phase) ||(alu_busy)||(div_busy)||(fpu_busy)||(op_break) ||((OPT_PIPELINED)&&( prelock_stall ||((i_mem_busy)&&(op_illegal)) ||((i_mem_busy)&&(op_valid_div)) ||(alu_illegal)||(o_break))); // }}} // // (Everything but memory) stall condition // {{{ // ALU, DIV, or FPU CE ... equivalent to the OR of all three of these",
            "always @(*) if (OPT_PIPELINED) adf_ce_unconditional = (!master_stall)&&(!op_valid_mem)&&(!i_mem_rdbusy) &&(!i_mem_busy || !op_wR || op_R[4:0] != { gie, CPU_CC_REG }); else adf_ce_unconditional = (!master_stall)&&(op_valid)&&(!op_valid_mem); // }}} // }}} //////////////////////////////////////////////////////////////////////// // // PIPELINE STAGE #1 :: Instruction fetch // {{{ //////////////////////////////////////////////////////////////////////// // // assign o_pf_ready = (!dcd_stalled && !dcd_phase);",
            "assign o_pf_new_pc = (new_pc)||((dcd_early_branch_stb)&&(!clear_pipeline));",
            "assign o_pf_request_address = ((dcd_early_branch_stb)&&(!clear_pipeline)) ? dcd_branch_pc:pf_pc;",
            "assign pf_gie = gie; // }}} //////////////////////////////////////////////////////////////////////// // // PIPELINE STAGE #2 :: Instruction Decode // {{{ //////////////////////////////////////////////////////////////////////// // // assign dcd_ce =((OPT_PIPELINED)&&(!dcd_valid))||(!dcd_stalled);",
            "wire [6:0] dcd_full_R, dcd_full_A, dcd_full_B; idecode #( // {{{ .ADDRESS_WIDTH(AW), .OPT_MPY((OPT_MPY!=0)? 1'b1:1'b0), .OPT_SHIFTS(OPT_SHIFTS), .OPT_PIPELINED(OPT_PIPELINED), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_DIVIDE(OPT_DIV), .OPT_FPU(IMPLEMENT_FPU), .OPT_LOCK(OPT_LOCK), .OPT_OPIPE(OPT_PIPELINED_BUS_ACCESS), .OPT_USERMODE(OPT_USERMODE), .OPT_SIM(OPT_SIM), .OPT_CIS(OPT_CIS), .OPT_LOWPOWER(OPT_LOWPOWER) // }}} ) instruction_decoder( // {{{ .i_clk(i_clk), .i_reset(i_reset||clear_pipeline||o_clear_icache), .i_ce(dcd_ce), .i_stalled(dcd_stalled), .i_instruction(i_pf_instruction), .i_gie(pf_gie), .i_pc(i_pf_instruction_pc), .i_pf_valid(i_pf_valid), .i_illegal(i_pf_illegal), .o_valid(dcd_valid), .o_phase(dcd_phase), .o_illegal(dcd_illegal), .o_pc(dcd_pc), .o_dcdR(dcd_full_R), .o_dcdA(dcd_full_A), .o_dcdB(dcd_full_B), .o_preA(dcd_preA), .o_preB(dcd_preB), .o_I(dcd_I), .o_zI(dcd_zI), .o_cond(dcd_F), .o_wF(dcd_wF), .o_op(dcd_opn), .o_ALU(dcd_ALU), .o_M(dcd_M), .o_DV(dcd_DIV), .o_FP(dcd_FP), .o_break(dcd_break), .o_lock(dcd_lock), .o_wR(dcd_wR), .o_rA(dcd_rA), .o_rB(dcd_rB), .o_early_branch(dcd_early_branch), .o_early_branch_stb(dcd_early_branch_stb), .o_branch_pc(dcd_branch_pc), .o_ljmp(dcd_ljmp), .o_pipe(dcd_pipe), .o_sim(dcd_sim), .o_sim_immv(dcd_sim_immv) `ifdef FORMAL , .f_insn_word(f_dcd_insn_word), .f_insn_gie(f_dcd_insn_gie), .f_insn_is_pipeable(f_dcd_insn_is_pipeable) `endif // }}} );",
            "assign { dcd_Rcc, dcd_Rpc, dcd_R } = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ? dcd_full_R : 7'h0;",
            "assign { dcd_Acc, dcd_Apc, dcd_A } = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ? dcd_full_A : 7'h0;",
            "assign { dcd_Bcc, dcd_Bpc, dcd_B } = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ? dcd_full_B : 7'h0;",
            "assign dcd_gie = pf_gie; // }}} //////////////////////////////////////////////////////////////////////// // // PIPELINE STAGE #3 :: Read Operands (Registers) // {{{ //////////////////////////////////////////////////////////////////////// // // // op_pipe // {{{ generate if (OPT_PIPELINED_BUS_ACCESS) begin : GEN_OP_PIPE // Memory pipelining",
            "reg r_op_pipe; // To be a pipeable operation, there must be // two valid adjacent instructions // Both must be memory instructions // Both must be writes, or both must be reads // Both operations must be to the same identical address, // or at least a single (one) increment above that // address // // However ... we need to know this before this clock, hence // this is calculated in the instruction decoder.",
            "initial r_op_pipe = 1'b0;",
            "always @(posedge i_clk) if ((OPT_LOWPOWER && i_reset)||(clear_pipeline)||(i_halt)) r_op_pipe <= 1'b0; else if (op_ce) r_op_pipe <= (dcd_pipe)&&(op_valid_mem)&&(!OPT_LOWPOWER || !dcd_illegal); else if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == op_Bid[4:0])) r_op_pipe <= 1'b0; else if (mem_ce) // Clear us any time an op_ is clocked in r_op_pipe <= 1'b0;",
            "assign op_pipe = r_op_pipe; `ifdef FORMAL",
            "always @(*) if (OPT_LOWPOWER && !op_valid_mem) assert(!r_op_pipe); `endif end else begin : NO_OP_PIPE",
            "assign op_pipe = 1'b0; end endgenerate // }}} // Read from our",
            "reg ister set // {{{ generate if (OPT_DISTRIBUTED_REGS) begin : GEN_DISTRIBUTED_REGS // {{{ if (OPT_USERMODE) begin : GEN_FULL_REGSET",
            "assign w_op_Av = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ?",
            "reg set[dcd_A] : 32'h0;",
            "assign w_op_Bv = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ?",
            "reg set[dcd_B] : 32'h0; end else begin : GEN_NO_USERREGS",
            "assign w_op_Av = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ?",
            "reg set[dcd_A[3:0]] : 32'h0;",
            "assign w_op_Bv = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ?",
            "reg set[dcd_B[3:0]] : 32'h0; end // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused_pre",
            "reg _addrs;",
            "assign unused_pre",
            "reg _addrs = &{ 1'b0, dcd_preA, dcd_preB }; // verilator lint_on UNUSED // verilator coverage_on // }}} end else begin : GEN_BLOCKRAM // {{{",
            "reg [31:0] pre_rewrite_value, pre_op_Av, pre_op_Bv;",
            "reg pre_rewrite_flag_A, pre_rewrite_flag_B;",
            "always @(posedge i_clk) if (dcd_ce) begin pre_rewrite_flag_A <= (wr_",
            "reg _ce)&&(dcd_preA == wr_",
            "reg _id); pre_rewrite_flag_B <= (wr_",
            "reg _ce)&&(dcd_preB == wr_",
            "reg _id); pre_rewrite_value <= wr_gp",
            "reg _vl; end else if (OPT_PIPELINED && dcd_valid) begin pre_rewrite_flag_A <= (wr_",
            "reg _ce)&&(dcd_A == wr_",
            "reg _id); pre_rewrite_flag_B <= (wr_",
            "reg _ce)&&(dcd_B == wr_",
            "reg _id); pre_rewrite_value <= wr_gp",
            "reg _vl; end if (OPT_USERMODE) begin : GEN_FULL_REGSET",
            "always @(posedge i_clk) if (dcd_ce || (OPT_PIPELINED && dcd_valid)) pre_op_Av <=",
            "reg set[dcd_ce ? dcd_preA : dcd_A];",
            "always @(posedge i_clk) if (dcd_ce || (OPT_PIPELINED && dcd_valid)) pre_op_Bv <=",
            "reg set[dcd_ce ? dcd_preB : dcd_B]; end else begin : GEN_NO_USERREGS",
            "always @(posedge i_clk) if (dcd_ce || (OPT_PIPELINED && dcd_valid)) pre_op_Av <=",
            "reg set[dcd_ce ? dcd_preA[3:0] : dcd_A[3:0]];",
            "always @(posedge i_clk) if (dcd_ce || (OPT_PIPELINED && dcd_valid)) pre_op_Bv <=",
            "reg set[dcd_ce ? dcd_preB[3:0] : dcd_B[3:0]]; end",
            "assign w_op_Av = (pre_rewrite_flag_A) ? pre_rewrite_value : pre_op_Av;",
            "assign w_op_Bv = (pre_rewrite_flag_B) ? pre_rewrite_value : pre_op_Bv; // }}} end endgenerate // }}}",
            "assign w_cpu_info = { // {{{ 1'b1, (OPT_MPY >0)? 1'b1:1'b0, (OPT_DIV >0)? 1'b1:1'b0, (IMPLEMENT_FPU >0)? 1'b1:1'b0, OPT_PIPELINED, 1'b0, (OPT_EARLY_BRANCHING > 0)? 1'b1:1'b0, OPT_PIPELINED_BUS_ACCESS, OPT_CIS }; // }}}",
            "always @(*) begin w_pcA_v = 0; if ((!OPT_USERMODE)||(dcd_A[4] == dcd_gie)) w_pcA_v[(AW+1):0] = { dcd_pc[AW+1:2], 2'b00 }; else w_pcA_v[(AW+1):0] = { upc[(AW+1):2], uhalt_phase, 1'b0 }; end // Op",
            "reg ister addresses // {{{ generate if (OPT_PIPELINED) begin : OP_REG_ADVANEC // {{{",
            "reg [4:0] r_op_R;",
            "reg [4:0] r_op_Aid, r_op_Bid;",
            "reg r_op_rA, r_op_rB;",
            "initial r_op_R = 0;",
            "initial r_op_Aid = 0;",
            "initial r_op_Bid = 0;",
            "initial r_op_rA = 0;",
            "initial r_op_rB = 0;",
            "initial op_Rcc = 0;",
            "always @(posedge i_clk) begin if (op_ce && (!OPT_LOWPOWER || w_op_valid)) begin r_op_R <= dcd_R; r_op_Aid <= dcd_A; if ((dcd_rB)&&(!dcd_early_branch)&&(!dcd_illegal)) r_op_Bid <= dcd_B; r_op_rA <= (dcd_rA)&&(!dcd_early_branch)&&(!dcd_illegal); r_op_rB <= (dcd_rB)&&(!dcd_early_branch)&&(!dcd_illegal); op_Rcc <= (dcd_Rcc)&&(dcd_wR)&&(dcd_R[4]==dcd_gie); end if (op_lowpower_clear) begin r_op_rA <= 1'b0; r_op_rB <= 1'b0; end end",
            "assign op_R = r_op_R;",
            "assign op_Aid = r_op_Aid;",
            "assign op_Bid = r_op_Bid;",
            "assign op_rA = r_op_rA;",
            "assign op_rB = r_op_rB; // }}} end else begin : OP_REG_COPY // {{{",
            "assign op_R = dcd_R;",
            "assign op_Aid = dcd_A;",
            "assign op_Bid = dcd_B;",
            "assign op_rA = dcd_rA;",
            "assign op_rB = dcd_rB;",
            "always @(*) op_Rcc = (dcd_Rcc)&&(dcd_wR)&&(dcd_R[4]==dcd_gie); // }}} end endgenerate // }}} // r_op_Av -- The",
            "reg istered value of the op A",
            "reg ister // {{{",
            "reg [2:0] avsrc;",
            "reg [2:0] bvsrc;",
            "reg [1:0] bisrc;",
            "always @(*) begin avsrc = 3'b000; if (!OPT_PIPELINED || op_ce) begin if (dcd_Apc) avsrc = 3'b101; else if (dcd_Acc) avsrc = 3'b110; else avsrc = 3'b111; end if (OPT_PIPELINED && wr_",
            "reg _ce) begin if (!op_ce && wr_",
            "reg _id == op_Aid && op_rA) avsrc = 3'b100; else if (op_ce && wr_",
            "reg _id == dcd_A) avsrc = 3'b100; end end // 44313",
            "initial r_op_Av = 0;",
            "always @(posedge i_clk) begin if (avsrc[2]) case(avsrc[1:0]) 2'b00: r_op_Av <= wr_gp",
            "reg _vl; 2'b01: r_op_Av <= w_pcA_v; 2'b10: r_op_Av <= { w_cpu_info, w_op_Av[22:16], (dcd_A[4])?w_uflags:w_iflags }; 2'b11: r_op_Av <= w_op_Av; endcase if (op_lowpower_clear) r_op_Av <= 0; end // }}} // w_op_B -- The",
            "reg istered value of the op B",
            "reg ister // {{{",
            "always @(*) begin w_pcB_v = 0; if ((!OPT_USERMODE)||(dcd_B[4] == dcd_gie)) w_pcB_v[(AW+1):0] = { dcd_pc[AW+1:2], 2'b00 }; else w_pcB_v[(AW+1):0] = { upc[(AW+1):2], uhalt_phase, 1'b0 }; end",
            "always @(*) if (!dcd_rB) bisrc = 0; else if ((OPT_PIPELINED)&&(wr_",
            "reg _ce)&&(wr_",
            "reg _id == dcd_B)) bisrc = 1; else if (dcd_Bcc) bisrc = 2; else bisrc = 3;",
            "always @(*) case(bisrc[1:0]) 2'b00: w_op_BnI = 0; 2'b01: w_op_BnI = wr_gp",
            "reg _vl; 2'b10: w_op_BnI = { w_cpu_info, w_op_Bv[22:16], (dcd_B[4]) ? w_uflags : w_iflags }; 2'b11: w_op_BnI = w_op_Bv; endcase",
            "always @(*) begin bvsrc = 0; if ((!OPT_PIPELINED)||(op_ce)) begin if ((dcd_Bpc)&&(dcd_rB)) bvsrc = 3'b100; else bvsrc = 3'b101; end else if ((OPT_PIPELINED)&&(op_rB) &&(wr_",
            "reg _ce)&&(op_Bid == wr_",
            "reg _id)) bvsrc = 3'b110; end",
            "initial r_op_Bv = 0;",
            "always @(posedge i_clk) begin if (bvsrc[2]) casez(bvsrc[1:0]) 2'b00: r_op_Bv <= w_pcB_v + { dcd_I[29:0], 2'b00 }; 2'b01: r_op_Bv <= w_op_BnI + dcd_I; 2'b1?: r_op_Bv <= wr_gp",
            "reg _vl; endcase if (op_lowpower_clear) r_op_Bv <= 0; end // }}} // op_F // {{{ // The",
            "logic here has become more complex than it should be, no thanks // to Xilinx's Vivado trying to help. The conditions are supposed to // be two sets of four bits: the top bits specify what bits matter, the // bottom specify what those top bits must equal. However, two of // conditions check whether bits are on, and those are the only two // conditions checking those bits. Therefore, Vivado complains that // these two bits are redundant. Hence the convoluted expression // below, arriving at what we finally want in the (now",
            "wire net) // op_F.",
            "initial r_op_F = 7'h00;",
            "always @(posedge i_clk) begin if ((!OPT_PIPELINED)||(op_ce)) // Cannot do op_change_data_ce here since op_F depends // upon being either correct for a valid op, or correct // for the last valid op begin // Set the flag condition codes, bit order is [3:0]=VNCZ case(dcd_F[2:0]) 3'h0: r_op_F <= 7'h00; // Always 3'h1: r_op_F <= 7'h11; // Z 3'h2: r_op_F <= 7'h44; // LT 3'h3: r_op_F <= 7'h22; // C 3'h4: r_op_F <= 7'h08; // V 3'h5: r_op_F <= 7'h10; // NE 3'h6: r_op_F <= 7'h40; // GE (!N) 3'h7: r_op_F <= 7'h20; // NC endcase end if (op_lowpower_clear) r_op_F <= 7'h00; end // Bit order is { (flags_not_used), VNCZ mask, VNCZ value }",
            "assign op_F = { r_op_F[3], r_op_F[6:0] }; // }}} // op_valid // {{{",
            "assign w_op_valid = (!clear_pipeline)&&(dcd_valid) &&(!dcd_ljmp)&&(!dcd_early_branch);",
            "initial op_valid = 1'b0;",
            "initial op_valid_alu = 1'b0;",
            "initial op_valid_mem = 1'b0;",
            "initial op_valid_div = 1'b0;",
            "initial op_valid_fpu = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(clear_pipeline)) begin // {{{ op_valid <= 1'b0; op_valid_alu <= 1'b0; op_valid_mem <= 1'b0; op_valid_div <= 1'b0; op_valid_fpu <= 1'b0; // }}} end else if (op_ce) begin // {{{ // Do we have a valid instruction? // The decoder may vote to stall one of its // instructions based upon something we currently // have in our queue. This instruction must then // move forward, and get a stall cycle inserted. // Hence, the test on dcd_stalled here. If we must // wait until our operands are valid, then we aren't // valid yet until then. if (OPT_PIPELINED || !op_valid) begin op_valid <= (w_op_valid)||(dcd_early_branch); op_valid_alu <= (w_op_valid)&&((dcd_ALU)||(dcd_illegal)); op_valid_mem <= (dcd_M)&&(!dcd_illegal) &&(w_op_valid); op_valid_div <= (OPT_DIV)&&(dcd_DIV)&&(!dcd_illegal)&&(w_op_valid); op_valid_fpu <= (IMPLEMENT_FPU)&&(dcd_FP)&&(!dcd_illegal)&&(w_op_valid); end else if ((adf_ce_unconditional)||(mem_ce)) begin op_valid <= 1'b0; op_valid_alu <= 1'b0; op_valid_mem <= 1'b0; op_valid_div <= 1'b0; op_valid_fpu <= 1'b0; end // }}} end else if ((adf_ce_unconditional)||(mem_ce)) begin // {{{ // If nothing advances into the OP stage, yet what was in // the OP stage moves forward, then we need to invalidate what // used to be here. op_valid <= 1'b0; op_valid_alu <= 1'b0; op_valid_mem <= 1'b0; op_valid_div <= 1'b0; op_valid_fpu <= 1'b0; // }}} end // }}} // op_lowpower_clear // {{{ generate if (!OPT_LOWPOWER || !OPT_PIPELINED) begin : NO_OP_LOWPOWER_CLEAR",
            "assign op_lowpower_clear = 1'b0; end else begin : GEN_OP_LOWPOWER_CLEAR",
            "reg r_op_lowpower_clear;",
            "always @(*) if (i_reset || clear_pipeline) r_op_lowpower_clear = 1'b1; else if (op_ce && !w_op_valid) r_op_lowpower_clear = 1'b1; else if ((!op_ce || !w_op_valid)&&(adf_ce_unconditional || mem_ce)) r_op_lowpower_clear = 1'b1; else r_op_lowpower_clear = 1'b0;",
            "assign op_lowpower_clear = r_op_lowpower_clear; end endgenerate // }}} // op_break // {{{ // Here's part of our debug interface. When we recognize a break // instruction, we set the op_break flag. That'll prevent this // instruction from entering the ALU, and cause an interrupt before // this instruction. Thus, returning to this code will cause the // break to repeat and continue upon return. To get out of this // condition, replace the break instruction with what it is supposed // to be, step through it, and then replace it back. In this fashion, // a debugger can step through code. // assign w_op_break = (dcd_break)&&(r_dcd_I[15:0] == 16'h0001);",
            "initial r_op_break = 1'b0;",
            "always @(posedge i_clk) if (clear_pipeline) r_op_break <= 1'b0; else if ((OPT_PIPELINED)&&(op_ce)) r_op_break <= (dcd_valid)&&(dcd_break)&&(!dcd_illegal); else if ((!OPT_PIPELINED)&&(dcd_valid)) r_op_break <= (dcd_break)&&(!dcd_illegal)&&(!step || !stepped);",
            "assign op_break = r_op_break; `ifdef FORMAL",
            "always @(*) if (op_break) assert(op_valid || clear_pipeline); `endif // }}} // op_lock // {{{ generate if (!OPT_LOCK) begin : NO_OPLOCK",
            "assign op_lock = 1'b0; // verilator coverage_off // Verilator lint_off UNUSED",
            "wire dcd_lock_unused;",
            "assign dcd_lock_unused = &{ 1'b0, dcd_lock }; // Verilator lint_on UNUSED // verilator coverage_on end else // if (!OPT_LOCK) begin : GEN_OPLOCK",
            "reg r_op_lock;",
            "initial r_op_lock = 1'b0;",
            "always @(posedge i_clk) if (clear_pipeline) r_op_lock <= 1'b0; else if (op_ce) r_op_lock <= (dcd_valid)&&(dcd_lock) &&(!dcd_illegal);",
            "assign op_lock = r_op_lock; end endgenerate // }}} // op_illegal // {{{",
            "initial op_illegal = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(clear_pipeline)) op_illegal <= 1'b0; else if (OPT_PIPELINED) begin if (op_ce) op_illegal <= (dcd_valid)&&(!dcd_ljmp) &&(!dcd_early_branch)&&(dcd_illegal); end else if (!OPT_PIPELINED) begin if (dcd_valid) op_illegal <= (!dcd_ljmp)&&(!dcd_early_branch)&&(dcd_illegal); end // }}} // op_wF // {{{",
            "always @(posedge i_clk) begin if ((!OPT_PIPELINED)||(op_ce)) op_wF <= (dcd_wF)&&((!dcd_Rcc)||(!dcd_wR)) &&(!dcd_early_branch); if (op_lowpower_clear) op_wF <= 1'b0; end // }}} // op_wR // {{{ generate if ((OPT_PIPELINED)||(OPT_EARLY_BRANCHING)) begin : GEN_OP_WR",
            "reg r_op_wR;",
            "initial r_op_wR = 1'b0;",
            "always @(posedge i_clk) begin if (op_ce) r_op_wR <= (dcd_wR)&&(!dcd_early_branch); if (op_lowpower_clear) r_op_wR <= 1'b0; end",
            "assign op_wR = r_op_wR; end else begin : COPY_OP_WR",
            "assign op_wR = dcd_wR; end endgenerate // }}} // op_sim, op_sim_immv // {{{ generate if (OPT_SIM) begin : OP_SIM // // Only execute this if OPT_SIM is true--that is, if we // are running from a simulated environment. // reg r_op_sim;",
            "reg [22:0] r_op_sim_immv;",
            "always @(posedge i_clk) if (op_ce) begin r_op_sim <= dcd_sim && (!OPT_LOWPOWER || w_op_valid); r_op_sim_immv <= dcd_sim_immv; if (OPT_LOWPOWER && (!dcd_sim || !w_op_valid)) r_op_sim_immv <= 0; end else if (adf_ce_unconditional) begin r_op_sim <= 1'b0; if (OPT_LOWPOWER) r_op_sim_immv <= 0; end",
            "assign op_sim = r_op_sim;",
            "assign op_sim_immv = r_op_sim_immv; end else begin : NO_OP_SIM",
            "assign op_sim = 0;",
            "assign op_sim_immv = 0; // verilator coverage_off // Verilator lint_off UNUSED",
            "wire op_sim_unused;",
            "assign op_sim_unused = &{ 1'b0, dcd_sim, dcd_sim_immv }; // Verilator lint_on UNUSED // verilator coverage_on end endgenerate // }}} // op_pc // {{{ generate if ((OPT_PIPELINED)||(OPT_EARLY_BRANCHING)) begin : SET_OP_PC",
            "reg [AW+1:0] r_op_pc;",
            "initial r_op_pc[0] = 1'b0;",
            "always @(posedge i_clk) if (op_ce) begin if (dcd_early_branch) // Need to retire an early branch as a NOOP, // to make sure our PC is properly updated r_op_pc <= dcd_branch_pc; else if (!OPT_LOWPOWER || w_op_valid) r_op_pc <= dcd_pc; end",
            "assign op_pc = r_op_pc; end else begin : SET_OP_PC",
            "assign op_pc = dcd_pc; end endgenerate // }}} // op_opn -- the opcode of the current operation // {{{ generate if (!OPT_PIPELINED) begin : COPY_DCD_OPN",
            "assign op_opn = dcd_opn; end else begin : FWD_OPERATION",
            "reg [3:0] r_op_opn;",
            "always @(posedge i_clk) if (op_ce && (!OPT_LOWPOWER || w_op_valid || dcd_early_branch)) begin // Which ALU operation? Early branches are // unimplemented moves r_op_opn <= ((dcd_early_branch)||(dcd_illegal)) ? CPU_MOV_OP : dcd_opn; // opM <= dcd_M; // Is this a memory operation? // What",
            "reg ister will these results be written into? end",
            "assign op_opn = r_op_opn; end endgenerate // }}}",
            "assign op_gie = gie;",
            "assign op_Fl = (op_gie)?(w_uflags[3:0]):(w_iflags[3:0]); // op_phase // {{{ generate if (OPT_CIS) begin : OPT_CIS_OP_PHASE",
            "reg r_op_phase;",
            "initial r_op_phase = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(clear_pipeline)) r_op_phase <= 1'b0; else if (op_ce) r_op_phase <= (dcd_phase)&&((!dcd_wR)||(!dcd_Rpc));",
            "assign op_phase = r_op_phase; end else begin : OPT_NOCIS_OP_PHASE",
            "assign op_phase = 1'b0; // verilator lint_off UNUSED",
            "wire OPT_CIS_dcdRpc;",
            "assign OPT_CIS_dcdRpc = dcd_Rpc; // verilator lint_on UNUSED end endgenerate // }}} // op_Av -- the combinatorial A value",
            "input to the ALU/MEM/DIV stage // {{{ // This is tricky. First, the PC and Flags",
            "reg isters aren't kept in // reg ister set but in special",
            "reg isters of their own. So step one // is to select the right",
            "reg ister. Step to is to replace that // reg ister with the results of an ALU or memory operation, if such // results are now available. Otherwise, we'd need to insert a wait // state of some type. // // The alternative approach would be to define some sort of // op_stall",
            "wire , which would stall any upstream stage. // We'll create a flag here to start our coordination. Once we // define this flag to something other than just plain zero, then // the stalls will already be in place. generate if (OPT_PIPELINED) begin : FWD_OP_AV",
            "assign op_Av = ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == op_Aid)) ? wr_gp",
            "reg _vl : r_op_Av; end else begin : COPY_OP_AV",
            "assign op_Av = r_op_Av; end endgenerate // }}} // dcd_A_stall // {{{ // Stall if we have decoded an instruction that will read",
            "reg ister A // AND ... something that may write a",
            "reg ister is running // AND (series of conditions here ...) // The operation might set flags, and we wish to read the // CC",
            "reg ister // OR ... (No other conditions) generate if (OPT_PIPELINED) begin : GEN_DCDA_STALL",
            "assign dcd_A_stall = (dcd_rA) // &&(dcd_valid) is checked for elsewhere &&((op_valid)||(i_mem_rdbusy) ||(div_busy)||(fpu_busy)) &&(((op_wF)||(cc_invalid_for_dcd))&&(dcd_Acc)) ||((dcd_rA)&&(dcd_Acc)&&(cc_invalid_for_dcd)); end else begin : NO_DCDA_STALL // There are no pipeline hazards, if we aren't pipelined",
            "assign dcd_A_stall = 1'b0; end endgenerate // }}} // op_Bv // {{{",
            "assign op_Bv = ((OPT_PIPELINED)&&(wr_",
            "reg _ce) &&(wr_",
            "reg _id == op_Bid)&&(op_rB)) ? wr_gp",
            "reg _vl: r_op_Bv; // }}} // dcd_B_stall, dcd_F_stall // {{{ generate if (OPT_PIPELINED) begin : DCD_BF_STALLS // Stall if we have decoded an instruction that will read",
            "reg ister B // AND ... something that may write a (unknown)",
            "reg ister is running // AND (series of conditions here ...) // The operation might set flags, and we wish to read the // CC",
            "reg ister // OR the operation might set",
            "reg ister B, and we still need // a clock to add the offset to it",
            "assign dcd_B_stall = (dcd_rB) // &&(dcd_valid) is checked for elsewhere // {{{ // If the op stage isn't valid, yet something // is running, then it must have been valid. // We'll use the last values from that stage // (op_wR, op_wF, op_R) in our",
            "logic below. &&((op_valid)||(i_mem_rdbusy) ||(div_busy)||(fpu_busy)||(alu_busy)) &&( // Okay, what happens if the result",
            "reg ister // from instruction 1 becomes the",
            "input for // instruction two, *and* there's an immediate // offset in instruction two? In that case, we // need an extra clock between the two // instructions to calculate the base plus // offset. // // What if instruction 1 (or before) is in a // memory pipeline? We may no longer know what // the",
            "reg ister was! We will then need to // blindly wait. We'll temper this only waiting // if we're not piping this new instruction. // If we were piping, the pipe",
            "logic in the // decode circuit has told us that the hazard // is clear, so we're okay then. // ((!dcd_zI)&&( ((op_R == dcd_B)&&(op_wR)) ||((i_mem_rdbusy)&&(!dcd_pipe)) ||(((alu_busy || div_busy || i_mem_rdbusy)) &&(alu_",
            "reg == dcd_B)) ||((wr_",
            "reg _ce)&&(wr_",
            "reg _id[3:1] == 3'h7)) )) // Stall following any instruction that will // set the flags, if we're going to need the // flags (CC)",
            "reg ister for op_B. ||(((op_wF)||(cc_invalid_for_dcd))&&(dcd_Bcc)) // Stall on any ongoing memory operation that // will write to op_B -- captured above // ||((i_mem_busy)&&(!mem_we)&&(mem_last_",
            "reg ==dcd_B)&&(!dcd_zI)) ) ||((dcd_rB)&&(dcd_Bcc)&&(cc_invalid_for_dcd)); // }}}",
            "assign dcd_F_stall = ((!dcd_F[3]) // {{{ ||((dcd_rA)&&(dcd_A[3:1]==3'h7) &&(dcd_A[4:0] != { gie, 4'hf})) ||((dcd_rB)&&(dcd_B[3:1]==3'h7)) &&(dcd_B[4:0] != { gie, 4'hf})) &&(((op_valid)&&(op_wR) &&(op_R[3:1]==3'h7) &&(op_R[4:0]!={gie, 4'hf})) ||(pending_s",
            "reg _write)); // &&(dcd_valid) is checked for elsewhere // }}} end else begin : NO_PIPELINE_NO_STALL // {{{ // No stalls without pipelining, 'cause how can you have a // pipeline hazard without the pipeline?",
            "assign dcd_B_stall = 1'b0;",
            "assign dcd_F_stall = 1'b0; // }}} end endgenerate // }}} // }}} //////////////////////////////////////////////////////////////////////// // // PIPELINE STAGE #4 :: Apply Instruction // {{{ //////////////////////////////////////////////////////////////////////// // // // The ALU itself cpuops #( // {{{ .OPT_MPY(OPT_MPY), .OPT_SHIFTS(OPT_SHIFTS), .OPT_LOWPOWER(OPT_LOWPOWER) // }}} ) doalu( // {{{ .i_clk(i_clk), .i_reset((i_reset)||(clear_pipeline)), .i_stb(alu_ce), .i_op((!OPT_LOWPOWER || alu_ce) ? op_opn : 4'h0), .i_a( (!OPT_LOWPOWER || alu_ce) ? op_Av : 32'h0), .i_b( (!OPT_LOWPOWER || alu_ce) ? op_Bv : 32'h0), .o_c(alu_result), .o_f(alu_flags), .o_valid(alu_valid), .o_busy(alu_busy) // }}} ); // Divide // {{{ generate if (OPT_DIV != 0) begin : DIVIDE `ifdef FORMAL `define DIVIDE_MODULE abs_div `else `define DIVIDE_MODULE div `endif `DIVIDE_MODULE #( .OPT_LOWPOWER(OPT_LOWPOWER) ) thedivide( // {{{ .i_clk(i_clk), .i_reset(i_reset || clear_pipeline), .i_wr(div_ce), .i_signed(op_opn[0]), .i_numerator(op_Av), .i_denominator(op_Bv), .o_busy(div_busy), .o_valid(div_valid), .o_err(div_error), .o_quotient(div_result), .o_flags(div_flags) // }}} ); end else begin : NO_DIVIDE // {{{",
            "assign div_error = 1'b0; // Can't be high unless div_valid",
            "assign div_busy = 1'b0;",
            "assign div_valid = 1'b0;",
            "assign div_result= 32'h00;",
            "assign div_flags = 4'h0; // Make verilator happy here // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused_divide;",
            "assign unused_divide = &{ 1'b0, div_ce }; // verilator lint_on UNUSED // verilator coverage_on // }}} end endgenerate // }}} // (Non-existent) FPU // {{{ generate if (IMPLEMENT_FPU != 0) begin : FPU // // sfpu thefpu(i_clk, i_reset, fpu_ce, op_opn[2:0], // op_Av, op_Bv, fpu_busy, fpu_valid, fpu_err, fpu_result, // fpu_flags); // `ifdef FORMAL abs_div thefpu(i_clk, ((i_reset)||(clear_pipeline)), fpu_ce, op_opn[2:0], op_Av, op_Bv, fpu_busy, fpu_valid, fpu_error, fpu_result, fpu_flags); `else",
            "assign fpu_error = 1'b0; // Must only be true if fpu_valid",
            "assign fpu_busy = 1'b0;",
            "assign fpu_valid = 1'b0;",
            "assign fpu_result= 32'h00;",
            "assign fpu_flags = 4'h0; `endif end else begin : GEN_NOFPU",
            "assign fpu_error = 1'b0;",
            "assign fpu_busy = 1'b0;",
            "assign fpu_valid = 1'b0;",
            "assign fpu_result= 32'h00;",
            "assign fpu_flags = 4'h0; end endgenerate // }}} // Condition handling // {{{",
            "assign set_cond = ((op_F[7:4]&op_Fl[3:0])==op_F[3:0]);",
            "initial alu_wF = 1'b0;",
            "initial alu_wR = 1'b0; generate if (OPT_PIPELINED) begin : GEN_COND_PIPELINED",
            "always @(posedge i_clk) if (i_reset) begin alu_wR <= 1'b0; alu_wF <= 1'b0; end else if (alu_ce) begin // alu_",
            "reg <= op_R; alu_wR <= (op_wR)&&(set_cond)&&(!op_illegal); alu_wF <= (op_wF)&&(set_cond)&&(!op_illegal); end else if (!alu_busy) begin // These are strobe signals, so clear them if they // aren't going to be set for any particular clock alu_wR <= (r_halted)&&(OPT_DBGPORT && i_dbg_we && !o_dbg_stall); alu_wF <= 1'b0; end end else begin : GEN_COND_NOPIPE",
            "always @(posedge i_clk) begin alu_wR <= (op_wR)&&(set_cond)&&(!op_illegal); alu_wF <= (op_wF)&&(set_cond)&&(!op_illegal); end end endgenerate // }}} // alu_phase // {{{ // Instruction phase (which half of the instruction we are on) tracking generate if (OPT_CIS) begin : GEN_ALU_PHASE",
            "reg r_alu_phase;",
            "initial r_alu_phase = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(clear_pipeline)) r_alu_phase <= 1'b0; else if (((adf_ce_unconditional)||(mem_ce))&&(op_valid)) r_alu_phase <= op_phase; else if ((adf_ce_unconditional)||(mem_ce)) r_alu_phase <= 1'b0;",
            "assign alu_phase = r_alu_phase; end else begin : NO_ALUPHASE",
            "assign alu_phase = 1'b0; end endgenerate // }}} // alu_",
            "reg // {{{ generate if (OPT_PIPELINED) begin : GEN_ALUREG_PIPE",
            "always @(posedge i_clk) if (alu_ce || div_ce || o_mem_ce || fpu_ce) alu_",
            "reg <= op_R; else if (OPT_DBGPORT && i_dbg_we && !o_dbg_stall) alu_",
            "reg <= i_dbg_w",
            "reg ; end else begin : GEN_ALUREG_NOPIPE",
            "always @(posedge i_clk) if (OPT_DBGPORT && i_dbg_we && !o_dbg_stall) alu_",
            "reg <= i_dbg_w",
            "reg ; else alu_",
            "reg <= op_R; end endgenerate // }}} // wr_index // {{{",
            "initial wr_index = 0;",
            "always @(posedge i_clk) begin if ((OPT_PIPELINED && (mem_ce || adf_ce_unconditional)) ||(!OPT_PIPELINED && op_valid)) begin wr_index <= 0; /* if (op_valid_mem) wr_index <= 3'b001; if (op_valid_alu) wr_index <= 3'b010; if (op_valid_div) wr_index <= 3'b011; if (op_valid_fpu) wr_index <= 3'b100; */ wr_index[0] <= (op_valid_mem | op_valid_div); wr_index[1] <= (op_valid_alu | op_valid_div); wr_index[2] <= (op_valid_fpu); end if (OPT_DBGPORT && i_dbg_we && !o_dbg_stall) wr_index <= 3'b000; if (!IMPLEMENT_FPU) wr_index[2] <= 1'b0; end // }}} // // DEBUG Register write access starts here // // {{{",
            "initial dbgv = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !r_halted) dbgv <= 0; else dbgv <= OPT_DBGPORT && i_dbg_we && !o_dbg_stall;",
            "always @(posedge i_clk) if (!OPT_LOWPOWER || (OPT_DBGPORT && i_dbg_we)) dbg_val <= i_dbg_data; // dbg_clear_pipe // {{{",
            "always @(posedge i_clk) if (i_reset || clear_pipeline || !r_halted) dbg_clear_pipe <= 0; else if (OPT_DBGPORT && i_dbg_we && !o_dbg_stall) begin dbg_clear_pipe <= 1'b0; if (!OPT_PIPELINED) dbg_clear_pipe <= 1'b1; if ((i_dbg_w",
            "reg == op_Bid)&&(op_rB)) dbg_clear_pipe <= 1'b1; if (i_dbg_w",
            "reg [3:1] == 3'h7) dbg_clear_pipe <= 1'b1; end else if ((!OPT_PIPELINED)&&(i_clear_cache && !o_dbg_stall)) dbg_clear_pipe <= 1'b1; else dbg_clear_pipe <= 1'b0; // }}}",
            "assign alu_gie = gie; // }}} // r_alu_pc // {{{ generate if (OPT_PIPELINED) begin : GEN_ALU_PC",
            "reg [(AW+1):0] r_alu_pc;",
            "initial r_alu_pc = 0;",
            "always @(posedge i_clk) if ((adf_ce_unconditional) ||((master_ce)&&(op_valid_mem) &&(!clear_pipeline)&&(!mem_stalled))) r_alu_pc <= op_pc;",
            "assign alu_pc = r_alu_pc; end else begin : GEN_ALU_PC_NOPIPE",
            "assign alu_pc = op_pc; end endgenerate // }}} // r_alu_illegal // {{{ generate if (OPT_PIPELINED) begin : SET_ALU_ILLEGAL",
            "reg r_alu_illegal;",
            "initial r_alu_illegal = 0;",
            "always @(posedge i_clk) if (clear_pipeline) r_alu_illegal <= 1'b0; else if (adf_ce_unconditional) r_alu_illegal <= op_illegal; else r_alu_illegal <= 1'b0;",
            "assign alu_illegal = (r_alu_illegal); end else begin : SET_ALU_ILLEGAL",
            "assign alu_illegal = op_illegal; end endgenerate // }}} // r_alu_pc_valid, mem_pc_valid // {{{",
            "initial r_alu_pc_valid = 1'b0;",
            "initial mem_pc_valid = 1'b0;",
            "always @(posedge i_clk) if (clear_pipeline) r_alu_pc_valid <= 1'b0; else if ((adf_ce_unconditional)&&(!op_phase)) r_alu_pc_valid <= 1'b1; else if (((!alu_busy)&&(!div_busy)&&(!fpu_busy))||(clear_pipeline)) r_alu_pc_valid <= 1'b0;",
            "assign alu_pc_valid = (r_alu_pc_valid) &&((!alu_busy)&&(!div_busy)&&(!fpu_busy));",
            "always @(posedge i_clk) if (i_reset) mem_pc_valid <= 1'b0; else mem_pc_valid <= (mem_ce); // }}} // Bus lock",
            "logic // {{{ generate if (OPT_LOCK) begin : BUSLOCK",
            "reg r_prelock_stall;",
            "reg [1:0] r_bus_lock;",
            "reg [AW+1:0] r_lock_pc; // r_prelock_stall // {{{",
            "initial r_prelock_stall = 1'b0;",
            "always @(posedge i_clk) if (!OPT_PIPELINED || clear_pipeline) r_prelock_stall <= 1'b0; else if (op_valid && op_lock && r_bus_lock == 2'b00 && adf_ce_unconditional) r_prelock_stall <= 1'b1; else if (op_valid && dcd_valid && (i_pf_valid || dcd_early_branch)) r_prelock_stall <= 1'b0; // }}} // r_lock_pc // {{{",
            "always @(posedge i_clk) if (op_valid && op_ce && op_lock) r_lock_pc <= op_pc-4; `ifdef FORMAL",
            "always @(posedge i_clk) cover(op_valid && op_ce && op_lock); `endif // }}} // r_bus_lock // {{{ // Count 3 cycles. The lock will only hold solid for three // cycles after the LOCK instruction is received. Count those // cycles here.",
            "initial r_bus_lock = 2'b00;",
            "always @(posedge i_clk) if (clear_pipeline) r_bus_lock <= 2'b00; else if (op_valid && (adf_ce_unconditional||mem_ce)) begin if (r_bus_lock != 2'b00) r_bus_lock <= r_bus_lock - 1; else if (op_lock) r_bus_lock <= 2'b11; end // }}}",
            "assign prelock_stall = OPT_PIPELINED && r_prelock_stall;",
            "assign o_bus_lock = |r_bus_lock;",
            "assign o_mem_lock_pc = r_lock_pc;",
            "assign last_lock_insn = (r_bus_lock <= 1); `ifdef FORMAL // {{{ if (OPT_PIPELINED) begin (* anyconst *)",
            "reg r_nojump_lock;",
            "always @(*) if (r_nojump_lock && (r_prelock_stall || r_bus_lock)) begin assume(!dcd_early_branch); assume(!dcd_ljmp); end",
            "always @(*) if (!clear_pipeline) case(r_bus_lock) 2'b11: if (!prelock_stall && r_nojump_lock) begin assert(op_valid && dcd_valid && i_pf_valid); end 2'b10: begin assert(!prelock_stall); if (r_nojump_lock) begin assert(dcd_valid); assert(op_valid + dcd_valid + i_pf_valid >= 2'b10); end end 2'b01: begin assert(!prelock_stall); if (r_nojump_lock && !dcd_illegal) begin assert(op_valid || dcd_valid || i_pf_valid); end end 2'b00: assert(!prelock_stall); endcase end else begin",
            "always @(*) assert(!prelock_stall); end // }}} `endif end else begin : NO_BUSLOCK // {{{",
            "assign prelock_stall = 1'b0;",
            "assign o_bus_lock = 1'b0;",
            "assign o_mem_lock_pc = 0;",
            "assign last_lock_insn= 1; // }}} end endgenerate // }}} // Memory interface // {{{ // This",
            "logic is now managed outside the ZipCore // assign o_mem_ce = mem_ce && set_cond;",
            "assign o_mem_op = ((mem_ce && set_cond) || !OPT_LOWPOWER) ? op_opn[2:0] : 3'h0;",
            "assign o_mem_data = ((mem_ce && set_cond) || !OPT_LOWPOWER) ? op_Av : 32'h0;",
            "assign o_mem_addr = ((mem_ce && set_cond) || !OPT_LOWPOWER) ? op_Bv : 32'h0;",
            "assign o_mem_",
            "reg = ((mem_ce && set_cond) || !OPT_LOWPOWER) ? op_R : 5'h0; // }}} // Sim instructions, alu_sim, alu_sim_immv // {{{",
            "wire cpu_sim; generate if (OPT_SIM) begin : ALU_SIM",
            "reg r_alu_sim;",
            "reg [22:0] r_alu_sim_immv;",
            "wire [4:0]",
            "reg id;",
            "assign reg id = { (OPT_USERMODE && gie), op_sim_immv[3:0]}; if (OPT_USERMODE) begin : GEN_ALLSIM // {{{",
            "assign cpu_sim = !i_reset && !clear_pipeline && adf_ce_unconditional && set_cond && op_sim && op_valid_alu &&(!wr_",
            "reg _ce || !wr_write_pc || wr_",
            "reg _id[4] != alu_gie);",
            "initial r_alu_sim = 1'b0;",
            "always @(posedge i_clk) begin if (cpu_sim) begin // Execute simulation only instructions // {{{ if ((op_sim_immv[19:10] == 10'h0)&&(op_sim_immv[8])) begin // [N/S]EXIT // {{{ $finish; // if (op_sim_immv[19:4] == 16'h0031) // Exit(User",
            "reg ), code cpu_wr_gp",
            "reg // Verilog offers no support for this. // Veri1ator might, but it isn't // standard. // if (op_sim_immv[19:4] == 16'h0030) // Exit(Normal",
            "reg ), code cpu_wr_gp",
            "reg // $finish; // if (op_sim_immv[19:8] == 12'h001) // Exit(Immediate), code cpu_wr_gp",
            "reg // $finish; // }}} end if (op_sim_immv[19:0] == 20'h2ff) begin // DUMP all",
            "reg isters // {{{ if (!op_gie) begin $write(\"sR0 : %08x \", reg set[0]); $write(\"sR1 : %08x \", reg set[1]); $write(\"sR2 : %08x \", reg set[2]); $write(\"sR3 : %08x\\n\", reg set[3]); $write(\"sR4 : %08x \", reg set[4]); $write(\"sR5 : %08x \", reg set[5]); $write(\"sR6 : %08x \", reg set[6]); $write(\"sR7 : %08x\\n\", reg set[7]); $write(\"sR8 : %08x \", reg set[8]); $write(\"sR9 : %08x \", reg set[9]); $write(\"sR10: %08x \", reg set[10]); $write(\"sR11: %08x\\n\", reg set[11]); $write(\"sR12: %08x \", reg set[12]); $write(\"sSP : %08x \", reg set[13]); $write(\"sCC : %08x \", w_iflags); $write(\"sPC : %08x\\n\", (!op_gie) ? op_pc : ipc); $write(\"\\n\", (!op_gie) ? op_pc : ipc); end $write(\"uR0 : %08x \", reg set[16]); $write(\"uR1 : %08x \", reg set[17]); $write(\"uR2 : %08x \", reg set[18]); $write(\"uR3 : %08x\\n\", reg set[19]); $write(\"uR4 : %08x \", reg set[20]); $write(\"uR5 : %08x \", reg set[21]); $write(\"uR6 : %08x \", reg set[22]); $write(\"uR7 : %08x\\n\", reg set[23]); $write(\"uR8 : %08x \", reg set[24]); $write(\"uR9 : %08x \", reg set[25]); $write(\"uR10: %08x \", reg set[26]); $write(\"uR11: %08x\\n\", reg set[27]); $write(\"uR12: %08x \", reg set[28]); $write(\"uSP : %08x \", reg set[29]); $write(\"uCC : %08x \", w_uflags); $write(\"uPC : %08x\\n\", (op_gie) ? op_pc : upc); // }}} end if (op_sim_immv[19:4] == 16'h0020) begin // Dump a",
            "reg ister // {{{ $write(\"@%08x \", op_pc); $write(\"%c\", (op_gie) ? \"s\":\"u\"); $write(\"R[%2d] = 0x\", op_sim_immv[3:0]); // Dump a",
            "reg ister if (wr_",
            "reg _ce && wr_",
            "reg _id ==",
            "reg id) $display(\"%08x\", wr_gp",
            "reg _vl); else $display(\"%08x\", reg set[",
            "reg id]); // }}} end if (op_sim_immv[19:4] == 16'h0021) begin // Dump a user",
            "reg ister // {{{ $write(\"@%08x u\", op_pc); $write(\"R[%2d] = 0x\", op_sim_immv[3:0]); if (wr_",
            "reg _ce && wr_",
            "reg _id == { 1'b1, op_sim_immv[3:0] }) $display(\"%08x\\n\", wr_gp",
            "reg _vl); else $display(\"%08x\\n\", reg set[{ 1'b1, op_sim_immv[3:0]}]); // }}} end if (op_sim_immv[19:4] == 16'h0023) begin // SOUT(user",
            "reg ister) // {{{ if (wr_",
            "reg _ce && wr_",
            "reg _id == { 1'b1, op_sim_immv[3:0] }) $write(\"%c\", wr_gp",
            "reg _vl[7:0]); else $write(\"%c\", reg set[{ 1'b1, op_sim_immv[3:0]}][7:0]); // }}} end if (op_sim_immv[19:4] == 16'h0022) begin // SOUT(",
            "reg ister) // {{{ if (wr_",
            "reg _ce && wr_",
            "reg _id ==",
            "reg id) $write(\"%c\", wr_gp",
            "reg _vl[7:0]); else $write(\"%c\", reg set[",
            "reg id][7:0]); // }}} end if (op_sim_immv[19:8] == 12'h004) begin // SOUT(Immediate) // {{{ $write(\"%c\", op_sim_immv[7:0]); // }}} end // ELSE unrecognized SIM instruction // Set alu_sim either way r_alu_sim <= 1'b1; // }}} end else r_alu_sim <= 1'b0; if (adf_ce_unconditional) r_alu_sim_immv <= op_sim_immv; end // }}} end else begin : GEN_NO_USERSIM // {{{",
            "assign cpu_sim = !i_reset && !clear_pipeline && adf_ce_unconditional && set_cond && op_sim && op_valid_alu &&(!wr_",
            "reg _ce || !wr_write_pc || wr_",
            "reg _id[4] != alu_gie);",
            "initial r_alu_sim = 1'b0;",
            "always @(posedge i_clk) begin if (cpu_sim) begin // Execute simulation only instructions // {{{ if ((op_sim_immv[19:10] == 10'h0)&&(op_sim_immv[8])) begin // [N/S]EXIT // {{{ $finish; // if (op_sim_immv[19:4] == 16'h0031) // Exit(User",
            "reg ), code cpu_wr_gp",
            "reg // Verilog offers no support for this. // Veri1ator might, but it isn't // standard. // if (op_sim_immv[19:4] == 16'h0030) // Exit(Normal",
            "reg ), code cpu_wr_gp",
            "reg // $finish; // if (op_sim_immv[19:8] == 12'h001) // Exit(Immediate), code cpu_wr_gp",
            "reg // $finish; // }}} end if (op_sim_immv[19:0] == 20'h2ff) begin // DUMP all",
            "reg isters // {{{ if (!op_gie) begin $write(\" R0 : %08x \", reg set[0]); $write(\" R1 : %08x \", reg set[1]); $write(\" R2 : %08x \", reg set[2]); $write(\" R3 : %08x\\n\", reg set[3]); $write(\" R4 : %08x \", reg set[4]); $write(\" R5 : %08x \", reg set[5]); $write(\" R6 : %08x \", reg set[6]); $write(\" R7 : %08x\\n\", reg set[7]); $write(\" R8 : %08x \", reg set[8]); $write(\" R9 : %08x \", reg set[9]); $write(\" R10: %08x \", reg set[10]); $write(\" R11: %08x\\n\", reg set[11]); $write(\" R12: %08x \", reg set[12]); $write(\" SP : %08x \", reg set[13]); $write(\" CC : %08x \", w_iflags); $write(\" PC : %08x\\n\", op_pc); end // }}} end if (op_sim_immv[19:5] == 15'h0010) begin // Dump a",
            "reg ister // {{{ $write(\"@%08x \", op_pc); $write(\" R[%2d] = 0x\", op_sim_immv[3:0]); // Dump a",
            "reg ister if (wr_",
            "reg _ce&&wr_",
            "reg _id[3:0] ==",
            "reg id[3:0]) $display(\"%08x\", wr_gp",
            "reg _vl); else $display(\"%08x\", reg set[",
            "reg id[3:0]]); // }}} end if (op_sim_immv[19:5] == 15'h0011) begin // SOUT(user",
            "reg ister) // {{{ if (wr_",
            "reg _ce && wr_",
            "reg _id[3:0] == op_sim_immv[3:0]) $write(\"%c\", wr_gp",
            "reg _vl[7:0]); else $write(\"%c\", reg set[op_sim_immv[3:0]][7:0]); // }}} end if (op_sim_immv[19:8] == 12'h004) begin // SOUT(Immediate) // {{{ $write(\"%c\", op_sim_immv[7:0]); // }}} end // ELSE unrecognized SIM instruction // Set alu_sim either way r_alu_sim <= 1'b1; // }}} end else r_alu_sim <= 1'b0; if (adf_ce_unconditional) r_alu_sim_immv <= op_sim_immv; end // Verilator lint_off UNUSED",
            "wire unused_simmv;",
            "assign unused_simmv = &{ 1'b0, reg id[4] }; // Verilator lint_on UNUSED // }}} end",
            "assign alu_sim = r_alu_sim;",
            "assign alu_sim_immv = r_alu_sim_immv; end else begin : NO_ALU_SIM",
            "assign alu_sim = 0;",
            "assign alu_sim_immv = 0;",
            "assign cpu_sim = 0; end endgenerate // }}} // }}} //////////////////////////////////////////////////////////////////////// // // PIPELINE STAGE #5 :: Write-back results // {{{ //////////////////////////////////////////////////////////////////////// // // // // This stage is not allowed to stall. If results are ready to be // written back, they are written back at all cost. Sleepy CPU's // won't prevent write back, nor debug modes, halting the CPU, nor // anything else. Indeed, the (master_ce) bit is only as relevant // as knowinig something is available for writeback. // (was) wr_discard, wr_",
            "reg _ce // {{{ // // Write back to our generic",
            "reg ister set ... // When shall we write back? On one of two conditions // Note that the flags needed to be checked before issuing the // bus instruction, so they don't need to be checked here. // Further, alu_wR includes (set_cond), so we don't need to // check for that here either. It also includes alu_illegal, so // again--doesn't need to be checked again here. /* // 12",
            "input s. This implementation is made worse by wr_index.",
            "always @(*) case(wr_index) 3'b000: wr_",
            "reg _ce = dbgv; 3'b001: wr_",
            "reg _ce = i_mem_valid; //3'b010: wr_",
            "reg _ce = (!clear_pipeline)&&(alu_wR && alu_valid); 3'b011: wr_",
            "reg _ce = (!clear_pipeline)&&(div_valid)&&(!div_error); 3'b1??: wr_",
            "reg _ce = (!clear_pipeline)&&(fpu_valid)&&(!fpu_error); default: wr_",
            "reg _ce = (!clear_pipeline)&&(alu_wR && alu_valid); endcase */ // 7-LUT -- without FPU or wr_index (which wasn't needed)",
            "always @(*) begin wr_",
            "reg _ce = dbgv || i_mem_valid; if ((alu_wR && alu_valid) ||(div_valid && !div_error) ||(fpu_valid && !fpu_error)) wr_",
            "reg _ce = wr_",
            "reg _ce || !clear_pipeline; end `ifdef FORMAL",
            "always @(*) if (!i_reset && ((alu_wR && alu_valid) ||(div_valid && !div_error) ||(fpu_valid && !fpu_error))) assert(!dbgv && !i_mem_valid);",
            "always @(*) if (!i_reset) casez(wr_index) 3'b000: assert(!i_mem_valid && (!alu_wR || !alu_valid) && (!div_valid || div_error) && (!fpu_valid || fpu_error)); 3'b001: assert(!dbgv && (!alu_wR || !alu_valid) && (!div_valid || div_error) && (!fpu_valid || fpu_error)); 3'b010: assert(!dbgv && !i_mem_valid // && (!alu_wR || !alu_valid) && (!div_valid || div_error) && (!fpu_valid || fpu_error)); 3'b011: assert(!dbgv && !i_mem_valid && (!alu_wR || !alu_valid) // && (!div_valid || div_error) && (!fpu_valid || fpu_error)); 3'b100: assert(!dbgv && !i_mem_valid && (!alu_wR || !alu_valid) && (!div_valid || div_error)); // && (!fpu_valid || fpu_error); default: assert(0); endcase `endif // }}} // wr_",
            "reg _id, wr_write-cc, wr_write_scc, wr_write_ucc, wr_write_pc // {{{ // Which",
            "reg ister shall be written? // COULD SIMPLIFY THIS: by adding three bits to these",
            "reg isters, // One or PC, one for CC, and one for GIE match // Note that the alu_",
            "reg is the",
            "reg ister to write on a divide or // FPU operation. generate if (OPT_USERMODE) begin : GEN_USERREG",
            "assign wr_",
            "reg _id = (i_mem_valid) ? i_mem_w",
            "reg : alu_",
            "reg ; end else begin : NO_USERREG",
            "assign wr_",
            "reg _id[3:0] = (i_mem_valid) ? i_mem_w",
            "reg [3:0] : alu_",
            "reg [3:0];",
            "assign wr_",
            "reg _id[4] = 1'b0; end endgenerate // Are we writing to the CC",
            "reg ister? // one 5-LUT ea",
            "assign wr_write_cc = (wr_",
            "reg _id[3:0] == CPU_CC_REG);",
            "assign wr_write_scc = (wr_",
            "reg _id[4:0] == {1'b0, CPU_CC_REG});",
            "assign wr_write_ucc = (wr_",
            "reg _id[4:0] == {1'b1, CPU_CC_REG}); // Are we writing to the PC?",
            "assign wr_write_pc = (wr_",
            "reg _id[3:0] == CPU_PC_REG); // }}} // wr_?p",
            "reg _vl: Select from among sources the value to be writtena // {{{ // One 6-LUT per bit, or 32 6-LUTs w/o FPU",
            "always @(*) casez(wr_index) 3'b000: wr_gp",
            "reg _vl = dbg_val; 3'b001: wr_gp",
            "reg _vl = i_mem_result; // 3'b010: wr_gp",
            "reg _vl = alu_result; 3'b011: wr_gp",
            "reg _vl = div_result; 3'b1??: wr_gp",
            "reg _vl = fpu_result; default: wr_gp",
            "reg _vl = alu_result; endcase // One 6-LUT per bit, or 32 6-LUTs",
            "always @(*) case(wr_index[1:0]) 2'b00: wr_sp",
            "reg _vl = dbg_val; 2'b01: wr_sp",
            "reg _vl = i_mem_result; // 3'b010: wr_gp",
            "reg _vl = alu_result; default: wr_sp",
            "reg _vl = alu_result; endcase // }}} // Update the",
            "reg ister set // {{{ generate if (OPT_USERMODE) begin : SET_REGISTERS",
            "always @(posedge i_clk) if (wr_",
            "reg _ce)",
            "reg set[wr_",
            "reg _id] <= wr_gp",
            "reg _vl; end else begin : SET_SREGISTERS",
            "always @(posedge i_clk) if (wr_",
            "reg _ce)",
            "reg set[wr_",
            "reg _id[3:0]] <= wr_gp",
            "reg _vl; end endgenerate // }}} // // Write back to the condition codes/flags",
            "reg ister ... // wr_flags_ce : should condition codes be written to? // {{{ // When shall we write to our flags",
            "reg ister? alu_wF already // includes the set condition ... // assign wr_flags_ce = (alu_wF)&&((alu_valid) // ||(div_valid)||(fpu_valid)) // &&(!clear_pipeline)&&(!alu_illegal); /* // 10",
            "input s",
            "always @(*) begin wr_flags_ce = 0; if (alu_wF && !clear_pipeline) // Includes !alu_illegal in wF case(wr_index) // 3'b000: wr_flags_ce = 0; // Debug // 3'b001: wr_flags_ce = 0; // Memory 3'b010: wr_flags_ce = alu_valid; // ALU 3'b011: wr_flags_ce = div_valid && !div_error; // DIV 3'b1??: wr_flags_ce = fpu_valid && !fpu_error; // FPU default: wr_flags_ce = 0; endcase end */ // 7-LUT -- since we don't need wr_index",
            "always @(*) begin wr_flags_ce = alu_valid || (div_valid && !div_error) || (fpu_valid && !fpu_error); if (!alu_wF || clear_pipeline) wr_flags_ce = 1'b0; end `ifdef FORMAL",
            "always @(*) if (!i_reset) begin casez(wr_index) 3'b000: assert(wr_flags_ce == 1'b0); 3'b001: assert(wr_flags_ce == 1'b0); 3'b010: assert(wr_flags_ce == (alu_wF && !clear_pipeline && alu_valid)); 3'b011: assert(wr_flags_ce == (alu_wF && !clear_pipeline && div_valid && !div_error)); 3'b100: assert(IMPLEMENT_FPU && wr_flags_ce == (alu_wF && !clear_pipeline && fpu_valid && !fpu_error)); default: assert(0); endcase if (alu_illegal) assert(!div_valid && !fpu_valid && (!alu_wF || !alu_valid)); end `endif // }}} // wr_flags: what should the new condition codes be? // {{{",
            "always @(*) begin wr_flags = 0; casez(wr_index) 3'b010: wr_flags = alu_flags; 3'b011: wr_flags = div_flags; 3'b1??: wr_flags = fpu_flags; default: wr_flags = 0; endcase end // }}} // w_uflags, w_iflags : Define the current CC",
            "reg isters // {{{",
            "assign w_uflags = { 2'b00, uhalt_phase, ufpu_err_flag, udiv_err_flag, ubus_err_flag, trap, ill_err_u, ubreak, !gie && user_step, 1'b1, sleep, (wr_flags_ce && alu_gie) ? wr_flags : flags };",
            "assign w_iflags = { 2'b00, ihalt_phase, ifpu_err_flag, idiv_err_flag, ibus_err_flag, trap, ill_err_i, break_en, 1'b0, 1'b0, sleep, (wr_flags_ce && !alu_gie) ? wr_flags : iflags }; // }}} // flags: The user condition codes, Z, C, N, and V // {{{ // What value to write?",
            "always @(posedge i_clk) // If explicitly writing the",
            "reg ister itself if (wr_",
            "reg _ce && wr_write_ucc) flags <= wr_gp",
            "reg _vl[3:0]; // Otherwise if we're setting the flags from an ALU operation else if (wr_flags_ce && alu_gie) flags <= wr_flags; // }}} // iflags: The supervisor condition codes, Z, C, N, and V // {{{",
            "always @(posedge i_clk) if (wr_",
            "reg _ce && wr_write_scc) iflags <= wr_gp",
            "reg _vl[3:0]; else if (wr_flags_ce && !alu_gie) iflags <= wr_flags; // }}} // break_en // {{{ // The 'break' enable bit. This bit can only be set from supervisor // mode. It controls what the CPU does upon encountering a break // instruction. // // The goal, upon encountering a break is that the CPU should stop and // not execute the break instruction, choosing instead to enter into // either interrupt mode or halt first. // if ((break_en) AND (break_instruction)) // user mode or not // HALT CPU // else if (break_instruction) // only in user mode // set an interrupt flag, set the user break bit, // go to supervisor mode, allow supervisor to step the CPU.",
            "initial break_en = 1'b0;",
            "always @(posedge i_clk) if (i_reset) break_en <= 1'b0; else if ((wr_",
            "reg _ce)&&(wr_write_scc)) break_en <= wr_sp",
            "reg _vl[CPU_BREAK_BIT]; // }}} // break_pending // {{{ generate if (OPT_PIPELINED) begin : GEN_PENDING_BREAK",
            "reg r_break_pending;",
            "initial r_break_pending = 1'b0;",
            "always @(posedge i_clk) if (clear_pipeline || !op_valid) r_break_pending <= 1'b0; else if (op_break && !r_break_pending) r_break_pending <= (!alu_busy)&&(!div_busy) &&(!fpu_busy)&&(!i_mem_busy) &&(!wr_",
            "reg _ce) && (!step || !stepped); // else // No need to clear this here. The break will force the // pipeline to be cleared above, at which point we can // clear this",
            "reg ister. // r_break_pending <= 1'b0;",
            "assign break_pending = r_break_pending; end else begin : GEN_BREAK_NOPIPE",
            "assign break_pending = op_break; `ifdef FORMAL",
            "always @(*) if (!gie && user_step && stepped) assert(!op_break); `endif end endgenerate // }}} // o_break // {{{ // // This is a 12-",
            "input equation on an",
            "output . Can this be // simplified any? What happens if o_break is set? Will it ever // clear on its own, or does it require a write to the debug port?",
            "assign o_break = (break_en || !op_gie)&&(break_pending) &&(!clear_pipeline) ||(ill_err_i) ||((!alu_gie)&&(i_bus_err)) ||((!alu_gie)&&(div_error)) ||((!alu_gie)&&(fpu_error)) ||((!alu_gie)&&(alu_illegal)&&(!clear_pipeline)); `ifdef FORMAL // Can I assume that, if break_pending is true, that we're either // in supervisor mode, or that break_en is set? If so, can I // simplify the calculation above? // // No, because once break_pending is set, the supervisor can then // adjust break_en without adjusting the external break. // // always @(*) // if (break_pending) // assert(!op_gie || break_en);",
            "always @(*) if (!alu_gie && alu_illegal && !clear_pipeline) assert(!master_ce); // Do I need to break on the last condition above?",
            "always @(posedge i_clk) if (!i_reset && $past(!i_reset && !alu_gie && alu_illegal && !clear_pipeline && !dbgv)) assert(ill_err_i);",
            "always @(*) if (!i_reset) assert(!dbgv || !alu_valid); `endif // }}} // sleep // {{{ // The sleep",
            "reg ister. Setting the sleep",
            "reg ister causes the CPU to // sleep until the next interrupt. Setting the sleep",
            "reg ister within // interrupt mode causes the processor to halt until a reset. This is // a panic/fault halt. The trick is that you cannot be allowed to // set the sleep bit and switch to supervisor mode in the same // instruction: users are not allowed to halt the CPU.",
            "initial sleep = 1'b0; generate if (OPT_USERMODE) begin : GEN_SLEEP // {{{",
            "initial sleep = 1'b0;",
            "always @(posedge i_clk) if (i_reset || w_switch_to_interrupt) // Wake up on any reset or any switch to supervisor mode sleep <= 1'b0; else if (wr_",
            "reg _ce && wr_write_cc) begin // // !GIE && SLEEP ==> halted // GIE && SLEEP ==> sleep until an interrupt // if (!alu_gie) // In supervisor mode, we have no protections. // The supervisor can set the sleep bit however // he wants. Well ... not quite. Switching to // user mode and sleep mode should only be // possible if the interrupt flag isn't set. // Hence, if an interrupt is pending, then any // WAIT instruction essentially becomes a NOOP. // // Thus: if (i_interrupt) // &&(wr_sp",
            "reg _vl[GIE]) // don't set the sleep bit // otherwise however it would o.w. be set sleep <= (wr_sp",
            "reg _vl[CPU_SLEEP_BIT]) &&((!i_interrupt) ||(!wr_sp",
            "reg _vl[CPU_GIE_BIT])); else if (wr_sp",
            "reg _vl[CPU_GIE_BIT]) // In user mode, however, you can only set the // sleep mode while remaining in user mode. // You can't switch to sleep mode *and* // supervisor mode at the same time, lest you // halt the CPU. sleep <= wr_sp",
            "reg _vl[CPU_SLEEP_BIT]; end // }}} end else begin : GEN_NO_USERMODE_SLEEP // {{{ // Even with no user mode, we still want to implement a sleep // instruction. Here, we create an r_sleep_is_halt to // differentiate between the halt and the sleep condition // so that the supervisor can still cause the CPU to sleep. // reg r_sleep_is_halt;",
            "initial r_sleep_is_halt = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_sleep_is_halt <= 1'b0; else if (wr_",
            "reg _ce && wr_write_cc && wr_sp",
            "reg _vl[CPU_SLEEP_BIT] && !wr_sp",
            "reg _vl[CPU_GIE_BIT]) // Setting SLEEP and supervisor mode at the same time // halts the CPU. Halts can only be set here. // They can only be cleared on reset. r_sleep_is_halt <= 1'b1; // Trying to switch to user mode, either via a WAIT or an RTU // instruction will cause the CPU to sleep until an interrupt, // in the NO-USERMODE build.",
            "always @(posedge i_clk) if (i_reset || (i_interrupt && !r_sleep_is_halt)) sleep <= 1'b0; else if ((wr_",
            "reg _ce)&&(wr_write_cc) &&(wr_sp",
            "reg _vl[CPU_GIE_BIT])) sleep <= 1'b1; // }}} end endgenerate // }}} // step : debug single-step control // {{{",
            "initial user_step = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !OPT_USERMODE) user_step <= 1'b0; else if ((wr_",
            "reg _ce)&&(!alu_gie)&&(wr_write_ucc)) // The supervisor can adjust whether or not we are stepping // the user mode process. This bit does not automatically // clear, but can",
            "always be written while in supervisor mode. user_step <= wr_sp",
            "reg _vl[CPU_STEP_BIT];",
            "assign step = user_step && gie; // }}} // o_clken // {{{ generate if (!OPT_CLKGATE) begin : NO_CLOCK_GATE",
            "assign w_clken = 1'b1;",
            "assign o_clken = 1'b1; end else begin : GEN_CLOCK_GATE",
            "reg r_clken; // Actual clock gating signal // // = r_clken || (i_interrupt&&!i_halt) || i_dbg_we // initial r_clken = !OPT_START_HALTED;",
            "always @(posedge i_clk) if (i_reset) r_clken <= !OPT_START_HALTED; else if (i_halt && r_halted && (!OPT_DBGPORT || !i_dbg_we)) r_clken <= i_mem_busy || !i_halt || o_mem_ce; else if (!i_halt&& (!sleep || i_interrupt || pending_interrupt)) r_clken <= 1'b1; else // if (sleep || i_halt) begin r_clken <= 1'b0; // If we are in the middle of a lock operation, then // don't shut the clock off if (o_bus_lock) r_clken <= 1'b1; // If we are in between two compressed instructions // from the same word, then don't disable the clock if (alu_phase) r_clken <= 1'b1; // Don't shut the clock off if we are still busy with // any previous operation(s) if (i_mem_busy || o_mem_ce || alu_busy || div_busy || fpu_busy || wr_",
            "reg _ce ||(OPT_DBGPORT && i_dbg_we) || i_bus_err) r_clken <= 1'b1; if (i_halt && !r_halted) r_clken <= 1'b1; // Should we wait for a valid PF result before halting? // if (!i_pf_valid) r_clken <= 1'b1; // if (!op_valid && !dcd_illegal) r_clken <= 1'b1; // if (!dcd_valid && !i_pf_illegal) r_clken <= 1'b1; end",
            "assign w_clken = r_clken; // Wake up on interrupts, debug write requests, or the raising // of the halt flag if we're not sleeping.",
            "assign o_clken = r_clken || (OPT_DBGPORT && i_dbg_we) || i_clear_cache || (!i_halt && (i_interrupt || !sleep)); end endgenerate // }}} // gie, switch_to_interrupt, release_from_interrupt, r_user_stepped // {{{ // The GIE",
            "reg ister. Only interrupts can disable the interrupt",
            "reg ister generate if (OPT_USERMODE) begin : GEN_PENDING_INTERRUPT // {{{",
            "reg r_pending_interrupt;",
            "reg r_user_stepped; // r_user_stepped is used to make certain that we stop a // user task once a full instruction has been accomplished.",
            "initial r_user_stepped = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !gie || !user_step) r_user_stepped <= 1'b0; // else if(w_switch_to_interrupt) // While this is technically what we want, we can wait // a clock cycle to speed up the CPU by not depending upon // the complex w_switch_to_interrupt calculation here // r_user_stepped <= 1'b0; else if (op_valid && !op_phase && !op_lock && last_lock_insn && (adf_ce_unconditional || mem_ce)) r_user_stepped <= 1'b1;",
            "initial r_pending_interrupt = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_pending_interrupt <= 1'b0; else if (!gie || w_switch_to_interrupt) r_pending_interrupt <= 1'b0; else if (clear_pipeline && (!user_step || !stepped)) r_pending_interrupt <= 1'b0; else begin if (i_interrupt) r_pending_interrupt <= 1'b1; if (break_pending) r_pending_interrupt <= 1'b1; if (adf_ce_unconditional && op_illegal) r_pending_interrupt <= 1'b1; if (((!alu_busy && !i_mem_busy && !div_busy && !fpu_busy) || wr_",
            "reg _ce) && user_step && stepped) r_pending_interrupt <= 1'b1; end",
            "assign pending_interrupt = r_pending_interrupt && !i_halt;",
            "assign w_switch_to_interrupt = (gie)&&( // On interrupt (obviously) ((pending_interrupt) &&(!alu_phase)&&(!o_bus_lock)&&(!i_mem_busy)) // // On division by zero. If the divide isn't // implemented, div_valid and div_error will be short // circuited and that",
            "logic will be bypassed ||(div_error) // // Same thing on a floating point error. Note that // fpu_error must *never* be set unless fpu_valid is // also set as well, else this will fail. ||(fpu_error) // // ||(i_bus_err) // // If we write to the CC",
            "reg ister ||((wr_",
            "reg _ce)&&(!wr_sp",
            "reg _vl[CPU_GIE_BIT]) &&(wr_",
            "reg _id[4])&&(wr_write_cc)) );",
            "assign w_release_from_interrupt = (!gie)&&(!i_interrupt) // Then if we write the sCC",
            "reg ister &&(((wr_",
            "reg _ce)&&(wr_sp",
            "reg _vl[CPU_GIE_BIT]) &&(wr_write_scc)) ); `ifdef FORMAL",
            "always @(posedge i_clk) if (r_pending_interrupt && gie && !clear_pipeline) assert(i_interrupt || user_step || alu_illegal || ill_err_u || break_pending);",
            "always @(posedge i_clk) if (f_past_valid && $past(user_step && stepped && !o_bus_lock && !o_dbg_stall)) assert(!gie || r_pending_interrupt); `endif",
            "assign stepped = r_user_stepped; // }}} end else begin : NO_PENDING_INTS // {{{",
            "assign w_switch_to_interrupt = 1'b0;",
            "assign w_release_from_interrupt = 1'b0;",
            "assign pending_interrupt = 1'b0;",
            "assign stepped = 1'b0; // Verilator lint_off UNUSED",
            "wire unused_int_signals;",
            "assign unused_int_signals = &{ 1'b0, last_lock_insn }; // Verilator lint_on UNUSED // }}} end endgenerate generate if (OPT_USERMODE) begin : SET_GIE",
            "reg r_gie;",
            "initial r_gie = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_gie <= 1'b0; // Supervisor mode else if (w_switch_to_interrupt) r_gie <= 1'b0; // Supervisor mode else if (w_release_from_interrupt) r_gie <= 1'b1; // User mode",
            "assign gie = r_gie; end else begin : ZERO_GIE",
            "assign gie = 1'b0; end endgenerate // }}} // trap, ubreak // {{{ generate if (OPT_USERMODE) begin : SET_TRAP_N_UBREAK // {{{",
            "reg r_trap;",
            "reg r_ubreak; // A trap is generated when the user writes to the CC // reg ister to clear the GIE bit. This is how the supervisor // can tell that supervisor mode was entered by a request from // usermode.",
            "initial r_trap = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(w_release_from_interrupt)) r_trap <= 1'b0; else if (wr_",
            "reg _ce && wr_write_ucc) begin if (!alu_gie) // The trap bit can only be cleared by the // supervisor. r_trap <= (r_trap)&&(wr_sp",
            "reg _vl[CPU_TRAP_BIT]); else if (!wr_sp",
            "reg _vl[CPU_GIE_BIT]) // && alu_gie // Execute a trap r_trap <= !dbgv; end // A user break is an indication of an exception. Something // went wrong. When entering supervisor mode, if this bit // is set the supervisor then knows something went wrong in // userspace that needs to be looked into.",
            "initial r_ubreak = 1'b0;",
            "always @(posedge i_clk) if (i_reset || w_release_from_interrupt) r_ubreak <= 1'b0; else if (op_gie && break_pending && w_switch_to_interrupt) // Breaks are set when a BREAK instruction is accepted // for execution from the OP stage, *and* when in user // mode r_ubreak <= 1'b1; else if ((!alu_gie || dbgv)&&(wr_",
            "reg _ce)&&(wr_write_ucc)) // Allow the supervisor or debug port to clear this // reg ister--but not to set it r_ubreak <= (ubreak)&&(wr_sp",
            "reg _vl[CPU_BREAK_BIT]);",
            "assign trap = r_trap;",
            "assign ubreak = r_ubreak; // }}} end else begin : NO_USERTRAP",
            "assign trap = 1'b0;",
            "assign ubreak = 1'b0; end endgenerate // }}} // ill_err_i, ill_err_u: Illegal instruction flags // {{{",
            "initial ill_err_i = 1'b0;",
            "always @(posedge i_clk) if (i_reset) ill_err_i <= 1'b0; else if (dbgv && wr_write_scc) // Only the debug interface (or a CPU reset) can clear the // supervisor's illegal instruction flag ill_err_i <= (ill_err_i)&&(wr_sp",
            "reg _vl[CPU_ILL_BIT]); else if (!alu_gie && alu_illegal && !clear_pipeline) // The supervisor's illegal instruction flag is set in // supervisor (not user) mode, on trying to execute the illegal // instruction ill_err_i <= 1'b1; generate if (OPT_USERMODE) begin : SET_USER_ILLEGAL_INSN",
            "reg r_ill_err_u; // // The user's illegal instruction exception flag. Used and // cleared by the supervisor. // initial r_ill_err_u = 1'b0;",
            "always @(posedge i_clk) // The bit is automatically cleared on release from interrupt // or reset if (i_reset || w_release_from_interrupt) r_ill_err_u <= 1'b0; else if ((!alu_gie || dbgv)&&(wr_",
            "reg _ce)&&(wr_write_ucc)) // Either the supervisor or the debugger can clear this // bit. (Neither can set it) r_ill_err_u <=((ill_err_u)&&(wr_sp",
            "reg _vl[CPU_ILL_BIT])); else if (alu_gie && alu_illegal && !clear_pipeline) // This flag is set if the CPU ever attempts to execute // an illegal instruction while in user mode. r_ill_err_u <= 1'b1;",
            "assign ill_err_u = r_ill_err_u; end else begin : NO_USER_ILL",
            "assign ill_err_u = 1'b0; end endgenerate // }}} // ibus_err_flag, ubus_err_flag : Bus error flags // {{{ // Supervisor/interrupt bus error flag -- this will crash the CPU if // ever set.",
            "initial ibus_err_flag = 1'b0;",
            "always @(posedge i_clk) if (i_reset) ibus_err_flag <= 1'b0; else if ((dbgv)&&(wr_write_scc)) ibus_err_flag <= (ibus_err_flag)&&(wr_sp",
            "reg _vl[CPU_BUSERR_BIT]); else if ((i_bus_err)&&(!alu_gie)) ibus_err_flag <= 1'b1; // User bus error flag -- if ever set, it will cause an interrupt to // supervisor mode. generate if (OPT_USERMODE) begin : SET_USER_BUSERR",
            "reg r_ubus_err_flag;",
            "initial r_ubus_err_flag = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(w_release_from_interrupt)) r_ubus_err_flag <= 1'b0; else if (((!alu_gie)||(dbgv))&&(wr_",
            "reg _ce)&&(wr_write_ucc)) r_ubus_err_flag <= (ubus_err_flag)&&(wr_sp",
            "reg _vl[CPU_BUSERR_BIT]); else if ((i_bus_err)&&(alu_gie)) r_ubus_err_flag <= 1'b1;",
            "assign ubus_err_flag = r_ubus_err_flag; end else begin : NO_USER_BUSERR",
            "assign ubus_err_flag = 1'b0; end endgenerate // }}} // idiv_err_flag, udiv_err_flag : Divide by zero error flags // {{{ generate if (OPT_DIV != 0) begin : DIVERR // {{{",
            "reg r_idiv_err_flag; // Supervisor/interrupt divide (by zero) error flag -- this will // crash the CPU if ever set. This bit is thus available for us // to be able to tell if/why the CPU crashed.",
            "initial r_idiv_err_flag = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_idiv_err_flag <= 1'b0; else if ((dbgv)&&(wr_write_scc)) r_idiv_err_flag <= (r_idiv_err_flag)&&(wr_sp",
            "reg _vl[CPU_DIVERR_BIT]); else if ((div_error)&&(!alu_gie)) r_idiv_err_flag <= 1'b1;",
            "assign idiv_err_flag = r_idiv_err_flag; if (OPT_USERMODE) begin : USER_DIVERR",
            "reg r_udiv_err_flag; // User divide (by zero) error flag -- if ever set, it will // cause a sudden switch interrupt to supervisor mode.",
            "initial r_udiv_err_flag = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(w_release_from_interrupt)) r_udiv_err_flag <= 1'b0; else if (((!alu_gie)||(dbgv))&&(wr_",
            "reg _ce) &&(wr_write_ucc)) r_udiv_err_flag <= (r_udiv_err_flag)&&(wr_sp",
            "reg _vl[CPU_DIVERR_BIT]); else if ((div_error)&&(alu_gie)) r_udiv_err_flag <= 1'b1;",
            "assign udiv_err_flag = r_udiv_err_flag; end else begin : NO_USER_DIVERR",
            "assign udiv_err_flag = 1'b0; end // }}} end else begin : NO_DIVERR // {{{",
            "assign idiv_err_flag = 1'b0;",
            "assign udiv_err_flag = 1'b0; // }}} end endgenerate // }}} // ifpu_err_flag, ufpu_err_flag : Floating point error flag(s) // {{{ generate if (IMPLEMENT_FPU !=0) begin : FPUERR // {{{ // Supervisor/interrupt floating point error flag -- this will // crash the CPU if ever set.",
            "reg r_ifpu_err_flag, r_ufpu_err_flag;",
            "initial r_ifpu_err_flag = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_ifpu_err_flag <= 1'b0; else if ((dbgv)&&(wr_write_scc)) r_ifpu_err_flag <= (r_ifpu_err_flag)&&(wr_sp",
            "reg _vl[CPU_FPUERR_BIT]); else if ((fpu_error)&&(fpu_valid)&&(!alu_gie)) r_ifpu_err_flag <= 1'b1; // User floating point error flag -- if ever set, it will cause // a sudden switch interrupt to supervisor mode.",
            "initial r_ufpu_err_flag = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)&&(w_release_from_interrupt)) r_ufpu_err_flag <= 1'b0; else if (((!alu_gie)||(dbgv))&&(wr_",
            "reg _ce) &&(wr_write_ucc)) r_ufpu_err_flag <= (r_ufpu_err_flag)&&(wr_sp",
            "reg _vl[CPU_FPUERR_BIT]); else if ((fpu_error)&&(alu_gie)&&(fpu_valid)) r_ufpu_err_flag <= 1'b1;",
            "assign ifpu_err_flag = r_ifpu_err_flag;",
            "assign ufpu_err_flag = r_ufpu_err_flag; // }}} end else begin : NO_FPUERR // {{{",
            "assign ifpu_err_flag = 1'b0;",
            "assign ufpu_err_flag = 1'b0; // }}} end endgenerate // }}} // ihalt_phase, uhalt_phase : If an instruction was broken when halting // {{{ generate if (OPT_CIS) begin : GEN_IHALT_PHASE",
            "reg r_ihalt_phase;",
            "initial r_ihalt_phase = 0;",
            "always @(posedge i_clk) if (i_reset) r_ihalt_phase <= 1'b0; else if ((!alu_gie)&&(alu_pc_valid)&&(!clear_pipeline)) r_ihalt_phase <= alu_phase;",
            "assign ihalt_phase = r_ihalt_phase; end else begin : GEN_IHALT_PHASE",
            "assign ihalt_phase = 1'b0; end endgenerate generate if ((!OPT_CIS) || (!OPT_USERMODE)) begin : GEN_UHALT_PHASE",
            "assign uhalt_phase = 1'b0; end else begin : GEN_UHALT_PHASE",
            "reg r_uhalt_phase;",
            "initial r_uhalt_phase = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(w_release_from_interrupt)) r_uhalt_phase <= 1'b0; else if ((alu_gie)&&(alu_pc_valid)) r_uhalt_phase <= alu_phase; else if ((!alu_gie)&&(wr_",
            "reg _ce)&&(wr_write_pc) &&(wr_",
            "reg _id[4])) r_uhalt_phase <= wr_sp",
            "reg _vl[1];",
            "assign uhalt_phase = r_uhalt_phase; end endgenerate // }}} // ipc, upc: Program counters // {{{ // // Write backs to the PC",
            "reg ister, and general increments of it // We support two: upc and ipc. If the instruction is normal, // we increment upc, if interrupt level we increment ipc. If // the instruction writes the PC, we write whichever PC is appropriate. // // Do we need to all our partial results from the pipeline? // What happens when the pipeline has gie and !gie instructions within // it? Do we clear both? What if a gie instruction tries to clear // a non-gie instruction? // upc generate if (OPT_USERMODE) begin : SET_USER_PC // {{{",
            "reg [(AW+1):0] r_upc;",
            "always @(posedge i_clk) if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id[4])&&(wr_write_pc)) r_upc <= { wr_sp",
            "reg _vl[(AW+1):2], 2'b00 }; else if ((alu_gie)&& (((alu_pc_valid)&&(!clear_pipeline)&&(!alu_illegal)) ||(mem_pc_valid))) r_upc <= alu_pc;",
            "assign upc = r_upc; // }}} end else begin : NO_UPC // {{{",
            "assign upc = {(AW+2){1'b0}}; // }}} end endgenerate // ipc // {{{",
            "initial ipc = { RESET_BUS_ADDRESS, 2'b00 };",
            "always @(posedge i_clk) if (i_reset) ipc <= { RESET_BUS_ADDRESS, 2'b00 }; else if ((wr_",
            "reg _ce)&&(!wr_",
            "reg _id[4])&&(wr_write_pc)) ipc <= { wr_sp",
            "reg _vl[(AW+1):2], 2'b00 }; else if ((!alu_gie)&&(!alu_phase)&& (((alu_pc_valid)&&(!clear_pipeline)&&(!alu_illegal)) ||(mem_pc_valid))) ipc <= alu_pc; // }}} // }}} // pf_pc : the program counter used by the pre-fetch // {{{ // pfpcset, pfpcsrc // {{{",
            "always @(*) begin pfpcset = 0; pfpcsrc = 0; if (i_reset) begin pfpcsrc = 0; pfpcset = 1; end else if ((dbgv)&&(wr_",
            "reg _ce)&&(wr_",
            "reg _id[4] == gie && wr_write_pc)) begin pfpcsrc = 1; // sp",
            "reg pfpcset = 1; end else if ((w_switch_to_interrupt) ||((!gie)&&((o_clear_icache)||(dbg_clear_pipe)))) begin pfpcsrc = 2; // ipc pfpcset = 1; end else if ((w_release_from_interrupt)||((gie)&&((o_clear_icache)||(dbg_clear_pipe)))) begin pfpcsrc = 3; // upc pfpcset = 1; end else if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id[4] == gie && wr_write_pc)) begin pfpcsrc = 1; // sp",
            "reg pfpcset = 1; end else if ((dcd_early_branch_stb)&&(!clear_pipeline)) begin pfpcsrc = 4; // branch pfpcset = 1; end else if ((new_pc)||(o_pf_ready&& i_pf_valid)) begin pfpcsrc = 5; // PC increment pfpcset = 1; end end // }}}",
            "initial pf_pc = { RESET_BUS_ADDRESS, 2'b00 };",
            "always @(posedge i_clk) if (pfpcset) case(pfpcsrc) 3'b000: pf_pc <= { RESET_BUS_ADDRESS, 2'b00 }; 3'b001: pf_pc <= { wr_sp",
            "reg _vl[(AW+1):2], 2'b00 }; 3'b010: pf_pc <= { ipc[(AW+1):2], 2'b00 }; 3'b011: pf_pc <= { upc[(AW+1):2], 2'b00 }; 3'b100: pf_pc <= { dcd_branch_pc[AW+1:2] + 1'b1, 2'b00 }; 3'b101: pf_pc <= { pf_pc[(AW+1):2] + 1'b1, 2'b00 }; default: pf_pc <= { RESET_BUS_ADDRESS, 2'b00 }; endcase /* if (i_reset) pf_pc <= { RESET_BUS_ADDRESS, 2'b00 }; else if ((dbg_clear_pipe)&&(wr_",
            "reg _ce)&&(wr_write_pc)) pf_pc <= { wr_sp",
            "reg _vl[(AW+1):2], 2'b00 }; else if ((w_switch_to_interrupt) ||((!gie)&&((o_clear_icache)||(dbg_clear_pipe)))) pf_pc <= { ipc[(AW+1):2], 2'b00 }; else if ((w_release_from_interrupt)||((gie)&&((o_clear_icache)||(dbg_clear_pipe)))) pf_pc <= { upc[(AW+1):2], 2'b00 }; else if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id[4] == gie)&&(wr_write_pc)) pf_pc <= { wr_sp",
            "reg _vl[(AW+1):2], 2'b00 }; else if ((dcd_early_branch_stb)&&(!clear_pipeline)) pf_pc <= { dcd_branch_pc[AW+1:2] + 1'b1, 2'b00 }; else if ((new_pc)||((!pf_stalled)&&(i_pf_valid))) pf_pc <= { pf_pc[(AW+1):2] + 1'b1, 2'b00 }; */ // }}}",
            "initial last_write_to_cc = 1'b0;",
            "always @(posedge i_clk) if (i_reset) last_write_to_cc <= 1'b0; else last_write_to_cc <= (wr_",
            "reg _ce)&&(wr_write_cc);",
            "assign cc_write_hold = (wr_",
            "reg _ce && wr_write_cc)||(last_write_to_cc); // o_clear_icache // {{{ // If we aren't pipelined, or equivalently if we have no cache, these // instructions will get quietly (or not so quietly) ignored by the // optimizer.",
            "initial r_clear_icache = 1'b1;",
            "always @(posedge i_clk) if (i_reset) r_clear_icache <= 1'b0; else if (i_clear_cache && !o_dbg_stall) r_clear_icache <= 1'b1; else if ((wr_",
            "reg _ce)&&(wr_write_scc)) r_clear_icache <= wr_sp",
            "reg _vl[CPU_CLRICACHE_BIT]; else r_clear_icache <= 1'b0;",
            "assign o_clear_icache = r_clear_icache; // }}} // o_clear_dcache // {{{ generate if (OPT_DCACHE) begin : CLEAR_DCACHE",
            "reg r_clear_dcache;",
            "initial r_clear_dcache = 1'b1;",
            "always @(posedge i_clk) if (i_reset) r_clear_dcache <= 1'b0; else if (i_clear_cache && !o_dbg_stall) r_clear_dcache <= 1'b1; else if ((wr_",
            "reg _ce)&&(wr_write_scc)) r_clear_dcache <= wr_sp",
            "reg _vl[CPU_CLRDCACHE_BIT]; else r_clear_dcache <= 1'b0;",
            "assign o_clear_dcache = r_clear_dcache; end else begin : NOCLEAR_DCACHE",
            "assign o_clear_dcache = 1'b0; end endgenerate // }}} // new_pc : does the Prefetch need to clear the pipeline and start over? // {{{",
            "initial new_pc = 1'b1;",
            "always @(posedge i_clk) if ((i_reset)||(o_clear_icache)||(dbg_clear_pipe)) new_pc <= 1'b1; else if (w_switch_to_interrupt) new_pc <= 1'b1; else if (w_release_from_interrupt) new_pc <= 1'b1; // else if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id[4] == gie)&&(wr_write_pc)) // Can't check for *this* PC here, since a user PC might be // loaded in the pipeline and hence rewritten. Thus, while // I hate to do it, we'll need to clear the pipeline on any // PC write else if ((wr_",
            "reg _ce)&&(alu_gie == wr_",
            "reg _id[4])&&(wr_write_pc)) new_pc <= 1'b1; else new_pc <= 1'b0; // }}} // // The debug write-back interface // {{{ // debug_pc // {{{ generate if (OPT_USERMODE) begin : DBGPC_FULL // {{{",
            "always @(*) begin debug_pc = 0; if (!OPT_DBGPORT) begin // Empty block--if there's no debug port, we'll // leave this valu at zero to reduce power end else if (i_dbg_r",
            "reg [4]) // User mode debug_pc[(AW+1):0] = { upc[(AW+1):2], uhalt_phase, 1'b0 }; else // Supervisor mode debug_pc[(AW+1):0] = { ipc[(AW+1):2], ihalt_phase, 1'b0 }; end // }}} end else begin : DBGPC_NO_USER // {{{",
            "always @(*) begin debug_pc = 0; if (OPT_DBGPORT) debug_pc[(AW+1):0] = { ipc[AW+1:2], ihalt_phase, 1'b0 }; end // }}} end endgenerate // }}} // o_dbg_",
            "reg // {{{ generate if (!OPT_DBGPORT) begin : NO_DBGPORT",
            "assign o_dbg_",
            "reg = 0; // verilator lint_off UNUSED",
            "wire unused_dbgport;",
            "assign unused_dbgport = &{ 1'b0, i_dbg_r",
            "reg , debug_pc }; // verilator lint_on UNUSED end else if (OPT_USERMODE) begin : SETDBG // {{{",
            "reg [31:0] pre_dbg_",
            "reg , r_dbg_",
            "reg ; if (OPT_DISTRIBUTED_REGS) begin : GEN_DISTRIBUTED_RAM_DBG // {{{",
            "always @(*) pre_dbg_",
            "reg =",
            "reg set[i_dbg_r",
            "reg ];",
            "always @(posedge i_clk) begin r_dbg_",
            "reg <= pre_dbg_",
            "reg ; if (i_dbg_r",
            "reg [3:0] == CPU_PC_REG) r_dbg_",
            "reg <= debug_pc; else if (i_dbg_r",
            "reg [3:0] == CPU_CC_REG) begin r_dbg_",
            "reg [15:0] <= (i_dbg_r",
            "reg [4]) ? w_uflags : w_iflags; r_dbg_",
            "reg [31:23] <= w_cpu_info; r_dbg_",
            "reg [CPU_GIE_BIT] <= i_dbg_r",
            "reg [4]; end end",
            "assign o_dbg_",
            "reg = r_dbg_",
            "reg ; // }}} end else begin : GEN_BKRAM_DBG // {{{",
            "reg [1:0] dbg_",
            "reg _sel;",
            "reg [31:0] pre_dbg_special; // First clock",
            "always @(posedge i_clk) begin dbg_",
            "reg _sel[1] <= (i_dbg_r",
            "reg [3:1] == 3'h7); dbg_",
            "reg _sel[0] <= i_dbg_r",
            "reg [0]; end",
            "always @(posedge i_clk) pre_dbg_",
            "reg <=",
            "reg set[i_dbg_r",
            "reg ];",
            "always @(posedge i_clk) if (i_dbg_r",
            "reg [0]) pre_dbg_special <= debug_pc; else begin pre_dbg_special <= 0; pre_dbg_special[15:0] <= (i_dbg_r",
            "reg [4]) ? w_uflags : w_iflags; pre_dbg_special[31:23] <= w_cpu_info; pre_dbg_special[CPU_GIE_BIT] <= i_dbg_r",
            "reg [4]; end // Second clock",
            "always @(posedge i_clk) if (!dbg_",
            "reg _sel[1]) r_dbg_",
            "reg <= pre_dbg_",
            "reg ; else if (dbg_",
            "reg _sel[0]) r_dbg_",
            "reg <= pre_dbg_special; else begin r_dbg_",
            "reg <= pre_dbg_special; r_dbg_",
            "reg [22:16] <= pre_dbg_",
            "reg [22:16]; end",
            "assign o_dbg_",
            "reg = r_dbg_",
            "reg ; // }}} end // }}} end else begin : NO_USER_SETDBG // {{{",
            "reg [31:0] r_dbg_",
            "reg , pre_dbg_",
            "reg ; if (OPT_DISTRIBUTED_REGS) begin : GEN_DISTRIBUTED_RAM_DBG",
            "always @(*) pre_dbg_",
            "reg =",
            "reg set[i_dbg_r",
            "reg [3:0]];",
            "always @(posedge i_clk) begin r_dbg_",
            "reg <= pre_dbg_",
            "reg ; if (i_dbg_r",
            "reg [3:0] == CPU_PC_REG) r_dbg_",
            "reg <= debug_pc; else if (i_dbg_r",
            "reg [3:0] == CPU_CC_REG) begin r_dbg_",
            "reg [15:0] <= w_iflags; r_dbg_",
            "reg [31:23] <= w_cpu_info; r_dbg_",
            "reg [CPU_GIE_BIT] <= 1'b0; end end end else begin : GEN_BKRAM_DBG // {{{",
            "reg [1:0] dbg_",
            "reg _sel;",
            "reg [31:0] pre_dbg_special; // First clock",
            "always @(posedge i_clk) begin dbg_",
            "reg _sel[1] <= (i_dbg_r",
            "reg [3:1] == 3'h7); dbg_",
            "reg _sel[0] <= i_dbg_r",
            "reg [0]; end",
            "always @(posedge i_clk) pre_dbg_",
            "reg <=",
            "reg set[i_dbg_r",
            "reg [3:0]];",
            "always @(posedge i_clk) if (i_dbg_r",
            "reg [0]) pre_dbg_special <= debug_pc; else begin pre_dbg_special <= 0; pre_dbg_special[15:0] <= w_iflags; pre_dbg_special[31:23] <= w_cpu_info; pre_dbg_special[CPU_GIE_BIT] <= 1'b0; end // Second clock",
            "always @(posedge i_clk) if (!dbg_",
            "reg _sel[1]) r_dbg_",
            "reg <= pre_dbg_",
            "reg ; else if (dbg_",
            "reg _sel[0]) r_dbg_",
            "reg <= pre_dbg_special; else begin r_dbg_",
            "reg <= pre_dbg_special; r_dbg_",
            "reg [22:16] <= pre_dbg_",
            "reg [22:16]; end",
            "assign o_dbg_",
            "reg = r_dbg_",
            "reg ; // }}} end",
            "assign o_dbg_",
            "reg = r_dbg_",
            "reg ; // }}} end endgenerate // }}}",
            "always @(posedge i_clk) o_dbg_cc <= { i_bus_err, gie, sleep }; // r_halted // {{{ generate if (OPT_PIPELINED) begin : GEN_HALT_PIPELINED // {{{",
            "initial r_halted = OPT_START_HALTED;",
            "always @(posedge i_clk) if (i_reset) r_halted <= OPT_START_HALTED; else if (!i_halt) r_halted <= 1'b0; else if (r_halted) r_halted <= 1'b1; else r_halted <= (!alu_phase)&&(!o_bus_lock)&&( // To be halted, any long lasting instruction // must be completed. (i_pf_valid)&&(!i_mem_busy)&&(!alu_busy) &&(!div_busy)&&(!fpu_busy) // Operations must either be valid, or illegal &&((dcd_valid)||(dcd_illegal))); // }}} end else begin : GEN_HALT_NOPIPE // {{{",
            "initial r_halted = OPT_START_HALTED;",
            "always @(posedge i_clk) if (i_reset) r_halted <= OPT_START_HALTED; else if (!i_halt) r_halted <= 1'b0; else if (r_halted) r_halted <= 1'b1; else r_halted <= (!alu_phase) // To be halted, any long lasting instruction // must be completed. &&(i_pf_valid)&&(!i_mem_busy)&&(!alu_busy) &&(!div_busy)&&(!fpu_busy); // }}} end endgenerate // }}} // o_dbg_stall // {{{",
            "initial r_dbg_stall = 1'b1;",
            "always @(posedge i_clk) if (i_reset) r_dbg_stall <= 1'b1; else if (!r_halted || (wr_",
            "reg _ce && wr_",
            "reg _id[3:1] == 3'h7)) r_dbg_stall <= 1'b1; else r_dbg_stall <= (OPT_DBGPORT && i_dbg_we && !o_dbg_stall);",
            "assign o_dbg_stall = OPT_DBGPORT && (!r_halted || r_dbg_stall); // }}} // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Accounting",
            "output s // {{{ // // // Produce accounting",
            "output s: Account for any CPU stalls, so we can // later evaluate how well we are doing. // // assign o_op_stall = (master_ce)&&(op_stall);",
            "assign o_pf_stall = (master_ce)&&(!i_pf_valid);",
            "assign o_i_count = (alu_pc_valid)&&(!clear_pipeline); // }}} //////////////////////////////////////////////////////////////////////// // // The debug scope",
            "output // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_TRACE_PORT) begin : GEN_DEBUG_PORT",
            "localparam [1:0] DBGSRC_FLAGS = 2'b00, DBGSRC_WRITEBACK = 2'b01, DBGSRC_JUMP = 2'b10;",
            "reg [31:0] r_debug;",
            "reg debug_trigger, dbg_mem_we;",
            "wire [27:0] debug_flags;",
            "reg [1:0] dbgsrc; // Verilator lint_off UNUSED",
            "wire [27:0] dbg_pc, dbg_wb_addr; // Verilator lint_on UNUSED",
            "initial debug_trigger = 1'b0;",
            "always @(posedge i_clk) debug_trigger <= (!i_halt)&&(o_break);",
            "always @(posedge i_clk) if (o_mem_ce) dbg_mem_we <= o_mem_op[0];",
            "assign debug_flags = { master_ce, i_halt, o_break, sleep, gie, ibus_err_flag, trap, ill_err_i, o_clear_icache, i_pf_valid, i_pf_illegal, dcd_ce, dcd_valid, dcd_stalled, op_ce, op_valid, op_pipe, alu_ce, alu_busy, alu_wR, alu_illegal, alu_wF, mem_ce, dbg_mem_we, i_mem_busy, i_mem_pipe_stalled, (new_pc), (dcd_early_branch) }; if (AW-1 < 27) begin : GEN_SHORT_DBGPC",
            "assign dbg_pc[(AW-1):0] = pf_pc[(AW+1):2];",
            "assign dbg_pc[27:AW] = 0;",
            "assign dbg_wb_addr[(AW-1):0] = 0;",
            "assign dbg_wb_addr[27:AW] = 0; end else // if (AW-1 >= 27) begin : GEN_WIDE_DBGPC",
            "assign dbg_pc[27:0] = pf_pc[29:2];",
            "assign dbg_wb_addr = 0; end",
            "always @(posedge i_clk) begin dbgsrc <= 0; if ((i_halt)||(!master_ce)||(debug_trigger)||(o_break)) dbgsrc <= DBGSRC_FLAGS; else if ((i_mem_valid)||((!clear_pipeline)&&(!alu_illegal) &&(((alu_wR)&&(alu_valid)) ||(div_valid)||(fpu_valid)))) dbgsrc <= DBGSRC_WRITEBACK; else if (clear_pipeline) dbgsrc <= DBGSRC_JUMP; else dbgsrc <= DBGSRC_FLAGS; end",
            "always @(posedge i_clk) casez(dbgsrc) DBGSRC_FLAGS: r_debug <= { debug_trigger, 3'b101, debug_flags }; DBGSRC_WRITEBACK: r_debug <= { debug_trigger, 1'b0, wr_",
            "reg _id[3:0], wr_gp",
            "reg _vl[25:0]}; DBGSRC_JUMP: r_debug <= { debug_trigger, 3'b100, dbg_pc }; default: r_debug <= 32'h0; endcase",
            "assign o_debug = r_debug; end else begin : NO_TRACE_PORT",
            "assign o_debug = 32'h0; end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // (Optional) Hardware profiler support // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_PROFILER) begin : GEN_PROFILER",
            "reg prof_stb;",
            "reg [AW+1:0] prof_addr;",
            "reg [31:0] prof_ticks;",
            "initial prof_stb = 1'b0;",
            "always @(posedge i_clk) if (i_reset || clear_pipeline) prof_stb <= 1'b0; else prof_stb <= (alu_pc_valid || mem_pc_valid);",
            "initial prof_addr = 0;",
            "always @(posedge i_clk) if (i_reset || clear_pipeline) prof_addr <= RESET_ADDRESS[AW+1:0]; else if (alu_pc_valid || mem_pc_valid) prof_addr <= alu_pc;",
            "initial prof_ticks = 0;",
            "always @(posedge i_clk) if (i_reset) prof_ticks <= 0; else if (!i_halt) prof_ticks <= prof_ticks + 1;",
            "assign o_prof_stb = prof_stb;",
            "assign o_prof_addr = prof_addr;",
            "assign o_prof_ticks = prof_ticks; end else begin : NO_PROFILER",
            "assign o_prof_stb = 1'b0;",
            "assign o_prof_addr = 0;",
            "assign o_prof_ticks = 0; end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // (Optional) Verilator $display simulation dumping support // {{{ //////////////////////////////////////////////////////////////////////// // // // The following is somewhat useful for debugging under Icarus Verilog. // In that case, the VCD file can tell you what's going on at any // specific moment, but it doesn't put the",
            "reg ister set into the VCD // file, nor does it give you any insight into the current contents of // the memory, or how they got that way. The following is intended to // be a first step towards that end. // // As currently envisioned, we track values written to the",
            "reg isters, // and values read and written to memory. The program counter offered // is typically off by 4 from the actual instruction address being // completed. It may be off by more in the case of memory instructions. // I haven't (yet) tried to make the PC given match the instruction // address--so that may be an item to do later. // // You can activate (or de-activate) these instructions via the // OPT_SIM_DEBUG flag below. If set to one, the simulation debuggin // statements will be",
            "output as the CPU executes.",
            "localparam OPT_SIM_DEBUG = 1'b0; generate if (OPT_SIM_DEBUG) begin : GEN_SIM_DEBUG",
            "reg [31:0] nstime;",
            "initial nstime = 0;",
            "always @(posedge i_clk) nstime <= nstime + 10;",
            "always @(posedge i_clk) if (!i_reset && o_mem_ce) begin if (o_mem_",
            "reg [4] && !o_mem_op[0]) begin case(o_mem_op[2:1]) // 3'b000: // 3'b001: 2'b01: $display(\"MEM: %8d LW uR%1d <- @%08x\", nstime, o_mem_",
            "reg [3:0], o_mem_addr); 2'b10: $display(\"MEM: %8d LH uR%1d <- @%08x\", nstime, o_mem_",
            "reg [3:0], o_mem_addr); 2'b11: $display(\"MEM: %8d LB uR%1d <- @%08x\", nstime, o_mem_",
            "reg [3:0], o_mem_addr); default: $display(\"MEM: %8d Unknown MEM op: %d\\n\", nstime, o_mem_op); endcase end else case(o_mem_op[2:0]) // 3'b000: // 3'b001: 3'b010: $display(\"MEM: %8d LW sR%1d <- @%08x\", nstime, o_mem_",
            "reg , o_mem_addr); 3'b011: $display(\"MEM: %8d SW 0x%08x -> @%08x\", nstime, o_mem_data, o_mem_addr); 3'b100: $display(\"MEM: %8d LH sR%1d <- @%08x\", nstime, o_mem_",
            "reg , o_mem_addr); 3'b101: $display(\"MEM: %8d SH 0x%08x -> @%04x\", nstime, o_mem_data[15:0], o_mem_addr); 3'b110: $display(\"MEM: %8d LB sR%1d <- @%08x\", nstime, o_mem_",
            "reg , o_mem_addr); 3'b111: $display(\"MEM: %8d SB 0x%08x -> @%02x\", nstime, o_mem_data[7:0], o_mem_addr); default: $display(\"MEM: %8d Unknown MEM op: %d\\n\", nstime, o_mem_op); endcase end",
            "always @(posedge i_clk) if (!i_reset && i_bus_err) begin $display(\"MEM: %8d BUS ERROR!!\", nstime); end",
            "always @(posedge i_clk) if (!i_reset && wr_",
            "reg _ce) begin if (i_mem_valid) begin if (i_mem_w",
            "reg [4]) $display(\"MEM: %8d Load 0x%08x -> uR%1d\", nstime, i_mem_result, i_mem_w",
            "reg [3:0]); else $display(\"MEM: %8d Load 0x%08x -> sR%1d\", nstime, i_mem_result, i_mem_w",
            "reg [3:0]); end if (wr_",
            "reg _id[4] && OPT_USERMODE) begin if (wr_",
            "reg _id[3:0] == CPU_PC_REG) $display(\"REG: %8d uPC <- 0x%08x [0x%08x]\", nstime, wr_sp",
            "reg _vl, (gie) ? upc : ipc); else if (wr_",
            "reg _id[3:0] == CPU_CC_REG) $display(\"REG: %8d uCC <- 0x%08x [0x%08x]\", nstime, wr_sp",
            "reg _vl, (gie) ? upc : ipc); else if (wr_",
            "reg _id == 4'hd) $display(\"REG: %8d uSP <- 0x%08x [0x%08x]\", nstime, wr_gp",
            "reg _vl, (gie) ? upc : ipc); else $display(\"REG: %8d uR%1x <- 0x%08x [0x%08x]\", nstime, wr_",
            "reg _id[3:0], wr_gp",
            "reg _vl, (gie) ? upc : ipc); end else begin if (wr_",
            "reg _id[3:0] == CPU_PC_REG) $display(\"REG: %8d sPC <- 0x%08x [0x%08x]\", nstime, wr_sp",
            "reg _vl, ipc); else if (wr_",
            "reg _id[3:0] == CPU_CC_REG) $display(\"REG: %8d sCC <- 0x%08x [0x%08x]\", nstime, wr_sp",
            "reg _vl, ipc); else if (wr_",
            "reg _id[3:0] == 4'hd) $display(\"REG: %8d sSP <- 0x%08x [0x%08x]\", nstime, wr_gp",
            "reg _vl, ipc); else $display(\"REG: %8d sR%1x <- 0x%08x [0x%08x]\", nstime, wr_",
            "reg _id[3:0], wr_gp",
            "reg _vl, ipc); end end end endgenerate // }}} // Make verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, fpu_ce, wr_sp",
            "reg _vl[1:0], ipc[1:0], upc[1:0], pf_pc[1:0], dcd_rA, dcd_pipe, dcd_zI, dcd_A_stall, dcd_B_stall, dcd_F_stall, op_Rcc, op_pipe, op_lock, i_mem_pipe_stalled, prelock_stall, dcd_F, w_clken }; generate if (AW+2 < 32) begin : UNUSED_AW",
            "wire generic_ignore;",
            "assign generic_ignore = &{ 1'b0, wr_sp",
            "reg _vl[31:(AW+2)] }; end if (!OPT_USERMODE) begin : UNUSED_USERMODE",
            "wire unused_usermode;",
            "assign unused_usermode = &{ 1'b0, alu_",
            "reg [4], i_mem_w",
            "reg [4], i_dbg_r",
            "reg [4] }; end endgenerate // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Declarations // {{{ `ifdef ZIPCPU `define ASSUME assume `else `define ASSUME assert `endif `define ASSERT assert // // wire [1+1+4+15+6+4+13+AW+1+32+4+23-1:0] f_dcd_data;",
            "wire fc_op_prepipe;",
            "wire [6:0] fc_alu_Aid;",
            "wire fc_alu_wR, fc_alu_M, fc_alu_prepipe;",
            "reg f_alu_phase;",
            "reg f_past_valid;",
            "reg [2:0] f_dbg_pc_seq, f_dbg_cc_seq, f_dbg_",
            "reg _seq;",
            "wire fc_op_illegal, fc_op_wF, fc_op_ALU, fc_op_M, fc_op_DV, fc_op_FP, fc_op_break, fc_op_lock, fc_op_wR, fc_op_rA, fc_op_rB, fc_op_sim;",
            "wire [6:0] fc_op_Rid, fc_op_Aid, fc_op_Bid;",
            "wire [31:0] fc_op_I;",
            "wire [3:0] fc_op_cond;",
            "wire [3:0] fc_op_op;",
            "wire [22:0] fc_op_sim_immv;",
            "wire f_op_insn; //f_alu_insn,f_wb_insn",
            "reg f_op_phase, f_op_early_branch;",
            "reg f_op_zI;",
            "reg f_op_branch;",
            "wire [31:0] f_Bv;",
            "reg [31:0] f_Av, f_pre_Bv;",
            "reg f_alu_branch;",
            "wire [31:0] f_dcd_mem_addr;",
            "wire [AW-1:0] f_next_mem, f_op_mem_addr;",
            "wire [4+AW+2+7+4-1:0] f_op_data;",
            "wire fc_alu_illegal, fc_alu_wF, fc_alu_ALU, fc_alu_DV, fc_alu_FP, fc_alu_break, fc_alu_lock, fc_alu_rA, fc_alu_rB, fc_alu_sim;",
            "wire [6:0] fc_alu_Rid, fc_alu_Bid;",
            "wire [31:0] fc_alu_I;",
            "wire [3:0] fc_alu_cond;",
            "wire [3:0] fc_alu_op;",
            "wire [22:0] fc_alu_sim_immv;",
            "wire [F_LGDEPTH-1:0] f_mem_outstanding;",
            "wire f_mem_gie, f_mem_pc, f_read_cycle, f_exwrite_cycle;",
            "wire [4:0] f_last_",
            "reg , f_addr_",
            "reg ;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; `ifndef VERIFIC",
            "initial assume(i_reset); `endif",
            "always @(posedge i_clk) if (!f_past_valid) assume(i_reset); // }}} //////////////////////////////////////////////////////////////////////// // // The debugging interface // {{{ //////////////////////////////////////////////////////////////////////// // // fdebug #( .OPT_START_HALTED(OPT_START_HALTED), .OPT_DISTRIBUTED_RAM(OPT_DISTRIBUTED_REGS) ) fdbg ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_cpu_reset(i_reset), .i_halt(i_halt), .i_halted(r_halted), .i_clear_cache(i_clear_cache), .i_dbg_we(i_dbg_we), .i_dbg_",
            "reg (i_dbg_w",
            "reg ), .i_dbg_data(i_dbg_data), .i_dbg_stall(o_dbg_stall), .i_dbg_break(o_break), .i_dbg_cc(o_dbg_cc) // , .i_dbg_r",
            "reg (i_dbg_r",
            "reg ), // .i_dbg_rdata(o_dbg_rdata), // }}} );",
            "always @(*) if (i_halt && r_halted) begin `ASSERT(!alu_ce); `ASSERT(!alu_phase); `ASSERT(!div_ce); `ASSERT(!o_mem_ce); `ASSERT(f_mem_outstanding == 0); end",
            "initial f_dbg_pc_seq = 0;",
            "always @(posedge i_clk) if (i_reset) f_dbg_pc_seq <= 0; else begin f_dbg_pc_seq[0] <= i_dbg_we && !o_dbg_stall && (i_dbg_w",
            "reg == { gie, CPU_PC_REG }); f_dbg_pc_seq[2:1] <= f_dbg_pc_seq[1:0]; end",
            "always @(posedge i_clk) begin if (f_dbg_pc_seq[0]) begin `ASSERT(dbgv && alu_",
            "reg == { gie, CPU_PC_REG }); end if (f_dbg_pc_seq[1]) begin `ASSERT(clear_pipeline); `ASSERT(o_pf_request_address == $past({ i_dbg_data[31:2], 2'b00 },2)); end end",
            "initial f_dbg_cc_seq = 0;",
            "always @(posedge i_clk) if (i_reset) f_dbg_cc_seq <= 0; else begin f_dbg_cc_seq[0] <= i_dbg_we && !o_dbg_stall && (i_dbg_w",
            "reg == { gie, CPU_CC_REG }); f_dbg_cc_seq[2:1] <= f_dbg_cc_seq[1:0]; end",
            "always @(posedge i_clk) if (f_dbg_cc_seq[0]) begin `ASSERT(wr_",
            "reg _ce); `ASSERT(wr_",
            "reg _id == $past(i_dbg_w",
            "reg )); `ASSERT(wr_sp",
            "reg _vl == $past(i_dbg_data)); end",
            "initial f_dbg_",
            "reg _seq = 0;",
            "always @(posedge i_clk) if (i_reset) f_dbg_",
            "reg _seq <= 0; else begin f_dbg_",
            "reg _seq[0] <= i_dbg_we && !o_dbg_stall && (i_dbg_r",
            "reg [3:1] != 3'h7 ); f_dbg_",
            "reg _seq[2:1] <= f_dbg_",
            "reg _seq[1:0]; end",
            "always @(posedge i_clk) begin if (f_dbg_",
            "reg _seq[0] && !i_reset) begin `ASSERT(dbgv && alu_",
            "reg == $past(i_dbg_w",
            "reg )); `ASSERT($past(i_dbg_r",
            "reg [3:1]) != 3'h7); `ASSERT(dbg_val == $past(i_dbg_data)); `ASSERT(wr_",
            "reg _ce); `ASSERT(wr_gp",
            "reg _vl == $past(i_dbg_data)); `ASSERT(wr_",
            "reg _id == $past(i_dbg_w",
            "reg )); end // if (f_dbg_",
            "reg _seq[1]) // begin // end end // }}} //////////////////////////////////////////////////////////////////////// // // Reset checks // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) begin // Initial assertions `ASSERT(!i_pf_valid); `ASSERT(!dcd_phase); `ASSERT(!op_phase); `ASSERT(!alu_phase); // `ASSERT(!i_pf_valid); `ASSERT(!dcd_valid); `ASSERT(!op_valid); `ASSERT(!op_valid_mem); `ASSERT(!op_valid_div); `ASSERT(!op_valid_alu); `ASSERT(!op_valid_fpu); // `ASSERT(!alu_valid); `ASSERT(!alu_busy); // `ASSERT(!i_mem_valid); `ASSERT(!i_mem_rdbusy); `ASSERT(!i_bus_err); // `ASSERT(!div_valid); `ASSERT(!div_busy); `ASSERT(!div_error); // `ASSERT(!fpu_valid); `ASSERT(!fpu_busy); `ASSERT(!fpu_error); // `ASSERT(!ill_err_i); `ASSERT(!ill_err_u); `ASSERT(!idiv_err_flag); `ASSERT(!udiv_err_flag); `ASSERT(!ibus_err_flag); `ASSERT(!ubus_err_flag); `ASSERT(!ifpu_err_flag); `ASSERT(!ufpu_err_flag); `ASSERT(!ihalt_phase); `ASSERT(!uhalt_phase); end",
            "always @(*) begin if (i_pf_valid) `ASSERT(f_past_valid); if (dcd_valid) `ASSERT(f_past_valid); if (alu_pc_valid) `ASSERT(f_past_valid); if (i_mem_valid) `ASSERT(f_past_valid); if (div_valid) `ASSERT(f_past_valid); if (fpu_valid) `ASSERT(f_past_valid); if (w_op_valid) `ASSERT(f_past_valid); // if (i_mem_busy) `ASSERT(f_past_valid); if (i_mem_rdbusy) `ASSERT(f_past_valid); if (div_busy) `ASSERT(f_past_valid); if (fpu_busy) `ASSERT(f_past_valid); end // }}} //////////////////////////////////////////////////////////////////////// // // Pipeline signaling check // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (clear_pipeline) begin // `ASSERT(!alu_ce); `ASSERT(!mem_ce); end",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(clear_pipeline))) begin `ASSERT(!alu_busy); `ASSERT(!div_busy); `ASSERT(!i_mem_rdbusy); `ASSERT(!fpu_busy); // `ASSERT(!alu_valid); `ASSERT(!div_valid); `ASSERT(!fpu_valid); end",
            "always @(*) if (dcd_ce) `ASSERT((op_ce)||(!dcd_valid));",
            "always @(*) if ((op_ce)&&(!clear_pipeline)) `ASSERT((adf_ce_unconditional)||(mem_ce)||(!op_valid)); // // Make sure the dcd stage is never permanently stalled",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(alu_wR))&&(!$past(alu_wF)) &&($past(f_past_valid,2))&&(!$past(alu_wR,2))&&(!$past(alu_wF)) &&(!op_valid)&&(master_ce) &&(!clear_pipeline)&&(!i_reset) &&(!div_busy)&&(!div_valid) &&(!i_mem_busy)&&(!i_mem_valid)&&(!i_bus_err) &&(!alu_busy)&&(!alu_pc_valid)&&(!alu_valid) &&(!fpu_busy)&&(!fpu_valid)&&(!fpu_error) &&(!op_break)&&(!o_break) &&(!w_switch_to_interrupt) &&(!ibus_err_flag)&&(!ill_err_i)&&(!idiv_err_flag)) begin if (OPT_PIPELINED) `ASSERT(dcd_ce || cc_invalid_for_dcd || i_halt); if (!dcd_valid) `ASSERT(dcd_ce); end",
            "always @(posedge i_clk) if (OPT_PIPELINED && !i_halt && !i_reset && (wr_flags_ce || (wr_",
            "reg _ce && wr_",
            "reg _id == { op_gie, CPU_CC_REG }))) `ASSERT(cc_invalid_for_dcd);",
            "always @(posedge i_clk) if (!f_past_valid || !OPT_PIPELINED) begin `ASSERT(!cc_invalid_for_dcd); end else if (alu_busy) begin `ASSERT(cc_invalid_for_dcd == (alu_wF || alu_",
            "reg == { gie, CPU_CC_REG })); end else if (i_mem_rdbusy || i_bus_err) begin `ASSERT(i_bus_err || f_exwrite_cycle || cc_invalid_for_dcd == (alu_",
            "reg == { gie, CPU_CC_REG })); end else if (!clear_pipeline && cc_invalid_for_dcd) begin `ASSERT(alu_illegal || wr_flags_ce || ((i_mem_valid || i_bus_err) && ($past(i_mem_rdbusy && f_last_",
            "reg == { gie, CPU_CC_REG }))) || (wr_flags_ce || (wr_",
            "reg _ce && wr_",
            "reg _id == { op_gie, CPU_CC_REG })) || ($past(wr_flags_ce) || $past(wr_",
            "reg _ce && wr_",
            "reg _id == { op_gie, CPU_CC_REG }))); end // // Make sure the ops stage is never permanently stalled",
            "always @(*) if ((op_valid)&&(master_ce)&&(!clear_pipeline)&&(!i_reset) &&(!div_busy)&&(!div_valid) &&(!i_mem_busy)&&(!i_mem_valid)&&(!i_bus_err) &&(!alu_busy)&&(!alu_pc_valid) &&(!fpu_busy)&&(!fpu_valid)&&(!fpu_error) &&(!op_break)&&(!o_break) &&(!w_switch_to_interrupt) &&(!alu_illegal) && (!prelock_stall) &&(!step || !stepped) &&(!ibus_err_flag)&&(!ill_err_i)&&(!idiv_err_flag)) `ASSERT(adf_ce_unconditional | mem_ce); // always @(posedge i_clk) // if (f_past_valid&& $past(op_valid && dcd_valid && i_pf_valid // && !op_ce)) // `ASSERT(!prelock_stall); // // Make sure that, following an op_ce && op_valid, op_valid is only // true if dcd_valid was as well",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(op_ce && op_valid && !dcd_valid))) begin if ($past(dcd_early_branch)) begin `ASSERT(!dcd_early_branch); end else `ASSERT(!op_valid); end // // Same for the next step",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(op_valid && (mem_ce ||adf_ce_unconditional))) &&(!$past(dcd_valid))) begin if ($past(dcd_early_branch)) begin `ASSERT(!dcd_early_branch); end else `ASSERT(!op_valid); end // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about the Program counter // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (i_pf_valid) `ASSERT(i_pf_instruction_pc[1:0]==2'b00);",
            "always @(*) if ((dcd_valid)&&(!dcd_illegal)) `ASSERT((!dcd_pc[1])||(dcd_phase));",
            "always @(*) `ASSERT(!op_pc[0]);",
            "always @(*) `ASSERT(!alu_pc[0]); // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about the prefetch (",
            "output ) stage // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if ((!clear_pipeline)&&(i_pf_valid)) `ASSERT(pf_gie == gie);",
            "always @(*) if ((i_pf_valid)&&(!clear_pipeline)) `ASSERT(pf_gie == gie); ffetch #(.ADDRESS_WIDTH(ADDRESS_WIDTH), .OPT_CONTRACT(1'b0), .OPT_ALIGNED(1'b1)) chkifetch( .i_clk(i_clk), .i_reset(i_reset), .cpu_new_pc(o_pf_new_pc), .cpu_clear_cache(o_clear_icache), .cpu_pc(o_pf_request_address), .pf_valid(i_pf_valid), .cpu_ready(o_pf_ready), .pf_pc(i_pf_instruction_pc), .pf_insn(i_pf_instruction), .pf_illegal(i_pf_illegal)); // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about the decode stage // {{{ //////////////////////////////////////////////////////////////////////// // // assign f_dcd_data = { dcd_phase, dcd_opn, dcd_A, dcd_B, dcd_R, // 4+15 dcd_Acc, dcd_Bcc, dcd_Apc, dcd_Bpc, dcd_Rcc, dcd_Rpc,//6 dcd_F, // 4 dcd_wR, dcd_rA, dcd_rB, dcd_ALU, dcd_M, dcd_DIV, dcd_FP, dcd_wF, dcd_gie, dcd_break, dcd_lock, dcd_pipe, dcd_ljmp, dcd_pc, // AW+1 dcd_I, // 32 dcd_zI, // true if dcd_I == 0 dcd_illegal, dcd_early_branch, dcd_sim, dcd_sim_immv };",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&(!$past(clear_pipeline)) &&(!$past(o_clear_icache)) &&($past(dcd_valid))&&($past(dcd_stalled)) &&(!clear_pipeline)) begin `ASSERT((!OPT_PIPELINED)||(dcd_valid)); `ASSERT((!dcd_valid && OPT_LOWPOWER) || $stable(f_dcd_data)); `ASSERT((!dcd_valid && OPT_LOWPOWER) || $stable(f_dcd_insn_word)); end",
            "always @(*) if ((dcd_valid || dcd_phase)&&(!clear_pipeline)) `ASSERT(f_dcd_insn_gie == dcd_gie);",
            "always @(posedge i_clk) if ((dcd_valid)&&(!dcd_illegal)&&(!clear_pipeline)) begin `ASSERT(dcd_gie == gie); if ((gie)||(dcd_phase)) begin `ASSERT((!dcd_wR)||(dcd_R[4]==dcd_gie)); `ASSERT((!dcd_rA)||(dcd_A[4]==dcd_gie)); `ASSERT((!dcd_rB)||(dcd_B[4]==dcd_gie)); end else if ((!dcd_early_branch)&&((dcd_M) ||(dcd_DIV)||(dcd_FP)||(!dcd_wR))) `ASSERT(!dcd_gie); if ((dcd_ALU)&&(dcd_opn==CPU_MOV_OP)) begin `ASSERT(((!dcd_rA)&&(dcd_wR)) ||((!dcd_rA)&&(!dcd_rB)&&(!dcd_wR))); end else if (dcd_ALU) `ASSERT( (gie == dcd_R[4]) &&(gie == dcd_A[4]) &&((!dcd_rB)||(gie == dcd_B[4])) &&(dcd_gie == gie)); end",
            "always @(*) if ((op_valid)&&(op_rA)&&(op_Aid[3:1] == 3'h7)&&(!clear_pipeline) &&(op_Aid[4:0] != { gie, 4'hf})) `ASSERT(!pending_s",
            "reg _write);",
            "always @(*) if ((op_valid)&&(op_rB)&&(op_Bid[3:1] == 3'h7)&&(!clear_pipeline) &&(op_Bid[4:0] != { gie, 4'hf})) `ASSERT(!pending_s",
            "reg _write);",
            "always @(*) if ((dcd_valid)&&(!clear_pipeline)) `ASSERT(dcd_gie == gie); // // // Piped Memory assertions // // always @(*) if ((dcd_valid)&&(dcd_M)&&(dcd_pipe)&&(!dcd_illegal)&&(!alu_illegal) &&(!break_pending)&&(!clear_pipeline)) begin if (op_valid_mem) begin `ASSERT(op_opn[0] == dcd_opn[0]); `ASSERT((!dcd_rB) ||(op_Bid[4:0] == dcd_B[4:0])); `ASSERT(op_rB == dcd_rB); end `ASSERT(dcd_B[4] == dcd_gie); end",
            "always @(*) if (op_valid_mem && op_pipe && i_mem_busy) `ASSERT(f_read_cycle == !op_opn[0]);",
            "always @(*) if ((dcd_valid)&&(!dcd_M)) `ASSERT((dcd_illegal)||(!dcd_pipe));",
            "assign f_dcd_mem_addr = w_op_BnI+dcd_I;",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(dcd_early_branch))&&(!dcd_early_branch) &&(dcd_valid)) `ASSERT(!dcd_pipe);",
            "always @(*) if ((dcd_valid)&&(dcd_early_branch)) `ASSERT(!dcd_M);",
            "always @(*) if ((dcd_valid)&&(!dcd_illegal)&&(!fc_op_prepipe)) `ASSERT(!dcd_pipe);",
            "always @(*) if ((dcd_valid)&&(dcd_pipe)&&(w_op_valid)) begin // `ASSERT((dcd_A[3:1] != 3'h7)||(dcd_opn[0])); `ASSERT(dcd_B[3:1] != 3'h7); `ASSERT(dcd_rB); `ASSERT(dcd_M); `ASSERT(dcd_B == op_Bid); if (op_valid) `ASSERT((op_valid_mem)||(op_illegal)); if (op_valid_mem) begin `ASSERT((dcd_I[AW+1:3] == 0) ||(!alu_busy)||(!div_busy) ||(!alu_wR)||(alu_",
            "reg != dcd_B)); `ASSERT((!op_wR)||(op_Aid != op_Bid)); end end // // Decode option processing // // OPT_CIS ... the compressed instruction set",
            "always @(*) if ((!OPT_CIS)&&(dcd_valid)) begin `ASSERT(!dcd_phase); `ASSERT(dcd_pc[1:0] == 2'b0); end",
            "always @(*) if ((dcd_valid)&&(dcd_phase)) `ASSERT(f_dcd_insn_word[31]); // OPT_EARLY_BRANCHING",
            "always @(*) if (!OPT_EARLY_BRANCHING) `ASSERT((!dcd_early_branch) &&(!dcd_early_branch_stb) &&(!dcd_ljmp)); // OPT_DIV",
            "always @(*) if ((dcd_DIV)&&(dcd_valid)&&(!dcd_illegal)) `ASSERT(dcd_wR); // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about the op stage // {{{ //////////////////////////////////////////////////////////////////////// // // assign f_op_data = { op_valid_mem, op_valid_alu, op_valid_div, op_valid_fpu, // The Av and Bv values can change while we are stalled in the // op stage--that's why we are stalled there // r_op_Av, r_op_Bv, // 32 ea op_pc[AW+1:2], // AW op_wR, op_wF, r_op_F, // 7 op_illegal, op_break, op_lock, op_pipe };",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(op_valid))&&(!$past(i_reset)) &&(!$past(clear_pipeline))) begin if (($past(op_valid_mem))&&($past(mem_stalled))) `ASSERT($stable(f_op_data[AW+16:1])&&(!$rose(op_pipe))); if (($past(op_valid_div))&&($past(div_busy))) `ASSERT($stable(f_op_data)); end f_idecode #( // {{{ .OPT_MPY((OPT_MPY!=0)? 1'b1:1'b0), .OPT_SHIFTS(OPT_SHIFTS), .OPT_DIVIDE(OPT_DIV), .OPT_FPU(IMPLEMENT_FPU), .OPT_LOCK(OPT_LOCK), .OPT_OPIPE(OPT_PIPELINED_BUS_ACCESS), .OPT_SIM(1'b0), .OPT_USERMODE(OPT_USERMODE), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_CIS(OPT_CIS) // }}} ) f_insn_decode_op( // {{{ f_op_insn_word, f_op_phase, op_gie, fc_op_illegal, fc_op_Rid, fc_op_Aid, fc_op_Bid, fc_op_I, fc_op_cond, fc_op_wF, fc_op_op, fc_op_ALU, fc_op_M, fc_op_DV, fc_op_FP, fc_op_break, fc_op_lock, fc_op_wR, fc_op_rA, fc_op_rB, fc_op_prepipe, fc_op_sim, fc_op_sim_immv // }}} );",
            "initial f_op_early_branch = 1'b0;",
            "always @(posedge i_clk) if (op_ce && (!OPT_MEMPIPE || dcd_valid || dcd_illegal || dcd_early_branch)) begin f_op_insn_word <= f_dcd_insn_word; f_op_phase <= dcd_phase; f_op_early_branch <= dcd_early_branch; f_op_zI <= dcd_zI; end",
            "initial f_op_branch = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(clear_pipeline)) f_op_branch <= 1'b0; else if (op_ce) f_op_branch <= (dcd_early_branch)||dcd_ljmp; else if ((adf_ce_unconditional)||(mem_ce)) f_op_branch <= 1'b0;",
            "always @(*) if (!OPT_EARLY_BRANCHING) begin `ASSERT(!f_op_branch); end else if ((f_op_early_branch)&&(op_valid)) `ASSERT(f_op_branch);",
            "always @(posedge i_clk) if (op_valid &&(f_op_branch || !fc_op_illegal)&& !clear_pipeline) begin // {{{ if (f_op_branch) begin // {{{ `ASSERT(!op_valid_alu); `ASSERT(!op_valid_mem); `ASSERT(!op_valid_div); `ASSERT(!op_valid_fpu); `ASSERT(!op_illegal); `ASSERT(!op_rA); `ASSERT(!op_rB); `ASSERT(!op_wR); `ASSERT(!op_wF); `ASSERT(op_opn == CPU_MOV_OP); // }}} end if (op_illegal) begin // {{{ `ASSERT(!op_valid_mem); `ASSERT(!op_valid_div); `ASSERT(!op_valid_fpu); `ASSERT( op_valid_alu); `ASSERT((!OPT_PIPELINED)||(!op_rA)); `ASSERT((!OPT_PIPELINED)||(!op_rB)); `ASSERT(!f_op_branch); // }}} end else begin if (!f_op_branch) begin // {{{ `ASSERT(fc_op_ALU == op_valid_alu); `ASSERT(fc_op_M == op_valid_mem); `ASSERT(fc_op_DV == op_valid_div); `ASSERT(fc_op_FP == op_valid_fpu); `ASSERT(fc_op_rA == op_rA); `ASSERT(fc_op_rB == op_rB); `ASSERT(fc_op_wF == op_wF); `ASSERT(fc_op_Rid[4:0] == op_R); `ASSERT(f_op_zI == (fc_op_I == 0)); `ASSERT(fc_op_wF == op_wF); `ASSERT(fc_op_lock == op_lock); if (!OPT_PIPELINED && step && stepped) begin `ASSERT(!op_break); end else begin `ASSERT(fc_op_break == op_break); end `ASSERT(fc_op_I == 0 || !i_mem_rdbusy || f_exwrite_cycle || !fc_op_rB || (fc_op_Bid[4:0] != f_last_",
            "reg && (f_mem_outstanding <= 1) && (!fc_op_M || !op_pipe)) || fc_op_Bid[4:0] == f_addr_",
            "reg ); if (!i_halt && !i_reset && !f_exwrite_cycle) `ASSERT((!wr_",
            "reg _ce) ||(wr_",
            "reg _id != fc_op_Bid[4:0]) ||(!op_rB)||(fc_op_I == 0)); `ASSERT(fc_op_sim == op_sim); `ASSERT(fc_op_sim_immv == op_sim_immv); case(fc_op_cond[2:0]) 3'h0: `ASSERT(op_F == 8'h00); // Always 3'h1: `ASSERT(op_F == 8'h11); // Z 3'h2: `ASSERT(op_F == 8'h44); // LT 3'h3: `ASSERT(op_F == 8'h22); // C 3'h4: `ASSERT(op_F == 8'h88); // V 3'h5: `ASSERT(op_F == 8'h10); // NE 3'h6: `ASSERT(op_F == 8'h40); // GE (!N) 3'h7: `ASSERT(op_F == 8'h20); // NC endcase if ((fc_op_wR)&&(fc_op_Rid[4:0] == { gie, CPU_PC_REG})) begin `ASSERT(!op_phase); end else `ASSERT(f_op_phase == op_phase); // }}} end // Bit order is { (flags_not_used), VNCZ mask, VNCZ value } `ASSERT((!op_wR)||(fc_op_Rid[4:0] == op_R)); `ASSERT(((!op_wR)&&(!op_rA))||(fc_op_Aid[4:0] == op_Aid[4:0])); `ASSERT((!op_rB)||(fc_op_Bid[4:0] == op_Bid)); // // if ((!alu_illegal)&&(!ill_err_i)&&(!clear_pipeline)) if (f_op_early_branch) begin // {{{ `ASSERT(op_opn == CPU_MOV_OP); `ASSERT(!op_wR); `ASSERT(!op_wF); `ASSERT(f_op_branch); // }}} end else begin // {{{ `ASSERT(fc_op_op == op_opn); `ASSERT(fc_op_wR == op_wR); // }}} end end if (!OPT_PIPELINED_BUS_ACCESS) `ASSERT((!i_mem_rdbusy)||(i_mem_w",
            "reg != fc_op_Bid) ||(!fc_op_rB)||(fc_op_I == 0)); // }}} end else if (op_valid && !clear_pipeline && fc_op_illegal) begin // {{{ `ASSERT(op_illegal); `ASSERT(op_valid_alu); `ASSERT(!f_op_branch); // }}} end",
            "always @(*) if ((op_valid)&&(op_illegal)) begin `ASSERT(!op_valid_div); `ASSERT(!op_valid_fpu); `ASSERT(!op_valid_mem); end // always @(*) // if (!op_valid) // `ASSERT(!op_break);",
            "always @(*) if ((!OPT_CIS)&&(op_valid)) begin `ASSERT((!op_phase)||(op_illegal)); `ASSERT(op_pc[1:0] == 2'b0); end",
            "always @(*) if ((!OPT_LOCK)&&(op_valid)) `ASSERT((!op_lock)||(op_illegal));",
            "always @(*) if (!OPT_EARLY_BRANCHING) `ASSERT(!f_op_early_branch);",
            "always @(*) if (op_ce) `ASSERT((dcd_valid)||(dcd_illegal)||(dcd_early_branch));",
            "always @(*) if ((f_past_valid)&&(!f_op_zI)&&(i_mem_rdbusy)&&(op_valid)&&(op_rB)) `ASSERT((!OPT_DCACHE)||(OPT_MEMPIPE) ||(i_mem_w",
            "reg != op_Bid));",
            "always @(posedge i_clk) if ((op_valid)&&(op_rB)&&(!f_op_zI)&&((i_mem_rdbusy)||(i_mem_valid)) &&(i_mem_w",
            "reg != {gie, CPU_PC_REG})) begin if (!OPT_MEMPIPE) begin `ASSERT(fc_alu_Aid[4:0] == i_mem_w",
            "reg ); `ASSERT(i_mem_w",
            "reg != op_Bid); end end",
            "always @(posedge i_clk) if (i_mem_rdbusy) begin `ASSERT(fc_alu_M); `ASSERT(!OPT_PIPELINED||fc_alu_wR || (OPT_LOCK && f_mem_pc)); end",
            "always @(*) if ((op_valid)&&(!clear_pipeline)) `ASSERT(op_gie == gie);",
            "always @(*) if ((op_valid_alu)&&(!op_illegal)) begin if ((op_opn != CPU_SUB_OP) &&(op_opn != CPU_AND_OP) &&(op_opn != CPU_MOV_OP)) begin `ASSERT(op_wR); end if ((op_opn != CPU_MOV_OP)&&(op_opn != CPU_BREV_OP)) `ASSERT(op_rA); end",
            "always @(posedge i_clk) if ((op_valid)&&(!op_illegal) &&(!alu_illegal)&&(!ill_err_i)&&(!clear_pipeline)) begin `ASSERT(op_gie == gie); if ((gie)||(op_phase)) begin `ASSERT((!op_wR)||(op_R[4] == gie)); `ASSERT((!op_rA)||(op_Aid[4] == gie)); `ASSERT((!op_rB)||(op_Bid[4] == gie)); end else if (((op_valid_mem) ||(op_valid_div)||(op_valid_fpu) ||((op_valid_alu)&&(op_opn!=CPU_MOV_OP)))) begin `ASSERT((!op_wR)||(op_R[4] == gie)); `ASSERT((!op_rA)||(op_Aid[4] == gie)); `ASSERT((!op_rB)||(op_Bid[4] == gie)); end end",
            "always @(posedge i_clk) if ((!op_valid)&&(!$past(op_illegal)) &&(!clear_pipeline)&&(!pending_interrupt)) `ASSERT(!op_illegal);",
            "always @(*) begin if (alu_ce) `ASSERT(adf_ce_unconditional); if (div_ce) `ASSERT(adf_ce_unconditional); if (fpu_ce) `ASSERT(adf_ce_unconditional); if ((op_valid)&&(op_illegal)) `ASSERT(op_valid_alu); end",
            "always @(*) if (mem_ce) `ASSERT((op_valid)&&(op_valid_mem)&&(!op_illegal));",
            "always @(*) if (div_ce) `ASSERT(op_valid_div);",
            "always @(*) if ((ibus_err_flag)||(ill_err_i)||(idiv_err_flag)) begin `ASSERT(master_stall); `ASSERT(!mem_ce); `ASSERT(!alu_ce); `ASSERT(!div_ce); `ASSERT(!adf_ce_unconditional); end",
            "always @(posedge i_clk) if ((adf_ce_unconditional)||(mem_ce)) `ASSERT(op_valid);",
            "always @(*) if ((op_valid_alu)&&(!adf_ce_unconditional)&&(!clear_pipeline)) `ASSERT(!op_ce);",
            "always @(*) if ((op_valid_div)&&(!adf_ce_unconditional)) `ASSERT(!op_ce);",
            "always @(posedge i_clk) if (alu_stall) `ASSERT(!alu_ce);",
            "always @(posedge i_clk) if (mem_stalled) `ASSERT(!o_mem_ce);",
            "always @(posedge i_clk) if (div_busy) `ASSERT(!div_ce);",
            "always @(*) if ((!i_reset)&&(break_pending)&&(!clear_pipeline)) `ASSERT((op_valid)&&(op_break)); // }}} //////////////////////////////////////////////////////////////////////// // // Memory // {{{ //////////////////////////////////////////////////////////////////////// // // Op: Memory pipeline assertions // assign f_next_mem = o_mem_addr + 1'b1;",
            "assign f_op_mem_addr = op_Bv[AW+1:2]; fmem #( // {{{ .OPT_LOCK(OPT_LOCK), .F_LGDEPTH(F_LGDEPTH), .OPT_MAXDEPTH((OPT_PIPELINED && OPT_PIPELINED_BUS_ACCESS) ? 14:1), .OPT_AXI_LOCK(2) // Let the solver pick // }}} ) chkmemops( // {{{ .i_clk(i_clk), .i_sys_reset(i_reset), .i_cpu_reset(i_reset), // .i_stb(o_mem_ce), .i_pipe_stalled(i_mem_pipe_stalled), .i_clear_cache(o_clear_dcache), .i_lock(o_bus_lock), .i_op(o_mem_op), .i_data(o_mem_data), .i_addr(o_mem_addr), .i_o",
            "reg (o_mem_",
            "reg ), .i_a",
            "reg (op_Bid), .i_busy(i_mem_busy),.i_rdbusy(i_mem_rdbusy), .i_valid(i_mem_valid), .i_err(i_bus_err), .i_w",
            "reg (i_mem_w",
            "reg ), .i_result(i_mem_result), .f_outstanding(f_mem_outstanding), .f_pc(f_mem_pc), .f_gie(f_mem_gie), .f_read_cycle(f_read_cycle), .f_axi_write_cycle(f_exwrite_cycle), .f_last_",
            "reg (f_last_",
            "reg ), .f_addr_",
            "reg (f_addr_",
            "reg ) // }}} );",
            "always @(*) if ((op_valid)&&(!fc_alu_prepipe)) `ASSERT((!op_valid_mem)||(!op_pipe)); // Validate op_opn and (some of) op_Bid // {{{",
            "always @(*) if ((op_valid_mem)&&(op_pipe)) begin // {{{ if (i_mem_rdbusy) `ASSERT(op_opn[0] == f_exwrite_cycle); if (f_mem_outstanding > ((i_bus_err || i_mem_valid) ? 1:0)) `ASSERT(op_opn[0] != fc_alu_wR); // if ((i_mem_busy)&&(!i_mem_rdbusy && !i_mem_valid)) // `ASSERT(!o_mem_ce || op_opn[0] == 1'b1); if (i_mem_rdbusy) begin if (OPT_PIPELINED_BUS_ACCESS) begin end else if (OPT_DCACHE) `ASSERT(!i_mem_valid || i_mem_w",
            "reg != op_Bid); end // }}} end // }}}",
            "always @(posedge i_clk) if (op_valid_mem && op_pipe) begin // {{{ if ((i_mem_busy)&&(!OPT_DCACHE)) `ASSERT((f_op_mem_addr == o_mem_addr) ||(f_op_mem_addr == f_next_mem)); if (i_mem_valid) `ASSERT(op_Bid != i_mem_w",
            "reg ); if (alu_busy||alu_valid) `ASSERT((!alu_wR)||(op_Bid != alu_",
            "reg )); if (f_past_valid) begin if ((i_mem_busy)&&(!OPT_DCACHE)) `ASSERT((op_Bv[(AW+1):2]==o_mem_addr[(AW-1):0]) ||(op_Bv[(AW+1):2]==o_mem_addr[(AW-1):0]+1'b1)); if ($past(mem_ce)) `ASSERT(op_Bid == $past(op_Bid)); end `ASSERT(op_Bid[3:1] != 3'h7); if ((i_mem_rdbusy||i_mem_valid) && !f_exwrite_cycle) begin if (!OPT_MEMPIPE) begin // {{{ `ASSERT(fc_alu_Aid[4:0] == i_mem_w",
            "reg ); `ASSERT(i_mem_w",
            "reg != op_Bid); // }}} end else if (OPT_DCACHE) begin // {{{ `ASSERT(fc_alu_Aid[4:0] != op_Bid); // }}} end else // if (!OPT_DCACHE) begin // {{{ if ((i_mem_valid) ||($past(i_mem_rdbusy))) `ASSERT(i_mem_w",
            "reg != op_Bid); // }}} end end // }}} end",
            "always @(*) if ((dcd_valid)&&(dcd_pipe)) `ASSERT((op_Aid[3:1] != 3'h7)||(op_opn[0]));",
            "always @(*) if ((op_valid)&(!op_valid_mem)) `ASSERT((op_illegal)||(!op_pipe)); // Check f_addr_",
            "reg and f_last_",
            "reg // {{{",
            "always @(*) if (OPT_MEMPIPE && (op_valid && op_rB) && !f_exwrite_cycle &&(!f_op_zI)&&(i_mem_rdbusy || i_mem_valid)) `ASSERT(f_last_",
            "reg != op_Bid);",
            "always @(*) if (i_mem_rdbusy && !f_exwrite_cycle) `ASSERT(f_last_",
            "reg == alu_",
            "reg );",
            "always @(*) if ((op_valid_mem)&&(op_pipe) && i_mem_valid) `ASSERT(op_Bid != i_mem_w",
            "reg );",
            "always @(*) if ((op_valid_mem)&&(op_pipe) && (i_mem_rdbusy || i_mem_valid)) `ASSERT(op_Bid == f_addr_",
            "reg );",
            "always @(*) if (i_mem_rdbusy) begin if (op_valid_mem && op_pipe) begin `ASSERT(op_Bid == f_addr_",
            "reg ); `ASSERT(op_Bid != f_last_",
            "reg ); if (dcd_M && dcd_pipe && !dcd_illegal && !dcd_early_branch) `ASSERT(op_Bid == dcd_B[4:0]); end else if (!op_valid_mem && dcd_M && dcd_pipe && !dcd_illegal && !dcd_early_branch) `ASSERT(dcd_B[4:0] == f_addr_",
            "reg ); end // }}}",
            "always @(*) if (op_valid && !f_op_zI && i_mem_rdbusy && (f_last_",
            "reg != { gie, CPU_PC_REG })) `ASSERT(!op_rB || fc_op_Bid[4:0] == f_addr_",
            "reg ||((f_mem_outstanding == 1) && (fc_op_Bid[4:0] != f_last_",
            "reg ))); // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about the ALU stage // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if ((alu_ce)&&(!clear_pipeline)) `ASSERT((op_valid_alu)&&(op_gie == gie));",
            "always @(*) if ((mem_ce)&&(!clear_pipeline)) `ASSERT((op_valid_mem)&&(op_gie == gie));",
            "always @(*) if ((div_ce)&&(!clear_pipeline)) `ASSERT((op_valid_div)&&(op_gie == gie));",
            "always @(*) if ((!clear_pipeline)&&((i_mem_valid)||(div_valid)||(div_busy) ||(i_mem_rdbusy)||(alu_valid))) `ASSERT(alu_gie == gie);",
            "always @(*) if ((!OPT_CIS)&&(alu_pc_valid)) `ASSERT(alu_pc[1:0] == 2'b0);",
            "always @(*) if (!OPT_LOCK) `ASSERT((!o_bus_lock)&&(!prelock_stall));",
            "always @(*) if (!OPT_DIV) `ASSERT((!dcd_DIV)&&(!op_valid_div)&&(!div_busy)&&(!div_valid)&&(!div_ce));",
            "always @(*) if (OPT_MPY == 0) `ASSERT(alu_busy == 1'b0);",
            "always @(*) if (!clear_pipeline) begin if ((alu_valid)||(alu_illegal)) `ASSERT(alu_gie == gie); if (div_valid) `ASSERT(alu_gie == gie); end",
            "always @(*) if (alu_busy) begin `ASSERT(!i_mem_rdbusy); `ASSERT(!div_busy); `ASSERT(!fpu_busy); end else if (i_mem_rdbusy) begin `ASSERT(!div_busy); `ASSERT(!fpu_busy); end else if (div_busy) `ASSERT(!fpu_busy);",
            "always @(posedge i_clk) if ((div_valid)||(div_busy)) `ASSERT(alu_",
            "reg [3:1] != 3'h7);",
            "always @(posedge i_clk) if ((f_past_valid)&&(wr_",
            "reg _ce) &&((!$past(r_halted))||(!$past(i_dbg_we)))) `ASSERT(alu_gie == gie); // }}} //////////////////////////////////////////////////////////////////////// // // Contract checking : A operand // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) begin f_Av =",
            "reg set[fc_op_Aid[4:0]]; if (fc_op_Aid[3:0] == CPU_PC_REG) begin if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Aid[4:0])) f_Av = wr_sp",
            "reg _vl; else if (fc_op_Aid[4] == op_gie) f_Av = op_pc; // f_next_addr; else if (fc_op_Aid[3:0] == { 1'b1, CPU_PC_REG }) begin f_Av[31:(AW+1)] = 0; f_Av[(AW+1):0] = { upc, uhalt_phase, 1'b0 }; end end else if (fc_op_Aid[4:0] == { 1'b0, CPU_CC_REG }) begin f_Av = { w_cpu_info, reg set[fc_op_Aid[4:0]][22:16], w_iflags }; if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Aid[4:0])) f_Av[22:16] = wr_sp",
            "reg _vl[22:16]; end else if (fc_op_Aid[4:0] == { 1'b1, CPU_CC_REG }) begin f_Av = { w_cpu_info, reg set[fc_op_Aid[4:0]][22:16], w_uflags }; if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Aid[4:0])) f_Av[22:16] = wr_sp",
            "reg _vl[22:16]; end else if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Aid[4:0])) f_Av = wr_gp",
            "reg _vl; else f_Av =",
            "reg set[fc_op_Aid[4:0]]; end // }}} //////////////////////////////////////////////////////////////////////// // // Contract checking : B operand // {{{ //////////////////////////////////////////////////////////////////////// // // // The PRE-",
            "logic always @(*) begin f_pre_Bv =",
            "reg set[fc_op_Bid[4:0]]; // if (fc_op_Bid[3:0] == CPU_PC_REG) begin // Can",
            "always read your own address if (fc_op_Bid[4] == op_gie) f_pre_Bv = { {(30-AW){1'b0}}, op_pc[(AW+1):2], 2'b00 }; // f_next_addr; else // if (fc_op_Bid[4]) // Supervisor or user may read the users PC",
            "reg begin f_pre_Bv = 0; f_pre_Bv[(AW+1):0] = { upc[(AW+1):2], uhalt_phase, 1'b0 }; if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Bid[4:0])) f_pre_Bv = wr_sp",
            "reg _vl; end end else if (fc_op_Bid[3:0] == CPU_CC_REG) begin f_pre_Bv = { w_cpu_info, reg set[fc_op_Bid[4:0]][22:16], w_uflags }; // if ((fc_op_Bid[4] == op_gie)&&(!fc_op_Bid[4])) f_pre_Bv[15:0] = (gie || fc_op_Bid[4]) ? w_uflags : w_iflags; if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Bid[4:0])) f_pre_Bv[22:16] = wr_sp",
            "reg _vl[22:16]; end else if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Bid[4:0])) f_pre_Bv = wr_gp",
            "reg _vl; else f_pre_Bv =",
            "reg set[fc_op_Bid[4:0]]; end // The actual calculation of B",
            "assign f_Bv = (fc_op_rB) ? ((fc_op_Bid[5]) ? ( { f_pre_Bv }+{ fc_op_I[29:0],2'b00 }) : (f_pre_Bv + fc_op_I)) : fc_op_I; // }}} //////////////////////////////////////////////////////////////////////// // // CONTRACT: The operands to an ALU/MEM/DIV operation must be valid. // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (!i_reset && op_valid && !op_illegal && (!clear_pipeline && !dbg_clear_pipe) && (!i_halt || !dbgv) &&((!wr_",
            "reg _ce)||(wr_",
            "reg _id!= { gie, CPU_PC_REG })) &&(!f_op_branch)) begin if ((fc_op_rA)&&(fc_op_Aid[3:1] != 3'h7)) `ASSERT(f_Av == op_Av); if (!fc_op_rB || fc_op_Bid[4:0] != { gie, CPU_CC_REG } || !OPT_PIPELINED) begin `ASSERT(f_Bv == op_Bv); end else if (f_op_zI) `ASSERT(((f_Bv ^ op_Bv) & 32'hffff_c0ff) == 0); end // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about the ALU stage // {{{ //////////////////////////////////////////////////////////////////////// // // // alu_valid // alu_ce // alu_stall // ALU stage assertions",
            "always @(posedge i_clk) if ((alu_ce)||(mem_ce)||(div_ce)||(fpu_ce)) begin f_alu_insn_word <= f_op_insn_word; f_alu_phase <= f_op_phase; end",
            "initial f_alu_branch = 1'b0;",
            "always @(posedge i_clk) if ((adf_ce_unconditional)||(mem_ce)) f_alu_branch <= f_op_branch; else f_alu_branch <= 1'b0; f_idecode #( // {{{ .OPT_MPY((OPT_MPY!=0)? 1'b1:1'b0), .OPT_SHIFTS(OPT_SHIFTS), .OPT_DIVIDE(OPT_DIV), .OPT_FPU(IMPLEMENT_FPU), .OPT_LOCK(OPT_LOCK), .OPT_OPIPE(OPT_PIPELINED_BUS_ACCESS), .OPT_SIM(1'b0), .OPT_USERMODE(OPT_USERMODE), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_CIS(OPT_CIS) // }}} ) f_insn_decode_alu( // {{{ f_alu_insn_word, f_alu_phase, alu_gie, fc_alu_illegal, fc_alu_Rid, fc_alu_Aid, fc_alu_Bid, fc_alu_I, fc_alu_cond, fc_alu_wF, fc_alu_op, fc_alu_ALU, fc_alu_M, fc_alu_DV, fc_alu_FP, fc_alu_break, fc_alu_lock, fc_alu_wR, fc_alu_rA, fc_alu_rB, fc_alu_prepipe, fc_alu_sim, fc_alu_sim_immv // }}} );",
            "always @(posedge i_clk) if (!wr_",
            "reg _ce) begin if (f_alu_branch) begin `ASSERT((!div_valid)&&(!div_busy)); `ASSERT((!fpu_valid)&&(!fpu_busy)); `ASSERT(!i_mem_rdbusy); `ASSERT(!alu_busy); end else begin `ASSERT(fc_alu_sim == alu_sim); `ASSERT(fc_alu_sim_immv == alu_sim_immv); if (!fc_alu_DV) `ASSERT((!div_valid)&&(!div_busy)&&(!div_error)); if (!fc_alu_M) `ASSERT(!i_mem_rdbusy); if (!fc_alu_ALU) `ASSERT(!alu_busy); if (!fc_alu_FP) `ASSERT((!fpu_busy)&&(!fpu_error)); if (alu_busy) `ASSERT((fc_alu_op[3:1] == 3'h5) ||(fc_alu_op[3:0] == 4'hc)); if ((alu_busy)||(div_busy)||(fpu_busy)) begin `ASSERT(!i_mem_rdbusy); `ASSERT((clear_pipeline) ||(fc_alu_Rid[4:0] == alu_",
            "reg )); if (alu_busy) `ASSERT(fc_alu_wF == alu_wF); if ((fc_alu_Rid[3:1] == 3'h7)&&(alu_wR) &&(fc_alu_Rid[4:0] != { gie, 4'hf })) `ASSERT(pending_s",
            "reg _write); end else if (i_mem_rdbusy) begin if ($past(i_mem_rdbusy)) `ASSERT(fc_alu_Rid[4] == f_mem_gie); end //if ((div_busy)||(fpu_busy)) // `ASSERT(alu_wR); //else if ((alu_busy)&&(alu_wR)) `ASSERT(fc_alu_wR); if (alu_busy || i_mem_rdbusy || div_busy) begin if ((fc_alu_wR)&&(fc_alu_Rid[4:0] == { gie, CPU_PC_REG})) begin `ASSERT(!alu_phase); end else `ASSERT(f_alu_phase == alu_phase); end end end else if (!dbgv) // && wr_",
            "reg _ce begin `ASSERT(fc_alu_DV || (!div_valid)&&(!div_error)); `ASSERT(fc_alu_ALU|| !alu_valid); `ASSERT(fc_alu_M || !i_mem_valid); `ASSERT(fc_alu_FP || (!fpu_valid)&&(!fpu_error)); `ASSERT((!alu_busy)&&(!div_busy)&&(!fpu_busy)); if ((!alu_illegal)&&(fc_alu_cond[3])&&(fc_alu_wR)&&(fc_alu_ALU)) `ASSERT(alu_wR); if (!i_mem_valid) `ASSERT(fc_alu_Rid[4:0] == alu_",
            "reg ); if (f_exwrite_cycle) begin `ASSERT(!alu_wR); end else `ASSERT((!alu_wR)||(fc_alu_wR == alu_wR)); if (alu_valid) `ASSERT(fc_alu_wF == alu_wF); if (!fc_alu_wF) `ASSERT(!wr_flags_ce); `ASSERT(!f_alu_branch); end",
            "always @(posedge i_clk) if (f_mem_pc && i_mem_rdbusy) begin // {{{ `ASSERT(!OPT_PIPELINED || cc_invalid_for_dcd || !fc_alu_wR || fc_alu_Rid[4:0] != { gie, CPU_CC_REG }); `ASSERT(!mem_ce); if (OPT_PIPELINED && fc_alu_Rid[4:0] != { gie, CPU_PC_REG } && (!OPT_LOCK || fc_alu_wR)) `ASSERT(pending_s",
            "reg _write); if ((!OPT_DCACHE)||(!OPT_MEMPIPE)) begin `ASSERT(!fc_alu_prepipe); end else if ((i_mem_rdbusy && !f_exwrite_cycle) &&(!$past(mem_ce))&&(!$past(mem_ce,2))) `ASSERT(!fc_alu_prepipe); // }}} end else if (i_mem_rdbusy) begin `ASSERT(!pending_s",
            "reg _write); // assert(!cc_invalid_for_dcd); end // Ongoing memory operation check // {{{",
            "always @(posedge i_clk) if (i_mem_rdbusy) begin // In pipelined mode, this is an ongoing load operation // Otherwise, mem_rdbusy == i_mem_busy and we have no idea // what type of operation we are in `ASSERT(!fc_alu_illegal); `ASSERT(fc_alu_M); `ASSERT(gie == alu_",
            "reg [4]); if (fc_alu_rB) `ASSERT(fc_alu_Bid[4:0] == f_addr_",
            "reg ); if (!f_exwrite_cycle) begin `ASSERT(alu_",
            "reg == f_last_",
            "reg ); if (alu_",
            "reg == f_addr_",
            "reg ) `ASSERT(!op_pipe); end if (fc_alu_cond[3]) `ASSERT(fc_alu_Rid[4:0] == alu_",
            "reg ); if ((fc_alu_wR)&&(fc_alu_Rid[4:0] == { gie, CPU_PC_REG})) begin `ASSERT(!alu_phase); end else `ASSERT(f_alu_phase == alu_phase); if (f_exwrite_cycle) begin `ASSERT(!fc_alu_wR); end else `ASSERT(fc_alu_wR); end else if ((i_mem_busy)&&(fc_alu_M) &&(f_mem_outstanding > ((i_mem_valid || i_bus_err) ? 1:0)) &&(!i_bus_err)) begin // Ongoing store operation // {{{ `ASSERT(!fc_alu_illegal); `ASSERT(fc_alu_M); `ASSERT(!fc_alu_wR); // }}} end // }}}",
            "always @(*) if (!fc_alu_wR && i_mem_rdbusy) begin `ASSERT(OPT_LOCK); `ASSERT(f_mem_outstanding == 1); `ASSERT(f_mem_pc); `ASSERT(!f_read_cycle); `ASSERT(!cc_invalid_for_dcd); `ASSERT(f_exwrite_cycle); // `ASSERT(i_mem_w",
            "reg [3:0] == 4'hf); `ASSERT(fc_alu_M); `ASSERT(!pending_s",
            "reg _write); `ASSERT(!alu_wR); end else if (i_mem_rdbusy) begin `ASSERT(fc_alu_wR); `ASSERT(!f_exwrite_cycle); `ASSERT(f_read_cycle); end // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about the writeback stage // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if ((f_past_valid)&&($past(i_reset))&&($past(gie) != gie)) `ASSERT(clear_pipeline);",
            "always @(*) if (!IMPLEMENT_FPU) begin `ASSERT(!ifpu_err_flag); `ASSERT(!ufpu_err_flag); end",
            "always @(posedge i_clk) if (dbgv) begin `ASSERT(wr_index == 3'h0); `ASSERT(wr_gp",
            "reg _vl == $past(i_dbg_data)); `ASSERT(wr_sp",
            "reg _vl == $past(i_dbg_data)); end",
            "always @(*) if (i_mem_rdbusy || i_mem_valid) begin `ASSERT(wr_index == 3'h1); if (i_mem_valid) `ASSERT(wr_gp",
            "reg _vl == i_mem_result); end",
            "always @(*) if (alu_busy || alu_valid) begin `ASSERT(wr_index == 3'h2); if (alu_valid) begin `ASSERT(wr_gp",
            "reg _vl == alu_result); `ASSERT(wr_sp",
            "reg _vl == alu_result); end end",
            "always @(*) if (div_busy || div_valid || div_error) begin `ASSERT(wr_index == 3'h3); if (div_valid) `ASSERT(wr_gp",
            "reg _vl == div_result); end",
            "always @(*) if (fpu_busy || fpu_valid || fpu_error) begin `ASSERT(wr_index == 3'h4); if (fpu_valid) `ASSERT(wr_gp",
            "reg _vl == fpu_result); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(r_halted)) begin `ASSERT(!div_busy); `ASSERT(!i_mem_rdbusy); `ASSERT(!alu_busy); `ASSERT(!div_valid); `ASSERT(!i_mem_valid); `ASSERT(!alu_valid); end",
            "always @(*) if (((wr_",
            "reg _ce)||(wr_flags_ce))&&(!dbgv)) `ASSERT(!alu_illegal);",
            "always @(*) if (!fc_alu_wR && (!OPT_LOCK || !f_mem_pc)) `ASSERT(!i_mem_rdbusy);",
            "always @(*) if (alu_illegal) `ASSERT(!i_mem_rdbusy);",
            "always @(posedge i_clk) if (wr_",
            "reg _ce && !$past(i_dbg_we)) begin if (!fc_alu_wR) `ASSERT(OPT_LOCK && f_exwrite_cycle); // Since writes are asynchronous, they can create errors later `ASSERT((!i_bus_err)||(!i_mem_valid)); `ASSERT(!fpu_error); `ASSERT(!div_error); end // }}} //////////////////////////////////////////////////////////////////////// // // Clock enable checking // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (!OPT_CLKGATE) begin assert(w_clken); assert(o_clken); end else if (!f_past_valid) begin end // clken can be anything on the first clock else if ($past(i_reset)) begin assert(w_clken != OPT_START_HALTED); end else if ($past((!i_halt || !r_halted) && (!sleep || i_interrupt))) begin assert(w_clken); end else if ($past((i_mem_busy && f_mem_outstanding > 0) || o_mem_ce)) begin assert(w_clken); end else if (i_mem_busy || div_busy || alu_busy || fpu_busy) begin assert(o_clken); end else if ($past((i_interrupt || pending_interrupt) && !i_halt)) begin assert(o_clken); end else if (!sleep && !r_halted) begin assert(o_clken); end // always @(posedge i_clk) // if (f_past_valid && i_mem_busy) // assert(!r_halted);",
            "always @(posedge i_clk) if (!OPT_CLKGATE) begin assert(o_clken); end else if (!f_past_valid) begin end else if (i_dbg_we || i_clear_cache || f_mem_outstanding > 0) begin assert(o_clken); end else if (!i_halt && (i_interrupt || !sleep)) assert(o_clken);",
            "always @(posedge i_clk) if (!i_reset && sleep) begin assert(!wr_",
            "reg _ce || dbgv); assert(!i_mem_rdbusy); end",
            "always @(posedge i_clk) if (!i_reset && r_halted) assert(!i_mem_rdbusy); // }}} //////////////////////////////////////////////////////////////////////// // // Low power checking // {{{ //////////////////////////////////////////////////////////////////////// // // // In low power mode, *nothing* should change unless we are doing // something. generate if (OPT_LOWPOWER && OPT_PIPELINED) begin : F_OPT_LOWPOWER_CHECK",
            "wire [70:0] op_state; // // OP*",
            "reg isters can only be expected to hold steady if // pipelined. If not pipelined, many of these",
            "reg isters // become aliases for the decode",
            "reg isters which will // (of course) change from one clock to the next. // assign op_state = { op_valid_mem, op_valid_div, op_valid_alu, op_valid_fpu, op_opn, op_R, op_Rcc, op_Aid, op_Bid, op_pc, r_op_break, op_illegal };",
            "always @(posedge i_clk) if (f_past_valid && !$past(i_reset) && !$past(clear_pipeline) && ($past(op_valid && !adf_ce_unconditional && !mem_ce) ||($past(!op_valid && !dcd_ljmp) && !op_valid))) begin assert($stable(op_state)); end",
            "always @(posedge i_clk) if (f_past_valid && !op_valid) begin assert(r_op_F == 7'h00); assert(!op_wR); assert(!op_wF); assert(!op_rA); assert(!op_rB); assert(r_op_Av == 0); assert(r_op_Bv == 0); end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Step properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if (f_past_valid && !i_reset && $past(!gie)) assert(!stepped);",
            "always @(posedge i_clk) if (f_past_valid && step && stepped) begin assert(!break_pending); assert(!o_bus_lock); end",
            "always @(posedge i_clk) if (f_past_valid && !i_reset && !o_bus_lock && !$past(o_bus_lock) && !$past(o_dbg_stall) && !o_dbg_stall) begin if (step && !stepped) begin `ASSERT(!i_mem_rdbusy); `ASSERT(!div_busy); `ASSERT(!alu_busy); `ASSERT(!fpu_busy); end if (wr_",
            "reg _ce || wr_flags_ce) `ASSERT(!step || stepped); end",
            "always @(posedge i_clk) if (!i_reset &&(i_mem_rdbusy|| div_busy|| alu_busy || fpu_busy)) assert(!r_halted);",
            "always @(posedge i_clk) if (f_past_valid && !$past(i_reset) && i_mem_busy) assert(!$rose(r_halted));",
            "always @(posedge i_clk) if (step && stepped) begin assert(!adf_ce_unconditional); assert(!div_ce); assert(!mem_ce); assert(!fpu_ce); end // }}} //////////////////////////////////////////////////////////////////////// // // Ad-hoc (unsorted) properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_mem_rdbusy)) &&(!$past(i_mem_valid) ||($past(i_mem_w",
            "reg [3:1] != 3'h7)))) `ASSERT(!i_mem_valid || i_mem_w",
            "reg [4] == alu_gie);",
            "always @(posedge i_clk) if (i_mem_valid) `ASSERT(i_mem_w",
            "reg [4] == alu_gie);",
            "always @(posedge i_clk) if (i_mem_rdbusy) `ASSERT(alu_gie == f_mem_gie);",
            "always @(posedge i_clk) if (f_mem_outstanding > 0) `ASSERT(alu_gie == f_mem_gie); // Break instructions are not allowed to move past the op stage",
            "always @(*) if ((break_pending)||(op_break)) `ASSERT((!alu_ce)&&(!mem_ce)&&(!div_ce)&&(!fpu_ce));",
            "always @(*) if (op_break) `ASSERT((!alu_ce)&&(!mem_ce)&&(!div_ce)&&(!fpu_ce));",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&($past(break_pending))&&(!break_pending)) `ASSERT((clear_pipeline)||($past(clear_pipeline)));",
            "always @(*) if ((o_break)||((alu_valid)&&(alu_illegal))) begin `ASSERT(!alu_ce); `ASSERT(!mem_ce); `ASSERT(!div_ce); `ASSERT(!fpu_ce); `ASSERT(!i_mem_rdbusy); // The following two shouldn't be true, but will be true // following a bus error if (!i_bus_err) begin `ASSERT(!alu_busy); `ASSERT(!div_busy); `ASSERT(!fpu_busy); end end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&(!$past(clear_pipeline))&& ($past(div_busy))&&(!clear_pipeline)) begin `ASSERT($stable(alu_",
            "reg )); `ASSERT(alu_",
            "reg [4] == alu_gie); `ASSERT($stable(alu_pc)); `ASSERT($stable(alu_phase)); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&(!i_reset) &&(!$past(clear_pipeline))&&(!clear_pipeline) &&(($past(div_busy))||($past(i_mem_rdbusy)))) `ASSERT($stable(alu_gie));",
            "always @(posedge i_clk) if (i_mem_rdbusy && f_mem_outstanding > 0) `ASSERT(!new_pc);",
            "always @(posedge i_clk) if ((wr_",
            "reg _ce)&&((wr_write_cc)||(wr_write_pc))) `ASSERT(wr_sp",
            "reg _vl == wr_gp",
            "reg _vl);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(clear_pipeline))&&(!$past(i_reset)) &&($past(op_valid))&&($past(op_illegal))&&(!op_illegal)) `ASSERT(alu_illegal);",
            "always @(*) if ((OPT_PIPELINED)&&(alu_valid)&&(alu_wR)&&(!clear_pipeline) &&(alu_",
            "reg [3:1] == 3'h7) &&(alu_",
            "reg [4:0] != { gie, CPU_PC_REG })) `ASSERT(pending_s",
            "reg _write);",
            "always @(posedge i_clk) if ((OPT_PIPELINED)&&(i_mem_valid || i_mem_rdbusy) &&(f_last_",
            "reg [3:1] == 3'h7) &&(!f_exwrite_cycle && f_last_",
            "reg [4:0] != { gie, CPU_PC_REG })) begin `ASSERT(pending_s",
            "reg _write); end else if ((OPT_PIPELINED)&&(OPT_DCACHE) && i_mem_valid &&($past(i_mem_rdbusy)) &&($past(i_mem_rdbusy,2))) `ASSERT((i_mem_w",
            "reg [3:1] != 3'h7) ||f_exwrite_cycle ||(i_mem_w",
            "reg == { gie, CPU_PC_REG}) ||(pending_s",
            "reg _write));",
            "always @(*) if ((op_valid_alu)||(op_valid_div)||(op_valid_mem)||(op_valid_fpu)) `ASSERT(op_valid);",
            "always @(*) if (!OPT_PIPELINED) begin if (op_valid) begin `ASSERT(!dcd_valid); `ASSERT(!i_mem_busy || f_mem_outstanding == 0); `ASSERT(!alu_busy); `ASSERT(!div_busy); `ASSERT((!wr_",
            "reg _ce)||(dbgv)); `ASSERT(!wr_flags_ce); end end",
            "always @(posedge i_clk) if ((!OPT_PIPELINED)&&(f_past_valid)) begin if (op_valid) `ASSERT($stable(f_dcd_insn_word)); end",
            "always @(posedge i_clk) if ((alu_ce)||(div_ce)||(fpu_ce)) `ASSERT(adf_ce_unconditional);",
            "always @(posedge i_clk) if ((!clear_pipeline)&&(master_ce)&&(op_ce)&&(op_valid)) begin if (op_valid_mem) begin `ASSERT((mem_ce)||(!set_cond)); end else begin `ASSERT(!master_stall); if ((set_cond)&&(op_valid_div)) `ASSERT(div_ce||pending_s",
            "reg _write); if (!op_valid_alu) `ASSERT(!alu_ce); end end // }}} //////////////////////////////////////////////////////////////////////// // // Debug port read properties // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_DBGPORT) begin : CHK_DBGPORT_READS",
            "reg [31:0] f_dbg_check; // o_dbg_",
            "reg -- Reading from the debugging interface if (OPT_DISTRIBUTED_REGS) begin : F_CHK_DISTRIBUTED_RAM // {{{",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_halt))&&(!$past(i_dbg_we))) begin if ($past(i_dbg_r",
            "reg [3:1]) != 3'h7) `ASSERT(o_dbg_",
            "reg == $past(",
            "reg set[i_dbg_r",
            "reg ])); if ($past(i_dbg_r",
            "reg [4:0]) == 5'h0f) `ASSERT(o_dbg_",
            "reg [AW+1:0] == $past({ ipc[(AW+1):2], ihalt_phase, 1'b0})); if ($past(i_dbg_r",
            "reg [4:0]) == 5'h1f) `ASSERT(o_dbg_",
            "reg [AW+1:0] == $past({ upc[(AW+1):2], uhalt_phase, 1'b0})); if ($past(i_dbg_r",
            "reg [4:0]) == 5'h0e) begin `ASSERT(o_dbg_",
            "reg [15:6] == $past(w_iflags[15:6])); `ASSERT(o_dbg_",
            "reg [ 4:0] == $past(w_iflags[ 4:0])); end if ($past(i_dbg_r",
            "reg [4:0]) == 5'h1e) begin `ASSERT(o_dbg_",
            "reg [15:6] == $past(w_uflags[15:6])); `ASSERT(o_dbg_",
            "reg [ 4:0] == $past(w_uflags[ 4:0])); end if ($past(i_dbg_r",
            "reg [3:0]) == 4'he) begin `ASSERT(o_dbg_",
            "reg [15] == 1'b0); `ASSERT(o_dbg_",
            "reg [31:23] == w_cpu_info); `ASSERT(o_dbg_",
            "reg [CPU_GIE_BIT] == $past(i_dbg_r",
            "reg [4])); end end // }}} end else begin : F_CHK_NO_DISTRIBUTED_RAM // {{{",
            "always @(posedge i_clk) if (f_past_valid&&$past(f_past_valid) && $past(i_halt)&&$past(i_halt,2) &&(!$past(i_dbg_we))) begin if ($past(i_dbg_r",
            "reg [3:1],2) != 3'h7) `ASSERT(o_dbg_",
            "reg == $past(",
            "reg set[i_dbg_r",
            "reg ],2)); end // }}} end if (OPT_USERMODE) begin : CHK_USER",
            "always @(*) begin f_dbg_check =",
            "reg set[i_dbg_r",
            "reg ]; case(i_dbg_r",
            "reg ) 5'h0e: begin f_dbg_check[15:0] = w_iflags; f_dbg_check[31:23] = w_cpu_info; f_dbg_check[CPU_GIE_BIT] <= 1'b0; end 5'h0f: f_dbg_check[(AW+1):0] = { ipc[(AW+1):2], ihalt_phase, 1'b0 }; 5'h1e: begin f_dbg_check[15:0] = w_uflags; f_dbg_check[31:23] = w_cpu_info; f_dbg_check[CPU_GIE_BIT] <= 1'b1; end 5'h1f: f_dbg_check[(AW+1):0] = { upc[(AW+1):2], uhalt_phase, 1'b0 }; default: f_dbg_check =",
            "reg set[i_dbg_r",
            "reg ]; endcase end end else begin : NO_USER",
            "always @(*) begin if (OPT_DISTRIBUTED_REGS) f_dbg_check =",
            "reg set[i_dbg_r",
            "reg ]; else f_dbg_check = 0; case(i_dbg_r",
            "reg [3:0]) 4'h0e: begin f_dbg_check[15:0] = w_iflags; f_dbg_check[31:23] = w_cpu_info; f_dbg_check[CPU_GIE_BIT] <= 1'b0; end 4'h0f: f_dbg_check[(AW+1):0] = { ipc[(AW+1):2], ihalt_phase, 1'b0 }; default: f_dbg_check =",
            "reg set[i_dbg_r",
            "reg [3:0]]; endcase end end if (OPT_DISTRIBUTED_REGS) begin",
            "always @(posedge i_clk) if (!i_reset && !$past(i_reset)) assert(o_dbg_",
            "reg == $past(f_dbg_check)); end else begin",
            "always @(posedge i_clk) if (!i_reset && !$past(i_reset) && !$past(i_reset,2)) assert(o_dbg_",
            "reg == $past(f_dbg_check,2)); end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Cover statements // {{{ //////////////////////////////////////////////////////////////////////// // always @(posedge i_clk) begin cover(!i_reset); cover(!i_halt); cover(!i_reset && !i_halt); end",
            "always @(posedge i_clk) if (!i_halt && !i_reset) begin cover(i_pf_valid && i_pf_illegal); cover(i_pf_valid && !i_pf_illegal); cover(dcd_valid && dcd_illegal); cover(dcd_valid && !dcd_illegal); cover(op_valid && !op_illegal); cover(op_valid && op_illegal); cover(op_valid && !op_illegal && op_ce); cover(op_valid && op_illegal && op_ce); cover(alu_valid); cover(div_valid); cover(o_mem_ce); cover(i_mem_valid); cover(wr_",
            "reg _ce); cover(gie); end",
            "always @(posedge i_clk) if (!i_halt && !i_reset && !$past(i_reset)) begin cover(i_interrupt && !alu_phase && !o_bus_lock); cover(alu_illegal); cover( gie && w_switch_to_interrupt); cover(!gie && w_release_from_interrupt); // Cover an illegal instruction cover(alu_illegal); cover(alu_illegal && !clear_pipeline); // Cover a break instruction cover((master_ce)&&(break_pending)&&(!break_en)); cover(o_break); // if (master_ce && (break_en || break_pending)) // `ASSERT(!wr_",
            "reg _ce); cover(gie); cover(step); cover(step && w_switch_to_interrupt); cover(step && w_switch_to_interrupt && !i_interrupt); end",
            "always @(posedge i_clk) if (!i_halt && !i_reset && !$past(i_reset)) begin cover(step); cover(step && wr_",
            "reg _ce); cover($fell(step) && $stable(!i_reset && !i_halt)); cover($past(step && !i_reset && !i_halt)); cover($past(step && !i_reset && !i_halt,2)); cover(!o_bus_lock && alu_ce && step); cover(user_step && !gie); cover(user_step && gie); cover(user_step && gie && wr_",
            "reg _ce); // Cover a division by zero cover(!OPT_DIV || div_busy); cover(!OPT_DIV || div_error); cover(!OPT_DIV || div_valid); end generate if (OPT_DIV) begin : F_DIVIDE",
            "always @(posedge i_clk) if (!i_halt && !i_reset && !$past(i_reset)) begin // Cover a division by zero cover(div_busy); cover(div_error); cover(div_valid); end end endgenerate generate if (OPT_LOCK) begin : F_CVR_LOCK",
            "always @(posedge i_clk) if (f_past_valid && !i_reset && !$past(i_reset || clear_pipeline)) begin cover($rose(o_bus_lock)); cover($fell(o_bus_lock)); cover($fell(o_bus_lock) && !$past(i_bus_err || div_error || alu_illegal)); end end else begin",
            "always @(*) `ASSERT(!o_bus_lock); end endgenerate",
            "always @(posedge i_clk) if (!i_halt && !i_reset && !$past(i_reset) && wr_",
            "reg _ce) begin `ASSERT(!alu_illegal); end",
            "always @(posedge i_clk) if (!i_halt && !i_reset && wr_",
            "reg _ce) begin cover(o_bus_lock); // Cover the switch to interrupt cover(i_interrupt); cover(i_interrupt && !alu_phase); cover(i_interrupt && !o_bus_lock); cover((i_interrupt)&&(!alu_phase)&&(!o_bus_lock)); // Cover a \"step\" instruction // cover(((alu_pc_valid)||(mem_pc_valid)) &&(step)&&(!alu_phase)&&(!o_bus_lock)); // `ASSERT(!(((alu_pc_valid)||(mem_pc_valid)) // &&(step)&&(!alu_phase)&&(!o_bus_lock))); // Cover a bus error cover(i_bus_err); // Cover a TRAP instruction to the CC",
            "reg ister cover(!alu_gie && !wr_sp",
            "reg _vl[CPU_GIE_BIT] &&(wr_",
            "reg _id[4])&&(wr_write_cc)); // Cover an AXI lock return branch cover(i_mem_valid && f_exwrite_cycle && !f_read_cycle); end // Cover all the various reasons to switch to an interrupt // {{{",
            "always @(posedge i_clk) if ((f_past_valid && !i_reset && !$past(i_reset) && !i_halt) && gie) begin cover((pending_interrupt) &&(!alu_phase)&&(!o_bus_lock)&&(!i_mem_busy)); cover(div_error); // cover(fpu_error); cover(i_bus_err); cover(wr_",
            "reg _ce && !wr_sp",
            "reg _vl[CPU_GIE_BIT] && wr_",
            "reg _id[4] && wr_write_cc); if (!clear_pipeline && !w_switch_to_interrupt) begin cover(pending_interrupt); cover(i_interrupt); cover(mem_ce && step); cover(break_pending && !adf_ce_unconditional); cover(adf_ce_unconditional && op_illegal); cover(adf_ce_unconditional && step); end `ASSERT(!adf_ce_unconditional || !break_pending); end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Careless assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // // Once asserted, an interrupt will stay asserted while the CPU is // in user mode",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_interrupt && (gie || !i_mem_busy)))) assume(i_interrupt); // }}} `endif // FORMAL // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "slowmpy.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/slowmpy.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: slowmpy.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This is a signed (OPT_SIGNED=1) or unsigned (OPT_SIGNED=0) // multiply designed for low",
            "logic and slow data signals. It // takes one clock per bit plus two more to complete the multiply. // // The OPT_SIGNED version of this algorithm was found on Wikipedia at // https://en.wikipedia.org/wiki/Binary_multiplier. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2018-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module slowmpy #( // {{{",
            "parameter LGNA = 6, parameter [LGNA:0] NA = 33, parameter [0:0] OPT_SIGNED = 1'b1, parameter [0:0] OPT_LOWPOWER = 1'b0, localparam NB = NA // Must be = NA for OPT_SIGNED to work // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // input wire i_stb, input wire signed [(NA-1):0] i_a, input wire signed [(NB-1):0] i_b, // verilator coverage_off",
            "input wire i_aux, // verilator coverage_on",
            "output reg o_busy, o_done, output reg signed [(NA+NB-1):0] o_p, // verilator coverage_off",
            "output reg o_aux // verilator coverage_on // }}} ); // Declarations // {{{",
            "reg [LGNA-1:0] count;",
            "reg [NA-1:0] p_a;",
            "reg [NB-1:0] p_b;",
            "reg [NA+NB-1:0] partial; // verilator coverage_off",
            "reg aux; // verilator coverage_on",
            "reg almost_done;",
            "wire pre_done;",
            "wire [NA-1:0] p",
            "wire ; // }}}",
            "assign pre_done = (count == 0); // almost_done // {{{",
            "initial almost_done = 1'b0;",
            "always @(posedge i_clk) almost_done <= (!i_reset)&&(o_busy)&&(pre_done); // }}} // aux, o_done, o_busy // {{{",
            "initial aux = 0;",
            "initial o_done = 0;",
            "initial o_busy = 0;",
            "always @(posedge i_clk) if (i_reset) begin // {{{ aux <= 0; o_done <= 0; o_busy <= 0; // }}} end else if (!o_busy) begin // {{{ o_done <= 0; o_busy <= i_stb; aux <= (!OPT_LOWPOWER || i_stb) ? i_aux : 0; // }}} end else if (almost_done) begin // {{{ o_done <= 1; o_busy <= 0; // }}} end else o_done <= 0; // }}}",
            "assign p",
            "wire = (p_b[0] ? p_a : 0); // count, partial, p_a, p_b // {{{",
            "always @(posedge i_clk) if (!o_busy) begin count <= NA[LGNA-1:0]-1; partial <= 0; p_a <= i_a; p_b <= i_b; if (OPT_LOWPOWER && !i_stb) begin p_a <= 0; p_b <= 0; end end else begin p_b <= (p_b >> 1); // partial[NA+NB-1:NB] <= partial[NA+NB partial[NB-2:0] <= partial[NB-1:1]; if ((OPT_SIGNED)&&(pre_done)) partial[NA+NB-1:NB-1] <= { 1'b0, partial[NA+NB-1:NB]} + { 1'b0, p",
            "wire [NA-1], ~p",
            "wire [NA-2:0] }; else if (OPT_SIGNED) partial[NA+NB-1:NB-1] <= {1'b0,partial[NA+NB-1:NB]} + { 1'b0, !p",
            "wire [NA-1], p",
            "wire [NA-2:0] }; else partial[NA+NB-1:NB-1] <= {1'b0, partial[NA+NB-1:NB]} + ((p_b[0]) ? {1'b0,p_a} : 0); count <= count - 1; end // }}} // o_p, o_aux // {{{",
            "always @(posedge i_clk) if (almost_done) begin if (OPT_SIGNED) o_p <= partial[NA+NB-1:0] + { 1'b1, {(NA-2){1'b0}}, 1'b1, {(NB){1'b0}} }; else o_p <= partial[NA+NB-1:0]; o_aux <= aux; end // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Declarations and reset // {{{ `define ASSERT assert `ifdef SLOWMPY `define ASSUME assume `else `define ASSUME assert `endif",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "initial assume(i_reset);",
            "always @(*) if (!f_past_valid) `ASSUME(i_reset); // }}}",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) begin `ASSERT(almost_done == 0); `ASSERT(o_done == 0); `ASSERT(o_busy == 0); `ASSERT(aux == 0); end // Assumptions about our",
            "input s",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_stb))&&($past(o_busy))) begin `ASSUME(i_stb); `ASSUME($stable(i_a)); `ASSUME($stable(i_b)); end // // For now, just formally verify our internal signaling // {{{",
            "always @(posedge i_clk) `ASSERT(almost_done == (o_busy&&(&count)));",
            "always @(*) if (!(&count[LGNA-1:1])||(count[0])) `ASSERT(!o_done);",
            "always @(posedge i_clk) if (o_done) `ASSERT(!o_busy);",
            "always @(posedge i_clk) if (!o_busy) `ASSERT(!almost_done);",
            "reg [NA-1:0] f_a, f_b;",
            "always @(posedge i_clk) if ((i_stb)&&(!o_busy)) begin f_a <= i_a; f_b <= i_b; end",
            "always @(*) if (o_done) begin if ((f_a == 0)||(f_b == 0)) begin `ASSERT(o_p == 0); end else `ASSERT(o_p[NA+NB-1] == f_a[NA-1] ^ f_b[NA-1]); end // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // always @(posedge i_clk) cover(o_done);",
            "reg cvr_past_done;",
            "initial cvr_past_done = 1'b0;",
            "always @(posedge i_clk) if (o_done) cvr_past_done <= 1'b1;",
            "always @(posedge i_clk) cover((o_done)&&(cvr_past_done)); // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "axiops.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axiops.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: axiops.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A memory unit to support a CPU based upon AXI4. This is about // the simplest AXI4 interface I can design for this purpose. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2020-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module axiops #( // {{{",
            "parameter C_AXI_ADDR_WIDTH = 32, parameter C_AXI_DATA_WIDTH = 32, parameter C_AXI_ID_WIDTH = 1, parameter [((C_AXI_ID_WIDTH > 0)? C_AXI_ID_WIDTH:1)-1:0] AXI_ID = 0, // // SWAP_ENDIANNESS // {{{ // The ZipCPU was designed to be a big endian machine. With // no other adjustments, this design will make the ZipCPU // *little* endian, for the simple reason that the AXI bus is // a little endian bus. However, if SWAP_ENDIANNESS is set, // the bytes within 32-bit words on the AXI bus will be swapped. // This will return the CPU to being a big endian CPU on a // little endian bus. It will also break any design that // assumes the bus is presented to it in its proper order. // Simple things like counters or interrupt controllers will // therefore cease to work with this option unless they also // swap the endianness of the words they are given.",
            "parameter [0:0] SWAP_ENDIANNESS = 1'b0, // }}} // SWAP_WSTRB // {{{ // SWAP_WSTRB represents a second attempt to fix the endianness // issue. It is incompatible with the SWAP_ENDIANNESS option // above. If SWAP_WSTRB is set, then half words and words will // be placed on the bus in little endian order, but at big // endian addresses. Words written to the bus will be written // in little endian order. Halfwords written to the bus at // address 2 will be written to address 0, halfwords written to // address 0 will be written to address 2. Bytes written to the // but at address 3 will be written to address 0, address 2 // will be written to address 1, address 1 to address 2, and // address 3 to address 0. // // This may just be a half baked attempt to solve this problem, // since it will fail if you ever trie to access bytes or // halfwords at other than their intended widths.",
            "parameter [0:0] SWAP_WSTRB = 1'b0, // }}} // OPT_SIGN_EXTEND // {{{ // Some CPU's want memory accesses to be sign extended upon // return. The ZipCPU is not one of those CPU's. However, // since it's fairly easy to do so, we'll implement this",
            "logic // if ever OPT_SIGN_EXTEND is true so you can see how it would // be done if necessary.",
            "parameter [0:0] OPT_SIGN_EXTEND = 1'b0, // }}}",
            "parameter [0:0] OPT_LOCK=1'b1, // OPT_ALIGNMENT_ERR // {{{ // If set, OPT_ALIGNMENT_ERR will generate an alignment error // on any attempt to write to or read from an unaligned word. // If not set, unaligned reads (or writes) will be expanded into // pairs so as to still accomplish the action requested. The // bus does not guarantee protection, however, that these two // writes or two reads will proceed uninterrupted. Since // unaligned writes and unaligned reads are no longer // guaranteed to be atomic by the AXI bus, it is possible that // any unaligned operations might yield an incoherent result.",
            "parameter [0:0] OPT_ALIGNMENT_ERR = 1'b0, // }}} // OPT_LOWPOWER // {{{ // If set, the design will use extra",
            "logic to guarantee that any // unused",
            "reg isters are kept at zero until they are used. This // will help to guarantee the design (ideally) has fewer // transitions and therefore uses lower power.",
            "parameter [0:0] OPT_LOWPOWER = 1'b1, // }}}",
            "parameter [3:0] OPT_QOS = 0, localparam IW = (C_AXI_ID_WIDTH > 0) ? C_AXI_ID_WIDTH:1, localparam AW = C_AXI_ADDR_WIDTH, localparam DW = C_AXI_DATA_WIDTH, localparam AXILSB = $clog2(C_AXI_DATA_WIDTH/8) // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, input wire i_cpu_reset, // // CPU interface // {{{",
            "input wire i_stb, input wire i_lock, input wire [2:0] i_op, input wire [AW-1:0] i_addr, input wire [AW-1:0] i_restart_pc, input wire [31:0] i_data, input wire [4:0] i_o",
            "reg , output reg o_busy, output reg o_rdbusy, output reg o_valid, output reg o_err, output reg [4:0] o_w",
            "reg , output reg [31:0] o_result, // }}} // AXI4 bus interface // // Writes // {{{",
            "output reg M_AXI_AWVALID, input wire M_AXI_AWREADY, // verilator coverage_off",
            "output wire [IW-1:0] M_AXI_AWID, // verilator coverage_on",
            "output reg [AW-1:0] M_AXI_AWADDR, output wire [7:0] M_AXI_AWLEN, output wire [2:0] M_AXI_AWSIZE, output wire [1:0] M_AXI_AWBURST, output wire M_AXI_AWLOCK, output wire [3:0] M_AXI_AWCACHE, // verilator coverage_off",
            "output wire [2:0] M_AXI_AWPROT, output wire [3:0] M_AXI_AWQOS, // verilator coverage_on // output reg M_AXI_WVALID, input wire M_AXI_WREADY, output reg [DW-1:0] M_AXI_WDATA, output reg [DW/8-1:0] M_AXI_WSTRB, output wire M_AXI_WLAST, // input wire M_AXI_BVALID, output reg M_AXI_BREADY, // verilator coverage_off",
            "input wire [IW-1:0] M_AXI_BID, // verilator coverage_on",
            "input wire [1:0] M_AXI_BRESP, // }}} // Reads // {{{",
            "output reg M_AXI_ARVALID, input wire M_AXI_ARREADY, // verilator coverage_off",
            "output wire [IW-1:0] M_AXI_ARID, // verilator coverage_on",
            "output reg [AW-1:0] M_AXI_ARADDR, output wire [7:0] M_AXI_ARLEN, output wire [2:0] M_AXI_ARSIZE, output wire [1:0] M_AXI_ARBURST, output wire M_AXI_ARLOCK, output wire [3:0] M_AXI_ARCACHE, // verilator coverage_off",
            "output wire [2:0] M_AXI_ARPROT, output wire [3:0] M_AXI_ARQOS, // verilator coverage_on // input wire M_AXI_RVALID, output reg M_AXI_RREADY, // verilator coverage_off",
            "input wire [IW-1:0] M_AXI_RID, // verilator coverage_on",
            "input wire [DW-1:0] M_AXI_RDATA, input wire M_AXI_RLAST, input wire [1:0] M_AXI_RRESP // }}} // }}} ); // Declarations // {{{",
            "localparam CPU_DATA_WIDTH = 32; // Verilator lint_off WIDTH",
            "localparam [2:0] DSZ = $clog2(CPU_DATA_WIDTH/8); // Verilator lint_on WIDTH",
            "localparam [1:0] AXI_INCR = 2'b01, OKAY = 2'b00, EXOKAY = 2'b01;",
            "wire i_clk = S_AXI_ACLK; // wire i_reset = !S_AXI_ARESETN;",
            "reg w_misaligned, w_misalignment_err;",
            "wire misaligned_request, misaligned_aw_request, misaligned_response_pending, pending_err, misaligned_read;",
            "reg r_flushing;",
            "reg [AW-1:0] r_pc;",
            "reg [AXILSB+1:0] r_op;",
            "reg [DW-1:0] next_wdata;",
            "reg [DW/8-1:0] next_wstrb;",
            "reg [DW-1:0] last_result; // reg [31:0] endian_swapped_wdata; // reg [31:0] endian_swapped_result;",
            "reg [2*DW/8-1:0] shifted_wstrb_word, shifted_wstrb_halfword, shifted_wstrb_byte;",
            "reg [2*DW/8-1:0] swapped_wstrb_word, swapped_wstrb_halfword, swapped_wstrb_byte;",
            "reg [DW-1:0] axi_wdata;",
            "reg [DW/8-1:0] axi_wstrb;",
            "reg axlock;",
            "reg [AXILSB-1:0] swapaddr;",
            "wire [DW-1:0] endian_swapped_rdata;",
            "reg [2*DW-1:0] wide_return;",
            "reg [31:0] pre_result; // }}} // xVALID, and xREADY // {{{",
            "initial M_AXI_AWVALID = 1'b0;",
            "initial M_AXI_WVALID = 1'b0;",
            "initial M_AXI_ARVALID = 1'b0;",
            "initial M_AXI_BREADY = 1'b0;",
            "initial M_AXI_RREADY = 1'b0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) begin // {{{ M_AXI_AWVALID <= 1'b0; M_AXI_WVALID <= 1'b0; M_AXI_ARVALID <= 1'b0; M_AXI_BREADY <= 1'b0; M_AXI_RREADY <= 1'b0; // }}} end else if (M_AXI_BREADY || M_AXI_RREADY) begin // Something is outstanding // {{{ if (M_AXI_AWREADY) M_AXI_AWVALID <= M_AXI_AWVALID && misaligned_aw_request; if (M_AXI_WREADY) M_AXI_WVALID <= M_AXI_WVALID && misaligned_request; if (M_AXI_ARREADY) M_AXI_ARVALID <= M_AXI_ARVALID && misaligned_request; if ((M_AXI_BVALID || M_AXI_RVALID) && !misaligned_response_pending) begin M_AXI_BREADY <= 1'b0; M_AXI_RREADY <= 1'b0; end // }}} end else begin // New memory operation // {{{ // Initiate a request M_AXI_AWVALID <= i_op[0]; // Write request M_AXI_WVALID <= i_op[0]; // Write request M_AXI_ARVALID <= !i_op[0]; // Read request // Set BREADY or RREADY to accept the response. These will // remain ready until the response is returned. M_AXI_BREADY <= i_op[0]; M_AXI_RREADY <= !i_op[0]; if (i_cpu_reset || o_err || !i_stb || w_misalignment_err) begin M_AXI_AWVALID <= 0; M_AXI_WVALID <= 0; M_AXI_ARVALID <= 0; M_AXI_BREADY <= 0; M_AXI_RREADY <= 0; end // }}} end // }}} // axlock // {{{",
            "initial axlock = 1'b0;",
            "always @(posedge i_clk) if (!OPT_LOCK || (!S_AXI_ARESETN && OPT_LOWPOWER)) begin // {{{ axlock <= 1'b0; // }}} end else if (M_AXI_BREADY || M_AXI_RREADY) begin // Something is outstanding // {{{ if (OPT_LOWPOWER && (M_AXI_BVALID || M_AXI_RVALID)) axlock <= axlock && i_lock && M_AXI_RVALID; // }}} end else begin // New memory operation // {{{ // Initiate a request if (!OPT_LOWPOWER) axlock <= i_lock; else begin if (i_stb) axlock <= i_lock; if (i_cpu_reset || o_err || w_misaligned) axlock <= 1'b0; end // }}} end",
            "assign M_AXI_AWLOCK = axlock;",
            "assign M_AXI_ARLOCK = axlock; // }}} // r_flushing // {{{",
            "initial r_flushing = 1'b0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) // If everything is reset, then we don't need to worry about // or wait for any pending returns--they'll be canceled by the // global reset. r_flushing <= 1'b0; else if (M_AXI_BREADY || M_AXI_RREADY) begin if (i_cpu_reset) // If only the CPU is reset, however, we have a problem. // The bus hasn't been reset, and so it is still active. // We can't respond to any new requests from the CPU // until we flush any transactions that are currently // active. r_flushing <= 1'b1; if (M_AXI_BVALID || M_AXI_RVALID) // A request just came back, therefore we can clear // r_flushing r_flushing <= 1'b0; if (misaligned_response_pending) // ... unless we're in the middle of a misaligned // request. In that case, there will be a second // return that we still need to wait for. This request, // though, will clear misaligned_response_pending. r_flushing <= r_flushing || i_cpu_reset; end else // If nothing is active, we don't care about the CPU reset. // Flushing just stays at zero. r_flushing <= 1'b0; // }}} // M_AXI_AxADDR // {{{",
            "initial M_AXI_AWADDR = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN && OPT_LOWPOWER) M_AXI_AWADDR <= 0; else if (!M_AXI_BREADY && !M_AXI_RREADY) begin // Initial address // {{{ M_AXI_AWADDR <= i_addr; if (OPT_LOWPOWER && (i_cpu_reset || o_err || !i_stb || w_misalignment_err)) M_AXI_AWADDR <= 0; if (SWAP_ENDIANNESS || SWAP_WSTRB) begin // When adjusting endianness, reads (or writes) are // always full words. This is important since the // the bytes at issues may (or may not) be in their // expected locations if (OPT_ALIGNMENT_ERR) M_AXI_AWADDR[AXILSB-1:0] <= 0; else M_AXI_AWADDR[1:0] <= 0; end // }}} end else if ((M_AXI_AWVALID && M_AXI_AWREADY) ||(M_AXI_ARVALID && M_AXI_ARREADY)) begin // Subsequent addresses // {{{ M_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:AXILSB] <= M_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:AXILSB] + 1; M_AXI_AWADDR[AXILSB-1:0] <= 0; if (OPT_LOWPOWER && ((M_AXI_RREADY && !misaligned_request) || (M_AXI_BREADY && !misaligned_aw_request))) M_AXI_AWADDR <= 0; // }}} end",
            "always @(*) M_AXI_ARADDR = M_AXI_AWADDR; // }}} // M_AXI_AxSIZE // {{{",
            "reg [2:0] axsize;",
            "initial axsize = DSZ;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) axsize <= DSZ; else if (!M_AXI_BREADY && !M_AXI_RREADY && (!OPT_LOWPOWER || i_stb)) begin casez(i_op[2:1]) 2'b0?: begin axsize <= 3'b010; // Word if ((|i_addr[1:0]) && !w_misaligned) axsize <= AXILSB[2:0]; end 2'b10: begin axsize <= 3'b001; // Half-word if (i_addr[0] && !w_misaligned) axsize <= AXILSB[2:0]; end 2'b11: axsize <= 3'b000; // Byte endcase if (SWAP_WSTRB) axsize <= (OPT_ALIGNMENT_ERR) ? DSZ : AXILSB[2:0]; end",
            "assign M_AXI_AWSIZE = axsize;",
            "assign M_AXI_ARSIZE = axsize; // }}} // AxOTHER // {{{",
            "localparam [3:0] AXI_NON_CACHABLE_BUFFERABLE = 4'h3;",
            "localparam [3:0] OPT_CACHE = AXI_NON_CACHABLE_BUFFERABLE;",
            "localparam [2:0] AXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS = 3'h0;",
            "localparam [2:0] OPT_PROT=AXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS;",
            "assign M_AXI_AWID = AXI_ID;",
            "assign M_AXI_AWLEN = 0;",
            "assign M_AXI_AWBURST = AXI_INCR;",
            "assign M_AXI_AWCACHE = M_AXI_AWLOCK ? 0: OPT_CACHE;",
            "assign M_AXI_AWPROT = OPT_PROT;",
            "assign M_AXI_AWQOS = OPT_QOS;",
            "assign M_AXI_WLAST = 1;",
            "assign M_AXI_ARID = AXI_ID;",
            "assign M_AXI_ARLEN = 0;",
            "assign M_AXI_ARBURST = AXI_INCR;",
            "assign M_AXI_ARCACHE = M_AXI_ARLOCK ? 0: OPT_CACHE;",
            "assign M_AXI_ARPROT = OPT_PROT;",
            "assign M_AXI_ARQOS = OPT_QOS; // }}} // shifted_wstrb_* // {{{ generate if (SWAP_WSTRB) begin : BIG_ENDIAN_WSTRB",
            "always @(*) shifted_wstrb_word = { 4'b1111, {(2*DW/8-4){1'b0}} } >> i_addr[AXILSB-1:0];",
            "always @(*) shifted_wstrb_halfword = { 2'b11, {(2*DW/8-2){1'b0}} } >> i_addr[AXILSB-1:0];",
            "always @(*) shifted_wstrb_byte = { 1'b1, {(2*DW/8-1){1'b0}} } >> i_addr[AXILSB-1:0]; end else begin : NORMAL_SHIFTED_WSTRB",
            "always @(*) shifted_wstrb_word = { {(2*DW/8-4){1'b0}}, 4'b1111} << i_addr[AXILSB-1:0];",
            "always @(*) shifted_wstrb_halfword = { {(2*DW/8-4){1'b0}}, 4'b0011} << i_addr[AXILSB-1:0];",
            "always @(*) shifted_wstrb_byte = { {(2*DW/8-4){1'b0}}, 4'b0001} << i_addr[AXILSB-1:0]; end endgenerate // }}} // Swapping WSTRB bits // {{{ generate if (SWAP_ENDIANNESS) begin : SWAPPING_ENDIANNESS // {{{ genvar gw, gb; for(gw=0; gw<2*DW/32; gw=gw+1) begin : FOREACH_32B_WORD for(gb=0; gb<32/8; gb=gb+1) begin : FOREACH_BYTE",
            "always @(*) begin swapped_wstrb_word[gw*4+gb] = shifted_wstrb_word[gw*4+(3-gb)]; swapped_wstrb_halfword[gw*4+gb] = shifted_wstrb_halfword[gw*4+(3-gb)]; swapped_wstrb_byte[gw*4+gb] = shifted_wstrb_byte[gw*4+(3-gb)]; end end end // }}} end else begin : KEEP_WSTRB // {{{",
            "always @(*) swapped_wstrb_word = shifted_wstrb_word;",
            "always @(*) swapped_wstrb_halfword = shifted_wstrb_halfword;",
            "always @(*) swapped_wstrb_byte = shifted_wstrb_byte; // }}} end endgenerate // }}} // wdata, wstrb // {{{",
            "always @(*) swapaddr = i_addr[AXILSB-1:0];",
            "initial axi_wdata = 0;",
            "initial axi_wstrb = 0;",
            "initial next_wdata = 0;",
            "initial next_wstrb = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && !S_AXI_ARESETN) begin // {{{ axi_wdata <= 0; axi_wstrb <= 0; next_wdata <= 0; next_wstrb <= 0; r_op <= 0; // }}} end else if (i_stb) begin // {{{ if (SWAP_WSTRB) begin casez(i_op[2:1]) 2'b10: { axi_wdata, next_wdata } <= { i_data[15:0], {(2*C_AXI_DATA_WIDTH-16){1'b0}} } >> (8*swapaddr); 2'b11: { axi_wdata, next_wdata } <= { i_data[7:0], {(2*C_AXI_DATA_WIDTH-8){1'b0}} } >> (8*swapaddr); default: { axi_wdata, next_wdata } <= { i_data, {(2*C_AXI_DATA_WIDTH-32){1'b0}} } >> (8*swapaddr); endcase end else begin casez(i_op[2:1]) 2'b10: { next_wdata, axi_wdata } <= { {(2*C_AXI_DATA_WIDTH-16){1'b0}}, i_data[15:0] } << (8*swapaddr); 2'b11: { next_wdata, axi_wdata } <= { {(2*C_AXI_DATA_WIDTH-8){1'b0}}, i_data[7:0] } << (8*swapaddr); default: { next_wdata, axi_wdata } <= { {(2*C_AXI_DATA_WIDTH-32){1'b0}}, i_data } << (8*swapaddr); endcase end // next_wstrb, axi_wstrb // {{{ if (SWAP_WSTRB) begin casez(i_op[2:1]) 2'b0?: { axi_wstrb, next_wstrb } <= swapped_wstrb_word; 2'b10: { axi_wstrb, next_wstrb } <= swapped_wstrb_halfword; 2'b11: { axi_wstrb, next_wstrb } <= swapped_wstrb_byte; endcase end else begin casez(i_op[2:1]) 2'b0?: { next_wstrb, axi_wstrb } <= swapped_wstrb_word; 2'b10: { next_wstrb, axi_wstrb } <= swapped_wstrb_halfword; 2'b11: { next_wstrb, axi_wstrb } <= swapped_wstrb_byte; endcase end // }}} r_op <= { i_op[2:1] , i_addr[AXILSB-1:0] }; // On a read set everything to zero but only if OPT_LOWPOWER // is set // {{{ if (OPT_LOWPOWER && !i_op[0]) { next_wstrb, next_wdata, axi_wstrb, axi_wdata } <= 0; if (w_misalignment_err) { next_wstrb, next_wdata } <= 0; if (OPT_LOWPOWER) begin if (w_misalignment_err) { axi_wdata, axi_wstrb, r_op } <= 0; if (o_err || i_cpu_reset) { next_wdata, next_wstrb, axi_wdata, axi_wstrb, r_op } <= 0; end // }}} // }}} end else if ((misaligned_request || !OPT_LOWPOWER) && M_AXI_WREADY) begin // {{{ axi_wdata <= next_wdata; axi_wstrb <= next_wstrb; if (OPT_LOWPOWER) { next_wdata, next_wstrb } <= 0; // }}} end else if (OPT_LOWPOWER && M_AXI_WREADY) begin // {{{ axi_wdata <= 0; axi_wstrb <= 0; // }}} end // }}} // M_AXI_WDATA, M_AXI_WSTRB // {{{ generate if (SWAP_ENDIANNESS) begin : SWAP_WRITE_DATA_STRB // {{{ genvar gw, gb; for(gw=0; gw<C_AXI_DATA_WIDTH/32; gw=gw+1) begin for(gb=0; gb<32/8; gb=gb+1) begin",
            "always @(*) begin M_AXI_WDATA[32*gw + 8*gb +: 8] = axi_wdata[32*gw+8*(3-gb) +: 8]; M_AXI_WSTRB[4*gw + gb] = axi_wstrb[4*gw+(3-gb)]; end end end // }}} end else begin : KEEP_WRITE_DATA_STRB // {{{",
            "always @(*) { M_AXI_WSTRB, M_AXI_WDATA } = { axi_wstrb, axi_wdata }; // }}} end endgenerate // }}} // w_misaligned // {{{",
            "always @(*) casez(i_op[2:1]) // Full word 2'b0?: w_misaligned = ((i_addr[AXILSB-1:0]+3) >= (1<<AXILSB)); // Half word 2'b10: w_misaligned = ((i_addr[AXILSB-1:0]+1) >= (1<<AXILSB)); // Bytes are",
            "always aligned 2'b11: w_misaligned = 1'b0; endcase // }}} // w_misalignment_err // {{{",
            "always @(*) begin w_misalignment_err = OPT_ALIGNMENT_ERR && w_misaligned; if (OPT_LOCK && i_lock) begin casez(i_op[2:1]) 2'b0?: w_misalignment_err = (|i_addr[1:0]); 2'b10: w_misalignment_err = i_addr[0]; default: w_misalignment_err = 1'b0; endcase end end // }}} // misaligned_[aw_|]request, pending_err, misaligned_response_pending // {{{ generate if (OPT_ALIGNMENT_ERR) begin : GEN_ALIGNMENT_ERR // {{{",
            "assign misaligned_request = 1'b0;",
            "assign misaligned_aw_request = 1'b0;",
            "assign misaligned_response_pending = 1'b0;",
            "assign misaligned_read = 1'b0;",
            "assign pending_err = 1'b0; // }}} end else begin : GEN_REALIGN // {{{",
            "reg r_misaligned_request, r_misaligned_aw_request, r_misaligned_response_pending, r_misaligned_read, r_pending_err; // misaligned_request // {{{",
            "initial r_misaligned_request = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) r_misaligned_request <= 0; else if (i_stb && !o_err && !i_cpu_reset) r_misaligned_request <= w_misaligned && !w_misalignment_err; else if ((M_AXI_WVALID && M_AXI_WREADY) || (M_AXI_ARVALID && M_AXI_ARREADY)) r_misaligned_request <= 1'b0;",
            "assign misaligned_request = r_misaligned_request; // }}} // misaligned_aw_request // {{{",
            "initial r_misaligned_aw_request = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) r_misaligned_aw_request <= 0; else if (i_stb && !o_err && !i_cpu_reset) r_misaligned_aw_request <= w_misaligned && i_op[0] && !w_misalignment_err; else if (M_AXI_AWREADY) r_misaligned_aw_request <= 1'b0;",
            "assign misaligned_aw_request = r_misaligned_aw_request; // }}} // misaligned_response_pending // {{{",
            "initial r_misaligned_response_pending = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) r_misaligned_response_pending <= 0; else if (i_stb && !o_err && !i_cpu_reset) r_misaligned_response_pending <= w_misaligned && !w_misalignment_err; else if (M_AXI_BVALID || M_AXI_RVALID) r_misaligned_response_pending <= 1'b0;",
            "assign misaligned_response_pending = r_misaligned_response_pending; // }}} // misaligned_read // {{{",
            "initial r_misaligned_read = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) r_misaligned_read <= 0; else if (i_stb && !o_err && !i_cpu_reset) r_misaligned_read <= w_misaligned && !i_op[0] && !w_misalignment_err; else if (M_AXI_RVALID) r_misaligned_read <= (misaligned_response_pending);",
            "assign misaligned_read = r_misaligned_read; // }}} // pending_err // {{{",
            "initial r_pending_err = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || (!M_AXI_BREADY && !M_AXI_RREADY) || r_flushing) r_pending_err <= 1'b0; else if ((M_AXI_BVALID && M_AXI_BRESP[1]) || (M_AXI_RVALID && M_AXI_RRESP[1])) r_pending_err <= 1'b1;",
            "assign pending_err = r_pending_err; // }}} // }}} end endgenerate // }}} // o_valid // {{{",
            "initial o_valid = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || r_flushing) o_valid <= 1'b0; else if (axlock) o_valid <= (M_AXI_RVALID && M_AXI_RRESP == EXOKAY) || (M_AXI_BVALID && M_AXI_BRESP == OKAY); else o_valid <= M_AXI_RVALID && !M_AXI_RRESP[1] && !pending_err && !misaligned_response_pending; // }}} // o_err // {{{",
            "initial o_err = 1'b0;",
            "always @(posedge i_clk) if (r_flushing || i_cpu_reset || o_err) o_err <= 1'b0; else if (i_stb && w_misalignment_err) o_err <= 1'b1; else if (axlock) begin o_err <= (M_AXI_BVALID && M_AXI_BRESP[1]) || (M_AXI_RVALID && M_AXI_RRESP != EXOKAY); end else if ((M_AXI_BVALID || M_AXI_RVALID) && !misaligned_response_pending) o_err <= (M_AXI_BVALID && M_AXI_BRESP[1]) || (M_AXI_RVALID && M_AXI_RRESP[1]) || pending_err; else o_err <= 1'b0; // }}} // o_busy, o_rdbusy // {{{",
            "always @(*) begin o_busy = M_AXI_BREADY || M_AXI_RREADY; o_rdbusy = (M_AXI_BREADY && axlock) || M_AXI_RREADY; if (r_flushing) o_rdbusy = 1'b0; end // }}} // o_w",
            "reg // {{{",
            "always @(posedge i_clk) if (i_stb) begin o_w",
            "reg <= i_o",
            "reg ; if (OPT_LOCK && i_stb && i_lock && i_op[0]) o_w",
            "reg [3:0] <= 4'hf; end // }}} // r_pc // {{{",
            "always @(posedge S_AXI_ACLK) if (!OPT_LOCK) r_pc <= 0; else if (i_stb && i_lock && !i_op[0]) r_pc <= i_restart_pc; // }}} // endian_swapped_rdata // {{{ generate if (SWAP_ENDIANNESS) begin : SWAP_RDATA_ENDIANNESS genvar gw, gb; for(gw=0; gw<C_AXI_DATA_WIDTH/32; gw=gw+1) begin for(gb=0; gb<32/8; gb=gb+1) begin",
            "assign endian_swapped_rdata[gw*32+gb*8 +: 8] = M_AXI_RDATA[gw*32+(3-gb)*8 +: 8]; end end end else begin : KEEP_RDATA",
            "assign endian_swapped_rdata = M_AXI_RDATA; end endgenerate // }}} // pre_result // {{{ // The purpose of the pre-result is to guarantee that the synthesis // tool knows we want a shift of the full 2*DW width.",
            "always @(*) begin if (SWAP_WSTRB) begin if (misaligned_read && !OPT_ALIGNMENT_ERR) wide_return={ last_result, endian_swapped_rdata } << (8*r_op[AXILSB-1:0]); else wide_return = { endian_swapped_rdata, {(DW){1'b0}} } << (8*r_op[AXILSB-1:0]); end else begin if (misaligned_read && !OPT_ALIGNMENT_ERR) wide_return={ endian_swapped_rdata, last_result } >> (8*r_op[AXILSB-1:0]); else wide_return = { {(DW){1'b0}}, endian_swapped_rdata } >> (8*r_op[AXILSB-1:0]); end if (OPT_LOWPOWER && (!M_AXI_RVALID || M_AXI_RRESP[1])) wide_return = 0; end",
            "always @(*) begin if (SWAP_WSTRB) begin pre_result = 0; casez(r_op[AXILSB +: 2]) 2'b10: pre_result[15:0] = { wide_return[(2*DW)-1:(2*DW)-16] }; 2'b11: pre_result[7:0] = { wide_return[(2*DW)-1:(2*DW)-8] }; default: pre_result[31:0] = wide_return[(2*DW-1):(2*DW-32)]; endcase end else pre_result = wide_return[31:0]; end // }}} // last_result, o_result // {{{",
            "always @(posedge i_clk) if (OPT_LOWPOWER &&((!M_AXI_RREADY && (!OPT_LOCK || !M_AXI_BREADY)) || !S_AXI_ARESETN || r_flushing || i_cpu_reset)) { last_result, o_result } <= 0; else begin // {{{ if (OPT_LOWPOWER) o_result <= 0; if (OPT_LOCK && M_AXI_BVALID && (!OPT_LOWPOWER || (axlock && M_AXI_BRESP == OKAY))) begin o_result <= 0; o_result[AW-1:0] <= r_pc; end if (M_AXI_RVALID) begin // {{{ if (OPT_LOWPOWER && (M_AXI_RRESP[1] || !misaligned_response_pending)) last_result <= 0; else last_result <= endian_swapped_rdata; o_result <= pre_result[31:0]; if (OPT_SIGN_EXTEND) begin // {{{ // verilator coverage_off // Optionally sign extend the return result. // Not covered, since this violates ZipCPU ISA casez(r_op[AXILSB +: 2]) 2'b10: o_result[31:16] <= {(16){pre_result[15]}}; 2'b11: o_result[31: 8] <= {(24){pre_result[7]}}; default: begin end endcase // verilator coverage_off // }}} end else begin // Fill unused return bits with zeros casez(r_op[AXILSB +: 2]) 2'b10: o_result[31:16] <= 0; 2'b11: o_result[31: 8] <= 0; default: begin end endcase end if (OPT_LOWPOWER && (M_AXI_RRESP[1] || (axlock && !M_AXI_RRESP[0]))) o_result <= 0; // }}} end if (OPT_ALIGNMENT_ERR) last_result <= 0; if (OPT_LOWPOWER && (pending_err || misaligned_response_pending)) o_result <= 0; // }}} end // }}} // Make verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, M_AXI_BID, M_AXI_RID, M_AXI_RLAST }; generate if (SWAP_WSTRB) begin : GEN_UNUSED",
            "wire wide_unused; if (SWAP_WSTRB) begin : UNUSED_SWAP_RETURN",
            "assign wide_unused = &{ 1'b0, wide_return[2*DW-32-1:0] }; end else begin : UNUSED_RETURN",
            "assign wide_unused = &{ 1'b0, wide_return[2*DW-1:32] }; end end endgenerate // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Local declarations // {{{ `define ASSERT assert `ifdef AXIOPS `define ASSUME assume `else `define ASSUME assert `endif",
            "localparam F_LGDEPTH = 10;",
            "reg f_misaligned;",
            "wire [F_LGDEPTH-1:0] faxi_awr_nbursts, faxi_rd_nbursts, faxi_rd_outstanding;",
            "wire [8:0] faxi_wr_pending;",
            "wire [IW-1:0] faxi_wr_checkid;",
            "wire faxi_wr_ckvalid;",
            "wire [F_LGDEPTH-1:0] faxi_wrid_nbursts;",
            "wire [AW-1:0] faxi_wr_addr;",
            "wire [7:0] faxi_wr_incr;",
            "wire [1:0] faxi_wr_burst;",
            "wire [2:0] faxi_wr_size;",
            "wire [7:0] faxi_wr_len;",
            "wire faxi_wr_lockd; // wire [IW-1:0] faxi_rd_checkid;",
            "wire faxi_rd_ckvalid;",
            "wire [8:0] faxi_rd_cklen;",
            "wire [AW-1:0] faxi_rd_ckaddr;",
            "wire [7:0] faxi_rd_ckincr;",
            "wire [1:0] faxi_rd_ckburst;",
            "wire [2:0] faxi_rd_cksize;",
            "wire [7:0] faxi_rd_ckarlen;",
            "wire faxi_rd_cklockd;",
            "wire [F_LGDEPTH-1:0] faxi_rdid_nbursts, faxi_rdid_outstanding;",
            "wire [F_LGDEPTH-1:0] faxi_rdid_ckign_nbursts, faxi_rdid_ckign_outstanding;",
            "wire [1:0] faxi_ex_state;",
            "wire faxi_ex_checklock;",
            "wire [F_LGDEPTH-1:0] faxi_rdid_bursts_to_lock;",
            "wire [F_LGDEPTH-1:0] faxi_wrid_bursts_to_exwrite; (* anyseq *)",
            "wire f_active_lock;",
            "reg [AW-1:0] f_exlock_addr;",
            "wire [AW-1:0] faxi_exreq_addr;",
            "wire [7:0] f_exlock_len, faxi_exreq_len;",
            "wire [1:0] f_exlock_burst, faxi_exreq_burst;",
            "wire [2:0] faxi_exreq_size;",
            "reg [2:0] f_exlock_size;",
            "wire faxi_exlock_return;",
            "wire f_pc, f_gie, f_read_cycle, f_exwrite_cycle;",
            "reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid = 1'b1;",
            "always @(*) if (!f_past_valid) `ASSUME(!S_AXI_ARESETN); // }}} //////////////////////////////////////////////////////////////////////// // // Bus properties // {{{ //////////////////////////////////////////////////////////////////////// // // faxi_master #( // {{{ .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH), .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .OPT_EXCLUSIVE(OPT_LOCK), .F_OPT_ASSUME_RESET(1'b1), .F_LGDEPTH(F_LGDEPTH) // }}} ) faxi( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // // Write address channel // {{{ .i_axi_awvalid(M_AXI_AWVALID), .i_axi_awready(M_AXI_AWREADY), .i_axi_awid( M_AXI_AWID), .i_axi_awaddr( M_AXI_AWADDR), .i_axi_awlen( M_AXI_AWLEN), .i_axi_awsize( M_AXI_AWSIZE), .i_axi_awburst(M_AXI_AWBURST), .i_axi_awlock( M_AXI_AWLOCK), .i_axi_awcache(M_AXI_AWCACHE), .i_axi_awprot( M_AXI_AWPROT), .i_axi_awqos( M_AXI_AWQOS), // }}} // Write data // {{{ .i_axi_wvalid(M_AXI_WVALID), .i_axi_wready(M_AXI_WREADY), .i_axi_wdata( M_AXI_WDATA), .i_axi_wstrb( M_AXI_WSTRB), .i_axi_wlast( M_AXI_WLAST), // }}} // Write return // {{{ .i_axi_bvalid(M_AXI_BVALID), .i_axi_bready(M_AXI_BREADY), .i_axi_bid( M_AXI_BID), .i_axi_bresp( M_AXI_BRESP), // }}} // Read address // {{{ .i_axi_arvalid(M_AXI_ARVALID), .i_axi_arready(M_AXI_ARREADY), .i_axi_arid( M_AXI_ARID), .i_axi_araddr( M_AXI_ARADDR), .i_axi_arlen( M_AXI_ARLEN), .i_axi_arsize( M_AXI_ARSIZE), .i_axi_arburst(M_AXI_ARBURST), .i_axi_arlock( M_AXI_ARLOCK), .i_axi_arcache(M_AXI_ARCACHE), .i_axi_arprot( M_AXI_ARPROT), .i_axi_arqos( M_AXI_ARQOS), // }}} // Read return // {{{ .i_axi_rvalid(M_AXI_RVALID), .i_axi_rready(M_AXI_RREADY), .i_axi_rid( M_AXI_RID), .i_axi_rdata( M_AXI_RDATA), .i_axi_rlast( M_AXI_RLAST), .i_axi_rresp( M_AXI_RRESP), // }}} // Induction values // {{{ .f_axi_awr_nbursts(faxi_awr_nbursts), .f_axi_wr_pending(faxi_wr_pending), .f_axi_rd_nbursts(faxi_rd_nbursts), .f_axi_rd_outstanding(faxi_rd_outstanding), // Write counters // {{{ .f_axi_wr_checkid(faxi_wr_checkid), .f_axi_wr_ckvalid(faxi_wr_ckvalid), .f_axi_wrid_nbursts(faxi_wrid_nbursts), .f_axi_wr_addr(faxi_wr_addr), .f_axi_wr_incr(faxi_wr_incr), .f_axi_wr_burst(faxi_wr_burst), .f_axi_wr_size(faxi_wr_size), .f_axi_wr_len(faxi_wr_len), .f_axi_wr_lockd(faxi_wr_lockd), // }}} // Read counters // {{{ .f_axi_rd_checkid(faxi_rd_checkid), .f_axi_rd_ckvalid(faxi_rd_ckvalid), .f_axi_rd_cklen(faxi_rd_cklen), .f_axi_rd_ckaddr(faxi_rd_ckaddr), .f_axi_rd_ckincr(faxi_rd_ckincr), .f_axi_rd_ckburst(faxi_rd_ckburst), .f_axi_rd_cksize(faxi_rd_cksize), .f_axi_rd_ckarlen(faxi_rd_ckarlen), .f_axi_rd_cklockd(faxi_rd_cklockd), .f_axi_rdid_nbursts(faxi_rdid_nbursts), .f_axi_rdid_outstanding(faxi_rdid_outstanding), .f_axi_rdid_ckign_nbursts(faxi_rdid_ckign_nbursts), .f_axi_rdid_ckign_outstanding(faxi_rdid_ckign_outstanding), // }}} // Exclusive access checks // {{{ .f_axi_ex_state(faxi_ex_state), .f_axi_ex_checklock(faxi_ex_checklock), .f_axi_rdid_bursts_to_lock(faxi_rdid_bursts_to_lock), .f_axi_wrid_bursts_to_exwrite(faxi_wrid_bursts_to_exwrite), .i_active_lock( f_active_lock), .i_exlock_addr( f_exlock_addr), .i_exlock_len( f_exlock_len), .i_exlock_burst(f_exlock_burst), .i_exlock_size( f_exlock_size), .f_axi_exreq_addr( faxi_exreq_addr), .f_axi_exreq_len( faxi_exreq_len), .f_axi_exreq_burst(faxi_exreq_burst), .f_axi_exreq_size( faxi_exreq_size), .f_axi_exreq_return( faxi_exlock_return) // }}} // }}} // }}} );",
            "always @(*) begin assert(faxi_wrid_nbursts == faxi_awr_nbursts); assert(faxi_rdid_nbursts == faxi_rd_nbursts); assert(faxi_rdid_outstanding == faxi_rd_outstanding); assert(faxi_rd_nbursts == faxi_rd_outstanding); assume(faxi_rd_checkid == faxi_wr_checkid); assume(faxi_rd_checkid == AXI_ID); if (faxi_wr_ckvalid) begin assert(faxi_wr_burst == M_AXI_AWBURST); // assert(faxi_wr_size == M_AXI_AWSIZE); assert(faxi_wr_len == M_AXI_AWLEN); // == 0 assert(faxi_wr_lockd == axlock); end if (faxi_rd_ckvalid) begin assert(faxi_rd_ckburst == M_AXI_ARBURST); // assert(faxi_rd_cksize == M_AXI_ARSIZE); assert(faxi_rd_ckarlen == M_AXI_ARLEN); // == 0 assert(faxi_rd_cklockd == axlock); end if (misaligned_request) `ASSERT(M_AXI_WVALID || M_AXI_ARVALID); if (misaligned_aw_request) `ASSERT(M_AXI_AWVALID); if (!misaligned_response_pending) begin `ASSERT(faxi_rd_outstanding <= (M_AXI_ARVALID ? 0:1)); // `ASSERT(faxi_wr_outstanding <= (M_AXI_WVALID ? 0:1)); `ASSERT(faxi_awr_nbursts <= (M_AXI_AWVALID ? 0:1)); `ASSERT(!misaligned_request); `ASSERT(!misaligned_aw_request); end else if (M_AXI_RREADY) `ASSERT(misaligned_read); if (!M_AXI_RREADY) begin `ASSERT(!M_AXI_ARVALID); `ASSERT(faxi_rd_outstanding == 0); `ASSERT(misaligned_read == 1'b0); end else begin if (misaligned_request) `ASSERT(faxi_rd_outstanding <= 0); `ASSERT(faxi_rd_outstanding <= 1 + (misaligned_read ? 1:0)); // `ASSERT(faxi_rd_outstanding == // (M_AXI_RREADY && misaligned_request) ? 1:0) // ((M_AXI_RREADY && !M_AXI_RVALID) ? 1:0) // ); end if (!M_AXI_BREADY) begin `ASSERT(!M_AXI_AWVALID); `ASSERT(!M_AXI_WVALID); `ASSERT(faxi_awr_nbursts == 0); `ASSERT(faxi_wr_pending == 0); end else begin if (misaligned_request) `ASSERT(faxi_wr_pending == (((!M_AXI_AWVALID || !misaligned_aw_request) && M_AXI_WVALID) ? 1:0)); if (misaligned_aw_request) begin `ASSERT(faxi_awr_nbursts == 0); `ASSERT(misaligned_request); `ASSERT(M_AXI_AWVALID); `ASSERT(M_AXI_WVALID); end `ASSERT(!M_AXI_AWVALID || M_AXI_WVALID); `ASSERT(faxi_awr_nbursts <= 2); `ASSERT(faxi_wr_pending <= 2); case({misaligned_request, misaligned_aw_request, misaligned_response_pending}) 3'b000: begin `ASSERT(faxi_awr_nbursts<= (M_AXI_BREADY ? 1:0)); `ASSERT(faxi_wr_pending <= (M_AXI_BREADY ? 1:0)); end 3'b001: begin `ASSERT(faxi_awr_nbursts<= 1 + (M_AXI_AWVALID ? 0:1)); `ASSERT(faxi_wr_pending <= 1 + (M_AXI_WVALID ? 0:1)); end 3'b010: `ASSERT(0); 3'b011: begin `ASSERT(faxi_wr_pending<= 1 + (M_AXI_WVALID ? 0:1)); `ASSERT(faxi_awr_nbursts == 0); `ASSERT(M_AXI_AWVALID); end 3'b100: `ASSERT(0); 3'b101: begin `ASSERT(faxi_awr_nbursts<= 1 + (M_AXI_AWVALID ? 0:1)); // `ASSERT(faxi_wr_pending == 0); `ASSERT(M_AXI_WVALID); end 3'b110: `ASSERT(0); 3'b111: begin `ASSERT(faxi_awr_nbursts == 0); // `ASSERT(faxi_wr_pending == 0); `ASSERT(M_AXI_AWVALID); `ASSERT(M_AXI_WVALID); end default: begin end endcase end // Rule: Only one of the two xREADY's may be valid, never both `ASSERT(!M_AXI_BREADY || !M_AXI_RREADY); // Rule: Only one of the two VALID's may be valid, never both `ASSERT(!M_AXI_RVALID || (!M_AXI_AWVALID && !M_AXI_WVALID)); end // f_exlock_* // {{{",
            "initial f_exlock_size = 3'b010;",
            "always @(posedge i_clk) if (M_AXI_ARVALID && M_AXI_ARREADY && M_AXI_ARLOCK) begin f_exlock_addr <= M_AXI_ARADDR; f_exlock_size <= M_AXI_ARSIZE; end",
            "assign f_exlock_len = 0;",
            "assign f_exlock_burst = M_AXI_AWBURST; // f_misaligned // {{{",
            "always @(*) begin f_misaligned = 0; case(r_op[AXILSB +: 2]) 2'b01: f_misaligned = ((r_op[AXILSB-1:0] + 3) >= (1<<AXILSB)); 2'b10: f_misaligned = ((r_op[AXILSB-1:0] + 1) >= (1<<AXILSB)); default: f_misaligned = 0; endcase if (!M_AXI_BREADY && !M_AXI_RREADY) f_misaligned = 0; end // }}}",
            "always @(*) if (!M_AXI_RREADY && !M_AXI_BREADY) begin // {{{ assert(!misaligned_aw_request); assert(!misaligned_request); assert(!misaligned_response_pending); assert(faxi_awr_nbursts == 0); assert(faxi_wr_pending == 0); assert(faxi_rd_outstanding == 0); // }}} end else if (f_misaligned) begin // {{{ assert(!OPT_ALIGNMENT_ERR); if (misaligned_aw_request || misaligned_request) begin // {{{ if (misaligned_aw_request) begin assert(faxi_awr_nbursts == 0); end else if (M_AXI_BREADY) begin assert(faxi_awr_nbursts == (M_AXI_AWVALID ? 0:1) + (misaligned_response_pending ? 1:0)); end else assert(faxi_awr_nbursts == 0); if (misaligned_request && M_AXI_BREADY) begin // assert(faxil_wr_outstanding == 0); assert(faxi_rd_outstanding == 0); end else if (M_AXI_RREADY) begin assert(faxi_rd_outstanding == (M_AXI_ARVALID ? 0:1) + (!misaligned_request && misaligned_response_pending ? 1:0)); // assert(faxil_wr_outstanding == 0); end else begin //assert(faxil_wr_outstanding // == (M_AXI_WVALID ? 0:1) // + (misaligned_response_pending ? 1:0)); assert(faxi_rd_outstanding == 0); end // }}} end else if (M_AXI_BREADY) begin // {{{ assert(faxi_awr_nbursts == (M_AXI_AWVALID ? 0:1) + (misaligned_response_pending ? 1:0)); //assert(faxil_wr_outstanding // == (M_AXI_WVALID ? 0:1) // + (misaligned_response_pending ? 1:0)); // }}} end else begin // Read cycle // {{{ assert(M_AXI_RREADY); assert(faxi_rd_outstanding == (M_AXI_ARVALID ? 0:1) + (misaligned_response_pending ? 1:0)); // }}} end // }}} end else if (M_AXI_BREADY) begin // {{{ assert(!misaligned_aw_request); assert(!misaligned_request); assert(!misaligned_response_pending); assert(!pending_err); assert(faxi_awr_nbursts == (M_AXI_AWVALID ? 0:1)); // assert(faxil_wr_outstanding == (M_AXI_WVALID ? 0:1)); assert(faxi_rd_outstanding == 0); assert(!misaligned_read); // }}} end else begin // {{{ assert(M_AXI_RREADY); assert(!misaligned_aw_request); assert(!misaligned_request); assert(!misaligned_response_pending); assert(!misaligned_read); assert(!pending_err); assert(faxi_awr_nbursts == 0); // assert(faxil_wr_outstanding == 0); assert(faxi_rd_outstanding == (M_AXI_ARVALID ? 0:1)); // }}} end // }}}",
            "always @(*) if (!o_busy) `ASSERT(!r_flushing); // Following any i_stb request, assuming we are idle, immediately // begin a bus transaction",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_stb && !o_err)) &&(!$past(o_busy))&&($past(!i_cpu_reset))) begin `ASSERT(o_busy || ($past(w_misalignment_err) && o_err)); end",
            "always @(*) `ASSERT(o_busy == (M_AXI_BREADY || M_AXI_RREADY));",
            "always @(*) if (o_busy && !misaligned_request && OPT_LOWPOWER) begin assert(next_wdata == 0); assert(next_wstrb == 0); end // If a transaction ends in an error, send o_err on the",
            "output port.",
            "always @(posedge i_clk) if (f_past_valid) begin if ($past(i_cpu_reset || r_flushing || o_err)) begin `ASSERT(!o_err); end else if ($past(M_AXI_BVALID && M_AXI_BRESP[1])) begin if ($past(misaligned_response_pending)) begin `ASSERT((!o_err && pending_err) || r_flushing); end else `ASSERT(o_err); end else if ($past(M_AXI_RVALID && M_AXI_RRESP[1] || (M_AXI_RVALID && axlock && M_AXI_RRESP != EXOKAY))) begin if ($past(misaligned_response_pending)) begin `ASSERT((!o_err && pending_err) || r_flushing); end else `ASSERT(o_err); end else if ($past(i_stb && w_misalignment_err)) begin `ASSERT(o_err); end else if (!$past(pending_err)) `ASSERT(!o_err); //else if ($past(misaligned)) //`ASSERT(o_err); end",
            "always @(*) if (misaligned_response_pending || misaligned_aw_request || misaligned_read || misaligned_request) assert(!axlock);",
            "always @(*) if (o_busy && misaligned_response_pending) `ASSERT(!pending_err);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(!i_cpu_reset))&&($past(i_stb))) begin // On a write, assert o_wb_we should be true assert($past(i_op[0] && !o_err && !w_misalignment_err) == (M_AXI_AWVALID && M_AXI_WVALID)); end",
            "always @(*) if (axlock && M_AXI_BREADY) assert(o_w",
            "reg [3:0] == 4'hf); // }}} //////////////////////////////////////////////////////////////////////// // // OPT_LOWPOWER / Zero on idle checks // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_LOWPOWER) begin genvar fb;",
            "always @(*) if (!M_AXI_AWVALID && !M_AXI_ARVALID) `ASSERT(M_AXI_AWADDR == 0);",
            "always @(*) if (!M_AXI_WVALID) begin `ASSERT(M_AXI_WDATA == 0); `ASSERT(M_AXI_WSTRB == 0); `ASSERT(next_wdata == 0); `ASSERT(next_wstrb == 0); end",
            "always @(*) if (S_AXI_ARESETN && !o_valid) `ASSERT(o_result == 0);",
            "always @(*) if (S_AXI_ARESETN && (OPT_ALIGNMENT_ERR || !M_AXI_RREADY || misaligned_response_pending)) `ASSERT(last_result == 0); for(fb=0; fb<C_AXI_DATA_WIDTH/8; fb=fb+1) begin",
            "always @(*) if (S_AXI_ARESETN && !M_AXI_WSTRB[fb]) `ASSERT(M_AXI_WDATA[fb*8 +: 8] == 8'h0); end",
            "always @(*) cover(M_AXI_WVALID && M_AXI_WDATA[31:24] != 8'h00); // always @(*) // if (!o_valid) // `ASSERT(o_result == 0); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Contract properties // {{{ //////////////////////////////////////////////////////////////////////// // // wire [3:0] cpu_outstanding;",
            "reg f_done;",
            "wire [4:0] f_last_",
            "reg , f_addr_",
            "reg ; (* anyseq *)",
            "reg [4:0] f_a",
            "reg ;",
            "initial f_done = 1'b0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN || r_flushing || i_cpu_reset) f_done <= 1'b0; else begin f_done <= (M_AXI_RVALID && !M_AXI_RRESP[1] || M_AXI_BVALID && !M_AXI_BRESP[1]); if (pending_err || misaligned_response_pending) f_done <= 0; end fmem #( // {{{ .OPT_LOCK(OPT_LOCK), .OPT_AXI_LOCK(1) // }}} ) fcheck( // {{{ .i_clk(S_AXI_ACLK), .i_sys_reset(!S_AXI_ARESETN), .i_cpu_reset(i_cpu_reset), .i_stb(i_stb), .i_pipe_stalled(o_busy), .i_clear_cache(1'b0), .i_lock(i_lock), .i_op(i_op), .i_addr(i_addr), .i_data(i_data), .i_o",
            "reg (i_o",
            "reg ), .i_busy(o_busy), .i_a",
            "reg (f_a",
            "reg ), .i_rdbusy(o_rdbusy), .i_valid(o_valid), .i_done(f_done), .i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_result), .f_outstanding(cpu_outstanding), .f_pc(f_pc), .f_gie(f_gie), .f_read_cycle(f_read_cycle), .f_axi_write_cycle(f_exwrite_cycle), .f_last_",
            "reg (f_last_",
            "reg ), .f_addr_",
            "reg (f_addr_",
            "reg ) // }}} );",
            "always @(*) if (r_flushing) begin `ASSERT(cpu_outstanding == 0); end else `ASSERT(cpu_outstanding == (o_busy ? 1:0) + ((f_done || o_err) ? 1 : 0));",
            "always @(*) if (o_rdbusy && M_AXI_BREADY) begin assert(f_exwrite_cycle); assert(axlock); end else if (M_AXI_RREADY) assert(!f_exwrite_cycle);",
            "always @(*) if (M_AXI_BREADY && (M_AXI_AWLOCK || f_exwrite_cycle || axlock)) begin assert(!pending_err); assert(!misaligned_response_pending); assert(M_AXI_AWLOCK && f_exwrite_cycle && axlock); if (f_active_lock) assert((M_AXI_AWVALID || M_AXI_WVALID) || faxi_ex_state == 2'b11); end else assert(faxi_ex_state != 2'b11);",
            "always @(*) if (M_AXI_RREADY && !r_flushing) assert(f_last_",
            "reg == o_w",
            "reg );",
            "always @(*) if (f_pc || (axlock && M_AXI_BREADY)) begin assert(o_w",
            "reg [3:1] == 3'h7); end else if (o_rdbusy) assert(o_w",
            "reg [3:1] != 3'h7);",
            "always @(*) if (o_busy) assert(o_w",
            "reg [4] == f_gie);",
            "always @(*) if (M_AXI_RREADY) begin assert(f_read_cycle || r_flushing); end else if (M_AXI_BREADY) assert(!f_read_cycle);",
            "always @(*) if (!OPT_LOCK) assert(!axlock);",
            "always @(posedge S_AXI_ACLK) if (S_AXI_ARESETN && $past(S_AXI_ARESETN) && !$past(i_cpu_reset) && $past(M_AXI_BVALID && axlock)) begin if ($past(M_AXI_BRESP == OKAY)) begin assert(o_valid); assert(o_w",
            "reg [3:0] == 4'hf); assert(o_result == {{(32-AW){1'b0}}, $past(r_pc)}); end else if ($past(M_AXI_BRESP == EXOKAY)) begin assert(!o_valid); assert(!o_err); assert(!o_busy); assert(!o_rdbusy); end else if ($past(M_AXI_BRESP[1])) assert(o_err); end // ???? Not written yet // // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // reg [3:0] cvr_writes, cvr_reads;",
            "initial cvr_writes = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) cvr_writes <= 0; else if (M_AXI_BVALID&& !misaligned_response_pending && !cvr_writes[3]) cvr_writes <= cvr_writes + 1;",
            "initial cvr_reads = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) cvr_reads <= 0; else if (M_AXI_RVALID && !misaligned_response_pending && !cvr_reads[3]) cvr_reads <= cvr_reads + 1; // Cover a write response",
            "always @(posedge i_clk) cover(M_AXI_BVALID && !M_AXI_BRESP[1]);",
            "always @(posedge i_clk) cover(M_AXI_BVALID && M_AXI_BRESP[1]);",
            "always @(posedge i_clk) cover(M_AXI_RVALID && !M_AXI_RRESP[1]);",
            "always @(posedge i_clk) cover(M_AXI_RVALID && M_AXI_RRESP[1]);",
            "always @(posedge i_clk) cover(cvr_writes > 3);",
            "always @(posedge i_clk) cover(cvr_reads > 3); generate if (OPT_LOCK) begin : COVER_LOCK",
            "always @(posedge i_clk) cover(axlock);",
            "always @(posedge i_clk) cover(o_valid && $past(axlock && M_AXI_RVALID));",
            "always @(posedge i_clk) cover(!o_valid && !o_err && faxi_ex_state == 2'b10);",
            "always @(posedge i_clk) cover(i_stb && i_op[0] && i_lock && faxi_ex_state == 2'b10);",
            "always @(posedge i_clk) cover(i_stb && i_op[0] && i_lock && faxi_ex_state == 2'b10 && !w_misalignment_err);",
            "always @(posedge i_clk) if (S_AXI_ARESETN && $past(S_AXI_ARESETN) && !i_cpu_reset && !$past(i_cpu_reset)) cover($past(i_stb && i_op[0] && i_lock && faxi_ex_state == 2'b10 && !w_misalignment_err));",
            "always @(posedge i_clk) cover(M_AXI_AWVALID && M_AXI_AWLOCK);",
            "always @(posedge i_clk) cover(M_AXI_BVALID && axlock);",
            "always @(posedge i_clk) cover(o_valid && $past(axlock && M_AXI_BVALID)); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // \"Careless\" assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (i_stb && i_op[0] && i_lock) begin assume(i_addr == f_exlock_addr); assume(faxi_ex_state == 2'b10); if (SWAP_WSTRB) begin assert(f_exlock_size == DSZ); end else casez(i_op[2:1]) 2'b0?: assume(f_exlock_size == 3'b010); // Word 2'b10: assume(f_exlock_size == 3'b001); // Half-word 2'b11: assume(f_exlock_size == 3'b000); // Byte endcase end",
            "always @(*) if (faxi_ex_state == 2'b10) begin assert(f_exlock_addr == faxi_exreq_addr); assert(f_exlock_len == faxi_exreq_len); assert(f_exlock_size == faxi_exreq_size); assert(f_exlock_burst == faxi_exreq_burst); end",
            "always @(*) if (i_stb && i_lock) assume(!i_cpu_reset);",
            "always @(posedge i_clk) if ($past(i_cpu_reset)) assume((faxi_ex_state == 2'b00) || (faxi_ex_state == 2'b01)); // }}} `endif // }}}",
            "endmodule // yosys -p 'read -sv axiops.v ; synth_xilinx -flatten -top axiops' // // Usage (from yosys): // (!LOWPOWER) LOWPOWER,AW=DW=32,LOCK,!ALGNERR // Cells 932 1076 // FDRE,FDSE 216 217 // LUT1 6 4 // LUT2 53 32 // LUT3 57 38 // LUT4 54 76 // LUT5 67 92 // LUT6 70 123 // MUX7 25 37 // MUX8 5 1 // Estimated LCs: 248 329 // //"
        ]
    },
    {
        "file_name": "axilops.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axilops.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: axilops.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A memory unit to support a CPU based upon AXI-lite. This is // a very basic memory unit designed to be low on",
            "logic and yet // to still support a lot of options. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2020-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module axilops #( // {{{",
            "parameter ADDRESS_WIDTH=30, parameter C_AXI_ADDR_WIDTH = ADDRESS_WIDTH, parameter C_AXI_DATA_WIDTH = 32, // // SWAP_ENDIANNESS // {{{ // The ZipCPU was designed to be a big endian machine. With // no other adjustments, this design will make the ZipCPU // *little* endian, for the simple reason that the AXI bus is // a little endian bus. However, if SWAP_ENDIANNESS is set, // the bytes within 32-bit words on the AXI bus will be swapped. // This will return the CPU to being a big endian CPU on a // little endian bus. It will also break any design that // assumes the bus is presented to it in its proper order. // Simple things like counters or interrupt controllers will // therefore cease to work with this option unless they also // swap the endianness of the words they are given.",
            "parameter [0:0] SWAP_ENDIANNESS = 1'b0, // }}} // SWAP_WSTRB // {{{ // SWAP_WSTRB represents a second attempt to fix the endianness // issue. It is incompatible with the SWAP_ENDIANNESS option // above. If SWAP_WSTRB is set, then half words and words will // be placed on the bus in little endian order, but at big // endian addresses. Words written to the bus will be written // in little endian order. Halfwords written to the bus at // address 2 will be written to address 0, halfwords written to // address 0 will be written to address 2. Bytes written to the // but at address 3 will be written to address 0, address 2 // will be written to address 1, address 1 to address 2, and // address 3 to address 0. // // This may just be a half baked attempt to solve this problem, // since it will fail if you ever trie to access bytes or // halfwords at other than their intended widths.",
            "parameter [0:0] SWAP_WSTRB = 1'b0, // }}} // OPT_SIGN_EXTEND // {{{ // Some CPU's want memory accesses to be sign extended upon // return. The ZipCPU is not one of those CPU's. However, // since it's fairly easy to do so, we'll implement this",
            "logic // if ever OPT_SIGN_EXTEND is true so you can see how it would // be done if necessary.",
            "parameter [0:0] OPT_SIGN_EXTEND = 1'b0, // }}} // OPT_ALIGNMENT_ERR // {{{ // If set, OPT_ALIGNMENT_ERR will generate an alignment error // on any attempt to write to or read from an unaligned word. // If not set, unaligned reads (or writes) will be expanded into // pairs so as to still accomplish the action requested. The // bus does not guarantee protection, however, that these two // writes or two reads will proceed uninterrupted. Since // unaligned writes and unaligned reads are no longer // guaranteed to be atomic by the AXI bus, it is possible that // any unaligned operations might yield an incoherent result.",
            "parameter [0:0] OPT_ALIGNMENT_ERR = 1'b1, // }}} // OPT_LOWPOWER // {{{ // If set, the design will use extra",
            "logic to guarantee that any // unused",
            "reg isters are kept at zero until they are used. This // will help to guarantee the design (ideally) has fewer // transitions and therefore uses lower power.",
            "parameter [0:0] OPT_LOWPOWER = 1'b0, // }}}",
            "localparam AW = C_AXI_ADDR_WIDTH, localparam DW = C_AXI_DATA_WIDTH, localparam AXILSB = $clog2(C_AXI_DATA_WIDTH/8) // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, input wire i_cpu_reset, // // CPU interface // {{{",
            "input wire i_stb, input wire i_lock, input wire [2:0] i_op, input wire [AW-1:0] i_addr, input wire [31:0] i_data, input wire [4:0] i_o",
            "reg , output reg o_busy, output reg o_rdbusy, output reg o_valid, output reg o_err, output reg [4:0] o_w",
            "reg , output reg [31:0] o_result, // }}} // AXI-Lite bus interface // // Writes // {{{",
            "output reg M_AXI_AWVALID, input wire M_AXI_AWREADY, output reg [AW-1:0] M_AXI_AWADDR, // verilator coverage_off",
            "output wire [2:0] M_AXI_AWPROT, // verilator coverage_on // output reg M_AXI_WVALID, input wire M_AXI_WREADY, output reg [DW-1:0] M_AXI_WDATA, output reg [DW/8-1:0] M_AXI_WSTRB, // input wire M_AXI_BVALID, output reg M_AXI_BREADY, input wire [1:0] M_AXI_BRESP, // }}} // Reads // {{{",
            "output reg M_AXI_ARVALID, input wire M_AXI_ARREADY, output reg [AW-1:0] M_AXI_ARADDR, // verilator coverage_off",
            "output wire [2:0] M_AXI_ARPROT, // verilator coverage_on // input wire M_AXI_RVALID, output reg M_AXI_RREADY, input wire [DW-1:0] M_AXI_RDATA, input wire [1:0] M_AXI_RRESP // }}} // }}} ); // Declarations // {{{",
            "wire i_clk = S_AXI_ACLK; // wire i_reset = !S_AXI_ARESETN;",
            "reg w_misaligned, w_misalignment_err;",
            "wire misaligned_request, misaligned_aw_request, misaligned_response_pending, pending_err, misaligned_read;",
            "reg r_flushing;",
            "reg [AXILSB+1:0] r_op;",
            "reg [DW-1:0] next_wdata;",
            "reg [DW/8-1:0] next_wstrb;",
            "reg [DW-1:0] last_result; // reg [31:0] endian_swapped_wdata; // reg [31:0] endian_swapped_result;",
            "reg [2*DW/8-1:0] shifted_wstrb_word, shifted_wstrb_halfword, shifted_wstrb_byte;",
            "reg [2*DW/8-1:0] swapped_wstrb_word, swapped_wstrb_halfword, swapped_wstrb_byte;",
            "reg [DW-1:0] axi_wdata;",
            "reg [DW/8-1:0] axi_wstrb;",
            "reg [AXILSB-1:0] swapaddr;",
            "wire [DW-1:0] endian_swapped_rdata;",
            "reg [31:0] pre_result;",
            "reg [2*DW-1:0] wide_return; // }}} // xVALID, and xREADY // {{{",
            "initial M_AXI_AWVALID = 1'b0;",
            "initial M_AXI_WVALID = 1'b0;",
            "initial M_AXI_ARVALID = 1'b0;",
            "initial M_AXI_BREADY = 1'b0;",
            "initial M_AXI_RREADY = 1'b0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) begin // {{{ M_AXI_AWVALID <= 1'b0; M_AXI_WVALID <= 1'b0; M_AXI_ARVALID <= 1'b0; M_AXI_BREADY <= 1'b0; M_AXI_RREADY <= 1'b0; // }}} end else if (M_AXI_BREADY || M_AXI_RREADY) begin // Something is outstanding // {{{ if (M_AXI_AWREADY) M_AXI_AWVALID <= M_AXI_AWVALID && misaligned_aw_request; if (M_AXI_WREADY) M_AXI_WVALID <= M_AXI_WVALID && misaligned_request; if (M_AXI_ARREADY) M_AXI_ARVALID <= M_AXI_ARVALID && misaligned_request; if ((M_AXI_BVALID || M_AXI_RVALID) && !misaligned_response_pending) begin M_AXI_BREADY <= 1'b0; M_AXI_RREADY <= 1'b0; end // }}} end else begin // New memory operation // {{{ // Initiate a request M_AXI_AWVALID <= i_op[0]; // Write request M_AXI_WVALID <= i_op[0]; // Write request M_AXI_ARVALID <= !i_op[0]; // Read request // Set BREADY or RREADY to accept the response. These will // remain ready until the response is returned. M_AXI_BREADY <= i_op[0]; M_AXI_RREADY <= !i_op[0]; if (i_cpu_reset || o_err || !i_stb || w_misalignment_err) begin M_AXI_AWVALID <= 0; M_AXI_WVALID <= 0; M_AXI_ARVALID <= 0; M_AXI_BREADY <= 0; M_AXI_RREADY <= 0; end // }}} end // }}} // r_flushing // {{{",
            "initial r_flushing = 1'b0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) // If everything is reset, then we don't need to worry about // or wait for any pending returns--they'll be canceled by the // global reset. r_flushing <= 1'b0; else if (M_AXI_BREADY || M_AXI_RREADY) begin if (i_cpu_reset) // If only the CPU is reset, however, we have a problem. // The bus hasn't been reset, and so it is still active. // We can't respond to any new requests from the CPU // until we flush any transactions that are currently // active. r_flushing <= 1'b1; if (M_AXI_BVALID || M_AXI_RVALID) // A request just came back, therefore we can clear // r_flushing r_flushing <= 1'b0; if (misaligned_response_pending) // ... unless we're in the middle of a misaligned // request. In that case, there will be a second // return that we still need to wait for. This request, // though, will clear misaligned_response_pending. r_flushing <= r_flushing || i_cpu_reset; end else // If nothing is active, we don't care about the CPU reset. // Flushing just stays at zero. r_flushing <= 1'b0; // }}} // M_AXI_AxADDR // {{{",
            "initial M_AXI_AWADDR = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN && OPT_LOWPOWER) M_AXI_AWADDR <= 0; else if (!M_AXI_BREADY && !M_AXI_RREADY) begin // Initial address // {{{ M_AXI_AWADDR <= i_addr; if (OPT_LOWPOWER && (i_cpu_reset || o_err || !i_stb || w_misalignment_err)) M_AXI_AWADDR <= 0; if (SWAP_ENDIANNESS || SWAP_WSTRB) begin // When adjusting endianness, reads (or writes) are // always full words. This is important since the // the bytes at issues may (or may not) be in their // expected locations if (OPT_ALIGNMENT_ERR) M_AXI_AWADDR[AXILSB-1:0] <= 0; else M_AXI_AWADDR[1:0] <= 0; end // }}} end else if ((M_AXI_AWVALID && M_AXI_AWREADY) ||(M_AXI_ARVALID && M_AXI_ARREADY)) begin // Subsequent addresses // {{{ M_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:AXILSB] <= M_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:AXILSB] + 1; M_AXI_AWADDR[AXILSB-1:0] <= 0; if (OPT_LOWPOWER && ((M_AXI_RREADY && !misaligned_request) || (M_AXI_BREADY && !misaligned_aw_request))) M_AXI_AWADDR <= 0; // }}} end",
            "always @(*) M_AXI_ARADDR = M_AXI_AWADDR; // }}} // AxPROT // {{{",
            "localparam [2:0] AXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS = 3'h0;",
            "localparam [2:0] OPT_PROT=AXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS;",
            "assign M_AXI_AWPROT = OPT_PROT;",
            "assign M_AXI_ARPROT = OPT_PROT; // }}} // shifted_wstrb_* // {{{ generate if (SWAP_WSTRB) begin : BIG_ENDIAN_WSTRB",
            "always @(*) shifted_wstrb_word = { 4'b1111, {(2*DW/8-4){1'b0}} } >> i_addr[AXILSB-1:0];",
            "always @(*) shifted_wstrb_halfword = { 2'b11, {(2*DW/8-2){1'b0}} } >> i_addr[AXILSB-1:0];",
            "always @(*) shifted_wstrb_byte = { 1'b1, {(2*DW/8-1){1'b0}} } >> i_addr[AXILSB-1:0]; end else begin : NORMAL_SHIFTED_WSTRB",
            "always @(*) shifted_wstrb_word = { {(2*DW/8-4){1'b0}}, 4'b1111} << i_addr[AXILSB-1:0];",
            "always @(*) shifted_wstrb_halfword = { {(2*DW/8-4){1'b0}}, 4'b0011} << i_addr[AXILSB-1:0];",
            "always @(*) shifted_wstrb_byte = { {(2*DW/8-4){1'b0}}, 4'b0001} << i_addr[AXILSB-1:0]; end endgenerate // }}} // Swapping WSTRB bits // {{{ generate if (SWAP_ENDIANNESS) begin : SWAPPING_ENDIANNESS // {{{ genvar gw, gb; for(gw=0; gw<2*DW/32; gw=gw+1) begin : FOREACH_32B_WORD for(gb=0; gb<32/8; gb=gb+1) begin : FOREACH_BYTE",
            "always @(*) begin swapped_wstrb_word[gw*4+gb] = shifted_wstrb_word[gw*4+(3-gb)]; swapped_wstrb_halfword[gw*4+gb] = shifted_wstrb_halfword[gw*4+(3-gb)]; swapped_wstrb_byte[gw*4+gb] = shifted_wstrb_byte[gw*4+(3-gb)]; end end end // }}} end else begin : KEEP_WSTRB // {{{",
            "always @(*) swapped_wstrb_word = shifted_wstrb_word;",
            "always @(*) swapped_wstrb_halfword = shifted_wstrb_halfword;",
            "always @(*) swapped_wstrb_byte = shifted_wstrb_byte; // }}} end endgenerate // }}} // wdata, wstrb // {{{",
            "always @(*) swapaddr = i_addr[AXILSB-1:0];",
            "initial axi_wdata = 0;",
            "initial axi_wstrb = 0;",
            "initial next_wdata = 0;",
            "initial next_wstrb = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && !S_AXI_ARESETN) begin // {{{ axi_wdata <= 0; axi_wstrb <= 0; next_wdata <= 0; next_wstrb <= 0; r_op <= 0; // }}} end else if (i_stb) begin // {{{ if (SWAP_WSTRB) begin casez(i_op[2:1]) 2'b10: { axi_wdata, next_wdata } <= { i_data[15:0], {(2*C_AXI_DATA_WIDTH-16){1'b0}} } >> (8*swapaddr); 2'b11: { axi_wdata, next_wdata } <= { i_data[7:0], {(2*C_AXI_DATA_WIDTH-8){1'b0}} } >> (8*swapaddr); default: { axi_wdata, next_wdata } <= { i_data, {(2*C_AXI_DATA_WIDTH-32){1'b0}} } >> (8*swapaddr); endcase end else begin casez(i_op[2:1]) 2'b10: { next_wdata, axi_wdata } <= { {(2*C_AXI_DATA_WIDTH-16){1'b0}}, i_data[15:0] } << (8*swapaddr); 2'b11: { next_wdata, axi_wdata } <= { {(2*C_AXI_DATA_WIDTH-8){1'b0}}, i_data[7:0] } << (8*swapaddr); default: { next_wdata, axi_wdata } <= { {(2*C_AXI_DATA_WIDTH-32){1'b0}}, i_data } << (8*swapaddr); endcase end // next_wstrb, axi_wstrb // {{{ if (SWAP_WSTRB) begin casez(i_op[2:1]) 2'b0?: { axi_wstrb, next_wstrb } <= swapped_wstrb_word; 2'b10: { axi_wstrb, next_wstrb } <= swapped_wstrb_halfword; 2'b11: { axi_wstrb, next_wstrb } <= swapped_wstrb_byte; endcase end else begin casez(i_op[2:1]) 2'b0?: { next_wstrb, axi_wstrb } <= swapped_wstrb_word; 2'b10: { next_wstrb, axi_wstrb } <= swapped_wstrb_halfword; 2'b11: { next_wstrb, axi_wstrb } <= swapped_wstrb_byte; endcase end // }}} r_op <= { i_op[2:1] , i_addr[AXILSB-1:0] }; // On a read set everything to zero but only if OPT_LOWPOWER // is set // {{{ if (OPT_LOWPOWER && !i_op[0]) { next_wstrb, next_wdata, axi_wstrb, axi_wdata } <= 0; if (OPT_ALIGNMENT_ERR) { next_wstrb, next_wdata } <= 0; if (OPT_LOWPOWER) begin if (w_misalignment_err) { axi_wdata, axi_wstrb, r_op } <= 0; if (o_err || i_cpu_reset) { next_wdata, next_wstrb, axi_wdata, axi_wstrb, r_op } <= 0; end // }}} // }}} end else if ((misaligned_request || !OPT_LOWPOWER) && M_AXI_WREADY) begin // {{{ axi_wdata <= next_wdata; axi_wstrb <= next_wstrb; if (OPT_LOWPOWER) { next_wdata, next_wstrb } <= 0; // }}} end else if (OPT_LOWPOWER && M_AXI_WREADY) begin // {{{ axi_wdata <= 0; axi_wstrb <= 0; // }}} end // }}} // M_AXI_WDATA, M_AXI_WSTRB // {{{ generate if (SWAP_ENDIANNESS) begin : SWAP_WRITE_DATA_STRB // {{{ genvar gw, gb; for(gw=0; gw<C_AXI_DATA_WIDTH/32; gw=gw+1) for(gb=0; gb<32/8; gb=gb+1)",
            "always @(*) begin M_AXI_WDATA[32*gw + 8*gb +: 8] = axi_wdata[32*gw+8*(3-gb) +: 8]; M_AXI_WSTRB[4*gw + gb] = axi_wstrb[4*gw+(3-gb)]; end // }}} end else begin : KEEP_WRITE_DATA_STRB // {{{",
            "always @(*) { M_AXI_WSTRB, M_AXI_WDATA } = { axi_wstrb, axi_wdata }; // }}} end endgenerate // }}} // w_misaligned // {{{",
            "always @(*) casez(i_op[2:1]) // Full word 2'b0?: w_misaligned = ((i_addr[AXILSB-1:0]+3) >= (1<<AXILSB)); // Half word 2'b10: w_misaligned = ((i_addr[AXILSB-1:0]+1) >= (1<<AXILSB)); // Bytes are",
            "always aligned 2'b11: w_misaligned = 1'b0; endcase // }}} // w_misalignment_err // {{{",
            "always @(*) begin w_misalignment_err = OPT_ALIGNMENT_ERR && w_misaligned; end // }}} // misaligned_[aw_|]request, pending_err, misaligned_response_pending // {{{ generate if (OPT_ALIGNMENT_ERR) begin : GEN_ALIGNMENT_ERR // {{{",
            "assign misaligned_request = 1'b0;",
            "assign misaligned_aw_request = 1'b0;",
            "assign misaligned_response_pending = 1'b0;",
            "assign misaligned_read = 1'b0;",
            "assign pending_err = 1'b0; // }}} end else begin : GEN_REALIGNMENT // {{{",
            "reg r_misaligned_request, r_misaligned_aw_request, r_misaligned_response_pending, r_misaligned_read, r_pending_err; // misaligned_request // {{{",
            "initial r_misaligned_request = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) r_misaligned_request <= 0; else if (i_stb && !o_err && !i_cpu_reset) r_misaligned_request <= w_misaligned && !w_misalignment_err; else if ((M_AXI_WVALID && M_AXI_WREADY) || (M_AXI_ARVALID && M_AXI_ARREADY)) r_misaligned_request <= 1'b0;",
            "assign misaligned_request = r_misaligned_request; // }}} // misaligned_aw_request // {{{",
            "initial r_misaligned_aw_request = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) r_misaligned_aw_request <= 0; else if (i_stb && !o_err && !i_cpu_reset) r_misaligned_aw_request <= w_misaligned && i_op[0] && !w_misalignment_err; else if (M_AXI_AWREADY) r_misaligned_aw_request <= 1'b0;",
            "assign misaligned_aw_request = r_misaligned_aw_request; // }}} // misaligned_response_pending // {{{",
            "initial r_misaligned_response_pending = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) r_misaligned_response_pending <= 0; else if (i_stb && !o_err && !i_cpu_reset) r_misaligned_response_pending <= w_misaligned && !w_misalignment_err; else if (M_AXI_BVALID || M_AXI_RVALID) r_misaligned_response_pending <= 1'b0;",
            "assign misaligned_response_pending = r_misaligned_response_pending; // }}} // misaligned_read // {{{",
            "initial r_misaligned_read = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) r_misaligned_read <= 0; else if (i_stb && !o_err && !i_cpu_reset) r_misaligned_read <= w_misaligned && !i_op[0] && !w_misalignment_err; else if (M_AXI_RVALID) r_misaligned_read <= (misaligned_response_pending);",
            "assign misaligned_read = r_misaligned_read; // }}} // pending_err // {{{",
            "initial r_pending_err = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || (!M_AXI_BREADY && !M_AXI_RREADY) || r_flushing) r_pending_err <= 1'b0; else if ((M_AXI_BVALID && M_AXI_BRESP[1]) || (M_AXI_RVALID && M_AXI_RRESP[1])) r_pending_err <= 1'b1;",
            "assign pending_err = r_pending_err; // }}} // }}} end endgenerate // }}} // o_valid // {{{",
            "initial o_valid = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || r_flushing) o_valid <= 1'b0; else o_valid <= M_AXI_RVALID && !M_AXI_RRESP[1] && !pending_err && !misaligned_response_pending; // }}} // o_err // {{{",
            "initial o_err = 1'b0;",
            "always @(posedge i_clk) if (r_flushing || i_cpu_reset || o_err) o_err <= 1'b0; else if (i_stb && w_misalignment_err) o_err <= 1'b1; else if ((M_AXI_BVALID || M_AXI_RVALID) && !misaligned_response_pending) o_err <= (M_AXI_BVALID && M_AXI_BRESP[1]) || (M_AXI_RVALID && M_AXI_RRESP[1]) || pending_err; else o_err <= 1'b0; // }}} // o_busy, o_rdbusy // {{{",
            "always @(*) begin o_busy = M_AXI_BREADY || M_AXI_RREADY; o_rdbusy = M_AXI_RREADY && !r_flushing; end // }}} // o_w",
            "reg // {{{",
            "always @(posedge i_clk) if (OPT_LOWPOWER && (!S_AXI_ARESETN || i_cpu_reset || o_err || (i_stb && w_misalignment_err))) o_w",
            "reg <= 0; else if (i_stb && (!OPT_LOWPOWER || !i_op[0])) o_w",
            "reg <= i_o",
            "reg ; else if (OPT_LOWPOWER && (o_valid || o_err)) o_w",
            "reg <= 0; // }}} // endian_swapped_rdata // {{{ generate if (SWAP_ENDIANNESS) begin : SWAP_RDATA_ENDIANNESS genvar gw, gb; for(gw=0; gw<C_AXI_DATA_WIDTH/32; gw=gw+1) for(gb=0; gb<32/8; gb=gb+1)",
            "assign endian_swapped_rdata[gw*32+gb*8 +: 8] = M_AXI_RDATA[gw*32+(3-gb)*8 +: 8]; end else begin : KEEP_RDATA",
            "assign endian_swapped_rdata = M_AXI_RDATA; end endgenerate // }}} // pre_result // {{{ // The purpose of the pre-result is to guarantee that the synthesis // tool knows we want a shift of the full 2*DW width.",
            "always @(*) begin if (SWAP_WSTRB) begin if (misaligned_read && !OPT_ALIGNMENT_ERR) wide_return={ last_result, endian_swapped_rdata } << (8*r_op[AXILSB-1:0]); else wide_return = { endian_swapped_rdata, {(DW){1'b0}} } << (8*r_op[AXILSB-1:0]); end else begin if (misaligned_read && !OPT_ALIGNMENT_ERR) wide_return={ endian_swapped_rdata, last_result } >> (8*r_op[AXILSB-1:0]); else wide_return = { {(DW){1'b0}}, endian_swapped_rdata } >> (8*r_op[AXILSB-1:0]); end if (OPT_LOWPOWER && (!M_AXI_RVALID || M_AXI_RRESP[1])) wide_return = 0; end",
            "always @(*) begin if (SWAP_WSTRB) begin pre_result = 0; casez(r_op[AXILSB +: 2]) 2'b10: pre_result[15:0] = wide_return[(2*DW)-1:(2*DW)-16]; 2'b11: pre_result[7:0] = wide_return[(2*DW)-1:(2*DW)-8]; default: pre_result[31:0] = wide_return[(2*DW-1):(2*DW-32)]; endcase end else pre_result = wide_return[31:0]; end // }}} // last_result, o_result // {{{",
            "always @(posedge i_clk) if (OPT_LOWPOWER &&(!M_AXI_RREADY || !S_AXI_ARESETN || r_flushing || i_cpu_reset)) { last_result, o_result } <= 0; else begin // {{{ if (OPT_LOWPOWER) o_result <= 0; if (M_AXI_RVALID) begin // {{{ if (OPT_LOWPOWER && (M_AXI_RRESP[1] || !misaligned_response_pending)) last_result <= 0; else last_result <= endian_swapped_rdata; o_result <= pre_result[31:0]; if (OPT_SIGN_EXTEND) begin // {{{ // verilator coverage_off // Optionally sign extend the return result. // ... would violate ZipCPU ISA casez(r_op[AXILSB +: 2]) 2'b10: o_result[31:16] <= {(16){pre_result[15]}}; 2'b11: o_result[31: 8] <= {(24){pre_result[7]}}; default: begin end endcase // verilator coverage_on // }}} end else begin // Fill unused return bits with zeros casez(r_op[AXILSB +: 2]) 2'b10: o_result[31:16] <= 0; 2'b11: o_result[31: 8] <= 0; default: begin end endcase end if (OPT_LOWPOWER && M_AXI_RRESP[1]) o_result <= 0; // }}} end if (OPT_ALIGNMENT_ERR) last_result <= 0; if (OPT_LOWPOWER && (pending_err || misaligned_response_pending)) o_result <= 0; // }}} end // }}} // Make verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_lock, M_AXI_RRESP[0], M_AXI_BRESP[0] }; generate if (SWAP_WSTRB) begin : GEN_UNUSED_SWAP",
            "wire wide_unused; if (SWAP_WSTRB) begin : UNUSED_SWAP_WSTRB",
            "assign wide_unused = &{ 1'b0, wide_return[2*DW-32-1:0] }; end else begin : UNUSED_NO_SWAP",
            "assign wide_unused = &{ 1'b0, wide_return[2*DW-1:32] }; end end endgenerate // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Local declarations // {{{ `define ASSERT assert `ifdef AXILOPS `define ASSUME assume `else `define ASSUME assert `endif",
            "localparam F_LGDEPTH = 2;",
            "reg f_misaligned;",
            "wire [F_LGDEPTH-1:0] faxil_rd_outstanding, faxil_wr_outstanding, faxil_awr_outstanding;",
            "wire f_pc, f_gie, f_read_cycle;",
            "reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid = 1'b1;",
            "always @(*) if (!f_past_valid) `ASSUME(!S_AXI_ARESETN); // }}} //////////////////////////////////////////////////////////////////////// // // Bus property checks // {{{ //////////////////////////////////////////////////////////////////////// // // faxil_master #( // {{{ .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH), .F_OPT_ASSUME_RESET(1'b1), .F_LGDEPTH(F_LGDEPTH) // }}} ) faxil( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // .i_axi_awvalid(M_AXI_AWVALID), .i_axi_awready(M_AXI_AWREADY), .i_axi_awaddr( M_AXI_AWADDR), .i_axi_awprot( M_AXI_AWPROT), // .i_axi_wvalid(M_AXI_WVALID), .i_axi_wready(M_AXI_WREADY), .i_axi_wdata( M_AXI_WDATA), .i_axi_wstrb( M_AXI_WSTRB), // .i_axi_bvalid(M_AXI_BVALID), .i_axi_bready(M_AXI_BREADY), .i_axi_bresp( M_AXI_BRESP), // .i_axi_arvalid(M_AXI_ARVALID), .i_axi_arready(M_AXI_ARREADY), .i_axi_araddr( M_AXI_ARADDR), .i_axi_arprot( M_AXI_ARPROT), // .i_axi_rvalid(M_AXI_RVALID), .i_axi_rready(M_AXI_RREADY), .i_axi_rdata( M_AXI_RDATA), .i_axi_rresp( M_AXI_RRESP), // .f_axi_rd_outstanding(faxil_rd_outstanding), .f_axi_wr_outstanding(faxil_wr_outstanding), .f_axi_awr_outstanding(faxil_awr_outstanding) // }}} );",
            "always @(*) begin if (misaligned_request) `ASSERT(M_AXI_WVALID || M_AXI_ARVALID); if (misaligned_aw_request) `ASSERT(M_AXI_AWVALID); if (!misaligned_response_pending) begin `ASSERT(faxil_awr_outstanding <= (M_AXI_AWVALID ? 0:1)); `ASSERT(faxil_wr_outstanding <= (M_AXI_WVALID ? 0:1)); `ASSERT(faxil_rd_outstanding <= (M_AXI_ARVALID ? 0:1)); `ASSERT(!misaligned_request); `ASSERT(!misaligned_aw_request); end else if (M_AXI_RREADY) `ASSERT(misaligned_read); if (!M_AXI_RREADY) begin `ASSERT(!M_AXI_ARVALID); `ASSERT(faxil_rd_outstanding == 0); // `ASSERT(misaligned_read == 1'b0); end else begin if (misaligned_request) `ASSERT(faxil_rd_outstanding == 0); `ASSERT(faxil_rd_outstanding <= 1 + (misaligned_read ? 1:0)); end if (!M_AXI_BREADY) begin `ASSERT(!M_AXI_AWVALID); `ASSERT(!M_AXI_WVALID); `ASSERT(faxil_awr_outstanding == 0); `ASSERT(faxil_wr_outstanding == 0); end else begin if (misaligned_request) `ASSERT(faxil_wr_outstanding == 0); if (misaligned_aw_request) `ASSERT(faxil_awr_outstanding == 0); `ASSERT(faxil_awr_outstanding <= 2); `ASSERT(faxil_wr_outstanding <= 2); case({misaligned_request, misaligned_aw_request, misaligned_response_pending}) 3'b000: begin `ASSERT(faxil_awr_outstanding<= (M_AXI_BREADY ? 1:0)); `ASSERT(faxil_wr_outstanding <= (M_AXI_BREADY ? 1:0)); end 3'b001: begin `ASSERT(faxil_awr_outstanding<= 1 + (M_AXI_AWVALID ? 0:1)); `ASSERT(faxil_wr_outstanding <= 1 + (M_AXI_WVALID ? 0:1)); end 3'b010: `ASSERT(0); 3'b011: begin `ASSERT(faxil_wr_outstanding<= 1 + (M_AXI_WVALID ? 0:1)); `ASSERT(faxil_awr_outstanding == 0); `ASSERT(M_AXI_AWVALID); end 3'b100: `ASSERT(0); 3'b101: begin `ASSERT(faxil_awr_outstanding<= 1 + (M_AXI_AWVALID ? 0:1)); `ASSERT(faxil_wr_outstanding == 0); `ASSERT(M_AXI_WVALID); end 3'b110: `ASSERT(0); 3'b111: begin `ASSERT(faxil_awr_outstanding == 0); `ASSERT(faxil_wr_outstanding == 0); `ASSERT(M_AXI_AWVALID); `ASSERT(M_AXI_WVALID); end default: begin end endcase end // Rule: Only one of the two xREADY's may be valid, never both `ASSERT(!M_AXI_BREADY || !M_AXI_RREADY); end // f_misaligned // {{{",
            "always @(*) begin f_misaligned = 0; case(r_op[AXILSB +: 2]) 2'b01: f_misaligned = ((r_op[AXILSB-1:0] + 3) >= (1<<AXILSB)); 2'b10: f_misaligned = ((r_op[AXILSB-1:0] + 1) >= (1<<AXILSB)); default: f_misaligned = 0; endcase if (!M_AXI_BREADY && !M_AXI_RREADY) f_misaligned = 0; end // }}}",
            "always @(*) if (!M_AXI_RREADY && !M_AXI_BREADY) begin // {{{ assert(!misaligned_aw_request); assert(!misaligned_request); assert(!misaligned_response_pending); assert(faxil_awr_outstanding == 0); assert(faxil_wr_outstanding == 0); assert(faxil_rd_outstanding == 0); // }}} end else if (f_misaligned) begin // {{{ assert(!OPT_ALIGNMENT_ERR); if (misaligned_aw_request || misaligned_request) begin // {{{ if (misaligned_aw_request) begin assert(faxil_awr_outstanding == 0); end else if (M_AXI_BREADY) begin assert(faxil_awr_outstanding == (M_AXI_AWVALID ? 0:1) + (misaligned_response_pending ? 1:0)); end else assert(faxil_awr_outstanding == 0); if (misaligned_request && M_AXI_BREADY) begin assert(faxil_wr_outstanding == 0); assert(faxil_rd_outstanding == 0); end else if (M_AXI_RREADY) begin assert(faxil_rd_outstanding == (M_AXI_ARVALID ? 0:1) + (!misaligned_request && misaligned_response_pending ? 1:0)); assert(faxil_wr_outstanding == 0); end else begin assert(faxil_wr_outstanding == (M_AXI_WVALID ? 0:1) + (misaligned_response_pending ? 1:0)); assert(faxil_rd_outstanding == 0); end // }}} end else if (M_AXI_BREADY) begin // {{{ assert(faxil_awr_outstanding == (M_AXI_AWVALID ? 0:1) + (misaligned_response_pending ? 1:0)); assert(faxil_wr_outstanding == (M_AXI_WVALID ? 0:1) + (misaligned_response_pending ? 1:0)); // }}} end else begin // Read cycle // {{{ assert(M_AXI_RREADY); assert(faxil_rd_outstanding == (M_AXI_ARVALID ? 0:1) + (misaligned_response_pending ? 1:0)); // }}} end // }}} end else if (M_AXI_BREADY) begin // {{{ assert(!misaligned_aw_request); assert(!misaligned_request); assert(!misaligned_response_pending); assert(!pending_err); assert(faxil_awr_outstanding == (M_AXI_AWVALID ? 0:1)); assert(faxil_wr_outstanding == (M_AXI_WVALID ? 0:1)); assert(faxil_rd_outstanding == 0); assert(!misaligned_read); // }}} end else begin // {{{ assert(M_AXI_RREADY); assert(!misaligned_aw_request); assert(!misaligned_request); assert(!misaligned_response_pending); assert(!misaligned_read); assert(!pending_err); assert(faxil_awr_outstanding == 0); assert(faxil_wr_outstanding == 0); assert(faxil_rd_outstanding == (M_AXI_ARVALID ? 0:1)); // }}} end // }}}",
            "always @(*) if (!o_busy) `ASSERT(!r_flushing); // Following any i_stb request, assuming we are idle, immediately // begin a bus transaction",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_stb && !o_err)) &&(!$past(o_busy))&&($past(!i_cpu_reset))) begin `ASSERT(o_busy || (OPT_ALIGNMENT_ERR && o_err)); end",
            "always @(*) `ASSERT(o_busy == (M_AXI_BREADY || M_AXI_RREADY));",
            "always @(*) `ASSERT(o_rdbusy == (M_AXI_RREADY && !r_flushing));",
            "always @(*) if (o_busy && !misaligned_request && OPT_LOWPOWER) begin assert(next_wdata == 0); assert(next_wstrb == 0); end // If a transaction ends in an error, send o_err on the",
            "output port.",
            "always @(posedge i_clk) if (f_past_valid) begin if ($past(i_cpu_reset || r_flushing || o_err)) begin `ASSERT(!o_err); end else if ($past(M_AXI_BVALID && M_AXI_BRESP[1])) begin if ($past(misaligned_response_pending)) begin `ASSERT((!o_err && pending_err) || r_flushing); end else `ASSERT(o_err); end else if ($past(M_AXI_RVALID && M_AXI_RRESP[1])) begin if ($past(misaligned_response_pending)) begin `ASSERT((!o_err && pending_err) || r_flushing); end else `ASSERT(o_err); end else if (OPT_ALIGNMENT_ERR && $past(i_stb && w_misaligned)) begin `ASSERT(o_err); end else if (!$past(pending_err)) `ASSERT(!o_err); //else if ($past(misaligned)) //`ASSERT(o_err); end",
            "always @(*) if (o_busy && misaligned_response_pending) `ASSERT(!pending_err);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(!i_cpu_reset))&&($past(i_stb))) begin // On a write, assert o_wb_we should be true assert($past(i_op[0] && !o_err && (!OPT_ALIGNMENT_ERR || !w_misaligned)) == (M_AXI_AWVALID && M_AXI_WVALID)); end //////////////////////////////////////////////////////////////////////// // // OPT_LOWPOWER / Zero on idle checks // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_LOWPOWER) begin genvar fb;",
            "always @(*) if (!M_AXI_AWVALID && !M_AXI_ARVALID) `ASSERT(M_AXI_AWADDR == 0);",
            "always @(*) if (!M_AXI_WVALID) begin `ASSERT(M_AXI_WDATA == 0); `ASSERT(M_AXI_WSTRB == 0); `ASSERT(next_wdata == 0); `ASSERT(next_wstrb == 0); end",
            "always @(*) if (S_AXI_ARESETN && !o_valid) `ASSERT(o_result == 0);",
            "always @(*) if (S_AXI_ARESETN && (!o_valid && !o_err) && (!M_AXI_RREADY || r_flushing)) `ASSERT(o_w",
            "reg == 0);",
            "always @(*) if (S_AXI_ARESETN && (OPT_ALIGNMENT_ERR || !M_AXI_RREADY || misaligned_response_pending)) `ASSERT(last_result == 0); for(fb=0; fb<C_AXI_DATA_WIDTH/8; fb=fb+1) begin",
            "always @(*) if (S_AXI_ARESETN && !M_AXI_WSTRB[fb]) `ASSERT(M_AXI_WDATA[fb*8 +: 8] == 8'h0);",
            "always @(*) if (S_AXI_ARESETN && !next_wstrb[fb]) `ASSERT(next_wdata[fb*8 +: 8] == 8'h0); end // always @(*) // if (!o_valid) // `ASSERT(o_result == 0); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Contract properties // {{{ //////////////////////////////////////////////////////////////////////// // // wire [3:0] cpu_outstanding;",
            "reg f_done;",
            "wire [4:0] f_last_",
            "reg , f_addr_",
            "reg ; (* anyseq *)",
            "reg [4:0] f_a",
            "reg ;",
            "initial f_done = 1'b0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN || r_flushing || i_cpu_reset) f_done <= 1'b0; else f_done <= (M_AXI_RVALID && !M_AXI_RRESP[1] || M_AXI_BVALID && !M_AXI_BRESP[1]) && !pending_err && !misaligned_response_pending; fmem fcheck( // {{{ .i_clk(S_AXI_ACLK), .i_sys_reset(!S_AXI_ARESETN), .i_cpu_reset(i_cpu_reset), .i_stb(i_stb), .i_pipe_stalled(o_busy), .i_clear_cache(1'b0), .i_lock(i_lock), .i_op(i_op), .i_addr(i_addr), .i_data(i_data), .i_o",
            "reg (i_o",
            "reg ), .i_busy(o_busy), .i_a",
            "reg (f_a",
            "reg ), .i_rdbusy(o_rdbusy), .i_valid(o_valid), .i_done(f_done), .i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_result), .f_outstanding(cpu_outstanding), .f_pc(f_pc), .f_gie(f_gie), .f_read_cycle(f_read_cycle), .f_last_",
            "reg (f_last_",
            "reg ), .f_addr_",
            "reg (f_addr_",
            "reg ) // }}} );",
            "always @(*) if (r_flushing) begin `ASSERT(cpu_outstanding == 0); end else `ASSERT(cpu_outstanding == (o_busy ? 1:0) + ((f_done || o_err) ? 1 : 0));",
            "always @(*) if (f_pc) begin assert(o_w",
            "reg [3:1] == 3'h7 || (OPT_LOWPOWER && o_err)); end else if (o_rdbusy) assert(o_w",
            "reg [3:1] != 3'h7);",
            "always @(*) if (cpu_outstanding > 0 && (!OPT_LOWPOWER || (f_read_cycle && !o_err))) assert(o_w",
            "reg == f_last_",
            "reg );",
            "always @(*) if (o_busy && (!OPT_LOWPOWER || (M_AXI_RREADY && !r_flushing))) assert(o_w",
            "reg [4] == f_gie);",
            "always @(*) if (M_AXI_RREADY) begin assert(f_read_cycle || r_flushing); end else if (M_AXI_BREADY) assert(!f_read_cycle); // ???? Not written yet // // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // reg [3:0] cvr_writes, cvr_reads;",
            "initial cvr_writes = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) cvr_writes <= 0; else if (M_AXI_BVALID&& !misaligned_response_pending && !cvr_writes[3]) cvr_writes <= cvr_writes + 1;",
            "initial cvr_reads = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) cvr_reads <= 0; else if (M_AXI_RVALID && !misaligned_response_pending && !cvr_reads[3]) cvr_reads <= cvr_reads + 1; // Cover a write response",
            "always @(posedge i_clk) cover(M_AXI_BVALID && !M_AXI_BRESP[1]);",
            "always @(posedge i_clk) cover(M_AXI_BVALID && M_AXI_BRESP[1]);",
            "always @(posedge i_clk) cover(M_AXI_RVALID && !M_AXI_RRESP[1]);",
            "always @(posedge i_clk) cover(M_AXI_RVALID && M_AXI_RRESP[1]);",
            "always @(posedge i_clk) cover(cvr_writes > 3);",
            "always @(posedge i_clk) cover(cvr_reads > 3); // }}} `endif // }}}",
            "endmodule // // // Usage (from yosys): // (BFOR) (!ZOI,ALIGN) (ZOI,ALIGN) (!ZOI,!ALIGN) // Cells 230 226 281 225 // FDRE 114 116 116 116 // LUT2 17 23 76 19 // LUT3 9 23 17 20 // LUT4 15 4 11 14 // LUT5 18 18 7 15 // LUT6 33 18 54 38 // MUX7 16 12 2 // MUX8 8 1 1 // //"
        ]
    },
    {
        "file_name": "div.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/div.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: div.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Provide an Integer divide capability to the Zip CPU. Provides // for both signed and unsigned divide. // // Steps: // i_reset The DIVide unit starts in idle. It can also be placed into an // idle by asserting the reset",
            "input . // // i_wr When i_reset is asserted, a divide begins. On the next clock: // // o_busy is set high so everyone else knows we are at work and they can // wait for us to complete. // // pre_sign is set to true if we need to do a signed divide. In this // case, we take a clock cycle to turn the divide into an unsigned // divide. // // o_quotient, a place to store our result, is",
            "initial ized to all zeros. // // r_dividend is set to the numerator // // r_divisor is set to 2^31 * the denominator (shift left by 31, or add // 31 zeros to the right of the number. // // pre_sign When true (clock cycle after i_wr), a clock cycle is used // to take the absolute value of the various arguments (r_dividend // and r_divisor), and to calculate what sign the",
            "output result // should be. // // // At this point, the divide is has started. The divide works by walking // through every shift of the // // DIVIDEND over the // DIVISOR // // If the DIVISOR is bigger than the dividend, the divisor is shifted // right, and nothing is done to the",
            "output quotient. // // DIVIDEND // DIVISOR // // This repeats, until DIVISOR is less than or equal to the divident, as in // // DIVIDEND // DIVISOR // // At this point, if the DIVISOR is less than the dividend, the // divisor is subtracted from the dividend, and the DIVISOR is again // shifted to the right. Further, a '1' bit gets set in the",
            "output // quotient. // // Once we've done this for 32 clocks, we've accumulated our answer into // the",
            "output quotient, and we can proceed to the next step. If the // result will be signed, the next step negates the quotient, otherwise // it returns the result. // // On the clock when we are done, o_busy is set to false, and o_valid set // to true. (It is a violation of the ZipCPU internal protocol for both // busy and valid to ever be true on the same clock. It is also a // violation for busy to be false with valid true thereafter.) // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module div #(",
            "parameter BW=32, LGBW = 5, parameter [0:0] OPT_LOWPOWER = 1'b0 ) ( // {{{",
            "input wire i_clk, i_reset, // Input",
            "parameter s",
            "input wire i_wr, i_signed, input wire [(BW-1):0] i_numerator, i_denominator, // Output",
            "parameter s",
            "output reg o_busy, o_valid, o_err, output reg [(BW-1):0] o_quotient, output wire [3:0] o_flags // }}} ); // Local declarations // {{{ // r_busy is an internal busy",
            "reg ister. It will clear one clock // before we are valid, so it can't be o_busy ... // reg r_busy;",
            "reg [BW-1:0] r_divisor;",
            "reg [(2*BW-2):0] r_dividend;",
            "wire [(BW):0] diff; // , xdiff[(BW-1):0];",
            "assign diff = r_dividend[2*BW-2:BW-1] - r_divisor;",
            "reg r_sign, pre_sign, r_z, r_c, last_bit;",
            "reg [(LGBW-1):0] r_bit;",
            "reg zero_divisor;",
            "wire w_n; // }}} // r_busy // {{{ // The Divide",
            "logic begins with r_busy. We use r_busy to determine // whether or not the divide is in progress, vs being complete. // Here, we clear r_busy on any reset and set it on i_wr (the request // to do a divide). The divide ends when we are on the last bit, // or equivalently when we discover we are dividing by zero.",
            "initial r_busy = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_busy <= 1'b0; else if (i_wr) r_busy <= 1'b1; else if ((last_bit)||(zero_divisor)) r_busy <= 1'b0; // }}} // o_busy // {{{ // o_busy is very similar to r_busy, save for some key differences. // Primary among them is that o_busy needs to (possibly) be true // for an extra clock after r_busy clears. This would be that extra // clock where we negate the result (assuming a signed divide, and that // the result is supposed to be negative.) Otherwise, the two are // identical.",
            "initial o_busy = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_busy <= 1'b0; else if (i_wr) o_busy <= 1'b1; else if (((last_bit)&&(!r_sign))||(zero_divisor)) o_busy <= 1'b0; else if (!r_busy) o_busy <= 1'b0; // }}} // zero_divisor // {{{",
            "always @(posedge i_clk) if (i_wr) zero_divisor <= (i_denominator == 0); // }}} // o_valid // {{{ // o_valid is part of the ZipCPU protocol. It will be set to true // anytime our answer is valid and may be used by the calling",
            "module . // Indeed, the ZipCPU will halt (and ignore us) once the i_wr has been // set until o_valid gets set. // // Here, we clear o_valid on a reset, and any time we are on the last // bit while busy (provided the sign is zero, or we are dividing by // zero). Since o_valid is self-clearing, we don't need to clear // it on an i_wr signal.",
            "initial o_valid = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(o_valid)) o_valid <= 1'b0; else if ((r_busy)&&(zero_divisor)) o_valid <= 1'b1; else if (r_busy) begin if (last_bit) o_valid <= (!r_sign); end else if (r_sign) begin o_valid <= 1'b1; end else o_valid <= 1'b0; // }}} // o_err // {{{ // Division by zero error reporting. Anytime we detect a zero divisor, // we set our",
            "output error, and then hold it until we are valid and // everything clears.",
            "initial o_err = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_err <= 1'b0; else if ((r_busy)&&(zero_divisor)) o_err <= 1'b1; else o_err <= 1'b0; // }}} // r_bit // {{{ // Keep track of which \"bit\" of our divide we are on. This number // ranges from 31 down to zero. On any write, we set ourselves to // 5'h1f. Otherwise, while we are busy (but not within the pre-sign // adjustment stage), we subtract one from our value on every clock.",
            "initial r_bit = 0;",
            "always @(posedge i_clk) if (i_reset) r_bit <= 0; else if ((r_busy)&&(!pre_sign)) r_bit <= r_bit + 1'b1; else r_bit <= 0; // }}} // last_bit // {{{ // This",
            "logic replaces a lot of",
            "logic that was inside our giant state // machine with ... something simpler. In particular, we'll use this // logic to determine if we are processing our last bit. The only trick // is, this bit needs to be set whenever (r_busy) and (r_bit == -1), // hence we need to set on (r_busy) and (r_bit == -2) so as to be set // when (r_bit == 0).",
            "initial last_bit = 1'b0;",
            "always @(posedge i_clk) if (i_reset) last_bit <= 1'b0; else if (r_busy) last_bit <= (r_bit == {(LGBW){1'b1}}-1'b1); else last_bit <= 1'b0; // }}} // pre_sign // {{{ // This is part of the state machine. pre_sign indicates that we need // a extra clock to take the absolute value of our",
            "input s. It need only // be true for the one clock, and then it must clear itself.",
            "initial pre_sign = 1'b0;",
            "always @(posedge i_clk) if (i_reset) pre_sign <= 1'b0; else pre_sign <= (i_wr)&&(i_signed)&&((i_numerator[BW-1])||(i_denominator[BW-1])); // }}} // r_z // {{{ // As a result of our operation, we need to set the flags. The most // difficult of these is the \"Z\" flag indicating that the result is // zero. Here, we'll use the same",
            "logic that sets the low-order // bit to clear our zero flag, and leave the zero flag set in all // other cases.",
            "always @(posedge i_clk) if (i_wr) r_z <= 1'b1; else if ((r_busy)&&(!pre_sign)&&(!diff[BW])) r_z <= 1'b0; // }}} // r_dividend // {{{ // This is",
            "initial ly the numerator. On a signed divide, it then becomes // the absolute value of the numerator. We'll subtract from this value // the divisor for every",
            "output bit we are looking for--just as with // traditional long division.",
            "always @(posedge i_clk) if (pre_sign) begin // If we are doing a signed divide, then take the // absolute value of the dividend if (r_dividend[BW-1]) begin r_dividend[2*BW-2:0] <= {(2*BW-1){1'b0}}; r_dividend[BW:0] <= -{ 1'b1, r_dividend[BW-1:0] }; end end else if (r_busy) begin r_dividend <= { r_dividend[2*BW-3:0], 1'b0 }; if (!diff[BW]) r_dividend[2*BW-2:BW] <= diff[(BW-2):0]; end else if (!r_busy && (!OPT_LOWPOWER || i_wr)) // Once we are done, and r_busy is no longer high, we'll // always accept new values into our dividend. This // guarantees that, when i_wr is set, the new value // is already set as desired. r_dividend <= { 31'h0, i_numerator }; // }}} // r_divisor // {{{",
            "initial r_divisor = 0;",
            "always @(posedge i_clk) if (i_reset) r_divisor <= 0; else if ((pre_sign)&&(r_busy)) begin if (r_divisor[BW-1]) r_divisor <= -r_divisor; end else if (!r_busy && (!OPT_LOWPOWER || i_wr)) r_divisor <= i_denominator; // }}} // r_sign // {{{ // is a flag for our state machine control(s). r_sign will be set to // true any time we are doing a signed divide and the result must be // negative. In that case, we take a final",
            "logic stage at the end of // the divide to negate the",
            "output . This flag is what tells us we need // to do that. r_busy will be true during the divide, then when r_busy // goes low, r_sign will be checked, then the idle/reset stage will have // been reached. For this reason, we cannot set r_sign unless we are // up to something.",
            "initial r_sign = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_sign <= 1'b0; else if (pre_sign) r_sign <= ((r_divisor[(BW-1)])^(r_dividend[(BW-1)])); else if (r_busy) r_sign <= (r_sign)&&(!zero_divisor); else r_sign <= 1'b0; // }}} // o_quotient // {{{",
            "initial o_quotient = 0;",
            "always @(posedge i_clk) if (i_reset) o_quotient <= 0; else if (r_busy) begin o_quotient <= { o_quotient[(BW-2):0], 1'b0 }; if (!diff[BW]) o_quotient[0] <= 1'b1; end else if (r_sign) o_quotient <= -o_quotient; else o_quotient <= 0; // }}} // r_c // {{{ // Set Carry on an exact divide // Perhaps nothing uses this, but ... well, I suppose we could remove // this",
            "logic eventually, just ... not yet.",
            "initial r_c = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_c <= 1'b0; else r_c <= (r_busy)&&(diff == 0); // }}} // w_n // {{{ // The last flag: Negative. This flag is set assuming that the result // of the divide was negative (i.e., the high order bit is set). This // will also be true of an unsigned divide--if the high order bit is // ever set upon completion. Indeed, you might argue that there's no // logic involved.",
            "assign w_n = o_quotient[(BW-1)]; // }}}",
            "assign o_flags = { 1'b0, w_n, r_c, r_z }; //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; `ifdef DIV `define ASSUME assume `else `define ASSUME assert `endif",
            "initial `ASSUME(i_reset);",
            "always @(*) if (!f_past_valid) `ASSUME(i_reset);",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) begin assert(!o_busy); assert(!o_valid); assert(!o_err); // assert(!r_busy); // assert(!zero_divisor); assert(r_bit==0); assert(!last_bit); assert(!pre_sign); // assert(!r_z); // assert(r_dividend==0); assert(o_quotient==0); assert(!r_c); assert(r_divisor==0); `ASSUME(!i_wr); end",
            "always @(*) if (o_busy) `ASSUME(!i_wr);",
            "always @(*) if (r_busy) assert(o_busy);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(o_busy))&&(!o_busy)) begin assert(o_valid); end // A formal methods section // // This section isn't yet complete. For now, it is just // a description of things I think should be in here ... not // yet a description of what it would take to prove // this divide (yet).",
            "always @(*) if (o_err) assert(o_valid);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_wr))) assert(!pre_sign);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_wr))&&($past(i_signed)) &&(|$past({i_numerator[BW-1],i_denominator[BW-1]}))) assert(pre_sign); // always @(posedge i_clk) // if ((f_past_valid)&&(!$past(pre_sign))) // assert(!r_sign);",
            "reg [BW:0] f_bits_set;",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_wr))) assert(o_busy);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_valid))) assert(!o_valid);",
            "always @(*) if ((o_valid)&&(!o_err)) begin assert(r_z == ((o_quotient == 0)? 1'b1:1'b0)); end else if (o_busy) assert(r_z == (((o_quotient&f_bits_set[BW-1:0]) == 0)? 1'b1: 1'b0));",
            "always @(*) if ((o_valid)&&(!o_err)) assert(w_n == o_quotient[BW-1]);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(r_busy))&&(!$past(i_wr))) assert(!o_busy);",
            "always @(posedge i_clk) assert((!o_busy)||(!o_valid));",
            "always @(*) if(r_busy) assert(o_busy);",
            "always @(posedge i_clk) if (i_reset) f_bits_set <= 0; else if (i_wr) f_bits_set <= 0; else if ((r_busy)&&(!pre_sign)) f_bits_set <= { f_bits_set[BW-1:0], 1'b1 };",
            "always @(posedge i_clk) if (r_busy) assert(((1<<r_bit)-1) == f_bits_set);",
            "always @(*) if ((o_valid)&&(!o_err)) assert((!f_bits_set[BW])&&(&f_bits_set[BW-1:0])); /* always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(r_busy)) &&($past(r_divisor[2*BW-2:BW])==0)) begin if ($past(r_divisor) == 0) begin assert(o_err); end else if ($past(pre_sign)) begin if ($past(r_dividend[BW-1])) assert(r_dividend == -$past(r_dividend)); if ($past(r_divisor[(2*BW-2)])) begin assert(r_divisor[(2*BW-2):(BW-1)] == -$past(r_divisor[(2*BW-2):(BW-1)])); assert(r_divisor[BW-2:0] == 0); end end else begin if (o_quotient[0]) begin assert(r_dividend == $past(diff)); end else assert(r_dividend == $past(r_dividend)); // r_divisor should shift down on every step assert(r_divisor[2*BW-2]==0); assert(r_divisor[2*BW-3:0]==$past(r_divisor[2*BW-2:1])); end if ($past(r_dividend) >= $past(r_divisor[BW-1:0])) begin assert(o_quotient[0]); end else assert(!o_quotient[0]); end */",
            "always @(*) if (r_busy) assert((f_bits_set & r_dividend[BW-1:0])==0);",
            "always @(*) if (r_busy) assert((r_divisor == 0) == zero_divisor); `ifdef VERIFIC // {{{ // Verify unsigned division assert property (@(posedge i_clk) disable iff (i_reset) (i_wr)&&(i_denominator != 0)&&(!i_signed) |=> ((!o_err)&&(!o_valid)&&(o_busy)&&(!r_sign)&&(!pre_sign) throughout (r_bit == 0) ##1 ((r_bit == $past(r_bit)+1)&&({1'b0,r_bit}< BW-1)) [*0:$] ##1 ({ 1'b0, r_bit } == BW-1)) ##1 (!o_err)&&(o_valid)); // Verify division by zero assert property (@(posedge i_clk) disable iff (i_reset) (i_wr)&&(i_denominator == 0) |=> (zero_divisor throughout (!o_err)&&(!o_valid)&&(pre_sign) [*0:1] ##1 ((r_busy)&&(!o_err)&&(!o_valid)) ##1 ((o_err)&&(o_valid)))); // }}} `endif // VERIFIC `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "pffifo.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/pffifo.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: pffifo.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This is a basic prefetch. As with the other prefetches, its job // is to keep the CPU fed with instructions, (ideally) at one // instruction per clock cycle and with only a minimum number stalls. // // This particular implementation is designed around a basic FIFO // implementation, like the dblfetch implementation, save that we allow a // FIFO that can hold more than two instructions at a time. It will work // well for a CPU that doesn't do a lot of branching, but poorly under // a high branching load. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module pffifo #( // {{{",
            "parameter LGFIFO = 4, parameter AW = 30, parameter BUS_WIDTH = 128, // Num data bits on the bus",
            "parameter INSN_WIDTH = 32, parameter [0:0] OPT_LITTLE_ENDIAN = 1'b0, parameter [0:0] OPT_LOWPOWER = 1'b0, parameter [0:0] OPT_ASYNC_READ = (BUS_WIDTH != INSN_WIDTH), localparam BUSW = BUS_WIDTH, localparam WBLSB = $clog2(BUS_WIDTH/8), localparam ADDRESS_WIDTH=AW + WBLSB // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // // The interface with the rest of the CPU // {{{",
            "input wire i_new_pc, input wire i_clear_cache, input wire i_ready, input wire [ADDRESS_WIDTH-1:0] i_pc, output wire o_valid, output wire o_illegal, output wire [INSN_WIDTH-1:0] o_insn, output reg [ADDRESS_WIDTH-1:0] o_pc, // }}} // The wishbone bus interface // {{{",
            "output reg o_wb_cyc, o_wb_stb, // verilator coverage_off",
            "output wire o_wb_we, // verilator coverage_on",
            "output reg [AW-1:0] o_wb_addr, // verilator coverage_off",
            "output wire [BUSW-1:0] o_wb_data, output wire [BUSW/8-1:0] o_wb_sel, // verilator coverage_on // input wire i_wb_stall, i_wb_ack, i_wb_err, input wire [BUSW-1:0] i_wb_data // }}} // }}} ); // Declarations // {{{",
            "localparam INLSB = $clog2(INSN_WIDTH/8);",
            "reg pending_err;",
            "reg [LGFIFO:0] wb_pending, pipe_fill;",
            "wire [LGFIFO:0] w_pipe_fill;",
            "wire pipe_full, last_ack;",
            "wire sfifo_reset, ign_sfifo_full, sfifo_empty,pf_err;",
            "wire [LGFIFO:0] sfifo_fill; // Used to start operation",
            "wire [BUS_WIDTH-1:0] sfifo_word;",
            "wire sfifo_read, pf_last; `ifdef FORMAL",
            "wire [LGFIFO:0] f_first_addr, f_second_addr, f_distance_to_first, f_distance_to_second;",
            "wire [BUS_WIDTH:0] f_first_data, f_second_data;",
            "wire f_first_in_fifo, f_second_in_fifo;",
            "wire [BUS_WIDTH-1:0] f_wide_data; `endif // }}} //////////////////////////////////////////////////////////////////////// // // Request instructions from the bus // {{{ // o_wb_cyc, o_wb_stb, o_wb_addr, pending_err // {{{",
            "initial pending_err = 1'b0;",
            "initial { o_wb_cyc, o_wb_stb } = 2'b00;",
            "always @(posedge i_clk) if (sfifo_reset) begin pending_err <= 1'b0; o_wb_cyc <= 1'b0; o_wb_stb <= 1'b0; if (i_new_pc) o_wb_addr <= i_pc[ADDRESS_WIDTH-1:WBLSB]; if (i_reset) o_wb_addr <= 0; end else if (o_wb_cyc && i_wb_err) begin pending_err <= 1'b1; o_wb_cyc <= 1'b0; o_wb_stb <= 1'b0; // Verilator lint_off WIDTH o_wb_addr <= o_wb_addr - wb_pending; // Verilator lint_on WIDTH end else if (o_wb_cyc) begin pending_err <= 1'b0; if (o_wb_stb && !i_wb_stall) o_wb_addr <= o_wb_addr + 1; if (pipe_full && !i_wb_stall) o_wb_stb <= 1'b0; if ((!o_wb_stb || (pipe_full && !i_wb_stall)) && last_ack) o_wb_cyc <= 1'b0; end else if (sfifo_fill[LGFIFO:LGFIFO-1] == 2'b00 && !pending_err) begin o_wb_cyc <= 1'b1; o_wb_stb <= 1'b1; // o_wb_addr == same as before end `ifdef FORMAL",
            "always @(*) if (!i_reset) assert(o_wb_cyc == (o_wb_stb || wb_pending > 0)); `endif // }}} // o_wb_sel // {{{ generate if (INSN_WIDTH == BUS_WIDTH) begin : GEN_ALWAYS_SEL",
            "assign o_wb_sel = {(BUS_WIDTH/8){1'b1}}; end else begin : GEN_WB_SEL",
            "reg [BUS_WIDTH/8-1:0] r_sel;",
            "wire [WBLSB-INLSB-1:0] new_shift;",
            "assign new_shift = i_pc[WBLSB-1:INLSB];",
            "always @(posedge i_clk) if (i_new_pc) begin if (OPT_LITTLE_ENDIAN) begin r_sel <= {(BUS_WIDTH/8){1'b1}} << ((INSN_WIDTH/8)*new_shift); end else begin r_sel <= {(BUS_WIDTH/8){1'b1}} >> ((INSN_WIDTH/8)*new_shift); end end else if (o_wb_stb && !i_wb_stall) r_sel <= {(BUS_WIDTH/8){1'b1}};",
            "assign o_wb_sel = r_sel; end endgenerate // }}} // wb_pending: When do we shut off CYC? // {{{",
            "initial wb_pending = 0;",
            "always @(posedge i_clk) if (sfifo_reset || i_wb_err) wb_pending <= 0; else case({ (o_wb_stb && !i_wb_stall), (o_wb_cyc && i_wb_ack) }) 2'b10: wb_pending <= wb_pending + 1; 2'b01: wb_pending <= wb_pending - 1; default: begin end endcase // }}} // pipe_fill: When do we shut off STB? // {{{",
            "initial pipe_fill = 0;",
            "always @(posedge i_clk) if (sfifo_reset || (o_wb_cyc && i_wb_err)) pipe_fill <= 0; else if (!pending_err) case({ (o_wb_stb && !i_wb_stall), o_valid && i_ready && pf_last }) 2'b10: pipe_fill <= pipe_fill + 1; 2'b01: pipe_fill <= pipe_fill - 1; default: begin end endcase // }}}",
            "assign w_pipe_fill = pipe_fill + (o_wb_stb ? 1:0);",
            "assign pipe_full = pending_err || w_pipe_fill[LGFIFO];",
            "assign last_ack = (wb_pending + (o_wb_stb ? 1:0)) == (i_wb_ack ? 1:0);",
            "assign o_wb_we = 1'b0;",
            "assign o_wb_data = {(BUS_WIDTH){1'b0}}; // }}} //////////////////////////////////////////////////////////////////////// // // Placed returned instructions into a FIFO // {{{ //////////////////////////////////////////////////////////////////////// // // assign sfifo_reset = i_reset || i_clear_cache || i_new_pc; sfifo #( .BW(BUS_WIDTH+1), .LGFLEN(LGFIFO), .OPT_ASYNC_READ(OPT_ASYNC_READ) ) u_sfifo ( .i_clk(i_clk), .i_reset(sfifo_reset), .i_wr(o_wb_cyc && (i_wb_ack || i_wb_err) && !pending_err), .i_data({ i_wb_err, i_wb_data }), .o_full(ign_sfifo_full), .o_fill(sfifo_fill), .i_rd(sfifo_read), .o_data({ pf_err, sfifo_word }), .o_empty(sfifo_empty) `ifdef FORMAL , .f_first_addr(f_first_addr), .f_second_addr(f_second_addr), .f_first_data(f_first_data), .f_second_data(f_second_data), .f_first_in_fifo(f_first_in_fifo), .f_second_in_fifo(f_second_in_fifo), .f_distance_to_first(f_distance_to_first), .f_distance_to_second(f_distance_to_second) `endif ); // }}} //////////////////////////////////////////////////////////////////////// // // Unpack wide responses into instructions for the CPU // {{{ // o_pc // {{{",
            "always @(posedge i_clk) begin if (i_reset) o_pc <= 0; else if (i_new_pc) o_pc <= i_pc; else if (o_valid && i_ready) o_pc <= o_pc + INSN_WIDTH/8; o_pc[$clog2(INSN_WIDTH/8)-1:0] <= 0; end // }}} generate if (BUS_WIDTH == INSN_WIDTH) begin : NO_UNPACKING",
            "reg r_illegal;",
            "assign o_valid = !sfifo_empty;",
            "assign sfifo_read = o_valid && i_ready;",
            "assign o_insn = sfifo_word; // o_illegal // {{{",
            "initial r_illegal = 1'b0;",
            "always @(posedge i_clk) if (sfifo_reset) r_illegal <= 1'b0; else if (o_valid && o_illegal) r_illegal <= 1'b1;",
            "assign o_illegal = (pf_err && !sfifo_empty) || r_illegal; // }}}",
            "assign pf_last = 1; `ifdef FORMAL",
            "assign f_wide_data = sfifo_word; `endif end else begin : UNPACK_BUS // {{{",
            "reg r_valid, r_illegal;",
            "reg [BUS_WIDTH-1:0] r_data;",
            "reg [WBLSB-INLSB-1:0] first_shift; // o_valid // {{{",
            "initial r_valid = 1'b0;",
            "always @(posedge i_clk) if (sfifo_reset) r_valid <= 1'b0; else if (!o_valid || i_ready) r_valid <= !sfifo_empty || (o_valid && !pf_last);",
            "assign o_valid = r_valid; // }}} // first_shift // {{{",
            "always @(posedge i_clk) if (i_reset) first_shift <= 0; else if (i_new_pc) first_shift <= i_pc[WBLSB-1:INLSB]; else if (sfifo_read && !sfifo_empty) first_shift <= 0; `ifdef FORMAL",
            "always @(*) if (i_reset) begin end else if (o_valid) begin assert(first_shift == 0); end else if (o_wb_cyc || pipe_fill > 0) assert(first_shift == o_pc[WBLSB-1:INLSB]); `endif // }}} // o_insn // {{{",
            "initial r_data = {(BUS_WIDTH){1'b0}};",
            "always @(posedge i_clk) if (OPT_LOWPOWER && (sfifo_reset)) r_data <= 0; else if (!o_valid || i_ready) begin if (o_valid && !pf_last) begin if (OPT_LITTLE_ENDIAN) r_data <= r_data >> INSN_WIDTH; else r_data <= r_data << INSN_WIDTH; end else if ((!OPT_LOWPOWER || !sfifo_empty) && (pf_last || !o_valid)) begin if (OPT_LITTLE_ENDIAN) r_data <= sfifo_word >> (INSN_WIDTH * first_shift); else r_data <= sfifo_word << (INSN_WIDTH * first_shift); end end if (OPT_LITTLE_ENDIAN) begin : ASSIGN_LOWBITS",
            "assign o_insn = r_data[INSN_WIDTH-1:0]; end else begin : ASSIGN_HIBITS",
            "assign o_insn = r_data[BUS_WIDTH-INSN_WIDTH +: INSN_WIDTH]; end // }}}",
            "assign sfifo_read = (!o_valid || i_ready) && (!o_valid || pf_last);",
            "assign pf_last = (&o_pc[WBLSB-1:INLSB]); // o_illegal // {{{",
            "initial r_illegal = 1'b0;",
            "always @(posedge i_clk) if (sfifo_reset) r_illegal <= 1'b0; else if (sfifo_read && !sfifo_empty) r_illegal <= r_illegal || pf_err;",
            "assign o_illegal = r_illegal; // }}} `ifdef FORMAL",
            "assign f_wide_data = r_data; `endif // }}} end endgenerate // }}} // Keep Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, sfifo_fill[LGFIFO-2:0], ign_sfifo_full }; // Verilator lint_on UNUSED // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal property section // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Declarations, reset, and f_past_valid // {{{",
            "localparam F_LGDEPTH=LGFIFO+1;",
            "reg f_past_valid;",
            "reg [4:0] f_cpu_delay;",
            "wire [WBLSB+AW-1:0] f_const_addr, f_address;",
            "wire f_const_illegal;",
            "wire [INSN_WIDTH-1:0] f_const_insn;",
            "wire f_fifo_extra;",
            "wire [(F_LGDEPTH-1):0] f_nreqs, f_nacks, f_outstanding;",
            "wire [INSN_WIDTH-1:0] f_insn; (* anyconst *)",
            "reg [BUS_WIDTH-1:0] f_const_word; (* anyconst *)",
            "reg fnvr_err;",
            "reg f_this_return, f_this_fifo;",
            "reg [AW-1:0] f_return_addr; // Keep track of a flag telling us whether or not $past() // will return valid results",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; // // Assume we start from a reset condition",
            "always @(*) if (!f_past_valid) assume(i_reset); // }}} //////////////////////////////////////////////////////////////////////// // // Assumptions about our",
            "input s // {{{ //////////////////////////////////////////////////////////////////////// // // ffetch #( // {{{ .ADDRESS_WIDTH(AW + WBLSB-INLSB), .OPT_CONTRACT(1'b1), .INSN_WIDTH(INSN_WIDTH) // }}} ) fcpu( // {{{ .i_clk(i_clk), .i_reset(i_reset), .cpu_new_pc(i_new_pc), .cpu_clear_cache(i_clear_cache), .cpu_pc(i_pc), .cpu_ready(i_ready), .pf_valid(o_valid), .pf_insn(o_insn), .pf_pc(o_pc), .pf_illegal(o_illegal), .fc_pc(f_const_addr), .fc_illegal(f_const_illegal), .fc_insn(f_const_insn), .f_address(f_address) // }}} );",
            "always @(*) begin assume(f_address[INLSB-1:0] == 0); end",
            "always @(*) begin f_return_addr = o_wb_addr - wb_pending; f_this_return = (f_return_addr == f_const_addr[WBLSB +: AW]); end",
            "always @(*) if (f_this_return) begin if (f_const_illegal) assume(!i_wb_ack); else assume(!i_wb_err); if (i_wb_ack) assume(i_wb_data == f_const_word); end // f_const_word -- a wide bus word to check against // {{{ generate if (INSN_WIDTH == BUS_WIDTH) begin : F_CONST_NOSHIFT",
            "always @(*) assume(f_const_word == f_const_insn); end else begin : F_CONST_SHIFT",
            "wire [WBLSB-INLSB-1:0] f_shift, f_shift_now;",
            "wire [BUS_WIDTH-1:0] f_shifted, f_now;",
            "wire [INSN_WIDTH-1:0] f_insn_check, f_insn_now;",
            "wire f_now_check;",
            "assign f_shift = f_const_addr[WBLSB-1:INLSB];",
            "assign f_shift_now = f_const_addr[WBLSB-1:INLSB] - o_pc[WBLSB-1:INLSB]; if (OPT_LITTLE_ENDIAN) begin",
            "assign f_shifted = f_const_word >> (INSN_WIDTH * f_shift);",
            "assign f_insn_check = f_shifted[INSN_WIDTH-1:0];",
            "assign f_now = f_wide_data >> (INSN_WIDTH * f_shift_now);",
            "assign f_insn_now = f_now[INSN_WIDTH-1:0]; end else begin",
            "assign f_shifted = f_const_word << (INSN_WIDTH * f_shift);",
            "assign f_insn_check = f_shifted[BUS_WIDTH-1:BUS_WIDTH-INSN_WIDTH];",
            "assign f_now = f_wide_data << (INSN_WIDTH * f_shift_now);",
            "assign f_insn_now = f_now[BUS_WIDTH-1:BUS_WIDTH-INSN_WIDTH]; end",
            "assign f_now_check = o_valid && !o_illegal && o_pc[WBLSB +: AW]==f_const_addr[WBLSB +: AW] && f_const_addr[WBLSB-1:INLSB] >= o_pc[WBLSB-1:INLSB];",
            "always @(*) assume(f_insn_check == f_const_insn);",
            "always @(*) if (f_past_valid && f_now_check) assert(f_insn_now == f_const_insn); end endgenerate // }}} `ifdef SKIPME // {{{ // Let's make some assumptions about how long it takes our // phantom bus and phantom CPU to respond. // // These delays need to be long enough to flush out any potential // errors, yet still short enough that the formal method doesn't // take forever to solve. // localparam F_CPU_DELAY = 4; // Now, let's repeat this bit but now looking at the delay the CPU // takes to accept an instruction.",
            "always @(posedge i_clk) // If no instruction is ready, then keep our counter at zero if ((!o_valid)||(i_ready)) f_cpu_delay <= 0; else // Otherwise, count the clocks the CPU takes to respond f_cpu_delay <= f_cpu_delay + 1'b1; `ifdef PFCACHE",
            "always @(posedge i_clk) assume(f_cpu_delay < F_CPU_DELAY); `endif // }}} `else",
            "always @(*) f_cpu_delay = 0; `endif // }}} //////////////////////////////////////////////////////////////////////// // // FIFO checks // {{{ //////////////////////////////////////////////////////////////////////// // // reg [AW-1:0] fifo_addr, f_first_wbaddr, f_second_wbaddr;",
            "reg f_first_is_last, f_second_is_last, f_known_return;",
            "assign f_fifo_extra = o_valid && (INSN_WIDTH != BUS_WIDTH); // Relating o_pc to o_wb_addr",
            "always @(*) begin if (pending_err) fifo_addr = o_pc[WBLSB +: AW] + (f_fifo_extra ? 1:0); else begin fifo_addr = o_wb_addr - pipe_fill; if (f_fifo_extra) fifo_addr = fifo_addr + 1; end f_this_fifo = !sfifo_empty && (fifo_addr == f_const_addr[WBLSB +: AW]); f_first_wbaddr = o_pc[WBLSB +: AW] + f_distance_to_first; f_second_wbaddr = o_pc[WBLSB +: AW] + f_distance_to_second; if(f_fifo_extra) begin f_first_wbaddr = f_first_wbaddr + 1; f_second_wbaddr = f_second_wbaddr + 1; end f_first_is_last = (f_distance_to_first + 1 == sfifo_fill); f_second_is_last = (f_distance_to_second + 1 == sfifo_fill); f_known_return = (f_first_in_fifo && f_distance_to_first==0) || (f_second_in_fifo && f_distance_to_second == 0); end",
            "always @(*) if (f_past_valid && (o_valid || o_wb_cyc || sfifo_fill > 0)) assert(o_pc == f_address);",
            "always @(*) if (!sfifo_reset && !o_illegal && !pending_err) assert(o_pc[WBLSB +: AW] == fifo_addr - f_fifo_extra);",
            "always @(*) if (f_past_valid) begin if (f_first_in_fifo&& !o_illegal && f_first_wbaddr == f_const_addr[WBLSB +: AW]) begin if (f_const_illegal) assert(f_first_data[BUS_WIDTH]); else assert(f_first_data== { 1'b0,f_const_word }); end if (f_second_in_fifo&& !o_illegal && f_second_wbaddr == f_const_addr[WBLSB +: AW]) begin if (f_const_illegal) assert(f_second_data[BUS_WIDTH]); else assert(f_second_data=={ 1'b0,f_const_word }); end if (f_first_in_fifo && !f_first_is_last) assert(!f_first_data[BUS_WIDTH]); if (f_second_in_fifo && !f_second_is_last) assert(!f_second_data[BUS_WIDTH]); if (!f_known_return) begin if (sfifo_fill > 1) assume(!pf_err); if (!pending_err) assume(!pf_err); if (f_this_fifo) begin if (f_const_illegal) assume(pf_err); else assume(!pf_err && sfifo_word == f_const_word); end end if (!pending_err) assert(!o_illegal); if (o_valid && f_const_addr[WBLSB +: AW] == o_pc[WBLSB +: AW]) begin if (f_const_illegal) assert(o_illegal); end if (pending_err) begin if (f_first_in_fifo && f_first_is_last) begin assert(f_first_data[BUS_WIDTH]); end else if (f_second_in_fifo && f_second_is_last) begin assert(f_second_data[BUS_WIDTH]); end else if (sfifo_fill == 1) assume(pf_err); end else begin if (f_first_in_fifo) assert(!f_first_data[BUS_WIDTH]); if (f_second_in_fifo) assert(!f_second_data[BUS_WIDTH]); end end // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about our",
            "output s // {{{ //////////////////////////////////////////////////////////////////////// // // fwb_master #( // {{{ .AW(AW), .DW(BUSW), .F_LGDEPTH(F_LGDEPTH), .F_MAX_STALL(2), .F_MAX_ACK_DELAY(3), .F_MAX_REQUESTS(0), .F_OPT_SOURCE(1), .F_OPT_RMW_BUS_OPTION(0), .F_OPT_DISCONTINUOUS(0) // }}} ) f_wbm( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_wb_cyc(o_wb_cyc), .i_wb_stb(o_wb_stb), .i_wb_we(o_wb_we), .i_wb_addr(o_wb_addr), .i_wb_data(o_wb_data), .i_wb_sel(o_wb_sel), .i_wb_ack(i_wb_ack), .i_wb_stall(i_wb_stall), .i_wb_data(i_wb_data), .i_wb_err(i_wb_err), .f_nreqs(f_nreqs), .f_nacks(f_nacks), .f_outstanding(f_outstanding) // }}} );",
            "always @(*) if (fnvr_err) assume(!i_wb_err);",
            "always @(*) if (!i_reset && fnvr_err) begin assert(!pending_err); assert(!o_illegal); end // writes are also illegal for a prefetch.",
            "always @(posedge i_clk) if (o_wb_stb) assert(!o_wb_we);",
            "always @(posedge i_clk) begin assert(f_outstanding == wb_pending); assert(pipe_fill >= wb_pending); if (!pending_err) begin assert(pipe_fill >= sfifo_fill); assert(pipe_fill == sfifo_fill + wb_pending + f_fifo_extra); end assert(pipe_fill <= (1<<LGFIFO)); end // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about our return responses to the CPU // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (!sfifo_reset) assert(o_illegal || o_pc == f_address); // // If an instruction is accepted, we should *",
            "always * move on to another // instruction. The only exception is following an i_new_pc (or // other invalidator), at which point the next instruction should // be invalid.",
            "always @(posedge i_clk) if ((f_past_valid)&& $past(o_valid && i_ready && !o_illegal && !i_new_pc)) begin // Should",
            "always advance the instruction pointer assert((!o_valid)||(o_pc != $past(o_pc))); end // // Once an instruction becomes valid, it should never become invalid // unless there's been a request for a new instruction.",
            "always @(posedge i_clk) if (!f_past_valid || $past(sfifo_reset)) begin assert(!o_valid); assert(!o_illegal); end else if ($past(o_valid && !i_ready)) begin if (!$past(o_illegal)) begin assert(o_valid); assert(!o_illegal); assert($stable(o_insn)); end else assert(o_illegal); end // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // reg f_valid_legal;",
            "always @(*) f_valid_legal = o_valid && (!o_illegal);",
            "always @(posedge i_clk) // Trace 0 cover((o_valid)&&( o_illegal));",
            "always @(posedge i_clk) // Trace 1 cover(f_valid_legal);",
            "always @(posedge i_clk) // Trace 2 cover((f_valid_legal) &&($past(!o_valid && !i_new_pc)) &&($past(i_new_pc,4)));",
            "always @(posedge i_clk) cover((f_valid_legal)&&($past(f_valid_legal && i_ready)));",
            "always @(posedge i_clk) cover((f_valid_legal) &&($past(f_valid_legal && i_ready)) &&($past(f_valid_legal && i_ready,2)) &&($past(f_valid_legal && i_ready,3)));",
            "always @(posedge i_clk) cover((f_valid_legal) &&($past(f_valid_legal && i_ready)) &&($past(f_valid_legal && i_ready,2)) &&($past(!o_illegal && i_ready && i_new_pc,5)) &&($past(f_valid_legal && i_ready,6))); // }}} `endif // FORMAL // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "axiicache.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axiicache.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: axiicache.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: An I-Cache, for when the CPU has an AXI interface. // // Goal: To return each instruction within a single clock tick. Jumps // should only stall if they switch cache lines. // // This",
            "logic is driven by a couple realities: // 1. It takes a clock to read from a block RAM address, and hence a clock // to read from the cache. // 2. It takes another clock to check that the tag matches // // Our goal will be to avoid this second check if at all possible. // Hence, we'll test on the clock of any given request whether // or not the request matches the last tag value, and on the next // clock whether it new tag value (if it has changed). Hence, // for anything found within the cache, there will be a one // cycle delay on any branch. // // // Address Words are separated into three components: // [ Tag bits ] [ Cache line number ] [ Cache position w/in the line ] // // On any read from the cache, only the second two components are required. // On any read from memory, the first two components will be fixed across // the bus, and the third component will be adjusted from zero to its // maximum value. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module axiicache #( // {{{ // LGCACHESZ is the log(based two) of the cache size *in bytes*",
            "parameter LGCACHESZ = 14, // // LGLINESZ is the size of one cache line, represented in // words",
            "parameter LGLINESZ=3, // // LGWAYS is the number of cache \"ways\" // parameter LGWAYS = 0, // parameter C_AXI_ID_WIDTH = 1, parameter C_AXI_ADDR_WIDTH = 32, parameter C_AXI_DATA_WIDTH = 32, parameter [0:0] OPT_WRAP = 1'b0, parameter [0:0] OPT_LOWPOWER = 1'b0, // // SWAP_ENDIANNESS",
            "parameter [0:0] SWAP_ENDIANNESS = 1'b0, // parameter INSN_WIDTH = 32, parameter [C_AXI_ID_WIDTH-1:0] AXI_ID = 0, localparam ADDRLSB = $clog2(C_AXI_DATA_WIDTH/8), localparam LGINSN = $clog2(INSN_WIDTH/8), // localparam INSN_PER_WORD = C_AXI_DATA_WIDTH/INSN_WIDTH, localparam AW=C_AXI_ADDR_WIDTH, localparam DW=C_AXI_DATA_WIDTH, localparam LS=LGLINESZ, // Size of a cache line in words LSB=LGLINESZ+ADDRLSB // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, // // The AXI Master (cache) interface // {{{ // An instruction cache only needs to support cache reads",
            "output wire M_AXI_ARVALID, input wire M_AXI_ARREADY, // verilator coverage_off",
            "output wire [C_AXI_ID_WIDTH-1:0] M_AXI_ARID, // verilator coverage_on",
            "output wire [C_AXI_ADDR_WIDTH-1:0] M_AXI_ARADDR, output wire [7:0] M_AXI_ARLEN, output wire [2:0] M_AXI_ARSIZE, output wire [1:0] M_AXI_ARBURST, // verilator coverage_off",
            "output wire M_AXI_ARLOCK, // = 0",
            "output wire [3:0] M_AXI_ARCACHE, output wire [2:0] M_AXI_ARPROT, output wire [3:0] M_AXI_ARQOS, // verilator coverage_on // input wire M_AXI_RVALID, output wire M_AXI_RREADY, // verilator coverage_off",
            "input wire [C_AXI_ID_WIDTH-1:0] M_AXI_RID, // verilator coverage_on",
            "input wire [C_AXI_DATA_WIDTH-1:0] M_AXI_RDATA, input wire M_AXI_RLAST, input wire [1:0] M_AXI_RRESP, // }}} // CPU interface // {{{",
            "input wire i_cpu_reset, input wire i_new_pc, input wire i_clear_cache, input wire i_ready, input wire [AW-1:0] i_pc, output wire [INSN_WIDTH-1:0] o_insn, output reg [AW-1:0] o_pc, output reg o_valid, output reg o_illegal // }}} `ifdef DEPRECATED",
            "output wire [AW-1:0] illegal_addr, output wire [AW-LSB-1:0] bus_tag, output wire [AW-LSB-1:0] o_tag, output wire [AW-LSB-1:0] i_tag, output wire [AW-LSB-1:0] lastpc_tag `endif // }}} ); // Register/local",
            "parameter declarations // {{{",
            "localparam [1:0] INCR = 2'b01, WRAP = 2'b10; // localparam CACHELEN=(1<<LGCACHESZ); //Byte Size of our cache memory // localparam CACHELENW = CACHELEN/(C_AXI_DATA_WIDTH/8); // Word sz",
            "localparam CWB=LGCACHESZ, // Short hand for LGCACHESZ CW=LGCACHESZ-ADDRLSB; // now in words",
            "localparam LGLINES=CWB-LSB; // reg [DW-1:0] cache [0:((1<<CW)-1)];",
            "reg [(AW-CWB-1):0] cache_tags [0:((1<<(LGLINES))-1)];",
            "reg [((1<<(LGLINES))-1):0] cache_valid;",
            "reg [DW-1:0] cache_word;",
            "reg last_valid, from_pc, pc_valid, illegal_valid, request_pending, bus_abort, valid_line;",
            "reg [AW-1:LSB] pc_tag, last_tag, illegal_tag;",
            "reg [LS-1:0] write_posn;",
            "reg axi_arvalid;",
            "reg [AW-1:0] axi_araddr, last_pc;",
            "reg start_read;",
            "wire wrap_valid;",
            "wire [CWB-LSB-1:0] axi_line, pc_line, last_line;",
            "wire [AW-CWB-1:0] axi_tag; // }}} //////////////////////////////////////////////////////////////////////// // // Check whether or not the instruction requested from the CPU is // in the cache or not // {{{ //////////////////////////////////////////////////////////////////////// // // // from_pc // {{{ // Whether our next address comes from the just-give program counter // from the CPU, or from our own internal measure. Why? Because the // CPU will move on to the next address on the next cycle, reg ardless // of whether or not we meet this one, therefore we need to latch it // for later.",
            "initial from_pc = 1;",
            "always @(posedge S_AXI_ACLK) if (i_new_pc || i_clear_cache || (o_valid && i_ready)) from_pc <= 1; else from_pc <= 0; // }}}",
            "assign axi_line = axi_araddr[CWB-1:LSB];",
            "assign axi_tag = axi_araddr[AW-1:CWB];",
            "assign pc_line = i_pc[CWB-1:LSB];",
            "assign last_line= last_pc[CWB-1:LSB]; // // From the PC // pc_valid // {{{ // True if the cache is valid at the address in the program counter",
            "always @(posedge S_AXI_ACLK) pc_valid <= cache_valid[pc_line]; // }}} // pc_tag // {{{ // Evaluates to the cache tag, at the program counter address for the // incoming/requested program counter",
            "always @(posedge S_AXI_ACLK) pc_tag <= { cache_tags[pc_line], pc_line }; // }}} // // Repeat for the last program counter--since the current counter // will be given only once. The last_* values will be used any time // we have to stall a request before it can be served // // last_pc // {{{",
            "always @(posedge S_AXI_ACLK) if (i_new_pc || (o_valid && i_ready && !o_illegal)) last_pc <= i_pc; // }}} // last_valid // {{{",
            "always @(posedge S_AXI_ACLK) last_valid <= cache_valid[last_line]; // }}} // last_tag // {{{",
            "always @(posedge S_AXI_ACLK) last_tag <= { cache_tags[last_line], last_line }; // }}} // valid_line --- are we serving a valid request line? // {{{",
            "always @(*) begin valid_line = 1'b0; // Zero delay lookup: New PC, but staying w/in same cache line // This only works if the entire line is full--so no requests // may be pending at this time. if (i_new_pc) valid_line = !request_pending && pc_valid && pc_tag == i_pc[AW-1:LSB]; else if (o_valid && i_ready) begin // Zero delay lookup, tag matches last lookup valid_line = pc_valid && (i_pc[AW-1:LSB] == pc_tag[AW-1:LSB]); if (wrap_valid && i_pc[AW-1:LSB] == axi_araddr[AW-1:LSB]) valid_line = 1; end else begin // Longer lookups. Several possibilities here. // 1. We might be working through recent reads from the // cache, for which the cache line isn't yet full valid_line = wrap_valid; // 2. One delay lookup. Request was for an address with // a different tag. Since it was different, we had // to do a memory read to look it up. After lookup, // the tag now matches. if (from_pc && pc_valid && pc_tag == last_pc[AW-1:LSB]) valid_line = 1'b1; // 3. Many delay lookup. The tag didn't match, so we // had to go search for it from memory. The cache // line is now valid, so now we can use it. if (!from_pc && last_valid && last_tag == last_pc[AW-1:LSB]) valid_line = 1'b1; // 4. Illegal lookup. if (!o_valid && illegal_valid && illegal_tag == last_pc[AW-1:LSB]) valid_line = 1; end end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Request data from the AXI bus to fill a cache miss // {{{ //////////////////////////////////////////////////////////////////////// // // // start_read // {{{ // Issue a bus transaction -- the cache line requested couldn't be // found in the bus anywhere, so we need to go look for it",
            "reg wait_on_read;",
            "initial wait_on_read = 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) wait_on_read <= 1; else begin wait_on_read <= request_pending; // M_AXI_RVALID && M_AXI_RLAST; if (i_clear_cache || i_new_pc || i_cpu_reset) wait_on_read <= 1; end",
            "always @(*) begin start_read = !valid_line && !o_valid; if (i_clear_cache || i_new_pc || wait_on_read) start_read = 0; if (o_illegal) start_read = 0; if (M_AXI_ARVALID) start_read = 0; if (request_pending || i_cpu_reset || !S_AXI_ARESETN) start_read = 0; end // }}} // axi_arvalid // {{{",
            "initial axi_arvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_arvalid <= 0; else if (!M_AXI_ARVALID || M_AXI_ARREADY) axi_arvalid <= start_read; // }}} // request_pending, bus_abort // {{{",
            "initial request_pending = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin request_pending <= 0; bus_abort <= 0; end else if (request_pending) begin if (i_cpu_reset || i_clear_cache) bus_abort <= 1; if (M_AXI_RVALID && M_AXI_RRESP[1]) bus_abort <= 1; if (i_new_pc && i_pc[AW-1:LSB] != axi_araddr[AW-1:LSB]) bus_abort <= 1; if (M_AXI_RVALID && M_AXI_RLAST) begin request_pending <= 0; bus_abort <= 0; end end else if (!M_AXI_ARVALID || M_AXI_ARREADY) begin request_pending <= start_read; bus_abort <= 0; end // }}} // axi_araddr // {{{",
            "always @(posedge S_AXI_ACLK) if ((!M_AXI_ARVALID || M_AXI_ARREADY) && !request_pending) begin axi_araddr <= last_pc; if (OPT_WRAP) axi_araddr[ADDRLSB-1:0] <= 0; else axi_araddr[LSB-1:0] <= 0; if (OPT_LOWPOWER && !start_read) axi_araddr <= 0; end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Fill the cache with the new data // {{{ //////////////////////////////////////////////////////////////////////// // // // write_posn -- the sub-address w/in the cache to write to // {{{",
            "always @(posedge S_AXI_ACLK) if (!request_pending) write_posn <= (OPT_WRAP) ? last_pc[LSB-1:ADDRLSB] : 0; else if (M_AXI_RVALID && M_AXI_RREADY) write_posn <= write_posn + 1; // }}} // cache -- Actually do the write to cache memory // {{{ generate if (SWAP_ENDIANNESS) begin : BIG_TO_LITTLE_ENDIAN // {{{ // // The ZipCPU is originally a big endian machine. Bytes on the // AXI bus are by nature little endian. The following little // snippet rearranges bytes so that they have the proper bus // order. Whether or not this is required, however, is ... // another issue entirely.",
            "reg [C_AXI_DATA_WIDTH-1:0] swapped_data; genvar gw, gb; // Word count, byte count for(gw=0; gw<C_AXI_DATA_WIDTH/32; gw=gw+1) begin for(gb=0; gb<4; gb=gb+1) begin",
            "always @(*) swapped_data[gw*32+(3-gb)*8 +: 8] = M_AXI_RDATA[gw*32+gb*8 +: 8]; end end",
            "always @(posedge S_AXI_ACLK) if (M_AXI_RVALID && M_AXI_RREADY) cache[{ axi_araddr[CWB-1:LSB], write_posn }] <= swapped_data; // }}} end else begin : KEEP_ENDIANNESS // {{{",
            "always @(posedge S_AXI_ACLK) if (M_AXI_RVALID && M_AXI_RREADY) cache[{ axi_araddr[CWB-1:LSB], write_posn }] <= M_AXI_RDATA; // }}} end endgenerate // }}} // cache_tags, set/control/write-to the cache tags array // {{{",
            "always @(posedge S_AXI_ACLK) if (request_pending) cache_tags[axi_line] <= axi_tag; // }}} // cache_valid--keep track of which cache entry has valid data w/in it // {{{",
            "initial cache_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset || i_clear_cache) cache_valid <= 0; else if (request_pending) cache_valid[axi_line] <= (M_AXI_RVALID && M_AXI_RREADY && M_AXI_RLAST && !M_AXI_RRESP[1]); // }}} // wrap_valid // {{{ generate if (OPT_WRAP) begin : GEN_WRAP_VALID // {{{",
            "reg r_wrap, r_valid, r_poss;",
            "reg [(1<<LS):0] r_count; // r_wrap-- Can we keep continuing prior to the cache being vld? // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_wrap <= 0; else if (M_AXI_ARVALID) r_wrap <= 1; else if (M_AXI_RVALID && (&write_posn)) r_wrap <= 0; // }}} // r_poss, r_count // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin r_poss <= 0; r_count <= 0; end else if (i_new_pc || i_clear_cache || i_cpu_reset || (M_AXI_RVALID && (M_AXI_RLAST||M_AXI_RRESP[1]))) begin r_poss <= 0; r_count <= 0; end else if (M_AXI_ARVALID && M_AXI_ARADDR[AW-1:ADDRLSB] == last_pc[AW-1:ADDRLSB]) begin r_poss <= !bus_abort; r_count <= 0; end else if (r_poss) case({ (M_AXI_RVALID && M_AXI_RREADY && r_wrap), (o_valid && i_ready)}) 2'b01: begin r_count <= r_count - 1; r_poss <= (r_count > 1) || r_wrap; end 2'b10: r_count <= r_count + 1; // 2'b00: // 2'b11: default: begin end endcase // }}} // wrap_valid itself // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_valid <= 0; else if (i_cpu_reset || i_new_pc || i_clear_cache || bus_abort || (M_AXI_RVALID && M_AXI_RRESP[1]) || !r_poss) r_valid <= 0; else if (!r_valid || !o_valid || i_ready) begin // We can be valid if there's one more in the buffer // than we've read so far. r_valid <=(r_count > ((r_valid&&(!o_valid||i_ready)) ? 1:0) + (o_valid ? 1:0)); // We can also be valid if another one has just been // read--as long as it's not due to a bus error. if (M_AXI_RVALID && r_wrap) r_valid <= 1'b1; end",
            "assign wrap_valid = r_valid; // }}} `ifdef FORMAL // {{{",
            "always @(*) if (S_AXI_ARESETN && M_AXI_ARVALID) assert(!r_valid && r_count == 0);",
            "always @(*) if (S_AXI_ARESETN && (!request_pending || bus_abort)) assert(!r_poss);",
            "always @(*) if (S_AXI_ARESETN && !r_poss) assert(r_count == 0);",
            "always @(*) if (S_AXI_ARESETN && r_poss) begin if (!r_wrap) assert(r_count < write_posn - last_pc[LSB-1:ADDRLSB]); else assert(r_count <= (1<<LS) - last_pc[LSB-1:ADDRLSB]); end",
            "always @(*) if (S_AXI_ARESETN && (r_poss || r_valid)) assert(last_pc[AW-1:LSB] == axi_araddr[AW-1:LSB]);",
            "always @(*) if (S_AXI_ARESETN && request_pending) assert(r_valid == (r_count > (o_valid ? 1:0))); // }}} `endif // }}} end else begin : NO_WRAP_MODE // {{{",
            "assign wrap_valid = 1'b0; // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused_nowrap;",
            "assign unused_nowrap = &{ 1'b0, bus_abort }; // verilator lint_on UNUSED // verilator coverage_on // }}} end endgenerate // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Read the instruction from the cache // {{{ //////////////////////////////////////////////////////////////////////// // // // cache_word -- the cache word at the requested address // {{{",
            "always @(posedge S_AXI_ACLK) if (i_new_pc || (!o_valid || i_ready)) begin cache_word <= cache[(i_new_pc || o_valid) ? i_pc[CWB-1:ADDRLSB] : o_pc[CWB-1:ADDRLSB]]; end // }}} // o_insn // {{{ // Generate the outgoing instruction from the given cache_word // This involves shifting large cache words down to the desired/correct // word of interest generate if (C_AXI_DATA_WIDTH == INSN_WIDTH) begin : NO_LINE_SHIFT",
            "assign o_insn = cache_word; // Make Verilator happy // {{{ // Verilator lint_off UNUSED if (DW > INSN_WIDTH) begin : GEN_UNUSED_WIDE",
            "wire unused_wide;",
            "assign unused_wide = &{ 1'b0, cache_word[DW-1:INSN_WIDTH] }; end // Verilator lint_on UNUSED // }}} end else begin : SHIFT_CACHE_LINE",
            "reg [C_AXI_DATA_WIDTH-1:0] shifted;",
            "always @(*) shifted=cache_word >> (INSN_WIDTH * o_pc[ADDRLSB-1:LGINSN]);",
            "assign o_insn = shifted[INSN_WIDTH-1:0]; // Make Verilator happy // {{{ // Verilator lint_off UNUSED if (DW > INSN_WIDTH) begin : GEN_UNUSED_WIDE",
            "wire unused_wide;",
            "assign unused_wide = &{ 1'b0, shifted[DW-1:INSN_WIDTH] }; end // Verilator lint_on UNUSED // }}} end endgenerate // }}} // o_pc // {{{ // Signal the CPU with the actual address of the value we are returning // The ffetch properties will insure this value is correct. This CPU // then uses it for knowing the program counter of the instruction // contained within each stage of the pipeline",
            "initial o_pc = 0;",
            "always @(posedge S_AXI_ACLK) if (i_new_pc) o_pc <= i_pc; else if (o_valid && i_ready) begin o_pc[AW-1:2] <= o_pc[AW-1:2]+1; o_pc[1:0] <= 0; end // }}} // o_valid // {{{ // Are we returning a valid instruction to the CPU on this cycle?",
            "initial o_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset || i_clear_cache) o_valid <= 0; else if (o_valid && (i_ready || i_new_pc)) begin // Grab the next instruction--",
            "always ready on the same cycle // if we stay within the same cache line o_valid <= valid_line; if (o_illegal) o_valid <= 0; end else if (!o_valid && !i_new_pc) begin // We're stuck waiting for the cache line to become valid. // Don't forget to check for the illegal flag. o_valid <= valid_line; if (illegal_valid && o_pc[AW-1:LSB] == illegal_tag) o_valid <= 1; end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Handle bus errors here. // {{{ //////////////////////////////////////////////////////////////////////// // // If a bus read request returns an error, then we'll mark the entire // line as having a (valid) illegal value. Once the o_illegal value // is set, it will remain set until either the CPU branches, or the // cache is cleared. // // illegal_tag, illegal_valid // {{{ // Here's the rule: if illegal_valid is true, then we know that address // at that illegal_tag value will produce a bus error, and we can serve // a bus error request response on any read request.",
            "initial illegal_tag = 0;",
            "initial illegal_valid = 0;",
            "always @(posedge S_AXI_ACLK) if ((i_cpu_reset)||(i_clear_cache)) begin illegal_tag <= 0; illegal_valid <= 0; end else if (M_AXI_RVALID && M_AXI_RRESP[1]) begin illegal_tag <= axi_araddr[AW-1:LSB]; illegal_valid <= 1'b1; end // }}} // o_illegal // {{{",
            "initial o_illegal = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset || i_clear_cache || i_new_pc) o_illegal <= 1'b0; else if (o_valid && !o_illegal) o_illegal <= 1'b0; else if (illegal_valid && o_pc[AW-1:LSB] == illegal_tag) o_illegal <= 1'b1; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Fixed/constant bus values, map",
            "reg isters to AXI",
            "wire s/ etc. // {{{ //////////////////////////////////////////////////////////////////////// // // // Fixed bus",
            "output s: we read from the bus only, never write. // Thus the",
            "output data is ... irrelevant and don't care. We set it // to zero just to set it to something.",
            "assign M_AXI_ARVALID= axi_arvalid;",
            "assign M_AXI_ARID = AXI_ID;",
            "assign M_AXI_ARADDR = axi_araddr;",
            "assign M_AXI_ARLEN = (1<<LS)-1;",
            "assign M_AXI_ARSIZE = ADDRLSB[2:0]; // ARBURST. AXI supports a WRAP burst specifically for the purpose // of a CPU. Not all peripherals support it. For compatibility and // simplicities sake, we'll just use INCR here.",
            "assign M_AXI_ARBURST= (OPT_WRAP) ? WRAP : INCR;",
            "assign M_AXI_ARLOCK = 0;",
            "assign M_AXI_ARCACHE= 4'b0011; // ARPROT = 3'b100 for an unprivileged, secure instruction access // (not sure what unprivileged or secure mean--even after reading the // spec)",
            "assign M_AXI_ARPROT = 3'b100;",
            "assign M_AXI_ARQOS = 4'h0;",
            "assign M_AXI_RREADY = 1'b1; // }}} // Make Verilator happy // {{{ // verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, M_AXI_RID, M_AXI_RRESP[0] }; // Verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal property section // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "reg f_past_valid;",
            "reg [4:0] f_cpu_delay;",
            "reg [((1<<(LGLINES))-1):0] f_past_valid_mask;",
            "reg [(AW+1):0] f_next_pc;",
            "reg [AW+1:0] f_next_lastpc;",
            "reg [AW-1:0] f_cklast, f_ckfirst;",
            "reg [AW-1:0] next_addr; // Keep track of a flag telling us whether or not $past() // will return valid results",
            "initial f_past_valid = 1'b0;",
            "always @(posedge S_AXI_ACLK) f_past_valid = 1'b1;",
            "always @(*) if (!S_AXI_ARESETN) assume(i_cpu_reset); //////////////////////////////////////////////////////////////////////// // // Assumptions about our",
            "input s // {{{ //////////////////////////////////////////////////////////////////////// // // wire [AW-1:0] f_const_addr, f_address;",
            "wire f_const_illegal;",
            "wire [INSN_WIDTH-1:0] f_const_insn; // // Assume/assert the properties of the PF <-> CPU interface // ffetch #(.ADDRESS_WIDTH(AW-LGINSN)) fcpu(.i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset), .cpu_new_pc(i_new_pc), .cpu_clear_cache(i_clear_cache), .cpu_pc(i_pc), .cpu_ready(i_ready), .pf_valid(o_valid), .pf_insn(o_insn), .pf_pc(o_pc), .pf_illegal(o_illegal), .fc_pc(f_const_addr), .fc_illegal(f_const_illegal), .fc_insn(f_const_insn), .f_address(f_address));",
            "always @(*) if (!i_cpu_reset && !i_new_pc && !i_clear_cache) assert(o_pc == f_address); // // Let's make some assumptions about how long it takes our // phantom bus and phantom CPU to respond. // // These delays need to be long enough to flush out any potential // errors, yet still short enough that the formal method doesn't // take forever to solve. // localparam F_CPU_DELAY = 4; // Now, let's repeat this bit but now looking at the delay the CPU // takes to accept an instruction.",
            "always @(posedge S_AXI_ACLK) // If no instruction is ready, then keep our counter at zero if ((!o_valid)||(i_ready)) f_cpu_delay <= 0; else // Otherwise, count the clocks the CPU takes to respond f_cpu_delay <= f_cpu_delay + 1'b1;",
            "always @(posedge S_AXI_ACLK) assume(f_cpu_delay < F_CPU_DELAY); // }}} //////////////////////////////////////////////////////////////////////// // // Formal AXI bus properties // {{{ //////////////////////////////////////////////////////////////////////// // // localparam F_LGDEPTH=12;",
            "wire M_AXI_AWREADY = 0, M_AXI_WREADY = 0, M_AXI_BVALID = 0;",
            "wire [C_AXI_ID_WIDTH-1:0] M_AXI_BID = 0;",
            "wire [1:0] M_AXI_BRESP = 0;",
            "wire [F_LGDEPTH-1:0] faxi_awr_nbursts, faxi_wr_pending, faxi_rd_nbursts, faxi_rd_outstanding;",
            "wire [C_AXI_ID_WIDTH-1:0] faxi_rd_checkid;",
            "wire faxi_rd_ckvalid;",
            "wire [9-1:0] faxi_rd_cklen;",
            "wire [AW-1:0] faxi_rd_ckaddr;",
            "wire [7:0] faxi_rd_ckincr;",
            "wire [1:0] faxi_rd_ckburst;",
            "wire [2:0] faxi_rd_cksize;",
            "wire [7:0] faxi_rd_ckarlen;",
            "wire faxi_rd_cklockd; // wire [F_LGDEPTH-1:0] faxi_rdid_nbursts, faxi_rdid_outstanding, faxi_rdid_ckign_nbursts, faxi_rdid_ckign_outstanding; faxi_master #( // {{{ .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH), .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .OPT_NARROW_BURST(1'b0), .OPT_ASYNC_RESET(1'b0), // We don't use asynchronous resets .OPT_EXCLUSIVE(1'b0), // We don't use the LOCK signal .F_OPT_ASSUME_RESET(1'b1), // We aren't generating the reset .F_OPT_NO_RESET(1'b1), .F_LGDEPTH(F_LGDEPTH) // Width of the counters // }}} ) faxi( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // Write signals // {{{ .i_axi_awvalid(1'b0), .i_axi_awready(M_AXI_AWREADY), .i_axi_awid( M_AXI_ARID), .i_axi_awaddr( M_AXI_ARADDR), .i_axi_awlen( M_AXI_ARLEN), .i_axi_awsize( M_AXI_ARSIZE), .i_axi_awburst(M_AXI_ARBURST), .i_axi_awlock( M_AXI_ARLOCK), .i_axi_awcache(M_AXI_ARCACHE), .i_axi_awprot( M_AXI_ARPROT), .i_axi_awqos( M_AXI_ARQOS), // .i_axi_wvalid(1'b0), .i_axi_wready(M_AXI_WREADY), .i_axi_wdata( {(C_AXI_DATA_WIDTH ){1'b0}}), .i_axi_wstrb( {(C_AXI_DATA_WIDTH/8){1'b0}}), .i_axi_wlast( 1'b0), // .i_axi_bvalid(M_AXI_BVALID), .i_axi_bready(1'b1), .i_axi_bid( M_AXI_BID), .i_axi_bresp( M_AXI_BRESP), // }}} // Read signals // {{{ .i_axi_arvalid(M_AXI_ARVALID), .i_axi_arready(M_AXI_ARREADY), .i_axi_arid( M_AXI_ARID), .i_axi_araddr( M_AXI_ARADDR), .i_axi_arlen( M_AXI_ARLEN), .i_axi_arsize( M_AXI_ARSIZE), .i_axi_arburst(M_AXI_ARBURST), .i_axi_arlock( M_AXI_ARLOCK), .i_axi_arcache(M_AXI_ARCACHE), .i_axi_arprot( M_AXI_ARPROT), .i_axi_arqos( M_AXI_ARQOS), // // .i_axi_rvalid(M_AXI_RVALID), .i_axi_rready(M_AXI_RREADY), .i_axi_rid( M_AXI_RID), .i_axi_rdata( M_AXI_RDATA), .i_axi_rlast( M_AXI_RLAST), .i_axi_rresp( M_AXI_RRESP), // }}} // Induction signals // {{{ .f_axi_awr_nbursts(faxi_awr_nbursts), .f_axi_wr_pending(faxi_wr_pending), .f_axi_rd_nbursts(faxi_rd_nbursts), .f_axi_rd_outstanding(faxi_rd_outstanding), // .f_axi_rd_checkid(faxi_rd_checkid), .f_axi_rd_ckvalid(faxi_rd_ckvalid), .f_axi_rd_cklen( faxi_rd_cklen), .f_axi_rd_ckaddr( faxi_rd_ckaddr), .f_axi_rd_ckincr( faxi_rd_ckincr), .f_axi_rd_ckburst(faxi_rd_ckburst), .f_axi_rd_cksize( faxi_rd_cksize), .f_axi_rd_ckarlen(faxi_rd_ckarlen), .f_axi_rd_cklockd(faxi_rd_cklockd), .f_axi_rdid_nbursts( faxi_rdid_nbursts), .f_axi_rdid_outstanding( faxi_rdid_outstanding), .f_axi_rdid_ckign_nbursts( faxi_rdid_ckign_nbursts), .f_axi_rdid_ckign_outstanding(faxi_rdid_ckign_outstanding) // }}} // }}} );",
            "always @(*) begin assert(faxi_awr_nbursts == 0); assert(faxi_wr_pending == 0); end",
            "always @(*) begin if (faxi_rd_checkid == AXI_ID) begin assert(faxi_rdid_nbursts == faxi_rd_nbursts); assert(faxi_rdid_outstanding == faxi_rd_outstanding); end else begin assert(faxi_rdid_nbursts == 0); assert(faxi_rdid_outstanding == 0); end assert(faxi_rd_nbursts <= 1); assert(faxi_rd_outstanding <= (1<<LS)); assert(faxi_rd_nbursts == 0 || !M_AXI_ARVALID); end",
            "always @(*) assert(request_pending == (M_AXI_ARVALID || faxi_rd_outstanding > 0));",
            "always @(*) begin f_cklast = faxi_rd_ckaddr; f_cklast[AW-1:ADDRLSB] = f_cklast[AW-1:ADDRLSB] + faxi_rd_cklen - 1; f_cklast[ADDRLSB-1:0] = 0; f_ckfirst = faxi_rd_ckaddr; f_ckfirst[LSB-1:ADDRLSB] = f_ckfirst[LSB-1:ADDRLSB] + faxi_rd_cklen; end",
            "always @(*) if (faxi_rd_ckvalid) begin assert(faxi_rd_ckarlen == M_AXI_ARLEN); assert(faxi_rd_cksize == M_AXI_ARSIZE); assert(faxi_rd_ckburst == M_AXI_ARBURST); assert(!faxi_rd_cklockd); assert(faxi_rd_ckaddr[AW-1:LSB] == axi_araddr[AW-1:LSB]); assert(write_posn == faxi_rd_ckaddr[LSB-1:ADDRLSB]); if (!OPT_WRAP) // If we aren't in wrap mode, then the last address // should be the last address in a cache line assert(&f_cklast[LSB-1:ADDRLSB]); end else if (!OPT_WRAP) begin assume(!M_AXI_RVALID || (M_AXI_RLAST == (&f_cklast[AW-1:LSB]))); if (faxi_rd_outstanding > 0) assert(write_posn + faxi_rd_outstanding == (1<<LS)); end",
            "always @(*) if (!OPT_WRAP && faxi_rd_nbursts > 0) assert(bus_abort || last_pc[AW-1:LSB] == axi_araddr[AW-1:LSB]);",
            "always @(*) begin next_addr = o_pc + (1<<LGINSN); next_addr[LGINSN-1:0] = 0; end",
            "always @(*) if (!i_cpu_reset && !i_new_pc && !i_clear_cache && !o_illegal) assert(last_pc == o_pc);",
            "always @(*) if (!i_cpu_reset && !i_new_pc && !i_clear_cache) assert(next_addr == i_pc); `ifdef DEPRECATED",
            "assign illegal_addr = { illegal_tag, {(LSB){1'b0}} };",
            "assign bus_tag = axi_araddr[AW-1:LSB];",
            "assign o_tag = o_pc[AW-1:LSB];",
            "assign i_tag = i_pc[AW-1:LSB];",
            "assign lastpc_tag= last_pc[AW-1:LSB]; `endif // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about our return responses to the CPU // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge S_AXI_ACLK) if (f_past_valid && $past(i_clear_cache || i_cpu_reset)) begin assert(cache_valid == 0); assert(!o_valid); assert(!illegal_valid); end",
            "always @(posedge S_AXI_ACLK) if (S_AXI_ARESETN && o_valid && !o_illegal && !request_pending && $past(!o_valid || i_ready)) begin if (!$past(wrap_valid)) begin if ($past(i_new_pc || (o_valid && i_ready))) begin assert(pc_valid); assert(pc_tag == o_pc[AW-1:LSB]); end else begin assert(last_valid); assert(last_tag == o_pc[AW-1:LSB]); end end end // }}} //////////////////////////////////////////////////////////////////////// // // Contract checking // {{{ //////////////////////////////////////////////////////////////////////// // // (* anyconst *)",
            "reg [DW-1:0] fc_line; // // 1. Assume a known response to a known address // {{{ generate if (INSN_WIDTH == C_AXI_DATA_WIDTH) begin",
            "always @(*) assume(fc_line == f_const_insn); end else begin : SHIFT_FC_LINE",
            "reg [DW-1:0] shifted_line;",
            "always @(*) shifted_line = fc_line >> (INSN_WIDTH * f_const_addr[ADDRLSB-1:LGINSN]);",
            "always @(*) assume(shifted_line[INSN_WIDTH-1:0] == f_const_insn); end endgenerate",
            "always @(*) if (M_AXI_RVALID && axi_araddr[AW-1:LSB] == f_const_addr[AW-1:LSB]) assume(f_const_illegal == M_AXI_RRESP[1]); generate if (SWAP_ENDIANNESS) begin : ASSUME_BIG_TO_LITTLE_ENDIAN",
            "always @(*) if (M_AXI_RVALID && {axi_araddr[AW-1:LSB], write_posn} == f_const_addr[AW-1:ADDRLSB]) begin if (!M_AXI_RRESP[1]) assume(BIG_TO_LITTLE_ENDIAN.swapped_data == fc_line); end end else begin : ASSUME_BUS_ENDIAN",
            "always @(*) if (M_AXI_RVALID && {axi_araddr[AW-1:LSB], write_posn} == f_const_addr[AW-1:ADDRLSB]) begin if (!M_AXI_RRESP[1]) assume(M_AXI_RDATA == fc_line); end end endgenerate // }}} // // 2. Assert that if the known address is in the cache, the data must be // the correct data // {{{",
            "always @(*) if (cache_valid[f_const_addr[CWB-1:LSB]] && cache_tags[f_const_addr[CWB-1:LSB]] == f_const_addr[AW-1:CWB]) assert(cache[f_const_addr[CWB-1:ADDRLSB]] == fc_line); generate if (OPT_WRAP) begin : GEN_WRAPCHECK // {{{",
            "reg f_wrap_written;",
            "reg [LS-1:0] f_wrap_distance;",
            "always @(*) begin // f_const_addr[CWB-1:LSB]] f_wrap_distance= f_const_addr[LSB-1:ADDRLSB]-write_posn; f_wrap_written = f_wrap_distance > faxi_rd_outstanding; if (M_AXI_ARVALID) f_wrap_written = 0; end",
            "always @(*) if (!f_const_illegal && request_pending && faxi_rd_nbursts > 0 && f_wrap_written && !cache_valid[f_const_addr[CWB-1:LSB]] && axi_araddr[AW-1:LSB] == f_const_addr[AW-1:LSB]) begin assert(cache[f_const_addr[CWB-1:ADDRLSB]] == fc_line); end // }}} end endgenerate",
            "always @(*) if (f_const_illegal) assert(!cache_valid[f_const_addr[CWB-1:LSB]] || cache_tags[f_const_addr[CWB-1:LSB]] != f_const_addr[AW-1:CWB]); else assert(!illegal_valid || illegal_tag != f_const_addr[AW-1:LSB]); // // Anything else in a line with one illegal element must also be illegal",
            "always @(*) if (o_valid && o_pc[AW-1:LSB] == f_const_addr[AW-1:LSB] && f_const_illegal) assert(o_illegal); // }}} // // 3. If our chosen address is ever returned, assert that it contains // the correct data and illegal flag within it // {{{ // Captured inside ffetch above // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // reg f_valid_legal;",
            "reg [LGLINESZ+2:0] cvr_valids, cvr_consecutive, cvr_resets;",
            "always @(*) f_valid_legal = o_valid && (!o_illegal);",
            "initial cvr_valids = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) cvr_valids <= 0; else if (i_cpu_reset || i_clear_cache || i_new_pc || o_illegal) cvr_valids <= 0; else if (o_valid && i_ready && !cvr_valids[LGLINESZ+2]) cvr_valids <= cvr_valids + 1;",
            "initial cvr_resets = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) cvr_resets <= 0; else if (i_cpu_reset || i_clear_cache || i_new_pc || o_illegal) cvr_resets <= cvr_resets + 1;",
            "always @(*) if (S_AXI_ARESETN && i_cpu_reset && !i_clear_cache && !i_new_pc && !o_illegal) cover(cvr_valids == (1<<(LGLINESZ+1)));",
            "always @(posedge S_AXI_ACLK) // Trace 0 cover((o_valid)&&( o_illegal));",
            "always @(posedge S_AXI_ACLK) // Trace 1 cover(f_valid_legal);",
            "always @(posedge S_AXI_ACLK) // Trace 2 cover((f_valid_legal) &&($past(!o_valid && !i_new_pc)) &&($past(i_new_pc,2)));",
            "always @(posedge S_AXI_ACLK) // Trace 3 cover((f_valid_legal)&&($past(i_ready))&&($past(i_new_pc)));",
            "always @(posedge S_AXI_ACLK) // Trace 4 cover((f_valid_legal)&&($past(f_valid_legal && i_ready)));",
            "always @(posedge S_AXI_ACLK) // Trace 5 cover((f_valid_legal) &&($past(f_valid_legal && i_ready)) &&($past(f_valid_legal && i_ready,2)) &&($past(f_valid_legal && i_ready,3)));",
            "always @(posedge S_AXI_ACLK) // Trace 6 cover((f_valid_legal) &&($past(f_valid_legal && i_ready)) &&($past(f_valid_legal && i_ready,2)) &&($past(!o_illegal && i_ready && i_new_pc,3)) &&($past(f_valid_legal && i_ready,4)) &&($past(f_valid_legal && i_ready,5)) &&($past(f_valid_legal && i_ready,6)));",
            "always @(posedge S_AXI_ACLK) // Trace 7 cover((f_valid_legal) &&($past(f_valid_legal && i_ready)) &&($past(!o_illegal && i_ready,2)) &&($past(!o_illegal && i_ready && i_new_pc,3)) &&($past(f_valid_legal && i_ready,4)) &&($past(f_valid_legal && i_ready,5)) &&($past(f_valid_legal && i_ready,6)));",
            "always @(*) begin cover(cvr_valids == (1<<(LGLINESZ+1))); cover(cvr_valids == 4'b0101); cover(cvr_valids == (1<<(LGLINESZ+1)) + (1<<(LGLINESZ))); cover((cvr_valids == (1<<(LGLINESZ+1)) + (1<<(LGLINESZ))) && (cvr_resets == 1)); end generate if (OPT_WRAP) begin : CVR_WRAP // Cover properties for OPT_WRAP // {{{",
            "reg [LGLINESZ+2:0] cvr_wrap_count, cvr_wrap_valid;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || i_new_pc || i_clear_cache|| M_AXI_ARVALID) cvr_wrap_count <= 0; else if (wrap_valid && (!o_valid || i_ready)) cvr_wrap_count <= cvr_wrap_count + 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || i_new_pc || i_clear_cache|| M_AXI_ARVALID || !o_valid) // || !wrap_valid) cvr_wrap_valid <= 0; else if (!cvr_wrap_valid[LGLINESZ+2] && o_valid && i_ready) cvr_wrap_valid <= cvr_wrap_valid + 1;",
            "always @(*) if (S_AXI_ARESETN && !i_new_pc && !i_clear_cache && !o_illegal) cover(o_valid && cvr_wrap_valid == (1<<(LGLINESZ-1)));",
            "always @(*) if (S_AXI_ARESETN && !i_new_pc && !i_clear_cache && !o_illegal) cover(o_valid && cvr_wrap_valid == (1<<(LGLINESZ-1)));",
            "always @(*) if (S_AXI_ARESETN && !i_new_pc && !i_clear_cache && !o_illegal) cover(o_valid && cvr_wrap_valid == (1<<(LGLINESZ)));",
            "always @(*) if (S_AXI_ARESETN && !i_new_pc && !i_clear_cache && !o_illegal) cover(o_valid && cvr_wrap_valid == (1<<(LGLINESZ)) + (1<<(LGLINESZ-1)));",
            "always @(*) if (S_AXI_ARESETN && !i_new_pc && !i_clear_cache && !o_illegal) cover(o_valid && cvr_wrap_count == (1<<(LGLINESZ-1)));",
            "always @(*) if (S_AXI_ARESETN && M_AXI_RVALID) assume(faxi_rd_ckvalid); // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Illegal instruction checks // {{{ //////////////////////////////////////////////////////////////////////// // // (* anyconst *)",
            "reg f_never_illegal, f_",
            "always _illegal;",
            "always @(*) assume(!f_never_illegal || !f_",
            "always _illegal);",
            "always @(*) if (M_AXI_RVALID) begin assume(!f_never_illegal || !M_AXI_RRESP[1]); assume(!f_",
            "always _illegal || M_AXI_RRESP[1]); end",
            "always @(*) if (f_",
            "always _illegal && o_valid) assert(o_illegal);",
            "always @(*) if (f_",
            "always _illegal) assert(cache_valid == 0);",
            "always @(*) if (f_never_illegal) assert(!illegal_valid);",
            "always @(*) if (f_never_illegal) assert(!o_illegal); // }}} //////////////////////////////////////////////////////////////////////// // // Constraining assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // // None currently // }}} `endif // FORMAL // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "prefetch.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/prefetch.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: prefetch.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This is a very simple instruction fetch approach. It gets // one instruction at a time. Future versions should pipeline // fetches and perhaps even cache results--this doesn't do that. It // should, however, be simple enough to get things running. // // The interface is fascinating. The 'i_pc'",
            "input wire is just a // suggestion of what to load. Other",
            "wire s may be loaded instead. i_pc // is what must be",
            "output , not necessarily",
            "input . // // 20150919 -- Added support for the WB error signal. When reading an // instruction results in this signal being raised, the pipefetch",
            "module // will set an illegal instruction flag to be returned to the CPU together // with the instruction. Hence, the ZipCPU can trap on it if necessary. // // 20171020 -- Added a formal proof to prove that the",
            "module works. This // also involved adding a req_addr",
            "reg ister, and the",
            "logic associated // with it. // // 20171113 -- Removed the req_addr",
            "reg ister, replacing it with a bus abort // capability. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module prefetch #( // {{{",
            "parameter ADDRESS_WIDTH=30, // Byte addr wid INSN_WIDTH=32, DATA_WIDTH=INSN_WIDTH, localparam AW=ADDRESS_WIDTH, DW=DATA_WIDTH, parameter [0:0] OPT_ALIGNED = 1'b0, parameter [0:0] OPT_LITTLE_ENDIAN = 1'b1 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // CPU interaction",
            "wire s",
            "input wire i_new_pc, i_clear_cache, i_ready, // We ignore i_pc unless i_new_pc is true as well",
            "input wire [AW-1:0] i_pc, output reg o_valid, // If",
            "output is valid",
            "output reg o_illegal, // bus err result",
            "output reg [INSN_WIDTH-1:0] o_insn, // Insn read from WB",
            "output reg [AW-1:0] o_pc, // Byt addr of that insn // Wishbone",
            "output s",
            "output reg o_wb_cyc, o_wb_stb, // verilator coverage_off",
            "output wire o_wb_we, // == const 0 // verilator coverage_on",
            "output reg [AW-$clog2(DW/8)-1:0] o_wb_addr, // verilator coverage_off",
            "output wire [DW-1:0] o_wb_data, // == const 0 // verilator coverage_on // And return",
            "input s",
            "input wire i_wb_stall, i_wb_ack, i_wb_err, input wire [DW-1:0] i_wb_data // }}} ); // Declare local variables // {{{",
            "reg invalid;",
            "wire r_valid;",
            "wire [DATA_WIDTH-1:0] r_insn, i_wb_shifted; // }}} // These are kind of obligatory",
            "output s when dealing with a bus, that // we'll set them here. Nothing's going to pay attention to these, // though, this is primarily for form.",
            "assign o_wb_we = 1'b0;",
            "assign o_wb_data = {(DATA_WIDTH){1'b0}}; // o_wb_cyc, o_wb_stb // {{{ // Let's build it simple and upgrade later: For each instruction // we do one bus cycle to get the instruction. Later we should // pipeline this, but for now let's just do one at a time.",
            "initial o_wb_cyc = 1'b0;",
            "initial o_wb_stb = 1'b0;",
            "always @(posedge i_clk) if ((i_reset || i_clear_cache)||(o_wb_cyc &&(i_wb_ack||i_wb_err))) begin // {{{ // End any bus cycle on a reset, or a return ACK // or error. o_wb_cyc <= 1'b0; o_wb_stb <= 1'b0; // }}} end else if (!o_wb_cyc &&( // Start if the last instruction",
            "output was // accepted, *and* it wasn't a bus error // response (i_ready && !o_illegal && !r_valid) // Start if the last bus result ended up // invalid ||(invalid) // Start on any request for a new address ||i_new_pc)) begin // {{{ // Initiate a bus transaction o_wb_cyc <= 1'b1; o_wb_stb <= 1'b1; // }}} end else if (o_wb_cyc) begin // {{{ // If our request has been accepted, then drop the // strobe line if (!i_wb_stall) o_wb_stb <= 1'b0; // Abort on new-pc // ... clear_cache is identical, save that it will // immediately be followed by a new PC, so we don't // need to worry about that other than to drop // CYC and STB here. if (i_new_pc) begin o_wb_cyc <= 1'b0; o_wb_stb <= 1'b0; end // }}} end // }}} // invalid // {{{ // If during the current bus request, a command came in from the CPU // that will invalidate the results of that request, then we need to // keep track of an \"invalid\" flag to remember that and so squash // the result. // initial invalid = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !o_wb_cyc) invalid <= 1'b0; else if (i_new_pc) invalid <= 1'b1; // }}} // The wishbone request address, o_wb_addr // {{{ // The rule",
            "reg arding this address is that it can *only* be changed // when no bus request is active. Further, since the CPU is depending // upon this value to know what \"PC\" is associated with the instruction // it is processing, we can't change until either the CPU has accepted // our result, or it is requesting a new PC (and hence not using the // output ). // initial o_wb_addr= 0;",
            "always @(posedge i_clk) if (i_new_pc) o_wb_addr <= i_pc[AW-1:$clog2(DATA_WIDTH/8)]; else if (o_valid && i_ready && !r_valid) o_wb_addr <= o_wb_addr + 1'b1; // }}} //////////////////////////////////////////////////////////////////////// // // (Optionally) shift the",
            "output word into place // {{{ //////////////////////////////////////////////////////////////////////// // // // This only applies when the bus size doesn't match the instruction // word size. Here, we only support bus sizes greater than the // instruction word size. `ifdef FORMAL",
            "wire [DATA_WIDTH-1:0] f_bus_word; `endif generate if (DATA_WIDTH > INSN_WIDTH) begin : GEN_SUBSHIFT // {{{",
            "localparam NSHIFT = $clog2(DATA_WIDTH/INSN_WIDTH);",
            "reg rg_valid;",
            "reg [DATA_WIDTH-1:0] rg_insn;",
            "reg [NSHIFT:0] r_count;",
            "reg [NSHIFT-1:0] r_shift; // rg_valid // {{{",
            "always @(posedge i_clk) if (i_reset || i_new_pc || i_clear_cache) rg_valid <= 1'b0; else if (r_count <= ((o_valid && i_ready) ? 1:0)) begin rg_valid <= 1'b0; if (o_wb_cyc && i_wb_ack && !(&r_shift)) rg_valid <= 1'b1; end // }}} // rg_insn // {{{",
            "always @(posedge i_clk) if (i_wb_ack && (r_count <= ((o_valid && i_ready) ? 1:0))) begin rg_insn <= i_wb_data; if (OPT_LITTLE_ENDIAN) begin rg_insn <= i_wb_shifted >> INSN_WIDTH; end else begin rg_insn <= i_wb_shifted << INSN_WIDTH; end end else if (o_valid && i_ready) begin if (OPT_LITTLE_ENDIAN) rg_insn <= rg_insn >> INSN_WIDTH; else rg_insn <= rg_insn << INSN_WIDTH; end // }}} // r_count // {{{",
            "always @(posedge i_clk) if (i_reset || i_new_pc || i_clear_cache) r_count <= 0; // Verilator lint_off CMPCONST else if (o_valid && i_ready && r_valid) // Verilator lint_on CMPCONST r_count <= r_count - 1; else if (o_wb_cyc && i_wb_ack) begin // if (OPT_LITTLE_ENDIAN) r_count <= { 1'b0, ~r_shift }; end `ifdef FORMAL",
            "always @(*) if (!i_reset) begin assert(r_valid == (r_count > 0)); assert(r_count <= (1<<NSHIFT)); if (r_valid) begin assert(!o_wb_cyc); assert(r_shift == 0); end else if (!i_new_pc && !i_clear_cache && !o_illegal) assert(invalid || o_valid || o_wb_cyc); end `endif // }}} // r_shift // {{{",
            "always @(posedge i_clk) if (i_reset) r_shift <= 0; else if (i_new_pc) r_shift <= i_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)]; else if (o_wb_cyc && (i_wb_ack || i_wb_err)) r_shift <= 0; `ifdef FORMAL",
            "always @(*) if (!i_reset && r_shift > 0) assert(!o_valid && !r_valid); `endif // }}}",
            "assign r_valid = rg_valid;",
            "assign r_insn = rg_insn; if (OPT_LITTLE_ENDIAN) begin : GEN_LIL_ENDIAN_SHIFT",
            "assign i_wb_shifted = i_wb_data >> (r_shift * INSN_WIDTH); end else begin : GEN_BIG_ENDIAN_SHIFT",
            "assign i_wb_shifted = i_wb_data << (r_shift * INSN_WIDTH); end // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_shift;",
            "assign unused_shift = &{ 1'b0, r_insn[DATA_WIDTH-1:INSN_WIDTH], i_wb_shifted[DATA_WIDTH-1:INSN_WIDTH] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} `ifdef FORMAL",
            "assign f_bus_word = rg_insn << ((r_count-1)* INSN_WIDTH);",
            "always @(*) if (!i_reset && r_valid) begin assert(o_valid); assert(r_shift == 0); // assert((r_count + o_pc[NSHIFT-1:0]) == ((1<<NSHIFT)-1)); assert((r_count + o_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)]) == ((1<<NSHIFT)-1)); end else if (!i_reset && o_wb_cyc && !invalid) begin assert(r_shift == o_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)]); end `endif // }}} end else begin : NO_SUBSHIFT // {{{",
            "assign r_valid = 1'b0;",
            "assign r_insn = {(INSN_WIDTH){1'b0}};",
            "assign i_wb_shifted = i_wb_data; `ifdef FORMAL",
            "assign f_bus_word = 0; `endif // Verilator lint_off UNUSED",
            "wire unused_shift;",
            "assign unused_shift = &{ 1'b0, OPT_LITTLE_ENDIAN }; // Verilator lint_on UNUSED // }}} end endgenerate // }}} // o_insn // {{{ // The instruction returned is given by the data returned from the bus.",
            "always @(posedge i_clk) if (i_wb_ack) begin if (OPT_LITTLE_ENDIAN) o_insn <= i_wb_shifted[INSN_WIDTH-1:0]; else o_insn <= i_wb_shifted[DW-1:DW-INSN_WIDTH]; end else if (i_ready && (DATA_WIDTH != INSN_WIDTH)) begin if (OPT_LITTLE_ENDIAN) o_insn <= r_insn[INSN_WIDTH-1:0]; else o_insn <= r_insn[DW-1:DW-INSN_WIDTH]; end `ifdef FORMAL",
            "always @(posedge i_clk) if (!i_reset && o_valid) assert(!i_wb_ack); `endif // }}} // o_valid, o_illegal // {{{ // Finally, the flags associated with the prefetch. The rule is that // if the",
            "output represents a return from the bus, then o_valid needs // to be true. o_illegal will be true any time the last bus request // resulted in an error. o_illegal is only relevant to the CPU when // o_valid is also true, hence o_valid will be true even in the case // of a bus error in our request. // initial o_valid = 1'b0;",
            "initial o_illegal = 1'b0;",
            "always @(posedge i_clk) if (i_reset || i_new_pc || i_clear_cache) begin // On any reset, request for a new PC (i.e. a branch), // or a request to clear our cache (i.e. the data // in memory may have changed), we invalidate any // output . o_valid <= 1'b0; o_illegal <= 1'b0; end else if (o_wb_cyc &&(i_wb_ack || i_wb_err)) begin // Otherwise, at the end of our bus cycle, the // answer will be valid. Well, not quite. If the // user requested something mid-cycle (i_new_pc) // or (i_clear_cache), then we'll have to redo the // bus request, so we aren't valid. // o_valid <= 1'b1; o_illegal <= ( i_wb_err); end else if (i_ready) begin // Once the CPU accepts any result we produce, clear // the valid flag, lest we send two identical // instructions to the CPU. // o_valid <= r_valid; // // o_illegal doesn't change ... that way we don't // access the bus again until a new address request // is given to us, via i_new_pc, or we are asked // to check again via i_clear_cache // // o_illegal <= (!i_ready); end // }}} // The o_pc",
            "output shares its value with the (last) wishbone address // {{{ generate if (OPT_ALIGNED && (INSN_WIDTH == DATA_WIDTH)) begin : ALIGNED_PF_PC // {{{",
            "always @(*) o_pc = { o_wb_addr, {($clog2(DATA_WIDTH/8)){1'b0}} }; // }}} end else begin : GENERATE_PF_PC // {{{",
            "initial o_pc = 0;",
            "always @(posedge i_clk) if (i_new_pc) o_pc <= i_pc; else if (o_valid && i_ready) begin o_pc <= 0; o_pc[AW-1:$clog2(INSN_WIDTH/8)] <= o_pc[AW-1:$clog2(INSN_WIDTH/8)] + 1; end // }}} end endgenerate `ifdef FORMAL",
            "always @(*) if (!i_reset && !o_illegal && !i_new_pc && !i_clear_cache) assert(o_pc[AW-1:$clog2(DATA_WIDTH/8)] == o_wb_addr); `endif // }}} // Make verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_pc[1:0] }; // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Declarations // {{{",
            "localparam F_LGDEPTH=2;",
            "reg f_past_valid;",
            "wire [(F_LGDEPTH-1):0] f_nreqs, f_nacks, f_outstanding;",
            "reg [AW-$clog2(DATA_WIDTH/8)-1:0] f_req_addr;",
            "wire [AW-$clog2(DATA_WIDTH/8)-1:0] f_next_wb_addr; // Keep track of a flag telling us whether or not $past() // will return valid results",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; // }}} //////////////////////////////////////////////////////////////////////// // // Bus interface properties // {{{ //////////////////////////////////////////////////////////////////////// // // fwb_master #( // {{{ .AW(AW-$clog2(DATA_WIDTH/8)), .DW(DW),.F_LGDEPTH(F_LGDEPTH), .F_MAX_REQUESTS(1), .F_OPT_SOURCE(1), .F_OPT_RMW_BUS_OPTION(0), .F_OPT_DISCONTINUOUS(0) // }}} ) f_wbm( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_wb_cyc(o_wb_cyc), .i_wb_stb(o_wb_stb), .i_wb_we(o_wb_we), .i_wb_addr(o_wb_addr), .i_wb_data(o_wb_data), .i_wb_sel({($clog2(DW/8)){1'b0}}), .i_wb_ack(i_wb_ack), .i_wb_stall(i_wb_stall), .i_wb_idata(i_wb_data), .i_wb_err(i_wb_err), .f_nreqs(f_nreqs), .f_nacks(f_nacks), .f_outstanding(f_outstanding) // }}} ); // }}} //////////////////////////////////////////////////////////////////////// // // CPU interface properties // {{{ ///////////////////////////////////////////////// // // wire f_const_illegal;",
            "wire [AW-1:0] f_const_addr;",
            "wire [DW-1:0] f_const_insn;",
            "wire [AW-1:0] f_address; ffetch #( // {{{ .ADDRESS_WIDTH(AW-$clog2(INSN_WIDTH/8)), .OPT_ALIGNED(OPT_ALIGNED), .INSN_WIDTH(INSN_WIDTH) // }}} ) cpu( // {{{ .i_clk(i_clk), .i_reset(i_reset), .cpu_new_pc(i_new_pc), .cpu_clear_cache(i_clear_cache), .cpu_pc(i_pc), .pf_valid(o_valid), .cpu_ready(i_ready), .pf_pc(o_pc), .pf_insn(o_insn), .pf_illegal(o_illegal), .fc_pc(f_const_addr), .fc_illegal(f_const_illegal), .fc_insn(f_const_insn), .f_address(f_address) // }}} );",
            "always @(*) if (!i_reset && !i_new_pc && !i_clear_cache && !o_illegal) assert(f_address == o_pc);",
            "always @(*) if (o_illegal) assert(!o_wb_cyc); // // // Let's make some assumptions about how long it takes our // phantom bus and phantom CPU to respond. // // These delays need to be long enough to flush out any potential // errors, yet still short enough that the formal method doesn't // take forever to solve. // localparam F_CPU_DELAY = 4;",
            "reg [4:0] f_cpu_delay; // First, let's assume that any response from the bus comes back // within F_WB_DELAY clocks // Here's our delay assumption: We'll assume that the // wishbone will",
            "always respond within F_WB_DELAY clock ticks // of the beginning of any cycle. // // This includes both dropping the stall line, as well as // acknowledging any request. While this may not be // a reasonable assumption for a piped master, it should // work here for us. // Count the number of clocks it takes the CPU to respond to our // instruction.",
            "always @(posedge i_clk) // If no instruction is ready, then keep our counter at zero if ((i_reset)||(!o_valid)||(i_ready)) f_cpu_delay <= 0; else // Otherwise, count the clocks the CPU takes to respond f_cpu_delay <= f_cpu_delay + 1'b1; `ifdef PREFETCH // Only *assume* that we are less than F_CPU_DELAY if we are not // integrated into the CPU",
            "always @(posedge i_clk) assume(f_cpu_delay < F_CPU_DELAY); `endif // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about our",
            "output s // {{{ ///////////////////////////////////////////////// // // Assertions about our wishbone control",
            "output s first // Prefetches don't write",
            "always @(*) assert(!o_wb_we);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(f_past_valid)) &&($past(i_clear_cache,2)) &&($past(o_wb_cyc,2))) // Make sure any clear-cache transaction is aborted, // *and* that no valid instructions get sent to the // CPU assert((!$past(o_wb_cyc))||(!o_wb_cyc));",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_valid && !r_valid))&&(o_valid)) assert(o_wb_addr == $past(o_wb_addr));",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(!i_reset && !i_clear_cache))&&($past(invalid))) assert(o_wb_cyc); // Any time the CPU accepts an instruction, assert that on the // valid line will be low on the next clock",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_valid && i_ready && !r_valid))) assert(!o_valid); // Since we only change our",
            "output on a response from the bus, we // need to insist that the item has been read by the CPU before // we go looking/asking for a next value. // // This routine should never be requesting a new instruction when // one is valid--lest the CPU never accept the old instruction and we // have nothing to do with the data when the bus request returns.",
            "always @(*) if (o_wb_cyc) assert(!o_valid && !r_valid); // If we just got a valid instruction from the wishbone, assert that // the instruction is listed as valid on the next instruction cycle",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&($past(o_wb_cyc)) &&($past(!i_clear_cache)) &&($past(i_wb_ack))&&(!$past(i_wb_err))) begin if (!invalid) assert(o_valid); end",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_clear_cache))) assert(!o_valid);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(f_past_valid)) &&($past(i_clear_cache,2)) &&($past(o_wb_cyc,2))) // Make sure any clear-cache transaction is aborted, // *and* that no valid instructions get sent to the // CPU assert(!o_valid); // // Assertions about our return responses // always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&(!$past(i_new_pc))&&(!$past(i_clear_cache)) &&($past(o_valid))&&(!$past(i_ready))) assert(o_valid == $past(o_valid)); // always @(posedge i_clk) // if ((f_past_valid)&&($past(o_valid))&&(o_valid)) // begin // assert($stable(o_pc)); // assert($stable(o_insn)); // assert($stable(o_illegal)); // end // // The o_illegal line is the one we use to remind us not to go // back and retry the last value if it returned a bus error. Hence, // let's assert that this line stays constant any time o_wb_cyc // is low, and we haven't received any new requests.",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&(!$past(i_new_pc))&&(!$past(i_clear_cache)) &&($past(!o_wb_cyc))) assert(o_illegal == $past(o_illegal)); // // // Let's examine whether or not we \"walk\" though PC addresses one // at a time like we expect. // // f_req_addr // {{{",
            "initial f_req_addr = 0;",
            "always @(posedge i_clk) if (i_new_pc) f_req_addr <= i_pc[AW-1:$clog2(DATA_WIDTH/8)]; else if (!invalid && o_wb_cyc && i_wb_ack && !i_wb_err && !r_valid) f_req_addr <= f_req_addr + 1'b1;",
            "assign f_next_wb_addr = o_wb_addr + 1; // }}} // Let's also keep the formal methods on track. Any time we are // requesting a value, it should either be from the req_addr, or if // not a new value should've come in rendering this one invalid.",
            "always @(posedge i_clk) if (o_wb_cyc) begin assert(invalid ||(f_req_addr == o_wb_addr)); // This isn't good enough for induction, so we'll need to // constrain this further end else if (!o_valid && !i_new_pc && !i_reset && !i_clear_cache) assert(o_illegal || f_req_addr == o_wb_addr); else if (!i_reset && r_valid) assert(f_req_addr == f_next_wb_addr); // In this version, invalid should only ever be high for one cycle. // CYC should be high on the cycle following--if ever.",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(invalid))) assert(!invalid); // }}} //////////////////////////////////////////////////////////////////////// // // Contract checking // {{{ //////////////////////////////////////////////////////////////////////// // // wire f_this_addr, f_this_pc, f_this_req, f_this_data;",
            "reg f_addr_pending;",
            "reg f_insn_pending; (* anyconst *)",
            "reg [DATA_WIDTH-1:0] f_const_bus_word;",
            "assign f_this_addr = (o_wb_addr == f_const_addr[AW-1:$clog2(DW/8)]);",
            "assign f_this_pc = (o_pc[AW-1:$clog2(DW/8)]== f_const_addr[AW-1:$clog2(DW/8)]);",
            "assign f_this_req = (i_pc[AW-1:$clog2(DW/8)]== f_const_addr[AW-1:$clog2(DW/8)]);",
            "assign f_this_data = (i_wb_data == f_const_bus_word); generate if (DATA_WIDTH > INSN_WIDTH) begin : F_CHECK_SHIFTED_WORD // {{{",
            "wire [DW-1:0] f_shifted_insn;",
            "localparam IW = INSN_WIDTH; if (OPT_LITTLE_ENDIAN) begin",
            "assign f_shifted_insn = f_const_bus_word >> (f_const_addr[$clog2(DW/8)-1:$clog2(IW/8)] * IW);",
            "always @(*) assume(f_shifted_insn[IW-1:0] == f_const_insn); end else begin",
            "assign f_shifted_insn = f_const_bus_word << (f_const_addr[$clog2(DW/8)-1:$clog2(IW/8)] * IW);",
            "always @(*) assume(f_shifted_insn[DW-1:DW-IW] == f_const_insn); end // }}} end else begin // {{{",
            "always @(*) assume(f_const_bus_word == f_const_insn); // }}} end endgenerate // f_addr_pending // {{{",
            "initial f_addr_pending = 1'b0;",
            "always @(posedge i_clk) if (i_reset) f_addr_pending <= 1'b0; else if (!o_wb_cyc) f_addr_pending <= 1'b0; else if ((o_wb_stb)&&(f_this_addr)) begin if ((!i_wb_ack)&&(!i_wb_err)) f_addr_pending <= 1'b1; end // }}} // 1. Assume the correct response for the given address // {{{",
            "always @(*) if ((o_wb_stb)&&(f_this_addr)&&(!i_wb_stall)) begin if (!f_const_illegal) begin assume(!i_wb_err); end else assume(!i_wb_ack); if (i_wb_ack) assume(f_this_data); end else if ((o_wb_cyc)&&(f_addr_pending)) begin if (!f_const_illegal) begin assume(!i_wb_err); end else assume(!i_wb_ack); if (i_wb_ack) assume(f_this_data); end // }}} // f_insn_pending // {{{",
            "initial f_insn_pending = 1'b0;",
            "always @(posedge i_clk) if (i_reset) f_insn_pending <= 1'b0; else if (i_clear_cache) f_insn_pending <= 1'b0; else if (i_new_pc && f_this_req) f_insn_pending <= 1'b1; else if ((o_valid)||(i_new_pc)) f_insn_pending <= 1'b0; // }}}",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_wb_cyc))&&(o_wb_cyc)&&(f_insn_pending)) assert(f_this_pc);",
            "always @(posedge i_clk) if (((f_past_valid)&&($past(o_wb_cyc))&&($past(f_insn_pending))) &&(!$past(i_reset))&&(!$past(i_clear_cache)) &&(!$past(i_new_pc))) begin if(!o_wb_cyc) assert(o_valid && f_this_pc); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(o_wb_cyc))&&(!o_wb_cyc)) assert(!f_insn_pending);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_wb_cyc))&&(o_wb_cyc)&&(f_this_addr)) assert(f_addr_pending);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_wb_cyc))&&(f_insn_pending)) assert(f_this_addr); // }}} // Make Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused_formal;",
            "assign unused_formal = &{ 1'b0, f_nreqs, f_nacks, f_outstanding, f_const_addr[1:0] }; // Verilator lint_on UNUSED // }}} `endif // }}}",
            "endmodule // // Usage: (this) (mid) (past) // Cells 167 230 175 // FDRE 67 97 69 // LUT1 1 1 1 // LUT2 1 3 3 // LUT3 31 63 33 // LUT4 5 3 3 // LUT5 1 3 3 // LUT6 2 1 3 // MUXCY 29 29 31 // XORCY 30 30 32"
        ]
    },
    {
        "file_name": "dblfetch.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/dblfetch.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: dblfetch.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This is one step beyond the simplest instruction fetch, // prefetch.v. dblfetch.v uses memory pipelining to fetch two // (or more) instruction words in one bus cycle. If the CPU consumes // either of these before the bus cycle completes, a new request will be // made of the bus. In this way, we can keep the CPU filled in spite // of a (potentially) slow memory operation. The bus request will end // when both requests have been sent and both result locations are empty. // // This routine is designed to be a touch faster than the single // instruction prefetch (prefetch.v), although not as fast as the // prefetch and cache approach found elsewhere (pfcache.v). // // 20180222: Completely rebuilt. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2017-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module dblfetch #( // {{{",
            "parameter ADDRESS_WIDTH=30, // Byte addr",
            "parameter INSN_WIDTH=32, parameter DATA_WIDTH = INSN_WIDTH, localparam AW=ADDRESS_WIDTH, DW=DATA_WIDTH, parameter [0:0] OPT_LITTLE_ENDIAN = 1'b1 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // CPU signals--from the CPU",
            "input wire i_new_pc, i_clear_cache,i_ready, input wire [AW-1:0] i_pc, // ... and in return",
            "output reg o_valid, output reg o_illegal, output reg [INSN_WIDTH-1:0] o_insn, output reg [AW-1:0] o_pc, // Wishbone",
            "output s",
            "output reg o_wb_cyc, o_wb_stb, // verilator coverage_off",
            "output wire o_wb_we, // verilator coverage_on",
            "output reg [AW-$clog2(DW/8)-1:0] o_wb_addr, // verilator coverage_off",
            "output wire [DW-1:0] o_wb_data, // verilator coverage_on // And return",
            "input s",
            "input wire i_wb_stall, i_wb_ack, i_wb_err, input wire [DW-1:0] i_wb_data // }}} ); // Local declarations // {{{",
            "wire last_stb;",
            "reg invalid_bus_cycle;",
            "reg [(DW-1):0] cache_word;",
            "reg cache_valid;",
            "reg [1:0] inflight;",
            "reg cache_illegal;",
            "wire r_valid;",
            "wire [DATA_WIDTH-1:0] r_insn, i_wb_shifted; // }}}",
            "assign o_wb_we = 1'b0;",
            "assign o_wb_data = {(DATA_WIDTH){1'b0}}; // o_wb_cyc, o_wb_stb // {{{",
            "initial o_wb_cyc = 1'b0;",
            "initial o_wb_stb = 1'b0;",
            "always @(posedge i_clk) if (i_reset || i_clear_cache || (o_wb_cyc && i_wb_err)) begin : RESET_ABORT // {{{ o_wb_cyc <= 1'b0; o_wb_stb <= 1'b0; // }}} end else if (o_wb_cyc) begin : END_CYCLE // {{{ if (!o_wb_stb || !i_wb_stall) o_wb_stb <= (!last_stb); // Relase the bus on the second ack if ((!o_wb_stb || !i_wb_stall) && last_stb && inflight + (o_wb_stb ? 1:0) == (i_wb_ack ? 1:0)) begin o_wb_cyc <= 1'b0; o_wb_stb <= 1'b0; end if (i_new_pc) // || i_clear_cache) { o_wb_cyc, o_wb_stb } <= 2'b0; // }}} end else if ((i_new_pc || invalid_bus_cycle) ||(o_valid && i_ready && !r_valid && !cache_illegal)) begin : START_CYCLE // {{{ // Initiate a bus cycle if ... the last bus cycle was // aborted (bus error or new_pc), we've been given a // new PC to go get, or we just exhausted our one // instruction cache o_wb_cyc <= 1'b1; o_wb_stb <= 1'b1; // }}} end // }}} // inflight // {{{",
            "initial inflight = 2'b00;",
            "always @(posedge i_clk) if (!o_wb_cyc) inflight <= 2'b00; else begin case({ (o_wb_stb && !i_wb_stall), i_wb_ack }) 2'b01: inflight <= inflight - 1'b1; 2'b10: inflight <= inflight + 1'b1; // If neither ack nor request, then no change. Likewise // if we have both an ack and a request, there's no change // in the number of requests in flight. default: begin end endcase end // }}} // last_stb // {{{ // assign last_stb = (inflight != 2'b00)||(o_valid&& (!i_ready||r_valid));",
            "assign last_stb = (!o_wb_stb||!i_wb_stall)&&(inflight + (o_wb_stb ? 1:0) + (o_valid&&(!i_ready || r_valid)) >= 2'b10); // }}} // invalid_bus_cycle // {{{",
            "initial invalid_bus_cycle = 1'b0;",
            "always @(posedge i_clk) if (i_reset) invalid_bus_cycle <= 1'b0; else if (o_wb_cyc && i_new_pc) invalid_bus_cycle <= 1'b1; else if (!o_wb_cyc) invalid_bus_cycle <= 1'b0; // }}} // o_wb_addr // {{{",
            "initial o_wb_addr = {(AW-$clog2(DATA_WIDTH/8)){1'b1}};",
            "always @(posedge i_clk) if (i_new_pc) o_wb_addr <= i_pc[AW-1:$clog2(DATA_WIDTH/8)]; // else if (i_clear_cache) // o_wb_addr <= o_pc[AW-1:$clog2(DATA_WIDTH/8)]; else if (o_wb_stb && !i_wb_stall) o_wb_addr <= o_wb_addr + 1'b1; // }}} //////////////////////////////////////////////////////////////////////// // // Now for the immediate",
            "output word to the CPU // {{{ //////////////////////////////////////////////////////////////////////// // // // This only applies when the bus size doesn't match the instruction // word size. Here, we only support bus sizes greater than the // instruction word size. `ifdef FORMAL",
            "wire [DATA_WIDTH-1:0] f_bus_word; `endif generate if (DATA_WIDTH > INSN_WIDTH) begin : GEN_SUBSHIFT // {{{",
            "localparam NSHIFT = $clog2(DATA_WIDTH/INSN_WIDTH);",
            "reg rg_valid;",
            "reg [DATA_WIDTH-1:0] rg_insn;",
            "reg [NSHIFT:0] r_count;",
            "reg [NSHIFT-1:0] r_shift; // rg_valid // {{{",
            "always @(posedge i_clk) if (i_reset || i_new_pc) // || i_clear_cache) rg_valid <= 1'b0; else if (r_valid) rg_valid <= !i_ready || (r_count > 1); else if (!o_valid || i_ready) begin rg_valid <= 1'b0; if (cache_valid) rg_valid <= 1'b1; if (o_wb_cyc && i_wb_ack && !(&r_shift)) rg_valid <= 1'b1; end // }}} // rg_insn // {{{",
            "always @(posedge i_clk) if (!o_valid || i_ready) begin if (cache_valid && !r_valid) begin if (OPT_LITTLE_ENDIAN) rg_insn <= cache_word >> INSN_WIDTH; else rg_insn <= cache_word << INSN_WIDTH; end else if (i_wb_ack && !r_valid) begin rg_insn <= i_wb_data; if (OPT_LITTLE_ENDIAN) rg_insn <= i_wb_shifted >> INSN_WIDTH; else rg_insn <= i_wb_shifted << INSN_WIDTH; end else begin if (OPT_LITTLE_ENDIAN) rg_insn <= rg_insn >> INSN_WIDTH; else rg_insn <= rg_insn << INSN_WIDTH; end end // }}} // r_count // {{{",
            "always @(posedge i_clk) if (i_reset || i_new_pc) // || i_clear_cache) r_count <= 0; else if (o_valid && i_ready && r_valid) begin r_count <= r_count - 1; end else if (!o_valid || (i_ready && !r_valid)) begin if (cache_valid) r_count <= { 1'b0, {(NSHIFT){1'b1}} }; else if (o_wb_cyc && i_wb_ack) r_count <= { 1'b0, ~r_shift }; end `ifdef FORMAL",
            "always @(*) if (!i_reset && !i_new_pc && !i_clear_cache) begin if (!o_valid) assert(!r_valid); assert(r_valid == (r_count > 0)); assert(r_count <= (1<<NSHIFT)); if (r_valid) begin assert(!cache_valid || !o_wb_cyc); assert(r_shift == 0); end else if (!i_new_pc && !i_clear_cache && !o_illegal) assert(invalid_bus_cycle || o_valid || o_wb_cyc); end `endif // }}} // r_shift // {{{",
            "always @(posedge i_clk) if (i_new_pc) r_shift <= i_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)]; // else if (i_clear_cache) // r_shift <= o_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)]; else if (o_wb_cyc && (i_wb_ack || i_wb_err)) r_shift <= 0; `ifdef FORMAL",
            "always @(*) if (!i_reset && r_shift > 0) assert(!o_valid && !r_valid); `endif // }}}",
            "assign r_valid = rg_valid;",
            "assign r_insn = rg_insn; if (OPT_LITTLE_ENDIAN) begin : GEN_LITTLE_ENDIAN_SHIFT",
            "assign i_wb_shifted = i_wb_data >> (r_shift * INSN_WIDTH); end else begin : GEN_BIGENDIAN_SHIFT",
            "assign i_wb_shifted = i_wb_data << (r_shift * INSN_WIDTH); end // Keep Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused_shift;",
            "assign unused_shift = &{ 1'b0, r_insn[DATA_WIDTH-1:INSN_WIDTH], i_wb_shifted[DATA_WIDTH-1:INSN_WIDTH] }; // Verilator lint_on UNUSED // }}} `ifdef FORMAL",
            "assign f_bus_word = rg_insn << ((r_count-1)* INSN_WIDTH);",
            "always @(*) if (!i_reset && r_valid) begin assert(i_clear_cache || i_new_pc || o_valid); assert(r_shift == 0); assert((r_count + o_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)]) == ((1<<NSHIFT)-1)); end else if (!i_reset && !o_valid && o_wb_cyc && !invalid_bus_cycle) begin assert(r_shift == o_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)]); end `endif // }}} end else begin : NO_SUBSHIFT // {{{",
            "assign r_valid = 1'b0;",
            "assign r_insn = {(INSN_WIDTH){1'b0}};",
            "assign i_wb_shifted = i_wb_data; // }}} end endgenerate // o_valid // {{{",
            "initial o_valid = 1'b0;",
            "always @(posedge i_clk) if (i_reset || i_new_pc || i_clear_cache) o_valid <= 1'b0; else if (o_wb_cyc &&(i_wb_ack || i_wb_err)) o_valid <= 1'b1; else if (i_ready) o_valid <= cache_valid || r_valid; // }}} // o_insn // {{{",
            "always @(posedge i_clk) if (!o_valid || i_ready) begin if (OPT_LITTLE_ENDIAN) begin if (r_valid) o_insn <= r_insn[INSN_WIDTH-1:0]; else if (cache_valid) o_insn <= cache_word[INSN_WIDTH-1:0]; else o_insn <= i_wb_shifted[INSN_WIDTH-1:0]; end else begin if (r_valid) o_insn <= r_insn[DW-1:DW-INSN_WIDTH]; else if (cache_valid) o_insn <= cache_word[DW-1:DW-INSN_WIDTH]; else o_insn <= i_wb_shifted[DW-1:DW-INSN_WIDTH]; end end // }}} // o_pc // {{{",
            "always @(posedge i_clk) if (i_new_pc) o_pc <= i_pc; else if (o_valid && i_ready) // && !i_clear_cache begin o_pc <= 0; o_pc[AW-1:$clog2(INSN_WIDTH/8)] <= o_pc[AW-1:$clog2(INSN_WIDTH/8)] + 1'b1; end // }}} // o_illegal // {{{",
            "initial o_illegal = 1'b0;",
            "always @(posedge i_clk) if (i_reset || i_new_pc || i_clear_cache) o_illegal <= 1'b0; else if (!r_valid && (!o_valid || i_ready) && !o_illegal) begin if (cache_valid) o_illegal <= cache_illegal; else if (o_wb_cyc && i_wb_err) o_illegal <= 1'b1; end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Now for the",
            "output /cached word // {{{ //////////////////////////////////////////////////////////////////////// // // // cache_valid // {{{",
            "initial cache_valid = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(i_new_pc)||(i_clear_cache)) cache_valid <= 1'b0; else begin if (o_valid && o_wb_cyc &&(i_wb_ack || i_wb_err)) cache_valid <= !i_ready || r_valid; else if (i_ready && !r_valid) cache_valid <= 1'b0; end `ifdef FORMAL",
            "always @(*) if (!i_reset && cache_valid && o_wb_cyc) assert(!i_wb_ack && !i_wb_err); `endif // }}} // cache_word // {{{",
            "always @(posedge i_clk) if (i_wb_ack) cache_word <= i_wb_data; // }}} // cache_illegal // {{{",
            "initial cache_illegal = 1'b0;",
            "always @(posedge i_clk) if (i_reset || i_clear_cache || i_new_pc) cache_illegal <= 1'b0; // Older",
            "logic ... // else if ((o_wb_cyc)&&(i_wb_err)&&(o_valid)&&(!i_ready)) // cache_illegal <= 1'b1; else if (o_wb_cyc && i_wb_err) // && o_valid && (!i_ready || r_valid)) cache_illegal <= 1'b1; // }}} // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal property section // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Local declarations // {{{ // Keep track of a flag telling us whether or not $past() // will return valid results",
            "reg f_past_valid; // Keep track of some alternatives to $past that can still be used // in a VERILATOR environment",
            "reg [AW-1:0] f_next_addr, f_dbl_next, f_cache_addr; //bytaddr",
            "localparam F_LGDEPTH=2;",
            "wire [(F_LGDEPTH-1):0] f_nreqs, f_nacks, f_outstanding;",
            "wire [AW-1:0] f_const_addr;",
            "wire [DW-1:0] f_const_insn;",
            "wire f_const_illegal;",
            "wire f_this_pc, f_this_insn, f_this_return;",
            "wire [AW-$clog2(DATA_WIDTH/8)-1:0] this_return_address, f_const_bus_addr, next_pc_address;",
            "wire [AW-1:0] f_address; (* anyconst *)",
            "wire [DW-1:0] f_const_bus_word;",
            "reg [AW-$clog2(DW/8)-1:0] pc_bus_addr, pc_bus_addr_next, pc_bus_addr_dbl;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; // }}} generate if (INSN_WIDTH == 8) begin : F_NEXT_BYTE_ADDR // {{{ // BUS addresses",
            "always @(*) f_next_addr = o_pc + (r_valid ? 0:1); // }}} end else begin : F_NEXT_ADDR // {{{ // BUS addresses",
            "always @(*) if (r_valid) f_next_addr = o_pc; else begin f_next_addr = o_pc + (INSN_WIDTH/8); f_next_addr[$clog2(INSN_WIDTH/8)-1:0] = 0; end // }}} end endgenerate",
            "always @(*) begin // BUS addresses f_dbl_next = f_next_addr + (DATA_WIDTH/8); if (r_valid) f_dbl_next = f_dbl_next + (DATA_WIDTH/8); f_dbl_next[$clog2(DATA_WIDTH/8)-1:0] = 0; f_cache_addr = o_pc + (DATA_WIDTH/8); f_cache_addr[$clog2(DATA_WIDTH/8)-1:0] = 0; end //////////////////////////////////////////////////////////////////////// // // Assumptions about our",
            "input s // {{{ //////////////////////////////////////////////////////////////////////// // // // // // Assume that resets, new-pc commands, and clear-cache commands // are never more than pulses--one clock wide at most. // // It may be that the CPU treats us differently. We'll only restrict // our solver to this here. // }}} //////////////////////////////////////////////////////////////////////// // // Wishbone bus properties // {{{ //////////////////////////////////////////////////////////////////////// // // // // Add a bunch of wishbone-based asserts fwb_master #( // {{{ .AW(AW-$clog2(DATA_WIDTH/8)), .DW(DW), .F_LGDEPTH(F_LGDEPTH), .F_MAX_STALL(2), .F_MAX_REQUESTS(0), .F_OPT_SOURCE(1), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(0) // }}} ) f_wbm( // {{{ i_clk, i_reset, o_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, {(DW/8){1'b1}}, i_wb_ack, i_wb_stall, i_wb_data, i_wb_err, f_nreqs, f_nacks, f_outstanding // }}} ); // }}} //////////////////////////////////////////////////////////////////////// // // Assumptions about our interaction with the CPU // {{{ //////////////////////////////////////////////////////////////////////// // // ffetch #( // {{{ .ADDRESS_WIDTH(AW-$clog2(INSN_WIDTH/8)), .INSN_WIDTH(INSN_WIDTH) // }}} ) cpu( // {{{ .i_clk(i_clk), .i_reset(i_reset), .cpu_new_pc(i_new_pc), .cpu_clear_cache(i_clear_cache), .cpu_pc(i_pc), .pf_valid(o_valid), .cpu_ready(i_ready), .pf_pc(o_pc), .pf_insn(o_insn), .pf_illegal(o_illegal), .fc_illegal(f_const_illegal), .fc_insn(f_const_insn), .fc_pc(f_const_addr), .f_address(f_address) // }}} );",
            "assign f_const_bus_addr = f_const_addr[AW-1:$clog2(DATA_WIDTH/8)]; // // Let's make some assumptions about how long it takes our phantom // (i.e. assumed) CPU to respond. // // This delay needs to be long enough to flush out any potential // errors, yet still short enough that the formal method doesn't // take forever to solve. // localparam F_CPU_DELAY = 4;",
            "reg [4:0] f_cpu_delay; // Now, let's look at the delay the CPU takes to accept an instruction.",
            "always @(posedge i_clk) // If no instruction is ready, then keep our counter at zero if ((!o_valid)||(i_ready)) f_cpu_delay <= 0; else // Otherwise, count the clocks the CPU takes to respond f_cpu_delay <= f_cpu_delay + 1'b1;",
            "always @(posedge i_clk) assume(f_cpu_delay < F_CPU_DELAY); // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about our",
            "output s // {{{ // //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if ((f_past_valid)&&($past(o_wb_stb))&&(!$past(i_wb_stall)) &&($past(!i_new_pc && !i_clear_cache))) assert(o_wb_addr <= $past(o_wb_addr)+1'b1); // // The cache doesn't change if we are stalled // always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&(!$past(i_new_pc))&&(!$past(i_clear_cache)) &&($past(o_valid))&&(!$past(i_ready || r_valid)) &&($past(cache_valid))) begin assert($stable(cache_valid)); assert($stable(cache_word)); assert($stable(cache_illegal)); end // Consider it invalid to present the CPU with the same instruction // twice in a row. Any effort to present the CPU with the same // instruction twice in a row must go through i_new_pc, and thus a // new bus cycle--hence the assertion below makes sense.",
            "always @(posedge i_clk) if ((f_past_valid)&& $past(!i_new_pc && !i_clear_cache) &&($past(o_valid && i_ready))) assert(o_pc == f_address);",
            "always @(posedge i_clk) if (!i_reset && !i_clear_cache && !i_new_pc) assert(o_pc == f_address);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&(!$past(i_new_pc)) &&(!$past(i_clear_cache)) &&($past(o_wb_cyc))&&($past(i_wb_err))) assert( ((o_valid)&&(o_illegal)) ||((cache_valid)&&(cache_illegal)) );",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(o_illegal))&&(o_illegal)) assert(o_valid);",
            "always @(posedge i_clk) if (!i_reset && cache_illegal) assert(!o_wb_cyc);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_new_pc))) assert(!o_valid);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&(!$past(i_clear_cache)) &&($past(o_valid))&&(!o_valid)&&(!o_illegal)) assert((o_wb_cyc)||(invalid_bus_cycle)); // }}} //////////////////////////////////////////////////////////////////////// // // // Our \"contract\" with the CPU // {{{ // //////////////////////////////////////////////////////////////////////// // // For any particular address, that address is associated with an // instruction and a flag",
            "reg arding whether or not it is illegal. // // Any attempt to return to the CPU a value from this address, // must return the value and the illegal flag. // // // While these",
            "wire s may seem like overkill, and while they make the // following",
            "logic perhaps a bit more obscure, these predicates make // it easier to follow the complex",
            "logic on a scope. They don't // affect anything synthesized. // assign f_this_pc = (o_pc[AW-1:$clog2(INSN_WIDTH/8)] == f_const_addr[AW-1:$clog2(INSN_WIDTH/8)]);",
            "assign f_this_insn = (o_insn == f_const_insn); // Verilator lint_off WIDTH",
            "assign f_this_return = (o_wb_addr - f_outstanding == f_const_addr[AW-1:$clog2(DATA_WIDTH/8)]); // Verilator lint_on WIDTH // // // Here's our contract: // // Any time we return a value for the address above, it *must* be // the \"right\" value. // always @(*) if (o_valid && f_this_pc) begin if (f_const_illegal) assert(o_illegal); if (!o_illegal) assert(f_this_insn); end // // The contract will only work if we assume the return from the // bus at this address will be the right return.",
            "always @(*) if ((o_wb_cyc)&&(f_this_return)) begin if (i_wb_ack) assume(i_wb_data == f_const_bus_word); if (f_const_illegal) begin assume(!i_wb_ack); end else assume(!i_wb_err); end generate if (INSN_WIDTH == DATA_WIDTH) begin : F_SAME_BUS_WORD // {{{",
            "always @(*) assume(f_const_bus_word == f_const_insn); // }}} end else begin : F_CHECK_SHIFTED_WORD // {{{",
            "wire [DW-1:0] f_shifted_insn;",
            "localparam IW = INSN_WIDTH; if (OPT_LITTLE_ENDIAN) begin",
            "assign f_shifted_insn = f_const_bus_word >> (f_const_addr[$clog2(DW/8)-1:$clog2(IW/8)] * IW);",
            "always @(*) assume(f_shifted_insn[IW-1:0] == f_const_insn); end else begin",
            "assign f_shifted_insn = f_const_bus_word << (f_const_addr[$clog2(DW/8)-1:$clog2(IW/8)] * IW);",
            "always @(*) assume(f_shifted_insn[DW-1:DW-IW] == f_const_insn); end // }}} end endgenerate // // Here is a corrollary to our contract. Anything in the one-word // cache must also match the contract as well. // always @(*) if ((f_cache_addr[AW-1:$clog2(DATA_WIDTH/8)] == f_const_bus_addr) &&(cache_valid)) begin if (!cache_illegal) assert(cache_word == f_const_bus_word); if (f_const_illegal) assert(cache_illegal); else assert(o_illegal || !cache_illegal); end // always @(posedge i_clk) // if ((f_past_valid)&&(!$past(cache_illegal))&&(!cache_valid)) // assert(!cache_illegal); // }}} //////////////////////////////////////////////////////////////////////// // // Additional assertions necessary to pass induction // {{{ //////////////////////////////////////////////////////////////////////// // // // We have only a one word cache. Hence, we shouldn't be asking // for more data any time we have nowhere to put it.",
            "always @(*) if (o_wb_stb) assert(!cache_valid || i_ready);",
            "always @(*) if (o_valid && cache_valid) assert((f_outstanding == 0)&&(!o_wb_stb));",
            "always @(*) if (o_valid && (r_valid || !i_ready)) assert(f_outstanding < 2);",
            "always @(*) if (!o_valid || (i_ready && !r_valid)) assert(f_outstanding <= 2); // always @(posedge i_clk) // if ((f_past_valid)&&($past(o_wb_cyc && !o_wb_stb)) &&(o_wb_cyc)) // assert(inflight != 0);",
            "always @(*) if (o_wb_cyc && i_wb_ack) assert(!cache_valid);",
            "always @(posedge i_clk) if (o_wb_cyc) assert(inflight == f_outstanding); // Verilator lint_off WIDTH",
            "assign this_return_address = o_wb_addr - f_outstanding; // Verilator lint_on WIDTH",
            "assign next_pc_address = f_next_addr[AW-1:$clog2(DATA_WIDTH/8)]; // }}} //////////////////////////////////////////////////////////////////////// // // Address checking // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) begin pc_bus_addr = o_pc[AW-1:$clog2(DW/8)]; pc_bus_addr_next = pc_bus_addr + 1; pc_bus_addr_dbl = pc_bus_addr + 2; end",
            "always @(*) if (i_reset || o_illegal || invalid_bus_cycle) begin end else if (!o_valid) begin if (o_wb_cyc) begin if (inflight == 0) assert(o_wb_addr == pc_bus_addr); assert(pc_bus_addr == this_return_address); end end else if (cache_valid || (o_wb_cyc && !o_wb_stb)) begin assert(o_wb_addr == pc_bus_addr_dbl); end else if (o_valid) assert(o_wb_addr == pc_bus_addr_next);",
            "always @(posedge i_clk) if (f_past_valid &&($past(!i_reset && !i_new_pc && !i_clear_cache)) &&(!$past(invalid_bus_cycle))) begin if (($past(o_wb_cyc && (i_wb_ack || i_wb_err))) &&($past(!o_valid || (i_ready && !r_valid))) &&(!$past(cache_valid))) begin assert(o_pc[AW-1:$clog2(DW/8)] == $past(this_return_address)); end else if (cache_valid) begin assert(o_wb_addr == pc_bus_addr_dbl); assert(f_outstanding == 0); end else if (o_valid) begin if (f_outstanding == 0) assert(o_illegal || o_wb_addr == pc_bus_addr_next); else if (f_outstanding == 1) assert(o_illegal || o_wb_addr == pc_bus_addr_dbl); else if (f_outstanding == 2) assert(o_wb_addr == pc_bus_addr_dbl); end else if (o_wb_cyc) assert(o_pc[AW-1:$clog2(DW/8)] == this_return_address); end",
            "always @(posedge i_clk) if (!i_reset && o_illegal) begin assert(!o_wb_cyc); assert(cache_illegal); end",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_wb_cyc && !i_new_pc))&&(!o_valid) &&(o_wb_cyc)) assert(o_pc[AW-1:$clog2(DW/8)] == this_return_address);",
            "always @(posedge i_clk) if (o_valid && !o_wb_cyc && !o_illegal) begin if (cache_valid) assert(f_dbl_next[AW-1:$clog2(DW/8)] == o_wb_addr); else assert(pc_bus_addr_next == o_wb_addr); end",
            "always @(*) if (o_wb_cyc || o_valid) begin assert(o_wb_addr == pc_bus_addr || o_wb_addr == pc_bus_addr_next || o_wb_addr == pc_bus_addr_dbl); end // always @(posedge i_clk) // if ((f_past_valid)&& $past(o_wb_cyc && !cache_valid) && cache_valid) // assert(next_pc_address == $past(this_return_address)); // // always @(posedge i_clk) if ((f_past_valid)&&($past(o_wb_cyc))&&(o_wb_cyc)) begin if (o_valid && !cache_valid) begin // assert(this_return_address == next_pc_address); end else if (!o_valid) assert(this_return_address == o_pc[AW-1:$clog2(DW/8)]); end else if ((f_past_valid)&&(!invalid_bus_cycle) &&(!o_wb_cyc)&&(o_valid)&&(!o_illegal) &&(!cache_valid)) assert(o_wb_addr == next_pc_address);",
            "always @(*) if (invalid_bus_cycle) assert(!o_wb_cyc);",
            "always @(*) if (cache_valid) assert(o_valid); // }}} //////////////////////////////////////////////////////////////////////// // // Cover statements // {{{ //////////////////////////////////////////////////////////////////////// // // reg f_cvr_aborted, f_cvr_fourth_ack;",
            "always @(posedge i_clk) cover((f_past_valid)&&($past(f_nacks)==3) &&($past(i_wb_ack))&&($past(o_wb_cyc)));",
            "initial f_cvr_aborted = 0;",
            "always @(posedge i_clk) if (i_reset) f_cvr_aborted <= 0; else if (!o_wb_cyc && (f_nreqs != f_nacks)) f_cvr_aborted <= 1;",
            "initial f_cvr_fourth_ack = 0;",
            "always @(posedge i_clk) if (i_reset) f_cvr_fourth_ack <= 0; else if ((f_nacks == 3)&&(o_wb_cyc && i_wb_ack)) f_cvr_fourth_ack <= 1;",
            "always @(posedge i_clk) cover(!o_wb_cyc && (f_nreqs == f_nacks) && !f_cvr_aborted && f_cvr_fourth_ack); // }}} //////////////////////////////////////////////////////////////////////// // // Temporary simplifications // {{{ //////////////////////////////////////////////////////////////////////// // // // }}} // Make Verilator happy -- formal section // {{{ // Verilator lint_off UNUSED",
            "wire unused_formal;",
            "assign unused_formal = &{ f_dbl_next[1:0], f_const_addr[1:0] }; // Verilator lint_on UNUSED // }}} `endif // FORMAL // }}}",
            "endmodule // // Usage: (this) (prior) (old) (S6) // Cells 374 387 585 459 // FDRE 135 108 203 171 // LUT1 2 3 2 // LUT2 9 3 4 5 // LUT3 98 76 104 71 // LUT4 2 0 2 2 // LUT5 3 35 35 3 // LUT6 6 5 10 43 // MUXCY 58 62 93 62 // MUXF7 1 0 2 3 // MUXF8 0 1 1 // RAM64X1D 0 32 32 32 // XORCY 60 64 96 64 //"
        ]
    },
    {
        "file_name": "axilfetch.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axilfetch.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: axilfetch.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This is a very simple instruction fetch approach based around // AXI-lite. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2020-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // // License: GPL, v3, as defined and found on www.gnu.org, // http://www.gnu.org/licenses/gpl.html // // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module axilfetch #( // {{{",
            "parameter C_AXI_ADDR_WIDTH = 32, parameter C_AXI_DATA_WIDTH = 64, parameter INSN_WIDTH=32, parameter FETCH_LIMIT=16, parameter [0:0] SWAP_ENDIANNESS = 1'b0, localparam AW=C_AXI_ADDR_WIDTH // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, // // CPU interaction",
            "wire s // {{{",
            "input wire i_cpu_reset, input wire i_new_pc, input wire i_clear_cache, input wire i_ready, input wire [AW-1:0] i_pc, // Ignd unls i_new_pc",
            "output wire [INSN_WIDTH-1:0] o_insn, // Insn read from bus",
            "output reg [AW-1:0] o_pc, // Addr of that insn",
            "output reg o_valid, // If valid",
            "output reg o_illegal, // Bus error // }}} // AXI-lite bus interface // {{{",
            "output reg M_AXI_ARVALID, input wire M_AXI_ARREADY, output reg [C_AXI_ADDR_WIDTH-1:0] M_AXI_ARADDR, // Verilator coverage_off",
            "output wire [2:0] M_AXI_ARPROT, // Verilator coverage_on // input wire M_AXI_RVALID, output wire M_AXI_RREADY, input wire [C_AXI_DATA_WIDTH-1:0] M_AXI_RDATA, input wire [1:0] M_AXI_RRESP // }}} // }}} ); // Declarations // {{{",
            "localparam AXILLSB = $clog2(C_AXI_DATA_WIDTH/8);",
            "localparam INSNS_PER_WORD = C_AXI_DATA_WIDTH / INSN_WIDTH;",
            "localparam INSN_LSB = $clog2(INSN_WIDTH/8);",
            "localparam LGDEPTH = $clog2(FETCH_LIMIT)+4;",
            "localparam LGFIFO = $clog2(FETCH_LIMIT);",
            "localparam W = LGDEPTH;",
            "localparam FILLBITS = $clog2(INSNS_PER_WORD); // ($clog2(INSNS_PER_WORD) > 0) // ? $clog2(INSNS_PER_WORD) : 1);",
            "reg [W:0] new_flushcount, outstanding, next_outstanding, flushcount;",
            "reg flushing, flush_request, full_bus;",
            "wire [((AXILLSB>INSN_LSB) ? (AXILLSB-INSN_LSB-1):0):0] shift;",
            "wire fifo_reset, fifo_wr, fifo_rd;",
            "wire ign_fifo_full, fifo_empty;",
            "wire [LGFIFO:0] ign_fifo_fill;",
            "wire [C_AXI_DATA_WIDTH:0] fifo_data;",
            "reg pending_new_pc;",
            "reg [C_AXI_ADDR_WIDTH-1:0] pending_pc;",
            "reg [W-1:0] fill;",
            "reg [FILLBITS:0] out_fill;",
            "reg [C_AXI_DATA_WIDTH-1:0] out_data;",
            "reg [C_AXI_DATA_WIDTH-1:0] endian_swapped_rdata; `ifdef FORMAL",
            "wire f_cache_valid;",
            "wire [C_AXI_DATA_WIDTH-1:0] f_cache_data;",
            "wire f_cache_illegal;",
            "wire [LGFIFO:0] f_cache_distance; `endif // }}}",
            "assign fifo_reset = i_cpu_reset || i_clear_cache || i_new_pc;",
            "assign fifo_wr = M_AXI_RVALID && !flushing; // ARPROT = 3'b100 for an unprivileged, secure instruction access // (not sure what unprivileged or secure mean--even after reading the // spec)",
            "assign M_AXI_ARPROT = 3'b100; // next_outstanding // {{{",
            "always @(*) begin next_outstanding = outstanding; case({ M_AXI_ARVALID && M_AXI_ARREADY, M_AXI_RVALID }) 2'b10: next_outstanding = outstanding + 1; 2'b01: next_outstanding = outstanding - 1; default: begin end endcase end // }}} // outstanding, full_bus // {{{",
            "initial outstanding = 0;",
            "initial full_bus = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin outstanding <= 0; full_bus <= 0; end else begin outstanding <= next_outstanding; full_bus <= (next_outstanding // + (((M_AXI_ARVALID && !M_AXI_ARREADY) ? 1:0) >= (1<<LGDEPTH)-1); end // }}} // fill // {{{",
            "initial fill = 0;",
            "always @(posedge S_AXI_ACLK) if (fifo_reset) fill <= 0; // else if (fo_reset || flushing) // fill <= 0; else case({ M_AXI_ARVALID && M_AXI_ARREADY && !flush_request, fifo_rd && !fifo_empty }) 2'b10: fill <= fill + 1; 2'b01: fill <= fill - 1; default: begin end endcase // }}} // new_flushcount // {{{",
            "always @(*) new_flushcount = outstanding + (M_AXI_ARVALID ? 1:0) - (M_AXI_RVALID ? 1:0); // }}} // flushcount, flushing, flush_request // {{{",
            "initial flushcount = 0;",
            "initial flushing = 0;",
            "initial flush_request = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin flushcount <= 0; flushing <= 0; flush_request <= 0; end else if (fifo_reset) begin flushcount <= new_flushcount; flushing <= (new_flushcount > 0); flush_request <= (M_AXI_ARVALID && !M_AXI_ARREADY); end else begin if (M_AXI_RVALID && flushcount > 0) begin flushcount <= flushcount - 1; // Verilator lint_off CMPCONST flushing <= (flushcount > 1); // Verilator lint_on CMPCONST end if (M_AXI_ARREADY) flush_request <= 0; end // }}} // M_AXI_ARVALID // {{{",
            "initial M_AXI_ARVALID = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) M_AXI_ARVALID <= 1'b0; else if (!M_AXI_ARVALID || M_AXI_ARREADY) begin M_AXI_ARVALID <= 1; if (i_new_pc || pending_new_pc) M_AXI_ARVALID <= 1'b1; // // Throttle the number of requests we make // Verilator lint_off CMPCONST // Verilator lint_off WIDTH // out_fill will only capture 0 or 1 if DATA_WIDTH == 32 if (fill + (M_AXI_ARVALID ? 1:0) + ((o_valid &&(!i_ready || out_fill > 1)) ? 1:0) >= FETCH_LIMIT) M_AXI_ARVALID <= 1'b0; // Verilator lint_on WIDTH // Verilator lint_on CMPCONST if (i_cpu_reset || i_clear_cache || full_bus) M_AXI_ARVALID <= 1'b0; end // }}}",
            "assign M_AXI_RREADY = 1'b1; // pending_new_pc // {{{",
            "initial pending_new_pc = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || i_clear_cache) pending_new_pc <= 1'b0; else if (!M_AXI_ARVALID || M_AXI_ARREADY) pending_new_pc <= 1'b0; else if (i_new_pc) pending_new_pc <= 1'b1; // }}} // pending_pc // {{{",
            "initial pending_pc = 0;",
            "always @(posedge S_AXI_ACLK) if (i_new_pc) pending_pc <= i_pc; // }}} // M_AXI_ARADDR // {{{",
            "always @(posedge S_AXI_ACLK) if (!M_AXI_ARVALID || M_AXI_ARREADY) begin if (i_new_pc) M_AXI_ARADDR <= i_pc; else if (pending_new_pc) M_AXI_ARADDR <= pending_pc; else if (M_AXI_ARVALID) begin M_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:AXILLSB] <= M_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:AXILLSB] +1; M_AXI_ARADDR[AXILLSB-1:0] <= 0; end end // }}} // o_pc // {{{",
            "initial o_pc = 0;",
            "always @(posedge S_AXI_ACLK) if (i_new_pc) o_pc <= i_pc; else if (o_valid && i_ready && !o_illegal) begin o_pc <= 0; o_pc[AW-1:INSN_LSB] <= o_pc[AW-1:INSN_LSB] + 1; end // }}} generate if (AXILLSB > INSN_LSB) begin : BIG_WORD // {{{",
            "assign shift = o_pc[AXILLSB-1:INSN_LSB]; // }}} end else begin : NO_SHIFT // {{{",
            "assign shift = 0; // }}} end endgenerate generate if (SWAP_ENDIANNESS) begin : SWAPPED_ENDIANNESS // {{{ genvar gw, gb; // Word count, byte count for(gw=0; gw<C_AXI_DATA_WIDTH/INSN_WIDTH; gw=gw+1) // For each bus word begin : FOR_INSN_WORD for(gb=0; gb<(INSN_WIDTH/8); gb=gb+1) // For each bus byte begin : FOR_INSN_BYTE",
            "always @(*) endian_swapped_rdata[gw*INSN_WIDTH + ((INSN_WIDTH/8)-1-gb)*8 +: 8] = M_AXI_RDATA[gw*INSN_WIDTH+gb*8 +: 8]; end end // }}} end else begin : NO_ENDIAN_SWAP // {{{",
            "always @(*) endian_swapped_rdata = M_AXI_RDATA; // }}} end endgenerate generate if (FETCH_LIMIT <= 1) begin : NOCACHE // {{{ // No cache // assign fifo_rd = fifo_wr; // Verilator lint_off CMPCONST",
            "assign fifo_rd = !o_valid || (i_ready && (out_fill <= 1)); // Verilator lint_on CMPCONST",
            "assign fifo_empty = !fifo_wr; //(out_fill <= (i_aready ? 1:0));",
            "assign fifo_data = { M_AXI_RRESP[1], endian_swapped_rdata };",
            "assign ign_fifo_fill = 1'b0;",
            "assign ign_fifo_full = 1'b0; `ifdef FORMAL",
            "always @(*) if (M_AXI_RVALID || M_AXI_ARVALID || outstanding > 0) assert(!o_valid);",
            "assign f_cache_valid = 1'b0;",
            "assign f_cache_data = 0;",
            "assign f_cache_illegal = 1'b0;",
            "assign f_cache_distance= 0; `endif // }}} end else if (FETCH_LIMIT == 2) begin : DBLFETCH // {{{ // Single word cache",
            "reg cache_valid;",
            "reg [C_AXI_DATA_WIDTH:0] cache_data; // Verilator lint_off CMPCONST",
            "assign fifo_rd = !o_valid || (i_ready && (out_fill <= 1)); // Verilator lint_on CMPCONST",
            "assign fifo_empty =(!M_AXI_RVALID && !cache_valid) || flushing;",
            "assign fifo_data = cache_valid ? cache_data : ({ M_AXI_RRESP[1], endian_swapped_rdata });",
            "assign ign_fifo_fill = cache_valid ? 1 : 0;",
            "assign ign_fifo_full = cache_valid;",
            "initial cache_valid = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (fifo_reset) cache_valid <= 1'b0; else if (M_AXI_RVALID && o_valid && !fifo_rd) cache_valid <= 1; else if (fifo_rd) cache_valid <= 1'b0;",
            "always @(posedge S_AXI_ACLK) if (M_AXI_RVALID) cache_data <= { M_AXI_RRESP[1], endian_swapped_rdata }; // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_dbl;",
            "assign unused_dbl = &{ 1'b0, fifo_wr }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} `ifdef FORMAL",
            "assign f_cache_valid = cache_valid;",
            "assign { f_cache_illegal, f_cache_data } = cache_data;",
            "assign f_cache_distance= 0; `endif // }}} end else begin : FIFO_FETCH // {{{ // FIFO cache `ifdef FORMAL",
            "wire [LGFIFO:0] f_first_addr;",
            "wire [LGFIFO:0] f_second_addr;",
            "wire [C_AXI_DATA_WIDTH:0] f_first_data, f_second_data;",
            "wire f_first_in_fifo, f_second_in_fifo;",
            "wire [LGFIFO:0] f_distance_to_first, f_distance_to_second; `endif // Verilator lint_off CMPCONST // out_fill will only capture 0 or 1 if DATA_WIDTH == 32",
            "assign fifo_rd = !o_valid || (i_ready && (out_fill <= 1)); // Verilator lint_on CMPCONST sfifo #( // {{{ .BW(1+C_AXI_DATA_WIDTH), .LGFLEN(LGFIFO) // }}} ) fcache( // {{{ .i_clk(S_AXI_ACLK), .i_reset(fifo_reset), .i_wr(fifo_wr), .i_data({M_AXI_RRESP[1], endian_swapped_rdata }), .o_full(ign_fifo_full), .o_fill(ign_fifo_fill), .i_rd(fifo_rd),.o_data(fifo_data),.o_empty(fifo_empty) `ifdef FORMAL // {{{ , .f_first_addr(f_first_addr), .f_second_addr(f_second_addr), .f_first_data(f_first_data), .f_second_data(f_second_data), .f_first_in_fifo(f_first_in_fifo), .f_second_in_fifo(f_second_in_fifo), .f_distance_to_first(f_distance_to_first), .f_distance_to_second(f_distance_to_second) // }}} `endif // }}} ); `ifdef FORMAL",
            "assign { f_cache_illegal, f_cache_data } = f_first_data;",
            "assign f_cache_distance = f_distance_to_first;",
            "assign f_cache_valid = f_first_in_fifo; `endif // }}} end endgenerate // o_valid // {{{",
            "initial o_valid = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (fifo_reset) o_valid <= 1'b0; else if (!o_valid || i_ready) o_valid <= (fifo_rd && !fifo_empty) || out_fill > (o_valid ? 1:0); // }}} // out_fill // {{{ // == number of instructions in the fifo_data word that have not (yet) // been accepted by the CPU. // == 0 when no data is available // == INSN_PER_WORD on the first instruction of any word // == 1 on the last instruction of any word",
            "initial out_fill = 0;",
            "always @(posedge S_AXI_ACLK) if (fifo_reset) out_fill <= 0; else if (fifo_rd) begin if (fifo_empty) out_fill <= 0; else if (o_valid) out_fill <= INSNS_PER_WORD[FILLBITS:0]; else // Verilator lint_off WIDTH out_fill <= (INSNS_PER_WORD[FILLBITS:0] - shift); // Verilator lint_on WIDTH end else if (i_ready && out_fill > 0) out_fill <= out_fill - 1; // }}} // out_data // {{{",
            "always @(posedge S_AXI_ACLK) if (fifo_rd) begin if (o_valid || (INSN_WIDTH == C_AXI_DATA_WIDTH)) out_data <= fifo_data[C_AXI_DATA_WIDTH-1:0]; else out_data <= fifo_data[C_AXI_DATA_WIDTH-1:0]>>(INSN_WIDTH*shift); end else if (i_ready) out_data <= out_data >> INSN_WIDTH; // }}}",
            "assign o_insn = out_data[INSN_WIDTH-1:0]; // o_illegal // {{{",
            "initial o_illegal = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (fifo_reset) o_illegal <= 1'b0; else if (!o_illegal && fifo_rd && !fifo_empty) o_illegal <= fifo_data[C_AXI_DATA_WIDTH]; // }}} // Make verilator happy // {{{ // Verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = & { 1'b0, M_AXI_RRESP[0], ign_fifo_full, ign_fifo_fill }; // verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Declarations // {{{",
            "localparam DW=INSN_WIDTH;",
            "localparam F_LGDEPTH=LGDEPTH+2;",
            "reg f_past_valid;",
            "wire [(F_LGDEPTH-1):0] faxil_outstanding; // Verilator lint_off UNUSED",
            "wire [(F_LGDEPTH-1):0] faxil_awr_outstanding, faxil_wr_outstanding; // Verilator lint_on UNUSED",
            "reg [(AW-1):0] f_last_pc;",
            "reg f_last_pc_valid; // reg [AW-1:0] fc_pc, f_address;",
            "reg fc_illegal;",
            "reg [INSN_WIDTH-1:0] fc_insn; //}}} //////////////////////////////////////////////////////////////////////// // // Generic setup // {{{ //////////////////////////////////////////////////////////////////////// // // // Keep track of a flag telling us whether or not $past() // will return valid results",
            "initial f_past_valid = 1'b0;",
            "always @(posedge S_AXI_ACLK) f_past_valid <= 1'b1; // }}} //////////////////////////////////////////////////////////////////////// // // Assumptions about our",
            "input s // {{{ //////////////////////////////////////////////////////////////////////// // // // Assume we start from a reset condition // {{{",
            "always @(*) if (!f_past_valid) assume(!S_AXI_ARESETN);",
            "always @(*) if (!S_AXI_ARESETN) assume(i_cpu_reset); // }}} // // // Let's make some assumptions about how long it takes our // phantom bus and phantom CPU to respond. // // These delays need to be long enough to flush out any potential // errors, yet still short enough that the formal method doesn't // take forever to solve. // localparam F_CPU_DELAY = 4;",
            "reg [$clog2(F_CPU_DELAY):0] f_cpu_delay; // First, let's assume that any response from the bus comes back // within F_WB_DELAY clocks // Here's our delay assumption: We'll assume that the // wishbone will",
            "always respond within F_WB_DELAY clock ticks // of the beginning of any cycle. // // This includes both dropping the stall line, as well as // acknowledging any request. While this may not be // a reasonable assumption for a piped master, it should // work here for us. // Count the number of clocks it takes the CPU to respond to our // instruction.",
            "always @(posedge S_AXI_ACLK) // If no instruction is ready, then keep our counter at zero if (i_cpu_reset|| !o_valid || i_ready) f_cpu_delay <= 0; else // Otherwise, count the clocks the CPU takes to respond f_cpu_delay <= f_cpu_delay + 1'b1; `ifdef PREFETCH // Only *assume* that we are less than F_CPU_DELAY if we are not // integrated into the CPU",
            "always @(posedge S_AXI_ACLK) assume(f_cpu_delay < F_CPU_DELAY); `endif // }}} //////////////////////////////////////////////////////////////////////// // // Bus properties // {{{ //////////////////////////////////////////////////////////////////////// // // faxil_master #( // {{{ .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .F_OPT_READ_ONLY(1'b1), .F_OPT_COVER_BURST(5), .F_OPT_ASSUME_RESET(1'b1), .F_LGDEPTH(F_LGDEPTH) // }}} ) faxil( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // Unused write interface // {{{ .i_axi_awvalid(1'b0), .i_axi_awready(1'b1), .i_axi_awaddr( {(AW){1'b0}}), .i_axi_awprot( 3'h0), .i_axi_wvalid(1'b0), .i_axi_wready(1'b1), .i_axi_wdata({(C_AXI_DATA_WIDTH){1'b0}}), .i_axi_wstrb({(C_AXI_DATA_WIDTH/8){1'b0}}), .i_axi_bvalid(1'b0), .i_axi_bready(1'b1), .i_axi_bresp(2'b00), // }}} // Read address channel // {{{ .i_axi_arvalid(M_AXI_ARVALID), .i_axi_arready(M_AXI_ARREADY), .i_axi_araddr( M_AXI_ARADDR), .i_axi_arprot( 3'h0), // }}} // Read return / data interface // {{{ .i_axi_rvalid(M_AXI_RVALID), .i_axi_rready(M_AXI_RREADY), .i_axi_rdata(M_AXI_RDATA), .i_axi_rresp(M_AXI_RRESP), // }}} .f_axi_awr_outstanding(faxil_awr_outstanding), .f_axi_wr_outstanding(faxil_wr_outstanding), .f_axi_rd_outstanding(faxil_outstanding) // }}} );",
            "always @(*) assert(full_bus == (outstanding >= (1<<LGDEPTH)-1));",
            "always @(*) assert(flushing == (flushcount > 0));",
            "always @(*) assert(flushcount <= outstanding + (flush_request ? 1:0));",
            "always @(posedge S_AXI_ACLK) if (flush_request && !i_clear_cache && !i_cpu_reset) assert(pending_new_pc || i_new_pc);",
            "always @(*) if (!M_AXI_ARVALID || !flushing) assert(!flush_request); // }}} //////////////////////////////////////////////////////////////////////// // // Subword return // {{{ //////////////////////////////////////////////////////////////////////// // // reg [W:0] f_word_count;",
            "reg [AW-1:0] f_return_addr;",
            "reg [AW-1:0] f_out_addr, f_subout_addr;",
            "reg [AW-1:0] f_req_addr, f_ret_addr;",
            "reg [W:0] f_req_offset, f_ret_offset;",
            "always @(*) begin f_req_offset = f_word_count; if (flushing) f_req_offset = f_req_offset - flushcount; if (M_AXI_ARVALID && f_req_offset > 0) f_req_offset = f_req_offset - 1; // Verilator lint_off WIDTH f_req_addr = 0; f_req_addr[AW-1:AXILLSB] = f_out_addr[AW-1:AXILLSB] + f_req_offset; /////////////// f_ret_offset = o_valid ? 1:0; f_ret_offset = f_ret_offset + ign_fifo_fill; f_ret_addr = 0; f_ret_addr[AW-1:AXILLSB] = f_out_addr[AW-1:AXILLSB] + f_ret_offset; end",
            "always @(*) if (S_AXI_ARESETN) begin assert(f_req_offset <= f_word_count); assert(f_req_offset == fill + (o_valid ? 1:0)); assert(f_ret_offset <= f_req_offset); end",
            "always @(*) if (!i_cpu_reset && !i_new_pc && !i_clear_cache && !pending_new_pc && M_AXI_ARADDR != o_pc) assert(M_AXI_ARADDR[AXILLSB-1:0] == 0);",
            "always @(*) if (S_AXI_ARESETN) begin if (!flushing) begin assert(f_word_count <= FETCH_LIMIT); end else assert(f_word_count - flushcount <= FETCH_LIMIT); end",
            "always @(*) if (!i_cpu_reset && !i_new_pc && !i_clear_cache && !flush_request) begin // if (!o_illegal) // assert(f_req_addr[AXILLSB-1:0] == M_AXI_ARADDR[AXILLSB-1:0]); assert(f_req_addr[AW-1:AXILLSB] == M_AXI_ARADDR[AW-1:AXILLSB]); end",
            "always @(*) if (S_AXI_ARESETN && !i_cpu_reset && !i_new_pc && !i_clear_cache && !flushing && !o_illegal) assert(f_ret_addr[AW-1:AXILLSB] == f_return_addr[AW-1:AXILLSB]);",
            "always @(*) begin f_word_count = faxil_outstanding; if (M_AXI_ARVALID) f_word_count = f_word_count + 1; f_word_count = f_word_count + ign_fifo_fill; if (o_valid) f_word_count = f_word_count + 1; end generate if (FETCH_LIMIT <= 1) begin : F_NO_CACHE end else if (FETCH_LIMIT == 2) begin : F_DBLFETCH end else begin : F_FIFO_CACHE end endgenerate",
            "always @(*) begin assert(faxil_outstanding + (M_AXI_ARVALID ? 1:0)<=(1<<LGDEPTH)); assert(faxil_outstanding == { 1'b0, outstanding }); assert(flushcount <= outstanding + (M_AXI_ARVALID ? 1:0)); assert(flushing == (flushcount != 0)); end",
            "always @(*) if (flushing) assert(!o_valid); // }}} //////////////////////////////////////////////////////////////////////// // // I-Fetch contract w/ CPU // {{{ //////////////////////////////////////////////////////////////////////// // // ffetch #( // {{{ .ADDRESS_WIDTH(C_AXI_ADDR_WIDTH-INSN_LSB), .OPT_ALIGNED(1'b0) // }}} ) ffetchi( // {{{ .i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset), .cpu_new_pc(i_new_pc), .cpu_clear_cache(i_clear_cache), .cpu_pc(i_pc), .pf_valid(o_valid), .cpu_ready(i_ready), .pf_pc(o_pc), .pf_insn(o_insn), .pf_illegal(o_illegal), .fc_pc(fc_pc), .fc_illegal(fc_illegal), .fc_insn(fc_insn), .f_address(f_address) // }}} );",
            "always @(*) if (!i_cpu_reset && !i_new_pc && !i_clear_cache && !o_illegal) assert(o_pc == f_address); // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about our",
            "output s // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge S_AXI_ACLK) if ((f_past_valid)&&(!$past(fifo_reset)) &&($past(o_valid && !i_ready))) begin assert(o_valid); assert($stable(o_illegal)); assert($stable(o_insn)); assert($stable(o_pc)); end",
            "always @(posedge S_AXI_ACLK) if ((f_past_valid)&&($past(i_clear_cache))) assert(!o_valid);",
            "always @(*) assert(out_fill <= INSNS_PER_WORD);",
            "always @(*) assert(o_valid == (out_fill >0)); generate if (AXILLSB != INSN_LSB) begin : OUTFILL_CHK",
            "always @(*) if (o_valid && !o_illegal) assert(out_fill == INSNS_PER_WORD - o_pc[AXILLSB-1:INSN_LSB]); end else begin",
            "always @(*) if (S_AXI_ARESETN) assert(out_fill <= 1); end endgenerate // // Assertions about our return responses // {{{ // While the below assertions (currently) appear to just copy the",
            "logic // above, they still have a purpose--they'll help us guarantee that the // logic above will never change without also requiring a change here. // generate if (SWAP_ENDIANNESS) begin : CHECK_SWAPPED_ENDIANNESS // {{{ genvar gw, gb; // Word count, byte count for(gw=0; gw<C_AXI_DATA_WIDTH/INSN_WIDTH; gw=gw+1) // For each bus word begin : FOR_INSN_WORD for(gb=0; gb<(INSN_WIDTH/8); gb=gb+1) // For each bus byte begin : FOR_INSN_BYTE",
            "always @(*) assert(endian_swapped_rdata[gw*INSN_WIDTH+((INSN_WIDTH/8)-1-gb)*8 +: 8] == M_AXI_RDATA[gw*INSN_WIDTH+gb*8 +: 8]); end end // }}} end else begin : CHECK_NO_ENDIAN_SWAP // {{{",
            "always @(*) assert(endian_swapped_rdata == M_AXI_RDATA); // }}} end endgenerate // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Contract checking // {{{ //////////////////////////////////////////////////////////////////////// // // `define CHECK_CONTRACT `ifdef CHECK_CONTRACT (* anyconst *)",
            "reg [AW:0] const_addr; (* anyconst *)",
            "reg [DW-1:0] const_insn;",
            "wire [INSN_WIDTH-1:0] f_bus_word, f_out_data;",
            "initial f_out_addr = 0;",
            "always @(posedge S_AXI_ACLK) if (i_new_pc) f_out_addr <= { i_pc[AW-1:INSN_LSB], {(INSN_LSB){1'b0}} }; else if (o_valid && i_ready && out_fill == 1) begin f_out_addr <= 0; f_out_addr[AW-1:AXILLSB] <= f_out_addr[AW-1:AXILLSB] + 1; end",
            "always @(*) if (out_fill == 0 || out_fill == INSNS_PER_WORD) f_subout_addr = f_out_addr; else begin f_subout_addr = 0; f_subout_addr[AW-1:AXILLSB] = f_out_addr[AW-1:AXILLSB]; f_subout_addr = f_subout_addr + ((INSNS_PER_WORD-out_fill) << INSN_LSB); end",
            "always @(*) assert(f_out_addr[INSN_LSB-1:0] == 0);",
            "always @(*) if (S_AXI_ARESETN && pending_new_pc) assert(f_out_addr[AW-1:INSN_LSB] == pending_pc[AW-1:INSN_LSB]);",
            "always @(*) if (o_valid && !o_illegal) begin assert(f_out_addr[AW-1:AXILLSB] == o_pc[AW-1:AXILLSB]); assert(f_subout_addr[AW-1:INSN_LSB] == o_pc[AW-1:INSN_LSB]); end else if (!i_cpu_reset && !i_clear_cache && !pending_new_pc && !i_new_pc && !o_illegal) begin assert(f_out_addr[AW-1:INSN_LSB] == o_pc[AW-1:INSN_LSB]); end",
            "always @(*) begin f_return_addr={ M_AXI_ARADDR[AW-1:AXILLSB], {(AXILLSB){1'b0}} }; f_return_addr = f_return_addr - ((outstanding - flushcount)<<AXILLSB); end // // // Step 1. Assume any return matches the contract // // generate if (INSN_WIDTH == C_AXI_DATA_WIDTH) begin : F_BUSWORD // {{{",
            "assign f_bus_word = endian_swapped_rdata; // }}} end else begin : BUSWORD_SHIFT // {{{",
            "reg [$clog2(INSNS_PER_WORD)-1:0] bshift; // Verilator lint_off WIDTH",
            "always @(*) bshift = fc_pc[AXILLSB-1:INSN_LSB];",
            "assign f_bus_word = endian_swapped_rdata >> (bshift * INSN_WIDTH); // Verilator lint_on WIDTH // }}} end endgenerate",
            "always @(*) if (M_AXI_RVALID && f_return_addr[AW-1:AXILLSB] == fc_pc[AW-1:AXILLSB]) begin assume(M_AXI_RRESP[1] == fc_illegal); assume(f_bus_word == fc_insn); end // // // Step 2: Assert that any value in our cache meets the contract // // generate if (INSN_WIDTH == C_AXI_DATA_WIDTH) begin : F_OUTDATA // {{{",
            "assign f_out_data = out_data; // }}} end else begin : F_OUTDATA_SHIFT // {{{",
            "reg [$clog2(INSNS_PER_WORD)-1:0] ashift; // Verilator lint_off WIDTH",
            "always @(*) ashift = (fc_pc - f_subout_addr) >> INSN_LSB;",
            "assign f_out_data = out_data >> (ashift * INSN_WIDTH); // Verilator lint_on WIDTH // }}} end endgenerate generate if (FETCH_LIMIT == 1) begin : F_SINGLE end else if (FETCH_LIMIT == 2) begin : F_CACHE_CHECK // {{{",
            "reg [AW-1:0] f_cache_addr;",
            "wire [C_AXI_DATA_WIDTH-1:0] f_cache_insn; // wire f_cache_illegal;",
            "reg f_cache_check;",
            "always @(*) begin f_cache_addr = 0; f_cache_addr[AW-1:AXILLSB] = f_out_addr[AW-1:AXILLSB]+1; f_cache_check = (fc_pc[AW-1:AXILLSB] == f_cache_addr[AW-1:AXILLSB]); if (!f_cache_valid) f_cache_check = 1'b0; end if (INSN_WIDTH == C_AXI_DATA_WIDTH) begin : F_CACHEDATA",
            "assign f_cache_insn = f_cache_data; end else begin : F_CACHEDATA_SHIFT",
            "reg [$clog2(INSNS_PER_WORD)-1:0] ashift;",
            "always @(*) ashift = (fc_pc - f_cache_addr) >> INSN_LSB;",
            "assign f_cache_insn = f_cache_data >> (ashift * INSN_WIDTH); end",
            "always @(*) if (f_cache_check && !o_illegal) begin assert(f_cache_insn[INSN_WIDTH-1:0] == fc_insn); assert(f_cache_illegal == fc_illegal); end // }}} end else begin : F_FIFO_CHECK // {{{",
            "reg [AW-1:0] f_cache_addr, f_fifo_addr;",
            "reg [C_AXI_DATA_WIDTH-1:0] f_cache_subdata, f_fifo_subdata;",
            "reg f_cache_check; // reg [LGFIFO:0] f_cache_distance;",
            "reg f_cache_assume; /* always @(*) { f_cache_illegal, f_cache_data } = { FIFO_FETCH.fcache.f_first_data };",
            "always @(*) f_cache_distance = FIFO_FETCH.fcache.f_distance_to_first;",
            "always @(*) f_cache_valid = FIFO_FETCH.fcache.f_first_in_fifo; */",
            "always @(*) begin f_cache_addr = 0; f_cache_addr[AW-1:AXILLSB] = f_out_addr[AW-1:AXILLSB] + (o_valid ? 1:0) + f_cache_distance; f_cache_check = (fc_pc[AW-1:AXILLSB] == f_cache_addr[AW-1:AXILLSB]); if (!f_cache_valid) f_cache_check = 1'b0; end if (INSN_WIDTH == C_AXI_DATA_WIDTH) begin : F_CACHEDATA",
            "always @(*) f_cache_subdata = f_cache_data;",
            "always @(*) f_fifo_subdata = fifo_data[INSN_WIDTH-1:0]; end else begin : F_CACHEDATA_SHIFT",
            "reg [$clog2(INSNS_PER_WORD)-1:0] ashift; // Verilator lint_off WIDTH",
            "always @(*) ashift = (fc_pc - f_cache_addr) >> INSN_LSB; // Verilator lint_on WIDTH",
            "always @(*) f_cache_subdata = f_cache_data >> (ashift * INSN_WIDTH);",
            "always @(*) f_fifo_subdata = fifo_data >> (ashift * INSN_WIDTH); end",
            "always @(*) begin f_fifo_addr = 0; f_fifo_addr[AW-1:AXILLSB] = f_out_addr[AW-1:AXILLSB] + (o_valid ? 1:0); end",
            "always @(*) if (f_cache_check && !o_illegal) begin assert(f_cache_subdata[INSN_WIDTH-1:0] == fc_insn); assert(f_cache_illegal == fc_illegal); end",
            "always @(*) begin f_cache_assume = 0; if (ign_fifo_fill != 0 && (f_fifo_addr[AW-1:AXILLSB] == fc_pc[AW-1:AXILLSB])) begin if (!f_cache_check || o_illegal) f_cache_assume = 1; if (f_cache_addr[AW-1:AXILLSB] != f_fifo_addr[AW-1:AXILLSB]) f_cache_assume = 1; end end",
            "always @(*) if (f_cache_assume) begin assume(f_fifo_subdata[INSN_WIDTH-1:0] == fc_insn); assume(fifo_data[C_AXI_DATA_WIDTH] == fc_illegal); end // }}} end endgenerate // // Check the final",
            "output word // This checks all instruction positions within that word",
            "always @(*) if ((out_fill > 0) && (fc_pc[AW-1:AXILLSB] == f_out_addr[AW-1:AXILLSB])) begin if (fc_illegal) begin assert(o_illegal); end else if (!o_illegal && fc_pc >= f_subout_addr) assert(f_out_data == fc_insn); end",
            "always @(*) if (pending_new_pc) assert(i_new_pc || flush_request);",
            "always @(*) if (pending_new_pc) assert(o_pc == pending_pc); // Verilator lint_off WIDTH",
            "always @(*) if (flush_request) assert(flushcount == faxil_outstanding + 1); // Verilator lint_on WIDTH",
            "always @(*) if (flushing) assert(!o_illegal);",
            "always @(*) if (flush_request && !i_cpu_reset && !i_new_pc && !i_clear_cache) begin assert(f_out_addr[AW-1:AXILLSB] == pending_pc[AW-1:AXILLSB]); assert(o_pc == pending_pc); end `endif // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // // Verilator lint_off UNDRIVEN (* anyconst *)",
            "reg cvr_",
            "always _ready; // Verilator lint_on UNDRIVEN",
            "reg [3:0] cvr_returns;",
            "always @(*) if (cvr_",
            "always _ready) assume(M_AXI_ARREADY);",
            "initial cvr_returns = 0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset || i_new_pc || i_clear_cache || o_illegal) cvr_returns <= 0; else if (o_valid && i_ready && !cvr_returns[3]) cvr_returns <= cvr_returns + 1;",
            "always @(*) begin cover(cvr_returns == 4'b0100); cover(cvr_returns == 4'b0101); cover(cvr_returns == 4'b0110 && cvr_",
            "always _ready); end // }}} // Make Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused_formal;",
            "assign unused_formal = &{ 1'b0, f_ret_addr[AXILLSB-1:0] }; // Verilator lint_on UNUSED // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "iscachable.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/iscachable.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: iscachable.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A helper function to both dcache and its formal properties, // used to determine when a particular address is cachable. This // module must be built of entirely combinatorial",
            "logic and nothing more. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2018-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module iscachable #( // {{{",
            "parameter ADDRESS_WIDTH=32, localparam AW = ADDRESS_WIDTH, // Just for ease of notation below",
            "parameter [AW-1:0] SDRAM_ADDR = 0, SDRAM_MASK = 0, parameter [AW-1:0] BKRAM_ADDR = 32'h10000000, BKRAM_MASK = 32'h10000000, parameter [AW-1:0] FLASH_ADDR = 0, FLASH_MASK = 0 // }}} ) ( // {{{",
            "input wire [AW-1:0] i_addr, output reg o_cachable // }}} );",
            "always @(*) begin o_cachable = 1'b0; if ((SDRAM_ADDR !=0)&&((i_addr & SDRAM_MASK)== SDRAM_ADDR)) o_cachable = 1'b1; else if ((FLASH_ADDR !=0)&&((i_addr & FLASH_MASK)== FLASH_ADDR)) o_cachable = 1'b1; else if ((BKRAM_ADDR !=0)&&((i_addr & BKRAM_MASK)== BKRAM_ADDR)) o_cachable = 1'b1; end",
            "endmodule"
        ]
    },
    {
        "file_name": "idecode.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/idecode.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: idecode.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This RTL file specifies how instructions are to be decoded // into their underlying meanings. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module idecode #( // {{{",
            "parameter ADDRESS_WIDTH=24, parameter [0:0] OPT_MPY = 1'b1, parameter [0:0] OPT_SHIFTS = 1'b1, parameter [0:0] OPT_EARLY_BRANCHING = 1'b1, parameter [0:0] OPT_PIPELINED = 1'b1, parameter [0:0] OPT_DIVIDE = (OPT_PIPELINED), parameter [0:0] OPT_FPU = 1'b0, parameter [0:0] OPT_CIS = 1'b1, parameter [0:0] OPT_LOCK = (OPT_PIPELINED), parameter [0:0] OPT_OPIPE = (OPT_PIPELINED), parameter [0:0] OPT_SIM = 1'b0, parameter [0:0] OPT_SUPPRESS_NULL_BRANCHES = 1'b0, parameter [0:0] OPT_USERMODE = 1'b1, parameter [0:0] OPT_LOWPOWER = 1'b0, localparam AW = ADDRESS_WIDTH // }}} ) ( // {{{",
            "input wire i_clk, i_reset, i_ce, i_stalled, input wire [31:0] i_instruction, input wire i_gie, input wire [(AW+1):0] i_pc, input wire i_pf_valid, i_illegal, output wire o_valid, o_phase, output reg o_illegal, output reg [(AW+1):0] o_pc, output reg [6:0] o_dcdR, o_dcdA, o_dcdB, output wire [4:0] o_preA, o_preB, output wire [31:0] o_I, output reg o_zI, output reg [3:0] o_cond, output reg o_wF, output reg [3:0] o_op, output reg o_ALU, o_M, o_DV, o_FP, o_break, output reg o_lock, output reg o_wR, o_rA, o_rB, output wire o_early_branch, o_early_branch_stb, output wire [(AW+1):0] o_branch_pc, output wire o_ljmp, output wire o_pipe, output reg o_sim, output reg [22:0] o_sim_immv `ifdef FORMAL , output reg [31:0] f_insn_word, output reg f_insn_gie, output wire f_insn_is_pipeable `endif // }}} ); // Declarations // {{{",
            "localparam [3:0] CPU_SP_REG = 4'hd, CPU_CC_REG = 4'he, CPU_PC_REG = 4'hf;",
            "localparam CISBIT = 31, CISIMMSEL = 23, IMMSEL = 18;",
            "wire [4:0] w_op;",
            "wire w_ldi, w_mov, w_cmptst, w_ldilo, w_ALU, w_brev, w_noop, w_lock, w_sim, w_break, w_special, w_add, w_mpy;",
            "wire [4:0] w_dcdR, w_dcdB, w_dcdA;",
            "wire w_dcdR_pc, w_dcdR_cc;",
            "wire w_dcdA_pc, w_dcdA_cc;",
            "wire w_dcdB_pc, w_dcdB_cc;",
            "wire [3:0] w_cond;",
            "wire w_wF, w_mem, w_sto, w_div, w_fpu;",
            "wire w_wR, w_rA, w_rB, w_wR_n;",
            "wire w_ljmp, w_ljmp_dly, w_cis_ljmp;",
            "wire [31:0] iword;",
            "wire pf_valid;",
            "reg [14:0] r_nxt_half;",
            "reg [4:0] w_cis_op;",
            "reg [22:0] r_I, w_fullI;",
            "wire [22:0] w_I;",
            "wire w_Iz;",
            "reg [1:0] w_immsrc;",
            "reg r_valid;",
            "wire insn_is_pipeable, illegal_shift; // }}}",
            "assign pf_valid = (i_pf_valid)&&(!o_early_branch_stb); // iword // {{{ generate if (OPT_CIS) begin : SET_IWORD",
            "assign iword = (o_phase) // set second half as a NOOP ... but really // shouldn't matter ? { 1'b1, r_nxt_half[14:0], i_instruction[15:0] } : i_instruction; end else begin : CLR_IWORD",
            "assign iword = { 1'b0, i_instruction[30:0] }; // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused_nxt_half;",
            "assign unused_nxt_half = &{ 1'b0, r_nxt_half }; // verilator lint_on UNUSED // verilator coverage_on end endgenerate // }}} // w_ljmp, w_cis_ljmp : Long jump early branching // {{{ generate if (OPT_EARLY_BRANCHING) begin : GEN_CIS_LONGJUMP if (OPT_CIS) begin : CIS_EARLY_BRANCHING",
            "assign w_cis_ljmp = (o_phase)&&(iword[31:16] == 16'hfcf8); end else begin : NOCIS_EARLY_BRANCH",
            "assign w_cis_ljmp = 1'b0; end",
            "assign w_ljmp = (iword == 32'h7c87c000); end else begin : NO_CIS_JUMPING",
            "assign w_cis_ljmp = 1'b0;",
            "assign w_ljmp = 1'b0; end endgenerate // }}} // w_cis_op : Get the opcode // {{{ generate if (OPT_CIS) begin : GEN_CIS_OP",
            "always @(*) if (!iword[CISBIT]) w_cis_op = iword[26:22]; else case(iword[26:24]) 3'h0: w_cis_op = 5'h00; // SUB 3'h1: w_cis_op = 5'h01; // AND 3'h2: w_cis_op = 5'h02; // ADD 3'h3: w_cis_op = 5'h10; // CMP 3'h4: w_cis_op = 5'h12; // LW 3'h5: w_cis_op = 5'h13; // SW 3'h6: w_cis_op = 5'h18; // LDI 3'h7: w_cis_op = 5'h0d; // MOV endcase end else begin : GEN_NOCIS_OP",
            "always @(*) w_cis_op = w_op; end endgenerate // }}} // Decode instructions // {{{",
            "assign w_op= iword[26:22];",
            "assign w_mov = (w_cis_op == 5'h0d);",
            "assign w_ldi = (w_cis_op[4:1] == 4'hc);",
            "assign w_brev = (w_cis_op == 5'h08);",
            "assign w_mpy = (w_cis_op[4:1] == 4'h5)||(w_cis_op[4:0]==5'h0c);",
            "assign w_cmptst = (w_cis_op[4:1] == 4'h8);",
            "assign w_ldilo = (w_cis_op[4:0] == 5'h09);",
            "assign w_ALU = (!w_cis_op[4]) // anything with [4]==0, but ... &&(w_cis_op[3:1] != 3'h7); // not the divide",
            "assign w_add = (w_cis_op[4:0] == 5'h02);",
            "assign w_mem = (w_cis_op[4:3] == 2'b10)&&(w_cis_op[2:1] !=2'b00);",
            "assign w_sto = (w_mem)&&( w_cis_op[0]);",
            "assign w_div = (!iword[CISBIT])&&(w_op[4:1] == 4'h7);",
            "assign w_fpu = (!iword[CISBIT])&&(w_op[4:3] == 2'b11) &&(w_dcdR[3:1] != 3'h7) &&(w_op[2:1] != 2'b00); // If the result",
            "reg ister is either CC or PC, and this would otherwise // be a floating point instruction with floating point opcode of 0, // then this is a NOOP.",
            "assign w_special= (!iword[CISBIT])&&(w_dcdR[3:1]==3'h7) &&(w_op[4:2] == 3'b111);",
            "assign w_break = (w_special)&&(w_op[4:0]==5'h1c);",
            "assign w_lock = (w_special)&&(w_op[4:0]==5'h1d);",
            "assign w_sim = (w_special)&&(w_op[4:0]==5'h1e);",
            "assign w_noop = (w_special)&&(w_op[4:1]==4'hf); // Must include w_sim `ifdef FORMAL",
            "always @(*) assert(!w_special || !w_fpu); `endif // }}} // w_dcdR, w_dcdA // {{{ // What",
            "reg ister will we be placing results into (if at all)? // // Two parts to the result",
            "reg ister: the",
            "reg ister set, given for // moves in iword[18] but only for the supervisor, and the other // four bits encoded in the instruction. // assign w_dcdR = { ((!iword[CISBIT])&&(OPT_USERMODE)&&(w_mov)&&(!i_gie))?iword[IMMSEL]:i_gie, iword[30:27] }; // 0 LUTs",
            "assign w_dcdA = w_dcdR; // on ZipCPU, A is",
            "always result",
            "reg // 0 LUTs",
            "assign w_dcdA_pc = w_dcdR_pc;",
            "assign w_dcdA_cc = w_dcdR_cc; // 2 LUTs, 1 delay each",
            "assign w_dcdR_pc = (w_dcdR == {i_gie, CPU_PC_REG});",
            "assign w_dcdR_cc = (w_dcdR == {i_gie, CPU_CC_REG}); // }}} // dcdB - What",
            "reg ister is used in the opB? // {{{",
            "assign w_dcdB[4] = ((!iword[CISBIT])&&(w_mov)&&(OPT_USERMODE)&&(!i_gie))?iword[13]:i_gie;",
            "assign w_dcdB[3:0]= (iword[CISBIT]) ? (((!iword[CISIMMSEL])&&(iword[26:25]==2'b10)) ? CPU_SP_REG : iword[22:19]) : iword[17:14]; // 2 LUTs, 1 delays each",
            "assign w_dcdB_pc = (w_rB)&&(w_dcdB[3:0] == CPU_PC_REG);",
            "assign w_dcdB_cc = (w_rB)&&(w_dcdB[3:0] == CPU_CC_REG); // }}} // w_cond // {{{ // Under what condition will we execute this instruction? Only the // load immediate instruction and the CIS instructions are completely // unconditional. Well ... not quite. The BREAK, LOCK, and SIM/NOOP // instructions are also unconditional. // assign w_cond = ((w_ldi)||(w_special)||(iword[CISBIT])) ? 4'h8 : { (iword[21:19]==3'h0), iword[21:19] }; // }}} // rA - do we need to read",
            "reg ister A? // {{{",
            "assign w_rA = // Floating point reads",
            "reg A (w_fpu) // Divide's read A ||(w_div) // ALU ops read A, // except for MOV's and BREV's which don't ||((w_ALU)&&(!w_brev)&&(!w_mov)) // STO's read A ||(w_sto) // Test/compares ||(w_cmptst); // }}} // rB -- do we read a",
            "reg ister for operand B? // {{{ // Specifically, do we add the",
            "reg isters value to the immediate to // create opB?",
            "assign w_rB = (w_mov) ||((!iword[CISBIT])&&(iword[IMMSEL])&&(!w_ldi)&&(!w_special)) ||(( iword[CISBIT])&&(iword[CISIMMSEL])&&(!w_ldi)) // If using compressed instruction sets, // we *",
            "always * read on memory operands. ||(( iword[CISBIT])&&(w_mem)); // }}} // wR -- will we be writing our result back? // {{{ // wR_n = !wR // All but STO, NOOP/BREAK/LOCK, and CMP/TST write back to w_dcdR",
            "assign w_wR_n = (w_sto) ||(w_special) ||(w_cmptst);",
            "assign w_wR = !w_wR_n; // }}} // // wF -- do we write flags when we are done? // {{{",
            "assign w_wF = (w_cmptst) ||((w_cond[3])&&(w_fpu||w_div ||((w_ALU)&&(!w_mov)&&(!w_ldilo)&&(!w_brev) &&(w_dcdR[3:1] != 3'h7)))); // }}} // w_immsrc - where does the immediate value come from // {{{ // Bottom 13 bits: no LUT's // w_dcd[12: 0] -- no LUTs // w_dcd[ 13] -- 2 LUTs // w_dcd[17:14] -- (5+i0+i1) = 3 LUTs, 1 delay // w_dcd[22:18] : 5 LUTs, 1 delay (assuming high bit is o/w determined)",
            "always @(*) if (w_ldi) w_immsrc = 0; else if (w_mov) w_immsrc = 1; else if (!iword[IMMSEL]) w_immsrc = 2; else // if (!iword[IMMSEL]) w_immsrc = 3; // }}} // w_fullI -- extracting the immediate value from the insn word // {{{",
            "always @(*) case(w_immsrc) 2'b00: w_fullI = { iword[22:0] }; // LDI 2'b01: w_fullI = { {(23-13){iword[12]}}, iword[12:0] }; // MOV 2'b10: w_fullI = { {(23-18){iword[17]}}, iword[17:0] }; // Immediate 2'b11: w_fullI = { {(23-14){iword[13]}}, iword[13:0] }; // Reg + Imm endcase /* assign w_fullI = (w_ldi) ? { iword[22:0] } // LDI // MOVE immediates have one less bit :((w_mov) ?{ {(23-13){iword[12]}}, iword[12:0] } // Normal Op-B immediate ... 18 or 14 bits :((!iword[IMMSEL]) ? { {(23-18){iword[17]}}, iword[17:0] } : { {(23-14){iword[13]}}, iword[13:0] } )); */ // }}} // w_I and w_Iz: Immediate value decoding // {{{ generate if (OPT_CIS) begin : GEN_CIS_IMMEDIATE",
            "wire [7:0] w_halfI, w_halfbits;",
            "assign w_halfbits = iword[CISIMMSEL:16];",
            "assign w_halfI = (iword[26:24]==3'h6) ? w_halfbits[7:0] // 8'b for LDI :(w_halfbits[7])? { {(6){w_halfbits[2]}}, w_halfbits[1:0]} :{ w_halfbits[6], w_halfbits[6:0] };",
            "assign w_I = (iword[CISBIT]) ? {{(23-8){w_halfI[7]}}, w_halfI } : w_fullI; end else begin : GEN_NOCIS_IMMEDIATE",
            "assign w_I = w_fullI; end endgenerate",
            "assign w_Iz = (w_I == 0); // }}} // o_phase // {{{ // The o_phase",
            "parameter is special. It needs to let the software // following know that it cannot break/interrupt on an o_phase asserted // instruction, lest the break take place between the first and second // half of a CIS instruction. To do this, o_phase must be asserted // when the first instruction half is valid, but not asserted on either // a 32-bit instruction or the second half of a 2x16-bit instruction. generate if (OPT_CIS) begin : GEN_CIS_PHASE // {{{",
            "reg r_phase; // Phase is '1' on the first instruction of a two-part set // But, due to the delay in processing, it's '1' when our // output is valid for that first part, but that'll be the // same time we are processing the second part ... so it may // look to us like a '1' on the second half of processing. // When no instruction is in the pipe, phase is zero",
            "initial r_phase = 1'b0;",
            "always @(posedge i_clk) if (i_reset || w_ljmp_dly) r_phase <= 1'b0; else if ((i_ce)&&(pf_valid)) begin if (o_phase) // CIS instructions only have two parts. On // the second part (o_phase is true), return // back to the first r_phase <= 0; else r_phase <= (i_instruction[CISBIT])&&(!i_illegal); end else if (i_ce) r_phase <= 1'b0;",
            "assign o_phase = r_phase; // }}} end else begin : NO_CIS // {{{",
            "assign o_phase = 1'b0; // }}} end endgenerate // }}} // illegal_shift // {{{ generate if (OPT_SHIFTS) begin : LEGAL_SHIFTS",
            "assign illegal_shift = 1'b0; end else begin : GEN_ILLEGAL_SHIFT",
            "reg r_illegal_shift;",
            "always @(*) begin r_illegal_shift = 1'b1; if (i_instruction[CISBIT]) r_illegal_shift = 1'b0; else if ((i_instruction[26:22] != 5'h5) &&(i_instruction[26:22] != 5'h6) &&(i_instruction[26:22] != 5'h7)) r_illegal_shift = 1'b0; else if (!i_instruction[18] && (i_instruction[17:0] == 18'h1)) r_illegal_shift = 1'b0; end",
            "assign illegal_shift = r_illegal_shift; end endgenerate // }}} // o_illegal // {{{",
            "initial o_illegal = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_illegal <= 1'b0; else if (i_ce && o_phase) begin // {{{ o_illegal <= o_illegal; // Cannot happen in compressed word ... // 1. multiply op-codes // 2. divide opcodes // 3. FPU opcodes // 4. special opcodes // }}} end else if (i_ce && i_pf_valid) begin // {{{ o_illegal <= 1'b0; if (illegal_shift) o_illegal <= 1'b1; if ((!OPT_CIS)&&(i_instruction[CISBIT])) o_illegal <= 1'b1; if ((!OPT_MPY)&&(w_mpy)) o_illegal <= 1'b1; if ((!OPT_DIVIDE)&&(w_div)) o_illegal <= 1'b1; else if ((OPT_DIVIDE)&&(w_div)&&(w_dcdR[3:1]==3'h7)) o_illegal <= 1'b1; if ((!OPT_FPU)&&(w_fpu)) o_illegal <= 1'b1; if ((!OPT_SIM)&&(w_sim)) // Simulation instructions on real hardware should // always cause an illegal instruction error o_illegal <= 1'b1; // There are two (missing) special instructions, after // BREAK, LOCK, SIM, and NOOP. These are special if their // (unused-result)",
            "reg ister is either the PC or CC",
            "reg ister. // // These should cause an illegal instruction error if ((w_dcdR[3:1]==3'h7)&&(w_cis_op[4:1]==4'b1101)) o_illegal <= 1'b1; // If the lock function isn't implemented, this should // also cause an illegal instruction error if ((!OPT_LOCK)&&(w_lock)) o_illegal <= 1'b1; // Bus errors",
            "always create illegal instructions if (i_illegal) o_illegal <= 1'b1; // }}} end // }}} // o_pc // {{{",
            "initial o_pc = 0;",
            "always @(posedge i_clk) if ((i_ce)&&((o_phase)||(i_pf_valid))) begin o_pc[0] <= 1'b0; if (OPT_CIS) begin if (iword[CISBIT]) begin if (o_phase) o_pc[AW+1:1] <= o_pc[AW+1:1] + 1'b1; else o_pc <= { i_pc[AW+1:2], 1'b1, 1'b0 }; end else begin // The normal, non-CIS case o_pc <= { i_pc[AW+1:2] + 1'b1, 2'b00 }; end end else begin // The normal, non-CIS case o_pc <= { i_pc[AW+1:2] + 1'b1, 2'b00 }; end end // }}} // Generate",
            "output products // {{{",
            "initial o_dcdR = 0;",
            "initial o_dcdA = 0;",
            "initial o_dcdB = 0;",
            "initial o_DV = 0;",
            "initial o_FP = 0;",
            "initial o_lock = 0;",
            "initial o_sim = 1'b0;",
            "initial o_sim_immv = 0; // r_I, o_zI, o_wR, o_rA, o_rB, o_dcdR, o_dcdA, o_dcdB",
            "always @(posedge i_clk) if (i_ce) begin // {{{ // o_cond, o_wF // {{{ // Under what condition will we execute this // instruction? Only the load immediate instruction // is completely unconditional. o_cond <= w_cond; // Don't change the flags on conditional instructions, // UNLESS: the conditional instruction was a CMP // or TST instruction. o_wF <= w_wF; // }}} // o_op // {{{ // Record what operation/op-code (4-bits) we are doing // Note that LDI magically becomes a MOV // instruction here. That way it's a pass through // the ALU. Likewise, the two compare instructions // CMP and TST becomes SUB and AND here as well. // We keep only the bottom four bits, since we've // already done the rest of the decode necessary to // settle between the other instructions. For example, // o_FP plus these four bits uniquely defines the FP // instruction, o_DV plus the bottom of these defines // the divide, etc. o_op <= w_cis_op[3:0]; if ((w_ldi)||(w_noop)||(w_lock)) o_op <= 4'hd; // }}} o_dcdR <= { w_dcdR_cc, w_dcdR_pc, w_dcdR}; o_dcdA <= { w_dcdA_cc, w_dcdA_pc, w_dcdA}; o_dcdB <= { w_dcdB_cc, w_dcdB_pc, w_dcdB}; o_wR <= w_wR; o_rA <= w_rA; o_rB <= w_rB; r_I <= w_I; o_zI <= w_Iz; // o_ALU, o_M, o_DV, o_FP // {{{ // Turn a NOOP into an ALU operation--subtract in // particular, although it doesn't really matter as long // as it doesn't take longer than one clock. Note // also that this depends upon not setting any",
            "reg isters // or flags, which should already be true. o_ALU <= (w_ALU)||(w_ldi)||(w_cmptst)||(w_noop) ||((!OPT_LOCK)&&(w_lock)); o_M <= w_mem; o_DV <= (OPT_DIVIDE)&&(w_div); o_FP <= (OPT_FPU)&&(w_fpu); // }}} // o_break, o_lock // {{{ o_break <= w_break; o_lock <= (OPT_LOCK)&&(w_lock); // }}} if (OPT_CIS) r_nxt_half <= { iword[14:0] }; else r_nxt_half <= 0; // o_sim, o_sim_immv -- simulation instructions vs NOOPs // {{{ if (OPT_SIM) begin // Support the SIM instruction(s) o_sim <= (w_sim)||(w_noop); o_sim_immv <= iword[22:0]; if (OPT_LOWPOWER && !w_sim && !w_noop) o_sim_immv <= 0; end else begin o_sim <= 1'b0; o_sim_immv <= 0; end // }}} // }}} end // }}}",
            "assign o_preA = w_dcdA;",
            "assign o_preB = w_dcdB; // o_early_branch, o_early_branch_stb, o_branch_pc // {{{ generate if (OPT_EARLY_BRANCHING) begin : GEN_EARLY_BRANCH_LOGIC // {{{",
            "reg r_early_branch, r_early_branch_stb, r_ljmp;",
            "reg [(AW+1):0] r_branch_pc;",
            "wire w_add_to_pc;",
            "initial r_ljmp = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_ljmp <= 1'b0; else if (i_ce) begin if ((r_ljmp)&&(pf_valid)) r_ljmp <= 1'b0; else if (o_early_branch_stb) r_ljmp <= 1'b0; else if (pf_valid) begin if ((OPT_CIS)&&(iword[CISBIT])) r_ljmp <= w_cis_ljmp; else r_ljmp <= (w_ljmp); end else if ((OPT_CIS)&&(o_phase)&&(iword[CISBIT])) r_ljmp <= w_cis_ljmp; end",
            "assign o_ljmp = r_ljmp;",
            "assign w_add_to_pc = (!o_phase && (!OPT_CIS || !i_instruction[CISBIT]) && (i_instruction[30:27]==CPU_PC_REG) // Rd=PC && (i_instruction[26:22] == 5'h02) // ADD && (i_instruction[21:19]==3'h0) // NONE && !i_instruction[IMMSEL]);",
            "initial r_early_branch = 1'b0;",
            "initial r_early_branch_stb = 1'b0;",
            "always @(posedge i_clk) if (i_reset) begin r_early_branch <= 1'b0; r_early_branch_stb <= 1'b0; end else if (i_ce && pf_valid) begin if (r_ljmp) begin // LW (PC),PC r_early_branch <= 1'b1; r_early_branch_stb <= 1'b1; end else if (w_add_to_pc) begin // Add x,PC r_early_branch <= 1'b1; r_early_branch_stb <= (!OPT_SUPPRESS_NULL_BRANCHES) || (i_instruction[IMMSEL-1:0] != 0); // LDI #x,PC is no longer supported end else begin r_early_branch <= 1'b0; r_early_branch_stb <= 1'b0; end end else begin r_early_branch_stb <= 1'b0; if (i_ce) r_early_branch <= 1'b0; end",
            "initial r_branch_pc = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && i_reset) r_branch_pc <= 0; else if (i_ce) begin if (r_ljmp) r_branch_pc <= { iword[(AW+1):2], 2'b00 }; else if (!OPT_LOWPOWER || w_add_to_pc) begin // Add x,PC r_branch_pc[AW+1:2] <= i_pc[AW+1:2] + {{(AW-15){i_instruction[17]}}, i_instruction[16:2]} + {{(AW-1){1'b0}},1'b1}; r_branch_pc[1:0] <= 2'b00; end else if (OPT_LOWPOWER) r_branch_pc <= 0; if (OPT_LOWPOWER && !pf_valid) r_branch_pc <= 0; end",
            "assign w_ljmp_dly = r_ljmp;",
            "assign o_early_branch = r_early_branch;",
            "assign o_early_branch_stb = r_early_branch_stb;",
            "assign o_branch_pc = r_branch_pc; `ifdef FORMAL",
            "always @(*) if (OPT_LOWPOWER && !r_early_branch) assert(r_branch_pc == 0); `endif // }}} end else begin : NO_EARLY_BRANCHING // {{{",
            "assign w_ljmp_dly = 1'b0;",
            "assign o_early_branch = 1'b0;",
            "assign o_early_branch_stb = 1'b0;",
            "assign o_branch_pc = {(AW+2){1'b0}};",
            "assign o_ljmp = 1'b0; // verilator coverage_off // verilator lint_off UNUSED",
            "wire early_branch_unused;",
            "assign early_branch_unused = &{ 1'b0, w_add }; // verilator lint_on UNUSED // verilator coverage_on // }}} end endgenerate // }}} // o_pipe // {{{ // To be a pipeable operation there must be ... // 1. Two valid adjacent instructions // 2. Both must be memory operations, of the same time (both lods // or both stos) // 3. Both must use the same",
            "reg ister base address // 4. Both must be to the same address, or the address incremented // by one // Note that we're not using iword here ... there's a lot of",
            "logic // taking place, and it's only valid if the new word is not compressed. // generate if (OPT_OPIPE) begin : GEN_OPIPE // {{{",
            "reg r_pipe, r_insn_is_pipeable; // Pipeline",
            "logic is too extreme for a single clock. // Let's break it into two clocks, using r_insn_is_pipeable // If this function is true, then the instruction associated // with the current",
            "output *may* have a pipeable instruction // following it. // initial r_insn_is_pipeable = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_insn_is_pipeable <= 1'b0; else if ((i_ce)&&((!pf_valid)||(i_illegal))&&(!o_phase)) // Pipeline bubble, can't pipe through it r_insn_is_pipeable <= 1'b0; else if (o_ljmp) r_insn_is_pipeable <= 1'b0; else if ((i_ce)&&((!OPT_CIS)&&(i_instruction[CISBIT]))) r_insn_is_pipeable <= 1'b0; else if (i_ce) begin // This is a valid instruction r_insn_is_pipeable <= (w_mem)&&(w_rB) // PC (and CC)",
            "reg isters can change // underneath us. Therefore they cannot // be used as a base",
            "reg ister for piped // memory ops &&(w_dcdB[3:1] != 3'h7) // Writes to PC or CC will destroy any // possibility of pipeing--since they // could create a jump &&(w_dcdR[3:1] != 3'h7) // // Loads landing in the current address // pointer",
            "reg ister are not allowed, // as they could then be used to violate // our rule(s) &&((w_cis_op[0])||(w_dcdB != w_dcdA)); end // else // The pipeline is stalled",
            "assign insn_is_pipeable = r_insn_is_pipeable;",
            "initial r_pipe = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_pipe <= 1'b0; else if (i_ce) r_pipe <= ((pf_valid)||(o_phase)) // The last operation must be capable of // being followed by a pipeable memory op &&(r_insn_is_pipeable) // Both must be memory operations &&(w_mem) // Both must be writes, or both stores &&(o_op[0] == w_cis_op[0]) // Both must be",
            "reg ister ops &&(w_rB) // Both must use the same",
            "reg ister for B &&(w_dcdB[3:0] == o_dcdB[3:0]); // // CC or PC",
            "reg isters are not valid addresses // // Captured above // // But ... the result can never be B // // Captured above // // // // Reads to CC or PC not allowed // // &&((o_op[0])||(w_dcdR[3:1] != 3'h7)) // // Prior-reads to CC or PC not allowed // // Captured above // // Same condition, or no condition now // &&((w_cond[2:0]==o_cond[2:0]) // ||(w_cond[2:0] == 3'h0)); // // Same or incrementing immediate // &&(w_I[22]==r_I[22]);",
            "assign o_pipe = r_pipe; // }}} end else begin : GEN_NO_PIPE // {{{",
            "assign o_pipe = 1'b0;",
            "assign insn_is_pipeable = 1'b0; // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused_pipable;",
            "assign unused_pipable = &{ 1'b0, insn_is_pipeable }; // verilator lint_on UNUSED // verilator coverage_on // }}} end endgenerate // }}} // o_valid // {{{",
            "initial r_valid = 1'b0; generate if (OPT_PIPELINED) begin : GEN_DCD_VALID",
            "always @(posedge i_clk) if (i_reset) r_valid <= 1'b0; else if (i_ce) r_valid <= ((pf_valid)||(o_phase))&&(!o_ljmp); else if (!i_stalled) r_valid <= 1'b0; end else begin : GEN_DCD_VALID",
            "always @(posedge i_clk) if (i_reset) r_valid <= 1'b0; else if (!i_stalled) r_valid <= ((pf_valid)||(o_phase))&&(!o_ljmp); else r_valid <= 1'b0; end endgenerate",
            "assign o_valid = r_valid; // }}}",
            "assign o_I = { {(32-22){r_I[22]}}, r_I[21:0] }; // Make Verilator happy across all our various options // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire possibly_unused;",
            "assign possibly_unused = &{ 1'b0, w_lock, w_ljmp, w_ljmp_dly, insn_is_pipeable, w_cis_ljmp, i_pc[1:0], w_add }; // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; `define ASSERT assert `ifdef IDECODE `define ASSUME assume `else `define ASSUME assert `endif",
            "always @(posedge i_clk) if ((i_ce)&&(i_pf_valid)&&(!o_phase)) f_insn_word <= i_instruction;",
            "assign f_insn_is_pipeable = insn_is_pipeable;",
            "always @(posedge i_clk) if ((i_ce)&&(i_pf_valid)&&(!o_phase)) f_insn_gie <= i_gie;",
            "always @(posedge i_clk) if (!i_reset && o_valid) `ASSUME(f_insn_gie == i_gie);",
            "always @(*) if (o_phase) assert(r_nxt_half == f_insn_word[14:0]); //////////////////////////// // // // Assumptions about our",
            "input s // // /////////////////////////// always @(*) if (OPT_PIPELINED) begin `ASSUME(i_ce == ((!o_valid)||(!i_stalled))); end else `ASSUME(i_ce == !i_stalled);",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset)) begin `ASSERT(!o_valid); // `ASSERT(!o_illegal); `ASSERT(!o_phase); `ASSERT(!o_ljmp); `ASSERT(!o_pipe); // `ASSUME(!i_pf_valid); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!i_reset)) `ASSUME(i_gie == $past(i_gie)); `ifdef IDECODE",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&(!$past(i_ce)) &&($past(f_past_valid))&&(!$past(i_reset,2))&&(!$past(i_ce,2))) assume(i_ce); `endif",
            "reg f_new_insn, f_last_insn;",
            "initial f_new_insn = 1'b0;",
            "always @(posedge i_clk) if (i_reset) f_new_insn <= 1'b0; else f_new_insn <= ((pf_valid)&&(!i_stalled));",
            "initial f_last_insn = 1'b0;",
            "always @(posedge i_clk) if (i_reset) f_last_insn <= 1'b0; else f_last_insn <= (o_valid)&&(i_stalled);",
            "always @(posedge i_clk) if ((f_past_valid)&&(f_last_insn)&&(!i_reset)) begin if (($past(pf_valid))&&(pf_valid)) begin `ASSUME(i_illegal || i_instruction == $past(i_instruction)); `ASSUME(i_gie == $past(i_gie)); `ASSUME(i_pc == $past(i_pc)); `ASSUME(i_illegal == $past(i_illegal)); end end",
            "always @(posedge i_clk) if ((f_past_valid)&&(o_early_branch_stb)) `ASSUME(!pf_valid);",
            "always @(*) if (i_pf_valid) `ASSUME(i_pc[1:0] == 2'b00);",
            "always @(*) if ((o_valid)&&(!o_early_branch)) `ASSERT((o_illegal)||(o_pc[1] == o_phase));",
            "wire [3+7+7+7+32+1+4+1+4+10+(AW+2)+3+23+(AW+2)-1:0] f_result;",
            "assign f_result = { o_phase, o_illegal, i_gie, o_dcdR, o_dcdA, o_dcdB, o_I, o_zI, o_cond, o_wF, o_op, o_ALU, o_M, o_DV, o_FP, o_break, o_lock, o_wR, o_rA, o_rB, o_early_branch, o_branch_pc, o_ljmp, o_pipe, o_sim, o_sim_immv, o_pc };",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($stable(i_gie))&&(f_last_insn)) begin `ASSERT($stable(f_result)); if (OPT_PIPELINED) // All but valid will be stable `ASSERT($stable(o_valid)); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(pf_valid)) &&(!$past(o_ljmp))) `ASSERT((!OPT_PIPELINED)||(o_valid));",
            "always @(posedge i_clk) if ((f_past_valid)&&(f_new_insn) &&($past(pf_valid))&&($past(i_illegal))&&(!$past(o_phase))) `ASSERT(o_illegal); `ifdef IDECODE //////////////////////////////////////////////////////////////////////// // // Let's walk through some basic instructions // {{{ //////////////////////////////////////////////////////////////////////// // // // First 8-instructions, SUB - ASR // {{{",
            "always @(*) if ((!iword[CISBIT])&&(iword[26:25]==2'b00)) begin // {{{ `ASSERT(!w_cmptst); `ASSERT(!w_div); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_ldi); `ASSERT(!w_mov); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT(!w_mpy); `ASSERT((w_rA)&&(w_wR)&&(w_ALU)); `ASSERT(w_rB == iword[IMMSEL]); `ASSERT(w_dcdA[4] == i_gie); `ASSERT(w_dcdB[4] == i_gie); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_dcdB[3:0] == iword[17:14]); `ASSERT(w_cis_op == w_op); `ASSERT(w_cond[3] == (iword[21:19] == 3'b000)); `ASSERT(w_cond[2:0] == iword[21:19]); `ASSERT((w_wF == w_cond[3])||(w_dcdA[3:1]==3'b111)); // }}} end else if ((iword[CISBIT])&&(iword[26:24]<3'b011)) begin // {{{ `ASSERT(!w_cmptst); `ASSERT(!w_div); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_ldi); `ASSERT(!w_mov); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT(!w_mpy); `ASSERT((w_rA)&&(w_wR)&&(w_ALU)); `ASSERT(w_rB == iword[CISIMMSEL]); `ASSERT(w_dcdA[4] == i_gie); `ASSERT(w_dcdB[4] == i_gie); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_dcdB[3:0] == iword[22:19]); if (iword[26:24] == 3'b000) begin `ASSERT(w_cis_op == 5'h0); end else if (iword[26:24] == 5'h01) begin `ASSERT(w_cis_op == 5'h01); end else // if (iword[26:24] == 3'b010) `ASSERT(w_cis_op == 5'h02); `ASSERT(w_cond == 4'h8); if (iword[CISIMMSEL]) begin `ASSERT(w_I == { {(23-3){iword[18]}}, iword[18:16] }); end else `ASSERT(w_I == { {(23-7){iword[22]}}, iword[22:16] }); // }}} end else `ASSERT(!w_add); // }}} // BREV and LDILO // {{{",
            "always @(*) if ((!iword[CISBIT])&&((w_cis_op == 5'h8) ||(w_cis_op == 5'h09))) begin // {{{ `ASSERT(!w_mpy); `ASSERT(!w_div); `ASSERT(!w_cmptst); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_ldi); `ASSERT(!w_mov); if (w_cis_op == 5'h8) begin `ASSERT(w_brev); `ASSERT(!w_ldilo); `ASSERT((!w_rA)&&(w_wR)&&(w_ALU)); end else begin// if (w_cis_op == 5'h9) `ASSERT(w_ldilo); `ASSERT(!w_brev); `ASSERT((w_rA)&&(w_wR)&&(w_ALU)); end `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT(w_rB == iword[IMMSEL]); `ASSERT(w_dcdA[4] == i_gie); `ASSERT(w_dcdB[4] == i_gie); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_dcdB[3:0] == iword[17:14]); `ASSERT(w_cis_op == w_op); `ASSERT(w_cond[3] == (iword[21:19] == 3'b000)); `ASSERT(w_cond[2:0] == iword[21:19]); `ASSERT(!w_wF); // }}} end else begin // {{{ `ASSERT(!w_brev); `ASSERT(!w_ldilo); // }}} end // }}} // Multiply instructions // {{{",
            "always @(*) if ((!iword[CISBIT])&&((w_cis_op == 5'ha) ||(w_cis_op == 5'h0b) ||(w_cis_op == 5'h0c))) begin // {{{ `ASSERT(w_mpy); `ASSERT(!w_div); `ASSERT(!w_cmptst); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_ldi); `ASSERT(!w_mov); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT((w_rA)&&(w_wR)&&(w_ALU)); `ASSERT(w_rB == iword[IMMSEL]); `ASSERT(w_dcdA[4] == i_gie); `ASSERT(w_dcdB[4] == i_gie); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_dcdB[3:0] == iword[17:14]); `ASSERT(w_cis_op == w_op); `ASSERT(w_cond[3] == (iword[21:19] == 3'b000)); `ASSERT(w_cond[2:0] == iword[21:19]); `ASSERT((w_wF == w_cond[3])||(w_dcdA[3:1]==3'b111)); // }}} end else `ASSERT(!w_mpy); // }}} // Move instruction // {{{",
            "always @(*) if ((!iword[CISBIT])&&((w_cis_op == 5'hd))) begin // {{{ `ASSERT(w_mov); `ASSERT(!w_div); `ASSERT(!w_mpy); `ASSERT(!w_cmptst); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_ldi); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT((!w_rA)&&(w_wR)&&(w_ALU)); `ASSERT(w_rB); `ASSERT(w_dcdA[4] == ((i_gie)||(iword[IMMSEL]))); `ASSERT(w_dcdB[4] == ((i_gie)||(iword[13]))); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_dcdB[3:0] == iword[17:14]); `ASSERT(w_cis_op == w_op); `ASSERT(w_cond[3] == (iword[21:19] == 3'b000)); `ASSERT(w_cond[2:0] == iword[21:19]); `ASSERT(!w_wF); // }}} end else if ((iword[CISBIT])&&(iword[26:24]==3'b111)) begin // {{{ `ASSERT(w_mov); `ASSERT(!w_div); `ASSERT(!w_mpy); `ASSERT(!w_cmptst); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_ldi); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT((!w_rA)&&(w_wR)&&(w_ALU)); `ASSERT(w_rB); `ASSERT(w_dcdA[4] == (i_gie)); `ASSERT(w_dcdB[4] == (i_gie)); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_dcdB[3:0] == iword[22:19]); `ASSERT(w_cis_op == 5'h0d); `ASSERT(w_cond == 4'h8); `ASSERT(!w_wF); // }}} end else `ASSERT(!w_mov); // }}} // Divide instruction // {{{",
            "always @(*) if ((!iword[CISBIT])&&(iword[26:23]==4'b0111)) begin // {{{ `ASSERT(w_div); `ASSERT(!w_cmptst); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_ldi); `ASSERT(!w_mov); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT(!w_mpy); `ASSERT((w_rA)&&(w_wR)); `ASSERT(w_rB == iword[IMMSEL]); `ASSERT(w_dcdA[4] == i_gie); `ASSERT(w_dcdB[4] == i_gie); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_dcdB[3:0] == iword[17:14]); `ASSERT(w_cis_op == w_op); `ASSERT(w_cond[3] == (iword[21:19] == 3'b000)); `ASSERT(w_cond[2:0] == iword[21:19]); `ASSERT((w_wF == w_cond[3])||(w_dcdA[3:1]==3'b111)); // }}} end else `ASSERT(!w_div); // }}} // Comparison instructions // {{{",
            "always @(*) if ((!iword[CISBIT])&&(iword[26:23]==4'b1000)) begin // {{{ `ASSERT(w_cmptst); `ASSERT(!w_div); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_ldi); `ASSERT(!w_mov); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT(!w_mpy); `ASSERT((w_rA)&&(!w_wR)&&(!w_ALU)); `ASSERT(w_rB == iword[IMMSEL]); `ASSERT(w_dcdA[4] == i_gie); `ASSERT(w_dcdB[4] == i_gie); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_dcdB[3:0] == iword[17:14]); `ASSERT(w_cis_op == w_op); `ASSERT(w_cond[3] == (iword[21:19] == 3'b000)); `ASSERT(w_cond[2:0] == iword[21:19]); `ASSERT(w_wF); // }}} end else if ((iword[CISBIT])&&(iword[26:24]==3'b011)) begin // {{{ `ASSERT(w_cmptst); `ASSERT(!w_div); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_ldi); `ASSERT(!w_mov); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT(!w_mpy); `ASSERT((w_rA)&&(!w_wR)&&(!w_ALU)); `ASSERT(w_rB == iword[CISIMMSEL]); `ASSERT(w_dcdA[4] == i_gie); `ASSERT(w_dcdB[4] == i_gie); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_dcdB[3:0] == iword[22:19]); `ASSERT(w_cis_op == 5'h10); `ASSERT(w_cond == 4'h8); if (iword[CISIMMSEL]) begin `ASSERT(w_I == { {(23-3){iword[18]}}, iword[18:16] }); end else `ASSERT(w_I == { {(23-7){iword[22]}}, iword[22:16] }); `ASSERT(w_wF); // }}} end else `ASSERT(!w_cmptst); // }}}",
            "always @(posedge i_clk) if ((f_new_insn)&&($past(w_cmptst))) `ASSERT(o_ALU); // Memory instructions // {{{",
            "always @(*) if ((!iword[CISBIT])&&( (iword[26:23]==4'b1001) // Word ||(iword[26:23]==4'b1010) // Half-word, or short ||(iword[26:23]==4'b1011))) // Byte ops begin // {{{ `ASSERT(w_mem); `ASSERT(w_sto == iword[22]); `ASSERT(!w_cmptst); `ASSERT(!w_div); `ASSERT(!w_ldi); `ASSERT(!w_mov); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT(!w_mpy); if (w_sto) begin `ASSERT((w_rA)&&(!w_wR)); end else `ASSERT((!w_rA)&&(w_wR)); `ASSERT(!w_ALU); `ASSERT(w_rB == iword[IMMSEL]); `ASSERT(w_dcdA[4] == i_gie); `ASSERT(w_dcdB[4] == i_gie); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_dcdB[3:0] == iword[17:14]); `ASSERT(w_cis_op == w_op); `ASSERT(w_cond[3] == (iword[21:19] == 3'b000)); `ASSERT(w_cond[2:0] == iword[21:19]); `ASSERT(!w_wF); // }}} end else if ((iword[CISBIT])&&(iword[26:25]==2'b10)) begin // {{{ `ASSERT(w_mem); `ASSERT(w_sto == iword[24]); `ASSERT(!w_cmptst); `ASSERT(!w_div); `ASSERT(!w_ldi); `ASSERT(!w_mov); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT(!w_mpy); if (w_sto) begin `ASSERT((w_rA)&&(!w_wR)); end else `ASSERT((!w_rA)&&(w_wR)); `ASSERT(!w_ALU); `ASSERT(w_rB); `ASSERT(w_dcdA[4] == i_gie); `ASSERT(w_dcdB[4] == i_gie); `ASSERT(w_dcdA[3:0] == iword[30:27]); if (iword[CISIMMSEL]) begin `ASSERT(w_dcdB[3:0] == iword[22:19]); end else `ASSERT(w_dcdB[3:0] == CPU_SP_REG); if (w_sto) begin `ASSERT(w_cis_op == 5'h13); end else `ASSERT(w_cis_op == 5'h12); `ASSERT(w_cond == 4'h8); `ASSERT(!w_wF); // }}} end else begin // {{{ `ASSERT(!w_sto); `ASSERT(!w_mem); // }}} end",
            "always @(*) if (w_sto) `ASSERT(w_mem); // }}} // LDI -- Load immediate // {{{",
            "always @(*) if ((!iword[CISBIT])&&(w_op[4:1] == 4'hc)) begin // {{{ `ASSERT(w_ldi); `ASSERT(!w_mpy); `ASSERT(!w_div); `ASSERT(!w_cmptst); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_mov); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT((!w_rA)&&(w_wR)&&(!w_ALU)); `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT(w_rB == 1'b0); `ASSERT(w_dcdA[4] == i_gie); `ASSERT(w_dcdB[4] == i_gie); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_dcdB[3:0] == iword[17:14]); `ASSERT(w_cis_op == w_op); `ASSERT(w_cond == 4'h8); `ASSERT(!w_wF); `ASSERT(w_Iz == (iword[22:0] == 0)); `ASSERT(w_I[22:0] == iword[22:0]); // }}} end else if ((iword[CISBIT])&&(iword[26:24] == 3'b110)) begin // {{{ `ASSERT(w_ldi); `ASSERT(!w_mpy); `ASSERT(!w_div); `ASSERT(!w_cmptst); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_mov); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT((!w_rA)&&(w_wR)&&(!w_ALU)); `ASSERT(!w_special); `ASSERT(!w_fpu); `ASSERT(w_rB == 1'b0); `ASSERT(w_dcdA[4] == i_gie); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_cis_op[4:1] == 4'hc); `ASSERT(w_cond == 4'h8); `ASSERT(!w_wF); `ASSERT(w_Iz == (iword[23:16] == 0)); `ASSERT(w_I[22:0] == { {(23-8){iword[23]}}, iword[23:16] }); // }}} end else `ASSERT(!w_ldi); // }}} `endif // IDECODE",
            "always @(posedge i_clk) if ((f_new_insn)&&($past(w_ldi))) `ASSERT(o_ALU);",
            "always @(*) if (!OPT_LOCK) `ASSERT(!o_lock); `ifdef IDECODE",
            "always @(*) if ((w_break)||(w_lock)||(w_sim)||(w_noop)) `ASSERT(w_special); // FPU -- Floating point instructions // {{{",
            "always @(*) if ((!iword[CISBIT])&&( (w_cis_op[4:1] == 4'hd) ||(w_cis_op[4:1] == 4'he) ||(w_cis_op[4:1] == 4'hf)) &&(iword[30:28] != 3'h7)) begin // {{{ `ASSERT(w_fpu); `ASSERT(!w_ldi); `ASSERT(!w_mpy); `ASSERT(!w_div); `ASSERT(!w_cmptst); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_mov); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT((w_wR)&&(!w_ALU)); if ((w_cis_op == 5'he)||(w_cis_op == 5'hf)) begin `ASSERT(!w_rA); end else begin `ASSERT(w_rA); end `ASSERT(!w_special); `ASSERT(w_rB == iword[IMMSEL]); `ASSERT(w_dcdA[4] == i_gie); `ASSERT(w_dcdB[4] == i_gie); `ASSERT(w_dcdA[3:0] == iword[30:27]); `ASSERT(w_dcdB[3:0] == iword[17:14]); `ASSERT(w_cis_op == w_op); `ASSERT(w_cond[3] == (iword[21:19] == 3'b000)); `ASSERT(w_cond[2:0] == iword[21:19]); `ASSERT((w_wF == w_cond[3])||(w_dcdA[3:1]==3'b111)); // }}} end else `ASSERT(!w_fpu); // }}} // Special instructions // {{{",
            "always @(*) if ((!iword[CISBIT])&&( (w_cis_op == 5'h1c) ||(w_cis_op == 5'h1d) ||(w_cis_op == 5'h1e) ||(w_cis_op == 5'h1f)) &&(iword[30:28] == 3'h7)) begin // {{{ `ASSERT(w_special); if (w_cis_op == 5'h1c) begin // Break instruction `ASSERT(w_break); `ASSERT(!w_lock); `ASSERT(!w_sim); `ASSERT(!w_noop); end else if (w_cis_op == 5'h1d) begin // Lock instruction `ASSERT(!w_break); `ASSERT( w_lock); `ASSERT(!w_sim); `ASSERT(!w_noop); end else if (w_cis_op == 5'h1e) begin // Sim instruction `ASSERT(!w_break); `ASSERT(!w_lock); `ASSERT( w_sim); `ASSERT( w_noop); end else begin // NOOP instruction `ASSERT(!w_break); `ASSERT(!w_lock); `ASSERT(!w_sim); `ASSERT( w_noop); end `ASSERT((!w_fpu)||(!OPT_FPU)); `ASSERT(!w_ldi); `ASSERT(!w_mpy); `ASSERT(!w_div); `ASSERT(!w_cmptst); `ASSERT(!w_mem); `ASSERT(!w_sto); `ASSERT(!w_mov); `ASSERT(!w_brev); `ASSERT(!w_ldilo); `ASSERT((!w_rA)&&(!w_rB)&&(!w_wR)&&(!w_ALU)); `ASSERT(w_cis_op == w_op); `ASSERT(w_cond == 4'h8); `ASSERT(!w_wF); // }}} end else begin // {{{ `ASSERT(!w_special); `ASSERT(!w_break); `ASSERT(!w_lock); `ASSERT(!w_sim); `ASSERT(!w_noop); // }}} end // }}} // }}} `endif //////////////////////////////////////////////////////////////////////// // // Early branching checks // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_EARLY_BRANCHING) begin",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_ce))&&(!$past(i_reset))&&(!i_reset)) begin if ($past(pf_valid)) begin if ($past(o_ljmp)) begin // 2nd half of LW (PC),PC `ASSERT(o_early_branch); `ASSERT(o_early_branch_stb); end else if ((!$past(iword[CISBIT]))&&($past(w_add)) &&(!$past(w_rB)) &&($past(w_cond[3])) &&(o_dcdR[4:0]=={ i_gie, 4'hf })) begin // ADD #x,PC `ASSERT(o_early_branch); `ASSERT(o_early_branch_stb); end else if ((!$past(iword[CISBIT])) &&($past(w_cis_op == 5'h12)) &&($past(w_rB)) &&($past(w_cond[3])) &&(o_zI) &&(o_dcdB[4:0]=={ i_gie, 4'hf }) &&(o_dcdR[4:0]=={ i_gie, 4'hf })) begin // LW (PC),PC `ASSERT(!o_early_branch); `ASSERT(!o_early_branch_stb); end else if ((OPT_CIS)&&($past(o_phase)) &&($past(w_cis_op == 5'h12)) &&($past(w_rB)) &&($past(w_cond[3])) &&($past(w_Iz)) &&($past(w_dcdB_pc)) &&($past(w_dcdR_pc)) &&(o_dcdR[4:0]=={ i_gie, 4'hf })) begin // (CIS) LW (PC),PC `ASSERT(!o_early_branch); `ASSERT(!o_early_branch_stb); end else begin `ASSERT(!o_early_branch); end end else if ((OPT_CIS)&&($past(o_phase))) begin if (($past(w_cis_op == 5'h12)) &&($past(w_rB)) &&($past(w_cond[3])) &&($past(w_Iz)) &&($past(w_dcdB_pc)) &&($past(w_dcdR_pc))) begin // (CIS) LW (PC),PC `ASSERT(!o_early_branch); `ASSERT(!o_early_branch_stb); end else begin `ASSERT(!o_early_branch); `ASSERT(!o_early_branch_stb); end end end else if (!i_reset) `ASSERT(!o_early_branch_stb); // // CIS instruction 16'hfcf8 decodes into: // // 1.1111.100.1.1111.0000 // // = LW (PC),PC // always @(*) // assume(i_instruction[31:16] != 16'hfcf8); end else begin",
            "always @(*) `ASSERT(!o_early_branch_stb);",
            "always @(*) `ASSERT(!o_early_branch); end endgenerate",
            "always @(*) if (o_early_branch_stb) `ASSERT(o_early_branch);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_early_branch_stb))&&(!$past(pf_valid))) `ASSERT(!o_early_branch_stb); // }}} // CIS specific checks // {{{ generate if (OPT_CIS) begin : F_OPT_CIS // {{{",
            "always @(*) if (OPT_PIPELINED && !o_valid) `ASSERT(!o_phase);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))) begin if ((o_phase)&&($past(i_ce))) begin `ASSERT((iword[30:16] == $past(i_instruction[14:0])) &&(iword[CISBIT])); end else if (!o_phase) `ASSERT(iword == i_instruction); if ((!$past(o_phase))&&($past(i_ce)) &&($past(pf_valid)) &&(!$past(i_illegal)) &&(!$past(w_ljmp_dly)) &&($past(i_instruction[CISBIT])) &&((!$past(w_dcdR_pc)) ||(!$past(w_wR)))) begin `ASSERT(o_phase); end else if (($past(o_phase))&&($past(i_ce))) `ASSERT(!o_phase); if (($past(i_ce))&&(!$past(o_phase)) &&($past(i_illegal))&&($past(i_pf_valid))) `ASSERT((o_illegal)&&(!o_phase)); `ASSERT((!o_phase)||(!o_ljmp)); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_stalled))&&($past(pf_valid)) &&($past(i_ce))) begin `ASSERT(o_pc[0] == 1'b0); if (!$past(iword[CISBIT])) begin `ASSERT(o_pc[1:0]==2'b00); `ASSERT(o_pc[AW+1:2] == $past(i_pc[AW+1:2])+1'b1); end else if ($past(iword[CISBIT])&&($past(o_phase))) begin `ASSERT(o_pc[(AW+1):1] == $past(o_pc[(AW+1):1]) + 1'b1); end else if ($past(iword[CISBIT])) begin `ASSERT(o_pc[(AW+1):1] == { $past(i_pc[(AW+1):2]), 1'b1}); if (o_valid) begin `ASSERT(o_pc[1]); `ASSERT((o_illegal)||(o_phase)); end end end",
            "always @(*) if (iword[CISBIT]) begin `ASSERT((!w_ldi)||(w_I == { {(23-8){iword[23]}}, iword[23:16] })); `ASSERT((w_ldi)||(iword[CISIMMSEL]) ||(w_I == { {(23-7){iword[22]}}, iword[22:16] })); `ASSERT((w_ldi)||(!iword[CISIMMSEL]) ||(w_I == { {(23-3){iword[18]}}, iword[18:16] })); end else begin `ASSERT((!w_ldi)||(w_I == iword[22:0])); `ASSERT((!w_mov)||(w_I == { {(23-13){iword[12]}}, iword[12:0] })); `ASSERT((w_ldi)||(w_mov)||(iword[IMMSEL]) ||(w_I == { {(23-18){iword[17]}}, iword[17:0] })); `ASSERT((w_ldi)||(w_mov)||(!iword[IMMSEL]) ||(w_I == { {(23-14){iword[13]}}, iword[13:0] })); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(o_phase)&&($past(i_ce))) `ASSERT(($past(i_instruction[CISBIT])) &&(r_nxt_half[14:0]==$past(i_instruction[14:0]))); // }}} end else begin // {{{",
            "always @(*) begin `ASSERT((o_phase)||(iword[30:0] == i_instruction[30:0])); `ASSERT(o_phase == 1'b0); `ASSERT(o_pc[0] == 1'b0); end",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_ce))&&($past(i_pf_valid))) begin `ASSERT(o_pc[AW+1:2] == $past(i_pc[AW+1:2]) + 1'b1); end else if (f_past_valid) `ASSERT(o_pc == $past(o_pc));",
            "always @(*) `ASSERT(o_pc[1:0] == 2'b00);",
            "always @(*) `ASSERT((!w_ldi)||(w_I == iword[22:0]));",
            "always @(*) `ASSERT((!w_mov)||(w_I == { {(23-13){iword[12]}}, iword[12:0] }));",
            "always @(*) `ASSERT((w_ldi)||(w_mov)||(iword[IMMSEL]) ||(w_I == { {(23-18){iword[17]}}, iword[17:0] }));",
            "always @(*) `ASSERT((w_ldi)||(w_mov)||(!iword[IMMSEL]) ||(w_I == { {(23-14){iword[13]}}, iword[13:0] }));",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_ce))&&(!$past(i_reset))) `ASSERT((!$past(i_instruction[CISBIT])) ||(!$past(pf_valid))||(o_illegal)); // }}} end endgenerate // }}}",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_ce && pf_valid)) &&($past(w_fpu))) begin if (OPT_FPU) begin `ASSERT(o_FP); end else if (!$past(w_special)) `ASSERT(o_illegal); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_ce && pf_valid))&&($past(w_lock))) begin if (OPT_LOCK) begin `ASSERT(o_lock); end else `ASSERT(o_illegal); end //////////////////////////////////////////////////////////////////////// // // Check pipelined memory instructions // {{{ //////////////////////////////////////////////////////////////////////// // // // wire [20:0] f_next_pipe_I, f_this_pipe_I; // assign f_this_pipe_I = r_I[22:2]; // assign f_next_pipe_I = r_I[22:2]+1'b1;",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))) begin if (OPT_OPIPE) begin if (($past(i_ce)) &&(($past(pf_valid))||($past(o_phase)))) begin if ((!$past(o_M))||(!o_M)) begin `ASSERT(!o_pipe); end else if ($past(o_op[0])!=o_op[0]) begin `ASSERT(!o_pipe); end else if ($past(o_rB)!=o_rB) begin `ASSERT(!o_pipe); end else if ((o_rB)&&($past(o_dcdB) != o_dcdB)) begin `ASSERT(!o_pipe); end else if (($past(o_wR)) &&($past(o_dcdR[3:1]) == 3'h7)) begin `ASSERT(!o_pipe); end else if (o_wR != $past(o_wR)) begin `ASSERT(!o_pipe); end else if ((o_wR)&&($past(o_dcdR) == o_dcdB)) begin `ASSERT(!o_pipe); end else if ((o_wR)&&(o_dcdB[3:1] == 3'h7)) begin `ASSERT(!o_pipe); // // Allow reading into the PC",
            "reg ister as a form of jumping // // else if ((o_wR)&&(o_dcdR[3:1] == 3'h7)) // // `ASSERT(!o_pipe); // Allow discontinuous reads -- since our crossbar can now // handle them // else if (($past(o_cond) != 4'h8) // &&($past(o_cond) != o_cond)) // `ASSERT(!o_pipe); // This never really guaranteed that addresses would only // increment, nor does it guarantee that addresses won't // wrap around, so ... we'll just ignore this and (instead) // generate a bus error in the memory controller on bad // addresses // else if ($past(r_I[22])!=r_I[22]) // `ASSERT(!o_pipe); // else if (r_I[22:0] - $past(r_I[22:0])>23'h4) // `ASSERT(!o_pipe); end else if (!$past(o_valid)) `ASSERT(!o_pipe); // else // assert(o_pipe); end else if ($past(i_stalled)) `ASSERT(o_pipe == $past(o_pipe)); end end",
            "always @(*) `ASSERT((OPT_OPIPE)||(!o_pipe)); // }}}",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_ce)) &&($past(i_pf_valid))&&($past(w_mpy))) `ASSERT((OPT_MPY)||(o_illegal));",
            "always @(*) if (o_valid) `ASSERT((!o_phase)||(!o_early_branch));",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_valid))&&($past(o_ljmp))&&($past(!i_stalled))) `ASSERT(!o_valid);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_early_branch_stb))) begin `ASSERT(!o_phase); if (!$past(i_stalled)) `ASSERT(!o_valid); `ASSERT(!o_ljmp); end // Unless another valid instruction comes along, once o_ljmp is asserted // it should stay asserted until either a reset or an early branch // strobe.",
            "always @(posedge i_clk) if ((OPT_EARLY_BRANCHING)&&(f_past_valid) &&($past(o_ljmp))&&(!$past(pf_valid)) &&(!$past(i_reset))&&(!$past(o_early_branch_stb))) `ASSERT(o_ljmp); // o_ljmp should only ever be asserted following a valid prefetch // input . Hence, if the prefetch",
            "input isn't valid, then o_ljmp // should be left low",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(o_ljmp)) &&( (!$past(pf_valid)) || (!$past(i_ce)) ) &&( !$past(o_phase) ) &&(!$past(i_reset))&&(!$past(o_early_branch_stb))) `ASSERT(!o_ljmp);",
            "always @(posedge i_clk) if ((OPT_EARLY_BRANCHING)&&(f_past_valid)&&($past(o_ljmp))&&(!o_ljmp) &&(!$past(i_reset))) `ASSERT((o_early_branch_stb)&&(!o_valid));",
            "always @(posedge i_clk) `ASSERT((!o_early_branch_stb)||(!o_ljmp));",
            "always @(posedge i_clk) `ASSERT((!o_valid)||(!o_ljmp)||(o_phase == o_pc[1]));",
            "always @(posedge i_clk) if (!OPT_CIS) begin `ASSERT(!o_phase); end else if (!f_insn_word[31]) begin `ASSERT(!o_phase); end else if (o_phase) `ASSERT(o_pc[1]);",
            "always @(*) if ((o_early_branch)&&(!o_early_branch_stb)) `ASSERT(!o_pipe);",
            "always @(*) if (o_ljmp) `ASSERT(!o_pipe);",
            "always @(*) `ASSERT(o_dcdR == o_dcdA);",
            "always @(*) if ((o_valid)&&(o_phase)) begin `ASSERT(!o_illegal); `ASSERT(o_pc[1]); `ASSERT(f_insn_word[31]); end",
            "always @(posedge i_clk) if ($rose(o_illegal)) `ASSERT(o_valid || $past(o_early_branch || o_ljmp));",
            "always @(*) `ASSERT(o_branch_pc[1:0] == 2'b00);",
            "always @(*) `ASSERT(o_pc[0] == 1'b0);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_pf_valid))&&(i_pf_valid)) `ASSUME((i_reset)||($stable(i_gie))); //////////////////////////////////////////////////////////////////////// // // Contract checking // {{{ //////////////////////////////////////////////////////////////////////// // // wire fc_illegal, fc_wF, fc_ALU, fc_M, fc_DV, fc_FP, fc_break, fc_lock, fc_wR, fc_rA, fc_rB, fc_prepipe, fc_sim;",
            "wire [6:0] fc_dcdR, fc_dcdA, fc_dcdB;",
            "wire [31:0] fc_I;",
            "wire [3:0] fc_cond;",
            "wire [3:0] fc_op;",
            "wire [22:0] fc_sim_immv; f_idecode #( // {{{ .OPT_MPY(OPT_MPY), .OPT_DIVIDE(OPT_DIVIDE), .OPT_FPU(OPT_FPU), .OPT_CIS(OPT_CIS), .OPT_LOCK(OPT_LOCK), .OPT_OPIPE(OPT_OPIPE), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_USERMODE(OPT_USERMODE), .OPT_SIM(OPT_SIM) // }}} ) formal_decoder( // {{{ .i_instruction(f_insn_word), .i_phase(o_phase), .i_gie(f_insn_gie), .o_illegal(fc_illegal), .o_dcdR(fc_dcdR), .o_dcdA(fc_dcdA), .o_dcdB(fc_dcdB), .o_I(fc_I), .o_cond(fc_cond), .o_wF(fc_wF), .o_op(fc_op), .o_ALU(fc_ALU), .o_M(fc_M), .o_DV(fc_DV), .o_FP(fc_FP), .o_break(fc_break), .o_lock(fc_lock), .o_wR(fc_wR), .o_rA(fc_rA), .o_rB(fc_rB), .o_prepipe(fc_prepipe), .o_sim(fc_sim), .o_sim_immv(fc_sim_immv) // }}} );",
            "always @(posedge i_clk) if (o_valid && fc_illegal) assert(o_illegal);",
            "always @(posedge i_clk) if (o_valid && !o_illegal) begin if (i_reset) begin `ASSERT(fc_dcdR[3:0]== o_dcdR[3:0]); // `ASSERT(fc_dcdA[3:0]== o_dcdA[3:0]); // `ASSERT(fc_dcdB[3:0]== o_dcdB[3:0]); // end else begin `ASSERT(fc_dcdR== o_dcdR); // `ASSERT(fc_dcdA== o_dcdA); // `ASSERT(fc_dcdB== o_dcdB); // end `ASSERT(fc_I == o_I); `ASSERT(o_zI == (fc_I == 0)); `ASSERT(fc_cond== o_cond); `ASSERT(fc_wF == o_wF); `ASSERT(fc_op == o_op); `ASSERT(fc_ALU == o_ALU); `ASSERT(fc_M == o_M); `ASSERT(fc_DV == o_DV); `ASSERT(fc_FP == o_FP); `ASSERT(fc_break== o_break); `ASSERT(fc_lock == o_lock); `ASSERT(fc_wR == o_wR); `ASSERT(fc_rA == o_rA); `ASSERT(fc_rB == o_rB); `ASSERT(fc_sim == o_sim); `ASSERT(fc_sim_immv == o_sim_immv); `ASSERT(fc_prepipe == insn_is_pipeable); end else `ASSERT((i_reset)||(!insn_is_pipeable));",
            "always @(*) if (o_phase) `ASSERT(r_nxt_half[14:0] == f_insn_word[14:0]);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&(!i_reset) &&($past(i_ce))&&(o_valid)) begin `ASSERT(((fc_illegal) ||$past((i_illegal)&&(!o_phase)) ||$past((o_illegal)&&( o_phase)))== o_illegal); end",
            "always @(posedge i_clk) if ((!o_valid)||(o_illegal)) `ASSERT(!insn_is_pipeable); generate if ((OPT_CIS)&&(OPT_EARLY_BRANCHING)) begin",
            "always @(*) if ((o_valid) // LW &&(o_M)&&(o_op[2:0]==3'b010) // Zero immediate &&(o_zI) // Unconditional &&(o_cond[3]) // From PC to PC &&(o_dcdR[5])&&(o_dcdB[5])) begin `ASSERT((o_ljmp) ||((f_insn_word[31])&&(o_phase || o_illegal))); end else if (o_valid) `ASSERT(!o_ljmp); end endgenerate // }}} `endif // FORMAL // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "mpyop.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/mpyop.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: mpyop.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This code has been pulled from the cpuops.v file so as to // encapsulate the multiply component--the one component that // (can't be) formally verified well, and so must be abstracted away. // This separation was done to support potential future abstraction. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module mpyop #( // {{{ // The following",
            "parameter selects which multiply algorithm we // use. Timing performance is strictly dependent upon it. // OPY_MPY // ------ // 0 No multiply // 1 Single op multiply, same timing as an ADD // 2 Two clock multiply // 3 Three clock multiply, standard Xlnx DSP timing // 4 Three clock multiply, Xilinx Spartan DSP timing // (Anything else) -- low",
            "logic slow multiply // 36 Required setting for the TB to work on the low // logic slow multiply",
            "parameter OPT_MPY = 1, parameter [0:0] OPT_LOWPOWER = 1'b0 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, i_stb, // // Three types of multiply operations. // 2'b00: 32x32 multiply, returning the low order 32 bits // 2'b10: 32x32 unsigned multiply, returning upper 32 bits // 2'b11: 32x32 signed multiply, returning upper 32 bits",
            "input wire [1:0] i_op, input wire [31:0] i_a, i_b, output wire o_valid, // True if the result is valid",
            "output wire o_busy, // output wire [63:0] o_result, // multiply result",
            "output wire o_hi // Return the high half of mpy // }}} ); // A 4-way multiplexer can be done in one 6-LUT. // A 16-way multiplexer can therefore be done in 4x 6-LUT's with // the Xilinx multiplexer fabric that follows. // Given that we wish to apply this multiplexer approach to 33-bits, // this will cost a minimum of 132 6-LUTs. // i_stb instead of this_is_a_multiply_op // o_result // o_busy // o_done generate if (OPT_MPY == 0) begin : MPYNONE // No multiply support. // {{{",
            "assign o_result = 64'h00;",
            "assign o_busy = 1'b0;",
            "assign o_valid = i_stb;",
            "assign o_hi = 1'b0; // Not needed `ifdef VERILATOR // verilator coverage_off // verilator lint_off UNUSED",
            "wire mpy_unused;",
            "assign mpy_unused = &{ 1'b0, i_clk, i_reset, i_stb, i_op, i_a, i_b }; // verilator lint_on UNUSED // verilator coverage_on `endif // }}} end else begin : IMPY if (OPT_MPY == 1) begin : MPY1CK // Our single clock option (no extra clocks) // {{{",
            "wire signed [63:0] w_mpy_a_",
            "input , w_mpy_b_",
            "input ;",
            "assign w_mpy_a_",
            "input = {{(32){(i_a[31])&(i_op[0])}},i_a[31:0]};",
            "assign w_mpy_b_",
            "input = {{(32){(i_b[31])&(i_op[0])}},i_b[31:0]};",
            "assign o_result = (OPT_LOWPOWER && !i_stb) ? 0 : (w_mpy_a_",
            "input * w_mpy_b_",
            "input );",
            "assign o_busy = 1'b0;",
            "assign o_valid = i_stb;",
            "assign o_hi = i_op[1]; `ifdef VERILATOR // verilator coverage_off // verilator lint_off UNUSED",
            "wire mpy_unused;",
            "assign mpy_unused = &{ 1'b0, i_clk, i_reset, i_stb, i_op[1] }; // verilator lint_on UNUSED // verilator coverage_on `endif // }}} end else begin: MPN1 if (OPT_MPY == 2) begin : MPY2CK // Our two clock option (ALU must pause for 1 clock) // {{{ // Declarations // {{{",
            "reg signed [63:0] r_mpy_a_",
            "input , r_mpy_b_",
            "input ;",
            "reg mpypipe, r_hi; // }}} // r_mpy_?_",
            "input : Register the",
            "input s // {{{",
            "always @(posedge i_clk) if (!OPT_LOWPOWER || i_stb) begin r_mpy_a_",
            "input <={{(32){(i_a[31])&(i_op[0])}},i_a[31:0]}; r_mpy_b_",
            "input <={{(32){(i_b[31])&(i_op[0])}},i_b[31:0]}; end else begin r_mpy_a_",
            "input <= 0; r_mpy_b_",
            "input <= 0; end // }}}",
            "assign o_result = r_mpy_a_",
            "input * r_mpy_b_",
            "input ;",
            "assign o_busy = 1'b0; // mpypipe // {{{",
            "initial mpypipe = 1'b0;",
            "always @(posedge i_clk) if (i_reset) mpypipe <= 1'b0; else mpypipe <= (i_stb); // }}}",
            "assign o_valid = mpypipe; // this_is_a_multiply_op; // o_hi // {{{",
            "always @(posedge i_clk) if (i_stb) r_hi <= i_op[1];",
            "assign o_hi = r_hi; // }}} // }}} end else begin : MPN2 if (OPT_MPY == 3) begin : MPY3CK // Our three clock option (ALU pauses for 2 clocks) // {{{ // Declarations // {{{",
            "reg signed [63:0] r_smpy_result;",
            "reg [63:0] r_umpy_result;",
            "reg signed [31:0] r_mpy_a_",
            "input , r_mpy_b_",
            "input ;",
            "reg [1:0] mpypipe;",
            "reg [1:0] r_sgn;",
            "reg r_hi; // }}} // mpypipe (FSM state) // {{{",
            "initial mpypipe = 2'b0;",
            "always @(posedge i_clk) if (i_reset) mpypipe <= 2'b0; else mpypipe <= { mpypipe[0], i_stb }; // }}} // First clock :",
            "reg ister r_mpy_?_",
            "input , r_sgn // {{{",
            "always @(posedge i_clk) r_sgn <= { r_sgn[0], (i_op[0] && (!OPT_LOWPOWER || i_stb)) };",
            "always @(posedge i_clk) if (!OPT_LOWPOWER || i_stb) begin r_mpy_a_",
            "input <= i_a[31:0]; r_mpy_b_",
            "input <= i_b[31:0]; end else begin r_mpy_a_",
            "input <= 0; r_mpy_b_",
            "input <= 0; end // }}} // Second clock : perform the multiply // {{{ `ifdef VERILATOR // Veri1ator only implementation // {{{",
            "wire signed [63:0] s_mpy_a_",
            "input , s_mpy_b_",
            "input ;",
            "wire [63:0] u_mpy_a_",
            "input , u_mpy_b_",
            "input ;",
            "assign s_mpy_a_",
            "input = {{(32){r_mpy_a_",
            "input [31]}},r_mpy_a_",
            "input };",
            "assign s_mpy_b_",
            "input = {{(32){r_mpy_b_",
            "input [31]}},r_mpy_b_",
            "input };",
            "assign u_mpy_a_",
            "input = {32'h00,r_mpy_a_",
            "input };",
            "assign u_mpy_b_",
            "input = {32'h00,r_mpy_b_",
            "input };",
            "always @(posedge i_clk) if (!OPT_LOWPOWER || mpypipe[0]) r_smpy_result <= s_mpy_a_",
            "input * s_mpy_b_",
            "input ;",
            "always @(posedge i_clk) if (!OPT_LOWPOWER || mpypipe[0]) r_umpy_result <= u_mpy_a_",
            "input * u_mpy_b_",
            "input ; // }}} `else // Synthesis implementation // {{{",
            "wire [31:0] u_mpy_a_",
            "input , u_mpy_b_",
            "input ;",
            "assign u_mpy_a_",
            "input = r_mpy_a_",
            "input ;",
            "assign u_mpy_b_",
            "input = r_mpy_b_",
            "input ;",
            "always @(posedge i_clk) if (!OPT_LOWPOWER || mpypipe[0]) r_smpy_result <= r_mpy_a_",
            "input * r_mpy_b_",
            "input ;",
            "always @(posedge i_clk) if (!OPT_LOWPOWER || mpypipe[0]) r_umpy_result <= u_mpy_a_",
            "input * u_mpy_b_",
            "input ; // }}} `endif",
            "always @(posedge i_clk) if (i_stb) r_hi <= i_op[1];",
            "assign o_hi = r_hi;",
            "assign o_busy = mpypipe[0];",
            "assign o_result = (r_sgn[1])?r_smpy_result:r_umpy_result;",
            "assign o_valid = mpypipe[1]; // }}} // Results are then available and",
            "reg istered on the third clock // }}} end else begin : MPN3 if (OPT_MPY == 4) begin : MPY4CK // The four clock option, polynomial multiplication // {{{ // Declarations // {{{",
            "reg [63:0] r_mpy_result;",
            "reg [31:0] r_mpy_a_",
            "input , r_mpy_b_",
            "input ;",
            "reg r_mpy_signed, r_hi;",
            "reg [2:0] mpypipe;",
            "reg [31:0] pp_f, pp_l; // F and L from FOIL",
            "reg [32:0] pp_oi; // The O and I from FOIL",
            "reg [32:0] pp_s; // }}} // First clock, latch in the",
            "input s : mpypipe, r_mpy_?_",
            "input // {{{",
            "initial mpypipe = 3'b0;",
            "always @(posedge i_clk) begin // mpypipe indicates we have a multiply in the // pipeline. In this case, the multiply // pipeline is a two stage pipeline, so we need // two bits in the pipe. if (i_reset) mpypipe <= 3'h0; else begin mpypipe[0] <= i_stb; mpypipe[1] <= mpypipe[0]; mpypipe[2] <= mpypipe[1]; end if (i_op[0]) // i.e. if signed multiply begin r_mpy_a_",
            "input <= {(~i_a[31]),i_a[30:0]}; r_mpy_b_",
            "input <= {(~i_b[31]),i_b[30:0]}; end else begin r_mpy_a_",
            "input <= i_a[31:0]; r_mpy_b_",
            "input <= i_b[31:0]; end // The signed bit really only matters in the // case of 64 bit multiply. We'll keep track // of it, though, and pretend in all other // cases. r_mpy_signed <= i_op[0]; if (i_stb) r_hi <= i_op[1]; else if (OPT_LOWPOWER) begin r_mpy_a_",
            "input <= 0; r_mpy_b_",
            "input <= 0; r_mpy_signed <= 0; end end // }}}",
            "assign o_hi = r_hi;",
            "assign o_busy = |mpypipe[1:0];",
            "assign o_valid = mpypipe[2]; // Second clock, do the multiplies, get the \"partial products\". // {{{ // Here, we break our",
            "input up into two halves, // // A = (2^16 ah + al) // B = (2^16 bh + bl) // // and use these to compute partial products. // // AB = (2^32 ah*bh + 2^16 (ah*bl + al*bh) + (al*bl) // // Since we're following the FOIL algorithm to get here, // we'll name these partial products according to FOIL. // // The trick is what happens if A or B is signed. In // those cases, the real value of A will not be given by // A = (2^16 ah + al) // but rather // A = (2^16 ah[31^] + al) - 2^31 // (where we have flipped the sign bit of A) // and so ... // // AB= (2^16 ah + al - 2^31) * (2^16 bh + bl - 2^31) // = 2^32(ah*bh) // +2^16 (ah*bl+al*bh) // +(al*bl) // - 2^31 (2^16 bh+bl + 2^16 ah+al) // - 2^62 // = 2^32(ah*bh) // +2^16 (ah*bl+al*bh) // +(al*bl) // - 2^31 (2^16 bh+bl + 2^16 ah+al + 2^31) // always @(posedge i_clk) if (!OPT_LOWPOWER || mpypipe[0]) begin pp_f<=r_mpy_a_",
            "input [31:16]*r_mpy_b_",
            "input [31:16]; pp_oi<=r_mpy_a_",
            "input [31:16]*r_mpy_b_",
            "input [15: 0] + r_mpy_a_",
            "input [15: 0]*r_mpy_b_",
            "input [31:16]; pp_l<=r_mpy_a_",
            "input [15: 0]*r_mpy_b_",
            "input [15: 0]; pp_s <= 32'h8000_0000-( r_mpy_a_",
            "input [31:0] + r_mpy_b_",
            "input [31:0]); end // }}} // Third clock, add the results and get a product: r_mpy_result // {{{",
            "always @(posedge i_clk) if (!OPT_LOWPOWER || mpypipe[1]) begin r_mpy_result[15:0] <= pp_l[15:0]; r_mpy_result[63:16] <= { 32'h00, pp_l[31:16] } + { 15'h00, pp_oi } + { pp_s, 15'h00 } + { pp_f, 16'h00 }; end // }}}",
            "assign o_result = r_mpy_result; // Fourth clock -- results are clocked into writeback // }}} end else begin : MPYSLOW // {{{ // Use an external multiply implementation, for when DSPs aren't // available. // // Declarations // {{{",
            "reg r_hi; // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused_aux;",
            "wire [65:0] full_result; // verilator lint_on UNUSED // verilator coverage_on // }}} slowmpy #(.LGNA(6), .NA(33) ) slowmpyi( i_clk, i_reset, i_stb, { (i_op[0])&(i_a[31]), i_a }, { (i_op[0])&(i_b[31]), i_b }, 1'b0, o_busy, o_valid, full_result, unused_aux );",
            "assign o_result = full_result[63:0];",
            "always @(posedge i_clk) if (i_stb) r_hi <= i_op[1];",
            "assign o_hi = r_hi; // }}} end end end end end endgenerate // All possible multiply results have been determined",
            "endmodule"
        ]
    },
    {
        "file_name": "pipemem.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/pipemem.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: pipemem.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A memory unit to support a CPU, this time one supporting // pipelined wishbone memory accesses. The goal is to be able // to issue one pipelined wishbone access per clock, and (given the memory // is fast enough) to be able to read the results back at one access per // clock. This renders on-chip memory fast enough to handle single cycle // (pipelined) access. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory, run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module pipemem #( // {{{",
            "parameter ADDRESS_WIDTH=28, parameter BUS_WIDTH=32, parameter [0:0] OPT_LOCK=1'b1, WITH_LOCAL_BUS=1'b1, OPT_ZERO_ON_IDLE=1'b0, // OPT_ALIGNMENT_ERR OPT_ALIGNMENT_ERR=1'b0, localparam AW=ADDRESS_WIDTH, FLN=4, parameter [(FLN-1):0] OPT_MAXDEPTH=4'hd // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // CPU interface // {{{",
            "input wire i_pipe_stb, i_lock, input wire [2:0] i_op, input wire [31:0] i_addr, input wire [31:0] i_data, input wire [4:0] i_o",
            "reg , // CPU",
            "output s",
            "output wire o_busy, o_rdbusy, output wire o_pipe_stalled, output reg o_valid, output reg o_err, output reg [4:0] o_w",
            "reg , output reg [31:0] o_result, // }}} // Wishbone",
            "output s // {{{",
            "output wire o_wb_cyc_gbl, output wire o_wb_cyc_lcl, output reg o_wb_stb_gbl, output reg o_wb_stb_lcl, o_wb_we, output reg [(AW-1):0] o_wb_addr, output reg [BUS_WIDTH-1:0] o_wb_data, output reg [BUS_WIDTH/8-1:0] o_wb_sel, // Wishbone",
            "input s",
            "input wire i_wb_stall, i_wb_ack, i_wb_err, input wire [BUS_WIDTH-1:0] i_wb_data // }}} // }}} ); // Declarations // {{{",
            "localparam WBLSB = $clog2(BUS_WIDTH/8); // Verilator lint_off UNUSED",
            "localparam F_LGDEPTH=FLN+1; // Verilator lint_on UNUSED `ifdef FORMAL",
            "wire [(F_LGDEPTH-1):0] f_nreqs, f_nacks, f_outstanding;",
            "reg f_pc; `endif",
            "reg cyc, r_wb_cyc_gbl, r_wb_cyc_lcl, fifo_full;",
            "wire gbl_stb, lcl_stb, lcl_bus;",
            "reg [(FLN-1):0] rdaddr, wraddr;",
            "wire [(FLN-1):0] nxt_rdaddr, fifo_fill;",
            "reg [4+2+WBLSB-1:0] fifo_mem [0:15];",
            "reg fifo_gie;",
            "wire [4+2+WBLSB-1:0] w_w",
            "reg ;",
            "wire misaligned;",
            "reg [BUS_WIDTH/8-1:0] oword_sel;",
            "wire [BUS_WIDTH/8-1:0] pre_wb_sel;",
            "reg [31:0] oword_data;",
            "wire [BUS_WIDTH-1:0] pre_wb_data, pre_result; // }}} // misaligned // {{{ generate if (OPT_ALIGNMENT_ERR) begin : GEN_ALIGNMENT_ERR",
            "reg r_mis;",
            "always @(*) casez({ i_op[2:1], i_addr[1:0] }) 4'b01?1: r_mis = i_pipe_stb; 4'b0110: r_mis = i_pipe_stb; 4'b10?1: r_mis = i_pipe_stb; default: r_mis = i_pipe_stb; endcase",
            "assign misaligned = r_mis; end else begin : NO_MISALIGNMENT_ERRS",
            "assign misaligned = 1'b0; end endgenerate // }}} // fifo_mem // {{{",
            "always @(posedge i_clk) fifo_mem[wraddr] <= { i_o",
            "reg [3:0], i_op[2:1], i_addr[WBLSB-1:0] }; // }}} // fifo_gie // {{{",
            "always @(posedge i_clk) if (i_pipe_stb) fifo_gie <= i_o",
            "reg [4]; // }}} // wraddr // {{{",
            "initial wraddr = 0;",
            "always @(posedge i_clk) if (i_reset) wraddr <= 0; else if (((i_wb_err)&&(cyc))||((i_pipe_stb)&&(misaligned))) wraddr <= 0; else if (i_pipe_stb) wraddr <= wraddr + 1'b1; // }}} // rdaddr // {{{",
            "initial rdaddr = 0;",
            "always @(posedge i_clk) if (i_reset) rdaddr <= 0; else if (((i_wb_err)&&(cyc))||((i_pipe_stb)&&(misaligned))) rdaddr <= 0; else if ((i_wb_ack)&&(cyc)) rdaddr <= rdaddr + 1'b1; // }}}",
            "assign fifo_fill = wraddr - rdaddr; // fifo_full // {{{",
            "initial fifo_full = 0;",
            "always @(posedge i_clk) if (i_reset || !cyc) fifo_full <= 0; else if (((i_wb_err)&&(cyc))||((i_pipe_stb)&&(misaligned))) fifo_full <= 0; else case({ i_pipe_stb, i_wb_ack }) 2'b10: fifo_full <= (fifo_fill >= OPT_MAXDEPTH-1); 2'b01: fifo_full <= 1'b0; default: begin end endcase `ifdef FORMAL",
            "always @(*) if (!cyc) begin assert(fifo_full == 0); end else assert(fifo_full == (fifo_fill >= OPT_MAXDEPTH));",
            "always @(*) if (fifo_full) assert(fifo_fill == OPT_MAXDEPTH); `endif // }}}",
            "assign nxt_rdaddr = rdaddr + 1'b1; // lcl_bus, lcl_stb, gbl_stb // {{{",
            "assign lcl_bus = (i_addr[31:24]==8'hff)&&(WITH_LOCAL_BUS);",
            "assign lcl_stb = (lcl_bus)&&(!misaligned);",
            "assign gbl_stb = ((!lcl_bus)||(!WITH_LOCAL_BUS))&&(!misaligned); //= ((i_addr[31:8]!=24'hc00000)||(i_addr[7:5]!=3'h0)); // }}} // cyc, [or]_wb_[cyc|stb]_[lcl|gbl] // {{{",
            "initial cyc = 0;",
            "initial r_wb_cyc_lcl = 0;",
            "initial r_wb_cyc_gbl = 0;",
            "initial o_wb_stb_lcl = 0;",
            "initial o_wb_stb_gbl = 0;",
            "always @(posedge i_clk) begin if (cyc) begin if (((!i_wb_stall)&&(!i_pipe_stb)&&(!misaligned)) ||(i_wb_err)) begin o_wb_stb_gbl <= 1'b0; o_wb_stb_lcl <= 1'b0; end if (((i_wb_ack)&&(nxt_rdaddr == wraddr) &&((!i_pipe_stb)||(misaligned))) ||(i_wb_err)) begin r_wb_cyc_gbl <= 1'b0; r_wb_cyc_lcl <= 1'b0; o_wb_stb_gbl <= 1'b0; o_wb_stb_lcl <= 1'b0; cyc <= 1'b0; end end else if (i_pipe_stb) // New memory operation begin // Grab the wishbone r_wb_cyc_lcl <= lcl_stb; r_wb_cyc_gbl <= gbl_stb; o_wb_stb_lcl <= lcl_stb; o_wb_stb_gbl <= gbl_stb; cyc <= (!misaligned); end if (i_reset) begin r_wb_cyc_gbl <= 1'b0; r_wb_cyc_lcl <= 1'b0; o_wb_stb_gbl <= 1'b0; o_wb_stb_lcl <= 1'b0; cyc <= 1'b0; end if (!WITH_LOCAL_BUS) begin r_wb_cyc_lcl <= 1'b0; o_wb_stb_lcl <= 1'b0; end end // }}} // pre_wb_sel // {{{",
            "always @(*) begin oword_sel = 0; casez({ i_op[2:1], i_addr[1:0] }) 4'b100?: oword_sel[3:0] = 4'b1100; // Op = 5 4'b101?: oword_sel[3:0] = 4'b0011; // Op = 5 4'b1100: oword_sel[3:0] = 4'b1000; // Op = 5 4'b1101: oword_sel[3:0] = 4'b0100; // Op = 7 4'b1110: oword_sel[3:0] = 4'b0010; // Op = 7 4'b1111: oword_sel[3:0] = 4'b0001; // Op = 7 default: oword_sel[3:0] = 4'b1111; // Op = 7 endcase end generate if (BUS_WIDTH == 32) begin : GEN_SEL32",
            "assign pre_wb_sel = oword_sel; end else begin : GEN_WIDESEL32 // If we were little endian, we'd do ... // assign pre_wb_sel = (oword_sel << (4* i_addr[WBLSB-1:2]));",
            "assign pre_wb_sel = {oword_sel[3:0], {(BUS_WIDTH/8-4){1'b0}} } >> (4* i_addr[WBLSB-1:2]); end endgenerate // }}} // pre_wb_data // {{{",
            "always @(*) casez({ i_op[2:1], i_addr[1:0] }) 4'b100?: oword_data = { i_data[15:0], 16'h00 }; 4'b101?: oword_data = { 16'h00, i_data[15:0] }; 4'b1100: oword_data = { i_data[7:0], 24'h00 }; 4'b1101: oword_data = { 8'h00, i_data[7:0], 16'h00 }; 4'b1110: oword_data = { 16'h00, i_data[7:0], 8'h00 }; 4'b1111: oword_data = { 24'h00, i_data[7:0] }; default: oword_data = i_data; endcase generate if (BUS_WIDTH == 32) begin : GEN_DATA32",
            "assign pre_wb_data = oword_data; end else begin : GEN_WIDEDATA32 // If we were little endian, we'd do ... // assign pre_wb_sel = (word_sel << (4* i_addr[WBLSB-1:2]));",
            "assign pre_wb_data = {oword_data, {(BUS_WIDTH-32){1'b0}} } >> (32* i_addr[WBLSB-1:2]); end endgenerate // }}} // o_wb_addr, o_wb_sel, and o_wb_data // {{{",
            "always @(posedge i_clk) if ((!cyc)||(!i_wb_stall)) begin // o_wb_add // {{{ if ((OPT_ZERO_ON_IDLE)&&(!i_pipe_stb)) o_wb_addr <= 0; else if (lcl_bus) o_wb_addr <= i_addr[2 +: AW]; else o_wb_addr <= i_addr[WBLSB +: AW]; // }}} // o_wb_sel // {{{ if ((OPT_ZERO_ON_IDLE)&&(!i_pipe_stb)) o_wb_sel <= {(BUS_WIDTH/8){1'b0}}; else if (lcl_bus) o_wb_sel <= oword_sel; else o_wb_sel <= pre_wb_sel; // }}} // o_wb_data // {{{ o_wb_data <= 0; if ((OPT_ZERO_ON_IDLE)&&(!i_pipe_stb)) o_wb_data <= 0; else if (lcl_bus) o_wb_data[31:0] <= oword_data; else o_wb_data <= pre_wb_data; // }}} end // }}} // o_wb_we // {{{",
            "always @(posedge i_clk) if ((i_pipe_stb)&&(!cyc)) o_wb_we <= i_op[0]; else if ((OPT_ZERO_ON_IDLE)&&(!cyc)) o_wb_we <= 1'b0; // }}} // o_valid // {{{",
            "initial o_valid = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_valid <= 1'b0; else o_valid <= (cyc)&&(i_wb_ack)&&(!o_wb_we); // }}} // o_err // {{{",
            "initial o_err = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_err <= 1'b0; else o_err <= ((cyc)&&(i_wb_err))||((i_pipe_stb)&&(misaligned)); // }}}",
            "assign o_busy = cyc;",
            "assign o_rdbusy = o_busy && !o_wb_we;",
            "assign w_w",
            "reg = fifo_mem[rdaddr]; // o_w",
            "reg // {{{",
            "always @(posedge i_clk) o_w",
            "reg <= { fifo_gie, w_w",
            "reg [2 + WBLSB +: 4] }; // }}} // o_result // {{{ generate if (BUS_WIDTH == 32) begin : COPY_IDATA",
            "assign pre_result = i_wb_data; end else begin : GEN_PRERESULT",
            "assign pre_result = i_wb_data << (8*w_w",
            "reg [WBLSB-1:0]); // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_preresult;",
            "assign unused_preresult = &{1'b0, pre_result[BUS_WIDTH-33:0] }; // Verilator lint_on UNUSED // Verilator coverage_on end endgenerate",
            "always @(posedge i_clk) if ((OPT_ZERO_ON_IDLE)&&((!cyc)||((!i_wb_ack)&&(!i_wb_err)))) o_result <= 0; else if ((o_wb_cyc_lcl && WITH_LOCAL_BUS) || (BUS_WIDTH == 32)) begin casez({ w_w",
            "reg [WBLSB +: 2], w_w",
            "reg [1:0] }) 4'b1100: o_result <= { 24'h00, i_wb_data[31:24] }; 4'b1101: o_result <= { 24'h00, i_wb_data[23:16] }; 4'b1110: o_result <= { 24'h00, i_wb_data[15: 8] }; 4'b1111: o_result <= { 24'h00, i_wb_data[ 7: 0] }; 4'b100?: o_result <= { 16'h00, i_wb_data[31:16] }; 4'b101?: o_result <= { 16'h00, i_wb_data[15: 0] }; default: o_result <= i_wb_data[31:0]; endcase end else begin casez(w_w",
            "reg [WBLSB +: 2]) 2'b11: o_result <= { 24'h00, pre_result[BUS_WIDTH-1:BUS_WIDTH-8] }; 2'b10: o_result <= { 16'h00, pre_result[BUS_WIDTH-1:BUS_WIDTH-16] }; default: o_result <= pre_result[BUS_WIDTH-1:BUS_WIDTH-32]; endcase end // }}} // o_pipe_stalled // {{{",
            "assign o_pipe_stalled = ((cyc)&&(fifo_full))||((cyc) &&((i_wb_stall)||((!o_wb_stb_lcl)&&(!o_wb_stb_gbl)))); // }}} // lock_gbl, lock_lcl // {{{ generate if (OPT_LOCK) begin : LOCK_REGISTER // {{{",
            "reg lock_gbl, lock_lcl;",
            "initial lock_gbl = 1'b0;",
            "initial lock_lcl = 1'b0;",
            "always @(posedge i_clk) begin lock_gbl <= r_wb_cyc_gbl || lock_gbl; lock_lcl <= r_wb_cyc_lcl || lock_lcl; if (i_reset || (i_wb_err && cyc) || (i_pipe_stb && misaligned) || !i_lock) begin lock_gbl <= 1'b0; lock_lcl <= 1'b0; end if (!WITH_LOCAL_BUS) lock_lcl <= 1'b0; end",
            "assign o_wb_cyc_gbl = (r_wb_cyc_gbl)||(lock_gbl);",
            "assign o_wb_cyc_lcl = (r_wb_cyc_lcl)||(lock_lcl); // }}} end else begin : NO_LOCK // {{{",
            "assign o_wb_cyc_gbl = (r_wb_cyc_gbl);",
            "assign o_wb_cyc_lcl = (r_wb_cyc_lcl); // Verilator coverage_off // verilator lint_off UNUSED",
            "wire unused_lock;",
            "assign unused_lock = &{ 1'b0, i_lock }; // verilator lint_on UNUSED // Verilator coverage_on // }}} end endgenerate // }}} // Make verilator happy // {{{ // Verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = { 1'b0 }; // verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal property section // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Declarations // {{{ `define ASSERT assert `ifdef PIPEMEM `define ASSUME assume `else `define ASSUME assert `endif",
            "wire [(F_LGDEPTH-1):0] fcpu_outstanding;",
            "wire f_cyc, f_stb;",
            "reg f_done;",
            "wire [3:0] f_pipe_used;",
            "reg [(1<<FLN)-1:0] f_mem_used;",
            "reg f_past_valid;",
            "wire f_pc_check, f_gie, f_read_cycle;",
            "wire [4:0] f_last_",
            "reg , f_addr_",
            "reg ; // Verilator lint_off UNDRIVEN (* anyseq *)",
            "reg [4:0] f_a",
            "reg ; // Verilator lint_on UNDRIVEN // }}} //////////////////////////////////////////////////////////////////////// // // Reset properties // {{{ //////////////////////////////////////////////////////////////////////// // // initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "initial `ASSUME( i_reset);",
            "always @(*) if (!f_past_valid) `ASSUME(i_reset); // }}} //////////////////////////////////////////////////////////////////////// // // Bus properties // {{{ //////////////////////////////////////////////////////////////////////// // // assign f_cyc = cyc;",
            "assign f_stb = (o_wb_stb_gbl)||(o_wb_stb_lcl); fwb_master #( // {{{ .AW(AW), .DW(BUS_WIDTH), .F_LGDEPTH(F_LGDEPTH), // .F_MAX_REQUESTS(14), // Not quite true, can do more .F_OPT_RMW_BUS_OPTION(OPT_LOCK), .F_OPT_DISCONTINUOUS(OPT_LOCK) // }}} ) fwb( // {{{ i_clk, i_reset, cyc, f_stb, o_wb_we, o_wb_addr, o_wb_data, o_wb_sel, i_wb_ack, i_wb_stall, i_wb_data, i_wb_err, f_nreqs, f_nacks, f_outstanding // }}} ); // }}} //////////////////////////////////////////////////////////////////////// // // CPU interface properties // {{{ //////////////////////////////////////////////////////////////////////// // // initial f_done = 0;",
            "always @(posedge i_clk) if (i_reset) f_done <= 1'b0; else if (cyc) begin f_done <= 0; if (i_wb_err || i_wb_ack) f_done <= 1; if (i_pipe_stb && misaligned) f_done <= 1; end else f_done <= 1'b0; fmem #( // {{{ .OPT_LOCK(OPT_LOCK), .F_LGDEPTH(F_LGDEPTH), .OPT_MAXDEPTH(OPT_MAXDEPTH) // }}} ) iface( // {{{ .i_clk(i_clk), .i_sys_reset(i_reset), .i_cpu_reset(i_reset), .i_stb(i_pipe_stb), .i_pipe_stalled(o_pipe_stalled), .i_clear_cache(1'b0), .i_lock(i_lock), .i_op(i_op), .i_addr(i_addr), .i_data(i_data), .i_o",
            "reg (i_o",
            "reg ), .i_a",
            "reg (f_a",
            "reg ), .i_busy(o_busy), .i_rdbusy(o_busy && !o_wb_we), .i_valid(o_valid), .i_done(f_done), .i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_result), .f_outstanding(fcpu_outstanding), .f_pc(f_pc_check), .f_gie(f_gie), .f_read_cycle(f_read_cycle), .f_last_",
            "reg (f_last_",
            "reg ), .f_addr_",
            "reg (f_addr_",
            "reg ) // }}} );",
            "always @(*) if (!o_err || !OPT_ALIGNMENT_ERR) assert(f_pc == f_pc_check);",
            "always @(*) if (o_busy) assert(f_gie == fifo_gie);",
            "always @(*) if (cyc) assert(f_read_cycle == !o_wb_we); // }}} //////////////////////////////////////////////////////////////////////// // // Other (induction) properties // {{{ //////////////////////////////////////////////////////////////////////// // // // // Assumptions about",
            "input s // always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) `ASSERT(!o_pipe_stalled); // Assume we won't cross from GBL to LCL in a given string // {{{",
            "always @(posedge i_clk) if ((r_wb_cyc_gbl)&&(i_pipe_stb)) `ASSUME(gbl_stb);",
            "always @(posedge i_clk) if ((r_wb_cyc_lcl)&&(i_pipe_stb)) `ASSUME(lcl_stb); // }}}",
            "assign f_pipe_used = wraddr - rdaddr;",
            "always @(*) `ASSERT(f_pipe_used == fifo_fill);",
            "always @(*) if (!o_err) `ASSERT(f_pipe_used + (f_done ? 1:0) == fcpu_outstanding);",
            "always @(posedge i_clk) if (f_pipe_used == OPT_MAXDEPTH) begin // `ASSUME(!i_pipe_stb); `ASSERT((o_busy)&&(o_pipe_stalled)); end",
            "always @(*) `ASSERT(fifo_fill <= OPT_MAXDEPTH); `ifndef VERILATOR",
            "always @(*) if ((WITH_LOCAL_BUS)&&(o_wb_cyc_gbl|o_wb_cyc_lcl) &&(i_pipe_stb)) begin if (o_wb_cyc_lcl) begin // `ASSUME(i_addr[31:24] == 8'hff); assume(i_addr[31:24] == 8'hff); end else assume(i_addr[31:24] != 8'hff); end `endif",
            "always @(*) if (!WITH_LOCAL_BUS) begin assert(!r_wb_cyc_lcl); assert(!o_wb_cyc_lcl); assert(!o_wb_stb_lcl); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(f_cyc))&&(!$past(i_pipe_stb))) `ASSERT(f_pipe_used == 0);",
            "always @(*) if (!f_cyc) `ASSERT(f_pipe_used == 0);",
            "always @(posedge i_clk) if (f_pipe_used >= 13) `ASSUME(!i_pipe_stb);",
            "always @(posedge i_clk) if ((f_cyc)&&(f_pipe_used >= 13)) `ASSERT((o_busy)&&(o_pipe_stalled));",
            "always @(posedge i_clk) `ASSERT((!r_wb_cyc_gbl)||(!r_wb_cyc_lcl));",
            "always @(posedge i_clk) `ASSERT((!o_wb_cyc_gbl)||(!o_wb_cyc_lcl));",
            "always @(posedge i_clk) `ASSERT((!o_wb_stb_gbl)||(!o_wb_stb_lcl));",
            "always @(*) if (!WITH_LOCAL_BUS) begin assert(!o_wb_cyc_lcl); assert(!o_wb_stb_lcl); if (o_wb_stb_lcl) assert(o_wb_addr[(AW-1):22] == {(8-(30-AW)){1'b1}}); end",
            "always @(posedge i_clk) if (o_wb_stb_gbl) `ASSERT(o_wb_cyc_gbl);",
            "always @(posedge i_clk) if (o_wb_stb_lcl) `ASSERT(o_wb_cyc_lcl);",
            "always @(posedge i_clk) `ASSERT(cyc == (r_wb_cyc_gbl|r_wb_cyc_lcl));",
            "always @(posedge i_clk) `ASSERT(cyc == (r_wb_cyc_lcl)|(r_wb_cyc_gbl));",
            "always @(posedge i_clk) if ((f_past_valid)&&(!i_reset)&&(!$past(misaligned))) begin if (f_stb) begin `ASSERT(f_pipe_used == f_outstanding + 4'h1); end else `ASSERT(f_pipe_used == f_outstanding); end",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(r_wb_cyc_gbl||r_wb_cyc_lcl)) &&(!$past(f_stb))) `ASSERT(!f_stb);",
            "always @(*) `ASSERT((!lcl_stb)||(!gbl_stb)); // // insist that we only ever accept memory requests for the same GIE // (i.e. 4th bit of",
            "reg ister) // always @(*) if ((i_pipe_stb)&&(wraddr != rdaddr)) `ASSUME(i_o",
            "reg [4] == fifo_gie);",
            "initial f_pc = 1'b0;",
            "always @(posedge i_clk) if(i_reset) f_pc <= 1'b0; else if (i_pipe_stb && !misaligned) f_pc <= (((f_pc)&&(f_cyc)) ||((!i_op[0])&&(i_o",
            "reg [3:1] == 3'h7))); else if (!f_cyc) f_pc <= 1'b0;",
            "always @(posedge i_clk) if ((f_cyc)&&(o_wb_we)) `ASSERT(!f_pc); // always @(*) // if ((f_pc)&&(f_cyc)) // `ASSUME(!i_pipe_stb);",
            "always @(*) if (wraddr == rdaddr) begin `ASSERT(!r_wb_cyc_gbl); `ASSERT(!r_wb_cyc_lcl); end else if (f_cyc) begin `ASSERT(fifo_fill == f_outstanding + ((f_stb)?1:0)); end // }}} //////////////////////////////////////////////////////////////////////// // // The FIFO check // {{{ //////////////////////////////////////////////////////////////////////// // `define FIFOCHECK `ifdef FIFOCHECK",
            "reg [4+2+WBLSB-1:0] fc_mem, frd_mem; // Verilator lint_off UNDRIVEN (* anyconst *)",
            "reg [3:0] fc_addr; // Verilator lint_on UNDRIVEN",
            "wire [3:0] lastaddr = wraddr - 1'b1; integer k;",
            "always @(*) begin f_mem_used = 0; for(k = 0 ; k < (1<<FLN); k=k+1) begin if (wraddr == rdaddr) f_mem_used[k] = 1'b0; else if (wraddr > rdaddr) begin if ((k < wraddr)&&(k >= rdaddr)) f_mem_used[k] = 1'b1; end else if (k < wraddr) f_mem_used[k] = 1'b1; else if (k >= rdaddr) f_mem_used[k] = 1'b1; end end",
            "always @(*) fc_mem = fifo_mem[fc_addr];",
            "always @(*) frd_mem = fifo_mem[rdaddr];",
            "always @(*) if (cyc && !o_wb_we) begin if (f_mem_used[rdaddr] && fc_addr != rdaddr) begin assume((frd_mem[1+2+WBLSB +: 3] == 3'h7) == (f_pc && rdaddr == lastaddr)); assume(({ fifo_gie, frd_mem[2+WBLSB +: 4] } != f_addr_",
            "reg ) || (rdaddr == lastaddr)); end if (f_mem_used[fc_addr]) begin `ASSERT((fc_mem[1+2+WBLSB +: 3] == 3'h7) == (f_pc && fc_addr == lastaddr)); `ASSERT(({ fifo_gie, fc_mem[2+WBLSB +: 4] } != f_addr_",
            "reg ) || fc_addr == lastaddr); end end",
            "always @(*) if (fifo_fill > 0) assert({ fifo_gie, fifo_mem[lastaddr][2+WBLSB +: 4] } == f_last_",
            "reg );",
            "initial assert(!fifo_full); // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) cover(cyc && !fifo_full);",
            "always @(posedge i_clk) cover((f_cyc)&&(f_stb)&&(!i_wb_stall)&&(!i_wb_ack) &&(!o_pipe_stalled));",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(f_stb))&&($past(f_cyc))) cover((f_cyc)&&(i_wb_ack));",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(f_stb))&&($past(f_cyc))) cover($past(i_wb_ack)&&(i_wb_ack));",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_valid))) cover(o_valid); `endif // FIFOCHECK // }}}",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(f_past_valid))&&($past(f_cyc))&&($past(f_cyc,2))) `ASSERT($stable(o_w",
            "reg [4]));",
            "always @(*) `ASSERT((!f_cyc)||(!o_valid)||(o_w",
            "reg [3:1]!=3'h7)); // Make Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, f_nreqs, f_nacks }; // Verilator lint_off UNUSED // }}} `endif // FORMAL // }}}",
            "endmodule // // // Usage (from yosys): (Before) (A,!OPTZ) (A,OPTZ) // Cells: 302 314 391 // FDRE 138 140 140 // LUT1 2 2 2 // LUT2 38 41 61 // LUT3 13 16 33 // LUT4 3 8 12 // LUT5 22 10 8 // LUT6 52 59 81 // MUXCY 6 6 6 // MUXF7 10 13 21 // MUXF8 1 2 10 // RAM64X1D 9 9 9 // XORCY 8 8 8 // //"
        ]
    },
    {
        "file_name": "zipwb.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/zipwb.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipwb.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This is the top level",
            "module holding the core of the Zip CPU // together. The Zip CPU is designed to be as simple as possible. // (actual implementation aside ...) The instruction set is about as // RISC as you can get, with only 26 instruction types currently supported. // (There are still 8-instruction Op-Codes reserved for floating point, // and 5 which can be used for transactions not requiring",
            "reg isters.) // Please see the accompanying spec.pdf file for a description of these // instructions. // // All instructions are 32-bits wide. All bus accesses, both address and // data, are 32-bits over a wishbone bus. // // The Zip CPU is fully pipelined with the following pipeline stages: // // 1. Prefetch, returns the instruction from memory. // // 2. Instruction Decode // // 3. Read Operands // // 4. Apply Instruction // // 4. Write-back Results // // Further information about the inner workings of this CPU, such as // what causes pipeline stalls, may be found in the spec.pdf file. (The // documentation within this file had become out of date and out of sync // with the spec.pdf, so look to the spec.pdf for accurate and up to date // information.) // // // In general, the pipelining is controlled by three pieces of",
            "logic // per stage: _ce, _stall, and _valid. _valid means that the stage // holds a valid instruction. _ce means that the instruction from the // previous stage is to move into this one, and _stall means that the // instruction from the previous stage may not move into this one. // The difference between these control signals allows individual stages // to propagate instructions independently. In general, the",
            "logic works // as: // // // assign (n)_ce = (n-1)_valid && (!(n)_stall) // // // always @(posedge i_clk) // if ((i_reset)||(clear_pipeline)) // (n)_valid = 0 // else if (n)_ce // (n)_valid = 1 // else if (n+1)_ce // (n)_valid = 0 // // assign (n)_stall = ( (n-1)_valid && ( pipeline hazard detection ) ) // || ( (n)_valid && (n+1)_stall ); // // and ... // // always @(posedge i_clk) // if (n)_ce // (n)_variable = ... whatever",
            "logic for this stage // // Note that a stage can stall even if no instruction is loaded into // it. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipwb #( // {{{",
            "parameter [31:0] RESET_ADDRESS=32'h010_0000, parameter ADDRESS_WIDTH=30, BUS_WIDTH = 32, // Bus width OPT_LGICACHE=12, localparam DATA_WIDTH = 32, // CPU data width",
            "parameter OPT_MPY = 3, parameter [0:0] OPT_DIV = 1, parameter [0:0] OPT_SHIFTS = 1, parameter [0:0] IMPLEMENT_FPU = 0, parameter [0:0] OPT_EARLY_BRANCHING = 1, parameter [0:0] OPT_CIS = 1'b1, parameter [0:0] OPT_DISTRIBUTED_REGS = 1'b1, parameter [0:0] OPT_PIPELINED = 1'b1, parameter [0:0] OPT_START_HALTED=1, parameter [0:0] OPT_LOCK=1, parameter [0:0] OPT_LOWPOWER = 1'b0, parameter OPT_LGDCACHE = 10, parameter [0:0] OPT_SIM = 1'b1, parameter [0:0] OPT_CLKGATE = 1'b0, parameter [0:0] WITH_LOCAL_BUS = 1'b1, parameter [0:0] OPT_DBGPORT = 1'b1, parameter [0:0] OPT_TRACE_PORT = 1'b0, parameter [0:0] OPT_PROFILER = 1'b0, parameter [0:0] OPT_USERMODE = 1'b1, localparam AW=ADDRESS_WIDTH, localparam WBLSB = $clog2(BUS_WIDTH/8) `ifdef FORMAL , parameter F_LGDEPTH=8 `endif // }}} ) ( // {{{",
            "input wire i_clk, i_reset, i_interrupt, input wire i_cpu_clken, // Debug interface --",
            "input s",
            "input wire i_halt, i_clear_cache, input wire [4:0] i_dbg_w",
            "reg , input wire i_dbg_we, input wire [DATA_WIDTH-1:0] i_dbg_data, input wire [4:0] i_dbg_r",
            "reg , // Debug interface --",
            "output s",
            "output wire o_dbg_stall, output wire o_halted, output wire [DATA_WIDTH-1:0] o_dbg_",
            "reg , output wire [2:0] o_dbg_cc, output wire o_break, // CPU interface to the wishbone bus // Wishbone interface --",
            "output s",
            "output wire o_wb_gbl_cyc, o_wb_gbl_stb, output wire o_wb_lcl_cyc, o_wb_lcl_stb, o_wb_we, output wire [AW-1:0] o_wb_addr, output wire [BUS_WIDTH-1:0] o_wb_data, output wire [BUS_WIDTH/8-1:0] o_wb_sel, // Wishbone interface --",
            "input s",
            "input wire i_wb_stall, i_wb_ack, input wire [BUS_WIDTH-1:0] i_wb_data, input wire i_wb_err, // Accounting",
            "output s ... to help us count stalls and usage",
            "output wire o_op_stall, output wire o_pf_stall, output wire o_i_count, // output wire [31:0] o_debug, output wire o_prof_stb, output wire [AW+WBLSB-1:0] o_prof_addr, output wire [31:0] o_prof_ticks // }}} ); // Declarations // {{{",
            "localparam [0:0] OPT_DCACHE = (OPT_LGDCACHE > 2);",
            "localparam [0:0] OPT_PIPELINED_BUS_ACCESS = (OPT_PIPELINED);",
            "localparam [0:0] OPT_MEMPIPE = OPT_PIPELINED_BUS_ACCESS;",
            "localparam INSN_WIDTH = 32;",
            "wire cpu_clken, cpu_clock, clk_gate;",
            "wire [31:0] cpu_debug; // Fetch // {{{",
            "wire pf_new_pc, clear_icache, pf_ready;",
            "wire [AW+WBLSB-1:0] pf_request_address;",
            "wire [INSN_WIDTH-1:0] pf_instruction;",
            "wire [AW+WBLSB-1:0] pf_instruction_pc;",
            "wire pf_valid, pf_illegal; // wire pf_cyc, pf_stb, pf_stall, pf_ack, pf_err;",
            "wire [AW-1:0] pf_addr;",
            "wire [BUS_WIDTH/8-1:0] pf_sel; // verilator coverage_off // Since we aren't writing, these values will be constants",
            "wire pf_we;",
            "wire [BUS_WIDTH-1:0] pf_data; // verilator coverage_on // }}} // Memory // {{{",
            "wire clear_dcache, mem_ce, bus_lock;",
            "wire [2:0] mem_op;",
            "wire [31:0] mem_cpu_addr;",
            "wire [AW+WBLSB-1:0] mem_lock_pc; // Byte address",
            "wire [DATA_WIDTH-1:0] mem_wdata;",
            "wire [BUS_WIDTH-1:0] mem_data;",
            "wire [4:0] mem_",
            "reg ;",
            "wire mem_busy, mem_rdbusy, mem_pipe_stalled, mem_valid, mem_bus_err;",
            "wire [4:0] mem_w",
            "reg ;",
            "wire [DATA_WIDTH-1:0] mem_result; // wire mem_stb_lcl, mem_stb_gbl, mem_cyc_lcl, mem_cyc_gbl;",
            "wire [AW-1:0] mem_bus_addr;",
            "wire mem_we, mem_stall, mem_ack, mem_err;",
            "wire [BUS_WIDTH/8-1:0] mem_sel; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // The ZipCPU Core // {{{ //////////////////////////////////////////////////////////////////////// // // wire w_dbg_stall; zipcore #( // {{{ .RESET_ADDRESS(RESET_ADDRESS), .ADDRESS_WIDTH(AW+WBLSB-$clog2(DATA_WIDTH/8)), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .IMPLEMENT_FPU(IMPLEMENT_FPU), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_START_HALTED(OPT_START_HALTED), .OPT_CIS(OPT_CIS), .OPT_SIM(OPT_SIM), .OPT_CLKGATE(OPT_CLKGATE), .OPT_PIPELINED(OPT_PIPELINED), .OPT_PIPELINED_BUS_ACCESS(OPT_MEMPIPE), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_USERMODE(OPT_USERMODE), .OPT_LOCK(OPT_LOCK), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_DBGPORT(OPT_DBGPORT), .OPT_TRACE_PORT(OPT_TRACE_PORT), .OPT_PROFILER(OPT_PROFILER) `ifdef FORMAL , .F_LGDEPTH(F_LGDEPTH) `endif // }}} ) core ( // {{{ .i_clk(cpu_clock), .i_reset(i_reset), .i_interrupt(i_interrupt), .o_clken(cpu_clken), // Debug interface // {{{ .i_halt(i_halt), .i_clear_cache(i_clear_cache), .i_dbg_w",
            "reg (i_dbg_w",
            "reg ), .i_dbg_we(i_dbg_we), .i_dbg_data(i_dbg_data), .i_dbg_r",
            "reg (i_dbg_r",
            "reg ), .o_dbg_stall(w_dbg_stall), .o_dbg_",
            "reg (o_dbg_",
            "reg ), .o_dbg_cc(o_dbg_cc), .o_break(o_break), // }}} // Instruction fetch interface // {{{ .o_pf_new_pc(pf_new_pc), .o_clear_icache(clear_icache), .o_pf_ready(pf_ready), .o_pf_request_address(pf_request_address), .i_pf_valid(pf_valid), .i_pf_illegal(pf_illegal), .i_pf_instruction(pf_instruction), .i_pf_instruction_pc(pf_instruction_pc), // }}} // Memory unit interface // {{{ .o_clear_dcache(clear_dcache), .o_mem_ce(mem_ce), .o_bus_lock(bus_lock), .o_mem_op(mem_op), .o_mem_addr(mem_cpu_addr), .o_mem_data(mem_wdata), .o_mem_lock_pc(mem_lock_pc), .o_mem_",
            "reg (mem_",
            "reg ), .i_mem_busy(mem_busy), .i_mem_rdbusy(mem_rdbusy), .i_mem_pipe_stalled(mem_pipe_stalled), .i_mem_valid(mem_valid), .i_bus_err(mem_bus_err), .i_mem_w",
            "reg (mem_w",
            "reg ), .i_mem_result(mem_result), // }}} // Accounting/CPU usage interface // {{{ .o_op_stall(o_op_stall), .o_pf_stall(o_pf_stall), .o_i_count(o_i_count), // }}} .o_debug(cpu_debug), .o_prof_stb(o_prof_stb), .o_prof_addr(o_prof_addr), .o_prof_ticks(o_prof_ticks) // }}} );",
            "assign o_dbg_stall = w_dbg_stall || !clk_gate;",
            "assign o_halted = !w_dbg_stall; // }}} // o_debug -- the debugging bus",
            "input // {{{",
            "assign o_debug = cpu_debug; // }}} //////////////////////////////////////////////////////////////////////// // // Instruction Fetch // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_LGICACHE <= 1) begin : SINGLE_FETCH",
            "assign pf_sel = {(BUS_WIDTH/8){1'b1}}; prefetch #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH+WBLSB), .INSN_WIDTH(INSN_WIDTH), .DATA_WIDTH(BUS_WIDTH), // .OPT_LOWPOWER(OPT_LOWPOWER), (Unused) .OPT_LITTLE_ENDIAN(1'b0) // }}} ) pf ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // CPU signals // {{{ .i_new_pc(pf_new_pc), .i_clear_cache(clear_icache), .i_ready(pf_ready && clk_gate), .i_pc(pf_request_address), .o_valid(pf_valid), .o_illegal(pf_illegal), .o_insn(pf_instruction), .o_pc(pf_instruction_pc), // }}} // Wishbone signals // {{{ .o_wb_cyc(pf_cyc), .o_wb_stb(pf_stb), .o_wb_we(pf_we), .o_wb_addr(pf_addr), .o_wb_data(pf_data), .i_wb_stall(pf_stall), .i_wb_ack(pf_ack), .i_wb_err(pf_err), .i_wb_data(i_wb_data) // }}} // }}} ); end else if (OPT_LGICACHE <= 2) begin : DBLFETCH",
            "assign pf_sel = {(BUS_WIDTH/8){1'b1}}; dblfetch #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH+WBLSB), .DATA_WIDTH(BUS_WIDTH), .INSN_WIDTH(INSN_WIDTH), // .OPT_LOWPOWER(OPT_LOWPOWER), (Unused) .OPT_LITTLE_ENDIAN(1'b0) // }}} ) pf ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // CPU signals // {{{ .i_new_pc(pf_new_pc), .i_clear_cache(clear_icache), .i_ready(pf_ready && clk_gate), .i_pc(pf_request_address), .o_valid(pf_valid), .o_illegal(pf_illegal), .o_insn(pf_instruction), .o_pc(pf_instruction_pc), // }}} // Wishbone signals // {{{ .o_wb_cyc(pf_cyc), .o_wb_stb(pf_stb), .o_wb_we(pf_we), .o_wb_addr(pf_addr), .o_wb_data(pf_data), .i_wb_stall(pf_stall), .i_wb_ack(pf_ack), .i_wb_err(pf_err), .i_wb_data(i_wb_data) // }}} // }}} ); end else if (OPT_LGICACHE <= 6) begin : PFFIFO pffifo #( // {{{ .AW(ADDRESS_WIDTH), .BUS_WIDTH(BUS_WIDTH), .INSN_WIDTH(INSN_WIDTH), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_LITTLE_ENDIAN(1'b0) // }}} ) pf ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // CPU signals // {{{ .i_new_pc(pf_new_pc), .i_clear_cache(clear_icache), .i_ready(pf_ready && clk_gate), .i_pc(pf_request_address), .o_valid(pf_valid), .o_illegal(pf_illegal), .o_insn(pf_instruction), .o_pc(pf_instruction_pc), // }}} // Wishbone signals // {{{ .o_wb_cyc(pf_cyc), .o_wb_stb(pf_stb), .o_wb_we(pf_we), .o_wb_addr(pf_addr), .o_wb_data(pf_data), .o_wb_sel(pf_sel), .i_wb_stall(pf_stall), .i_wb_ack(pf_ack), .i_wb_err(pf_err), .i_wb_data(i_wb_data) // }}} // }}} ); end else begin : PFCACHE",
            "assign pf_sel = {(BUS_WIDTH/8){1'b1}}; pfcache #( // {{{ .BUS_WIDTH(BUS_WIDTH), // .INSN_WIDTH(INSN_WIDTH), .LGCACHELEN(OPT_LGICACHE-WBLSB), // .OPT_LOWPOWER(OPT_LOWPOWER), (Unused) .ADDRESS_WIDTH(ADDRESS_WIDTH) // }}} ) pf( // {{{ .i_clk(i_clk), .i_reset(i_reset), // CPU signals .i_new_pc(pf_new_pc), .i_clear_cache(clear_icache), .i_ready(pf_ready && clk_gate), .i_pc(pf_request_address), .o_valid(pf_valid), .o_illegal(pf_illegal), .o_insn(pf_instruction), .o_pc(pf_instruction_pc), // Wishbone signals .o_wb_cyc(pf_cyc), .o_wb_stb(pf_stb), .o_wb_we(pf_we), .o_wb_addr(pf_addr), .o_wb_data(pf_data), .i_wb_stall(pf_stall), .i_wb_ack(pf_ack), .i_wb_err(pf_err), .i_wb_data(i_wb_data) // }}} ); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Memory Unit // {{{ //////////////////////////////////////////////////////////////////////// // generate if (OPT_DCACHE) begin : DATA_CACHE dcache #( // {{{ .LGCACHELEN(OPT_LGDCACHE-WBLSB), .ADDRESS_WIDTH(AW), .BUS_WIDTH(BUS_WIDTH), .LGNLINES(OPT_LGDCACHE-WBLSB-3), .OPT_LOCAL_BUS(WITH_LOCAL_BUS), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_PIPE(OPT_MEMPIPE), .OPT_LOCK(OPT_LOCK) `ifdef FORMAL , .OPT_FIFO_DEPTH(2) , .F_LGDEPTH(F_LGDEPTH) `endif // }}} ) mem( // {{{ .i_clk(cpu_clock), .i_reset(i_reset),.i_clear(clear_dcache), // CPU interface .i_pipe_stb(mem_ce), .i_lock(bus_lock && OPT_PIPELINED), .i_op(mem_op), .i_addr(mem_cpu_addr),.i_data(mem_wdata), .i_o",
            "reg (mem_",
            "reg ), .o_busy(mem_busy), .o_rdbusy(mem_rdbusy), .o_pipe_stalled(mem_pipe_stalled), .o_valid(mem_valid), .o_err(mem_bus_err), .o_w",
            "reg (mem_w",
            "reg ), .o_data(mem_result), // Wishbone interface .o_wb_cyc_gbl(mem_cyc_gbl), .o_wb_cyc_lcl(mem_cyc_lcl), .o_wb_stb_gbl(mem_stb_gbl), .o_wb_stb_lcl(mem_stb_lcl), .o_wb_we(mem_we), .o_wb_addr(mem_bus_addr), .o_wb_data(mem_data),.o_wb_sel(mem_sel), .i_wb_stall(mem_stall), .i_wb_ack(mem_ack), .i_wb_err(mem_err),.i_wb_data(i_wb_data) // }}} ); end else if (OPT_MEMPIPE) begin : PIPELINED_MEM pipemem #( // {{{ .ADDRESS_WIDTH(AW), .BUS_WIDTH(BUS_WIDTH), .OPT_LOCK(OPT_LOCK), // .OPT_LOWPOWER(OPT_LOWPOWER), (Unused) .WITH_LOCAL_BUS(WITH_LOCAL_BUS) `ifdef FORMAL , .OPT_MAXDEPTH(4'h3), .F_LGDEPTH(F_LGDEPTH) `endif // }}} ) domem( // {{{ .i_clk(cpu_clock), .i_reset(i_reset), // CPU interface .i_pipe_stb(mem_ce), .i_lock(bus_lock && OPT_PIPELINED), .i_op(mem_op), .i_addr(mem_cpu_addr), .i_data(mem_wdata), .i_o",
            "reg (mem_",
            "reg ), .o_busy(mem_busy), .o_rdbusy(mem_rdbusy), .o_pipe_stalled(mem_pipe_stalled), .o_valid(mem_valid), .o_err(mem_bus_err), .o_w",
            "reg (mem_w",
            "reg ), .o_result(mem_result), // Wishbone interface .o_wb_cyc_gbl(mem_cyc_gbl), .o_wb_cyc_lcl(mem_cyc_lcl), .o_wb_stb_gbl(mem_stb_gbl), .o_wb_stb_lcl(mem_stb_lcl), .o_wb_we(mem_we), .o_wb_addr(mem_bus_addr), .o_wb_data(mem_data),.o_wb_sel(mem_sel), .i_wb_stall(mem_stall), .i_wb_ack(mem_ack), .i_wb_err(mem_err),.i_wb_data(i_wb_data) // }}} ); end else begin : BARE_MEM memops #( // {{{ .ADDRESS_WIDTH(AW), .BUS_WIDTH(BUS_WIDTH), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_LOCK(OPT_LOCK), .WITH_LOCAL_BUS(WITH_LOCAL_BUS) `ifdef FORMAL , .F_LGDEPTH(F_LGDEPTH) `endif // F_LGDEPTH // }}} ) domem( // {{{ .i_clk(cpu_clock), .i_reset(i_reset), // CPU interface .i_stb(mem_ce), .i_lock(bus_lock && OPT_PIPELINED), .i_op(mem_op), .i_addr(mem_cpu_addr), .i_data(mem_wdata), .i_o",
            "reg (mem_",
            "reg ), .o_busy(mem_busy), .o_rdbusy(mem_rdbusy), .o_valid(mem_valid), .o_err(mem_bus_err), .o_w",
            "reg (mem_w",
            "reg ), .o_result(mem_result), // Wishbone interface .o_wb_cyc_gbl(mem_cyc_gbl), .o_wb_cyc_lcl(mem_cyc_lcl), .o_wb_stb_gbl(mem_stb_gbl), .o_wb_stb_lcl(mem_stb_lcl), .o_wb_we(mem_we), .o_wb_addr(mem_bus_addr), .o_wb_data(mem_data), .o_wb_sel(mem_sel), .i_wb_stall(mem_stall), .i_wb_ack(mem_ack), .i_wb_err(mem_err), .i_wb_data(i_wb_data) // }}} );",
            "assign mem_pipe_stalled = mem_busy; end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Bus arbiter // {{{ //////////////////////////////////////////////////////////////////////// // // Either the prefetch or the instruction gets the memory bus, but // never both under this arbitration scheme. generate if (OPT_PIPELINED) begin : PRIORITY_DATA wbdblpriarb #( // {{{ .AW(AW), .DW(BUS_WIDTH), .OPT_ZERO_ON_IDLE(OPT_LOWPOWER) // }}} ) pformem( // {{{ .i_clk(i_clk), .i_reset(i_reset), // Memory access to the arbiter, priority position .i_a_cyc_a(mem_cyc_gbl), .i_a_cyc_b(mem_cyc_lcl), .i_a_stb_a(mem_stb_gbl), .i_a_stb_b(mem_stb_lcl), .i_a_we(mem_we), .i_a_adr(mem_bus_addr), .i_a_dat(mem_data), .i_a_sel(mem_sel), .o_a_stall(mem_stall), .o_a_ack(mem_ack), .o_a_err(mem_err), // Prefetch access to the arbiter // // At a first glance, we might want something like: // // pf_cyc, 1'b0, pf_stb, 1'b0, pf_we, pf_addr, pf_data, 4'hf, // // However, we know that the prefetch will not generate // any writes. Therefore, the write specific lines // (mem_data) can be shared with the memory in order to // ease timing and LUT usage. This is not true of // mem_sel, which may be used to know which bytes we are // reading from. .i_b_cyc_a(pf_cyc), .i_b_cyc_b(1'b0), .i_b_stb_a(pf_stb), .i_b_stb_b(1'b0), .i_b_we(pf_we), .i_b_adr(pf_addr), .i_b_dat(mem_data), .i_b_sel(pf_sel), .o_b_stall(pf_stall), .o_b_ack(pf_ack), .o_b_err(pf_err), // Common",
            "wire s, in and out, of the arbiter .o_cyc_a(o_wb_gbl_cyc), .o_cyc_b(o_wb_lcl_cyc), .o_stb_a(o_wb_gbl_stb), .o_stb_b(o_wb_lcl_stb), .o_we(o_wb_we), .o_adr(o_wb_addr), .o_dat(o_wb_data), .o_sel(o_wb_sel), .i_stall(i_wb_stall), .i_ack(i_wb_ack), .i_err(i_wb_err) // }}} ); end else begin : PRIORITY_PREFETCH wbdblpriarb #( // {{{ .DW(BUS_WIDTH), .AW(AW), .OPT_ZERO_ON_IDLE(OPT_LOWPOWER) // }}} ) pformem( // {{{ .i_clk(i_clk), .i_reset(i_reset), // Prefetch access to the arbiter, priority position // .i_a_cyc_a(pf_cyc), .i_a_cyc_b(1'b0), .i_a_stb_a(pf_stb), .i_a_stb_b(1'b0), .i_a_we(pf_we), .i_a_adr(pf_addr), .i_a_dat(mem_data), .i_a_sel(pf_sel), .o_a_stall(pf_stall), .o_a_ack(pf_ack), .o_a_err(pf_err), // Memory access to the arbiter .i_b_cyc_a(mem_cyc_gbl), .i_b_cyc_b(mem_cyc_lcl), .i_b_stb_a(mem_stb_gbl),.i_b_stb_b(mem_stb_lcl), .i_b_we(mem_we), .i_b_adr(mem_bus_addr), .i_b_dat(mem_data), .i_b_sel(mem_sel), .o_b_stall(mem_stall), .o_b_ack(mem_ack), .o_b_err(mem_err), // Common",
            "wire s, in and out, of the arbiter .o_cyc_a(o_wb_gbl_cyc), .o_cyc_b(o_wb_lcl_cyc), .o_stb_a(o_wb_gbl_stb), .o_stb_b(o_wb_lcl_stb), .o_we(o_wb_we), .o_adr(o_wb_addr), .o_dat(o_wb_data), .o_sel(o_wb_sel), .i_stall(i_wb_stall), .i_ack(i_wb_ack), .i_err(i_wb_err) // }}} ); end endgenerate //}}} //////////////////////////////////////////////////////////////////////// // // (Optional) Clock Gate // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_CLKGATE) begin : GATE_CPU_CLOCK // {{{",
            "reg gatep;",
            "reg gaten /* verilator clock_enable */;",
            "initial gatep = 1'b1;",
            "always @(posedge i_clk) if (i_reset) gatep <= 1'b1; else gatep <= cpu_clken || i_dbg_we || i_cpu_clken;",
            "initial gaten = 1'b1;",
            "always @(negedge i_clk) if (i_reset) gaten <= 1'b1; else gaten <= gatep;",
            "assign cpu_clock = i_clk && gaten;",
            "assign clk_gate = gatep; // }}} end else begin : NO_CLOCK_GATE",
            "assign cpu_clock = i_clk;",
            "assign clk_gate = 1'b1; // Verilattor lint_off UNUSED",
            "wire unused_clk;",
            "assign unused_clk = &{ 1'b0, i_cpu_clken, cpu_clken }; // Verilator lint_on UNUSED end endgenerate // }}} // Make Verilator happy // {{{ // verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, pf_data, mem_lock_pc, clear_dcache }; // Verilator lint_on UNUSED // verilator coverage_on // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "axipipe.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axipipe.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: axipipe.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A memory unit to support a CPU based upon AXI-lite. Unlike the // axilops core, this one will permit multiple requests to be // outstanding at any given time. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2020-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module axipipe #( // {{{",
            "parameter C_AXI_ADDR_WIDTH = 30, parameter C_AXI_DATA_WIDTH = 32, parameter C_AXI_ID_WIDTH = 1, parameter [((C_AXI_ID_WIDTH>0)? C_AXI_ID_WIDTH:1)-1:0] AXI_ID = 0, localparam AW = C_AXI_ADDR_WIDTH, localparam DW = C_AXI_DATA_WIDTH, localparam IW =(C_AXI_ID_WIDTH > 0) ? C_AXI_ID_WIDTH : 1, // // parameter [0:0] SWAP_ENDIANNESS = 1'b0, parameter [0:0] SWAP_WSTRB = 1'b0, parameter [0:0] OPT_SIGN_EXTEND = 1'b0, // AXI locks are a challenge, and require support from the // CPU. Specifically, we have to be able to unroll and re-do // the load instruction on any atomic access failure. For that // reason, we'll ignore the lock request",
            "initial ly.",
            "parameter [0:0] OPT_LOCK=1'b1, parameter [0:0] OPT_ALIGNMENT_ERR = 1'b0, parameter [0:0] OPT_LOWPOWER = 1'b1, parameter [3:0] OPT_QOS = 0 // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, input wire i_cpu_reset, // // CPU interface // {{{",
            "input wire i_stb, input wire i_lock, input wire [2:0] i_op, input wire [AW-1:0] i_addr, input wire [AW-1:0] i_restart_pc, input wire [31:0] i_data, input wire [4:0] i_o",
            "reg , output reg o_busy, output reg o_pipe_stalled, output reg o_rdbusy, output reg o_valid, output reg o_err, output reg [4:0] o_w",
            "reg , output reg [31:0] o_result, // }}} // // AXI4 bus interface // {{{ // Writes // {{{",
            "output reg M_AXI_AWVALID, input wire M_AXI_AWREADY, // verilator coverage_off",
            "output wire [IW-1:0] M_AXI_AWID, // verilator coverage_on",
            "output reg [AW-1:0] M_AXI_AWADDR, // verilator coverage_off",
            "output wire [7:0] M_AXI_AWLEN, // == 0 // verilator coverage_on",
            "output wire [2:0] M_AXI_AWSIZE, output wire [1:0] M_AXI_AWBURST, output wire M_AXI_AWLOCK, output wire [3:0] M_AXI_AWCACHE, // verilator coverage_off",
            "output wire [2:0] M_AXI_AWPROT, output wire [3:0] M_AXI_AWQOS, // verilator coverage_on // output reg M_AXI_WVALID, input wire M_AXI_WREADY, output reg [DW-1:0] M_AXI_WDATA, output reg [DW/8-1:0] M_AXI_WSTRB, output wire M_AXI_WLAST, // input wire M_AXI_BVALID, // verilator coverage_off",
            "input wire [IW-1:0] M_AXI_BID, // verilator coverage_on",
            "output wire M_AXI_BREADY, input wire [1:0] M_AXI_BRESP, // }}} // Reads // {{{",
            "output reg M_AXI_ARVALID, input wire M_AXI_ARREADY, // verilator coverage_off",
            "output wire [IW-1:0] M_AXI_ARID, // verilator coverage_on",
            "output reg [AW-1:0] M_AXI_ARADDR, // verilator coverage_off",
            "output wire [7:0] M_AXI_ARLEN, // == 0 // verilator coverage_on",
            "output wire [2:0] M_AXI_ARSIZE, output wire [1:0] M_AXI_ARBURST, output wire M_AXI_ARLOCK, output wire [3:0] M_AXI_ARCACHE, // verilator coverage_off",
            "output wire [2:0] M_AXI_ARPROT, output wire [3:0] M_AXI_ARQOS, // verilator coverage_on // input wire M_AXI_RVALID, output wire M_AXI_RREADY, // verilator coverage_off",
            "input wire [IW-1:0] M_AXI_RID, // verilator coverage_on",
            "input wire [DW-1:0] M_AXI_RDATA, input wire M_AXI_RLAST, input wire [1:0] M_AXI_RRESP // }}} // }}} // }}} ); // Declarations // {{{",
            "localparam AXILSB = $clog2(C_AXI_DATA_WIDTH/8);",
            "localparam [2:0] DSZ = AXILSB[2:0];",
            "localparam LGPIPE = 4;",
            "localparam FIFO_WIDTH = AXILSB+1+2+4 + 1;",
            "localparam [1:0] AXI_INCR = 2'b01, OKAY = 2'b00, EXOKAY = 2'b01; // SLVERR // DECERR",
            "wire i_clk = S_AXI_ACLK;",
            "reg w_misaligned;",
            "wire misaligned_request, misaligned_aw_request, pending_err;",
            "reg w_misalignment_err;",
            "reg [C_AXI_DATA_WIDTH-1:0] next_wdata;",
            "reg [C_AXI_DATA_WIDTH/8-1:0] next_wstrb;",
            "reg [AW-1:0] r_pc;",
            "reg r_lock;",
            "reg [2:0] axi_size;",
            "reg none_outstanding, bus_abort, read_abort, write_abort;",
            "reg [LGPIPE:0] beats_outstanding;",
            "reg r_flushing, flush_request, r_pipe_stalled;",
            "reg [LGPIPE:0] flushcount, new_flushcount;",
            "reg [LGPIPE:0] wraddr, rdaddr;",
            "reg [3:0] ar_o",
            "reg ;",
            "reg [1:0] ar_op;",
            "reg [AXILSB-1:0] adr_lsb;",
            "reg [FIFO_WIDTH-1:0] fifo_data [0:((1<<LGPIPE)-1)];",
            "reg [FIFO_WIDTH-1:0] fifo_read_data;",
            "wire fifo_read_op, fifo_misaligned;",
            "reg fifo_gie;",
            "wire [1:0] fifo_op;",
            "wire [3:0] fifo_return_",
            "reg ;",
            "wire [AXILSB-1:0] fifo_lsb;",
            "reg [2*C_AXI_DATA_WIDTH-1:0] wide_return, wide_wdata;",
            "reg [31:0] pre_result;",
            "reg [2*C_AXI_DATA_WIDTH/8-1:0] wide_wstrb;",
            "reg [C_AXI_DATA_WIDTH-1:0] misdata; // }}} //////////////////////////////////////////////////////////////////////// // // Transaction issue // {{{ //////////////////////////////////////////////////////////////////////// // // // AWVALID // {{{",
            "initial M_AXI_AWVALID = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) M_AXI_AWVALID <= 0; else if (!M_AXI_AWVALID || M_AXI_AWREADY) begin if (i_stb && i_op[0]) M_AXI_AWVALID <= !w_misalignment_err; else M_AXI_AWVALID <= M_AXI_AWVALID && misaligned_aw_request; if (write_abort && !misaligned_aw_request) M_AXI_AWVALID <= 0; end // }}} // WVALID // {{{",
            "initial M_AXI_WVALID = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) M_AXI_WVALID <= 0; else if (!M_AXI_WVALID || M_AXI_WREADY) begin if (i_stb && i_op[0]) M_AXI_WVALID <= !w_misalignment_err; else M_AXI_WVALID <= M_AXI_WVALID && misaligned_request; if (write_abort && !misaligned_request) M_AXI_WVALID <= 0; end // }}} // ARVALID // {{{",
            "initial M_AXI_ARVALID = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) M_AXI_ARVALID <= 0; else if (!M_AXI_ARVALID || M_AXI_ARREADY) begin if (i_stb && !i_op[0]) M_AXI_ARVALID <= !w_misalignment_err; else M_AXI_ARVALID <= M_AXI_ARVALID && misaligned_request; if (read_abort && !misaligned_request) M_AXI_ARVALID <= 0; end // }}} // r_lock, M_AXI_AxLOCK // {{{",
            "initial r_lock = 1'b0;",
            "always @(posedge i_clk) if (!OPT_LOCK || !S_AXI_ARESETN) r_lock <= 1'b0; else if ((!M_AXI_ARVALID || M_AXI_ARREADY) &&(!M_AXI_AWVALID || M_AXI_AWREADY)) begin if (!M_AXI_AWVALID && !M_AXI_ARVALID && !M_AXI_WVALID && beats_outstanding <= ((M_AXI_RVALID||M_AXI_BVALID)? 1:0)) r_lock <= 1'b0; if (i_stb) r_lock <= i_lock && !w_misalignment_err; if (i_cpu_reset || r_flushing) r_lock <= 1'b0; end",
            "assign M_AXI_AWLOCK = r_lock;",
            "assign M_AXI_ARLOCK = r_lock; // }}} // axi_size, M_AXI_AxSIZE // {{{",
            "initial axi_size = DSZ;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_size <= DSZ; else if (i_stb) begin if (SWAP_WSTRB) axi_size <= AXILSB[2:0]; else begin casez(i_op[2:1]) 2'b0?: begin axi_size <= 3'b010; if ((|i_addr[1:0]) && !w_misaligned) axi_size <= AXILSB[2:0]; end 2'b10: begin axi_size <= 3'b001; if (i_addr[0] && !w_misaligned) axi_size <= AXILSB[2:0]; end 2'b11: axi_size <= 3'b000; // default: begin end endcase end end",
            "assign M_AXI_AWSIZE = axi_size;",
            "assign M_AXI_ARSIZE = axi_size; // }}} // o_busy, // {{{ // True if the bus is busy doing ... something, whatever it might be. // If the bus is busy, the CPU will avoid issuing further interactions // to the bus other than pipelined interactions.",
            "initial o_busy = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) o_busy <= 0; else if (i_stb && !w_misalignment_err && !bus_abort) o_busy <= 1; else if (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) o_busy <= 1; else if (beats_outstanding > ((M_AXI_RVALID || M_AXI_BVALID) ? 1:0)) o_busy <= 1; else o_busy <= 0; `ifdef FORMAL",
            "always @(*) assert(o_busy == (!none_outstanding || M_AXI_ARVALID || M_AXI_AWVALID || M_AXI_WVALID)); `endif // }}} // Read busy // {{{ // True if the CPU should expect some kind of pending response from a // read, and so should stall for that purpose. False otherwise.",
            "initial o_rdbusy = 0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset || r_flushing) o_rdbusy <= 0; else if ((i_stb && w_misalignment_err) || bus_abort) o_rdbusy <= 0; else if (i_stb && (!i_op[0] || (OPT_LOCK && i_lock))) o_rdbusy <= 1; else if (OPT_LOCK) begin if (M_AXI_AWVALID || M_AXI_ARVALID || M_AXI_WVALID) o_rdbusy <= o_rdbusy; else if (o_rdbusy) o_rdbusy <= (beats_outstanding > ((M_AXI_RVALID||M_AXI_BVALID) ? 1:0)); end else if (o_rdbusy && !M_AXI_ARVALID) o_rdbusy <= (beats_outstanding > (M_AXI_RVALID ? 1:0)); `ifdef FORMAL",
            "reg writing;",
            "always @(posedge S_AXI_ACLK) if (i_stb && !o_busy) writing <= i_op[0];",
            "always @(*) if (r_flushing) begin assert(!o_rdbusy); end else begin if (writing && r_lock && (M_AXI_AWVALID || M_AXI_WVALID || (beats_outstanding > 0))) begin assert(o_rdbusy); end else if (writing) begin assert(!o_rdbusy); end if (!o_busy) assert(!o_rdbusy); end `endif // }}} // o_pipe_stalled, r_pipe_stalled // {{{ // True if the CPU should expect some kind of pending response from a // read, and so should stall for that purpose. False otherwise. generate if (OPT_ALIGNMENT_ERR) begin : FULL_PIPE_STALL // {{{ // Here, we stall if the FIFO is ever full. In this case, // any new beat will count as only one item to the FIFO, and // so we can run all the way to full.",
            "reg [LGPIPE:0] beats_committed;",
            "always @(*) beats_committed = beats_outstanding + ((i_stb && !w_misalignment_err) ? 1:0) + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0);",
            "initial r_pipe_stalled = 0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset) r_pipe_stalled <= 0; else if (M_AXI_RVALID || M_AXI_BVALID) r_pipe_stalled <= 0; else if (i_stb && i_lock && !w_misalignment_err) r_pipe_stalled <= 1; else if (OPT_LOCK && r_lock) r_pipe_stalled <= (beats_committed > 0); else r_pipe_stalled <= (beats_committed >= (1<<LGPIPE)); `ifdef FORMAL",
            "always @(*) if (r_flushing) begin assert(o_pipe_stalled); end else if (beats_outstanding + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0) >= (1<<LGPIPE)) begin assert(r_pipe_stalled); end else if (beats_outstanding + (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) < (1<<LGPIPE)-1) assert(r_lock || !r_pipe_stalled);",
            "always @(*) if (r_lock && !r_flushing) begin if (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) begin assert(r_pipe_stalled); end else if (beats_outstanding >= 1) begin assert(r_pipe_stalled); end else assert(!r_pipe_stalled && !OPT_LOWPOWER); end `endif // }}} end else begin : PENULTIMATE_FULL_STALL // {{{ // If we allow for misaligned reads and writes, than we have // to stall the CPU just before the FIFO is full, lest the // CPU send us a value that needs two items to be placed into // the FIO.",
            "reg [LGPIPE:0] beats_committed;",
            "always @(*) begin beats_committed = beats_outstanding + (i_stb ? 1:0) + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0) - ((M_AXI_BVALID || M_AXI_RVALID) ? 1:0); end",
            "initial r_pipe_stalled = 0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset || bus_abort) r_pipe_stalled <= 0; else begin r_pipe_stalled <= 0; if (r_lock && (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID)) r_pipe_stalled <= 1; if (r_lock && (beats_outstanding > ((M_AXI_RVALID || M_AXI_BVALID) ? 1:0))) r_pipe_stalled <= 1; if (i_stb && (w_misaligned && !w_misalignment_err) && !o_pipe_stalled) r_pipe_stalled <= 1'b1; if (misaligned_request && (M_AXI_WVALID && !M_AXI_WREADY)) r_pipe_stalled <= 1'b1; if (misaligned_request && (M_AXI_ARVALID && !M_AXI_ARREADY)) r_pipe_stalled <= 1'b1; if (misaligned_aw_request && (M_AXI_AWVALID && !M_AXI_AWREADY)) r_pipe_stalled <= 1'b1; if (beats_committed >= (1<<LGPIPE)-2) r_pipe_stalled <= 1'b1; if (i_stb && i_lock && !w_misalignment_err) r_pipe_stalled <= 1'b1; end `ifdef FORMAL",
            "always @(*) if (!r_flushing && (beats_outstanding + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0) + ((misaligned_aw_request || misaligned_request) ? 1:0) >= (1<<LGPIPE))) begin assert(r_pipe_stalled); end else if (r_lock && !r_flushing) begin assert(r_pipe_stalled == o_busy); end else if (!r_flushing && !o_err && !M_AXI_AWVALID && !M_AXI_WVALID && !M_AXI_ARVALID && beats_outstanding <= ((1<<LGPIPE)-4)) assert(!r_pipe_stalled);",
            "always @(*) assert(beats_committed + ((i_stb && w_misaligned && !r_pipe_stalled) ? 1:0) <= (1<<LGPIPE)); `endif // }}} end endgenerate",
            "always @(*) begin o_pipe_stalled = r_pipe_stalled || r_flushing; // if (r_lock && o_busy) o_pipe_stalled = 1; if (M_AXI_AWVALID && (!M_AXI_AWREADY || misaligned_aw_request)) o_pipe_stalled = 1; if (M_AXI_WVALID && (!M_AXI_WREADY || misaligned_request)) o_pipe_stalled = 1; if (M_AXI_ARVALID && (!M_AXI_ARREADY || misaligned_request)) o_pipe_stalled = 1; end `ifdef FORMAL",
            "always @(*) if (misaligned_request) assert(M_AXI_WVALID || M_AXI_ARVALID);",
            "always @(*) if (misaligned_aw_request) assert(M_AXI_AWVALID);",
            "always @(*) if (r_lock && o_busy) assert(o_pipe_stalled); `endif // }}} // Count the number of outstanding beats // {{{ // This is the true count. It is not affected by the number of // items the CPU believes is on the bus or not.",
            "initial beats_outstanding = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) beats_outstanding <= 0; else casez({M_AXI_AWVALID && M_AXI_AWREADY, M_AXI_WVALID && M_AXI_WREADY, M_AXI_ARVALID && M_AXI_ARREADY, M_AXI_RVALID || M_AXI_BVALID}) 4'b0001: beats_outstanding <= beats_outstanding - 1; 4'b??10: beats_outstanding <= beats_outstanding + 1; 4'b1100: beats_outstanding <= beats_outstanding + 1; 4'b1000: if (!M_AXI_WVALID || (misaligned_aw_request && !misaligned_request)) beats_outstanding <= beats_outstanding + 1; 4'b0100: if (!M_AXI_AWVALID || (misaligned_request && !misaligned_aw_request)) beats_outstanding <= beats_outstanding + 1; 4'b10?1: if ((M_AXI_WVALID && (OPT_ALIGNMENT_ERR || (misaligned_request == misaligned_aw_request))) || (!misaligned_aw_request && misaligned_request)) beats_outstanding <= beats_outstanding - 1; 4'b0101: if ((M_AXI_AWVALID && (OPT_ALIGNMENT_ERR || (misaligned_request == misaligned_aw_request))) || (!misaligned_request && misaligned_aw_request)) beats_outstanding <= beats_outstanding - 1; default: begin end endcase",
            "initial none_outstanding = 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) none_outstanding <= 1; else casez({M_AXI_AWVALID && M_AXI_AWREADY, M_AXI_WVALID && M_AXI_WREADY, M_AXI_ARVALID && M_AXI_ARREADY, M_AXI_RVALID || M_AXI_BVALID}) 4'b0001: none_outstanding <= (beats_outstanding <= 1); 4'b??10: none_outstanding <= 0; 4'b1100: none_outstanding <= 0; 4'b1000: if (!M_AXI_WVALID || (misaligned_aw_request && !misaligned_request)) none_outstanding <= 0; 4'b0100: if (!M_AXI_AWVALID || (misaligned_request && !misaligned_aw_request)) none_outstanding <= 0; 4'b10?1: if ((M_AXI_WVALID && (OPT_ALIGNMENT_ERR || (misaligned_request == misaligned_aw_request))) || (!misaligned_aw_request && misaligned_request)) none_outstanding <= (beats_outstanding <= 1); 4'b0101: if ((M_AXI_AWVALID && (OPT_ALIGNMENT_ERR || (misaligned_request == misaligned_aw_request))) || (!misaligned_request && misaligned_aw_request)) none_outstanding <= (beats_outstanding <= 1); default: begin end endcase `ifdef FORMAL",
            "always @(*) assert(none_outstanding == (beats_outstanding == 0)); `endif // }}} // bus_abort // {{{ // When do we abandon everything and start aborting bus transactions?",
            "always @(*) begin bus_abort = 0; if (i_cpu_reset || o_err) bus_abort = 1; if (M_AXI_BVALID && M_AXI_BRESP[1]) bus_abort = 1; if (M_AXI_RVALID && M_AXI_RRESP[1]) bus_abort = 1; write_abort = 0; if (i_cpu_reset || o_err) write_abort = 1; if (M_AXI_BVALID && M_AXI_BRESP[1]) write_abort = 1; read_abort = 0; if (i_cpu_reset || o_err) read_abort = 1; if (M_AXI_RVALID && M_AXI_RRESP[1]) read_abort = 1; end // }}} // Flushing // {{{ // new_flushcount // {{{",
            "always @(*) begin case({((M_AXI_AWVALID || M_AXI_WVALID) || M_AXI_ARVALID), (M_AXI_BVALID || M_AXI_RVALID) }) 2'b01: new_flushcount = beats_outstanding - 1; 2'b10: new_flushcount = beats_outstanding + 1; default: new_flushcount = beats_outstanding; endcase if (!OPT_ALIGNMENT_ERR && (misaligned_request || misaligned_aw_request)) new_flushcount = new_flushcount + 1; end // }}}",
            "initial r_flushing = 1'b0;",
            "initial flushcount = 0;",
            "initial flush_request = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) begin // {{{ r_flushing <= 1'b0; flush_request <= 0; flushcount <= 0; // }}} end else if (i_cpu_reset || bus_abort || (i_stb && w_misalignment_err)) begin // {{{ r_flushing <= (new_flushcount != 0); flushcount <= new_flushcount; flush_request <= (M_AXI_ARVALID && (!M_AXI_ARREADY || misaligned_request)) || (M_AXI_AWVALID && (!M_AXI_AWREADY || misaligned_aw_request)) || (M_AXI_WVALID && (!M_AXI_WREADY || misaligned_request)); // }}} end else if (r_flushing) begin // {{{ if (M_AXI_BVALID || M_AXI_RVALID) begin flushcount <= flushcount - 1; r_flushing <= (flushcount > 1); end casez({M_AXI_AWVALID && (M_AXI_AWREADY && !misaligned_aw_request), (M_AXI_WVALID && M_AXI_WREADY && !misaligned_request), (M_AXI_ARVALID && M_AXI_ARREADY && !misaligned_request) }) 3'b001: flush_request <= 0; 3'b10?: flush_request <= M_AXI_WVALID; 3'b01?: flush_request <= M_AXI_AWVALID; 3'b11?: flush_request <= 0; default: begin end endcase // }}} end `ifdef FORMAL",
            "always @(*) begin assert(r_flushing == (flushcount > 0)); if (!r_flushing) begin assert(!flush_request); end else assert(flush_request == (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID)); if (r_flushing && !flush_request) begin assert(!misaligned_request); assert(!misaligned_aw_request); end if (flush_request) begin assert(flushcount == beats_outstanding + 1 + ((misaligned_request || misaligned_aw_request) ? 1:0)); // else if (faxil_rd_outstanding > 0 || M_AXI_ARVALID) end else if (r_flushing) begin assert(beats_outstanding == flushcount); end else assert(beats_outstanding >= flushcount); end `endif // }}} // Bus addressing // {{{",
            "initial M_AXI_AWADDR = 0;",
            "always @(posedge i_clk) if (i_stb) begin M_AXI_AWADDR <= i_addr[AW-1:0]; if (SWAP_WSTRB) M_AXI_AWADDR[AXILSB-1:0] <= 0; end else if (!OPT_ALIGNMENT_ERR && ((M_AXI_AWVALID && M_AXI_AWREADY) // && misaligned_aw_request || (M_AXI_ARVALID && M_AXI_ARREADY))) // && misaligned_request)) begin M_AXI_AWADDR[AW-1:AXILSB] <= M_AXI_AWADDR[AW-1:AXILSB] + 1; M_AXI_AWADDR[AXILSB-1:0] <= 0; end",
            "always @(*) M_AXI_ARADDR = M_AXI_AWADDR; // }}} // Is this request misaligned? // {{{",
            "always @(*) casez(i_op[2:1]) // Full word 2'b0?: w_misaligned = (i_addr[AXILSB-1:0]+3) >= (1<<AXILSB); // Half word 2'b10: w_misaligned = (i_addr[AXILSB-1:0]+1) >= (1<<AXILSB); // Bytes are",
            "always aligned 2'b11: w_misaligned = 1'b0; endcase",
            "always @(*) begin w_misalignment_err = w_misaligned && OPT_ALIGNMENT_ERR; if (OPT_LOCK && i_lock) begin casez(i_op[2:1]) 2'b0?: w_misalignment_err = (|i_addr[1:0]); 2'b10: w_misalignment_err = i_addr[0]; default: w_misalignment_err = 1'b0; endcase end end // }}} // wide_wdata, wide_wstrb // {{{",
            "always @(*) if (SWAP_WSTRB) begin : BACKWARDS_ORDER // {{{ casez(i_op[2:1]) 2'b10: wide_wdata = { i_data[15:0], {(2*C_AXI_DATA_WIDTH-16){1'b0}} } >> (i_addr[AXILSB-1:0] * 8); 2'b11: wide_wdata = { i_data[7:0], {(2*C_AXI_DATA_WIDTH-8){1'b0}} } >> (i_addr[AXILSB-1:0] * 8); default: wide_wdata = ({ i_data, {(2*C_AXI_DATA_WIDTH-32){ 1'b0 }} } >> (i_addr[AXILSB-1:0] * 8)); endcase casez(i_op[2:1]) 2'b0?: wide_wstrb = { 4'b1111, {(2*C_AXI_DATA_WIDTH/8-4){1'b0}} } >> i_addr[AXILSB-1:0]; 2'b10: wide_wstrb = { 2'b11, {(2*C_AXI_DATA_WIDTH/8-2){1'b0}} } >> i_addr[AXILSB-1:0]; 2'b11: wide_wstrb = { 1'b1, {(2*C_AXI_DATA_WIDTH/8-1){1'b0}} } >> i_addr[AXILSB-1:0]; endcase // }}} end else begin : LITTLE_ENDIAN_DATA // {{{ casez(i_op[2:1]) 2'b10: wide_wdata = { {(2*C_AXI_DATA_WIDTH-16){1'b0}}, i_data[15:0] } << (8*i_addr[AXILSB-1:0]); 2'b11: wide_wdata = { {(2*C_AXI_DATA_WIDTH-8){1'b0}}, i_data[7:0] } << (8*i_addr[AXILSB-1:0]); default: wide_wdata = { {(2*C_AXI_DATA_WIDTH-32){1'b0}}, i_data } << (8*i_addr[AXILSB-1:0]); endcase casez(i_op[2:1]) 2'b0?: wide_wstrb = { {(2*C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b1111} << i_addr[AXILSB-1:0]; 2'b10: wide_wstrb = { {(2*C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b0011} << i_addr[AXILSB-1:0]; 2'b11: wide_wstrb = { {(2*C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b0001} << i_addr[AXILSB-1:0]; endcase // }}} end // }}} // WDATA and WSTRB // {{{",
            "initial M_AXI_WDATA = 0;",
            "initial M_AXI_WSTRB = 0;",
            "initial next_wdata = 0;",
            "initial next_wstrb = 0;",
            "always @(posedge i_clk) if (i_stb) begin if (SWAP_WSTRB) begin : BACKWARDS_ORDER_REG // {{{ { M_AXI_WDATA, next_wdata } <= wide_wdata; { M_AXI_WSTRB, next_wstrb } <= wide_wstrb; // }}} end else begin // {{{ { next_wdata, M_AXI_WDATA } <= wide_wdata; { next_wstrb, M_AXI_WSTRB } <= wide_wstrb; // }}} end if (OPT_ALIGNMENT_ERR) { next_wstrb, next_wdata } <= 0; end else if ((OPT_LOWPOWER || !OPT_ALIGNMENT_ERR) && M_AXI_WREADY) begin M_AXI_WDATA <= next_wdata; M_AXI_WSTRB <= next_wstrb; if (OPT_LOWPOWER) { next_wdata, next_wstrb } <= 0; end // }}} generate if (OPT_ALIGNMENT_ERR) begin : GEN_ALIGNMENT_ERR // {{{ // Generate an error on any misaligned request",
            "assign misaligned_request = 1'b0;",
            "assign misaligned_aw_request = 1'b0;",
            "assign pending_err = 1'b0; // }}} end else begin : GEN_REALIGNMENT // {{{",
            "reg r_misaligned_request, r_misaligned_aw_request, r_pending_err; // misaligned_request // {{{",
            "initial r_misaligned_request = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) r_misaligned_request <= 0; else if (i_stb && !o_err && !i_cpu_reset && !bus_abort) r_misaligned_request <= w_misaligned && !w_misalignment_err; else if ((M_AXI_WVALID && M_AXI_WREADY) || (M_AXI_ARVALID && M_AXI_ARREADY)) r_misaligned_request <= 1'b0;",
            "assign misaligned_request = r_misaligned_request; // }}} // misaligned_aw_request // {{{",
            "initial r_misaligned_aw_request = 0;",
            "always @(posedge i_clk) if (!S_AXI_ARESETN) r_misaligned_aw_request <= 0; else if (i_stb && !o_err && !i_cpu_reset && !write_abort) r_misaligned_aw_request <= w_misaligned && i_op[0] && !w_misalignment_err; else if (M_AXI_AWREADY) r_misaligned_aw_request <= 1'b0;",
            "assign misaligned_aw_request = r_misaligned_aw_request; // }}} // pending_err // {{{",
            "initial r_pending_err = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || i_stb || o_err || r_flushing) r_pending_err <= 1'b0; else if ((M_AXI_BVALID && M_AXI_BRESP[1]) || (M_AXI_RVALID && M_AXI_RRESP[1])) r_pending_err <= 1'b1;",
            "assign pending_err = r_pending_err; // }}} `ifdef FORMAL",
            "always @(*) if (pending_err) assert(r_flushing || o_err); `endif // }}} end endgenerate // AxOTHER // {{{",
            "localparam [3:0] AXI_NON_CACHABLE_BUFFERABLE = 4'h3;",
            "localparam [3:0] OPT_CACHE = AXI_NON_CACHABLE_BUFFERABLE;",
            "localparam [2:0] AXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS = 3'h0;",
            "localparam [2:0] OPT_PROT=AXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS;",
            "assign M_AXI_AWID = AXI_ID;",
            "assign M_AXI_AWLEN = 0;",
            "assign M_AXI_AWBURST = AXI_INCR;",
            "assign M_AXI_AWCACHE = M_AXI_AWLOCK ? 0:OPT_CACHE;",
            "assign M_AXI_AWPROT = OPT_PROT;",
            "assign M_AXI_AWQOS = OPT_QOS;",
            "assign M_AXI_WLAST = 1;",
            "assign M_AXI_ARID = AXI_ID;",
            "assign M_AXI_ARLEN = 0;",
            "assign M_AXI_ARBURST = AXI_INCR;",
            "assign M_AXI_ARCACHE = M_AXI_ARLOCK ? 0:OPT_CACHE;",
            "assign M_AXI_ARPROT = OPT_PROT;",
            "assign M_AXI_ARQOS = OPT_QOS; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Read transaction FIFO // {{{ //////////////////////////////////////////////////////////////////////// // // // wraddr // {{{",
            "initial wraddr = 0;",
            "always @(posedge S_AXI_ACLK) if (bus_abort || flush_request) // bus_abort includes i_cpu_reset wraddr <= 0; else if ((M_AXI_ARVALID && M_AXI_ARREADY) || (M_AXI_WVALID && M_AXI_WREADY)) wraddr <= wraddr + 1; // }}} // rdaddr // {{{",
            "initial rdaddr = 0;",
            "always @(posedge S_AXI_ACLK) if (bus_abort || r_flushing) rdaddr <= 0; else if (M_AXI_RVALID||M_AXI_BVALID) rdaddr <= rdaddr + 1; // }}} // ar_o",
            "reg , ar_op, adr_lsb // {{{",
            "always @(posedge S_AXI_ACLK) if (i_stb) { fifo_gie, ar_o",
            "reg , ar_op, adr_lsb } <= { i_o",
            "reg , i_op[2:1], i_addr[AXILSB-1:0] }; else if ((M_AXI_ARVALID && M_AXI_ARREADY)||(M_AXI_WVALID && M_AXI_WREADY)) adr_lsb <= 0; // }}} // fifo_data // {{{",
            "always @(posedge S_AXI_ACLK) if ((M_AXI_ARVALID && M_AXI_ARREADY) || (M_AXI_WVALID && M_AXI_WREADY)) fifo_data[wraddr[LGPIPE-1:0]] <= { M_AXI_ARVALID, ar_o",
            "reg ,ar_op, misaligned_request, adr_lsb };",
            "always @(*) fifo_read_data = fifo_data[rdaddr[LGPIPE-1:0]];",
            "assign { fifo_read_op, fifo_return_",
            "reg , fifo_op, fifo_misaligned, fifo_lsb } = fifo_read_data; // }}} // r_pc // {{{",
            "always @(posedge S_AXI_ACLK) if (!OPT_LOCK) r_pc <= 0; else if (i_stb && i_lock && !i_op[0]) r_pc <= i_restart_pc; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Read return generation // {{{ //////////////////////////////////////////////////////////////////////// // // // o_valid // {{{",
            "initial o_valid = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || r_flushing) o_valid <= 1'b0; else if (OPT_LOCK && r_lock) o_valid <= (M_AXI_RVALID && M_AXI_RRESP == EXOKAY) ||(M_AXI_BVALID && M_AXI_BRESP == OKAY); else if (OPT_ALIGNMENT_ERR && i_stb && w_misaligned) o_valid <= 1'b0; else o_valid <= M_AXI_RVALID && !M_AXI_RRESP[1] // && !pending_err && !fifo_misaligned; // }}} // o_w",
            "reg // {{{",
            "always @(posedge i_clk) begin o_w",
            "reg <= { fifo_gie, fifo_return_",
            "reg }; if (OPT_LOCK && r_lock && M_AXI_BVALID) o_w",
            "reg [3:0] <= 4'hf; end // }}} // o_result, misdata // {{{ // Need to realign any returning data // wide_return // {{{",
            "always @(*) begin if (SWAP_WSTRB) begin if (fifo_misaligned && !OPT_ALIGNMENT_ERR) wide_return = { misdata, M_AXI_RDATA } << (8*fifo_lsb); else wide_return = { M_AXI_RDATA, {(DW){1'b0}} } << (8*fifo_lsb); end else begin if (fifo_misaligned && !OPT_ALIGNMENT_ERR) wide_return = { M_AXI_RDATA, misdata } >> (8*fifo_lsb); else wide_return = { {(C_AXI_DATA_WIDTH){1'b0}}, M_AXI_RDATA } >> (8*fifo_lsb); end if (OPT_LOWPOWER && (!M_AXI_RVALID || M_AXI_RRESP[1])) wide_return = 0; end",
            "always @(*) begin if (SWAP_WSTRB) begin pre_result = 32'h0; casez(fifo_op) 2'b10: pre_result[15:0] = { wide_return[(2*DW)-1:(2*DW)-16] }; 2'b11: pre_result[7:0] = { wide_return[(2*DW)-1:(2*DW)-8] }; default: pre_result[31:0] = wide_return[(2*DW-1):(2*DW-32)]; endcase end else pre_result = wide_return[31:0]; end // }}} // misdata // {{{",
            "always @(posedge i_clk) if (OPT_ALIGNMENT_ERR) misdata <= 0; else if (M_AXI_RVALID) begin if (fifo_misaligned) misdata <= M_AXI_RDATA; else misdata <= 0; end // }}} // o_result // {{{",
            "always @(posedge i_clk) if (OPT_LOWPOWER && (!S_AXI_ARESETN || r_flushing || i_cpu_reset)) begin o_result <= 0; end else if (OPT_LOCK && M_AXI_BVALID && (!OPT_LOWPOWER || (r_lock && M_AXI_BRESP == OKAY))) begin o_result <= 0; o_result[AW-1:0] <= r_pc; end else if (!OPT_LOWPOWER || M_AXI_RVALID) begin o_result <= pre_result[31:0]; if (OPT_SIGN_EXTEND) begin // {{{ // verilator coverage_off // Optionally sign extend the return result. // This would be contrary to the ZipCPU ISA case(fifo_op) 2'b10: o_result[31:16] <= {(16){pre_result[15]}}; 2'b11: o_result[31: 8] <= {(24){pre_result[7]}}; default: begin end endcase // verilator coverage_on // }}} end else if (fifo_op[1]) begin // {{{ if (fifo_op[0]) o_result[31: 8] <= 0; else o_result[31:16] <= 0; // }}} end end // }}} // }}} // o_err - report bus errors back to the CPU // {{{",
            "initial o_err = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || r_flushing || o_err) o_err <= 1'b0; else if (i_stb && w_misalignment_err) o_err <= 1'b1; else if (OPT_LOCK && r_lock) o_err <= (M_AXI_BVALID && M_AXI_BRESP[1]) ||(M_AXI_RVALID && M_AXI_RRESP != EXOKAY); else if (M_AXI_BVALID || M_AXI_RVALID) o_err <= (M_AXI_BVALID && M_AXI_BRESP[1]) || (M_AXI_RVALID && M_AXI_RRESP[1]); else o_err <= 1'b0; // }}} // Return xREADY --",
            "always ready // {{{",
            "assign M_AXI_RREADY = 1;",
            "assign M_AXI_BREADY = 1; // }}} // }}} // Make verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, M_AXI_RRESP[0], M_AXI_BRESP[0], M_AXI_BID, M_AXI_RID, M_AXI_RLAST, // i_addr[31:C_AXI_ADDR_WIDTH], (&i_addr), // wide_return[2*C_AXI_DATA_WIDTH-1:32], pending_err, fifo_read_op, none_outstanding }; generate if (SWAP_WSTRB) begin : GEN_UNUSED",
            "wire wide_unused; if (SWAP_WSTRB) begin : GEN_UNUSED_SWAP",
            "assign wide_unused = &{ 1'b0, wide_return[2*DW-32-1:0] }; end else begin : GEN_UNUSED_WIDE",
            "assign wide_unused = &{ 1'b0, wide_return[2*DW-1:32] }; end end endgenerate // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal property section // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Declarations // {{{ `define ASSERT assert `ifndef BMC_ASSERT `define BMC_ASSERT assume `endif `ifdef AXILPIPE `define ASSUME assume `else `define ASSUME assert `endif",
            "localparam F_LGDEPTH = (LGPIPE > 9) ? (LGPIPE+1) : 10; // Verilator lint_off UNDRIVEN (* anyseq *)",
            "wire f_active_lock; (* anyconst *)",
            "reg [LGPIPE:0] f_first_addr; (* anyseq *)",
            "reg [4:0] f_a",
            "reg ; // Verilator lint_on UNDRIVEN",
            "wire [F_LGDEPTH-1:0] faxi_awr_nbursts, faxi_rd_nbursts, faxi_rd_outstanding;",
            "wire [8:0] faxi_wr_pending;",
            "wire [IW-1:0] faxi_wr_checkid;",
            "wire faxi_wr_ckvalid;",
            "wire [F_LGDEPTH-1:0] faxi_wrid_nbursts;",
            "wire [AW-1:0] faxi_wr_addr;",
            "wire [7:0] faxi_wr_incr;",
            "wire [1:0] faxi_wr_burst;",
            "wire [2:0] faxi_wr_size;",
            "wire [7:0] faxi_wr_len;",
            "wire faxi_wr_lockd; // wire [IW-1:0] faxi_rd_checkid;",
            "wire faxi_rd_ckvalid;",
            "wire [8:0] faxi_rd_cklen;",
            "wire [AW-1:0] faxi_rd_ckaddr;",
            "wire [7:0] faxi_rd_ckincr;",
            "wire [1:0] faxi_rd_ckburst;",
            "wire [2:0] faxi_rd_cksize;",
            "wire [7:0] faxi_rd_ckarlen;",
            "wire faxi_rd_cklockd;",
            "wire [F_LGDEPTH-1:0] faxi_rdid_nbursts, faxi_rdid_outstanding;",
            "wire [F_LGDEPTH-1:0] faxi_rdid_ckign_nbursts, faxi_rdid_ckign_outstanding;",
            "wire [1:0] faxi_ex_state;",
            "wire faxi_ex_checklock;",
            "wire [F_LGDEPTH-1:0] faxi_rdid_bursts_to_lock;",
            "wire [F_LGDEPTH-1:0] faxi_wrid_bursts_to_exwrite;",
            "reg [AW-1:0] f_exlock_addr;",
            "wire [AW-1:0] faxi_exreq_addr;",
            "wire [7:0] f_exlock_len, faxi_exreq_len;",
            "wire [1:0] f_exlock_burst, faxi_exreq_burst;",
            "wire [2:0] faxi_exreq_size;",
            "reg [2:0] f_exlock_size; // Verilator lint_off UNUSED",
            "wire faxi_exlock_return; // Verilator lint_on UNUSED",
            "reg [LGPIPE:0] f_fifo_fill;",
            "reg f_clrfifo, f_wrfifo, f_rdfifo;",
            "wire misaligned_response_pending;",
            "reg [1:0] f_fsmfifo;",
            "reg [LGPIPE:0] f_next_addr, f_penu_addr, f_last_written, f_distance_to_first, f_distance_to_next;",
            "reg [FIFO_WIDTH-1:0] f_first_data, f_next_data, f_penu_data;",
            "reg [4:0] f_first_return_",
            "reg , f_next_return_",
            "reg , f_return_",
            "reg , f_penu_return_",
            "reg ;",
            "reg f_first_in_fifo, f_next_in_fifo, f_first_misaligned, f_next_misaligned, f_this_misaligned, f_penu_misaligned, f_first_read_cycle, f_next_read_cycle, f_this_read_cycle, f_penu_read_cycle;",
            "wire [LGPIPE:0] cpu_outstanding;",
            "wire cpu_gie, cpu_pc, cpu_read_cycle;",
            "wire [4:0] cpu_last_",
            "reg , cpu_addr_",
            "reg ;",
            "reg [4:0] f_ar_a",
            "reg ;",
            "reg f_done;",
            "reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "always @(*) if (!f_past_valid) `ASSUME(!S_AXI_ARESETN); // }}} //////////////////////////////////////////////////////////////////////// // // Bus property checking // {{{ //////////////////////////////////////////////////////////////////////// // // faxi_master #( // {{{ .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH), .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH), .OPT_MAXBURST(8'h0), .OPT_EXCLUSIVE(OPT_LOCK), .F_OPT_ASSUME_RESET(1'b1), .F_LGDEPTH(F_LGDEPTH) // }}} ) faxi ( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // Write interface // {{{ .i_axi_awvalid(M_AXI_AWVALID), .i_axi_awready(M_AXI_AWREADY), .i_axi_awid( M_AXI_AWID), .i_axi_awaddr( M_AXI_AWADDR), .i_axi_awlen( M_AXI_AWLEN), .i_axi_awsize( M_AXI_AWSIZE), .i_axi_awburst(M_AXI_AWBURST), .i_axi_awlock( M_AXI_AWLOCK), .i_axi_awcache(M_AXI_AWCACHE), .i_axi_awprot( M_AXI_AWPROT), .i_axi_awqos( M_AXI_AWQOS), // .i_axi_wvalid(M_AXI_WVALID), .i_axi_wready(M_AXI_WREADY), .i_axi_wdata( M_AXI_WDATA), .i_axi_wstrb( M_AXI_WSTRB), .i_axi_wlast( M_AXI_WLAST), // .i_axi_bvalid(M_AXI_BVALID), .i_axi_bready(M_AXI_BREADY), .i_axi_bid( M_AXI_BID), .i_axi_bresp( M_AXI_BRESP), // }}} // Read interface // {{{ .i_axi_arvalid(M_AXI_ARVALID), .i_axi_arready(M_AXI_ARREADY), .i_axi_arid( M_AXI_ARID), .i_axi_araddr( M_AXI_ARADDR), .i_axi_arlen( M_AXI_ARLEN), .i_axi_arsize( M_AXI_ARSIZE), .i_axi_arburst(M_AXI_ARBURST), .i_axi_arlock( M_AXI_ARLOCK), .i_axi_arcache(M_AXI_ARCACHE), .i_axi_arprot( M_AXI_ARPROT), .i_axi_arqos( M_AXI_ARQOS), // .i_axi_rvalid(M_AXI_RVALID), .i_axi_rready(M_AXI_RREADY), .i_axi_rid( M_AXI_RID), .i_axi_rdata( M_AXI_RDATA), .i_axi_rresp( M_AXI_RRESP), .i_axi_rlast( M_AXI_RLAST), // }}} // Induction information // .f_axi_awr_nbursts(faxi_awr_nbursts), .f_axi_wr_pending(faxi_wr_pending), .f_axi_rd_nbursts(faxi_rd_nbursts), .f_axi_rd_outstanding(faxi_rd_outstanding), // WR_COUNT // {{{ .f_axi_wr_checkid( faxi_wr_checkid), .f_axi_wr_ckvalid( faxi_wr_ckvalid), .f_axi_wrid_nbursts(faxi_wrid_nbursts), .f_axi_wr_addr( faxi_wr_addr), .f_axi_wr_incr( faxi_wr_incr), .f_axi_wr_burst( faxi_wr_burst), .f_axi_wr_size( faxi_wr_size), .f_axi_wr_len( faxi_wr_len), .f_axi_wr_lockd( faxi_wr_lockd), // }}} // RD_COUNT // {{{ .f_axi_rd_checkid(faxi_rd_checkid), .f_axi_rd_ckvalid(faxi_rd_ckvalid), .f_axi_rd_cklen( faxi_rd_cklen), .f_axi_rd_ckaddr( faxi_rd_ckaddr), .f_axi_rd_ckincr( faxi_rd_ckincr), .f_axi_rd_ckburst(faxi_rd_ckburst), .f_axi_rd_cksize( faxi_rd_cksize), .f_axi_rd_ckarlen(faxi_rd_ckarlen), .f_axi_rd_cklockd(faxi_rd_cklockd), // .f_axi_rdid_nbursts(faxi_rdid_nbursts), .f_axi_rdid_outstanding(faxi_rdid_outstanding), .f_axi_rdid_ckign_nbursts(faxi_rdid_ckign_nbursts), .f_axi_rdid_ckign_outstanding(faxi_rdid_ckign_outstanding), // }}} // Exclusive access handling // {{{ .f_axi_ex_state(faxi_ex_state), .f_axi_ex_checklock(faxi_ex_checklock), .f_axi_rdid_bursts_to_lock(faxi_rdid_bursts_to_lock), .f_axi_wrid_bursts_to_exwrite(faxi_wrid_bursts_to_exwrite), .i_active_lock( f_active_lock), .i_exlock_addr( f_exlock_addr), .i_exlock_len( f_exlock_len), .i_exlock_burst(f_exlock_burst), .i_exlock_size( f_exlock_size), .f_axi_exreq_addr( faxi_exreq_addr), .f_axi_exreq_len( faxi_exreq_len), .f_axi_exreq_burst(faxi_exreq_burst), .f_axi_exreq_size( faxi_exreq_size), .f_axi_exreq_return( faxi_exlock_return) // }}} // // }}} );",
            "always @(*) f_fifo_fill = wraddr - rdaddr;",
            "always @(*) begin if (misaligned_request) `ASSERT(M_AXI_WVALID || M_AXI_ARVALID); if (misaligned_aw_request) `ASSERT(M_AXI_AWVALID); if (M_AXI_ARVALID || faxi_rd_outstanding > 0) begin assert(faxi_awr_nbursts == 0); assert(!M_AXI_AWVALID); assert(!M_AXI_WVALID); end if (faxi_awr_nbursts > 0 || M_AXI_AWVALID || M_AXI_WVALID) begin assert(faxi_rd_outstanding == 0); assert(!M_AXI_ARVALID); end // Rule: Only one of the two VALID's may be valid, never both `ASSERT(!M_AXI_RVALID || (!M_AXI_AWVALID && !M_AXI_WVALID)); assert({ 5'h0, beats_outstanding } + ((misaligned_request && !misaligned_aw_request && M_AXI_WVALID) ? 1:0) + ((M_AXI_WVALID && !M_AXI_AWVALID) ? 1:0) == faxi_rd_outstanding + faxi_awr_nbursts); /* assert(beats_outstanding + ((misaligned_aw_request && !misaligned_request) ? 1:0) + ((M_AXI_AWVALID && !M_AXI_WVALID) ? 1:0) == faxi_rd_outstanding + faxi_awr_nbursts); */ if (OPT_ALIGNMENT_ERR && !r_flushing && (faxi_rd_outstanding > 0 || M_AXI_ARVALID)) begin assert({ 5'h0, f_fifo_fill } == faxi_rd_outstanding); end else if (OPT_ALIGNMENT_ERR && !r_flushing && (faxi_awr_nbursts > 0)) begin if (M_AXI_WVALID == M_AXI_AWVALID) begin assert({ 5'h0, f_fifo_fill } == faxi_awr_nbursts); end else if (M_AXI_WVALID) assert({ 5'h0, f_fifo_fill } == faxi_awr_nbursts-1); end if (faxi_rd_outstanding == 0 && faxi_awr_nbursts == 0) assert(f_fifo_fill == 0); end // Internal write checks // {{{",
            "always @(*) begin if (faxi_wr_checkid == AXI_ID) begin assert(faxi_wrid_nbursts == faxi_awr_nbursts); end else assert(faxi_wrid_nbursts == 0); if (M_AXI_AWVALID) begin assert(M_AXI_WVALID); if (!misaligned_aw_request && misaligned_request) begin assert(faxi_wr_pending == 1); end else assert(faxi_wr_pending == 0); end if (faxi_wr_ckvalid) begin assert(faxi_wr_pending == (M_AXI_WVALID ? 1:0)); // assert(faxi_wr_addr == ); // assert(faxi_wr_incr == ); assert(faxi_wr_burst == AXI_INCR); // assert(faxi_wr_size == AXI_INCR); assert(faxi_wr_len == 0); assert(r_flushing || faxi_wr_lockd == r_lock); end end // }}} // Internal read checks // {{{",
            "always @(*) begin if (faxi_rd_ckvalid) begin assert(faxi_rd_checkid == AXI_ID); // assert(faxi_rd_cklen == AXI_ID); // assert(faxi_rd_ckaddr == AXI_ID); // assert(faxi_rd_ckincr == AXI_INCR); assert(faxi_rd_ckburst == AXI_INCR); // assert(faxi_rd_cksize == AXI_INCR); assert(faxi_rd_ckarlen == 8'h00); assert(r_flushing || faxi_rd_cklockd == r_lock); end if (faxi_rd_checkid == AXI_ID) begin assert(faxi_rd_nbursts == faxi_rdid_nbursts); end else assert(faxi_rdid_nbursts == 0); assert(faxi_rd_nbursts == faxi_rd_outstanding); assert(faxi_rdid_nbursts == faxi_rdid_outstanding); if (faxi_rd_nbursts > 1) assert(!r_lock); end // }}}",
            "always @(*) if (!o_busy) `ASSERT(!r_flushing); // Following any i_stb request, assuming we are idle, immediately // begin a bus transaction",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_stb && !o_err)) &&(!$past(o_busy))&&($past(!i_cpu_reset))) begin if (OPT_LOCK && $past(w_misalignment_err)) begin `ASSERT(o_err && !o_busy); end else `ASSERT(o_busy || (OPT_ALIGNMENT_ERR && o_err)); end",
            "always @(*) if (o_busy && !misaligned_request && OPT_LOWPOWER) begin assert(next_wdata == 0); assert(next_wstrb == 0); end // o_err checking // {{{ // If a transaction ends in an error, send o_err on the",
            "output port.",
            "always @(posedge i_clk) if (f_past_valid) begin if ($past(i_cpu_reset || r_flushing || o_err)) begin `ASSERT(!o_err); end else if ($past(M_AXI_BVALID && M_AXI_BRESP[1])) begin `ASSERT(o_err); end else if ($past(M_AXI_RVALID && M_AXI_RRESP[1])) begin `ASSERT(o_err); end else if ($past(r_lock && M_AXI_RVALID && M_AXI_RRESP != EXOKAY)) begin `ASSERT(o_err); end else if ($past(i_stb && w_misalignment_err)) begin `ASSERT(o_err); end else if (!$past(pending_err)) `ASSERT(!o_err); end // }}}",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(!i_cpu_reset))&&($past(i_stb))) begin // On a write, assert o_wb_we should be true assert($past(i_op[0] && !o_err && (!M_AXI_BVALID || !M_AXI_BRESP[1]) && (!w_misalignment_err)) == (M_AXI_AWVALID && M_AXI_WVALID)); end",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_cpu_reset))) `ASSUME(!i_stb);",
            "always @(*) if (!S_AXI_ARESETN) `ASSUME(i_cpu_reset); // misaligned_response_pending // {{{ generate if (OPT_ALIGNMENT_ERR) begin : NO_MISALIGNED_RESPONSES",
            "assign misaligned_response_pending = 0; end else begin : MISALIGNED_RESPONSE_PENDING",
            "reg r_misaligned_response_pending;",
            "always @(*) begin r_misaligned_response_pending = fifo_misaligned; if (wraddr == rdaddr) r_misaligned_response_pending = 0; end",
            "assign misaligned_response_pending = r_misaligned_response_pending; end endgenerate // }}}",
            "always @(*) if (o_busy) begin cover(i_stb); cover(o_valid); cover(o_err); end else begin cover(o_valid); cover(o_err); end // }}} //////////////////////////////////////////////////////////////////////// // // Zero on idle checks // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_LOWPOWER) begin",
            "always @(*) if (!M_AXI_AWVALID && !M_AXI_ARVALID) `ASSERT(M_AXI_AWADDR == 0);",
            "always @(*) if (!M_AXI_WVALID) begin `ASSERT(M_AXI_WDATA == 0); `ASSERT(M_AXI_WSTRB == 0); `ASSERT(next_wdata == 0); `ASSERT(next_wstrb == 0); end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // FIFO property checking // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) begin // {{{ f_next_addr = f_first_addr + 1; f_last_written = wraddr - 1; f_penu_addr = rdaddr + 1; f_penu_data = fifo_data[f_penu_addr[LGPIPE-1:0]]; f_clrfifo = (!S_AXI_ARESETN || bus_abort || flush_request); f_wrfifo = (!f_clrfifo) && ((M_AXI_ARVALID && M_AXI_ARREADY) || (M_AXI_WVALID && M_AXI_WREADY)); f_rdfifo = (!f_clrfifo) && ((M_AXI_RVALID && M_AXI_RREADY) || (M_AXI_BVALID && M_AXI_BREADY)); f_distance_to_first = f_first_addr - rdaddr; f_distance_to_next = f_next_addr - rdaddr; f_first_in_fifo = (f_distance_to_first < f_fifo_fill) && (f_fifo_fill > 0); f_next_in_fifo = (f_distance_to_next < f_fifo_fill) && (f_fifo_fill > 0); f_return_",
            "reg = { fifo_gie, fifo_return_",
            "reg }; f_first_return_",
            "reg = { fifo_gie, f_first_data[AXILSB+3 +: 4] }; f_next_return_",
            "reg = { fifo_gie, f_next_data[AXILSB+3 +: 4] }; f_penu_return_",
            "reg = { fifo_gie, f_penu_data[AXILSB+3 +: 4] }; f_first_misaligned = f_first_data[AXILSB]; f_next_misaligned = f_next_data[AXILSB]; f_this_misaligned = fifo_read_data[AXILSB]; f_penu_misaligned = f_penu_data[AXILSB]; f_first_read_cycle = f_first_data[FIFO_WIDTH-1]; f_next_read_cycle = f_next_data[FIFO_WIDTH-1]; f_this_read_cycle = fifo_read_data[FIFO_WIDTH-1]; f_penu_read_cycle = f_penu_data[FIFO_WIDTH-1]; // }}} end",
            "always @(*) if (r_flushing && !f_clrfifo) assert(rdaddr == wraddr);",
            "always @(*) if (!f_clrfifo) begin if (f_first_in_fifo) `ASSERT(f_first_data == fifo_data[f_first_addr[LGPIPE-1:0]]); if (f_next_in_fifo) `ASSERT(f_next_data == fifo_data[f_next_addr[LGPIPE-1:0]]); end",
            "always @(posedge S_AXI_ACLK) if (f_wrfifo && wraddr == f_first_addr) f_first_data <= { M_AXI_ARVALID, ar_o",
            "reg , ar_op, misaligned_request, adr_lsb };",
            "always @(posedge S_AXI_ACLK) if (f_wrfifo && wraddr == f_next_addr) f_next_data <= { M_AXI_ARVALID, ar_o",
            "reg , ar_op, misaligned_request, adr_lsb }; // f_fsmfifo // {{{",
            "initial f_fsmfifo = 2'b00;",
            "always @(posedge S_AXI_ACLK) if (f_clrfifo) f_fsmfifo <= 2'b00; else case(f_fsmfifo) 2'b00: if (f_wrfifo && wraddr == f_first_addr) f_fsmfifo <= 2'b01; 2'b01: if (f_rdfifo && rdaddr == f_first_addr) f_fsmfifo <= 2'b00; else if (f_wrfifo && wraddr == f_next_addr) f_fsmfifo <= 2'b10; 2'b10: if (f_rdfifo && rdaddr == f_first_addr) f_fsmfifo <= 2'b11; 2'b11: if (f_rdfifo) f_fsmfifo <= 2'b00; endcase",
            "always @(*) if (!f_clrfifo) case(f_fsmfifo) 2'b00: begin // {{{ `ASSERT(!f_first_in_fifo); end // }}} 2'b01: begin // {{{ `ASSERT(f_fifo_fill >= 1); `ASSERT(f_first_in_fifo); end // }}} 2'b10: begin // {{{ `ASSERT(f_fifo_fill >= 2); `ASSERT(f_first_in_fifo); `ASSERT(f_next_in_fifo); end // }}} 2'b11: begin // {{{ `ASSERT(f_fifo_fill >= 1); `ASSERT(f_next_in_fifo); `ASSERT(rdaddr == f_next_addr); end // }}} endcase // }}} // { ar_o",
            "reg , ar_op, misaligned_request, M_AXI_ARADDR[AXILSB-1:0] }; // cpu_gie checks // {{{",
            "always @(*) if (M_AXI_ARVALID) `ASSERT(cpu_gie == fifo_gie);",
            "always @(*) if (!f_clrfifo && f_fifo_fill != 0) begin if (M_AXI_ARVALID || M_AXI_WVALID || M_AXI_AWVALID) `ASSERT(cpu_gie == fifo_gie); if ((!f_first_in_fifo || rdaddr != f_first_addr) && (!f_next_in_fifo || rdaddr != f_next_addr) && (f_fifo_fill > 0)) `ASSUME(cpu_gie == f_return_",
            "reg [4]); if (f_first_in_fifo) `ASSERT(cpu_gie == f_first_return_",
            "reg [4]); if (f_next_in_fifo) `ASSERT(cpu_gie == f_next_return_",
            "reg [4]); end // }}} // cpu_pc checks // {{{",
            "always @(*) if (M_AXI_ARVALID) `ASSERT(cpu_pc == ((&ar_o",
            "reg [3:1]) && (o_err || !flush_request)));",
            "always @(*) if (!f_clrfifo && f_fifo_fill != 0) begin if ((M_AXI_ARVALID || (rdaddr != f_last_written))) begin `ASSERT(f_this_misaligned || !cpu_read_cycle || !(&f_return_",
            "reg [3:1])); end else if (f_fifo_fill > 0 && !M_AXI_ARVALID) `ASSERT(f_this_misaligned || !cpu_read_cycle || cpu_pc == (&f_return_",
            "reg [3:1])); if ((!f_first_in_fifo || rdaddr != f_first_addr) && (!f_next_in_fifo || rdaddr != f_next_addr) && cpu_read_cycle) begin if (M_AXI_ARVALID) // && (&ar_o",
            "reg [3:1])) begin `ASSUME(!(&f_return_",
            "reg [3:1])); end else if (rdaddr != f_last_written) begin `ASSUME(!(&f_return_",
            "reg [3:1])); end else if (!M_AXI_ARVALID && !o_err) `ASSUME(cpu_pc == (&f_return_",
            "reg [3:1])); // Not last written end if (f_first_in_fifo && cpu_read_cycle) begin if (!cpu_pc || M_AXI_ARVALID || (f_last_written != f_first_addr)) begin `ASSERT(f_first_misaligned || !cpu_read_cycle || !(&f_first_return_",
            "reg [3:1])); end else if (!M_AXI_ARVALID && !o_err) `ASSERT(&f_first_return_",
            "reg [3:1]); end if (f_next_in_fifo && cpu_read_cycle) begin if (!cpu_pc || M_AXI_ARVALID || (f_last_written != f_next_addr)) begin `ASSERT(f_next_misaligned || !(&f_next_return_",
            "reg [3:1])); end else if (!M_AXI_ARVALID && !o_err) `ASSERT(&f_next_return_",
            "reg [3:1]); end if (M_AXI_ARVALID) `ASSERT(cpu_pc == (&ar_o",
            "reg [3:1])); end // }}}",
            "always @(*) if (cpu_read_cycle && !r_flushing) assert(o_rdbusy==((rdaddr != wraddr)||(M_AXI_ARVALID)));",
            "always @(*) if (cpu_read_cycle) assert(!M_AXI_AWVALID && !M_AXI_WVALID&& faxi_awr_nbursts == 0); // Verifying the alignment flags // {{{",
            "always @(*) if (M_AXI_ARVALID && OPT_ALIGNMENT_ERR) assert(!misaligned_request);",
            "always @(*) if (!f_clrfifo && f_fifo_fill != 0) begin if (OPT_ALIGNMENT_ERR) begin // {{{ if (f_first_in_fifo) `ASSERT(!f_first_misaligned); if (f_next_in_fifo) `ASSERT(!f_next_misaligned); if ((!f_first_in_fifo || rdaddr != f_first_addr) && (!f_next_in_fifo || rdaddr != f_next_addr)) `ASSUME(!f_this_misaligned); // }}} end else begin // {{{ if (f_first_in_fifo && f_first_misaligned) begin if (f_next_in_fifo) begin `ASSERT(!f_next_misaligned); end else begin `ASSERT(!misaligned_request); `ASSERT(M_AXI_ARVALID || M_AXI_WVALID); end end if (misaligned_response_pending && (!f_first_in_fifo || rdaddr != f_first_addr)) begin if (f_fifo_fill > 1) begin `BMC_ASSERT(!f_penu_misaligned); end else if (f_fifo_fill == 1) begin `BMC_ASSERT(!misaligned_request); end end // }}} end end // }}} // Verifying unaligned",
            "reg isters remain the same // {{{",
            "always @(*) if (!f_clrfifo && f_fifo_fill != 0 && !OPT_ALIGNMENT_ERR) begin if (f_first_in_fifo && f_first_misaligned) begin if (f_next_in_fifo) begin `ASSERT(f_first_return_",
            "reg == f_next_return_",
            "reg ); end else begin `ASSERT(M_AXI_ARVALID || M_AXI_WVALID); `ASSERT(!misaligned_request); `ASSERT(f_first_return_",
            "reg == { fifo_gie, ar_o",
            "reg }); end end if (misaligned_response_pending && (!f_first_in_fifo || rdaddr != f_first_addr)) begin if (f_fifo_fill == 1) begin `BMC_ASSERT(M_AXI_ARVALID || M_AXI_WVALID); `BMC_ASSERT(!misaligned_request); `BMC_ASSERT(f_first_return_",
            "reg == { fifo_gie, ar_o",
            "reg }); end else `BMC_ASSERT({ fifo_gie, fifo_return_",
            "reg } == f_penu_return_",
            "reg ); end end // }}}",
            "always @(*) assert(f_fifo_fill <= (1<<LGPIPE));",
            "always @(*) assert(beats_outstanding <= (1<<LGPIPE)); // Verifying the cpu_read_cycle flags // {{{",
            "always @(*) if (!r_flushing && f_fifo_fill > 0) begin if (f_first_in_fifo) `ASSERT(cpu_read_cycle == f_first_read_cycle); if (f_next_in_fifo) `ASSERT(cpu_read_cycle == f_next_read_cycle); if (// f_fifo_fill > 0 && // Redundant (!f_first_in_fifo || rdaddr != f_first_addr) && (!f_next_in_fifo || rdaddr != f_next_addr)) begin `BMC_ASSERT(cpu_read_cycle == f_this_read_cycle); end if (f_fifo_fill > 1 && (!f_first_in_fifo || f_penu_addr != f_first_addr) && (!f_next_in_fifo || f_penu_addr != f_next_addr)) begin `BMC_ASSERT(cpu_read_cycle == f_penu_read_cycle); end if (cpu_read_cycle) begin `ASSERT(!M_AXI_AWVALID && !M_AXI_WVALID); `ASSERT(faxi_awr_nbursts == 0); end end // }}} // Verifying the cpu_last_",
            "reg // {{{",
            "always @(*) if (M_AXI_WVALID || M_AXI_ARVALID) begin if (cpu_axi_write_cycle) begin assert(cpu_last_",
            "reg == { fifo_gie, 4'hf }); end else if (!r_flushing) assert(cpu_last_",
            "reg == { fifo_gie, ar_o",
            "reg }); end else if (!f_clrfifo && f_fifo_fill > 0) begin if (cpu_axi_write_cycle) begin assert(cpu_last_",
            "reg == { fifo_gie, 4'hf }); end else if (f_first_in_fifo && f_first_addr == f_last_written) begin assert(f_first_return_",
            "reg == cpu_last_",
            "reg ); end if (!cpu_axi_write_cycle && f_next_in_fifo && f_next_addr == f_last_written) begin assert(f_next_return_",
            "reg == cpu_last_",
            "reg ); end if (rdaddr == f_last_written && (rdaddr != f_first_addr) && (rdaddr != f_next_addr)) `BMC_ASSERT({ fifo_gie, fifo_return_",
            "reg } == cpu_last_",
            "reg ); end // }}} // Verifying the cpu_addr_",
            "reg // {{{",
            "always @(posedge S_AXI_ACLK) if (i_stb) f_ar_a",
            "reg <= f_a",
            "reg ;",
            "always @(*) if (o_rdbusy) `ASSERT(f_ar_a",
            "reg == cpu_addr_",
            "reg );",
            "always @(*) if (!f_clrfifo && o_rdbusy && f_fifo_fill > 0) begin if (f_first_in_fifo && f_first_addr != f_last_written) assert(f_first_return_",
            "reg != cpu_addr_",
            "reg || f_first_misaligned); if (f_next_in_fifo && f_next_addr != f_last_written) assert(f_next_return_",
            "reg != cpu_addr_",
            "reg || f_next_misaligned); // If the base address",
            "reg ister exists in the FIFO, then it // can't be part of any current requests. if ((f_first_in_fifo && (f_first_return_",
            "reg == cpu_addr_",
            "reg ) && !f_first_misaligned) ||(f_next_in_fifo && (f_next_return_",
            "reg == cpu_addr_",
            "reg ) && !f_next_misaligned)) assert(!M_AXI_WVALID && !M_AXI_ARVALID); if ((rdaddr != f_last_written || M_AXI_WVALID || M_AXI_ARVALID) && !misaligned_response_pending && (cpu_outstanding > (o_valid ? 1:0)) && (rdaddr != f_first_addr) && (rdaddr != f_next_addr)) `BMC_ASSERT({ fifo_gie, fifo_return_",
            "reg } != cpu_addr_",
            "reg ); end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Exclusive access properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge S_AXI_ACLK) if (M_AXI_ARVALID && M_AXI_ARREADY && M_AXI_ARLOCK) begin f_exlock_addr <= M_AXI_ARADDR; f_exlock_size <= M_AXI_ARSIZE; end",
            "assign f_exlock_len = 0;",
            "assign f_exlock_burst = M_AXI_AWBURST;",
            "always @(*) if (faxi_ex_state != 2'b00) begin assert(f_exlock_addr == faxi_exreq_addr); assert(f_exlock_len == faxi_exreq_len); assert(f_exlock_size == faxi_exreq_size); assert(f_exlock_burst == faxi_exreq_burst); end",
            "always @(*) if (r_lock) begin if (M_AXI_ARVALID) begin assert(M_AXI_ARLOCK); assert(!M_AXI_AWVALID); assert(faxi_rdid_bursts_to_lock == 0); end else if (M_AXI_AWVALID) begin assert(!M_AXI_ARVALID); assert(M_AXI_AWLOCK); assert(faxi_rdid_bursts_to_lock == 0); end else if (faxi_ex_checklock&&(M_AXI_ARID == faxi_rd_checkid)) begin assert(faxi_rdid_bursts_to_lock == faxi_rd_nbursts); end else assert(faxi_rdid_bursts_to_lock == 0); if (faxi_rd_nbursts > 1) assume(!M_AXI_RVALID || M_AXI_RRESP != EXOKAY); assert(faxi_rdid_bursts_to_lock <= 1); assert(faxi_wrid_bursts_to_exwrite <= 1); end else begin assume(r_flushing || !M_AXI_RVALID || M_AXI_RRESP != EXOKAY); assert(r_flushing || faxi_rdid_bursts_to_lock == 0); assert(r_flushing || faxi_wrid_bursts_to_exwrite == 0); end // }}} //////////////////////////////////////////////////////////////////////// // // Contract properties // {{{ //////////////////////////////////////////////////////////////////////// // // wire cpu_axi_write_cycle;",
            "initial f_done = 1'b0;",
            "always @(posedge i_clk) if (i_cpu_reset || r_flushing) f_done <= 1'b0; else f_done <= (M_AXI_RVALID && !M_AXI_RRESP[1] || M_AXI_BVALID && !M_AXI_BRESP[1]) && !pending_err && !misaligned_response_pending;",
            "localparam FMEM_OPT_MAXDEPTH = (1<<LGPIPE); fmem #( // {{{ .F_LGDEPTH(LGPIPE+1), .OPT_LOCK(OPT_LOCK), .OPT_AXI_LOCK(OPT_LOCK), .OPT_MAXDEPTH(FMEM_OPT_MAXDEPTH[LGPIPE:0]) // }}} ) fcheck( // {{{ .i_clk(S_AXI_ACLK), .i_sys_reset(!S_AXI_ARESETN), .i_cpu_reset(i_cpu_reset), .i_stb(i_stb), .i_pipe_stalled(o_pipe_stalled), .i_clear_cache(1'b0), .i_lock(i_lock), .i_op(i_op), .i_addr({ {(32-AW){1'b0}}, i_addr }), .i_data(i_data), .i_o",
            "reg (i_o",
            "reg ), .i_busy(o_busy), .i_a",
            "reg (f_a",
            "reg ), .i_rdbusy(o_rdbusy), .i_valid(o_valid), .i_done(f_done), .i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_result), .f_outstanding(cpu_outstanding), .f_pc(cpu_pc), .f_gie(cpu_gie), .f_read_cycle(cpu_read_cycle), .f_axi_write_cycle(cpu_axi_write_cycle), .f_last_",
            "reg (cpu_last_",
            "reg ), .f_addr_",
            "reg (cpu_addr_",
            "reg ) // }}} );",
            "always @(*) if (flush_request) begin `ASSERT(cpu_outstanding == 0 || o_err); end else if (r_flushing) begin `ASSERT(o_err || cpu_outstanding == 0); end else if (OPT_ALIGNMENT_ERR) begin if (!o_err) `ASSERT(cpu_outstanding == (beats_outstanding - flushcount) + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0) + ((o_valid || f_done) ? 1:0)); // else `ASSERT(cpu_outstanding == flushcount); end",
            "always @(*) if (o_err && beats_outstanding > 0) `ASSERT(r_flushing);",
            "always @(*) if (!o_err && cpu_outstanding > 0) begin if (cpu_axi_write_cycle) begin assert(faxi_rd_outstanding == 0); assert(!M_AXI_ARVALID); if (f_done) begin assert(!M_AXI_AWVALID && !M_AXI_WVALID && faxi_awr_nbursts == 0); assert(!o_rdbusy); end else begin assert(faxi_awr_nbursts == (M_AXI_AWVALID ? 0:1)); assert(o_rdbusy); end end else if (faxi_rd_outstanding > 0 || M_AXI_ARVALID || o_rdbusy) begin assert(cpu_read_cycle); end else if (faxi_awr_nbursts > 0 || M_AXI_AWVALID || M_AXI_WVALID) assert(!cpu_read_cycle); end // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // reg [LGPIPE:0] cvr_writes, cvr_reads, cvr_valids;",
            "reg cvr_idle;",
            "always @(*) begin cvr_idle = 1; if (i_cpu_reset || o_err || f_done) cvr_idle = 1'b0; if (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) cvr_idle = 1'b0; if (faxi_awr_nbursts > 0) cvr_idle = 1'b0; if (faxi_rd_outstanding > 0) cvr_idle = 1'b0; end",
            "initial cvr_writes = 0;",
            "always @(posedge i_clk) if (i_cpu_reset || o_err) cvr_writes <= 0; else if (M_AXI_BVALID&& !misaligned_response_pending && !(&cvr_writes)) cvr_writes <= cvr_writes + 1;",
            "initial cvr_reads = 0;",
            "always @(posedge i_clk) if (i_cpu_reset || o_err) cvr_reads <= 0; else if (M_AXI_RVALID && !misaligned_response_pending && !(&cvr_reads)) cvr_reads <= cvr_reads + 1;",
            "initial cvr_valids = 0;",
            "always @(posedge i_clk) if (i_cpu_reset || o_err) cvr_valids <= 0; else if (o_valid) cvr_valids <= cvr_valids + 1; // Cover a write response",
            "always @(posedge i_clk) cover(M_AXI_BVALID && !M_AXI_BRESP[1]);",
            "always @(posedge i_clk) cover(M_AXI_BVALID && M_AXI_BRESP[1]);",
            "always @(posedge i_clk) cover(M_AXI_RVALID && !M_AXI_RRESP[1]);",
            "always @(posedge i_clk) cover(M_AXI_RVALID && M_AXI_RRESP[1]);",
            "always @(posedge i_clk) if (cvr_idle) begin cover(cvr_writes > 3); cover(cvr_reads > 3); cover(cvr_valids > 3); cover(cvr_writes > (1<<LGPIPE)); cover(cvr_reads > (1<<LGPIPE)); cover(cvr_valids > (1<<LGPIPE)); cover(cvr_writes > (1<<LGPIPE)+2); cover(cvr_reads > (1<<LGPIPE)+2); cover(cvr_valids > (1<<LGPIPE)+2); end generate if (!OPT_ALIGNMENT_ERR) begin",
            "reg [LGPIPE:0] cvr_unaligned_writes, cvr_unaligned_reads;",
            "initial cvr_writes = 0;",
            "always @(posedge i_clk) if (i_cpu_reset || o_err) cvr_unaligned_writes <= 0; else if (i_stb && i_op[0] && w_misaligned) cvr_unaligned_writes <= cvr_unaligned_writes + 1;",
            "initial cvr_reads = 0;",
            "always @(posedge i_clk) if (i_cpu_reset || o_err) cvr_unaligned_reads <= 0; else if (i_stb && !i_op[0] && w_misaligned) cvr_unaligned_reads <= cvr_unaligned_reads + 1;",
            "always @(posedge i_clk) if (cvr_idle) begin cover(cvr_unaligned_writes > 3); cover(cvr_unaligned_reads > 3); cover(cvr_unaligned_writes > (1<<LGPIPE)); cover(cvr_unaligned_reads > (1<<LGPIPE)); end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Careless assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (!OPT_ALIGNMENT_ERR) begin if (!r_flushing && !o_err) `BMC_ASSERT(cpu_outstanding <= beats_outstanding + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0) + ((o_valid || f_done) ? 1:0)); if (!r_flushing && cpu_read_cycle) begin `BMC_ASSERT({ 4'h0, cpu_outstanding } >= (f_done ? 1:0) + faxi_rd_outstanding[F_LGDEPTH-1:1]); end else if (!r_flushing) `BMC_ASSERT({ 4'h0, cpu_outstanding } >= (f_done ? 1:0) + faxi_awr_nbursts[F_LGDEPTH-1:1]); if (!r_flushing && !o_err) assert(f_fifo_fill == beats_outstanding + ((misaligned_aw_request && !misaligned_request) ? 1:0) + ((M_AXI_AWVALID && !M_AXI_WVALID) ? 1:0)); if (!r_flushing && !o_err) begin `BMC_ASSERT((cpu_outstanding == 0) == (!M_AXI_AWVALID && !M_AXI_WVALID && !M_AXI_ARVALID && (beats_outstanding + (f_done ? 1:0) == 0))); end else if (o_err) `BMC_ASSERT(cpu_outstanding > 0); if (!r_flushing && !o_err && cpu_outstanding == (f_done ? 1:0)) `BMC_ASSERT(beats_outstanding == 0 && !M_AXI_AWVALID && !M_AXI_WVALID && !M_AXI_ARVALID); end // Lock assumptions",
            "always @(*) if (SWAP_WSTRB) begin if (M_AXI_AWVALID) // && M_AXI_AWLOCK) begin assert(M_AXI_AWADDR[AXILSB-1:0] == 0); assert(M_AXI_AWSIZE == AXILSB[2:0]); end if (M_AXI_ARVALID) // && M_AXI_AWLOCK) begin assert(M_AXI_ARADDR[AXILSB-1:0] == 0); assert(M_AXI_ARSIZE == AXILSB[2:0]); end end",
            "always @(*) if (i_stb && i_op[0] && i_lock) begin assume(i_addr == f_exlock_addr); assume(faxi_ex_state == 2'b10); if (SWAP_WSTRB) begin assume(f_exlock_size == AXILSB[2:0]); assume(f_exlock_addr[AXILSB-1:0] == 0); end else casez(i_op[2:1]) 2'b0?: assume(f_exlock_size == 3'b010); 2'b10: assume(f_exlock_size == 3'b001); 2'b11: assume(f_exlock_size == 3'b000); endcase end",
            "always @(*) assume(faxi_wr_checkid == AXI_ID);",
            "always @(*) assume(faxi_rd_checkid == AXI_ID);",
            "always @(*) if (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID || (beats_outstanding > 0)) assume(!i_stb || !i_lock); // }}} // Make Verilator happy w/ formal // {{{ // Verilator lint_off UNUSED",
            "wire unused_formal;",
            "assign unused_formal = &{ 1'b0, faxi_exlock_return, f_return_",
            "reg , faxi_rdid_ckign_outstanding, faxi_rdid_ckign_nbursts, faxi_wr_incr, faxi_wr_size, faxi_rd_cklen, faxi_rd_ckaddr, faxi_rd_cksize, faxi_rd_ckincr, faxi_wr_addr }; // Verilator lint_on UNUSED // }}} `endif // }}}",
            "endmodule // yosys -p 'read -sv axipipe.v; synth_xilinx -flatten -top axipipe' // // (!LOWPOWER) (LOWPOWER) // Cells: 932 1099 // FDRE,FDSE 234 234 // LUT1 0 32 // LUT2 62 73 // LUT3 46 58 // LUT4 25 36 // LUT5 75 62 // LUT6 116 130 // MUXF7 14 55 // MUXF8 6 12 // RAM32X1D 9 9 // Estimated LCs: 262 286 //"
        ]
    },
    {
        "file_name": "pipefetch.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/pipefetch.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: pipefetch.v (DEPRECATED) // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Keeping our CPU fed with instructions, at one per clock and // with no stalls, can be quite a chore. Worse, the Wishbone // takes a couple of cycles just to read one instruction from // the bus. However, if we use pipeline accesses to the Wishbone // bus, then we can read more and faster. Further, if we cache // these results so that we have them before we need them, then // we have a chance of keeping our CPU from stalling. Those are // the purposes of this instruction fetch",
            "module : 1) Pipeline // wishbone accesses, and 2) an instruction cache. // // 20150919 -- Fixed a nasty race condition whereby the pipefetch routine // would produce either the same instruction twice, or skip // an instruction. This condition was dependent on the CPU stall // condition, and would only take place if the pipeline wasn't // completely full throughout the stall. // // Interface support was also added for trapping on illegal // instructions (i.e., instruction fetches that cause bus errors), // however the internal interface has not caught up to supporting // these exceptions yet. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024 Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module pipefetch(i_clk, i_reset, i_new_pc, i_clear_cache, i_stall_n, i_pc, // {{{ o_i, o_pc, o_v, o_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, i_wb_stall, i_wb_ack, i_wb_err, i_wb_data, i_wb_request, o_illegal);",
            "parameter RESET_ADDRESS=32'h0010_0000, LGCACHELEN = 6, ADDRESS_WIDTH=24, CACHELEN=(1<<LGCACHELEN), BUSW=32, AW=ADDRESS_WIDTH;",
            "input wire i_clk, i_reset, i_new_pc, i_clear_cache, i_stall_n;",
            "input wire [AW+1:0] i_pc;",
            "output reg [BUSW-1:0] o_i;",
            "output reg [AW+1:0] o_pc;",
            "output reg o_v; // output reg o_wb_cyc, o_wb_stb;",
            "output wire o_wb_we;",
            "output reg [(AW-1):0] o_wb_addr;",
            "output wire [(BUSW-1):0] o_wb_data; // input wire i_wb_stall, i_wb_ack, i_wb_err;",
            "input wire [(BUSW-1):0] i_wb_data; // // Is the (data) memory unit also requesting access to the bus?",
            "input wire i_wb_request;",
            "output wire o_illegal; // }}} // Declarations // {{{",
            "reg [(AW-1):0] r_cache_base;",
            "reg [(LGCACHELEN):0] r_nvalid, r_acks_waiting;",
            "reg [(BUSW-1):0] cache[0:(CACHELEN-1)];",
            "wire [(LGCACHELEN-1):0] w_cache_offset;",
            "reg [1:0] r_cache_offset;",
            "reg r_addr_set;",
            "reg [AW+1:0] r_addr;",
            "wire [(AW-1):0] bus_nvalid;",
            "wire w_pc_out_of_bounds;",
            "wire w_ran_off_end_of_cache;",
            "wire w_running_out_of_cache;",
            "wire w_cv; // Cache valid, address is in the cache",
            "reg r_cv;",
            "wire [(LGCACHELEN-1):0] c_rdaddr, c_cache_base;",
            "reg [(AW-1):0] ill_address; // }}} // Fixed bus",
            "output s: we read from the bus only, never write. // {{{ // Thus the",
            "output data is ... irrelevant and don't care. We set it // to zero just to set it to something.",
            "assign o_wb_we = 1'b0;",
            "assign o_wb_data = 0; // }}}",
            "assign bus_nvalid = { {(AW-LGCACHELEN-1){1'b0}}, r_nvalid }; // What are some of the conditions for which we need to restart the // cache?",
            "assign w_pc_out_of_bounds = ((i_new_pc)&&((r_nvalid == 0) ||(i_pc[AW+1:2] < r_cache_base) ||(i_pc[AW+1:2] >= r_cache_base + CACHELEN) ||(i_pc[AW+1:2] >= r_cache_base + bus_nvalid+5)));",
            "assign w_ran_off_end_of_cache =((r_addr_set)&&((r_addr[AW+1:2] < r_cache_base) ||(r_addr[AW+1:2] >= r_cache_base + CACHELEN) ||(r_addr[AW+1:2] >= r_cache_base + bus_nvalid+5)));",
            "assign w_running_out_of_cache = (r_addr_set) &&(r_addr[AW+1:2] >= r_cache_base + // {{(AW-LGCACHELEN-1),{1'b0}},2'b11, // {(LGCACHELEN-1){1'b0}}}) // (1<<(LGCACHELEN-2)) + (1<<(LGCACHELEN-1))) +(3<<(LGCACHELEN-2))) &&(|r_nvalid[(LGCACHELEN):(LGCACHELEN-1)]); // o_wb_[cyc|stb] // {{{",
            "initial { o_wb_cyc, o_wb_stb } = 2'b00;",
            "always @(posedge i_clk) if ((i_reset)||(i_clear_cache)||((o_wb_cyc)&&(i_wb_err))) begin o_wb_cyc <= 1'b0; o_wb_stb <= 1'b0; end else if ((o_wb_cyc)&&(w_pc_out_of_bounds)) begin // {{{ // We need to abandon our bus action to start over in // a new",
            "reg ion, setting up a new cache. This may // happen mid cycle while waiting for a result. By // dropping o_wb_cyc, we state that we are no longer // interested in that result--whatever it might be. o_wb_cyc <= 1'b0; o_wb_stb <= 1'b0; // }}} end else if ((!o_wb_cyc)&&(!r_nvalid[LGCACHELEN])&&(!i_wb_request)&&(r_addr_set)) begin // Restart a bus cycle that was interrupted when the // {{{ // data section wanted access to our bus. o_wb_cyc <= 1'b1; o_wb_stb <= 1'b1; // o_wb_addr <= r_cache_base + bus_nvalid; // }}} end else if ((!o_wb_cyc)&&( (w_pc_out_of_bounds)||(w_ran_off_end_of_cache))) begin // Start a bus transaction // {{{ o_wb_cyc <= 1'b1; o_wb_stb <= 1'b1; // }}} end else if ((!o_wb_cyc)&&(w_running_out_of_cache)) begin // {{{ // If we're using the last quarter of the cache, then // let's start a bus transaction to extend the cache. o_wb_cyc <= 1'b1; o_wb_stb <= 1'b1; // o_wb_addr <= r_cache_base + (1<<(LGCACHELEN)); // r_nvalid <= r_nvalid - (1<<(LGCACHELEN-2)); // r_cache_base <= r_cache_base + (1<<(LGCACHELEN-2)); // w_cache_offset <= w_cache_offset + (1<<(LGCACHELEN-2)); // }}} end else if (o_wb_cyc) begin // {{{ // This handles everything ... but the case where // while reading we need to extend our cache. if ((o_wb_stb)&&(!i_wb_stall)) begin // o_wb_addr <= o_wb_addr + 1; if ((o_wb_addr - r_cache_base >= CACHELEN-1) ||(i_wb_request)) o_wb_stb <= 1'b0; end if (i_wb_ack) begin // r_nvalid <= r_nvalid + 1; if ((r_acks_waiting == 1)&&(!o_wb_stb)) o_wb_cyc <= 1'b0; end else if ((r_acks_waiting == 0)&&(!o_wb_stb)) o_wb_cyc <= 1'b0; // }}} end // }}}} // r_nvalid // {{{",
            "initial r_nvalid = 0;",
            "always @(posedge i_clk) if ((i_reset)||(i_clear_cache)) // Required, so we can reload memoy and then reset r_nvalid <= 0; else if ((!o_wb_cyc)&&( (w_pc_out_of_bounds)||(w_ran_off_end_of_cache))) r_nvalid <= 0; else if ((!o_wb_cyc)&&(w_running_out_of_cache)) r_nvalid[LGCACHELEN:(LGCACHELEN-2)] <= r_nvalid[LGCACHELEN:(LGCACHELEN-2)] +3'b111; // i.e. - (1<<(LGCACHELEN-2)); else if ((o_wb_cyc)&&(i_wb_ack)) r_nvalid <= r_nvalid + {{(LGCACHELEN){1'b0}},1'b1}; // +1; // }}} // r_cache_base // {{{",
            "initial r_cache_base = RESET_ADDRESS[(AW+1):2];",
            "always @(posedge i_clk) if (i_clear_cache) r_cache_base <= i_pc[AW+1:2]; else if ((!o_wb_cyc)&&( (w_pc_out_of_bounds) ||(w_ran_off_end_of_cache))) r_cache_base <= (i_new_pc) ? i_pc[AW+1:2] : r_addr[AW+1:2]; else if ((!o_wb_cyc)&&(w_running_out_of_cache)) r_cache_base[(AW-1):(LGCACHELEN-2)] <= r_cache_base[(AW-1):(LGCACHELEN-2)] + {{(AW-LGCACHELEN+1){1'b0}},1'b1}; // i.e. + (1<<(LGCACHELEN-2)); // }}} // [w|r]_cache_offset // {{{",
            "always @(posedge i_clk) if (i_clear_cache) r_cache_offset <= 0; else if ((!o_wb_cyc)&&( (w_pc_out_of_bounds) ||(w_ran_off_end_of_cache))) r_cache_offset <= 0; else if ((!o_wb_cyc)&&(w_running_out_of_cache)) r_cache_offset[1:0] <= r_cache_offset[1:0] + 2'b01;",
            "assign w_cache_offset = { r_cache_offset, {(LGCACHELEN-2){1'b0}} }; // }}} // o_wb_addr // {{{",
            "always @(posedge i_clk) if (i_clear_cache) o_wb_addr <= i_pc[AW+1:2]; else if ((o_wb_cyc)&&(w_pc_out_of_bounds)) begin if (i_wb_ack) o_wb_addr <= r_cache_base + bus_nvalid+1; else o_wb_addr <= r_cache_base + bus_nvalid; end else if ((!o_wb_cyc)&&((w_pc_out_of_bounds) ||(w_ran_off_end_of_cache))) o_wb_addr <= (i_new_pc) ? i_pc[AW+1:2] : r_addr[AW+1:2]; else if ((o_wb_stb)&&(!i_wb_stall)) // && o_wb_cyc o_wb_addr <= o_wb_addr + 1; // }}} // r_acks_waiting // {{{",
            "initial r_acks_waiting = 0;",
            "always @(posedge i_clk) if (!o_wb_cyc) r_acks_waiting <= 0; // o_wb_cyc *must* be true for all following else if ((o_wb_stb)&&(!i_wb_stall)&&(!i_wb_ack)) //&&(o_wb_cyc) r_acks_waiting <= r_acks_waiting + {{(LGCACHELEN){1'b0}},1'b1}; else if ((i_wb_ack)&&((!o_wb_stb)||(i_wb_stall))) //&&(o_wb_cyc) r_acks_waiting <= r_acks_waiting + {(LGCACHELEN+1){1'b1}}; // - 1; // }}} // cache // {{{",
            "always @(posedge i_clk) if ((o_wb_cyc)&&(i_wb_ack)) cache[r_nvalid[(LGCACHELEN-1):0]+w_cache_offset] <= i_wb_data; // }}} // r_addr_set // {{{",
            "initial r_addr_set = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(i_new_pc)) r_addr_set <= 1'b1; else if (i_clear_cache) r_addr_set <= 1'b0; // }}} // Now, read from the cache",
            "assign w_cv = ((r_nvalid != 0)&&(r_addr[AW+1:2]>=r_cache_base) &&(r_addr[AW+1:2]-r_cache_base < bus_nvalid)); // o_v // {{{",
            "initial o_v = 0;",
            "always @(posedge i_clk) if (i_reset || i_new_pc || i_clear_cache) o_v <= 0; else o_v <= ((w_cv)||((!i_stall_n)&&(r_cv))); // }}} // r_addr // {{{",
            "initial r_addr = 0;",
            "always @(posedge i_clk) if (i_new_pc) r_addr <= i_pc; else if (o_v && i_stall_n) begin r_addr[AW+1:2] <= r_addr[AW+1:2] + {{(AW-1){1'b0}},1'b1}; r_addr[1:0] <= 0; end // }}}",
            "assign c_cache_base = r_cache_base[(LGCACHELEN-1):0];",
            "assign c_rdaddr = r_addr[(LGCACHELEN-1):0]-c_cache_base+w_cache_offset; // o_i // {{{",
            "always @(posedge i_clk) if ((!o_v)||((i_stall_n)&&(o_v))) o_i <= cache[c_rdaddr]; // }}} // o_pc // {{{",
            "always @(*) o_pc = r_addr; // }}} // ill_valid // {{{",
            "reg ill_valid;",
            "initial ill_valid = 0;",
            "initial ill_address = 0;",
            "always @(posedge i_clk) if (i_reset) ill_valid <= 0; else if ((o_wb_cyc)&&(i_wb_err)) ill_valid <= 1; // }}} // ill_address // {{{",
            "always @(posedge i_clk) if ((o_wb_cyc)&&(i_wb_err)) ill_address <= o_wb_addr - {{(AW-LGCACHELEN-1){1'b0}}, r_acks_waiting}; // }}} // o_illegal // {{{",
            "assign o_illegal = (ill_valid) && (o_pc == ill_address)&&(o_v); // }}} `ifdef FORMAL //////////////////////////////////////////////////////////////////////// // // Wishbone properties // //////////////////////////////////////////////////////////////////////// // // localparam F_LGDEPTH = LGCACHELEN+1;",
            "wire [F_LGDEPTH-1:0] f_nreqs, f_nacks, f_outstanding; fwb_master #( .AW(ADDRESS_WIDTH), .F_LGDEPTH(F_LGDEPTH), .F_OPT_SOURCE(1) ) fwb( i_clk, i_reset, o_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, 4'h0, i_wb_ack, i_wb_stall, i_wb_data, i_wb_err, f_nreqs, f_nacks, f_outstanding); //////////////////////////////////////////////////////////////////////// // // CPU interface properties // //////////////////////////////////////////////////////////////////////// // // wire [AW+1:0] fc_pc, f_address;",
            "wire [31:0] fc_insn;",
            "wire fc_illegal; ffetch #(.ADDRESS_WIDTH(ADDRESS_WIDTH), .OPT_CONTRACT(1'b0)) cpu( .i_clk(i_clk), .i_reset(i_reset), .cpu_new_pc(i_new_pc), .cpu_clear_cache(i_clear_cache), .cpu_ready(i_stall_n), .cpu_pc(i_pc), .pf_insn(o_i), .pf_valid(o_v), .pf_pc(o_pc), .pf_illegal(o_illegal), .fc_pc(fc_pc), .fc_illegal(fc_illegal), .fc_insn(fc_insn), .f_address(f_address));",
            "always @(*) assume(!o_v || o_pc != fc_pc); //////////////////////////////////////////////////////////////////////// // // Constraining assumptions // //////////////////////////////////////////////////////////////////////// // // always @(*) assume(!i_wb_err);",
            "always @(*) assert(!ill_valid); `endif",
            "endmodule"
        ]
    },
    {
        "file_name": "pfcache.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/pfcache.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: pfcache.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Keeping our CPU fed with instructions, at one per clock and // with only a minimum number stalls. The entire cache may also // be cleared (if necessary). // // This",
            "logic is driven by a couple realities: // 1. It takes a clock to read from a block RAM address, and hence a clock // to read from the cache. // 2. It takes another clock to check that the tag matches // // Our goal will be to avoid this second check if at all possible. // Hence, we'll test on the clock of any given request whether // or not the request matches the last tag value, and on the next // clock whether it new tag value (if it has changed). Hence, // for anything found within the cache, there will be a one // cycle delay on any branch. // // // Address Words are separated into three components: // [ Tag bits ] [ Cache line number ] [ Cache position w/in the line ] // // On any read from the cache, only the second two components are required. // On any read from memory, the first two components will be fixed across // the bus, and the third component will be adjusted from zero to its // maximum value. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module pfcache #( // {{{ `ifdef FORMAL",
            "parameter LGCACHELEN = 4, ADDRESS_WIDTH=30, LGLINES=2, // Log of # of separate cache lines `else",
            "parameter LGCACHELEN = 12, ADDRESS_WIDTH=30, LGLINES=LGCACHELEN-3, // Log of # of separate cache lines `endif",
            "parameter BUS_WIDTH = 32, // Num data bits on the bus",
            "parameter [0:0] OPT_LITTLE_ENDIAN = 1'b0, localparam CACHELEN=(1<<LGCACHELEN), //Wrd Size of cach mem",
            "localparam CW=LGCACHELEN, // Short hand for LGCACHELEN",
            "localparam LS=LGCACHELEN-LGLINES, // Size of a cache line",
            "localparam BUSW = BUS_WIDTH, localparam INSN_WIDTH = 32, localparam WBLSB = $clog2(BUS_WIDTH/8), localparam AW=ADDRESS_WIDTH // Shorthand for ADDRESS_WIDTH // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // // The interface with the rest of the CPU // {{{",
            "input wire i_new_pc, input wire i_clear_cache, input wire i_ready, input wire [AW+WBLSB-1:0] i_pc, output reg o_valid, output reg o_illegal, output wire [INSN_WIDTH-1:0] o_insn, output wire [AW+WBLSB-1:0] o_pc, // }}} // The wishbone bus interface // {{{",
            "output reg o_wb_cyc, o_wb_stb, // verilator coverage_off",
            "output wire o_wb_we, // verilator coverage_on",
            "output reg [AW-1:0] o_wb_addr, // verilator coverage_off",
            "output wire [BUSW-1:0] o_wb_data, // verilator coverage_on // input wire i_wb_stall, i_wb_ack, i_wb_err, input wire [BUSW-1:0] i_wb_data // }}} `ifdef FORMAL , output wire [AW-1:0] f_pc_wb `endif // }}} ); // Declarations // {{{",
            "localparam INLSB = $clog2(INSN_WIDTH/8); // // o_illegal will be true if this instruction was the result of a // bus error (This is also part of the CPU interface) // // Fixed bus",
            "output s: we read from the bus only, never write. // Thus the",
            "output data is ... irrelevant and don't care. We set it // to zero just to set it to something.",
            "assign o_wb_we = 1'b0;",
            "assign o_wb_data = 0; `ifdef FORMAL",
            "assign f_pc_wb = i_pc[AW+1:2]; `endif",
            "wire r_v;",
            "reg [BUSW-1:0] cache [0:CACHELEN-1];",
            "wire [BUSW-1:0] cache_word;",
            "reg [AW-CW-1:0] cache_tags [0:((1<<(LGLINES))-1)];",
            "reg [((1<<(LGLINES))-1):0] valid_mask;",
            "reg r_v_from_pc, r_v_from_last;",
            "reg rvsrc;",
            "wire w_v_from_pc, w_v_from_last;",
            "reg [AW+WBLSB-1:0] lastpc;",
            "reg [(CW-1):0] wraddr;",
            "reg [AW-1:LS] pc_tag_lookup, last_tag_lookup;",
            "wire [AW-1:LS] tag_lookup;",
            "wire [AW-1:LS] pc_tag, lasttag;",
            "reg illegal_valid;",
            "reg [AW-1:LS] illegal_cache; // initial o_i = 32'h76_00_00_00; // A NOOP instruction // initial o_pc = 0;",
            "reg [BUSW-1:0] r_pc_cache, r_last_cache;",
            "reg [AW+WBLSB-1:0] r_pc;",
            "reg isrc;",
            "reg [1:0] delay;",
            "reg svmask, last_ack, needload, last_addr, bus_abort;",
            "reg [LGLINES-1:0] saddr;",
            "wire w_advance;",
            "wire w_invalidate_result;",
            "wire [CW-LS-1:0] pc_line, last_line; // }}}",
            "assign w_advance = (i_new_pc)||((r_v)&&(i_ready)); //////////////////////////////////////////////////////////////////////// // // Read the instruction from the cache // {{{ //////////////////////////////////////////////////////////////////////// // // // We'll read two values from the cache, the first is the value if // i_pc contains the address we want, the second is the value we'd read // if lastpc (i.e. $past(i_pc)) was the address we wanted.",
            "initial r_pc = 0;",
            "always @(posedge i_clk) begin // We don't have the",
            "logic to select what to read, we must // read both the value at i_pc and lastpc. cache[i_pc] is // the value we return if the last cache request was in the // cache on the last clock, cacne[lastpc] is the value we // return if we've been stalled, weren't valid, or had to wait // a clock or two. // // Part of the issue here is that i_pc is going to increment // on this clock before we know whether or not the cache entry // we've just read is valid. We can't stop this. Hence, we // need to read from the lastpc entry. // // // Here we keep track of which answer we want/need. // If we reported a valid value to the CPU on the last clock, // and the CPU wasn't stalled, then we want to use i_pc. // Likewise if the CPU gave us an i_new_pc request, then we'll // want to return the value associated with reading the cache // at i_pc. isrc <= w_advance; // Here we read both cache entries, at i_pc and lastpc. // We'll select from among these cache possibilities on the // next clock r_pc_cache <= cache[i_pc[WBLSB +: CW]]; r_last_cache <= cache[lastpc[WBLSB +: CW]]; // // Let's also",
            "reg ister(delay) the r_pc value for the next // clock, so we can accurately report the address of the cache // value we just looked up. if (w_advance) r_pc <= i_pc; else r_pc <= lastpc; end // On our next clock, our result with either be the",
            "reg istered i_pc // value from the last clock (if isrc), otherwise r_lastpc",
            "assign o_pc = r_pc; // The same applies for determining what the next",
            "output instruction // will be. We just read it in the last clock, now we just need to // select between the two possibilities we just read.",
            "assign cache_word = (isrc) ? r_pc_cache : r_last_cache; generate if (BUS_WIDTH == INSN_WIDTH) begin : GEN_INSN",
            "assign o_insn = cache_word; end else begin : SHIFT_INSN",
            "wire [BUS_WIDTH-1:0] shifted;",
            "wire [WBLSB-INLSB-1:0] shift;",
            "assign shift = r_pc[WBLSB-1:INLSB]; if (OPT_LITTLE_ENDIAN) begin : GEN_LIL_ENDIAN_SHIFT",
            "assign shifted = cache_word >> (INSN_WIDTH*shift);",
            "assign o_insn= shifted[INSN_WIDTH-1:0]; end else begin : BIG_ENDIAN_SHIFT",
            "assign shifted = cache_word << (INSN_WIDTH*shift);",
            "assign o_insn=shifted[BUS_WIDTH-1:BUS_WIDTH-INSN_WIDTH]; end // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_shift;",
            "assign unused_shift = &{ 1'b0, shifted }; // Verilator lint_on UNUSED // Verilator coverage_on end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Read the tag value associated with this cache line // {{{ //////////////////////////////////////////////////////////////////////// // // assign pc_tag = i_pc[WBLSB+LS +: (AW-LS)];",
            "assign pc_line = i_pc[WBLSB+LS +: (CW-LS)];",
            "assign last_line = lastpc[WBLSB+LS +: (CW-LS)]; // // Read the tag value associated with this i_pc value",
            "always @(posedge i_clk) pc_tag_lookup <= { cache_tags[pc_line], pc_line }; // tagvalipc <= cache_tags[i_pc[WBLSB + LS +: (CW-LS)]]; // // Read the tag value associated with the lastpc value, from what // i_pc was when we could not tell if this value was in our cache or // not, or perhaps from when we determined that i was not in the cache. // initial tagvallst = 0;",
            "always @(posedge i_clk) last_tag_lookup <= { cache_tags[last_line], last_line }; // tagvallst <= cache_tags[lastpc[WBLSB + LS +: (CW-LS)]]; // Select from between these two values on the next clock",
            "assign tag_lookup = (isrc)? pc_tag_lookup : last_tag_lookup; // i_pc will only increment when everything else isn't stalled, thus // we can set it without worrying about that. Doing this enables // us to work in spite of stalls. For example, if the next address // isn't valid, but the decoder is stalled, get the next address // anyway.",
            "initial lastpc = 0;",
            "always @(posedge i_clk) if (w_advance) lastpc <= i_pc;",
            "assign lasttag = lastpc[WBLSB + LS +: (AW-LS)]; // }}} //////////////////////////////////////////////////////////////////////// // // Use the tag value to determine if our",
            "output instruction will be // valid. // {{{ //////////////////////////////////////////////////////////////////////// // // assign w_v_from_pc = ((pc_tag == lasttag) &&(tag_lookup == pc_tag) && valid_mask[pc_line]);",
            "assign w_v_from_last = ((tag_lookup == lasttag) &&(valid_mask[last_line]));",
            "initial delay = 2'h3;",
            "always @(posedge i_clk) if (i_reset || i_clear_cache || w_advance) begin // Source our valid signal from i_pc rvsrc <= 1'b1; // Delay at least two clocks before declaring that // we have an invalid result. This will give us time // to check the tag value of what's in the cache. delay <= 2'h2; end else if (!r_v && !o_illegal) begin // If we aren't sourcing our valid signal from the // i_pc clock, then we are sourcing it from the // lastpc clock (one clock later). If r_v still // isn't valid, we may need to make a bus request. // Apply our timer and timeout. rvsrc <= 1'b0; // Delay is two once the bus starts, in case the // bus transaction needs to be restarted upon completion // This might happen if, after we start loading the // cache, we discover a branch. The cache load will // still complete, but the branches address needs to be // the onen we jump to. This may mean we need to load // the cache twice. if (o_wb_cyc) delay <= 2'h2; else if (delay != 0) delay <= delay + 2'b11; // i.e. delay -= 1; end else begin // After sourcing our",
            "output from i_pc, if it wasn't // accepted, source the instruction from the lastpc valid // determination instead rvsrc <= 1'b0; if (o_illegal) delay <= 2'h2; end",
            "assign w_invalidate_result = (i_reset)||(i_clear_cache);",
            "initial r_v_from_pc = 0;",
            "initial r_v_from_last = 0;",
            "always @(posedge i_clk) begin r_v_from_pc <= (w_v_from_pc)&&(!w_invalidate_result) &&(!o_illegal); r_v_from_last <= (w_v_from_last)&&(!w_invalidate_result); end // Now use rvsrc to determine which of the two valid flags we'll be // using: r_v_from_pc (the i_pc address), or r_v_from_last (the lastpc // address)",
            "assign r_v = ((rvsrc)?(r_v_from_pc):(r_v_from_last));",
            "always @(*) o_valid = r_v || o_illegal; // }}} //////////////////////////////////////////////////////////////////////// // // If the instruction isn't in our cache, then we need to load // a new cache line from memory. // {{{ //////////////////////////////////////////////////////////////////////// // // initial needload = 1'b0;",
            "always @(posedge i_clk) if (i_clear_cache || o_wb_cyc) needload <= 1'b0; else if ((w_advance)&&(!o_illegal)) needload <= 1'b0; else needload <= (delay==0)&&(!w_v_from_last) // Prevent us from reloading an illegal address // (i.e. one that produced a bus error) over and over // and over again &&(!illegal_valid ||(lasttag != illegal_cache)); // // Working from the rule that you want to keep complex",
            "logic out of // a state machine if possible, we calculate a \"last_stb\" value one // clock ahead of time. Hence, any time a request is accepted, if // last_stb is also true we'll know we need to drop the strobe line, // having finished requesting a complete cache line.",
            "initial last_addr = 1'b0;",
            "always @(posedge i_clk) if (!o_wb_cyc) last_addr <= 1'b0; else if ((o_wb_addr[(LS-1):1] == {(LS-1){1'b1}}) &&((!i_wb_stall)|(o_wb_addr[0]))) last_addr <= 1'b1; // // \"last_ack\" is almost identical to last_addr, save that this // will be true on the same clock as the last acknowledgment from the // bus. The state machine",
            "logic will use this to determine when to // get off the bus and end the wishbone bus cycle.",
            "initial last_ack = 1'b0;",
            "always @(posedge i_clk) last_ack <= (o_wb_cyc)&&( (wraddr[(LS-1):1]=={(LS-1){1'b1}}) &&((wraddr[0])||(i_wb_ack)));",
            "initial bus_abort = 1'b0;",
            "always @(posedge i_clk) if (!o_wb_cyc) bus_abort <= 1'b0; else if (i_clear_cache || i_new_pc) bus_abort <= 1'b1; // // Here's the difficult piece of state machine",
            "logic --the part that // determines o_wb_cyc and o_wb_stb. We've already moved most of the // complicated",
            "logic off of this statemachine, calculating it one cycle // early. As a result, this is a fairly easy piece of",
            "logic .",
            "initial o_wb_cyc = 1'b0;",
            "initial o_wb_stb = 1'b0;",
            "always @(posedge i_clk) if (i_reset || i_clear_cache) begin o_wb_cyc <= 1'b0; o_wb_stb <= 1'b0; end else if (o_wb_cyc) begin if (i_wb_err) o_wb_stb <= 1'b0; else if (o_wb_stb && !i_wb_stall && last_addr) o_wb_stb <= 1'b0; if ((i_wb_ack && last_ack )|| i_wb_err) o_wb_cyc <= 1'b0; end else if (needload && !i_new_pc) begin o_wb_cyc <= 1'b1; o_wb_stb <= 1'b1; end // If we are reading from this cache line, then once we get the first // acknowledgement, this cache line has the new tag value",
            "always @(posedge i_clk) if (o_wb_cyc && i_wb_ack) cache_tags[o_wb_addr[(CW-1):LS]] <= o_wb_addr[(AW-1):CW]; // On each acknowledgment, increment the address we use to write into // our cache. Hence, this is the write address into our cache block // RAM.",
            "initial wraddr = 0;",
            "always @(posedge i_clk) if (o_wb_cyc && i_wb_ack && !last_ack) wraddr[LS-1:0] <= wraddr[LS-1:0] + 1'b1; else if (!o_wb_cyc) wraddr <= { last_line, {(LS){1'b0}} }; // // The wishbone request address. This has meaning anytime o_wb_stb // is active, and needs to be incremented any time an address is // accepted--WITH THE EXCEPTION OF THE LAST ADDRESS. We need to keep // this steady for that last address, unless the last address returns // a bus error. In that case, the whole cache line will be marked as // invalid--but we'll need the value of this",
            "reg ister to know how // to do that propertly.",
            "initial o_wb_addr = {(AW){1'b0}};",
            "always @(posedge i_clk) if ((o_wb_stb)&&(!i_wb_stall)&&(!last_addr)) o_wb_addr[(LS-1):0] <= o_wb_addr[(LS-1):0]+1'b1; else if (!o_wb_cyc) o_wb_addr <= { lasttag, {(LS){1'b0}} }; // Since it is impossible to",
            "initial ize an array, our cache will start // up cache un",
            "initial ized. We'll also never get a valid ack without // cyc being active, although we might get one on the clock after // cyc was active--so we need to test and gate on whether o_wb_cyc // is true. // // wraddr will advance forward on every clock cycle where ack is true, // hence we don't need to check i_wb_ack here. This will work because // multiple writes to the same address, ending with a valid write, // will",
            "always yield the valid write's value only after our bus cycle // is over.",
            "always @(posedge i_clk) if (o_wb_cyc) cache[wraddr] <= i_wb_data; // VMask ... is a section loaded? // Note \"svmask\". It's purpose is to delay the valid_mask setting by // one clock, so that we can insure the right value of the cache is // loaded before declaring that the cache line is valid. Without // this, the cache line would get read, and the instruction would // read from the last cache line.",
            "initial valid_mask = 0;",
            "initial svmask = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(i_clear_cache)) begin valid_mask <= 0; svmask<= 1'b0; end else begin svmask <= (o_wb_cyc && i_wb_ack && last_ack && !bus_abort); if (svmask) valid_mask[saddr] <= !bus_abort; if (!o_wb_cyc && needload) valid_mask[last_line] <= 1'b0; end",
            "always @(posedge i_clk) if ((o_wb_cyc)&&(i_wb_ack)) saddr <= wraddr[(CW-1):LS]; // }}} //////////////////////////////////////////////////////////////////////// // // Handle bus errors here. If a bus read request // returns an error, then we'll mark the entire // line as having a (valid) illegal value. // {{{ //////////////////////////////////////////////////////////////////////// // // // initial illegal_cache = 0;",
            "initial illegal_valid = 0;",
            "always @(posedge i_clk) if ((i_reset)||(i_clear_cache)) begin illegal_cache <= 0; illegal_valid <= 0; end else if ((o_wb_cyc)&&(i_wb_err)) begin illegal_cache <= o_wb_addr[(AW-1):LS]; illegal_valid <= 1'b1; end else if ((o_wb_cyc)&&(i_wb_ack)&&(last_ack)&&(!bus_abort) &&(wraddr[(CW-1):LS] == illegal_cache[CW-1:LS])) illegal_valid <= 1'b0;",
            "initial o_illegal = 1'b0;",
            "always @(posedge i_clk) if (i_reset || i_clear_cache || i_new_pc) o_illegal <= 1'b0; // else if ((o_illegal)||((o_valid)&&(i_ready))) // o_illegal <= 1'b0; else if (!o_illegal) begin o_illegal <= (!i_wb_err)&&(illegal_valid)&&(!isrc) &&(illegal_cache == lasttag); end // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal property section // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Declarations, reset, and f_past_valid // {{{",
            "localparam F_LGDEPTH=LS+1;",
            "reg f_past_valid;",
            "reg [4:0] f_cpu_delay;",
            "reg [((1<<(LGLINES))-1):0] f_past_valid_mask;",
            "reg [AW+WBLSB-1:0] f_next_pc;",
            "reg [AW+WBLSB-1:0] f_next_lastpc;",
            "wire [WBLSB+AW-1:0] f_const_addr, f_address;",
            "wire f_const_illegal;",
            "wire [BUSW-1:0] f_const_insn;",
            "wire [(F_LGDEPTH-1):0] f_nreqs, f_nacks, f_outstanding;",
            "wire [INSN_WIDTH-1:0] f_insn; (* anyconst *)",
            "reg [BUS_WIDTH-1:0] f_const_word; // Keep track of a flag telling us whether or not $past() // will return valid results",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; // // Assume we start from a reset condition",
            "always @(*) if (!f_past_valid) assume(i_reset); // }}} //////////////////////////////////////////////////////////////////////// // // Assumptions about our",
            "input s // {{{ //////////////////////////////////////////////////////////////////////// // // ffetch #( // {{{ .ADDRESS_WIDTH(AW + WBLSB-INLSB), .OPT_CONTRACT(1'b1) // }}} ) fcpu( // {{{ .i_clk(i_clk), .i_reset(i_reset), .cpu_new_pc(i_new_pc), .cpu_clear_cache(i_clear_cache), .cpu_pc(i_pc), .cpu_ready(i_ready), .pf_valid(o_valid), .pf_insn(o_insn), .pf_pc(o_pc), .pf_illegal(o_illegal), .fc_pc(f_const_addr), .fc_illegal(f_const_illegal), .fc_insn(f_const_insn), .f_address(f_address) // }}} ); generate if (INSN_WIDTH == BUS_WIDTH) begin : F_CONST_NOSHIFT",
            "always @(*) assume(f_const_word == f_const_insn); end else begin : F_CONST_SHIFT",
            "wire [WBLSB-INLSB-1:0] f_shift;",
            "wire [BUS_WIDTH-1:0] f_shifted;",
            "wire [INSN_WIDTH-1:0] f_insn_check;",
            "assign f_shift = f_const_addr[WBLSB-1:INLSB]; if (OPT_LITTLE_ENDIAN) begin",
            "assign f_shifted = f_const_word >> (INSN_WIDTH * f_shift);",
            "assign f_insn_check = f_shifted[INSN_WIDTH-1:0]; end else begin",
            "assign f_shifted = f_const_word << (INSN_WIDTH * f_shift);",
            "assign f_insn_check = f_shifted[BUS_WIDTH-1:BUS_WIDTH-INSN_WIDTH]; end",
            "always @(*) assume(f_insn_check == f_const_insn); end endgenerate // // Let's make some assumptions about how long it takes our // phantom bus and phantom CPU to respond. // // These delays need to be long enough to flush out any potential // errors, yet still short enough that the formal method doesn't // take forever to solve. // localparam F_CPU_DELAY = 4; // Now, let's repeat this bit but now looking at the delay the CPU // takes to accept an instruction.",
            "always @(posedge i_clk) // If no instruction is ready, then keep our counter at zero if ((!o_valid)||(i_ready)) f_cpu_delay <= 0; else // Otherwise, count the clocks the CPU takes to respond f_cpu_delay <= f_cpu_delay + 1'b1; `ifdef PFCACHE",
            "always @(posedge i_clk) assume(f_cpu_delay < F_CPU_DELAY); `endif // }}} //////////////////////////////////////////////////////////////////////// // // // //////////////////////////////////////////////////////////////////////// // // always @(*) if (o_wb_cyc && !bus_abort) assert(!o_valid); //////////////////////////////////////////////////////////////////////// // // Assertions about our",
            "output s // {{{ //////////////////////////////////////////////////////////////////////// // // fwb_master #( // {{{ .AW(AW), .DW(BUSW), .F_LGDEPTH(F_LGDEPTH), .F_MAX_STALL(2), .F_MAX_ACK_DELAY(3), .F_MAX_REQUESTS(1<<LS), .F_OPT_SOURCE(1), .F_OPT_RMW_BUS_OPTION(0), .F_OPT_DISCONTINUOUS(0) // }}} ) f_wbm( // {{{ i_clk, i_reset, o_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, {(BUSW/8){1'b1}}, i_wb_ack, i_wb_stall, i_wb_data, i_wb_err, f_nreqs, f_nacks, f_outstanding // }}} ); // writes are also illegal for a prefetch.",
            "always @(posedge i_clk) if (o_wb_stb) assert(!o_wb_we);",
            "always @(posedge i_clk) begin assert(f_nreqs <= (1<<LS)); if ((o_wb_cyc)&&(o_wb_stb)) assert(f_nreqs == o_wb_addr[(LS-1):0]); if ((f_past_valid)&&($past(o_wb_cyc)) &&(!o_wb_stb)&&(!$past(i_wb_err || i_reset || i_clear_cache))) assert(f_nreqs == (1<<LS)); end",
            "always @(posedge i_clk) if (f_past_valid) begin if ((!o_wb_cyc)&&($past(o_wb_cyc))&&(!$past(i_reset)) &&(!$past(i_clear_cache)) &&(!$past(i_wb_err))) begin assert(f_nacks == (1<<LS)); end else if (o_wb_cyc) assert(f_nacks[(LS-1):0] == wraddr[(LS-1):0]); end // The last-ack line",
            "always @(posedge i_clk) if (o_wb_cyc) assert(last_ack == (f_nacks == ((1<<LS)-1))); // The valid line for whats being read",
            "always @(posedge i_clk) if (o_wb_cyc) assert(!valid_mask[o_wb_addr[CW-1:LS]]);",
            "always @(posedge i_clk) if ((illegal_valid)&&(o_wb_cyc)) assert(o_wb_addr[AW-1:LS] != illegal_cache);",
            "initial f_past_valid_mask = 0;",
            "always @(posedge i_clk) f_past_valid_mask <= valid_mask;",
            "always @(posedge i_clk) if ((o_valid)&&($past(!o_valid || !o_illegal))) assert((!o_wb_cyc) ||(o_wb_addr[AW-1:LS] != o_pc[WBLSB+LS +: (AW-LS)]));",
            "always @(posedge i_clk) if (illegal_valid) begin assert((!o_wb_cyc) ||(o_wb_addr[AW-1:LS] != illegal_cache)); // The illegal cache line should never be valid within our // cache assert((!valid_mask[illegal_cache[CW-1:LS]]) ||(cache_tags[illegal_cache[CW-1:LS]] != illegal_cache[AW-1:CW])); end // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about our return responses to the CPU // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (INSN_WIDTH == BUS_WIDTH) begin : F_OWORD_NOSHIFT",
            "assign f_insn = cache[o_pc[WBLSB +: CW]]; end else begin : F_OWORD_SHIFT",
            "wire [WBLSB-INLSB-1:0] f_shift;",
            "wire [BUS_WIDTH-1:0] f_shifted;",
            "assign f_shift = o_pc[WBLSB-1:INLSB]; if (OPT_LITTLE_ENDIAN) begin",
            "assign f_shifted = cache[o_pc[WBLSB +: CW]] >> (INSN_WIDTH * f_shift);",
            "assign f_insn = f_shifted[INSN_WIDTH-1:0]; end else begin",
            "assign f_shifted = cache[o_pc[WBLSB +: CW]] << (INSN_WIDTH * f_shift);",
            "assign f_insn = f_shifted[BUS_WIDTH-1:BUS_WIDTH-INSN_WIDTH]; end end endgenerate",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_wb_cyc))) assert(o_wb_addr[(AW-1):LS] == $past(o_wb_addr[(AW-1):LS]));",
            "always @(posedge i_clk) if (o_valid && !i_new_pc) begin if (!o_illegal) begin assert(valid_mask[o_pc[WBLSB+LS +: (CW-LS)]]); assert(cache_tags[o_pc[WBLSB+LS +: (CW-LS)]] == o_pc[WBLSB+CW +: (AW-CW)]); assert(o_insn == f_insn); assert((!illegal_valid) ||(illegal_cache != o_pc[WBLSB+LS +: (AW-LS)])); end if ($rose(o_illegal)) assert(o_illegal == ($past(illegal_valid) &&($past(illegal_cache)== o_pc[WBLSB+LS +: (AW-LS)]))); end else if (!i_reset && !i_new_pc && !i_clear_cache) assert(o_pc == f_address);",
            "always @(*) if (!i_reset && !i_new_pc && !i_clear_cache) assert(o_illegal || o_pc == f_address);",
            "always @(*) begin f_next_lastpc = lastpc + 4; f_next_lastpc[1:0] = 2'b00; end",
            "always @(posedge i_clk) if ((f_past_valid)&& !$past(i_reset || i_clear_cache) && !o_illegal && !i_new_pc && !i_clear_cache) begin assert(lastpc == r_pc); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(o_valid)&&($past(o_valid)) &&(!$past(i_reset)) &&(!$past(i_new_pc)) &&(!$past(i_ready)) &&(!o_illegal)) begin assert(cache_tags[o_pc[WBLSB+LS +: (CW-LS)]] == o_pc[WBLSB+CW +: (AW-CW)]); end // // If an instruction is accepted, we should *",
            "always * move on to another // instruction. The only exception is following an i_new_pc (or // other invalidator), at which point the next instruction should // be invalid.",
            "always @(posedge i_clk) if ((f_past_valid)&& $past(o_valid && i_ready && !o_illegal && !i_new_pc)) begin // Should",
            "always advance the instruction assert((!o_valid)||(o_pc != $past(o_pc))); end // // Once an instruction becomes valid, it should never become invalid // unless there's been a request for a new instruction.",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset || i_clear_cache)) begin assert(!o_valid); assert(!o_illegal); end else if ($past(o_valid && !i_ready && !i_new_pc)) begin if (!$past(o_illegal)) begin assert(o_valid); assert(!o_illegal); assert($stable(o_insn)); end else assert(o_illegal); end // }}} //////////////////////////////////////////////////////////////////////// // // Contract checking // {{{ //////////////////////////////////////////////////////////////////////// // // // // Assertions associated with a response to a known address request // That is, if you assume a value exists at an arbitrary address, // prove that this value is returned whenever that arbitrary address's // value gets returned. // wire f_this_pc, f_this_insn, f_this_data, f_this_line, f_this_ack, f_this_tag; // f_this_addr;",
            "wire [LS-1:0] f_const_line;",
            "wire [AW-LS-1:0] f_const_tag;",
            "assign f_const_line = f_const_addr[WBLSB+LS +: (CW-LS)];",
            "assign f_const_tag = f_const_addr[WBLSB+LS +: (AW-LS)];",
            "assign f_this_pc = (o_pc == f_const_addr); // assign f_this_addr = (o_wb_addr == f_const_addr[AW-1:0] );",
            "assign f_this_insn = (o_insn == f_const_insn);",
            "assign f_this_data = (i_wb_data == f_const_word);",
            "assign f_this_line = (o_wb_addr[AW-1:LS] == f_const_tag);",
            "assign f_this_ack = (f_this_line)&&(f_nacks == f_const_addr[WBLSB +: LS]);",
            "assign f_this_tag = (tag_lookup == f_const_tag);",
            "always @(posedge i_clk) if ((o_valid)&&(f_this_pc)&&(!$past(o_illegal))) begin assert(o_illegal == f_const_illegal); if (!o_illegal) begin assert(f_this_insn); assert(f_this_tag); end end",
            "always @(*) if ((valid_mask[f_const_line]) &&(cache_tags[f_const_line]==f_const_addr[WBLSB+CW +: (AW-CW)])) begin assert(f_const_word == cache[f_const_addr[WBLSB +: CW]]); end else if ((o_wb_cyc)&&(o_wb_addr[AW-1:LS] == f_const_addr[WBLSB+LS +: (AW-LS)]) &&(f_nacks > f_const_addr[WBLSB +: LS])) begin assert(f_const_word == cache[f_const_addr[WBLSB +: CW]]); end",
            "always @(*) if (o_wb_cyc) assert(wraddr[CW-1:LS] == o_wb_addr[CW-1:LS]);",
            "always @(*) if (!f_const_illegal) assert((!illegal_valid) ||(illegal_cache != f_const_tag)); else assert(cache_tags[f_const_line] != f_const_addr[WBLSB+CW +: (AW-CW)] || !valid_mask[f_const_line]);",
            "always @(*) if ((f_this_line)&&(o_wb_cyc)) begin if (f_const_illegal) begin assume(!i_wb_ack); end else assume(!i_wb_err); if ((f_this_ack)&&(i_wb_ack)) assume(f_this_data); end // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // reg f_valid_legal;",
            "always @(*) f_valid_legal = o_valid && (!o_illegal);",
            "always @(posedge i_clk) // Trace 0 cover((o_valid)&&( o_illegal));",
            "always @(posedge i_clk) // Trace 1 cover(f_valid_legal);",
            "always @(posedge i_clk) // Trace 2 cover((f_valid_legal) &&($past(!o_valid && !i_new_pc)) &&($past(i_new_pc,2)));",
            "always @(posedge i_clk) // Trace 3 cover((f_valid_legal)&&($past(i_ready))&&($past(i_new_pc)));",
            "always @(posedge i_clk) // Trace 4 cover((f_valid_legal)&&($past(f_valid_legal && i_ready)));",
            "always @(posedge i_clk) // Trace 5 cover((f_valid_legal) &&($past(f_valid_legal && i_ready)) &&($past(f_valid_legal && i_ready,2)) &&($past(f_valid_legal && i_ready,3)));",
            "always @(posedge i_clk) // Trace 6 cover((f_valid_legal) &&($past(f_valid_legal && i_ready)) &&($past(f_valid_legal && i_ready,2)) &&($past(!o_illegal && i_ready && i_new_pc,3)) &&($past(f_valid_legal && i_ready,4)) &&($past(f_valid_legal && i_ready,5)) &&($past(f_valid_legal && i_ready,6))); // }}} `endif // FORMAL // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "dcache.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/dcache.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: dcache.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: To provide a simple data cache for the ZipCPU. The cache is // designed to be a drop in replacement for the pipememm memory // unit currently existing within the ZipCPU. The goal of this unit is // to achieve single cycle read access to any memory in the last cache line // used, or two cycle access to any memory currently in the cache. // // The cache separates between four types of accesses, one write and three // read access types. The read accesses are split between those that are // not cacheable, those that are in the cache, and those that are not. // // 1. Write accesses",
            "always create writes to the bus. For these reasons, // these may",
            "always be considered cache misses. // // Writes to memory locations within the cache must also update // cache memory immediately, to keep the cache in synch. // // It is our goal to be able to maintain single cycle write // accesses for memory bursts. // // 2. Read access to non-cacheable memory locations will also immediately // go to the bus, just as all write accesses go to the bus. // // 3. Read accesses to cacheable memory locations will immediately read // from the appropriate cache line. However, since thee valid // line will take a second clock to read, it may take up to two // clocks to know if the memory was in cache. For this reason, // we bypass the test for the last validly accessed cache line. // // We shall design these read accesses so that reads to the cache // may take place concurrently with other writes to the bus. // // Errors in cache reads will void the entire cache line. For this reason, // cache lines must",
            "always be of a smaller in size than any associated // virtual page size--lest in the middle of reading a page a TLB miss // take place referencing only a part of the cacheable page. // // // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2016-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // // `ifdef FORMAL `define ASSERT assert `ifdef DCACHE `define ASSUME assume `else `define ASSUME assert `endif `endif // }}}",
            "module dcache #( // {{{",
            "parameter LGCACHELEN = 8, BUS_WIDTH=32, ADDRESS_WIDTH=32-$clog2(BUS_WIDTH/8), LGNLINES=(LGCACHELEN-3), // Log of the number of separate cache lines NAUX=5, // # of aux d-",
            "wire s to keep aligned w/memops",
            "parameter DATA_WIDTH=32, // CPU's",
            "reg ister width",
            "parameter [0:0] OPT_LOCAL_BUS=1'b1, parameter [0:0] OPT_PIPE=1'b1, parameter [0:0] OPT_LOCK=1'b1, parameter [0:0] OPT_DUAL_READ_PORT=1'b1, parameter OPT_FIFO_DEPTH = 4, localparam AW = ADDRESS_WIDTH, // Just for ease of notation below",
            "localparam CS = LGCACHELEN, // Number of bits in a cache address",
            "localparam LS = CS-LGNLINES, // Bits to spec position w/in cline `ifdef FORMAL",
            "parameter F_LGDEPTH=1 + (((!OPT_PIPE)||(LS > OPT_FIFO_DEPTH)) ? LS : OPT_FIFO_DEPTH), `endif",
            "parameter [0:0] OPT_LOWPOWER = 1'b0, // localparam DW = 32, // Bus data width",
            "localparam DP = OPT_FIFO_DEPTH, localparam WBLSB = $clog2(BUS_WIDTH/8), // localparam DLSB = $clog2(DATA_WIDTH/8), // localparam [1:0] DC_IDLE = 2'b00, // Bus is idle",
            "localparam [1:0] DC_WRITE = 2'b01, // Write",
            "localparam [1:0] DC_READS = 2'b10, // Read a single value(!cachd)",
            "localparam [1:0] DC_READC = 2'b11 // Read a whole cache line // }}} ) ( // {{{",
            "input wire i_clk, i_reset, i_clear, // Interface from the CPU // {{{",
            "input wire i_pipe_stb, i_lock, input wire [2:0] i_op, input wire [DATA_WIDTH-1:0] i_addr, input wire [DATA_WIDTH-1:0] i_data, input wire [(NAUX-1):0] i_o",
            "reg , // Aux data, such as",
            "reg to write to // Outputs, going back to the CPU",
            "output reg o_busy, o_rdbusy, output reg o_pipe_stalled, output reg o_valid, o_err, output reg [(NAUX-1):0] o_w",
            "reg , output reg [DATA_WIDTH-1:0] o_data, // }}} // Wishbone bus master",
            "output s // {{{",
            "output wire o_wb_cyc_gbl, o_wb_cyc_lcl, output reg o_wb_stb_gbl, o_wb_stb_lcl, output reg o_wb_we, output reg [(AW-1):0] o_wb_addr, output reg [BUS_WIDTH-1:0] o_wb_data, output wire [BUS_WIDTH/8-1:0] o_wb_sel, // Wishbone bus slave response",
            "input s",
            "input wire i_wb_stall, i_wb_ack, i_wb_err, input wire [BUS_WIDTH-1:0] i_wb_data // }}} // }}} ); // Declarations // {{{",
            "localparam FIF_WIDTH = (NAUX-1)+2+WBLSB; integer ik; `ifdef FORMAL",
            "wire [(F_LGDEPTH-1):0] f_nreqs, f_nacks, f_outstanding;",
            "wire f_pc, f_gie, f_read_cycle;",
            "reg f_past_valid; `endif // // output reg [31:0] o_debug;",
            "reg cyc, stb, last_ack, end_of_line, last_line_stb;",
            "reg r_wb_cyc_gbl, r_wb_cyc_lcl; // npending is the number of pending non-cached operations, counted // from the i_pipe_stb to the o_wb_ack",
            "reg [DP:0] npending;",
            "reg [((1<<LGNLINES)-1):0] c_v; // One bit per cache line, is it valid?",
            "reg [(AW-LS-1):0] c_vtags [0:((1<<LGNLINES)-1)];",
            "reg [BUS_WIDTH-1:0] c_mem [0:((1<<CS)-1)];",
            "reg set_vflag;",
            "reg [1:0] state;",
            "reg [(CS-1):0] wr_addr;",
            "reg [BUS_WIDTH-1:0] cached_iword, cached_rword;",
            "reg lock_gbl, lock_lcl; // To simplify writing to the cache, and the job of the synthesizer to // recognize that a cache write needs to take place, we'll take an extra // clock to get there, and use these c_w...",
            "reg isters to capture the // data in the meantime.",
            "reg c_wr;",
            "reg [BUS_WIDTH-1:0] c_wdata;",
            "reg [BUS_WIDTH/8-1:0] c_wsel;",
            "reg [(CS-1):0] c_waddr;",
            "reg [(AW-LS-1):0] last_tag;",
            "reg last_tag_valid;",
            "wire [(LGNLINES-1):0] i_cline;",
            "wire [(CS-1):0] i_caddr; `ifdef FORMAL",
            "reg [F_LGDEPTH-1:0] f_fill;",
            "reg [AW:0] f_return_address;",
            "reg [AW:0] f_pending_addr;",
            "reg f_pc_pending;",
            "wire [4:0] f_last_",
            "reg , f_addr_",
            "reg ; // Verilator lint_off UNDRIVEN (* anyseq *)",
            "reg [4:0] f_a",
            "reg ; // Verilator lint_on UNDRIVEN `endif",
            "wire cache_miss_inow, w_cachable;",
            "wire raw_cachable_address;",
            "reg r_cachable, r_svalid, r_dvalid, r_rd, r_cache_miss, r_rd_pending;",
            "reg [AW-1:0] r_addr;",
            "wire [(LGNLINES-1):0] r_cline;",
            "wire [(CS-1):0] r_caddr;",
            "wire [(AW-LS-1):0] r_ctag;",
            "reg wr_cstb, r_iv, in_cache;",
            "reg [(AW-LS-1):0] r_itag;",
            "reg [FIF_WIDTH:0] req_data;",
            "reg gie;",
            "reg [BUS_WIDTH-1:0] pre_data, pre_shifted; // }}} // Convenience",
            "assign ments // {{{",
            "assign i_cline = i_addr[WBLSB +LS +: (CS-LS)];",
            "assign i_caddr = i_addr[WBLSB +: CS];",
            "assign cache_miss_inow = (!last_tag_valid) ||(last_tag != i_addr[WBLSB+LS +: (AW-LS)]) ||(!c_v[i_cline]);",
            "assign w_cachable = ((!OPT_LOCAL_BUS) ||(i_addr[DATA_WIDTH-1:DATA_WIDTH-8]!=8'hff)) &&((!i_lock)||(!OPT_LOCK))&&(raw_cachable_address);",
            "assign r_cline = r_addr[(CS-1):LS];",
            "assign r_caddr = r_addr[(CS-1):0];",
            "assign r_ctag = r_addr[(AW-1):LS]; // }}} // Cachability checking // {{{ iscachable chkaddress(i_addr[0 +: AW+WBLSB], raw_cachable_address); // }}} // r_* values // {{{ // The one-clock delayed read values from the cache. // initial r_rd = 1'b0;",
            "initial r_cachable = 1'b0;",
            "initial r_svalid = 1'b0;",
            "initial r_dvalid = 1'b0;",
            "initial r_cache_miss = 1'b0;",
            "initial r_addr = 0;",
            "initial last_tag_valid = 0;",
            "initial r_rd_pending = 0;",
            "always @(posedge i_clk) begin // The single clock path // The valid for the single clock path // Only ... we need to wait if we are currently writing // to our cache. r_svalid<= (i_pipe_stb)&&(!i_op[0])&&(w_cachable) &&(!cache_miss_inow)&&(!c_wr)&&(!wr_cstb); // // The two clock in-cache path // // Some preliminaries that needed to be calculated on the first // clock if ((!o_pipe_stalled)&&(!r_rd_pending)) r_addr <= i_addr[WBLSB +: AW]; if ((!o_pipe_stalled)&&(!r_rd_pending)) begin r_iv <= c_v[i_cline]; // r_itag <= c_vtags[i_cline]; r_cachable <= (!i_op[0])&&(w_cachable)&&(i_pipe_stb); r_rd_pending <= (i_pipe_stb)&&(!i_op[0])&&(w_cachable) &&((cache_miss_inow)||(c_wr)||(wr_cstb)); // &&((!c_wr)||(!wr_cstb)); end else begin r_iv <= c_v[r_cline]; // r_itag <= c_vtags[r_cline]; r_rd_pending <= (r_rd_pending) &&((!cyc)||(!i_wb_err)) &&((r_itag != r_ctag)||(!r_iv)); end r_rd <= (i_pipe_stb)&&(!i_op[0]); // r_itag contains the tag we didn't have available to us on the // last clock, r_ctag is a bit select from r_addr containing a // one clock delayed address. r_dvalid <= (!r_svalid)&&(!r_dvalid)&&(r_itag == r_ctag)&&(r_iv) &&(r_cachable)&&(r_rd_pending); if ((r_itag == r_ctag)&&(r_iv)&&(r_cachable)&&(r_rd_pending)) begin last_tag_valid <= 1'b1; last_tag <= r_ctag; end else if ((state == DC_READC) &&(last_tag[CS-LS-1:0]==r_addr[CS-1:LS]) &&((i_wb_ack)||(i_wb_err))) last_tag_valid <= 1'b0; // r_cache miss takes a clock cycle. It is only ever true for // something that should be cachable, but isn't in the cache. // A cache miss is only true _if_ // 1. A read was requested // 2. It is for a cachable address, AND // 3. It isn't in the cache on the first read // or the second read // 4. The read hasn't yet started to get this address r_cache_miss <= ((!cyc)||(o_wb_we))&&(r_cachable) // One clock path -- miss &&(!r_svalid) // Two clock path -- misses as well &&(r_rd)&&(!r_svalid) &&((r_itag != r_ctag)||(!r_iv)); if (i_clear) last_tag_valid <= 0; if (i_reset) begin // r_rd <= 1'b0; r_cachable <= 1'b0; r_svalid <= 1'b0; r_dvalid <= 1'b0; r_cache_miss <= 1'b0; // r_addr <= 0; r_rd_pending <= 0; last_tag_valid <= 0; end end",
            "always @(posedge i_clk) r_itag <= c_vtags[(!o_pipe_stalled && !r_rd_pending) ? i_cline : r_cline]; // }}} // o_wb_sel, r_sel // {{{ generate if (DATA_WIDTH == BUS_WIDTH) begin : COPY_SEL // {{{",
            "reg [BUS_WIDTH/8-1:0] r_sel;",
            "initial r_sel = 4'hf;",
            "always @(posedge i_clk) if (i_reset) r_sel <= 4'hf; else if (!o_pipe_stalled && (!OPT_LOWPOWER || i_pipe_stb)) begin casez({i_op[2:1], i_addr[1:0]}) 4'b0???: r_sel <= 4'b1111; 4'b100?: r_sel <= 4'b1100; 4'b101?: r_sel <= 4'b0011; 4'b1100: r_sel <= 4'b1000; 4'b1101: r_sel <= 4'b0100; 4'b1110: r_sel <= 4'b0010; 4'b1111: r_sel <= 4'b0001; endcase end else if (OPT_LOWPOWER && !i_wb_stall) r_sel <= 4'h0;",
            "assign o_wb_sel = (state == DC_READC) ? 4'hf : r_sel; // }}} end else begin : GEN_SEL // {{{",
            "reg [DATA_WIDTH/8-1:0] pre_sel;",
            "reg [BUS_WIDTH/8-1:0] full_sel, r_wb_sel;",
            "always @(*) casez(i_op[2:1]) 2'b0?: pre_sel = {(DATA_WIDTH/8){1'b1}}; 2'b10: pre_sel = { 2'b11, {(DATA_WIDTH/8-2){1'b0}} }; 2'b11: pre_sel = { 1'b1, {(DATA_WIDTH/8-1){1'b0}} }; endcase",
            "always @(*) if (OPT_LOCAL_BUS && (&i_addr[31:24])) full_sel = { {(BUS_WIDTH/8-4){1'b0}}, pre_sel } >> (i_addr[1:0]); else full_sel = { pre_sel, {(BUS_WIDTH/8-4){1'b0}} } >> (i_addr[WBLSB-1:0]);",
            "initial r_wb_sel = -1;",
            "always @(posedge i_clk) if (i_reset) r_wb_sel <= -1; else if (i_pipe_stb && (i_op[0] || !w_cachable)) r_wb_sel <= full_sel; else if (!i_wb_stall) r_wb_sel <= -1;",
            "assign o_wb_sel = r_wb_sel; // }}} end endgenerate // }}} // o_wb_data // {{{ generate if (DATA_WIDTH == BUS_WIDTH) begin : GEN_SAME_BUSWIDTH // {{{",
            "initial o_wb_data = 0;",
            "always @(posedge i_clk) if (i_reset) o_wb_data <= 0; else if ((!o_busy || !i_wb_stall) && (!OPT_LOWPOWER || i_pipe_stb)) begin if (DATA_WIDTH == 32) begin if (OPT_LOWPOWER) begin : ZERO_UNUSED_DATA_BITS casez({ i_op[2:1], i_addr[1:0] }) 4'b0???: o_wb_data <= i_data; 4'b100?: o_wb_data <= { i_data[15:0], 16'h0 }; 4'b101?: o_wb_data <= { 16'h0, i_data[15:0] }; 4'b1100: o_wb_data <= { i_data[7:0], 24'h0 }; 4'b1101: o_wb_data <= { 8'h0, i_data[7:0], 16'h0 }; 4'b1110: o_wb_data <= { 16'h0, i_data[7:0], 8'h0 }; 4'b1111: o_wb_data <= { 24'h0, i_data[7:0] }; endcase end else begin : DUPLICATE_UNUSED_DATA_BITS casez(i_op[2:1]) 2'b0?: o_wb_data <= i_data; 2'b10: o_wb_data <= { (2){i_data[15:0]} }; 2'b11: o_wb_data <= { (4){i_data[ 7:0]} }; endcase end end else begin // Verilator coverage_off casez(i_op[2:1]) 2'b0?: o_wb_data <= i_data << (8*i_addr[$clog2(DATA_WIDTH)-1:0]); 2'b10: o_wb_data <= { 16'h0, i_data[15:0] } << (8*i_addr[$clog2(DATA_WIDTH)-1:0]); 2'b11: o_wb_data <= { 24'h0, i_data[7:0] } << (8*i_addr[$clog2(DATA_WIDTH)-1:0]); endcase // Verilator coverage_on end end else if (OPT_LOWPOWER && !i_wb_stall) o_wb_data <= 0; // }}} end else begin : GEN_WIDE_BUS // {{{",
            "reg [DATA_WIDTH-1:0] pre_shift;",
            "reg [BUS_WIDTH-1:0] wide_preshift, shifted_data;",
            "always @(*) begin casez(i_op[2:1]) 2'b0?: pre_shift = i_data; 2'b10: pre_shift = { i_data[15:0], {(DATA_WIDTH-16){1'b0}} }; 2'b11: pre_shift = { i_data[ 7:0], {(DATA_WIDTH- 8){1'b0}} }; endcase if (OPT_LOCAL_BUS && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8])) begin wide_preshift = { {(BUS_WIDTH-DATA_WIDTH){1'b0}}, pre_shift }; shifted_data = wide_preshift >> (8*i_addr[2-1:0]); end else begin wide_preshift = { pre_shift, {(BUS_WIDTH-DATA_WIDTH){1'b0}} }; shifted_data = wide_preshift >> (8*i_addr[WBLSB-1:0]); end end",
            "initial o_wb_data = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && i_reset) o_wb_data <= 0; else if ((!o_busy || !i_wb_stall) && (!OPT_LOWPOWER || (i_pipe_stb && i_op[0]))) begin if (!OPT_LOWPOWER) begin casez(i_op[2:1]) 2'b0?: o_wb_data <= {(BUS_WIDTH/DATA_WIDTH){i_data}}; 2'b10: o_wb_data <= {(BUS_WIDTH/16){i_data[15:0]}}; 2'b11: o_wb_data <= {(BUS_WIDTH/ 8){i_data[ 7:0]}}; endcase end else begin o_wb_data <= shifted_data; end end else if (OPT_LOWPOWER && !i_wb_stall) o_wb_data <= 0; // }}} end endgenerate // }}} // Register return FIFO // {{{ generate if (OPT_PIPE) begin : OPT_PIPE_FIFO // {{{",
            "reg [FIF_WIDTH-1:0] fifo_data [0:((1<<OPT_FIFO_DEPTH)-1)];",
            "reg [DP:0] wraddr, rdaddr;",
            "always @(posedge i_clk) if (i_pipe_stb) fifo_data[wraddr[DP-1:0]] <= { i_o",
            "reg [NAUX-2:0], i_op[2:1], i_addr[WBLSB-1:0] };",
            "always @(posedge i_clk) if (i_pipe_stb) gie <= i_o",
            "reg [NAUX-1]; `ifdef NO_BKRAM",
            "reg [FIF_WIDTH-1:0] r_req_data, r_last_data;",
            "reg single_write;",
            "always @(posedge i_clk) r_req_data <= fifo_data[rdaddr[DP-1:0]];",
            "always @(posedge i_clk) single_write <= (rdaddr == wraddr)&&(i_pipe_stb);",
            "always @(posedge i_clk) if (i_pipe_stb) r_last_data <= { i_o",
            "reg [NAUX-2:0], i_op[2:1], i_addr[WBLSB-1:0] };",
            "always @(*) begin req_data[NAUX+4-1] = gie; // if ((r_svalid)||(state == DC_READ)) if (single_write) req_data[FIF_WIDTH-1:0] = r_last_data; else req_data[FIF_WIDTH-1:0] = r_req_data; end",
            "always @(*) `ASSERT(req_data == fifo_data[rdaddr[DP-1:0]]); `else",
            "always @(*) req_data[FIF_WIDTH-1:0] = fifo_data[rdaddr[DP-1:0]];",
            "always @(*) req_data[FIF_WIDTH] = gie; `endif",
            "initial wraddr = 0;",
            "always @(posedge i_clk) if ((i_reset)||((cyc)&&(i_wb_err))) wraddr <= 0; else if (i_pipe_stb) wraddr <= wraddr + 1'b1;",
            "initial rdaddr = 0;",
            "always @(posedge i_clk) if ((i_reset)||((cyc)&&(i_wb_err))) rdaddr <= 0; else if ((r_dvalid)||(r_svalid)) rdaddr <= rdaddr + 1'b1; else if ((state == DC_WRITE)&&(i_wb_ack)) rdaddr <= rdaddr + 1'b1; else if ((state == DC_READS)&&(i_wb_ack)) rdaddr <= rdaddr + 1'b1; `ifdef FORMAL",
            "reg [AW-1:0] f_fifo_addr [0:((1<<OPT_FIFO_DEPTH)-1)];",
            "reg [F_LGDEPTH-1:0] f_last_wraddr;",
            "reg [FIF_WIDTH:0] f_last_data;",
            "always @(*) begin f_fill = 0; f_fill[DP:0] = wraddr - rdaddr; end",
            "always @(*) `ASSERT(f_fill <= { 1'b1, {(DP){1'b0}} });",
            "always @(*) if ((r_dvalid)||(r_svalid)) begin if (r_svalid) begin `ASSERT(f_fill == 1); end else if (r_dvalid) begin `ASSERT(f_fill == 1); end else `ASSERT(f_fill == 0); end else if (r_rd_pending) begin `ASSERT(f_fill == 1); end else `ASSERT(f_fill == npending);",
            "initial f_pc_pending = 0;",
            "always @(posedge i_clk) if (i_reset) f_pc_pending <= 1'b0; else if (i_pipe_stb) f_pc_pending <= (!i_op[0])&&(i_o",
            "reg [3:1] == 3'h7); else if (f_fill == 0) f_pc_pending <= 1'b0; //else if ((o_valid)&&(o_w",
            "reg [3:1] == 3'h7)&&(f_fill == 0)) // f_pc_pending <= 1'b0;",
            "always @(posedge i_clk) if (f_pc_pending) begin `ASSUME(!i_pipe_stb); end",
            "always @(posedge i_clk) if (state == DC_WRITE) begin `ASSERT(!f_pc_pending); end",
            "always @(*) begin f_last_wraddr = 0; f_last_wraddr[DP:0] = wraddr - 1'b1; end",
            "assign f_last_data = fifo_data[f_last_wraddr];",
            "always @(posedge i_clk) if (r_rd_pending) begin `ASSERT(f_pc_pending == (f_last_data[1+WBLSB+2 +: 3] == 3'h7)); `ASSERT({ gie, f_last_data[2+WBLSB +: 4] } == f_last_",
            "reg ); end `define INSPECT_FIFO",
            "reg [((1<<(DP+1))-1):0] f_valid_fifo_entry; genvar gk; for(gk=0; gk<(1<<(DP+1)); gk=gk+1) begin",
            "always @(*) begin f_valid_fifo_entry[gk] = 1'b0; /* if ((rdaddr[DP] != wraddr[DP]) &&(rdaddr[DP-1:0] == wraddr[DP-1:0])) f_valid_fifo_entry[k] = 1'b1; else */ if ((rdaddr < wraddr)&&(gk < wraddr) &&(gk >= rdaddr)) f_valid_fifo_entry[gk] = 1'b1; else if ((rdaddr > wraddr)&&(gk >= rdaddr)) f_valid_fifo_entry[gk] = 1'b1; else if ((rdaddr > wraddr)&&(gk < wraddr)) f_valid_fifo_entry[gk] = 1'b1; end `ifdef INSPECT_FIFO",
            "wire [FIF_WIDTH-1:0] fifo_data_k;",
            "assign fifo_data_k = fifo_data[gk[DP-1:0]];",
            "always @(*) if (f_valid_fifo_entry[gk]) begin if (!f_pc_pending) begin `ASSERT((o_wb_we)||(fifo_data_k[1+2+WBLSB +: 3] != 3'h7)); end else if (gk != f_last_wraddr) `ASSERT(fifo_data_k[1+2+WBLSB +: 3] != 3'h7); end `endif // INSPECT_FIFO end `ifndef INSPECT_FIFO",
            "always @(posedge i_clk) if ((r_rd_pending)&&(rdaddr[DP:0] != f_last_wraddr[DP-1])) assume(req_data[1+2+WBLSB +: 3] != 3'h7); `endif // INSPECT_FIFO // // // always @(*) begin f_pending_addr[AW-1:0] = f_fifo_addr[rdaddr]; f_pending_addr[AW] = r_wb_cyc_lcl; end // // // always @(posedge i_clk) if (i_pipe_stb) begin if (OPT_LOCAL_BUS && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8])) f_fifo_addr[wraddr[DP-1:0]] <= { 1'b1, i_addr[2 +: AW] }; else f_fifo_addr[wraddr[DP-1:0]] <= { 1'b0, i_addr[WBLSB +: AW] }; end",
            "always @(*) begin f_return_address[AW] = (o_wb_cyc_lcl); f_return_address[AW-1:0] = f_fifo_addr[rdaddr]; if (state == DC_READC) f_return_address[LS-1:0] = (o_wb_addr[LS-1:0] - f_outstanding[LS-1:0]); end `define TWIN_WRITE_TEST `ifdef TWIN_WRITE_TEST",
            "reg [DP:0] f_twin_next; // Verilator lint_off UNDRIVEN (* anyconst *)",
            "reg [DP:0] f_twin_base; (* anyconst *)",
            "reg [AW+FIF_WIDTH-1:0] f_twin_first, f_twin_second; // Verilator lint_on UNDRIVEN",
            "reg f_twin_none, f_twin_single, f_twin_double, f_twin_last;",
            "reg f_twin_valid_one, f_twin_valid_two;",
            "always @(*) f_twin_next = f_twin_base+1;",
            "always @(*) begin f_twin_valid_one = ((f_valid_fifo_entry[f_twin_base]) &&(f_twin_first == { f_fifo_addr[f_twin_base[DP-1:0]], fifo_data[f_twin_base[DP-1:0]] })); f_twin_valid_two = ((f_valid_fifo_entry[f_twin_next]) &&(f_twin_second == { f_fifo_addr[f_twin_next[DP-1:0]], fifo_data[f_twin_next[DP-1:0]] })); end",
            "always @(*) begin f_twin_none =(!f_twin_valid_one)&&(!f_twin_valid_two); f_twin_single =( f_twin_valid_one)&&(!f_twin_valid_two); f_twin_double =( f_twin_valid_one)&&( f_twin_valid_two); f_twin_last =(!f_twin_valid_one)&&( f_twin_valid_two); end",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))||($past(cyc && i_wb_err))) begin `ASSERT(f_twin_none); end else if ($past(f_twin_none)) begin `ASSERT(f_twin_none || f_twin_single || f_twin_last); end else if ($past(f_twin_single)) begin `ASSERT(f_twin_none || f_twin_single || f_twin_double || f_twin_last); end else if ($past(f_twin_double)) begin `ASSERT(f_twin_double || f_twin_last); end else if ($past(f_twin_last)) `ASSERT(f_twin_none || f_twin_single || f_twin_last); // f_addr_",
            "reg test // {{{",
            "always @(*) if (o_rdbusy) begin if (f_twin_valid_one && f_twin_base != f_last_wraddr) `ASSERT({ gie, f_twin_first[2+WBLSB +: 4] } != f_addr_",
            "reg ); if (f_twin_valid_two && f_twin_next != f_last_wraddr) `ASSERT({ gie, f_twin_second[2+WBLSB +: 4] } != f_addr_",
            "reg ); if ((rdaddr != f_last_wraddr)&&(rdaddr != f_twin_base) &&(rdaddr != f_twin_next)) assume({ gie, req_data[2+WBLSB +: 4] } != f_addr_",
            "reg ); end // }}} `endif // TWIN_WRITE_TEST",
            "always @(*) `ASSERT(req_data == { gie, fifo_data[rdaddr[DP-1:0]] });",
            "always @(posedge i_clk) if (r_svalid||r_dvalid || r_rd_pending) begin `ASSERT(f_fill == 1); end else if (f_fill > 0) begin `ASSERT(cyc); end",
            "always @(posedge i_clk) if (state != 0) begin `ASSERT(f_fill > 0); end else if (!r_svalid && !r_dvalid && !r_rd_pending) `ASSERT(f_fill == 0); `endif // FORMAL",
            "always @(posedge i_clk) o_w",
            "reg <= req_data[2+WBLSB +: NAUX]; // }}} end else begin : NO_FIFO // {{{",
            "reg [AW-1:0] fr_last_addr;",
            "always @(posedge i_clk) if (i_pipe_stb) req_data <= { i_o",
            "reg , i_op[2:1], i_addr[WBLSB-1:0] };",
            "always @(*) o_w",
            "reg = req_data[2+WBLSB +: NAUX];",
            "always @(*) gie = o_w",
            "reg [NAUX-1]; `ifdef FORMAL // f_pc_pending // {{{",
            "always @(*) begin f_pc_pending = 0; if ((r_rd_pending || state == DC_READS)||(o_valid)) f_pc_pending = (o_w",
            "reg [3:1] == 3'h7); end // }}} // f_pending_addr // {{{",
            "initial f_pending_addr = 0;",
            "always @(posedge i_clk) if (i_reset) f_pending_addr <= 0; else if (i_pipe_stb) begin if ((OPT_LOCAL_BUS)&&(&i_addr[DATA_WIDTH-1:DATA_WIDTH-8])) f_pending_addr <= { 1'b1, i_addr[2 +: AW] }; else f_pending_addr <= { 1'b0, i_addr[WBLSB +: AW] }; end // }}} // f_return_address // {{{",
            "always @(posedge i_clk) if (stb) fr_last_addr <= o_wb_addr;",
            "always @(*) begin f_return_address[AW] = o_wb_cyc_lcl; f_return_address[AW-1:LS] = o_wb_addr[AW-1:LS]; if (OPT_LOWPOWER && !stb) f_return_address[AW-1:LS] = fr_last_addr[AW-1:LS]; end",
            "always @(*) if (state == DC_READS) begin f_return_address[LS-1:0] = o_wb_addr[LS-1:0]; if (OPT_LOWPOWER && !stb) f_return_address[LS-1:0] = fr_last_addr[LS-1:0]; end else begin f_return_address[LS-1:0] = (o_wb_addr[LS-1:0] - f_outstanding[LS-1:0]); if (OPT_LOWPOWER && !stb) f_return_address[LS-1:0] = (fr_last_addr[LS-1:0] - f_outstanding[LS-1:0]); end // }}} // f_last_",
            "reg // {{{",
            "always @(*) if (o_rdbusy) assert(o_w",
            "reg == f_last_",
            "reg ); // }}} // verilator lint_off UNUSED",
            "initial f_fill = 0;",
            "wire unused_no_fifo_formal;",
            "assign unused_no_fifo_formal = &{ 1'b0, f_return_address, f_addr_",
            "reg , f_fill }; `endif",
            "wire unused_no_fifo;",
            "assign unused_no_fifo = &{ 1'b0, gie }; // verilator lint_on UNUSED // }}} end endgenerate // }}} // BIG STATE machine: CYC, STB, c_v, state, etc // {{{",
            "initial o_wb_addr = 0;",
            "initial r_wb_cyc_gbl = 0;",
            "initial r_wb_cyc_lcl = 0;",
            "initial o_wb_stb_gbl = 0;",
            "initial o_wb_stb_lcl = 0;",
            "initial c_v = 0;",
            "initial cyc = 0;",
            "initial stb = 0;",
            "initial c_wr = 0;",
            "initial wr_cstb = 0;",
            "initial state = DC_IDLE;",
            "initial set_vflag = 1'b0;",
            "always @(posedge i_clk) if (i_reset) begin // {{{ c_v <= 0; c_wr <= 1'b0; c_wsel <= {(BUS_WIDTH/8){1'b1}}; r_wb_cyc_gbl <= 1'b0; r_wb_cyc_lcl <= 1'b0; o_wb_stb_gbl <= 0; o_wb_stb_lcl <= 0; o_wb_addr <= 0; wr_cstb <= 1'b0; last_line_stb <= 1'b0; end_of_line <= 1'b0; state <= DC_IDLE; cyc <= 1'b0; stb <= 1'b0; state <= DC_IDLE; set_vflag <= 1'b0; // }}} end else begin // By default, update the cache from the write 1-clock ago // c_wr <= (wr_cstb)&&(wr_wtag == wr_vtag); // c_waddr <= wr_addr[(CS-1):0]; c_wr <= 0; set_vflag <= 1'b0; if (!cyc && set_vflag) c_v[c_waddr[(CS-1):LS]] <= 1'b1; wr_cstb <= 1'b0; // end_of_line // {{{ // Verilator coverage_off if (LS <= 0) end_of_line <= 1'b1; // Verilator coverage_on else if (!cyc) end_of_line <= 1'b0; else if (!end_of_line) begin if (i_wb_ack) end_of_line <= (c_waddr[(LS-1):0] == {{(LS-2){1'b1}},2'b01}); else end_of_line <= (c_waddr[(LS-1):0]=={{(LS-1){1'b1}}, 1'b0}); end // }}} // last_line_stb // {{{ if (!cyc || !stb || (OPT_LOWPOWER && state != DC_READC)) last_line_stb <= (LS <= 0); // Verilator coverage_off else if (!i_wb_stall && (LS <= 1)) last_line_stb <= 1'b1; // Verilator coverage_on else if (!i_wb_stall) last_line_stb <= (o_wb_addr[(LS-1):1]=={(LS-1){1'b1}}); else last_line_stb <= (o_wb_addr[(LS-1):0]=={(LS){1'b1}}); // }}} // // case(state) DC_IDLE: begin // {{{ o_wb_we <= 1'b0; cyc <= 1'b0; stb <= 1'b0; r_wb_cyc_gbl <= 1'b0; r_wb_cyc_lcl <= 1'b0; o_wb_stb_gbl <= 1'b0; o_wb_stb_lcl <= 1'b0; in_cache <= (i_op[0])&&(w_cachable); if ((i_pipe_stb)&&(i_op[0])) begin // Write operation // {{{ state <= DC_WRITE; if (OPT_LOCAL_BUS && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8])) o_wb_addr <= i_addr[2 +: AW]; else o_wb_addr <= i_addr[WBLSB +: AW]; o_wb_we <= 1'b1; cyc <= 1'b1; stb <= 1'b1; if (OPT_LOCAL_BUS) begin r_wb_cyc_gbl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]!=8'hff); r_wb_cyc_lcl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]==8'hff); o_wb_stb_gbl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]!=8'hff); o_wb_stb_lcl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]==8'hff); end else begin r_wb_cyc_gbl <= 1'b1; o_wb_stb_gbl <= 1'b1; end // }}} end else if (r_cache_miss) begin // Cache miss state <= DC_READC; o_wb_addr <= { r_ctag, {(LS){1'b0}} }; c_waddr <= { r_ctag[CS-LS-1:0], {(LS){1'b0}} }-1'b1; cyc <= 1'b1; stb <= 1'b1; r_wb_cyc_gbl <= 1'b1; o_wb_stb_gbl <= 1'b1; end else if ((i_pipe_stb)&&(!w_cachable)) begin // Read non-cachable memory area state <= DC_READS; if (OPT_LOCAL_BUS && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8])) o_wb_addr <= i_addr[2 +: AW]; else o_wb_addr <= i_addr[WBLSB +: AW]; cyc <= 1'b1; stb <= 1'b1; if (OPT_LOCAL_BUS) begin r_wb_cyc_gbl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]!=8'hff); r_wb_cyc_lcl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]==8'hff); o_wb_stb_gbl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]!=8'hff); o_wb_stb_lcl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]==8'hff); end else begin r_wb_cyc_gbl <= 1'b1; o_wb_stb_gbl <= 1'b1; end end // else we stay idle end // }}} DC_READC: begin // {{{ // We enter here once we have committed to reading // data into a cache line. if (stb && !i_wb_stall) begin stb <= (!last_line_stb); o_wb_stb_gbl <= (!last_line_stb); o_wb_addr[(LS-1):0] <= o_wb_addr[(LS-1):0]+1'b1; if (OPT_LOWPOWER && last_line_stb) o_wb_addr <= 0; end if (i_wb_ack) c_v[r_cline] <= 1'b0; c_wr <= (i_wb_ack); c_wdata <= i_wb_data; c_waddr <= c_waddr+(i_wb_ack ? 1:0); c_wsel <= {(BUS_WIDTH/8){1'b1}}; set_vflag <= !i_wb_err; // if (i_wb_ack) // c_vtags[r_addr[(CS-1):LS]] // <= r_addr[(AW-1):LS]; if ((i_wb_ack && end_of_line)|| i_wb_err) begin state <= DC_IDLE; cyc <= 1'b0; stb <= 1'b0; r_wb_cyc_gbl <= 1'b0; r_wb_cyc_lcl <= 1'b0; o_wb_stb_gbl <= 1'b0; o_wb_stb_lcl <= 1'b0; // if (OPT_LOWPOWER) o_wb_addr <= 0; end end // }}} DC_READS: begin // {{{ // We enter here once we have committed to reading // data that cannot go into a cache line if ((!i_wb_stall)&&(!i_pipe_stb)) begin stb <= 1'b0; o_wb_stb_gbl <= 1'b0; o_wb_stb_lcl <= 1'b0; if (OPT_LOWPOWER) o_wb_addr <= 0; end if ((!i_wb_stall)&&(i_pipe_stb)) begin if (OPT_LOCAL_BUS && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8])) o_wb_addr <= i_addr[2 +: AW]; else o_wb_addr <= i_addr[WBLSB +: AW]; end c_wr <= 1'b0; if (((i_wb_ack)&&(last_ack))||(i_wb_err)) begin state <= DC_IDLE; cyc <= 1'b0; stb <= 1'b0; r_wb_cyc_gbl <= 1'b0; r_wb_cyc_lcl <= 1'b0; o_wb_stb_gbl <= 1'b0; o_wb_stb_lcl <= 1'b0; if (OPT_LOWPOWER) o_wb_addr <= 0; end end // }}} DC_WRITE: begin // {{{ c_wr <= o_wb_stb_gbl && (c_v[o_wb_addr[CS-1:LS]]) // &&(c_vtags[o_wb_addr[CS-1:LS]]==o_wb_addr[AW-1:LS]); &&(r_itag==o_wb_addr[AW-1:LS]); c_wdata <= o_wb_data; c_waddr <= r_addr[CS-1:0]; c_wsel <= o_wb_sel; if ((!i_wb_stall)&&(!i_pipe_stb)) begin stb <= 1'b0; o_wb_stb_gbl <= 1'b0; o_wb_stb_lcl <= 1'b0; if (OPT_LOWPOWER) o_wb_addr <= 0; end wr_cstb <= (stb)&&(!i_wb_stall)&&(in_cache); if (i_pipe_stb && !i_wb_stall) begin if (OPT_LOCAL_BUS && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8])) o_wb_addr <= i_addr[2 +: AW]; else o_wb_addr <= i_addr[WBLSB +: AW]; end if (((i_wb_ack)&&(last_ack) &&((!OPT_PIPE)||(!i_pipe_stb))) ||(i_wb_err)) begin state <= DC_IDLE; cyc <= 1'b0; stb <= 1'b0; r_wb_cyc_gbl <= 1'b0; r_wb_cyc_lcl <= 1'b0; o_wb_stb_gbl <= 1'b0; o_wb_stb_lcl <= 1'b0; if (OPT_LOWPOWER) o_wb_addr <= 0; end end // }}} endcase if (i_clear) c_v <= 0; end",
            "always @(posedge i_clk) if (state == DC_READC && i_wb_ack) c_vtags[r_addr[(CS-1):LS]] <= r_addr[(AW-1):LS]; // }}} // wr_addr // {{{",
            "always @(posedge i_clk) if (!cyc) begin wr_addr <= r_addr[(CS-1):0]; if ((!i_pipe_stb || !i_op[0])&&(r_cache_miss)) wr_addr[LS-1:0] <= 0; end else if (i_wb_ack) wr_addr <= wr_addr + 1'b1; else wr_addr <= wr_addr; // }}} // npending // {{{ // npending is the number of outstanding (non-cached) read or write // requests. We only keep track of npending if we are running in a // piped fashion, i.e. if OPT_PIPE, and so need to keep track of // possibly multiple outstanding transactions",
            "initial npending = 0;",
            "always @(posedge i_clk) if ((i_reset)||(!OPT_PIPE) ||((cyc)&&(i_wb_err)) ||((!cyc)&&(!i_pipe_stb)) ||(state == DC_READC)) npending <= 0; else if (r_svalid) npending <= (i_pipe_stb) ? 1:0; else case({ (i_pipe_stb), (cyc)&&(i_wb_ack) }) 2'b01: npending <= npending - 1'b1; 2'b10: npending <= npending + 1'b1; default: begin end endcase `ifdef FORMAL",
            "always @(*) `ASSERT(npending <= { 1'b1, {(DP){1'b0}} }); `endif // }}} // last_ack // {{{",
            "initial last_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) last_ack <= 1'b0; else if (state == DC_IDLE) begin last_ack <= 1'b0; if ((i_pipe_stb)&&(i_op[0])) last_ack <= 1'b1; else if (r_cache_miss) last_ack <= (LS == 0); else if ((i_pipe_stb)&&(!w_cachable)) last_ack <= 1'b1; end else if (state == DC_READC) begin if (i_wb_ack) last_ack <= last_ack || (&wr_addr[LS-1:1]); else last_ack <= last_ack || (&wr_addr[LS-1:0]); end else case({ (i_pipe_stb), (i_wb_ack) }) 2'b01: last_ack <= (npending <= 2); 2'b10: last_ack <= (!cyc)||(npending == 0); default: begin end endcase // }}} // // Writes to the cache // {{{ // These have been made as simple as possible. Note that the c_wr // line has already been determined, as have the write value and address // on the last clock. Further, this structure is defined to match the // block RAM design of as many architectures as possible. // always @(posedge i_clk) if (c_wr) begin for(ik=0; ik<BUS_WIDTH/8; ik=ik+1) if (c_wsel[ik]) c_mem[c_waddr][ik *8 +: 8] <= c_wdata[ik * 8 +: 8]; end // }}} // // Reads from the cache // {{{ // Some architectures require that all reads be",
            "reg istered. We // accomplish that here. Whether or not the result of this read is // going to be our",
            "output will need to be determined with combinatorial // logic on the",
            "output . // generate if (OPT_DUAL_READ_PORT) begin : GEN_DUAL_READ_PORT",
            "always @(posedge i_clk) cached_iword <= c_mem[i_caddr];",
            "always @(posedge i_clk) cached_rword <= c_mem[r_caddr]; end else begin : GEN_SHARED_READ_PORT",
            "always @(posedge i_clk) cached_rword <= c_mem[(o_busy) ? r_caddr : i_caddr];",
            "always @(*) cached_iword = cached_rword; end endgenerate // }}} // o_data, pre_data // {{{ // o_data can come from one of three places: // 1. The cache, assuming the data was in the last cache line // 2. The cache, second clock, assuming the data was in the cache at all // 3. The cache, after filling the cache // 4. The wishbone state machine, upon reading the value desired.",
            "always @(*) if (r_svalid) pre_data = cached_iword; else if (state == DC_READS) pre_data = i_wb_data; else pre_data = cached_rword;",
            "always @(*) if (o_wb_cyc_lcl) pre_shifted = { i_wb_data[31:0], {(BUS_WIDTH-32){1'b0}} } << (8*req_data[2-1:0]); else pre_shifted = pre_data << (8*req_data[WBLSB-1:0]); // o_data",
            "initial o_data = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && (i_reset ||(!r_svalid && (!i_wb_ack || state != DC_READS) && !r_dvalid))) o_data <= 0; else casez(req_data[WBLSB +: 2]) 2'b10: o_data <= { 16'h0, pre_shifted[BUS_WIDTH-1:BUS_WIDTH-16] }; 2'b11: o_data <= { 24'h0, pre_shifted[BUS_WIDTH-1:BUS_WIDTH- 8] }; default o_data <= pre_shifted[BUS_WIDTH-1:BUS_WIDTH-32]; endcase // }}} // o_valid // {{{",
            "initial o_valid = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_valid <= 1'b0; else if (state == DC_READS) o_valid <= i_wb_ack; else o_valid <= (r_svalid)||(r_dvalid); // }}} // o_err // {{{",
            "initial o_err = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_err <= 1'b0; else o_err <= (cyc)&&(i_wb_err); // }}} // o_busy // {{{",
            "initial o_busy = 0;",
            "always @(posedge i_clk) if ((i_reset)||((cyc)&&(i_wb_err))) o_busy <= 1'b0; else if (i_pipe_stb) o_busy <= 1'b1; else if ((state == DC_READS)&&(i_wb_ack)) o_busy <= 1'b0; else if ((r_rd_pending)&&(!r_dvalid)) o_busy <= 1'b1; else if ((state == DC_WRITE) &&(i_wb_ack)&&(last_ack)&&(!i_pipe_stb)) o_busy <= 1'b0; else if (cyc) o_busy <= 1'b1; else // if ((r_dvalid)||(r_svalid)) o_busy <= 1'b0; // }}} // o_rdbusy // {{{",
            "initial o_rdbusy = 0;",
            "always @(posedge i_clk) if ((i_reset)||((cyc)&&(i_wb_err))) o_rdbusy <= 1'b0; else if (i_pipe_stb && !i_op[0]) o_rdbusy <= 1'b1; else if ((state == DC_READS)&&(i_wb_ack)) o_rdbusy <= 1'b0; else if ((r_rd_pending)&&(!r_dvalid)) o_rdbusy <= 1'b1; else if (cyc && !o_wb_we) o_rdbusy <= 1'b1; else // if ((r_dvalid)||(r_svalid)) o_rdbusy <= 1'b0; // }}} // // We can use our FIFO addresses to pre-calculate when an ACK is going // to be the last_noncachable_ack.",
            "always @(*) if (OPT_PIPE) o_pipe_stalled = (cyc)&&((!o_wb_we)||(i_wb_stall)||(!stb)) ||(r_rd_pending)||(npending[DP]); else o_pipe_stalled = o_busy;",
            "initial lock_gbl = 0;",
            "initial lock_lcl = 0;",
            "always @(posedge i_clk) if (i_reset || !OPT_LOCK) begin lock_gbl <= 1'b0; lock_lcl<= 1'b0; end else begin // lock_gbl <= (r_wb_cyc_gbl)||(lock_gbl); // lock_lcl <= (r_wb_cyc_lcl)||(lock_lcl); if (i_pipe_stb) begin lock_gbl <= (!OPT_LOCAL_BUS || i_addr[DATA_WIDTH-1:DATA_WIDTH-8] != 8'hff); lock_lcl <=(i_addr[DATA_WIDTH-1:DATA_WIDTH-8] == 8'hff); end if (r_wb_cyc_gbl && i_wb_err) lock_gbl <= 1'b0; if (r_wb_cyc_lcl && i_wb_err) lock_lcl <= 1'b0; if (!i_lock) { lock_gbl, lock_lcl } <= 2'b00; if (!OPT_LOCAL_BUS) lock_lcl <= 1'b0; end",
            "assign o_wb_cyc_gbl = (r_wb_cyc_gbl)||(lock_gbl);",
            "assign o_wb_cyc_lcl = (r_wb_cyc_lcl)||(lock_lcl); // Make Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, pre_shifted }; generate if (AW+WBLSB < DATA_WIDTH) begin : UNUSED_BITS",
            "wire unused_aw;",
            "assign unused = &{ 1'b0, i_addr[DATA_WIDTH-1:AW+WBLSB] }; end endgenerate // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties for verification // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; //////////////////////////////////////////////////////////////////////// // // Reset properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if(!f_past_valid) `ASSUME(i_reset);",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) begin // Insist on",
            "initial statements matching reset values // `ASSERT(r_rd == 1'b0); `ASSERT(r_cachable == 1'b0); `ASSERT(r_svalid == 1'b0); `ASSERT(r_dvalid == 1'b0); `ASSERT(r_cache_miss == 1'b0); // `ASSERT(r_addr == 0); // `ASSERT(c_wr == 0); `ASSERT(c_v == 0); // // assert(aux_head == 0); // assert(aux_tail == 0); // `ASSERT(lock_gbl == 0); `ASSERT(lock_lcl == 0); end // }}} //////////////////////////////////////////////////////////////////////// // // Assumptions about our",
            "input s (the CPU interface) // {{{ //////////////////////////////////////////////////////////////////////// // // reg f_rdbusy, f_done;",
            "reg [F_LGDEPTH-1:0] f_cpu_outstanding;",
            "wire faxi_write; fmem #( // {{{ .OPT_LOCK(OPT_LOCK), .F_LGDEPTH(F_LGDEPTH), .OPT_MAXDEPTH(1<<(F_LGDEPTH-1)), .OPT_AXI_LOCK(1'b0) // }}} ) f_cpu( // {{{ .i_clk(i_clk), .i_sys_reset(i_reset), .i_cpu_reset(i_reset), // The CPU interface .i_stb(i_pipe_stb), .i_pipe_stalled(o_pipe_stalled), .i_clear_cache(i_clear), .i_lock(i_lock), .i_op(i_op), .i_addr(i_addr), .i_data(i_data), .i_o",
            "reg (i_o",
            "reg ), .i_a",
            "reg (f_a",
            "reg ), .i_busy(o_busy), .i_rdbusy(o_rdbusy), .i_valid(o_valid), .i_done(f_done), .i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_data), .f_outstanding(f_cpu_outstanding), .f_pc(f_pc), .f_gie(f_gie), .f_read_cycle(f_read_cycle), .f_axi_write_cycle(faxi_write), .f_last_",
            "reg (f_last_",
            "reg ), .f_addr_",
            "reg (f_addr_",
            "reg ) // }}} );",
            "always @(*) assert(faxi_write == 0);",
            "always @(*) if (OPT_PIPE || (!o_err && !r_svalid && !r_dvalid)) assert(f_pc_pending == f_pc); // f_rdbusy // {{{",
            "always @(*) begin f_rdbusy = 0; if (state == DC_READC) f_rdbusy = 1'b1; if (state == DC_READS) f_rdbusy = 1'b1; if (r_svalid || r_dvalid) f_rdbusy = 1'b1; if ((r_rd_pending)||(r_dvalid)||(r_svalid)) f_rdbusy = 1'b1; assert(f_rdbusy == o_rdbusy); end // }}} // f_done // {{{",
            "initial f_done = 0;",
            "always @(posedge i_clk) if (i_reset) f_done <= 1'b0; else begin f_done <= 1'b0; if ((cyc)&&(i_wb_err)) f_done <= 1'b1; if ((state == DC_READS || state == DC_WRITE)&&(i_wb_ack)) f_done <= 1'b1; if ((r_dvalid)||(r_svalid)) f_done <= 1'b1; end // }}} // f_gie // {{{",
            "always @(*) if (o_busy) assert(gie == f_gie); // }}} // f_read_cycle // {{{",
            "always @(*) if (state == DC_READS || state == DC_READC || r_svalid || r_dvalid) begin assert(f_read_cycle); end else if (state == DC_WRITE) assert(!f_read_cycle); // }}} // The CPU is not allowed to write to the CC",
            "reg ister while a // memory operation is pending, lest any resulting bus error // get returned to the wrong mode--i.e. user bus error halting // the supervisor. What this means, though, is that the CPU // will *never* attempt to clear the data cache while the cache // is busy. // always @(*) // if (o_busy || i_pipe_stb) // f_outstanding) // `ASSUME(!i_clear);",
            "always @(*) if (cyc && !o_wb_we) begin if (state == DC_READC) begin assert(f_cpu_outstanding == 1); end else assert(f_cpu_outstanding == f_outstanding + (r_svalid ? 1:0) + (r_dvalid ? 1:0) + (o_valid ? 1:0) + (stb ? 1:0)); end else if (cyc) // Writing begin assume(f_cpu_outstanding <= (1<<OPT_FIFO_DEPTH)); if (!o_err) assert(f_cpu_outstanding == f_outstanding + (stb ? 1:0) + (f_done ? 1:0)); end",
            "always @(*) if (!cyc && (!OPT_PIPE || !o_err)) assert(f_cpu_outstanding == ((r_svalid || r_dvalid || r_rd_pending) ? 1:0) + ((f_done || o_valid || o_err) ? 1:0)); /* always @(*) if (o_pipe_stalled) `ASSUME(!i_pipe_stb);",
            "always @(*) if (!f_past_valid) `ASSUME(!i_pipe_stb);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&($past(i_pipe_stb))&&($past(o_pipe_stalled))) begin `ASSUME($stable(i_pipe_stb)); `ASSUME($stable(i_op[0])); `ASSUME($stable(i_addr)); if (i_op[0]) `ASSUME($stable(i_data)); end",
            "always @(posedge i_clk) if (o_err) `ASSUME(!i_pipe_stb); */ // }}} //////////////////////////////////////////////////////////////////////// // // Wishbone properties // {{{ //////////////////////////////////////////////////////////////////////// // // wire f_cyc, f_stb;",
            "assign f_cyc = (o_wb_cyc_gbl)|(o_wb_cyc_lcl);",
            "assign f_stb = (o_wb_stb_gbl)|(o_wb_stb_lcl);",
            "always @(*) begin // Only one interface can be active at once `ASSERT((!o_wb_cyc_gbl)||(!o_wb_cyc_lcl)); // Strobe may only be active on the active interface `ASSERT((r_wb_cyc_gbl)||(!o_wb_stb_gbl)); `ASSERT((r_wb_cyc_lcl)||(!o_wb_stb_lcl)); if (o_wb_stb_lcl) begin if (o_wb_we) begin assert(state == DC_WRITE); end else assert(state == DC_READS); end if (cyc) assert(o_wb_we == (state == DC_WRITE)); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(cyc)&&($past(cyc))) begin `ASSERT($stable(r_wb_cyc_gbl)); `ASSERT($stable(r_wb_cyc_lcl)); end fwb_master #( // {{{ .AW(AW), .DW(BUS_WIDTH), .F_MAX_STALL(2), .F_MAX_ACK_DELAY(3), // If you need the proof to run faster, use these // lines instead of the two that follow // .F_MAX_STALL(1), // .F_MAX_ACK_DELAY(1), .F_LGDEPTH(F_LGDEPTH), // Verilator lint_off WIDTH .F_MAX_REQUESTS((OPT_PIPE) ? 0 : (1<<LS)), // Verilator lint_on WIDTH `ifdef DCACHE .F_OPT_SOURCE(1'b1), `endif .F_OPT_DISCONTINUOUS(0) // }}} ) fwb( // {{{ i_clk, i_reset, cyc, f_stb, o_wb_we, o_wb_addr, o_wb_data, o_wb_sel, i_wb_ack, i_wb_stall, i_wb_data, i_wb_err, f_nreqs, f_nacks, f_outstanding // }}} ); // }}} //////////////////////////////////////////////////////////////////////// // // Contract checking -- Arbitrary address (contract) properties // {{{ //////////////////////////////////////////////////////////////////////// `ifdef DCACHE // Arbitrary access is specific to local dcache implementation // // (* anyconst *)",
            "reg [AW:0] f_const_addr; (* anyconst *)",
            "reg f_const_buserr;",
            "wire [AW-LS-1:0] f_const_tag, f_ctag_here, f_wb_tag;",
            "wire [CS-LS-1:0] f_const_tag_addr;",
            "reg [BUS_WIDTH-1:0] f_const_data;",
            "wire [BUS_WIDTH-1:0] f_cmem_here;",
            "reg f_pending_rd;",
            "wire f_cval_in_cache;",
            "wire [AW-1:0] wb_start;",
            "reg [AW-1:0] f_cache_waddr;",
            "wire f_this_cache_waddr;",
            "wire f_this_return;",
            "assign f_const_tag = f_const_addr[AW-1:LS];",
            "assign f_const_tag_addr = f_const_addr[CS-1:LS];",
            "assign f_cmem_here = c_mem[f_const_addr[CS-1:0]];",
            "assign f_ctag_here = c_vtags[f_const_addr[CS-1:LS]];",
            "assign f_wb_tag = (OPT_LOWPOWER ? r_addr[AW-1:LS] : o_wb_addr[AW-1:LS]);",
            "assign f_cval_in_cache= (c_v[f_const_addr[CS-1:LS]]) &&(f_ctag_here == f_const_tag);",
            "assign f_this_cache_waddr = (!f_const_addr[AW]) &&(f_cache_waddr == f_const_addr[AW-1:0]);",
            "assign f_this_return = (f_return_address == f_const_addr);",
            "assign wb_start = (f_stb) ? (o_wb_addr - f_nreqs) : { r_addr[AW-1:LS], {(LS){1'b0}} }; // Assume f_const_addr[AW] consistent with the local bus declaration // {{{ generate if ((AW > BUS_WIDTH - 8)&&(OPT_LOCAL_BUS)) begin : UPPER_CONST_ADDR_BITS",
            "always @(*) if (f_const_addr[AW]) begin assume(&f_const_addr[AW-1:DATA_WIDTH-8-2]); end else assume(!(&f_const_addr[AW-1:DATA_WIDTH-8-WBLSB])); end endgenerate // }}} // f_const_data -- Adjust our special data word upon request // {{{",
            "reg [BUS_WIDTH-1:0] f_shifted_data;",
            "reg [BUS_WIDTH/8-1:0] f_shifted_sel;",
            "always @(*) begin casez(i_op[2:1]) 2'b0?: begin f_shifted_data = { i_data, {(BUS_WIDTH-DATA_WIDTH){1'b0}} } >> (8*i_addr[WBLSB-1:0]); f_shifted_sel = { 4'b1111, {(BUS_WIDTH/8-4){1'b0}} } >> i_addr[WBLSB-1:0]; end 2'b10: begin f_shifted_data = { i_data[15:0], {(BUS_WIDTH-16){1'b0}} } >> (8*i_addr[WBLSB-1:0]); f_shifted_sel = { 2'b11, {(BUS_WIDTH/8-2){1'b0}} } >> i_addr[WBLSB-1:0]; end 2'b11: begin f_shifted_data = { i_data[ 7:0], {(BUS_WIDTH-8){1'b0}} } >> (8*i_addr[WBLSB-1:0]); f_shifted_sel = { 1'b1, {(BUS_WIDTH/8-1){1'b0}} } >> i_addr[WBLSB-1:0]; end endcase end",
            "always @(posedge i_clk) // Upon a request for our special address ... if (i_pipe_stb && (!cyc || !i_wb_err) // That matches the local or global bus address.... && f_const_addr[AW] == ((OPT_LOCAL_BUS) &&(&i_addr[DATA_WIDTH-1:DATA_WIDTH-8])) // and it is a write request && i_op[0]) begin // Then update the chosen data word at that address if (f_const_addr[AW] && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]) && (i_addr[2 +: AW] == f_const_addr[AW-1:0])) begin // Local bus word // {{{ casez({ i_op[2:1], i_addr[1:0] }) 4'b0???: f_const_data[31: 0] <= i_data; 4'b100?: f_const_data[31:16] <= i_data[15:0]; 4'b101?: f_const_data[15: 0] <= i_data[15:0]; 4'b1100: f_const_data[31:24] <= i_data[ 7:0]; 4'b1101: f_const_data[23:16] <= i_data[ 7:0]; 4'b1110: f_const_data[15: 8] <= i_data[ 7:0]; 4'b1111: f_const_data[ 7: 0] <= i_data[ 7:0]; endcase // }}} end else if (!f_const_addr[AW] && (!OPT_LOCAL_BUS || !(&i_addr[DATA_WIDTH-1:DATA_WIDTH-8])) && (i_addr[WBLSB +: AW] == f_const_addr[AW-1:0])) begin // Global bus word for(ik=0; ik<BUS_WIDTH/8; ik=ik+1) if (f_shifted_sel[ik]) f_const_data[8*ik +: 8] <= f_shifted_data[8*ik +: 8]; end end // }}} // Insure the cache and bus both have an accurate/valid copy of the data // {{{",
            "always @(posedge i_clk) if ((f_past_valid)&&(!i_reset)&&(!f_const_buserr)) begin // Is this a write to our special address? if (cyc && o_wb_we && f_stb &&(o_wb_addr[AW-1:0] == f_const_addr[AW-1:0]) &&( o_wb_stb_lcl == f_const_addr[AW])) begin // Only the updated data value should be written to the // bus // {{{ if (f_const_addr[AW]) begin for(ik=0; ik<DATA_WIDTH/8; ik=ik+1) if (f_stb && o_wb_sel[ik]) `ASSERT(o_wb_data[ik*8 +: 8]==f_const_data[ik*8 +: 8]); end else begin for(ik=0; ik<BUS_WIDTH/8; ik=ik+1) if (f_stb && o_wb_sel[ik]) `ASSERT(o_wb_data[ik*8 +: 8]==f_const_data[ik*8 +: 8]); end // }}} // Check the data written into the cache for validity // {{{ if (!f_const_addr[AW] && c_v[f_const_tag_addr] && (f_ctag_here == o_wb_addr[AW-1:LS])) begin for(ik=0; ik<BUS_WIDTH/8; ik=ik+1) if (!o_wb_sel[ik] && !c_wsel[ik]) `ASSERT(f_cmem_here[8*ik +: 8]==f_const_data[8*ik +: 8]); // }}} end // Otherwise, if this is a valid address, *and* it is in the // cache ... end else if (!f_const_addr[AW] && c_v[f_const_tag_addr] &&(f_ctag_here ==f_const_addr[AW-1:LS])) begin // If ... // 1. Our magic address is cachable // 2. Our magic address is associated with a valid // cache line // 3. The cache tag matches our magic address // {{{ // if ($past(cyc && i_wb_err)) // begin // Ignore what happens on an error, the result // becomes undefined anyway // end else if (c_wr &&(c_waddr[CS-1:0] == f_const_addr[CS-1:0])) begin // // If we are writing to this valid cache line // {{{ for(ik=0; ik<BUS_WIDTH/8; ik=ik+1) if (c_wsel[ik] && $past(o_wb_cyc_gbl)) begin `ASSERT(c_wdata[8*ik +: 8] == f_const_data[8*ik +: 8]); end else `ASSERT(f_cmem_here[8*ik +: 8] == f_const_data[8*ik +: 8]); // }}} end else // Else, we assert the correct value is already // in the cache `ASSERT(f_cmem_here == f_const_data); // }}} end end // }}} // When reading a cache line, assert the correct value has been read // if we've passed that aprt of our read // {{{",
            "always @(posedge i_clk) if ((f_past_valid)&&(state == DC_READC)) begin `ASSERT(f_return_address[AW-1:LS] == r_ctag); `ASSERT(f_wb_tag == r_ctag); if ((r_ctag == f_const_tag) &&(!c_v[f_const_tag_addr]) &&(f_const_addr[AW] == r_wb_cyc_lcl) &&(f_nacks > f_const_addr[LS-1:0])) begin // We are reading the cache line containing our // constant address f_const_addr. Make sure the data // is correct. if ((c_wr)&&(c_waddr[CS-1:0] == f_const_addr[CS-1:0])) begin `ASSERT(c_wdata == f_const_data); end else `ASSERT(f_cmem_here == f_const_data); end if (!i_reset && f_nacks > 0) `ASSERT(!c_v[r_cline]); end // }}}",
            "always @(posedge i_clk) if ((state == DC_READC)&&(f_nacks > 0)) begin `ASSERT(c_vtags[wb_start[(CS-1):LS]] <= wb_start[(AW-1):LS]); `ASSERT(c_vtags[wb_start[(CS-1):LS]] <= r_addr[AW-1:LS]); end",
            "always @(*) begin // f_cache_waddr[AW-1:LS] = c_vtags[c_waddr[CS-1:CS-LS]]; f_cache_waddr[AW-1:LS] = wb_start[AW-1:LS]; f_cache_waddr[CS-1: 0] = c_waddr[CS-1:0]; end",
            "always @(posedge i_clk) if ((f_past_valid)&&(state == DC_READC)) begin if ((c_wr)&&(c_waddr[LS-1:0] != 0)&&(f_this_cache_waddr)) `ASSERT(c_wdata == f_const_data); end // always @(posedge i_clk) // if ((OPT_PIPE)&&(o_busy)&&(i_pipe_stb)) // `ASSUME(i_op[0] == o_wb_we);",
            "initial f_pending_rd = 0;",
            "always @(posedge i_clk) if (i_reset) f_pending_rd <= 0; else if (i_pipe_stb) f_pending_rd <= (!i_op[0]); else if ((o_valid)&&((!OPT_PIPE) ||((state != DC_READS)&&(!r_svalid)&&(!$past(i_pipe_stb))))) f_pending_rd <= 1'b0;",
            "always @(*) if ((state == DC_READC)&&(!f_stb)) `ASSERT(f_nreqs == (1<<LS));",
            "always @(*) if ((state == DC_READC)&&(f_stb)) `ASSERT(f_nreqs == { 1'b0, o_wb_addr[LS-1:0] });",
            "always @(posedge i_clk) if (state == DC_READC) begin if (f_stb) assert(r_addr[AW-1:LS] == o_wb_addr[AW-1:LS]); if (($past(i_wb_ack))&&(!$past(f_stb))) begin `ASSERT(f_nacks-1 == { 1'b0, c_waddr[LS-1:0] }); end else if (f_nacks > 0) begin `ASSERT(f_nacks-1 == { 1'b0, c_waddr[LS-1:0] }); `ASSERT(c_waddr[CS-1:LS] == r_addr[CS-1:LS]); end else begin `ASSERT(c_waddr[CS-1:LS] == r_addr[CS-1:LS]-1'b1); `ASSERT(&c_waddr[LS-1:0]); end end",
            "always @(*) if (r_rd_pending) `ASSERT(r_addr == f_pending_addr[AW-1:0]);",
            "always @(*) if (f_pending_addr[AW]) begin `ASSERT(state != DC_READC); `ASSERT((!o_wb_we)||(!o_wb_cyc_gbl)); end",
            "reg [BUS_WIDTH-1:0] f_shift_const_data;",
            "always @(posedge i_clk) begin if (f_const_addr[AW]) f_shift_const_data = { f_const_data[31:0], {(BUS_WIDTH-DATA_WIDTH){1'b0}} } << (8*req_data[2-1:0]); else f_shift_const_data = f_const_data << (8*req_data[WBLSB-1:0]); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(o_valid)&&($past(f_pending_addr) == f_const_addr)) begin if (f_const_buserr) begin `ASSERT(o_err); end else if (f_pending_rd) begin casez($past(req_data[WBLSB +: 2])) 4'b0?: `ASSERT(o_data ==f_shift_const_data[BUS_WIDTH-1:BUS_WIDTH-32]); 4'b10: `ASSERT(o_data =={16'h00,f_shift_const_data[BUS_WIDTH-1:BUS_WIDTH-16]}); 4'b11: `ASSERT(o_data =={24'h00,f_shift_const_data[BUS_WIDTH-1:BUS_WIDTH- 8]}); endcase end end // #1. Assume this return matches our chosen data // {{{",
            "always @(*) if ((f_cyc)&&( ((state == DC_READC) &&(f_return_address[AW-1:LS] == f_const_addr[AW-1:LS])) ||(f_this_return))) begin if (f_const_buserr) begin assume(!i_wb_ack); end else begin assume(!i_wb_err); assume(i_wb_data == f_const_data); end end // }}}",
            "always @(posedge i_clk) if ((f_past_valid)&&(last_tag == f_const_tag)&&(f_const_buserr) &&(!f_const_addr[AW])) `ASSERT(!last_tag_valid); // Chosen address is invalid: bus error properties // {{{",
            "always @(*) if (f_const_buserr) begin `ASSERT((!c_v[f_const_tag_addr])||(f_const_addr[AW]) ||(f_ctag_here != f_const_tag)); if ((state == DC_READC)&&(wb_start[AW-1:LS] == f_const_tag)) begin `ASSERT(f_nacks <= f_const_tag[LS-1:0]); if (f_nacks == f_const_tag[LS-1:0]) assume(!i_wb_ack); end end // }}} /* // ?? why was I assuming this again?",
            "always @(*) if (f_cval_in_cache) begin assume((!i_wb_err) ||(!i_pipe_stb) ||(f_const_addr[AW-1:0] != i_addr[WBLSB +: AW])); end */ `endif // DCACHE // }}} //////////////////////////////////////////////////////////////////////// // // Checking the lock // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) `ASSERT((!lock_gbl)||(!lock_lcl));",
            "always @(*) if (!OPT_LOCK) `ASSERT((!lock_gbl)&&(!lock_lcl)); // }}} //////////////////////////////////////////////////////////////////////// // // State based properties // {{{ //////////////////////////////////////////////////////////////////////// // // reg [F_LGDEPTH-1:0] f_rdpending;",
            "wire f_wb_cachable; // f_rdpending // {{{",
            "initial f_rdpending = 0;",
            "always @(posedge i_clk) if ((i_reset)||(o_err)) f_rdpending <= 0; else case({ (i_pipe_stb)&&(!i_op[0]), o_valid }) 2'b01: f_rdpending <= f_rdpending - 1'b1; 2'b10: f_rdpending <= f_rdpending + 1'b1; default: begin end endcase // }}} iscachable #( // {{{ .ADDRESS_WIDTH(AW+WBLSB) // }}} ) f_chkwb_addr({ r_addr, {(WBLSB){1'b0}} }, f_wb_cachable);",
            "always @(*) if (state == DC_IDLE) begin `ASSERT(!r_wb_cyc_gbl); `ASSERT(!r_wb_cyc_lcl); `ASSERT(!cyc); if ((r_rd_pending)||(r_dvalid)||(r_svalid)) `ASSERT(o_busy); if (!OPT_PIPE) begin if (r_rd_pending) begin `ASSERT(o_busy); end else if (r_svalid) begin `ASSERT(o_busy); end else if (o_valid) begin `ASSERT(!o_busy); end else if (o_err) begin `ASSERT(!o_busy); end end end else begin `ASSERT(o_busy); `ASSERT(cyc); end",
            "always @(posedge i_clk) if (state == DC_IDLE) begin if (r_svalid) begin `ASSERT(!r_dvalid); `ASSERT(!r_rd_pending); if (!OPT_PIPE) begin `ASSERT(!o_valid); end else if (o_valid) `ASSERT(f_rdpending == 2); end if (r_dvalid) begin `ASSERT(!r_rd_pending); `ASSERT(npending == 0); `ASSERT(f_rdpending == 1); end if (r_rd_pending) begin if ((OPT_PIPE)&&(o_valid)) begin `ASSERT(f_rdpending <= 2); end else `ASSERT(f_rdpending == 1); end else if ((OPT_PIPE)&&(o_valid)&&($past(r_dvalid|r_svalid))) begin `ASSERT(f_rdpending <= 2); end else `ASSERT(f_rdpending <= 1); end",
            "always @(posedge i_clk) if (state == DC_READC) begin `ASSERT( o_wb_cyc_gbl); `ASSERT(!o_wb_cyc_lcl); `ASSERT(!o_wb_we); `ASSERT(f_wb_cachable); `ASSERT(!lock_gbl); `ASSERT(!lock_lcl); `ASSERT(r_rd_pending); `ASSERT(r_cachable); if (($past(cyc))&&(!$past(o_wb_stb_gbl))) begin `ASSERT(!o_wb_stb_gbl); end if ((OPT_PIPE)&&(o_valid)) begin `ASSERT(f_rdpending == 2); end else `ASSERT(f_rdpending == 1); end",
            "always @(*) if (state == DC_READS) begin `ASSERT(!o_wb_we); if (OPT_PIPE) begin if (o_valid) begin `ASSERT(({ 1'b0, f_rdpending } == npending + 1) ||({ 1'b0, f_rdpending } == npending)); end else `ASSERT({ 1'b0, f_rdpending } == npending); end end else if (state == DC_WRITE) `ASSERT(o_wb_we);",
            "always @(posedge i_clk) if ((state == DC_READS)||(state == DC_WRITE)) begin `ASSERT(o_wb_we == (state == DC_WRITE)); `ASSERT(!r_rd_pending); if (o_wb_we) `ASSERT(f_rdpending == 0); if (OPT_PIPE) begin casez({ $past(i_pipe_stb), f_stb }) 2'b00: `ASSERT(npending == { 1'b0, f_outstanding}); 2'b1?: `ASSERT(npending == { 1'b0, f_outstanding} + 1); 2'b01: `ASSERT(npending == { 1'b0, f_outstanding} + 1); endcase if (state == DC_WRITE) `ASSERT(!o_valid); end else `ASSERT(f_outstanding <= 1); end",
            "always @(*) if (OPT_PIPE) begin `ASSERT(f_rdpending <= 2); end else `ASSERT(f_rdpending <= 1);",
            "always @(posedge i_clk) if ((!OPT_PIPE)&&(o_valid)) begin `ASSERT(f_rdpending == 1); end else if (o_valid) `ASSERT(f_rdpending >= 1);",
            "always @(*) if ((!o_busy)&&(!o_err)&&(!o_valid)) `ASSERT(f_rdpending == 0);",
            "always @(*) `ASSERT(cyc == ((r_wb_cyc_gbl)||(r_wb_cyc_lcl)));",
            "always @(*) if ((!i_reset)&&(f_nreqs == f_nacks)&&(!f_stb)) `ASSERT(!cyc);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_err))) begin `ASSUME(!i_lock); end else if ((f_past_valid)&&(OPT_LOCK)&&($past(i_lock)) &&((!$past(o_valid)) || ($past(i_pipe_stb)))) `ASSUME($stable(i_lock)); // }}} //////////////////////////////////////////////////////////////////////// // // Ad-hoc properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if ((OPT_PIPE)&&(state == DC_WRITE)&&(!i_wb_stall)&&(stb) &&(!npending[DP])) `ASSERT(!o_pipe_stalled);",
            "always @(posedge i_clk) if (state == DC_WRITE) begin `ASSERT(o_wb_we); end else if ((state == DC_READS)||(state == DC_READC)) `ASSERT(!o_wb_we);",
            "always @(*) if (cyc) `ASSERT(f_cyc);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(cyc))&&(!c_wr)&&(last_tag_valid) &&(!r_rd_pending)) `ASSERT((c_v[last_tag[(CS-LS-1):0]]) &&(c_vtags[last_tag[(CS-LS-1):0]] == last_tag));",
            "always @(*) if (!OPT_LOCAL_BUS) begin `ASSERT(r_wb_cyc_lcl == 1'b0); `ASSERT(o_wb_stb_lcl == 1'b0); `ASSERT(lock_lcl == 1'b0); end",
            "always @(posedge i_clk) if (state == DC_READC && !stb) begin if (OPT_LOWPOWER) begin `ASSERT(o_wb_addr == 0); end else begin `ASSERT(o_wb_addr[LS-1:0] == 0); `ASSERT(o_wb_addr[AW-1:CS] == r_addr[AW-1:CS]); end end else if ((state == DC_READC)&&(stb)) begin `ASSERT(o_wb_addr[AW-1:CS] == r_addr[AW-1:CS]); `ASSERT(o_wb_addr[LS-1:0] == f_nreqs[LS-1:0]); end",
            "wire [CS-1:0] f_expected_caddr;",
            "assign f_expected_caddr = { r_ctag[CS-LS-1:0], {(LS){1'b0}} }-1 + { {(CS-F_LGDEPTH){1'b0}}, f_nacks };",
            "always @(posedge i_clk) if (state == DC_READC) begin if (LS == 0) begin `ASSERT(end_of_line); end else if (f_nacks < (1<<LS)-1) begin `ASSERT(!end_of_line); end else if (f_nacks == (1<<LS)-1) begin `ASSERT(end_of_line); end `ASSERT(f_nacks <= (1<<LS)); `ASSERT(f_nreqs <= (1<<LS)); if (f_nreqs < (1<<LS)) begin `ASSERT(o_wb_stb_gbl); `ASSERT(o_wb_addr[(LS-1):0] == f_nreqs[LS-1:0]); end else `ASSERT(!f_stb); `ASSERT((f_nreqs == 0)||(f_nacks <= f_nreqs)); `ASSERT(c_waddr == f_expected_caddr); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(r_rd)&&(!$past(i_reset))) begin `ASSERT((o_busy)||(r_svalid)); end",
            "always @(posedge i_clk) if (!$past(o_busy)) `ASSERT(!r_dvalid);",
            "always @(posedge i_clk) if ((state == DC_READC)&&(c_wr)) `ASSERT(&c_wsel);",
            "always @(*) if (c_wr && !(&c_wsel)) `ASSERT($countones(c_wsel) == 1 || $countones(c_wsel) == 2 || $countones(c_wsel) == 4);",
            "always @(*) if (!OPT_PIPE) begin `ASSERT(o_pipe_stalled == o_busy); end else if (o_pipe_stalled) `ASSERT(o_busy); // // Only ever abort on reset",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(cyc))&&(!$past(i_wb_err))) begin if (($past(i_pipe_stb))&&(!$past(o_pipe_stalled))) begin `ASSERT(cyc); end else if ($past(f_outstanding > 1)) begin `ASSERT(cyc); end else if (($past(f_outstanding == 1)) &&((!$past(i_wb_ack)) ||(($past(f_stb)) &&(!$past(i_wb_stall))))) begin `ASSERT(cyc); end else if (($past(f_outstanding == 0)) &&($past(f_stb)&&(!$past(i_wb_ack)))) `ASSERT(cyc); end",
            "always @(posedge i_clk) if ((OPT_PIPE)&&(f_past_valid)&&(!$past(i_reset))&&(state != DC_READC)) begin if ($past(cyc && i_wb_err)) begin `ASSERT(npending == 0); end else if (($past(i_pipe_stb))||($past(i_wb_stall && stb))) begin `ASSERT((npending == f_outstanding+1) ||(npending == f_outstanding+2)); end else `ASSERT(npending == { 1'b0, f_outstanding }); end",
            "always @(posedge i_clk) if ((OPT_PIPE)&&(state != DC_READC)&&(state != DC_IDLE)) `ASSERT(last_ack == (npending <= 1));",
            "always @(*) `ASSERT(stb == f_stb);",
            "always @(*) if (r_rd_pending) `ASSERT(!r_svalid);",
            "always @(*) if (o_err) `ASSUME(!i_pipe_stb);",
            "always @(*) if (last_tag_valid) `ASSERT(|c_v);",
            "always @(posedge i_clk) if (cyc &&(state == DC_READC)&&($past(f_nacks > 0))) `ASSERT(!c_v[r_cline]);",
            "always @(*) if (last_tag_valid) begin `ASSERT((!cyc)||(o_wb_we)||(state == DC_READS) ||(o_wb_addr[AW-1:LS] != last_tag)); end",
            "wire f_cachable_last_tag, f_cachable_r_addr; iscachable #(.ADDRESS_WIDTH(AW+WBLSB)) fccheck_last_tag({last_tag, {(LS+WBLSB){1'b0}} }, f_cachable_last_tag); iscachable #( .ADDRESS_WIDTH(AW+WBLSB) ) fccheck_r_cachable({ r_addr, {(WBLSB){1'b0}} }, f_cachable_r_addr);",
            "always @(*) if ((r_cachable)&&(r_rd_pending)) begin `ASSERT(state != DC_WRITE); // `ASSERT(state != DC_READS); `ASSERT(f_cachable_r_addr); if (cyc && (stb || !OPT_LOWPOWER)) `ASSERT(o_wb_addr[AW-1:LS] == r_addr[AW-1:LS]); end",
            "always @(*) if (last_tag_valid) begin `ASSERT(f_cachable_last_tag); `ASSERT(c_v[last_tag[CS-LS-1:0]]); `ASSERT(c_vtags[last_tag[CS-LS-1:0]]==last_tag); `ASSERT((state != DC_READC)||(last_tag != o_wb_addr[AW-1:LS])); end // }}} //////////////////////////////////////////////////////////////////////// // // Low power checks // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_LOWPOWER) begin : CHECK_LOWPOWER",
            "always @(posedge i_clk) if (!o_wb_stb_gbl && !o_wb_stb_lcl) begin assert($stable(o_wb_addr) || (o_wb_addr == 0)); assert($stable(o_wb_data) || (o_wb_data == 0)); assert($stable(o_wb_sel) || (o_wb_sel == 0) || (&o_wb_sel)); end",
            "always @(posedge i_clk) if (!o_valid && !o_err) begin assert($stable(o_data) || (o_data == 0)); end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Cover statements // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) cover(o_valid);",
            "always @(posedge i_clk) if (f_past_valid) cover($past(r_svalid)); generate if (OPT_PIPE) begin : PIPE_COVER",
            "wire recent_reset;",
            "reg [2:0] recent_reset_s",
            "reg ;",
            "initial recent_reset_s",
            "reg = -1;",
            "always @(posedge i_clk) if (i_reset) recent_reset_s",
            "reg <= -1; else recent_reset_s",
            "reg <= { recent_reset_s",
            "reg [1:0], 1'b0 };",
            "assign recent_reset = (i_reset)||(|recent_reset_s",
            "reg ); // // wire f_cvr_cread = (!recent_reset)&&(i_pipe_stb)&&(!i_op[0]) &&(w_cachable);",
            "wire f_cvr_cwrite = (!recent_reset)&&(i_pipe_stb)&&(i_op[0]) &&(!cache_miss_inow);",
            "wire f_cvr_writes = (!recent_reset)&&(i_pipe_stb)&&(i_op[0]) &&(!w_cachable);",
            "wire f_cvr_reads = (!recent_reset)&&(i_pipe_stb)&&(!i_op[0]) &&(!w_cachable);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_valid))) cover(o_valid);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_pipe_stb))) cover(i_pipe_stb);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_valid))&&($past(o_valid,2))) cover(o_valid);",
            "always @(posedge i_clk) cover(($past(f_cvr_cread))&&(f_cvr_cread));",
            "always @(posedge i_clk) cover(($past(f_cvr_cwrite))&&(f_cvr_cwrite));",
            "always @(posedge i_clk) cover(($past(f_cvr_writes))&&(f_cvr_writes)); /* * This cover statement will never pass. Why not? Because * cache reads must be separated from non-cache reads. Hence, * we can only allow a single non-cache read at a time, otherwise * we'd bypass the cache read",
            "logic . *",
            "always @(posedge i_clk) cover(($past(f_cvr_reads))&&(f_cvr_reads)); */ // // This is unrealistic, as it depends upon the Wishbone // acknoledging the request on the same cycle",
            "always @(posedge i_clk) cover(($past(f_cvr_reads,2))&&(f_cvr_reads));",
            "always @(posedge i_clk) cover(($past(r_dvalid))&&(r_svalid)); // // A minimum of one clock must separate two dvalid's. // This option is rather difficult to cover, since it means // we must first load two separate cache lines before // this can even be tried.",
            "always @(posedge i_clk) cover(($past(r_dvalid,2))&&(r_dvalid)); // // This is the optimal configuration we want: // i_pipe_stb // ##1 i_pipe_stb && r_svalid // ##1 r_svalid && o_valid // ##1 o_valid // It proves that we can handle a 2 clock delay, but that // we can also pipelin these cache accesses, so this // 2-clock delay becomes a 1-clock delay between pipelined // memory reads. // always @(posedge i_clk) cover(($past(r_svalid))&&(r_svalid)); // // While we'd never do this (it breaks the ZipCPU's pipeline // rules), it's nice to know we could. // i_pipe_stb && (!i_op[0]) // a read // ##1 i_pipe_stb && (i_op[0]) && r_svalid // a write // ##1 o_valid",
            "always @(posedge i_clk) cover(($past(r_svalid))&&(f_cvr_writes)); /* Unreachable *",
            "always @(posedge i_clk) cover(($past(f_cvr_writes))&&(o_valid));",
            "always @(posedge i_clk) cover(($past(f_cvr_writes,2))&&(o_valid));",
            "always @(posedge i_clk) cover(($past(f_cvr_writes,3))&&(o_valid));",
            "always @(posedge i_clk) cover(($past(r_dvalid,3))&&(r_dvalid)); */",
            "always @(posedge i_clk) cover(($past(f_cvr_writes,4))&&(o_valid)); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Carelesss assumption section // {{{ //////////////////////////////////////////////////////////////////////// // // // // Can't jump from local to global mid lock",
            "always @(*) if((OPT_LOCK)&&(OPT_LOCAL_BUS)) begin if ((i_lock)&&(o_wb_cyc_gbl)&&(i_pipe_stb)) begin assume(!(&i_addr[(DATA_WIDTH-1):(DATA_WIDTH-8)])); end else if ((i_lock)&&(o_wb_cyc_lcl)&&(i_pipe_stb)) assume(&i_addr[(DATA_WIDTH-1):(DATA_WIDTH-8)]); end",
            "always @(*) if ((OPT_PIPE)&&(o_busy || i_lock)&&(!o_pipe_stalled)) begin if (i_pipe_stb) assume((!OPT_LOCAL_BUS) ||(f_pending_addr[AW]==(&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]))); end // If the bus is active, but we allow a second item in anyway 'cause // we are piped, then assume that we don't cross from local to global // buses",
            "always @(posedge i_clk) if ((OPT_PIPE)&&(o_busy)&&(i_pipe_stb)) begin `ASSUME(i_op[0] == o_wb_we); if (o_wb_cyc_lcl) begin assume(&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]); end else assume(!(&i_addr[DATA_WIDTH-1:DATA_WIDTH-8])); end // Assume aligned accesses",
            "always @(*) if (i_pipe_stb) casez(i_op[2:1]) 2'b0?: assume(i_addr[1:0] == 2'b00); 2'b10: assume(i_addr[ 0] == 1'b0); 2'b11: begin end endcase // always @(posedge i_clk) // if ((f_past_valid)&&(!$past(cyc))&&(!cyc)) // assume((!i_wb_err)&&(!i_wb_ack)); // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "memops.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/memops.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: memops.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A memory unit to support a CPU. // // In the interests of code simplicity, this memory operator is // susceptible to unknown results should a new command be sent to it // before it completes the last one. Unpredictable results might then // occurr. // // BIG ENDIAN // Note that this core assumes a big endian bus, with the MSB // of the bus word being the least bus address // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module memops #( // {{{",
            "parameter ADDRESS_WIDTH=28, parameter DATA_WIDTH=32, // CPU's",
            "reg ister width",
            "parameter BUS_WIDTH=32, parameter [0:0] OPT_LOCK=1'b1, WITH_LOCAL_BUS=1'b1, OPT_ALIGNMENT_ERR=1'b1, OPT_LOWPOWER=1'b0, OPT_LITTLE_ENDIAN = 1'b0, localparam AW=ADDRESS_WIDTH `ifdef FORMAL , parameter F_LGDEPTH = 2 `endif // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // CPU interface // {{{",
            "input wire i_stb, i_lock, input wire [2:0] i_op, input wire [31:0] i_addr, input wire [DATA_WIDTH-1:0] i_data, input wire [4:0] i_o",
            "reg , // CPU",
            "output s",
            "output wire o_busy, output reg o_rdbusy, output reg o_valid, output reg o_err, output reg [4:0] o_w",
            "reg , output reg [DATA_WIDTH-1:0] o_result, // }}} // Wishbone // {{{",
            "output wire o_wb_cyc_gbl, output wire o_wb_cyc_lcl, output reg o_wb_stb_gbl, output reg o_wb_stb_lcl, output reg o_wb_we, output reg [AW-1:0] o_wb_addr, output reg [BUS_WIDTH-1:0] o_wb_data, output reg [BUS_WIDTH/8-1:0] o_wb_sel, // Wishbone",
            "input s",
            "input wire i_wb_stall, i_wb_ack, i_wb_err, input wire [BUS_WIDTH-1:0] i_wb_data // }}} // }}} ); // Declarations // {{{",
            "localparam WBLSB = $clog2(BUS_WIDTH/8); `ifdef FORMAL",
            "wire [(F_LGDEPTH-1):0] f_nreqs, f_nacks, f_outstanding; `endif",
            "wire misaligned;",
            "reg r_wb_cyc_gbl, r_wb_cyc_lcl;",
            "reg [2+WBLSB-1:0] r_op;",
            "wire lock_gbl, lock_lcl;",
            "wire lcl_bus, gbl_stb, lcl_stb;",
            "reg [BUS_WIDTH/8-1:0] oword_sel;",
            "wire [BUS_WIDTH/8-1:0] pre_sel;",
            "wire [BUS_WIDTH-1:0] pre_result;",
            "wire [1:0] oshift2;",
            "wire [WBLSB-1:0] oshift; // }}} // misaligned // {{{ generate if (OPT_ALIGNMENT_ERR) begin : GENERATE_ALIGNMENT_ERR",
            "reg r_misaligned;",
            "always @(*) casez({ i_op[2:1], i_addr[1:0] }) 4'b01?1: r_misaligned = i_stb; // Words must be halfword aligned 4'b0110: r_misaligned = i_stb; // Words must be word aligned 4'b10?1: r_misaligned = i_stb; // Halfwords must be aligned // 4'b11??: r_misaligned <= 1'b0; Byte access are never misaligned default: r_misaligned = 1'b0; endcase",
            "assign misaligned = r_misaligned; end else begin : NO_MISALIGNMENT_ERR",
            "assign misaligned = 1'b0; end endgenerate // }}} // lcl_stb, gbl_stb // {{{",
            "assign lcl_bus = (WITH_LOCAL_BUS)&&(i_addr[31:24]==8'hff);",
            "assign lcl_stb = (i_stb)&&( lcl_bus)&&(!misaligned);",
            "assign gbl_stb = (i_stb)&&(!lcl_bus)&&(!misaligned); // }}} // r_wb_cyc_gbl, r_wb_cyc_lcl // {{{",
            "initial r_wb_cyc_gbl = 1'b0;",
            "initial r_wb_cyc_lcl = 1'b0;",
            "always @(posedge i_clk) if (i_reset) begin r_wb_cyc_gbl <= 1'b0; r_wb_cyc_lcl <= 1'b0; end else if ((r_wb_cyc_gbl)||(r_wb_cyc_lcl)) begin if ((i_wb_ack)||(i_wb_err)) begin r_wb_cyc_gbl <= 1'b0; r_wb_cyc_lcl <= 1'b0; end end else begin // New memory operation // Grab the wishbone r_wb_cyc_lcl <= (lcl_stb); r_wb_cyc_gbl <= (gbl_stb); end // }}} // o_wb_stb_gbl // {{{",
            "initial o_wb_stb_gbl = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_wb_stb_gbl <= 1'b0; else if ((i_wb_err)&&(r_wb_cyc_gbl)) o_wb_stb_gbl <= 1'b0; else if (gbl_stb) o_wb_stb_gbl <= 1'b1; else if (o_wb_cyc_gbl) o_wb_stb_gbl <= (o_wb_stb_gbl)&&(i_wb_stall); // }}} // o_wb_stb_lcl // {{{",
            "initial o_wb_stb_lcl = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_wb_stb_lcl <= 1'b0; else if ((i_wb_err)&&(r_wb_cyc_lcl)) o_wb_stb_lcl <= 1'b0; else if (lcl_stb) o_wb_stb_lcl <= 1'b1; else if (o_wb_cyc_lcl) o_wb_stb_lcl <= (o_wb_stb_lcl)&&(i_wb_stall); // }}} // o_wb_we, o_wb_data, o_wb_sel // {{{",
            "always @(*) begin oword_sel = 0; casez({ OPT_LITTLE_ENDIAN, i_op[2:1], i_addr[1:0] }) 5'b00???: oword_sel[3:0] = 4'b1111; 5'b0100?: oword_sel[3:0] = 4'b1100; 5'b0101?: oword_sel[3:0] = 4'b0011; 5'b01100: oword_sel[3:0] = 4'b1000; 5'b01101: oword_sel[3:0] = 4'b0100; 5'b01110: oword_sel[3:0] = 4'b0010; 5'b01111: oword_sel[3:0] = 4'b0001; // // verilator coverage_off 5'b10???: oword_sel[3:0] = 4'b1111; 5'b1100?: oword_sel[3:0] = 4'b0011; 5'b1101?: oword_sel[3:0] = 4'b1100; 5'b11100: oword_sel[3:0] = 4'b0001; 5'b11101: oword_sel[3:0] = 4'b0010; 5'b11110: oword_sel[3:0] = 4'b0100; 5'b11111: oword_sel[3:0] = 4'b1000; // verilator coverage_on // default: oword_sel[3:0] = 4'b1111; endcase end // pre_sel // {{{ generate if (BUS_WIDTH == 32) begin : COPY_PRESEL",
            "assign pre_sel = oword_sel; end else if (OPT_LITTLE_ENDIAN) begin : GEN_LILPRESEL",
            "wire [WBLSB-3:0] shift;",
            "assign shift = i_addr[WBLSB-1:2];",
            "assign pre_sel = oword_sel << (4 * i_addr[WBLSB-1:2]); end else begin : GEN_PRESEL",
            "wire [WBLSB-3:0] shift;",
            "assign shift = {(WBLSB-2){1'b1}} ^ i_addr[WBLSB-1:2];",
            "assign pre_sel = oword_sel << (4 * shift); end endgenerate // }}}",
            "assign oshift = i_addr[WBLSB-1:0];",
            "assign oshift2 = i_addr[1:0];",
            "initial o_wb_we = 1'b0;",
            "initial o_wb_data = 0;",
            "initial o_wb_sel = 0;",
            "always @(posedge i_clk) if (i_stb) begin o_wb_we <= i_op[0]; if (OPT_LOWPOWER) begin if (lcl_bus) begin // {{{ o_wb_data <= 0; casez({ OPT_LITTLE_ENDIAN, i_op[2:1] }) 3'b010: o_wb_data[31:0] <= { i_data[15:0], {(16){1'b0}} } >> (8*oshift2); 3'b011: o_wb_data[31:0] <= { i_data[ 7:0], {(24){1'b0}} } >> (8*oshift2); 3'b00?: o_wb_data[31:0] <= i_data[31:0]; // // verilator coverage_off 3'b110: o_wb_data <= { {(BUS_WIDTH-16){1'b0}}, i_data[15:0] } << (8*oshift2); 3'b111: o_wb_data <= { {(BUS_WIDTH-8){1'b0}}, i_data[ 7:0] } << (8*oshift2); 3'b10?: o_wb_data <= { {(BUS_WIDTH-32){1'b0}}, i_data[31:0] } << (8*oshift2); // verilator coverage_on // endcase // }}} end else begin // {{{ casez({ OPT_LITTLE_ENDIAN, i_op[2:1] }) 3'b010: o_wb_data <= { i_data[15:0], {(BUS_WIDTH-16){1'b0}} } >> (8*oshift); 3'b011: o_wb_data <= { i_data[ 7:0], {(BUS_WIDTH- 8){1'b0}} } >> (8*oshift); 3'b00?: o_wb_data <= { i_data[31:0], {(BUS_WIDTH-32){1'b0}} } >> (8*oshift); // 3'b110: o_wb_data <= { {(BUS_WIDTH-16){1'b0}}, i_data[15:0] } << (8*oshift); 3'b111: o_wb_data <= { {(BUS_WIDTH-8){1'b0}}, i_data[ 7:0] } << (8*oshift); 3'b10?: o_wb_data <= { {(BUS_WIDTH-32){1'b0}}, i_data[31:0] } << (8*oshift); // endcase // }}} end end else casez({ i_op[2:1] }) 2'b10: o_wb_data <= { (BUS_WIDTH/16){ i_data[15:0] } }; 2'b11: o_wb_data <= { (BUS_WIDTH/ 8){ i_data[7:0] } }; default: o_wb_data <= {(BUS_WIDTH/32){i_data}}; endcase if (lcl_bus) begin o_wb_addr <= i_addr[2 +: (AW+2>32 ? (32-2) : AW)]; o_wb_sel <= oword_sel; end else begin o_wb_addr <= i_addr[WBLSB +: (AW+WBLSB>32 ? (32-WBLSB) : AW)]; o_wb_sel <= pre_sel; end r_op <= { i_op[2:1] , i_addr[WBLSB-1:0] }; end else if ((OPT_LOWPOWER)&&(!o_wb_cyc_gbl)&&(!o_wb_cyc_lcl)) begin o_wb_we <= 1'b0; o_wb_addr <= 0; o_wb_data <= {(BUS_WIDTH){1'b0}}; o_wb_sel <= {(BUS_WIDTH/8){1'b0}}; end // }}} // o_valid // {{{",
            "initial o_valid = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_valid <= 1'b0; else o_valid <= (((o_wb_cyc_gbl)||(o_wb_cyc_lcl)) &&(i_wb_ack)&&(!o_wb_we)); // }}} // o_err // {{{",
            "initial o_err = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_err <= 1'b0; else if ((r_wb_cyc_gbl)||(r_wb_cyc_lcl)) o_err <= i_wb_err; else if ((i_stb)&&(!o_busy)) o_err <= misaligned; else o_err <= 1'b0; // }}}",
            "assign o_busy = (r_wb_cyc_gbl)||(r_wb_cyc_lcl); // o_rdbusy // {{{",
            "initial o_rdbusy = 1'b0;",
            "always @(posedge i_clk) if (i_reset|| ((o_wb_cyc_gbl || o_wb_cyc_lcl)&&(i_wb_err || i_wb_ack))) o_rdbusy <= 1'b0; else if (i_stb && !i_op[0] && !misaligned) o_rdbusy <= 1'b1; else if (o_valid) o_rdbusy <= 1'b0; // }}}",
            "always @(posedge i_clk) if (i_stb) o_w",
            "reg <= i_o",
            "reg ; // o_result // {{{ generate if (OPT_LITTLE_ENDIAN) begin : LILEND_RESULT",
            "assign pre_result = i_wb_data >> (8*r_op[$clog2(BUS_WIDTH/8)-1:0]); end else begin : BIGEND_RESULT",
            "assign pre_result = i_wb_data << (8*r_op[$clog2(BUS_WIDTH/8)-1:0]); end endgenerate",
            "always @(posedge i_clk) if ((OPT_LOWPOWER)&&(!i_wb_ack)) o_result <= 32'h0; else if (o_wb_cyc_lcl && (BUS_WIDTH != 32)) begin // The Local bus is naturally (and only) a 32-bit bus casez({ OPT_LITTLE_ENDIAN, r_op[WBLSB +: 2], r_op[1:0] }) 5'b?01??: o_result <= i_wb_data[31:0]; // // Big endian 5'b0100?: o_result <= { 16'h00, i_wb_data[31:16] }; 5'b0101?: o_result <= { 16'h00, i_wb_data[15: 0] }; 5'b01100: o_result <= { 24'h00, i_wb_data[31:24] }; 5'b01101: o_result <= { 24'h00, i_wb_data[23:16] }; 5'b01110: o_result <= { 24'h00, i_wb_data[15: 8] }; 5'b01111: o_result <= { 24'h00, i_wb_data[ 7: 0] }; // // Little endian : Same bus result, just grab a different bits // from the bus return to send back to the CPU. // verilator coverage_off 5'b1100?: o_result <= { 16'h00, i_wb_data[15: 0] }; 5'b1101?: o_result <= { 16'h00, i_wb_data[31:16] }; 5'b11100: o_result <= { 24'h00, i_wb_data[ 7: 0] }; 5'b11101: o_result <= { 24'h00, i_wb_data[15: 8] }; 5'b11110: o_result <= { 24'h00, i_wb_data[23:16] }; 5'b11111: o_result <= { 24'h00, i_wb_data[31:24] }; // verilator coverage_on default: o_result <= i_wb_data[31:0]; endcase end else begin casez({ OPT_LITTLE_ENDIAN, r_op[$clog2(BUS_WIDTH/8) +: 2] }) // Word // // Big endian 3'b00?: o_result <= pre_result[BUS_WIDTH-1:BUS_WIDTH-32]; 3'b010: o_result <= { 16'h00, pre_result[BUS_WIDTH-1:BUS_WIDTH-16] }; 3'b011: o_result <= { 24'h00, pre_result[BUS_WIDTH-1:BUS_WIDTH-8] }; // // Little endian : Same bus result, just grab a different bits // from the bus return to send back to the CPU. // verilator coverage_off 3'b10?: o_result <= pre_result[31: 0]; 3'b110: o_result <= { 16'h00, pre_result[15: 0] }; 3'b111: o_result <= { 24'h00, pre_result[ 7: 0] }; // verilator coverage_on // // Just to have an (unused) default // default: o_result <= pre_result[31:0]; (Messes w/ coverage) endcase end // }}} // lock_gbl and lock_lcl // {{{ generate if (OPT_LOCK) begin : GEN_LOCK // {{{",
            "reg r_lock_gbl, r_lock_lcl;",
            "initial r_lock_gbl = 1'b0;",
            "initial r_lock_lcl = 1'b0;",
            "always @(posedge i_clk) if (i_reset) begin r_lock_gbl <= 1'b0; r_lock_lcl <= 1'b0; end else if (((i_wb_err)&&((r_wb_cyc_gbl)||(r_wb_cyc_lcl))) ||(misaligned)) begin // Kill the lock if // there's a bus error, or // User requests a misaligned memory op r_lock_gbl <= 1'b0; r_lock_lcl <= 1'b0; end else begin // Kill the lock if // i_lock goes down // User starts on the global bus, then switches // to local or vice versa r_lock_gbl <= (i_lock)&&((r_wb_cyc_gbl)||(lock_gbl)) &&(!lcl_stb); r_lock_lcl <= (i_lock)&&((r_wb_cyc_lcl)||(lock_lcl)) &&(!gbl_stb); end",
            "assign lock_gbl = r_lock_gbl;",
            "assign lock_lcl = r_lock_lcl;",
            "assign o_wb_cyc_gbl = (r_wb_cyc_gbl)||(lock_gbl);",
            "assign o_wb_cyc_lcl = (r_wb_cyc_lcl)||(lock_lcl); // }}} end else begin : NO_LOCK // {{{",
            "assign o_wb_cyc_gbl = (r_wb_cyc_gbl);",
            "assign o_wb_cyc_lcl = (r_wb_cyc_lcl);",
            "assign { lock_gbl, lock_lcl } = 2'b00; // Make verilator happy // verilator lint_off UNUSED",
            "wire [2:0] lock_unused;",
            "assign lock_unused = { i_lock, lock_gbl, lock_lcl }; // verilator lint_on UNUSED // }}} end endgenerate // }}} `ifdef VERILATOR",
            "always @(posedge i_clk) if ((r_wb_cyc_gbl)||(r_wb_cyc_lcl)) assert(!i_stb); `endif // Make verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, pre_result }; generate if (AW < 22) begin : TOO_MANY_ADDRESS_BITS",
            "wire [(21-AW):0] unused_addr;",
            "assign unused_addr = i_addr[23:(AW+2)]; end endgenerate // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL `define ASSERT assert `ifdef MEMOPS `define ASSUME assume `else `define ASSUME assert `endif",
            "reg f_past_valid;",
            "reg [2:0] fcpu_op;",
            "reg [31:0] fcpu_addr, fcpu_data;;",
            "reg [BUS_WIDTH-1:0] fbus_data, fpre_data;",
            "reg [$clog2(BUS_WIDTH/8)-1:0] fcpu_shift;",
            "reg fcpu_local, fcpu_misaligned;",
            "reg [BUS_WIDTH/8-1:0] fbus_sel, fpre_sel;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "always @(*) if (!f_past_valid) `ASSUME(i_reset); //////////////////////////////////////////////////////////////////////// // // Bus properties // {{{ //////////////////////////////////////////////////////////////////////// // // initial `ASSUME(!i_stb);",
            "wire f_cyc, f_stb;",
            "assign f_cyc = (o_wb_cyc_gbl)||(o_wb_cyc_lcl);",
            "assign f_stb = (o_wb_stb_gbl)||(o_wb_stb_lcl); fwb_master #( // {{{ .AW(AW), .F_LGDEPTH(F_LGDEPTH), .DW(BUS_WIDTH), .F_OPT_RMW_BUS_OPTION(OPT_LOCK), .F_OPT_DISCONTINUOUS(OPT_LOCK) // }}} ) f_wb( // {{{ i_clk, i_reset, f_cyc, f_stb, o_wb_we, o_wb_addr, o_wb_data, o_wb_sel, i_wb_ack, i_wb_stall, i_wb_data, i_wb_err, f_nreqs, f_nacks, f_outstanding // }}} ); // Rule: Only one of the two CYC's may be valid, never both",
            "always @(posedge i_clk) `ASSERT((!o_wb_cyc_gbl)||(!o_wb_cyc_lcl)); // Rule: Only one of the two STB's may be valid, never both",
            "always @(posedge i_clk) `ASSERT((!o_wb_stb_gbl)||(!o_wb_stb_lcl)); // Rule: if WITH_LOCAL_BUS is ever false, neither the local STB nor CYC // may be valid",
            "always @(*) if (!WITH_LOCAL_BUS) begin `ASSERT(!o_wb_cyc_lcl); `ASSERT(!o_wb_stb_lcl); end // Rule: If the global CYC is ever true, the LCL one cannot be true // on the next clock without an intervening idle of both",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(r_wb_cyc_gbl))) `ASSERT(!r_wb_cyc_lcl); // Same for if the LCL CYC is true",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(r_wb_cyc_lcl))) `ASSERT(!r_wb_cyc_gbl); // STB can never be true unless CYC is also true",
            "always @(posedge i_clk) if (o_wb_stb_gbl) `ASSERT(r_wb_cyc_gbl);",
            "always @(posedge i_clk) if (o_wb_stb_lcl) `ASSERT(r_wb_cyc_lcl); // This core only ever has zero or one outstanding transaction(s)",
            "always @(posedge i_clk) if ((o_wb_stb_gbl)||(o_wb_stb_lcl)) begin `ASSERT(f_outstanding == 0); end else `ASSERT((f_outstanding == 0)||(f_outstanding == 1)); // The LOCK function only allows up to two transactions (at most) // before CYC must be dropped.",
            "always @(posedge i_clk) if ((o_wb_stb_gbl)||(o_wb_stb_lcl)) begin if (OPT_LOCK) begin `ASSERT((f_outstanding == 0)||(f_outstanding == 1)); end else `ASSERT(f_nreqs <= 1); end // }}} //////////////////////////////////////////////////////////////////////// // // CPU properties // {{{ //////////////////////////////////////////////////////////////////////// // // reg f_done;",
            "wire [(F_LGDEPTH-1):0] cpu_outstanding;",
            "wire f_pc, f_rdbusy, f_gie, f_read_cycle;",
            "wire [4:0] f_last_",
            "reg ;",
            "wire [4:0] f_addr_",
            "reg ; // Verilator lint_off UNDRIVEN (* anyseq *)",
            "reg [4:0] f_a",
            "reg ; // Verilator lint_on UNDRIVEN",
            "assign f_rdbusy = f_cyc && (f_stb || f_outstanding > 0) && !o_wb_we;",
            "initial f_done = 1'b0;",
            "always @(posedge i_clk) if (i_reset) f_done <= 1'b0; else f_done <= ((o_wb_cyc_gbl)||(o_wb_cyc_lcl))&&(i_wb_ack); fmem #( // {{{ .F_LGDEPTH(F_LGDEPTH), .OPT_LOCK(OPT_LOCK), .OPT_MAXDEPTH(1) // }}} ) fmemi( // {{{ .i_clk(i_clk), .i_sys_reset(i_reset), .i_cpu_reset(i_reset), .i_stb(i_stb), .i_pipe_stalled(o_busy), .i_clear_cache(1'b0), .i_lock(i_lock), .i_op(i_op), .i_addr(i_addr), .i_data(i_data), .i_o",
            "reg (i_o",
            "reg ), .i_a",
            "reg (f_a",
            "reg ), .i_busy(o_busy), .i_rdbusy(f_rdbusy), .i_valid(o_valid), .i_done(f_done), .i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_result), .f_outstanding(cpu_outstanding), .f_pc(f_pc), .f_gie(f_gie), .f_read_cycle(f_read_cycle), .f_last_",
            "reg (f_last_",
            "reg ), .f_addr_",
            "reg (f_addr_",
            "reg ) // }}} );",
            "always @(*) if (!o_err) assert(cpu_outstanding == f_outstanding + (f_stb ? 1:0) + ((f_done || o_err) ? 1:0));",
            "always @(*) assert(cpu_outstanding <= 1);",
            "always @(*) if (f_pc) begin assert(o_w",
            "reg [3:1] == 3'h7); end else if (f_rdbusy) assert(o_w",
            "reg [3:1] != 3'h7);",
            "always @(*) if (o_busy) assert(o_w",
            "reg [4] == f_gie);",
            "always @(*) if (!o_err) assert(f_rdbusy == o_rdbusy);",
            "always @(*) if (o_busy) assert(o_wb_we == !f_read_cycle);",
            "always @(*) if (cpu_outstanding > 0) assert(f_last_",
            "reg == o_w",
            "reg ); // }}} //////////////////////////////////////////////////////////////////////// // // Tying the two together // {{{ //////////////////////////////////////////////////////////////////////// // // // Following any i_stb request, assuming we are idle, immediately // begin a bus transaction",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_stb)) &&(!$past(f_cyc))&&(!$past(i_reset))) begin if ($past(misaligned)) begin `ASSERT(!f_cyc); `ASSERT(!o_busy); `ASSERT(o_err); `ASSERT(!o_valid); end else begin `ASSERT(f_cyc); `ASSERT(o_busy); end end // always @(posedge i_clk) // if (o_busy) // `ASSUME(!i_stb);",
            "always @(*) if (o_err || o_valid) `ASSERT(!o_busy);",
            "always @(posedge i_clk) if (o_wb_cyc_gbl) `ASSERT((o_busy)||(lock_gbl));",
            "always @(posedge i_clk) if (o_wb_cyc_lcl) `ASSERT((o_busy)||(lock_lcl));",
            "always @(posedge i_clk) if (f_outstanding > 0) `ASSERT(o_busy); // If a transaction ends in an error, send o_err on the",
            "output port.",
            "always @(posedge i_clk) if (f_past_valid && !$past(i_reset)) begin if (($past(f_cyc))&&($past(i_wb_err))) begin `ASSERT(o_err); end else if ($past(misaligned)) `ASSERT(o_err); end // Always following a successful ACK, return an O_VALID value.",
            "always @(posedge i_clk) if (f_past_valid && !$past(i_reset)) begin if(($past(f_cyc))&&($past(i_wb_ack)) &&(!$past(o_wb_we))) begin `ASSERT(o_valid); end else if ($past(misaligned)) begin `ASSERT((!o_valid)&&(o_err)); end else `ASSERT(!o_valid); end",
            "always @(posedge i_clk) if (i_stb) begin fcpu_op <= i_op; fcpu_addr <= i_addr; fcpu_data <= i_data; end",
            "always @(*) begin fcpu_local = (&fcpu_addr[31:24]) && WITH_LOCAL_BUS; if (OPT_LITTLE_ENDIAN) begin // {{{ casez(fcpu_op[2:1]) 2'b11: fpre_sel = { {(BUS_WIDTH/8-1){1'b0}}, 1'b1 }; 2'b10: fpre_sel = { {(BUS_WIDTH/8-2){1'b0}}, 2'b11 }; 2'b0?: fpre_sel = { {(BUS_WIDTH/8-4){1'b0}}, 4'b1111 }; endcase casez(fcpu_op[2:1]) 2'b11: fpre_data = { {(BUS_WIDTH- 8){1'b0}}, fcpu_data[ 7:0] }; 2'b10: fpre_data = { {(BUS_WIDTH-16){1'b0}}, fcpu_data[15:0] }; 2'b0?: fpre_data = { {(BUS_WIDTH-32){1'b0}}, fcpu_data[31:0] }; endcase // }}} end else if (fcpu_local) begin // {{{ fpre_sel = 0; casez(fcpu_op[2:1]) 2'b11: fpre_sel[3:0] = 4'b1000; 2'b10: fpre_sel[3:0] = 4'b1100; 2'b0?: fpre_sel[3:0] = 4'b1111; endcase fpre_data = 0; casez(fcpu_op[2:1]) 2'b11: fpre_data[31:0] = { fcpu_data[ 7:0], {(24){1'b0}} }; 2'b10: fpre_data[31:0] = { fcpu_data[15:0], {(16){1'b0}} }; 2'b0?: fpre_data[31:0] = fcpu_data[31:0]; endcase // }}} end else begin // {{{ casez(fcpu_op[2:1]) 2'b11: fpre_sel = { 1'b1, {(BUS_WIDTH/8-1){1'b0}} }; 2'b10: fpre_sel = { 2'b11, {(BUS_WIDTH/8-2){1'b0}} }; 2'b0?: fpre_sel = { 4'b1111, {(BUS_WIDTH/8-4){1'b0}} }; endcase casez(fcpu_op[2:1]) 2'b11: fpre_data = { fcpu_data[ 7:0], {(BUS_WIDTH- 8){1'b0}} }; 2'b10: fpre_data = { fcpu_data[15:0], {(BUS_WIDTH-16){1'b0}} }; 2'b0?: fpre_data = { fcpu_data[31:0], {(BUS_WIDTH-32){1'b0}} }; endcase // }}} end casez({ fcpu_op[2:1], fcpu_addr[1:0] }) 4'b01?1: fcpu_misaligned = 1'b1; // Words must be halfword aligned 4'b0110: fcpu_misaligned = 1'b1; // Words must be word aligned 4'b10?1: fcpu_misaligned = 1'b1; // Halfwords must be aligned // 4'b11??: fcpu_misaligned <= 1'b0; Byte access are never misaligned default: fcpu_misaligned = 1'b0; endcase if (fcpu_local) begin fcpu_shift = fcpu_addr[1:0]; if (OPT_LITTLE_ENDIAN) begin fbus_sel = fpre_sel << fcpu_shift; fbus_data = fpre_data << (8*fcpu_shift); end else begin fbus_sel = fpre_sel >> (fcpu_shift + (DATA_WIDTH/8-4)); fbus_data = fpre_data >> (8*(fcpu_shift + (DATA_WIDTH/8-4))); end end else begin fcpu_shift = fcpu_addr[WBLSB-1:0]; if (OPT_LITTLE_ENDIAN) begin fbus_sel = fpre_sel << fcpu_shift; fbus_data = fpre_data << (8*fcpu_shift); end else begin fbus_sel = fpre_sel >> fcpu_shift; fbus_data = fpre_data >> (8*fcpu_shift); end end if (!OPT_LOWPOWER) casez(fcpu_op[2:1]) 2'b11: fbus_data = {(BUS_WIDTH/ 8){fcpu_data[ 7:0] } }; 2'b10: fbus_data = {(BUS_WIDTH/16){fcpu_data[15:0] } }; 2'b0?: fbus_data = {(BUS_WIDTH/32){fcpu_data[31:0] } }; endcase end",
            "always @(*) if (OPT_ALIGNMENT_ERR && fcpu_misaligned) assert(!o_valid && !f_cyc);",
            "always @(*) if (f_stb) begin if (fcpu_local) begin assert(o_wb_stb_lcl); assert(o_wb_addr == fcpu_addr[AW+1:2]); end else begin assert(o_wb_stb_gbl); assert(o_wb_addr == fcpu_addr[WBLSB +: AW]); end if (fcpu_op[0]) begin `ASSERT(o_wb_we); `ASSERT(fcpu_misaligned || o_wb_sel == fbus_sel); `ASSERT(fcpu_misaligned || o_wb_data == fbus_data); end else begin `ASSERT(!o_wb_we); end end",
            "always @(*) if (f_cyc) assert(o_wb_cyc_lcl == fcpu_local);",
            "initial o_wb_we = 1'b0;",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_stb))) begin // On a write, assert o_wb_we should be true assert( $past(i_op[0]) == o_wb_we); end",
            "always @(posedge i_clk) if (o_wb_stb_lcl) `ASSERT(fcpu_local);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(misaligned))) begin `ASSERT(!o_wb_cyc_gbl); `ASSERT(!o_wb_cyc_lcl); `ASSERT(!o_wb_stb_gbl); `ASSERT(!o_wb_stb_lcl); `ASSERT(o_err); end // always @(posedge i_clk) // if ((!f_past_valid)||($past(i_reset))) // `ASSUME(!i_stb);",
            "always @(posedge i_clk) if ((f_past_valid)&&(OPT_LOCK) &&(!$past(i_reset))&&(!$past(i_wb_err)) &&(!$past(misaligned)) &&(!$past(lcl_stb)) &&($past(i_lock))&&($past(lock_gbl))) assert(lock_gbl);",
            "always @(posedge i_clk) if ((f_past_valid)&&(OPT_LOCK) &&(!$past(i_reset))&&(!$past(i_wb_err)) &&(!$past(misaligned)) &&(!$past(lcl_stb)) &&($past(o_wb_cyc_gbl))&&($past(i_lock)) &&($past(lock_gbl))) assert(o_wb_cyc_gbl);",
            "always @(posedge i_clk) if ((f_past_valid)&&(OPT_LOCK) &&(!$past(i_reset))&&(!$past(i_wb_err)) &&(!$past(misaligned)) &&(!$past(gbl_stb)) &&($past(o_wb_cyc_lcl))&&($past(i_lock)) &&($past(lock_lcl))) assert(o_wb_cyc_lcl); // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) cover(i_wb_ack); // Cover a response on the same clock it is made",
            "always @(posedge i_clk) cover((o_wb_stb_gbl)&&(i_wb_ack)); // Cover a response a clock later",
            "always @(posedge i_clk) cover((o_wb_stb_gbl)&&(i_wb_ack));",
            "always @(posedge i_clk) cover(f_done);",
            "always @(posedge i_clk) cover(f_done && !o_busy); generate if (WITH_LOCAL_BUS) begin // Same things on the local bus",
            "always @(posedge i_clk) cover((o_wb_cyc_lcl)&&(!o_wb_stb_lcl)&&(i_wb_ack));",
            "always @(posedge i_clk) cover((o_wb_stb_lcl)&&(i_wb_ack)); end endgenerate // }}} // Make Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, f_nacks, f_addr_",
            "reg }; // Verilator lint_on UNUSED // }}} `endif // }}}",
            "endmodule // // // Usage (from yosys): // (BFOR) (!ZOI,ALIGN) (ZOI,ALIGN) (!ZOI,!ALIGN) // Cells 230 226 281 225 // FDRE 114 116 116 116 // LUT2 17 23 76 19 // LUT3 9 23 17 20 // LUT4 15 4 11 14 // LUT5 18 18 7 15 // LUT6 33 18 54 38 // MUX7 16 12 2 // MUX8 8 1 1 // //"
        ]
    },
    {
        "file_name": "wbpriarbiter.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/wbpriarbiter.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: wbpriarbiter.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This is a priority bus arbiter. It allows two separate wishbone // masters to connect to the same bus, while also guaranteeing // that one master can have the bus with no delay any time the other // master is not using the bus. The goal is to eliminate the combinatorial // logic required in the other wishbone arbiter, while still guarateeing // access time for the priority channel. // // The core",
            "logic works like this: // // 1. When no one requests the bus, 'A' is granted the bus and guaranteed // that any access will go right through. // 2. If 'B' requests the bus (asserts cyc), and the bus is idle, then // 'B' will be granted the bus. // 3. Bus grants last as long as the 'cyc' line is high. // 4. Once 'cyc' is dropped, the bus returns to 'A' as the owner. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module wbpriarbiter #( // {{{",
            "parameter DW=32, AW=32, // OPT_ZERO_ON_IDLE // {{{ // ZERO_ON_IDLE uses more",
            "logic than the alternative. It should // be useful for reducing power, as these circuits tend to drive // wire s all the way across the design, but it may also slow // down the master clock. I've used it as an option when using // VER1LATOR, 'cause zeroing things on idle can make them stand // out all the more when staring at",
            "wire s and dumps and such.",
            "parameter [0:0] OPT_ZERO_ON_IDLE = 1'b0 // }}} // }}} ) ( // {{{",
            "input wire i_clk, // Bus A // {{{",
            "input wire i_a_cyc, i_a_stb, i_a_we, input wire [(AW-1):0] i_a_adr, input wire [(DW-1):0] i_a_dat, input wire [(DW/8-1):0] i_a_sel, output wire o_a_stall, o_a_ack, o_a_err, // }}} // Bus B // {{{",
            "input wire i_b_cyc, i_b_stb, i_b_we, input wire [(AW-1):0] i_b_adr, input wire [(DW-1):0] i_b_dat, input wire [(DW/8-1):0] i_b_sel, output wire o_b_stall, o_b_ack, o_b_err, // }}} // Outgoing combined bus // {{{",
            "output wire o_cyc, o_stb, o_we, output wire [(AW-1):0] o_adr, output wire [(DW-1):0] o_dat, output wire [(DW/8-1):0] o_sel, input wire i_stall, i_ack, i_err // }}} // }}} );",
            "reg r_a_owner; // r_a_owner // {{{ // Go high immediately (new cycle) if ... // Previous cycle was low and *someone* is requesting a bus cycle // Go low immadiately if ... // We were just high and the owner no longer wants the bus // WISHBONE Spec recommends no",
            "logic between a FF and the o_cyc // This violates that spec. (Rec 3.15, p35)",
            "initial r_a_owner = 1'b1;",
            "always @(posedge i_clk) if (!i_b_cyc) r_a_owner <= 1'b1; // Allow B to set its CYC line w/o activating this interface else if ((i_b_cyc)&&(i_b_stb)&&(!i_a_cyc)) r_a_owner <= 1'b0; // }}} // CYC, STB, and WE // {{{ // Realistically, if neither master owns the bus, the",
            "output is a // don't care. Thus we trigger off whether or not 'A' owns the bus. // If 'B' owns it all we care is that 'A' does not. Likewise, if // neither owns the bus than the values on these various lines are // irrelevant.",
            "assign o_cyc = (r_a_owner) ? i_a_cyc : i_b_cyc;",
            "assign o_we = (r_a_owner) ? i_a_we : i_b_we;",
            "assign o_stb = (r_a_owner) ? i_a_stb : i_b_stb; // }}} // Everything else // {{{ generate if (OPT_ZERO_ON_IDLE) begin : OPT_LOWPOWER // {{{",
            "assign o_adr = (o_stb)?((r_a_owner) ? i_a_adr : i_b_adr):0;",
            "assign o_dat = (o_stb)?((r_a_owner) ? i_a_dat : i_b_dat):0;",
            "assign o_sel = (o_stb)?((r_a_owner) ? i_a_sel : i_b_sel):0;",
            "assign o_a_ack = (o_cyc)&&( r_a_owner) ? i_ack : 1'b0;",
            "assign o_b_ack = (o_cyc)&&(!r_a_owner) ? i_ack : 1'b0;",
            "assign o_a_stall = (o_cyc)&&( r_a_owner) ? i_stall : 1'b1;",
            "assign o_b_stall = (o_cyc)&&(!r_a_owner) ? i_stall : 1'b1;",
            "assign o_a_err = (o_cyc)&&( r_a_owner) ? i_err : 1'b0;",
            "assign o_b_err = (o_cyc)&&(!r_a_owner) ? i_err : 1'b0; // }}} end else begin : OPT_LOWLOGIC // {{{",
            "assign o_adr = (r_a_owner) ? i_a_adr : i_b_adr;",
            "assign o_dat = (r_a_owner) ? i_a_dat : i_b_dat;",
            "assign o_sel = (r_a_owner) ? i_a_sel : i_b_sel; // We cannot allow the return acknowledgement to ever go high if // the master in question does not own the bus. Hence we force it // low if the particular master doesn't own the bus.",
            "assign o_a_ack = ( r_a_owner) ? i_ack : 1'b0;",
            "assign o_b_ack = (!r_a_owner) ? i_ack : 1'b0; // Stall must be asserted on the same cycle the",
            "input master asserts // the bus, if the bus isn't granted to him.",
            "assign o_a_stall = ( r_a_owner) ? i_stall : 1'b1;",
            "assign o_b_stall = (!r_a_owner) ? i_stall : 1'b1; // // assign o_a_err = ( r_a_owner) ? i_err : 1'b0;",
            "assign o_b_err = (!r_a_owner) ? i_err : 1'b0; // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL `ifdef WBPRIARBITER `define ASSUME assume `else `define ASSUME assert `endif",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "initial assume(!i_a_cyc);",
            "initial assume(!i_a_stb);",
            "initial assume(!i_b_cyc);",
            "initial assume(!i_b_stb);",
            "initial assume(!i_ack);",
            "initial assume(!i_err);",
            "always @(posedge i_clk) begin if (o_cyc) assert((i_a_cyc)||(i_b_cyc)); if ((f_past_valid)&&($past(o_cyc))&&(o_cyc)) assert($past(r_a_owner) == r_a_owner); if ((f_past_valid)&&($past(!o_cyc))&&($past(i_a_stb))) assert(r_a_owner); if ((f_past_valid)&&($past(!o_cyc))&&($past(i_b_stb))) assert(!r_a_owner); end",
            "reg f_reset;",
            "initial f_reset = 1'b1;",
            "always @(posedge i_clk) f_reset <= 1'b0;",
            "always @(*) if (!f_past_valid) assert(f_reset);",
            "parameter F_LGDEPTH=3;",
            "wire [(F_LGDEPTH-1):0] f_nreqs, f_nacks, f_outstanding, f_a_nreqs, f_a_nacks, f_a_outstanding, f_b_nreqs, f_b_nacks, f_b_outstanding; fwb_master #( // {{{ .F_MAX_STALL(0), .F_LGDEPTH(F_LGDEPTH), .F_MAX_ACK_DELAY(0), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1) // }}} ) f_wbm( // {{{ i_clk, f_reset, o_cyc, o_stb, o_we, o_adr, o_dat, o_sel, i_ack, i_stall, 32'h0, i_err, f_nreqs, f_nacks, f_outstanding // }}} ); fwb_slave #( // {{{ .F_MAX_STALL(0), .F_LGDEPTH(F_LGDEPTH), .F_MAX_ACK_DELAY(0), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1) // }}} ) f_wba( // {{{ i_clk, f_reset, i_a_cyc, i_a_stb, i_a_we, i_a_adr, i_a_dat, i_a_sel, o_a_ack, o_a_stall, 32'h0, o_a_err, f_a_nreqs, f_a_nacks, f_a_outstanding // }}} ); fwb_slave #( // {{{ .F_MAX_STALL(0), .F_LGDEPTH(F_LGDEPTH), .F_MAX_ACK_DELAY(0), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1) // }}} ) f_wbb( // {{{ i_clk, f_reset, i_b_cyc, i_b_stb, i_b_we, i_b_adr, i_b_dat, i_b_sel, o_b_ack, o_b_stall, 32'h0, o_b_err, f_b_nreqs, f_b_nacks, f_b_outstanding // }}} ); // Induction, relate number of requests and acks to r_a_owner // {{{",
            "always @(posedge i_clk) if (r_a_owner) begin assert(f_b_nreqs == 0); assert(f_b_nacks == 0); assert(f_a_outstanding == f_outstanding); end else begin assert(f_a_nreqs == 0); assert(f_a_nacks == 0); assert(f_b_outstanding == f_outstanding); end // }}}",
            "always @(posedge i_clk) if ((r_a_owner)&&(i_b_cyc)) assume(i_b_stb);",
            "always @(posedge i_clk) if ((r_a_owner)&&(i_a_cyc)) assume(i_a_stb); `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "busdelay.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/busdelay.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: busdelay.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Delay any access to the wishbone bus by a single clock. // // When the first Zip System would not meet the timing requirements of // the board it was placed upon, this bus delay was added to help out. // It may no longer be necessary, having cleaned some other problems up // first, but it will remain here as a means of alleviating timing // problems. // // The specific problem takes place on the stall line: a wishbone master // *must* know on the first clock whether or not the bus will stall. // // // After a period of time, I started a new design where the timing // associated with this original bus clock just wasn't ... fast enough. // I needed to delay the stall line as well. A new busdelay was then // written and debugged whcih delays the stall line. (I know, you aren't // supposed to delay the stall line--but what if you *have* to in order // to meet timing?) This new",
            "logic has been merged in with the old, // and the DELAY_STALL line can be set to non-zero to use it instead // of the original",
            "logic . Don't use it if you don't need it: it will // consume resources and slow your bus down more, but if you do need // it--don't be afraid to use it. // // Both versions of the bus delay will maintain a single access per // clock when pipelined, they only delay the time between the strobe // going high and the actual command being accomplished. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module busdelay #( // {{{",
            "parameter AW=32, DW=32, `ifdef FORMAL",
            "localparam F_LGDEPTH=4, `endif",
            "parameter [0:0] DELAY_STALL = 1, parameter [0:0] OPT_LOWPOWER = 0 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Input/master bus // {{{",
            "input wire i_wb_cyc, i_wb_stb, i_wb_we, input wire [(AW-1):0] i_wb_addr, input wire [(DW-1):0] i_wb_data, input wire [(DW/8-1):0] i_wb_sel, output wire o_wb_stall, output reg o_wb_ack, output reg [(DW-1):0] o_wb_data, output reg o_wb_err, // }}} // Delayed bus // {{{",
            "output reg o_dly_cyc, o_dly_stb, o_dly_we, output reg [(AW-1):0] o_dly_addr, output reg [(DW-1):0] o_dly_data, output reg [(DW/8-1):0] o_dly_sel, input wire i_dly_stall, input wire i_dly_ack, input wire [(DW-1):0] i_dly_data, input wire i_dly_err // }}} // }}} ); `ifdef FORMAL",
            "wire [2+AW+DW+DW/8-1:0] f_wpending; `endif generate if (DELAY_STALL) begin : SKIDBUFFER // {{{",
            "reg r_stb, r_we;",
            "reg [(AW-1):0] r_addr;",
            "reg [(DW-1):0] r_data;",
            "reg [(DW/8-1):0] r_sel; // o_dly_cyc // {{{",
            "initial o_dly_cyc = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !i_wb_cyc) o_dly_cyc <= 1'b0; else o_dly_cyc <= (!o_wb_err)&&((!i_dly_err)||(!o_dly_cyc)); // }}} // o_dly_stb // {{{",
            "initial o_dly_stb = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !i_wb_cyc || o_wb_err || (o_dly_cyc && i_dly_err)) o_dly_stb <= 1'b0; else if (!o_dly_stb || !i_dly_stall) o_dly_stb <= i_wb_stb || r_stb; // }}} // r_stb // {{{",
            "initial r_stb = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !i_wb_cyc || o_wb_err || i_dly_err || !i_dly_stall || !o_dly_stb) r_stb <= 1'b0; else if (i_wb_stb && !o_wb_stall) // && (o_dly_stb&&i_dly_stall) r_stb <= 1'b1; // }}} // r_* // {{{",
            "initial { r_we, r_addr, r_data, r_sel } = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && (i_reset || !i_wb_cyc || i_dly_err || !o_dly_stb || !i_dly_stall)) { r_we, r_addr, r_data, r_sel } <= 0; else if (i_wb_stb && !o_wb_stall) // && (o_dly_stb&&i_dly_stall) { r_we, r_addr, r_data, r_sel } <= { i_wb_we, i_wb_addr, i_wb_data, i_wb_sel }; // }}}",
            "initial o_dly_we = 1'b0;",
            "initial o_dly_addr = 0;",
            "initial o_dly_data = 0;",
            "initial o_dly_sel = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && (i_reset || (!i_wb_cyc || o_wb_err || (o_dly_cyc && i_dly_err)))) { o_dly_we, o_dly_addr, o_dly_data, o_dly_sel } <= 0; else if (!o_dly_stb || !i_dly_stall) begin if (r_stb) { o_dly_we, o_dly_addr, o_dly_data, o_dly_sel } <= { r_we, r_addr, r_data, r_sel }; else if (!OPT_LOWPOWER || i_wb_stb) { o_dly_we, o_dly_addr, o_dly_data, o_dly_sel } <= { i_wb_we, i_wb_addr, i_wb_data, i_wb_sel }; else { o_dly_addr, o_dly_data, o_dly_sel } <= 0; end",
            "assign o_wb_stall = r_stb; // o_wb_ack // {{{",
            "initial o_wb_ack = 0;",
            "always @(posedge i_clk) if (i_reset || !i_wb_cyc || o_wb_err || !o_dly_cyc) o_wb_ack <= 1'b0; else o_wb_ack <= (i_dly_ack); // }}} // o_wb_data // {{{",
            "initial o_wb_data = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && (i_reset || !i_wb_cyc || !o_dly_cyc || o_wb_err || !i_dly_ack)) o_wb_data <= 0; else o_wb_data <= i_dly_data; // }}} // o_wb_err // {{{",
            "initial o_wb_err = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !i_wb_cyc || !o_dly_cyc) o_wb_err <= 1'b0; else o_wb_err <= i_dly_err; // }}} `ifdef FORMAL // {{{",
            "assign f_wpending = { r_stb, r_we, r_addr, r_data, r_sel };",
            "always @(*) if (OPT_LOWPOWER && !r_stb) begin assert(r_we == 0); assert(r_addr == 0); assert(r_data == 0); assert(r_sel == 0); end else if (r_stb) assert(r_we == o_dly_we); // }}} `endif // }}} end else begin : NO_SKIDBUFFER // {{{",
            "initial o_dly_cyc = 1'b0;",
            "initial o_dly_stb = 1'b0;",
            "initial o_dly_we = 1'b0;",
            "initial o_dly_addr = 0;",
            "initial o_dly_data = 0;",
            "initial o_dly_sel = 0;",
            "always @(posedge i_clk) if (i_reset) o_dly_cyc <= 1'b0; else if ((i_dly_err)&&(o_dly_cyc)) o_dly_cyc <= 1'b0; else if ((o_wb_err)&&(i_wb_cyc)) o_dly_cyc <= 1'b0; else o_dly_cyc <= i_wb_cyc; // Add the i_wb_cyc criteria here, so we can simplify the // o_wb_stall criteria below, which would otherwise *and* // these two.",
            "always @(posedge i_clk) if (i_reset) o_dly_stb <= 1'b0; else if ((i_dly_err)&&(o_dly_cyc)) o_dly_stb <= 1'b0; else if ((o_wb_err)&&(i_wb_cyc)) o_dly_stb <= 1'b0; else if (!i_wb_cyc) o_dly_stb <= 1'b0; else if (!o_wb_stall) o_dly_stb <= (i_wb_stb);",
            "always @(posedge i_clk) if (!o_wb_stall) o_dly_we <= i_wb_we;",
            "initial o_dly_addr = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && (i_reset || !i_wb_cyc || o_wb_err || (o_dly_cyc && i_dly_err))) { o_dly_addr, o_dly_data, o_dly_sel } <= 0; else if (!o_dly_stb || !i_dly_stall) begin { o_dly_addr, o_dly_data, o_dly_sel } <= { i_wb_addr, i_wb_data, i_wb_sel }; if (OPT_LOWPOWER && !i_wb_stb) { o_dly_addr, o_dly_data, o_dly_sel } <= 0; end",
            "initial o_wb_ack = 0;",
            "always @(posedge i_clk) if (i_reset) o_wb_ack <= 1'b0; else o_wb_ack <= ((i_dly_ack)&&(!i_dly_err) &&(o_dly_cyc)&&(i_wb_cyc)) &&(!o_wb_err);",
            "initial o_wb_err = 0;",
            "always @(posedge i_clk) if (i_reset) o_wb_err <= 1'b0; else if (!o_dly_cyc) o_wb_err <= 1'b0; else o_wb_err <= (o_wb_err)||(i_dly_err)&&(i_wb_cyc);",
            "initial o_wb_data = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && (i_reset || !i_wb_cyc || !o_dly_cyc || o_wb_err || !i_dly_ack)) o_wb_data <= 0; else o_wb_data <= i_dly_data; // Our only non-delayed line, yet still really delayed. Perhaps // there's a way to",
            "reg ister this? // o_wb_stall <= (i_wb_cyc)&&(i_wb_stb) ... or some such? // assign o_wb_stall=((i_wb_cyc)&&(i_dly_stall)&&(o_dly_stb));//&&o_cyc",
            "assign o_wb_stall = (i_dly_stall)&&(o_dly_stb); `ifdef FORMAL // f_wpending isn't used if DELAY_STALL is zero, but we'll give // it a seemingly useful value anyway--if for no other reason // than to be sure we set it to the right number of bits",
            "assign f_wpending = { i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel }; `endif // }}} end endgenerate //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Declarations // {{{ `ifdef BUSDELAY `define ASSUME assume `else `define ASSUME assert `endif",
            "localparam ACK_DELAY = 5, STALL_DELAY = 4;",
            "localparam STB_BIT = 2+AW+DW+DW/8-1;",
            "wire [(F_LGDEPTH-1):0] f_wb_nreqs,f_wb_nacks, f_wb_outstanding, f_dly_nreqs, f_dly_nacks, f_dly_outstanding;",
            "wire f_wb_busy, f_dly_busy, f_wb_req, f_dly_req;",
            "wire [STB_BIT:0] f_wb_request, f_dly_request;",
            "reg [STB_BIT:0] f_pending;",
            "reg [(F_LGDEPTH-1):0] f_pending_acks;",
            "reg [(F_LGDEPTH-1):0] f_pending_reqs;",
            "reg [(F_LGDEPTH-1):0] f_expected, f_exp_nreqs, f_exp_nacks;",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; // }}}",
            "initial `ASSUME(i_reset);",
            "always @(*) if (!f_past_valid) `ASSUME(i_reset); //////////////////////////////////////////////////////////////////////// // // Bus properties // {{{ //////////////////////////////////////////////////////////////////////// // // fwb_slave #(.AW(AW), .DW(DW), .F_LGDEPTH(F_LGDEPTH), .F_MAX_STALL(STALL_DELAY+1), .F_MAX_ACK_DELAY(ACK_DELAY+1+2*STALL_DELAY), .F_MAX_REQUESTS((1<<F_LGDEPTH)-2), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1)) f_wbs(i_clk, i_reset, i_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel, o_wb_ack, o_wb_stall, o_wb_data, o_wb_err, f_wb_nreqs, f_wb_nacks, f_wb_outstanding); fwb_master #(.AW(AW), .DW(DW), .F_LGDEPTH(F_LGDEPTH), .F_MAX_STALL(STALL_DELAY), .F_MAX_ACK_DELAY(ACK_DELAY), .F_MAX_REQUESTS(0), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1)) f_wbm(i_clk, i_reset, o_dly_cyc, o_dly_stb, o_dly_we, o_dly_addr, o_dly_data, o_dly_sel, i_dly_ack, i_dly_stall, i_dly_data, i_dly_err, f_dly_nreqs, f_dly_nacks, f_dly_outstanding); // }}} // WB and DLY request packets // {{{",
            "assign f_wb_request = { i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel };",
            "assign f_dly_request={ o_dly_stb,o_dly_we,o_dly_addr,o_dly_data,o_dly_sel }; // }}} // f_pending",
            "reg ister // {{{",
            "initial f_pending = 0;",
            "always @(posedge i_clk) if (!DELAY_STALL) f_pending = 0; else if ((i_reset)||(!i_wb_cyc)||(i_dly_err)) f_pending[STB_BIT] <= 1'b0; else if ((i_wb_stb)&&(!o_wb_stall)) begin f_pending <= f_wb_request; if ((!i_dly_stall)||(!o_dly_stb)) f_pending[STB_BIT] <= 1'b0; end else if ((!i_dly_stall)&&(f_pending[STB_BIT])) f_pending[STB_BIT] <= 1'b0; // }}}",
            "assign f_wb_busy = (i_wb_stb )&&( o_wb_stall);",
            "assign f_dly_busy = (o_dly_stb)&&( i_dly_stall);",
            "assign f_wb_req = (i_wb_stb )&&(!o_wb_stall);",
            "assign f_dly_req = (o_dly_stb)&&(!i_dly_stall);",
            "always @(posedge i_clk) if (!DELAY_STALL) begin if ((f_past_valid)&&($past(f_wb_req))&&(!$past(i_reset)) &&(!$past(o_wb_err))&&(!o_wb_err)) assert(($past(f_wb_request) == f_dly_request)); if ((f_past_valid)&&($past(i_reset))) assert(!o_dly_stb); if ((f_past_valid)&&(!$past(i_wb_cyc))) assert(!o_dly_stb); if ((o_dly_stb)&&(i_dly_stall)) assert(o_wb_stall); end else if ((DELAY_STALL)&&(f_past_valid)) begin if ($past(i_reset)) assert(!f_pending[STB_BIT]); if (!$past(f_dly_busy)) assert(!f_pending[STB_BIT]); // if (($past(i_reset))||($past(i_dly_err))) begin assert(!f_pending[STB_BIT]); end else if ($past(f_wb_req)) begin if ($past(f_dly_busy)) assert($past(f_wb_request) == f_pending); end else if ((!$past(i_dly_stall))&&($past(f_pending[STB_BIT])) &&($past(i_wb_cyc))) begin assert(f_dly_request == $past(f_pending)); end end // Constrain the induction solver: whatever's in our f_pending // hold",
            "reg ister should be identical to whatever is in the f_wpending // wire s above.",
            "always @(posedge i_clk) if ((DELAY_STALL)&&(f_past_valid)&&(!$past(i_reset) && i_wb_cyc && !o_wb_err)) begin if (!$past(i_wb_cyc)) begin assert((!f_pending[STB_BIT]) &&(!f_wpending[STB_BIT])); end else if (($past(f_dly_busy))&&($past(f_wb_busy))) begin assert(f_pending == f_wpending); end else if(($past(f_dly_busy))&&($past(f_pending[STB_BIT]))) assert(f_pending == f_wpending); end",
            "always @(posedge i_clk) if ((!DELAY_STALL)&&(f_past_valid)&&(!$past(i_reset)) &&($past(i_wb_stb))&&(!$past(o_wb_stall)) &&(!$past(o_wb_err))&&(!o_wb_err)) assert(f_dly_request == $past(f_wb_request));",
            "always @(posedge i_clk) if ((DELAY_STALL)&&(!i_reset)&&(!o_wb_err)) assert(f_pending[STB_BIT] == f_wpending[STB_BIT]); // Upon any request at the",
            "input , there should",
            "always be a request // on the",
            "output at the very next clock // {{{",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_wb_stb))&&(i_wb_cyc)) assert((o_dly_stb)||(o_wb_err)); // }}} // Following any dropping of CYC or raising of RESET, STB should // go down as well // {{{",
            "always @(posedge i_clk) if ((f_past_valid)&&(($past(!i_wb_cyc))||($past(i_reset)))) assert(!o_dly_stb);",
            "always @(posedge i_clk) if ((DELAY_STALL)&&(f_past_valid) &&(!$past(i_reset)) &&($past(i_wb_cyc)) &&($past(f_pending[STB_BIT]))) begin if ($past(i_dly_err)) begin assert(!o_dly_stb); end else assert(o_dly_stb); end // }}} // Make sure we get no more than one ack per request // {{{",
            "always @(*) if (DELAY_STALL) begin f_pending_acks <= 0; if ((f_past_valid) &&((o_wb_err)||(o_wb_ack)) &&(o_dly_cyc)) f_pending_acks <= 1; end else f_pending_acks <= (((o_wb_ack)||(o_wb_err)) ? 1:0);",
            "always @(*) if (DELAY_STALL) begin f_pending_reqs <= ((o_dly_stb) ? 1:0) + ((f_pending[STB_BIT]) ? 1:0); end else begin f_pending_reqs <= (!f_past_valid) ? 0 : ((o_dly_stb) ? 1:0); end",
            "always @(*) f_expected <= f_dly_outstanding + f_pending_reqs+f_pending_acks;",
            "always @(*) f_exp_nreqs<= f_dly_nreqs + f_pending_reqs;",
            "always @(*) f_exp_nacks<= f_dly_nacks - f_pending_acks;",
            "always @(*) if (i_wb_cyc) assert(f_dly_outstanding <= f_wb_outstanding);",
            "always @(posedge i_clk) if ((!i_reset)&&(i_wb_cyc)&&(o_dly_cyc)&&(!i_dly_err)) assert(f_expected == f_wb_outstanding);",
            "always @(posedge i_clk) if ((i_wb_cyc)&&(o_dly_cyc)&&(!i_reset)&&(!i_dly_err)) begin assert(f_exp_nreqs == f_wb_nreqs); assert(f_exp_nacks == f_wb_nacks); end // }}}",
            "always @(posedge i_clk) if (i_wb_cyc && o_dly_stb || (f_wb_outstanding > 0 && f_dly_outstanding > 0)) assert(i_wb_we == o_dly_we); //////////////////////////////////////////////////////////////////////// // // The \"never\" property // {{{ //////////////////////////////////////////////////////////////////////// // // `ifdef BUSDELAY (* anyconst *)",
            "reg f_never; (* anyconst *)",
            "reg [STB_BIT:0] f_nvr_request;",
            "always @(*) if (f_never && i_wb_stb) `ASSUME(f_wb_request != f_nvr_request);",
            "always @(*) if (f_never && f_pending[STB_BIT]) assert(f_pending != f_nvr_request);",
            "always @(*) if (f_never && o_dly_stb) assert(f_dly_request != f_nvr_request); `endif // }}} //////////////////////////////////////////////////////////////////////// // // Low power properties (if invoked) // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_LOWPOWER) begin",
            "always @(*) if (!o_dly_stb) begin assert(o_dly_addr == 0); assert(o_dly_data == 0); assert(o_dly_sel == 0); end",
            "always @(*) if (!o_wb_ack) assert(o_wb_data == 0); end endgenerate // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "fwb_master.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/fwb_master.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: fwb_master.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This file describes the rules of a wishbone interaction from the // perspective of a wishbone master. These formal rules may be // used with SymbiYosys to *prove* that the master properly handles // outgoing transactions and incoming responses. // // This",
            "module contains no functional",
            "logic . It is intended for formal // verification only. The",
            "output s returned, the number of requests that // have been made, the number of acknowledgements received, and the number // of outstanding requests, are designed for further formal verification // purposes *only*. // // This file is different from a companion formal_slave.v file in that the // assertions are made on the",
            "output s of the wishbone master: o_wb_cyc, // o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, and o_wb_sel, while only // assumptions are made about the",
            "input s: i_wb_stall, i_wb_ack, i_wb_data, // i_wb_err. In the formal_slave.v, assumptions are made about the // slave",
            "input s (the master",
            "output s), and assertions are made about the // slave",
            "output s (the master",
            "input s). // // In order to make it easier to compare the slave against the master, // assumptions with respect to the slave have been marked with the // `SLAVE_ASSUME macro. Similarly, assertions the slave would make have // been marked with `SLAVE_ASSERT. This allows the master to redefine // these two macros to be from his perspective, and therefore the // diffs between the two files actually show true differences, rather // than just these differences in perspective. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2017-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module fwb_master #( // {{{",
            "parameter AW=32, DW=32, parameter F_MAX_STALL = 0, F_MAX_ACK_DELAY = 0, parameter F_LGDEPTH = 4, parameter [(F_LGDEPTH-1):0] F_MAX_REQUESTS = 0, // OPT_BUS_ABORT: If true, the master can drop CYC at any time // and must drop CYC following any bus error",
            "parameter [0:0] OPT_BUS_ABORT = 1'b1, // // If true, allow the bus to be kept open when there are no // outstanding requests. This is useful for any master that // might execute a read modify write cycle, such as an atomic // add.",
            "parameter [0:0] F_OPT_RMW_BUS_OPTION = 1, // // // If true, allow the bus to issue multiple discontinuous // requests. // Unlike F_OPT_RMW_BUS_OPTION, these requests may be issued // while other requests are outstanding",
            "parameter [0:0] F_OPT_DISCONTINUOUS = 1, // // // If true, insist that there be a minimum of a single clock // delay between request and response. This defaults to off // since the wishbone specification specifically doesn't // require this. However, some interfaces do, so we allow it // as an option here.",
            "parameter [0:0] F_OPT_MINCLOCK_DELAY = 0, // // // localparam [(F_LGDEPTH-1):0] MAX_OUTSTANDING = {(F_LGDEPTH){1'b1}}, localparam MAX_DELAY = (F_MAX_STALL > F_MAX_ACK_DELAY) ? F_MAX_STALL : F_MAX_ACK_DELAY, localparam DLYBITS= (MAX_DELAY < 4) ? 2 : (MAX_DELAY >= 65536) ? 32 : $clog2(MAX_DELAY+1), // parameter [0:0] F_OPT_SHORT_CIRCUIT_PROOF = 0, // // If this is the source of a request, then we can assume STB and CYC // will",
            "initial ly start out high. Master interfaces following the // source on the way to the slave may not have this property",
            "parameter [0:0] F_OPT_SOURCE = 0 // // // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // The Wishbone bus",
            "input wire i_wb_cyc, i_wb_stb, i_wb_we, input wire [(AW-1):0] i_wb_addr, input wire [(DW-1):0] i_wb_data, input wire [(DW/8-1):0] i_wb_sel, // input wire i_wb_ack, input wire i_wb_stall, input wire [(DW-1):0] i_wb_idata, input wire i_wb_err, // Some convenience",
            "output parameter s",
            "output reg [(F_LGDEPTH-1):0] f_nreqs, f_nacks, output wire [(F_LGDEPTH-1):0] f_outstanding // }}} ); `define SLAVE_ASSUME assert `define SLAVE_ASSERT assume // // Let's just make sure our",
            "parameter s are set up right // {{{",
            "initial assert(F_MAX_REQUESTS < {(F_LGDEPTH){1'b1}}); // }}} // f_request // {{{ // Wrap the request line in a bundle. The top bit, named STB_BIT, // is the bit indicating whether the request described by this vector // is a valid request or not. // localparam STB_BIT = 2+AW+DW+DW/8-1;",
            "wire [STB_BIT:0] f_request;",
            "assign f_request = { i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel }; // }}} // f_past_valid and i_reset // {{{ // A quick",
            "reg ister to be used later to know if the $past() operator // will yield valid result",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "always @(*) if (!f_past_valid) `SLAVE_ASSUME(i_reset); // }}} //////////////////////////////////////////////////////////////////////// // // Assertions",
            "reg arding the",
            "initial (and reset) state // {{{ //////////////////////////////////////////////////////////////////////// // // // // Assume we start from a reset condition",
            "initial assert(i_reset);",
            "initial `SLAVE_ASSUME(!i_wb_cyc);",
            "initial `SLAVE_ASSUME(!i_wb_stb); // initial `SLAVE_ASSERT(!i_wb_ack);",
            "initial `SLAVE_ASSERT(!i_wb_err); `ifdef VERIFIC",
            "always @(*) if (!f_past_valid) begin `SLAVE_ASSUME(!i_wb_cyc); `SLAVE_ASSUME(!i_wb_stb); // `SLAVE_ASSERT(!i_wb_ack); `SLAVE_ASSERT(!i_wb_err); end `endif",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) begin `SLAVE_ASSUME(!i_wb_cyc); `SLAVE_ASSUME(!i_wb_stb); // `SLAVE_ASSERT(!i_wb_ack); `SLAVE_ASSERT(!i_wb_err); end",
            "always @(*) if (!f_past_valid) `SLAVE_ASSUME(!i_wb_cyc); // }}} //////////////////////////////////////////////////////////////////////// // // Bus requests // {{{ //////////////////////////////////////////////////////////////////////// // // // Following any bus error, the CYC line should be dropped to abort // the transaction",
            "always @(posedge i_clk) if (f_past_valid && OPT_BUS_ABORT && $past(i_wb_err)&& $past(i_wb_cyc)) `SLAVE_ASSUME(!i_wb_cyc);",
            "always @(*) if (!OPT_BUS_ABORT && !i_reset && (f_nreqs != f_nacks)) `SLAVE_ASSUME(i_wb_cyc);",
            "always @(posedge i_clk) if (f_past_valid && !OPT_BUS_ABORT && $past(!i_reset && i_wb_stb && i_wb_stall)) `SLAVE_ASSUME(i_wb_cyc); // STB can only be true if CYC is also true",
            "always @(*) if (i_wb_stb) `SLAVE_ASSUME(i_wb_cyc); // If a request was both outstanding and stalled on the last clock, // then nothing should change on this clock",
            "reg arding it.",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_stb)) &&($past(i_wb_stall))&&(i_wb_cyc)) begin `SLAVE_ASSUME(i_wb_stb); `SLAVE_ASSUME(i_wb_we == $past(i_wb_we)); `SLAVE_ASSUME(i_wb_addr == $past(i_wb_addr)); `SLAVE_ASSUME(i_wb_sel == $past(i_wb_sel)); if (i_wb_we) `SLAVE_ASSUME(i_wb_data == $past(i_wb_data)); end // Within any series of STB/requests, the direction of the request // may not change.",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_wb_stb))&&(i_wb_stb)) `SLAVE_ASSUME(i_wb_we == $past(i_wb_we)); // Within any given bus cycle, the direction may *only* change when // there are no further outstanding requests.",
            "always @(posedge i_clk) if ((f_past_valid)&&(f_outstanding > 0)) `SLAVE_ASSUME(i_wb_we == $past(i_wb_we)); // Write requests must also set one (or more) of i_wb_sel // // This test has been removed since down-sizers (taking bus from width // DW to width dw < DW) might actually create empty requests that this // would prevent. Re-enabling it would also complicate AXI to WB // transfers, since AXI explicitly allows WSTRB == 0. Finally, this // criteria isn't found in the WB spec--so while it might be a good // idea to check, in hind sight there are too many exceptions to be // dogmatic about it. // // always @(*) // if ((i_wb_stb)&&(i_wb_we)) // `SLAVE_ASSUME(|i_wb_sel); // }}} //////////////////////////////////////////////////////////////////////// // // Bus responses // {{{ //////////////////////////////////////////////////////////////////////// // // // If CYC was low on the last clock, then both ACK and ERR should be // low on this clock.",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_wb_cyc))&&(!i_wb_cyc)) begin `SLAVE_ASSERT(!i_wb_ack); `SLAVE_ASSERT(!i_wb_err); // Stall may still be true--such as when we are not // selected at some arbiter between us and the slave end // // Any time the CYC line drops, it is possible that there may be a // remaining (",
            "reg istered) ACK or ERR that hasn't yet been returned. // Restrict such out of band returns so that they are *only* returned // if there is an outstanding operation. // // Update: As per spec, WB-classic to WB-pipeline conversions require // that the ACK|ERR might come back on the same cycle that STB // is low, yet also be",
            "reg istered. Hence, if STB & STALL are true on // one cycle, then CYC is dropped, ACK|ERR might still be true on the // cycle when CYC is dropped",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_cyc))&&(!i_wb_cyc)) begin // Note that, unlike f_outstanding, f_nreqs and f_nacks are both // reg istered. Hence, we can check here if a response is still // pending. If not, no response should be returned. if (f_nreqs == f_nacks) begin `SLAVE_ASSERT(!i_wb_ack); `SLAVE_ASSERT(!i_wb_err); end end // ACK and ERR may never both be true at the same time",
            "always @(*) `SLAVE_ASSERT((!i_wb_ack)||(!i_wb_err)); // }}} //////////////////////////////////////////////////////////////////////// // // Stall checking // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (F_MAX_STALL > 0) begin : MXSTALL // // Assume the slave cannnot stall for more than F_MAX_STALL // counts. We'll count this forward any time STB and STALL // are both true. // reg [(DLYBITS-1):0] f_stall_count;",
            "initial f_stall_count = 0;",
            "always @(posedge i_clk) if ((!i_reset)&&(i_wb_stb)&&(i_wb_stall)) f_stall_count <= f_stall_count + 1'b1; else f_stall_count <= 0;",
            "always @(*) if (i_wb_cyc) `SLAVE_ASSERT(f_stall_count < F_MAX_STALL); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Maximum delay in any response // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (F_MAX_ACK_DELAY > 0) begin : MXWAIT // // Assume the slave will respond within F_MAX_ACK_DELAY cycles, // counted either from the end of the last request, or from the // last ACK received // reg [(DLYBITS-1):0] f_ackwait_count;",
            "initial f_ackwait_count = 0;",
            "always @(posedge i_clk) if ((!i_reset)&&(i_wb_cyc)&&(!i_wb_stb) &&(!i_wb_ack)&&(!i_wb_err) &&(f_outstanding > 0)) f_ackwait_count <= f_ackwait_count + 1'b1; else f_ackwait_count <= 0;",
            "always @(*) if ((!i_reset)&&(i_wb_cyc)&&(!i_wb_stb) &&(!i_wb_ack)&&(!i_wb_err) &&(f_outstanding > 0)) `SLAVE_ASSERT(f_ackwait_count < F_MAX_ACK_DELAY); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Count outstanding requests vs acknowledgments // {{{ //////////////////////////////////////////////////////////////////////// // // // Count the number of requests that have been received // initial f_nreqs = 0;",
            "always @(posedge i_clk) if ((i_reset)||(!i_wb_cyc)) f_nreqs <= 0; else if ((i_wb_stb)&&(!i_wb_stall)) f_nreqs <= f_nreqs + 1'b1; // // Count the number of acknowledgements that have been returned // initial f_nacks = 0;",
            "always @(posedge i_clk) if (i_reset) f_nacks <= 0; else if (!i_wb_cyc) f_nacks <= 0; else if ((i_wb_ack)||(i_wb_err)) f_nacks <= f_nacks + 1'b1; // // The number of outstanding requests is the difference between // the number of requests and the number of acknowledgements // assign f_outstanding = (i_wb_cyc) ? (f_nreqs - f_nacks):0;",
            "always @(*) if ((i_wb_cyc)&&(F_MAX_REQUESTS > 0)) begin if (i_wb_stb) begin `SLAVE_ASSUME(f_nreqs < F_MAX_REQUESTS); end else `SLAVE_ASSUME(f_nreqs <= F_MAX_REQUESTS); `SLAVE_ASSERT(f_nacks <= f_nreqs); assert(f_outstanding < MAX_OUTSTANDING); end else assume(f_outstanding < MAX_OUTSTANDING);",
            "always @(*) if ((i_wb_cyc)&&(f_outstanding == 0)) begin // If nothing is outstanding, then there should be // no acknowledgements ... however, an acknowledgement // *can* come back on the same clock as the stb is // going out. if (F_OPT_MINCLOCK_DELAY) begin `SLAVE_ASSERT(!i_wb_ack); `SLAVE_ASSERT(!i_wb_err); end else begin `SLAVE_ASSERT((!i_wb_ack)||((i_wb_stb)&&(!i_wb_stall))); // The same is true of errors. They may not be // created before the request gets through `SLAVE_ASSERT((!i_wb_err)||((i_wb_stb)&&(!i_wb_stall))); end end else if (!i_wb_cyc && f_nacks == f_nreqs) begin `SLAVE_ASSERT(!i_wb_ack); `SLAVE_ASSERT(!i_wb_err); end // }}} //////////////////////////////////////////////////////////////////////// // // Bus direction // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (!F_OPT_RMW_BUS_OPTION) begin // If we aren't waiting for anything, and we aren't issuing // any requests, then then our transaction is over and we // should be dropping the CYC line.",
            "always @(*) if (f_outstanding == 0) `SLAVE_ASSUME((i_wb_stb)||(!i_wb_cyc)); // Not all masters will abide by this restriction. Some // masters may wish to implement read-modify-write bus // interactions. These masters need to keep CYC high between // transactions, even though nothing is outstanding. For // these busses, turn F_OPT_RMW_BUS_OPTION on. end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Discontinuous request checking // {{{ //////////////////////////////////////////////////////////////////////// // // generate if ((!F_OPT_DISCONTINUOUS)&&(!F_OPT_RMW_BUS_OPTION)) begin : INSIST_ON_NO_DISCONTINUOUS_STBS // Within my own code, once a request begins it goes to // completion and the CYC line is dropped. The master // is not allowed to raise STB again after dropping it. // Doing so would be a *discontinuous* request. // // However, in any RMW scheme, discontinuous requests are // necessary, and the spec doesn't disallow them. Hence we // make this check optional.",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_wb_cyc))&&(!$past(i_wb_stb))) `SLAVE_ASSUME(!i_wb_stb); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Master only checks // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (F_OPT_SHORT_CIRCUIT_PROOF) begin // In many ways, we don't care what happens on the bus return // lines if the cycle line is low, so restricting them to a // known value makes a lot of sense. // // On the other hand, if something above *does* depend upon // these values (when it shouldn't), then we might want to know // about it. // // always @(posedge i_clk) begin if (!i_wb_cyc) begin assume(!i_wb_stall); assume($stable(i_wb_idata)); end else if ((!$past(i_wb_ack))&&(!i_wb_ack)) assume($stable(i_wb_idata)); end end endgenerate generate if (F_OPT_SOURCE) begin : SRC // Any opening bus request starts with both CYC and STB high // This is true for the master only, and more specifically // only for those masters that are the",
            "initial source of any // transaction. By the time an interaction gets to the slave, // the CYC line may go high or low without actually affecting // the STB line of the slave.",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_wb_cyc))&&(i_wb_cyc)) `SLAVE_ASSUME(i_wb_stb); end endgenerate // }}} // Keep Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, f_request }; // Verilator lint_on UNUSED // }}}",
            "endmodule `undef SLAVE_ASSUME `undef SLAVE_ASSERT"
        ]
    },
    {
        "file_name": "fwb_slave.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/fwb_slave.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: fwb_slave.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This file describes the rules of a wishbone interaction from the // perspective of a wishbone slave. These formal rules may be used // with yosys-smtbmc to *prove* that the slave properly handles outgoing // responses to (assumed correct) incoming requests. // // This",
            "module contains no functional",
            "logic . It is intended for formal // verification only. The",
            "output s returned, the number of requests that // have been made, the number of acknowledgements received, and the number // of outstanding requests, are designed for further formal verification // purposes *only*. // // This file is different from a companion formal_master.v file in that // assumptions are made about the",
            "input s to the slave: i_wb_cyc, // i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, and i_wb_sel, while full // assertions are made about the",
            "output s: o_wb_stall, o_wb_ack, o_wb_data, // o_wb_err. In the formal_master.v, assertions are made about the // master",
            "output s (slave",
            "input s)), and assumptions are made about the // master",
            "input s (the slave",
            "output s). // // In order to make it easier to compare the slave against the master, // assumptions with respect to the slave have been marked with the // `SLAVE_ASSUME macro. Similarly, assertions the slave would make have // been marked with `SLAVE_ASSERT. This allows the master to redefine // these two macros to be from his perspective, and therefore the // diffs between the two files actually show true differences, rather // than just these differences in perspective. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2017-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module fwb_slave #( // {{{",
            "parameter AW=32, DW=32, parameter F_MAX_STALL = 0, F_MAX_ACK_DELAY = 0, parameter F_LGDEPTH = 4, parameter [(F_LGDEPTH-1):0] F_MAX_REQUESTS = 0, // OPT_BUS_ABORT: If true, the master can drop CYC at any time // and must drop CYC following any bus error",
            "parameter [0:0] OPT_BUS_ABORT = 1'b1, // // If true, allow the bus to be kept open when there are no // outstanding requests. This is useful for any master that // might execute a read modify write cycle, such as an atomic // add.",
            "parameter [0:0] F_OPT_RMW_BUS_OPTION = 1, // // // If true, allow the bus to issue multiple discontinuous // requests. // Unlike F_OPT_RMW_BUS_OPTION, these requests may be issued // while other requests are outstanding",
            "parameter [0:0] F_OPT_DISCONTINUOUS = 1, // // // If true, insist that there be a minimum of a single clock // delay between request and response. This defaults to off // since the wishbone specification specifically doesn't // require this. However, some interfaces do, so we allow it // as an option here.",
            "parameter [0:0] F_OPT_MINCLOCK_DELAY = 0, // // // localparam [(F_LGDEPTH-1):0] MAX_OUTSTANDING = {(F_LGDEPTH){1'b1}}, localparam MAX_DELAY = (F_MAX_STALL > F_MAX_ACK_DELAY) ? F_MAX_STALL : F_MAX_ACK_DELAY, localparam DLYBITS= (MAX_DELAY < 4) ? 2 : (MAX_DELAY >= 65536) ? 32 : $clog2(MAX_DELAY+1) // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // The Wishbone bus",
            "input wire i_wb_cyc, i_wb_stb, i_wb_we, input wire [(AW-1):0] i_wb_addr, input wire [(DW-1):0] i_wb_data, input wire [(DW/8-1):0] i_wb_sel, // input wire i_wb_ack, input wire i_wb_stall, input wire [(DW-1):0] i_wb_idata, input wire i_wb_err, // Some convenience",
            "output parameter s",
            "output reg [(F_LGDEPTH-1):0] f_nreqs, f_nacks, output wire [(F_LGDEPTH-1):0] f_outstanding // }}} ); `define SLAVE_ASSUME assume `define SLAVE_ASSERT assert // // Let's just make sure our",
            "parameter s are set up right // {{{",
            "initial assert(F_MAX_REQUESTS < {(F_LGDEPTH){1'b1}}); // }}} // f_request // {{{ // Wrap the request line in a bundle. The top bit, named STB_BIT, // is the bit indicating whether the request described by this vector // is a valid request or not. // localparam STB_BIT = 2+AW+DW+DW/8-1;",
            "wire [STB_BIT:0] f_request;",
            "assign f_request = { i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel }; // }}} // f_past_valid and i_reset // {{{ // A quick",
            "reg ister to be used later to know if the $past() operator // will yield valid result",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "always @(*) if (!f_past_valid) `SLAVE_ASSUME(i_reset); // }}} //////////////////////////////////////////////////////////////////////// // // Assertions",
            "reg arding the",
            "initial (and reset) state // {{{ //////////////////////////////////////////////////////////////////////// // // // // Assume we start from a reset condition",
            "initial assert(i_reset);",
            "initial `SLAVE_ASSUME(!i_wb_cyc);",
            "initial `SLAVE_ASSUME(!i_wb_stb); // initial `SLAVE_ASSERT(!i_wb_ack);",
            "initial `SLAVE_ASSERT(!i_wb_err); `ifdef VERIFIC",
            "always @(*) if (!f_past_valid) begin `SLAVE_ASSUME(!i_wb_cyc); `SLAVE_ASSUME(!i_wb_stb); // `SLAVE_ASSERT(!i_wb_ack); `SLAVE_ASSERT(!i_wb_err); end `endif",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) begin `SLAVE_ASSUME(!i_wb_cyc); `SLAVE_ASSUME(!i_wb_stb); // `SLAVE_ASSERT(!i_wb_ack); `SLAVE_ASSERT(!i_wb_err); end",
            "always @(*) if (!f_past_valid) `SLAVE_ASSUME(!i_wb_cyc); // }}} //////////////////////////////////////////////////////////////////////// // // Bus requests // {{{ //////////////////////////////////////////////////////////////////////// // // // Following any bus error, the CYC line should be dropped to abort // the transaction",
            "always @(posedge i_clk) if (f_past_valid && OPT_BUS_ABORT && $past(i_wb_err)&& $past(i_wb_cyc)) `SLAVE_ASSUME(!i_wb_cyc);",
            "always @(*) if (!OPT_BUS_ABORT && !i_reset && (f_nreqs != f_nacks)) `SLAVE_ASSUME(i_wb_cyc);",
            "always @(posedge i_clk) if (f_past_valid && !OPT_BUS_ABORT && $past(!i_reset && i_wb_stb && i_wb_stall)) `SLAVE_ASSUME(i_wb_cyc); // STB can only be true if CYC is also true",
            "always @(*) if (i_wb_stb) `SLAVE_ASSUME(i_wb_cyc); // If a request was both outstanding and stalled on the last clock, // then nothing should change on this clock",
            "reg arding it.",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_stb)) &&($past(i_wb_stall))&&(i_wb_cyc)) begin `SLAVE_ASSUME(i_wb_stb); `SLAVE_ASSUME(i_wb_we == $past(i_wb_we)); `SLAVE_ASSUME(i_wb_addr == $past(i_wb_addr)); `SLAVE_ASSUME(i_wb_sel == $past(i_wb_sel)); if (i_wb_we) `SLAVE_ASSUME(i_wb_data == $past(i_wb_data)); end // Within any series of STB/requests, the direction of the request // may not change.",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_wb_stb))&&(i_wb_stb)) `SLAVE_ASSUME(i_wb_we == $past(i_wb_we)); // Within any given bus cycle, the direction may *only* change when // there are no further outstanding requests.",
            "always @(posedge i_clk) if ((f_past_valid)&&(f_outstanding > 0)) `SLAVE_ASSUME(i_wb_we == $past(i_wb_we)); // Write requests must also set one (or more) of i_wb_sel // // This test has been removed since down-sizers (taking bus from width // DW to width dw < DW) might actually create empty requests that this // would prevent. Re-enabling it would also complicate AXI to WB // transfers, since AXI explicitly allows WSTRB == 0. Finally, this // criteria isn't found in the WB spec--so while it might be a good // idea to check, in hind sight there are too many exceptions to be // dogmatic about it. // // always @(*) // if ((i_wb_stb)&&(i_wb_we)) // `SLAVE_ASSUME(|i_wb_sel); // }}} //////////////////////////////////////////////////////////////////////// // // Bus responses // {{{ //////////////////////////////////////////////////////////////////////// // // // If CYC was low on the last clock, then both ACK and ERR should be // low on this clock.",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_wb_cyc))&&(!i_wb_cyc)) begin `SLAVE_ASSERT(!i_wb_ack); `SLAVE_ASSERT(!i_wb_err); // Stall may still be true--such as when we are not // selected at some arbiter between us and the slave end // // Any time the CYC line drops, it is possible that there may be a // remaining (",
            "reg istered) ACK or ERR that hasn't yet been returned. // Restrict such out of band returns so that they are *only* returned // if there is an outstanding operation. // // Update: As per spec, WB-classic to WB-pipeline conversions require // that the ACK|ERR might come back on the same cycle that STB // is low, yet also be",
            "reg istered. Hence, if STB & STALL are true on // one cycle, then CYC is dropped, ACK|ERR might still be true on the // cycle when CYC is dropped",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_cyc))&&(!i_wb_cyc)) begin // Note that, unlike f_outstanding, f_nreqs and f_nacks are both // reg istered. Hence, we can check here if a response is still // pending. If not, no response should be returned. if (f_nreqs == f_nacks) begin `SLAVE_ASSERT(!i_wb_ack); `SLAVE_ASSERT(!i_wb_err); end end // ACK and ERR may never both be true at the same time",
            "always @(*) `SLAVE_ASSERT((!i_wb_ack)||(!i_wb_err)); // }}} //////////////////////////////////////////////////////////////////////// // // Stall checking // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (F_MAX_STALL > 0) begin : MXSTALL // // Assume the slave cannnot stall for more than F_MAX_STALL // counts. We'll count this forward any time STB and STALL // are both true. // reg [(DLYBITS-1):0] f_stall_count;",
            "initial f_stall_count = 0;",
            "always @(posedge i_clk) if ((!i_reset)&&(i_wb_stb)&&(i_wb_stall)) f_stall_count <= f_stall_count + 1'b1; else f_stall_count <= 0;",
            "always @(*) if (i_wb_cyc) `SLAVE_ASSERT(f_stall_count < F_MAX_STALL); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Maximum delay in any response // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (F_MAX_ACK_DELAY > 0) begin : MXWAIT // // Assume the slave will respond within F_MAX_ACK_DELAY cycles, // counted either from the end of the last request, or from the // last ACK received // reg [(DLYBITS-1):0] f_ackwait_count;",
            "initial f_ackwait_count = 0;",
            "always @(posedge i_clk) if ((!i_reset)&&(i_wb_cyc)&&(!i_wb_stb) &&(!i_wb_ack)&&(!i_wb_err) &&(f_outstanding > 0)) f_ackwait_count <= f_ackwait_count + 1'b1; else f_ackwait_count <= 0;",
            "always @(*) if ((!i_reset)&&(i_wb_cyc)&&(!i_wb_stb) &&(!i_wb_ack)&&(!i_wb_err) &&(f_outstanding > 0)) `SLAVE_ASSERT(f_ackwait_count < F_MAX_ACK_DELAY); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Count outstanding requests vs acknowledgments // {{{ //////////////////////////////////////////////////////////////////////// // // // Count the number of requests that have been received // initial f_nreqs = 0;",
            "always @(posedge i_clk) if ((i_reset)||(!i_wb_cyc)) f_nreqs <= 0; else if ((i_wb_stb)&&(!i_wb_stall)) f_nreqs <= f_nreqs + 1'b1; // // Count the number of acknowledgements that have been returned // initial f_nacks = 0;",
            "always @(posedge i_clk) if (i_reset) f_nacks <= 0; else if (!i_wb_cyc) f_nacks <= 0; else if ((i_wb_ack)||(i_wb_err)) f_nacks <= f_nacks + 1'b1; // // The number of outstanding requests is the difference between // the number of requests and the number of acknowledgements // assign f_outstanding = (i_wb_cyc) ? (f_nreqs - f_nacks):0;",
            "always @(*) if ((i_wb_cyc)&&(F_MAX_REQUESTS > 0)) begin if (i_wb_stb) begin `SLAVE_ASSUME(f_nreqs < F_MAX_REQUESTS); end else `SLAVE_ASSUME(f_nreqs <= F_MAX_REQUESTS); `SLAVE_ASSERT(f_nacks <= f_nreqs); assert(f_outstanding < (1<<F_LGDEPTH)-1); end else assume(f_outstanding < (1<<F_LGDEPTH)-1);",
            "always @(*) if ((i_wb_cyc)&&(f_outstanding == 0)) begin // If nothing is outstanding, then there should be // no acknowledgements ... however, an acknowledgement // *can* come back on the same clock as the stb is // going out. if (F_OPT_MINCLOCK_DELAY) begin `SLAVE_ASSERT(!i_wb_ack); `SLAVE_ASSERT(!i_wb_err); end else begin `SLAVE_ASSERT((!i_wb_ack)||((i_wb_stb)&&(!i_wb_stall))); // The same is true of errors. They may not be // created before the request gets through `SLAVE_ASSERT((!i_wb_err)||((i_wb_stb)&&(!i_wb_stall))); end end else if (!i_wb_cyc && f_nacks == f_nreqs) begin `SLAVE_ASSERT(!i_wb_ack); `SLAVE_ASSERT(!i_wb_err); end // }}} //////////////////////////////////////////////////////////////////////// // // Bus direction // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (!F_OPT_RMW_BUS_OPTION) begin // If we aren't waiting for anything, and we aren't issuing // any requests, then then our transaction is over and we // should be dropping the CYC line.",
            "always @(*) if (f_outstanding == 0) `SLAVE_ASSUME((i_wb_stb)||(!i_wb_cyc)); // Not all masters will abide by this restriction. Some // masters may wish to implement read-modify-write bus // interactions. These masters need to keep CYC high between // transactions, even though nothing is outstanding. For // these busses, turn F_OPT_RMW_BUS_OPTION on. end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Discontinuous request checking // {{{ //////////////////////////////////////////////////////////////////////// // // generate if ((!F_OPT_DISCONTINUOUS)&&(!F_OPT_RMW_BUS_OPTION)) begin : INSIST_ON_NO_DISCONTINUOUS_STBS // Within my own code, once a request begins it goes to // completion and the CYC line is dropped. The master // is not allowed to raise STB again after dropping it. // Doing so would be a *discontinuous* request. // // However, in any RMW scheme, discontinuous requests are // necessary, and the spec doesn't disallow them. Hence we // make this check optional.",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_wb_cyc))&&(!$past(i_wb_stb))) `SLAVE_ASSUME(!i_wb_stb); end endgenerate // }}}",
            "endmodule `undef SLAVE_ASSUME `undef SLAVE_ASSERT"
        ]
    },
    {
        "file_name": "skidbuffer.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/skidbuffer.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: skidbuffer.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A basic SKID buffer. // {{{ // Skid buffers are required for high throughput AXI code, since the AXI // specification requires that all",
            "output s be",
            "reg istered. This means // that, if there are any stall conditions calculated, it will take a clock // cycle before the stall can be propagated up stream. This means that // the data will need to be buffered for a cycle until the stall signal // can make it to the",
            "output . // // Handling that buffer is the purpose of this core. // // On one end of this core, you have the i_valid and i_data",
            "input s to // connect to your bus interface. There's also a",
            "reg istered o_ready // signal to signal stalls for the bus interface. // // The other end of the core has the same basic interface, but it isn't // reg istered. This allows you to interact with the bus interfaces // as though they were combinatorial",
            "logic , by interacting with this half // of the core. // // If at any time the incoming !stall signal, i_ready, signals a stall, // the incoming data is placed into a buffer. Internally, that buffer // is held in r_data with the r_valid flag used to indicate that valid // data is within it. // }}} // Parameters: // {{{ // DW or data width // In order to make this core generic, the width of the data in the // skid buffer is",
            "parameter ized // // OPT_LOWPOWER // Forces both o_data and r_data to zero if the respective *VALID // signal is also low. While this costs extra",
            "logic , it can also // be used to guarantee that any unused values aren't toggling and // therefore unnecessarily using power. // // This excess toggling can be particularly problematic if the // bus signals have a high fanout rate, or a long signal path // across an FPGA. // // OPT_OUTREG // Causes the",
            "output s to be",
            "reg istered // // OPT_PASSTHROUGH // Turns the skid buffer into a passthrough. Used for formal // verification only. // }}} // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2019-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module skidbuffer #( // {{{",
            "parameter [0:0] OPT_LOWPOWER = 0, parameter [0:0] OPT_OUTREG = 1, // parameter [0:0] OPT_PASSTHROUGH = 0, parameter DW = 8, parameter [0:0] OPT_INITIAL = 1'b1 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, input wire i_valid, output wire o_ready, input wire [DW-1:0] i_data, output wire o_valid, input wire i_ready, output reg [DW-1:0] o_data // }}} );",
            "wire [DW-1:0] w_data; generate if (OPT_PASSTHROUGH) begin : PASSTHROUGH // {{{",
            "assign { o_valid, o_ready } = { i_valid, i_ready };",
            "always @(*) if (!i_valid && OPT_LOWPOWER) o_data = 0; else o_data = i_data;",
            "assign w_data = 0; // Keep Verilator happy // Verilator lint_off UNUSED // {{{",
            "wire unused_passthrough;",
            "assign unused_passthrough = &{ 1'b0, i_clk, i_reset }; // }}} // Verilator lint_on UNUSED // }}} end else begin : LOGIC // We'll start with skid buffer itself // {{{",
            "reg r_valid;",
            "reg [DW-1:0] r_data; // r_valid // {{{",
            "initial if (OPT_INITIAL) r_valid = 0;",
            "always @(posedge i_clk) if (i_reset) r_valid <= 0; else if ((i_valid && o_ready) && (o_valid && !i_ready)) // We have incoming data, but the",
            "output is stalled r_valid <= 1; else if (i_ready) r_valid <= 0; // }}} // r_data // {{{",
            "initial if (OPT_INITIAL) r_data = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && i_reset) r_data <= 0; else if (OPT_LOWPOWER && (!o_valid || i_ready)) r_data <= 0; else if ((!OPT_LOWPOWER || !OPT_OUTREG || i_valid) && o_ready) r_data <= i_data;",
            "assign w_data = r_data; // }}} // o_ready // {{{",
            "assign o_ready = !r_valid; // }}} // // And then move on to the",
            "output port // if (!OPT_OUTREG) begin : NET_OUTPUT // Outputs are combinatorially determined from",
            "input s // {{{ // o_valid // {{{",
            "assign o_valid = !i_reset && (i_valid || r_valid); // }}} // o_data // {{{",
            "always @(*) if (r_valid) o_data = r_data; else if (!OPT_LOWPOWER || i_valid) o_data = i_data; else o_data = 0; // }}} // }}} end else begin : REG_OUTPUT // Register our",
            "output s // {{{ // o_valid // {{{",
            "reg ro_valid;",
            "initial if (OPT_INITIAL) ro_valid = 0;",
            "always @(posedge i_clk) if (i_reset) ro_valid <= 0; else if (!o_valid || i_ready) ro_valid <= (i_valid || r_valid);",
            "assign o_valid = ro_valid; // }}} // o_data // {{{",
            "initial if (OPT_INITIAL) o_data = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && i_reset) o_data <= 0; else if (!o_valid || i_ready) begin if (r_valid) o_data <= r_data; else if (!OPT_LOWPOWER || i_valid) o_data <= i_data; else o_data <= 0; end // }}} // }}} end // }}} end endgenerate // Keep Verilator happy // {{{ // verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, w_data }; // Verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL `ifdef SKIDBUFFER `define ASSUME assume `else `define ASSUME assert `endif",
            "reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1;",
            "always @(*) if (!f_past_valid) assume(i_reset); //////////////////////////////////////////////////////////////////////// // // Incoming stream properties / assumptions // {{{ //////////////////////////////////////////////////////////////////////// // always @(posedge i_clk) if (!f_past_valid) begin `ASSUME(!i_valid || !OPT_INITIAL); end else if ($past(i_valid && !o_ready && !i_reset) && !i_reset) `ASSUME(i_valid && $stable(i_data)); `ifdef VERIFIC `define FORMAL_VERIFIC // Reset properties property RESET_CLEARS_IVALID; @(posedge i_clk) i_reset |=> !i_valid; endproperty property IDATA_HELD_WHEN_NOT_READY; @(posedge i_clk) disable iff (i_reset) i_valid && !o_ready |=> i_valid && $stable(i_data); endproperty `ifdef SKIDBUFFER assume property (IDATA_HELD_WHEN_NOT_READY); `else assert property (IDATA_HELD_WHEN_NOT_READY); `endif `endif // }}} //////////////////////////////////////////////////////////////////////// // // Outgoing stream properties / assumptions // {{{ //////////////////////////////////////////////////////////////////////// // generate if (!OPT_PASSTHROUGH) begin",
            "always @(posedge i_clk) if (!f_past_valid) // || $past(i_reset)) begin // Following any reset, valid must be deasserted assert(!o_valid || !OPT_INITIAL); end else if ($past(o_valid && !i_ready && !i_reset) && !i_reset) // Following any stall, valid must remain high and // data must be preserved assert(o_valid && $stable(o_data)); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Other properties // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (!OPT_PASSTHROUGH) begin // Rule #1: // If",
            "reg istered, then following any reset we should be // ready for a new request // {{{",
            "always @(posedge i_clk) if (f_past_valid && $past(OPT_OUTREG && i_reset)) assert(o_ready); // }}} // Rule #2: // All incoming data must either go directly to the // output port, or into the skid buffer // {{{ `ifndef VERIFIC",
            "always @(posedge i_clk) if (f_past_valid && !$past(i_reset) && $past(i_valid && o_ready && (!OPT_OUTREG || o_valid) && !i_ready)) assert(!o_ready && w_data == $past(i_data)); `else assert property (@(posedge i_clk) disable iff (i_reset) (i_valid && o_ready && (!OPT_OUTREG || o_valid) && !i_ready) |=> (!o_ready && w_data == $past(i_data))); `endif // }}} // Rule #3: // After the last transaction, o_valid should become idle // {{{ if (!OPT_OUTREG) begin // {{{",
            "always @(posedge i_clk) if (f_past_valid && !$past(i_reset) && !i_reset && $past(i_ready)) begin assert(o_valid == i_valid); assert(!i_valid || (o_data == i_data)); end // }}} end else begin // {{{",
            "always @(posedge i_clk) if (f_past_valid && !$past(i_reset)) begin if ($past(i_valid && o_ready)) assert(o_valid); if ($past(!i_valid && o_ready && i_ready)) assert(!o_valid); end // }}} end // }}} // Rule #4 // Same thing, but this time for o_ready // {{{",
            "always @(posedge i_clk) if (f_past_valid && $past(!o_ready && i_ready)) assert(o_ready); // }}} // If OPT_LOWPOWER is set, o_data and w_data both need to be // zero any time !o_valid or !r_valid respectively // {{{ if (OPT_LOWPOWER) begin",
            "always @(*) if ((OPT_OUTREG || !i_reset) && !o_valid) assert(o_data == 0);",
            "always @(*) if (o_ready) assert(w_data == 0); end // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Cover checks // {{{ //////////////////////////////////////////////////////////////////////// // // `ifdef SKIDBUFFER generate if (!OPT_PASSTHROUGH) begin",
            "reg f_changed_data;",
            "initial f_changed_data = 0;",
            "always @(posedge i_clk) if (i_reset) f_changed_data <= 1; else if (i_valid && $past(!i_valid || o_ready)) begin if (i_data != $past(i_data + 1)) f_changed_data <= 0; end else if (!i_valid && i_data != 0) f_changed_data <= 0; `ifndef VERIFIC",
            "reg [3:0] cvr_steps, cvr_hold;",
            "always @(posedge i_clk) if (i_reset) begin cvr_steps <= 0; cvr_hold <= 0; end else begin cvr_steps <= cvr_steps + 1; cvr_hold <= cvr_hold + 1; case(cvr_steps) 0: if (o_valid || i_valid) cvr_steps <= 0; 1: if (!i_valid || !i_ready) cvr_steps <= 0; 2: if (!i_valid || !i_ready) cvr_steps <= 0; 3: if (!i_valid || !i_ready) cvr_steps <= 0; 4: if (!i_valid || i_ready) cvr_steps <= 0; 5: if (!i_valid || !i_ready) cvr_steps <= 0; 6: if (!i_valid || !i_ready) cvr_steps <= 0; 7: if (!i_valid || i_ready) cvr_steps <= 0; 8: if (!i_valid || i_ready) cvr_steps <= 0; 9: if (!i_valid || !i_ready) cvr_steps <= 0; 10: if (!i_valid || !i_ready) cvr_steps <= 0; 11: if (!i_valid || !i_ready) cvr_steps <= 0; 12: begin cvr_steps <= cvr_steps; cover(!o_valid && !i_valid && f_changed_data); if (!o_valid || !i_ready) cvr_steps <= 0; else cvr_hold <= cvr_hold + 1; end default: assert(0); endcase end `else // Cover test cover property (@(posedge i_clk) disable iff (i_reset) (!o_valid && !i_valid) ##1 i_valid && i_ready [*3] ##1 i_valid && !i_ready ##1 i_valid && i_ready [*2] ##1 i_valid && !i_ready [*2] ##1 i_valid && i_ready [*3] // Wait for the design to clear ##1 o_valid && i_ready [*0:5] ##1 (!o_valid && !i_valid && f_changed_data)); `endif end endgenerate `endif // SKIDBUFFER // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "fwb_counter.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/fwb_counter.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: fwb_counter.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2017-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module fwb_counter(i_clk, i_reset, // The Wishbone bus i_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel, i_wb_ack, i_wb_stall, i_wb_idata, i_wb_err, // Some convenience",
            "output parameter s f_nreqs, f_nacks, f_outstanding);",
            "parameter AW=32, DW=32;",
            "parameter F_MAX_STALL = 0, F_MAX_ACK_DELAY = 0;",
            "parameter F_LGDEPTH = 4;",
            "parameter [(F_LGDEPTH-1):0] F_MAX_REQUESTS = 0; // // If true, allow the bus to be kept open when there are no outstanding // requests. This is useful for any master that might execute a // read modify write cycle, such as an atomic add.",
            "parameter [0:0] F_OPT_RMW_BUS_OPTION = 1; // // // If true, allow the bus to issue multiple discontinuous requests. // Unlike F_OPT_RMW_BUS_OPTION, these requests may be issued while other // requests are outstanding",
            "parameter [0:0] F_OPT_DISCONTINUOUS = 0; // // // If true, insist that there be a minimum of a single clock delay // between request and response. This defaults to off since the // wishbone specification specifically doesn't require this. However, // some interfaces do, so we allow it as an option here.",
            "parameter [0:0] F_OPT_MINCLOCK_DELAY = 0; // // localparam [(F_LGDEPTH-1):0] MAX_OUTSTANDING = {(F_LGDEPTH){1'b1}};",
            "localparam MAX_DELAY = (F_MAX_STALL > F_MAX_ACK_DELAY) ? F_MAX_STALL : F_MAX_ACK_DELAY;",
            "localparam DLYBITS= (MAX_DELAY < 4) ? 2 : ((MAX_DELAY < 16) ? 4 : ((MAX_DELAY < 64) ? 6 : ((MAX_DELAY < 256) ? 8 : ((MAX_DELAY < 1024) ? 10 : ((MAX_DELAY < 4096) ? 12 : ((MAX_DELAY < 16384) ? 14 : ((MAX_DELAY < 65536) ? 16 : 32))))))); // input wire i_clk, i_reset; // Input/master bus",
            "input wire i_wb_cyc, i_wb_stb, i_wb_we;",
            "input wire [(AW-1):0] i_wb_addr;",
            "input wire [(DW-1):0] i_wb_data;",
            "input wire [(DW/8-1):0] i_wb_sel; // input wire i_wb_ack;",
            "input wire i_wb_stall;",
            "input wire [(DW-1):0] i_wb_idata;",
            "input wire i_wb_err; // output reg [(F_LGDEPTH-1):0] f_nreqs, f_nacks;",
            "output wire [(F_LGDEPTH-1):0] f_outstanding; // // Let's just make sure our",
            "parameter s are set up right // always @(*) assert(F_MAX_REQUESTS < {(F_LGDEPTH){1'b1}}); // // // Bus requests // // //////////////////////////////////////////////////////////////////////// // // Count outstanding requests vs acknowledgments // {{{ //////////////////////////////////////////////////////////////////////// // // // Count the number of requests that have been received // initial f_nreqs = 0;",
            "always @(posedge i_clk) if ((i_reset)||(!i_wb_cyc)) f_nreqs <= 0; else if ((i_wb_stb)&&(!i_wb_stall)) f_nreqs <= f_nreqs + 1'b1; // // Count the number of acknowledgements that have been returned // initial f_nacks = 0;",
            "always @(posedge i_clk) if (i_reset) f_nacks <= 0; else if (!i_wb_cyc) f_nacks <= 0; else if ((i_wb_ack)||(i_wb_err)) f_nacks <= f_nacks + 1'b1; // // The number of outstanding requests is the difference between // the number of requests and the number of acknowledgements // assign f_outstanding = (i_wb_cyc) ? (f_nreqs - f_nacks):0; // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "sfifo.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/sfifo.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sfifo.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A synchronous data FIFO. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // // Written and distributed by Gisselquist Technology, LLC // }}} // This design is hereby granted to the public domain. // {{{ // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module sfifo #( // {{{",
            "parameter BW=8, // Byte/data width",
            "parameter LGFLEN=4, parameter [0:0] OPT_ASYNC_READ = 1'b1, parameter [0:0] OPT_WRITE_ON_FULL = 1'b0, parameter [0:0] OPT_READ_ON_EMPTY = 1'b0 // }}} ) ( // {{{",
            "input wire i_clk, input wire i_reset, // // Write interface",
            "input wire i_wr, input wire [(BW-1):0] i_data, output wire o_full, output reg [LGFLEN:0] o_fill, // // Read interface",
            "input wire i_rd, output reg [(BW-1):0] o_data, output wire o_empty // True if FIFO is empty `ifdef FORMAL `ifdef F_PEEK , output wire [LGFLEN:0] f_first_addr, output wire [LGFLEN:0] f_second_addr, output reg [BW-1:0] f_first_data, f_second_data, output reg f_first_in_fifo, f_second_in_fifo, output reg [LGFLEN:0] f_distance_to_first, f_distance_to_second `endif `endif // }}} ); // Register/net declarations // {{{",
            "localparam FLEN=(1<<LGFLEN);",
            "reg r_full, r_empty;",
            "reg [(BW-1):0] mem[0:(FLEN-1)];",
            "reg [LGFLEN:0] wr_addr, rd_addr;",
            "wire w_wr = (i_wr && !o_full);",
            "wire w_rd = (i_rd && !o_empty); // }}} //////////////////////////////////////////////////////////////////////// // // Write half // {{{ //////////////////////////////////////////////////////////////////////// // // // o_fill // {{{",
            "initial o_fill = 0;",
            "always @(posedge i_clk) if (i_reset) o_fill <= 0; else case({ w_wr, w_rd }) 2'b01: o_fill <= o_fill - 1; 2'b10: o_fill <= o_fill + 1; default: o_fill <= wr_addr - rd_addr; endcase // }}} // r_full, o_full // {{{",
            "initial r_full = 0;",
            "always @(posedge i_clk) if (i_reset) r_full <= 0; else case({ w_wr, w_rd}) 2'b01: r_full <= 1'b0; 2'b10: r_full <= (o_fill == { 1'b0, {(LGFLEN){1'b1}} }); default: r_full <= (o_fill == { 1'b1, {(LGFLEN){1'b0}} }); endcase",
            "assign o_full = (i_rd && OPT_WRITE_ON_FULL) ? 1'b0 : r_full; // }}} // wr_addr, the write address pointer // {{{",
            "initial wr_addr = 0;",
            "always @(posedge i_clk) if (i_reset) wr_addr <= 0; else if (w_wr) wr_addr <= wr_addr + 1'b1; // }}} // Write to memory // {{{",
            "always @(posedge i_clk) if (w_wr) mem[wr_addr[(LGFLEN-1):0]] <= i_data; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Read half // {{{ //////////////////////////////////////////////////////////////////////// // // // rd_addr, the read address pointer // {{{",
            "initial rd_addr = 0;",
            "always @(posedge i_clk) if (i_reset) rd_addr <= 0; else if (w_rd) rd_addr <= rd_addr + 1; // }}} // r_empty, o_empty // {{{",
            "initial r_empty = 1'b1;",
            "always @(posedge i_clk) if (i_reset) r_empty <= 1'b1; else case ({ w_wr, w_rd }) 2'b01: r_empty <= (o_fill <= 1); 2'b10: r_empty <= 1'b0; default: begin end endcase",
            "assign o_empty = (OPT_READ_ON_EMPTY && i_wr) ? 1'b0 : r_empty; // }}} // Read from the FIFO // {{{ generate if (OPT_ASYNC_READ && OPT_READ_ON_EMPTY) begin : ASYNCHRONOUS_READ_ON_EMPTY // o_data // {{{",
            "always @(*) begin o_data = mem[rd_addr[LGFLEN-1:0]]; if (r_empty) o_data = i_data; end // }}} end else if (OPT_ASYNC_READ) begin : ASYNCHRONOUS_READ // o_data // {{{",
            "always @(*) o_data = mem[rd_addr[LGFLEN-1:0]]; // }}} end else begin : REGISTERED_READ // {{{",
            "reg bypass_valid;",
            "reg [BW-1:0] bypass_data, rd_data;",
            "reg [LGFLEN-1:0] rd_next;",
            "always @(*) rd_next = rd_addr[LGFLEN-1:0] + 1; // Memory read, bypassing it if we must // {{{",
            "initial bypass_valid = 0;",
            "always @(posedge i_clk) if (i_reset) bypass_valid <= 0; else if (r_empty || i_rd) begin if (!i_wr) bypass_valid <= 1'b0; else if (r_empty || (i_rd && (o_fill == 1))) bypass_valid <= 1'b1; else bypass_valid <= 1'b0; end",
            "always @(posedge i_clk) if (r_empty || i_rd) bypass_data <= i_data;",
            "initial mem[0] = 0;",
            "initial rd_data = 0;",
            "always @(posedge i_clk) if (w_rd) rd_data <= mem[rd_next];",
            "always @(*) if (OPT_READ_ON_EMPTY && r_empty) o_data = i_data; else if (bypass_valid) o_data = bypass_data; else o_data = rd_data; // }}} // }}} end endgenerate // }}} // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // FORMAL METHODS // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // // Assumptions about our",
            "input (s) // // `ifdef SFIFO `define ASSUME assume `else `define ASSUME assert `endif",
            "reg f_past_valid;",
            "wire [LGFLEN:0] f_fill, f_next;",
            "wire f_empty;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; //////////////////////////////////////////////////////////////////////// // // Assertions about our flags and counters // {{{ //////////////////////////////////////////////////////////////////////// // // assign f_fill = wr_addr - rd_addr;",
            "assign f_empty = (wr_addr == rd_addr);",
            "assign f_next = rd_addr + 1'b1;",
            "always @(*) begin assert(f_fill <= { 1'b1, {(LGFLEN){1'b0}} }); assert(o_fill == f_fill); assert(r_full == (f_fill == {1'b1, {(LGFLEN){1'b0}} })); assert(r_empty == (f_fill == 0)); if (!OPT_WRITE_ON_FULL) begin assert(o_full == r_full); end else begin assert(o_full == (r_full && !i_rd)); end if (!OPT_READ_ON_EMPTY) begin assert(o_empty == r_empty); end else begin assert(o_empty == (r_empty && !i_wr)); end end",
            "always @(posedge i_clk) if (!OPT_ASYNC_READ && f_past_valid) begin if (f_fill == 0) begin assert(r_empty); assert(o_empty || (OPT_READ_ON_EMPTY && i_wr)); end else if ($past(f_fill)>1) begin assert(!r_empty); end else if ($past(!i_rd && f_fill > 0)) assert(!r_empty); end",
            "always @(*) if (!r_empty) begin // This also applies for the",
            "reg istered read case assert(mem[rd_addr[LGFLEN-1:0]] == o_data); end else if (OPT_READ_ON_EMPTY) assert(o_data == i_data); // }}} //////////////////////////////////////////////////////////////////////// // // Formal contract: (Twin write test) // {{{ // If you write two values in succession, you should be able to read // those same two values in succession some time later. // //////////////////////////////////////////////////////////////////////// // // // Verilator lint_off UNDRIVEN (* anyconst *)",
            "reg [LGFLEN:0] fw_first_addr; // Verilator lint_on UNDRIVEN `ifndef F_PEEK",
            "wire [LGFLEN:0] f_first_addr;",
            "wire [LGFLEN:0] f_second_addr;",
            "reg [BW-1:0] f_first_data, f_second_data;",
            "reg f_first_in_fifo, f_second_in_fifo;",
            "reg [LGFLEN:0] f_distance_to_first, f_distance_to_second; `endif",
            "reg f_first_addr_in_fifo, f_second_addr_in_fifo;",
            "assign f_first_addr = fw_first_addr;",
            "assign f_second_addr = f_first_addr + 1;",
            "always @(*) begin f_distance_to_first = (f_first_addr - rd_addr); f_first_addr_in_fifo = 0; if ((f_fill != 0) && (f_distance_to_first < f_fill)) f_first_addr_in_fifo = 1; end",
            "always @(*) begin f_distance_to_second = (f_second_addr - rd_addr); f_second_addr_in_fifo = 0; if ((f_fill != 0) && (f_distance_to_second < f_fill)) f_second_addr_in_fifo = 1; end",
            "always @(posedge i_clk) if (w_wr && wr_addr == f_first_addr) f_first_data <= i_data;",
            "always @(posedge i_clk) if (w_wr && wr_addr == f_second_addr) f_second_data <= i_data;",
            "always @(*) if (f_first_addr_in_fifo) assert(mem[f_first_addr[LGFLEN-1:0]] == f_first_data);",
            "always @(*) f_first_in_fifo = (f_first_addr_in_fifo && (mem[f_first_addr[LGFLEN-1:0]] == f_first_data));",
            "always @(*) if (f_second_addr_in_fifo) assert(mem[f_second_addr[LGFLEN-1:0]] == f_second_data);",
            "always @(*) f_second_in_fifo = (f_second_addr_in_fifo && (mem[f_second_addr[LGFLEN-1:0]] == f_second_data));",
            "always @(*) if (f_first_in_fifo && (o_fill == 1 || f_distance_to_first == 0)) assert(o_data == f_first_data);",
            "always @(*) if (f_second_in_fifo && (o_fill == 1 || f_distance_to_second == 0)) assert(o_data == f_second_data);",
            "always @(posedge i_clk) if (f_past_valid && !$past(i_reset)) begin case({$past(f_first_in_fifo), $past(f_second_in_fifo)}) 2'b00: begin if ($past(w_wr && (!w_rd || !r_empty)) &&($past(wr_addr == f_first_addr))) begin assert(f_first_in_fifo); end else begin assert(!f_first_in_fifo); end // // The second could be in the FIFO, since // one might write other data than f_first_data // // assert(!f_second_in_fifo); end 2'b01: begin assert(!f_first_in_fifo); if ($past(w_rd && (rd_addr==f_second_addr))) begin assert((o_empty&&!OPT_ASYNC_READ)||!f_second_in_fifo); end else begin assert(f_second_in_fifo); end end 2'b10: begin if ($past(w_wr) &&($past(wr_addr == f_second_addr))) begin assert(f_second_in_fifo); end else begin assert(!f_second_in_fifo); end if ($past(!w_rd ||(rd_addr != f_first_addr))) assert(f_first_in_fifo); end 2'b11: begin assert(f_second_in_fifo); if ($past(!w_rd ||(rd_addr != f_first_addr))) begin assert(f_first_in_fifo); if (rd_addr == f_first_addr) assert(o_data == f_first_data); end else begin assert(!f_first_in_fifo); assert(o_data == f_second_data); end end endcase end // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // `ifdef SFIFO",
            "reg f_was_full;",
            "initial f_was_full = 0;",
            "always @(posedge i_clk) if (o_full) f_was_full <= 1;",
            "always @(posedge i_clk) cover($fell(f_empty));",
            "always @(posedge i_clk) cover($fell(o_empty));",
            "always @(posedge i_clk) cover(f_was_full && f_empty);",
            "always @(posedge i_clk) cover($past(o_full,2)&&(!$past(o_full))&&(o_full));",
            "always @(posedge i_clk) if (f_past_valid) cover($past(o_empty,2)&&(!$past(o_empty))&& o_empty); `endif // }}} // Make Verilator happy // Verilator lint_off UNUSED",
            "wire unused_formal;",
            "assign unused_formal = &{ 1'b0, f_next[LGFLEN], f_empty }; // Verilator lint_on UNUSED `endif // FORMAL // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "wbarbiter.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/wbarbiter.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: wbarbiter.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This is a priority bus arbiter. It allows two separate wishbone // masters to connect to the same bus, while also guaranteeing // that the last master can have the bus with no delay any time it is // idle. The goal is to minimize the combinatorial",
            "logic required in this // process, while still minimizing access time. // // The core",
            "logic works like this: // // 1. If 'A' or 'B' asserts the o_cyc line, a bus cycle will begin, // with acccess granted to whomever requested it. // 2. If both 'A' and 'B' assert o_cyc at the same time, only 'A' // will be granted the bus. (If the alternating",
            "parameter // is set, A and B will alternate who gets the bus in // this case.) // 3. The bus will remain owned by whomever the bus was granted to // until they deassert the o_cyc line. // 4. At the end of a bus cycle, o_cyc is guaranteed to be // deasserted (low) for one clock. // 5. On the next clock, bus arbitration takes place again. If // 'A' requests the bus, no matter how long 'B' was // waiting, 'A' will then be granted the bus. (Unless // again the alternating",
            "parameter is set, then the // access is guaranteed to switch to B.) // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // `define WBA_ALTERNATING // }}}",
            "module wbarbiter #( // {{{",
            "parameter DW=32, AW=32, parameter SCHEME=\"ALTERNATING\", parameter [0:0] OPT_ZERO_ON_IDLE = 1'b0 `ifdef FORMAL , parameter F_MAX_STALL = 3, parameter F_MAX_ACK_DELAY = 3, parameter F_LGDEPTH=3 `endif // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Bus A -- the priority bus // {{{",
            "input wire i_a_cyc, i_a_stb, i_a_we, input wire [(AW-1):0] i_a_adr, input wire [(DW-1):0] i_a_dat, input wire [(DW/8-1):0] i_a_sel, output wire o_a_stall, o_a_ack, o_a_err, // }}} // Bus B // {{{",
            "input wire i_b_cyc, i_b_stb, i_b_we, input wire [(AW-1):0] i_b_adr, input wire [(DW-1):0] i_b_dat, input wire [(DW/8-1):0] i_b_sel, output wire o_b_stall, o_b_ack, o_b_err, // }}} // Combined/arbitrated bus // {{{",
            "output wire o_cyc, o_stb, o_we, output wire [(AW-1):0] o_adr, output wire [(DW-1):0] o_dat, output wire [(DW/8-1):0] o_sel, input wire i_stall, i_ack, i_err // }}} `ifdef FORMAL , output wire [(F_LGDEPTH-1):0] f_nreqs, f_nacks, f_outstanding, f_a_nreqs, f_a_nacks, f_a_outstanding, f_b_nreqs, f_b_nacks, f_b_outstanding `endif // }}} ); // {{{ // Go high immediately (new cycle) if ... // Previous cycle was low and *someone* is requesting a bus cycle // Go low immadiately if ... // We were just high and the owner no longer wants the bus // WISHBONE Spec recommends no",
            "logic between a FF and the o_cyc // This violates that spec. (Rec 3.15, p35) // }}} // Local declarations // {{{",
            "reg r_a_owner; // }}}",
            "assign o_cyc = (r_a_owner) ? i_a_cyc : i_b_cyc;",
            "initial r_a_owner = 1'b1; // r_a_owner -- determined through arbitration // {{{ generate if (SCHEME == \"PRIORITY\") begin : PRI // {{{",
            "always @(posedge i_clk) if (!i_b_cyc) r_a_owner <= 1'b1; // Allow B to set its CYC line w/o activating this // interface else if ((i_b_stb)&&(!i_a_cyc)) r_a_owner <= 1'b0; // }}} end else if (SCHEME == \"ALTERNATING\") begin : ALT // {{{",
            "reg last_owner;",
            "initial last_owner = 1'b0;",
            "always @(posedge i_clk) if ((i_a_cyc)&&(r_a_owner)) last_owner <= 1'b1; else if ((i_b_cyc)&&(!r_a_owner)) last_owner <= 1'b0;",
            "always @(posedge i_clk) if ((!i_a_cyc)&&(!i_b_cyc)) r_a_owner <= !last_owner; else if ((r_a_owner)&&(!i_a_cyc)) begin if (i_b_stb) r_a_owner <= 1'b0; end else if ((!r_a_owner)&&(!i_b_cyc)) begin if (i_a_stb) r_a_owner <= 1'b1; end // }}} end else // if (SCHEME == \"LAST\") begin : LST // {{{",
            "always @(posedge i_clk) if ((!i_a_cyc)&&(i_b_stb)) r_a_owner <= 1'b0; else if ((!i_b_cyc)&&(i_a_stb)) r_a_owner <= 1'b1; // ?}}} end endgenerate // }}} // o_we // {{{ // Realistically, if neither master owns the bus, the",
            "output is a // don't care. Thus we trigger off whether or not 'A' owns the bus. // If 'B' owns it all we care is that 'A' does not. Likewise, if // neither owns the bus than the values on the various lines are // irrelevant.",
            "assign o_we = (r_a_owner) ? i_a_we : i_b_we; // }}} // Other bus",
            "output s // {{{ generate if (OPT_ZERO_ON_IDLE) begin : LOW_POWER // {{{ // OPT_ZERO_ON_IDLE will use up more",
            "logic and may even slow // down the master clock if set. However, it may also reduce // the power used by the FPGA by preventing things from toggling // when the bus isn't in use. The option is here because it // also makes it a lot easier to look for when things happen // on the bus via VERILATOR when timing and",
            "logic counts // don't matter. // assign o_stb = (o_cyc)? ((r_a_owner) ? i_a_stb : i_b_stb):0;",
            "assign o_adr = (o_stb)? ((r_a_owner) ? i_a_adr : i_b_adr):0;",
            "assign o_dat = (o_stb)? ((r_a_owner) ? i_a_dat : i_b_dat):0;",
            "assign o_sel = (o_stb)? ((r_a_owner) ? i_a_sel : i_b_sel):0;",
            "assign o_a_ack = (o_cyc)&&( r_a_owner) ? i_ack : 1'b0;",
            "assign o_b_ack = (o_cyc)&&(!r_a_owner) ? i_ack : 1'b0;",
            "assign o_a_stall = (o_cyc)&&( r_a_owner) ? i_stall : 1'b1;",
            "assign o_b_stall = (o_cyc)&&(!r_a_owner) ? i_stall : 1'b1;",
            "assign o_a_err = (o_cyc)&&( r_a_owner) ? i_err : 1'b0;",
            "assign o_b_err = (o_cyc)&&(!r_a_owner) ? i_err : 1'b0; // }}} end else begin : LOW_LOGIC // {{{",
            "assign o_stb = (r_a_owner) ? i_a_stb : i_b_stb;",
            "assign o_adr = (r_a_owner) ? i_a_adr : i_b_adr;",
            "assign o_dat = (r_a_owner) ? i_a_dat : i_b_dat;",
            "assign o_sel = (r_a_owner) ? i_a_sel : i_b_sel; // We cannot allow the return acknowledgement to ever go high if // the master in question does not own the bus. Hence we force // it low if the particular master doesn't own the bus.",
            "assign o_a_ack = ( r_a_owner) ? i_ack : 1'b0;",
            "assign o_b_ack = (!r_a_owner) ? i_ack : 1'b0; // Stall must be asserted on the same cycle the",
            "input master // asserts the bus, if the bus isn't granted to him.",
            "assign o_a_stall = ( r_a_owner) ? i_stall : 1'b1;",
            "assign o_b_stall = (!r_a_owner) ? i_stall : 1'b1; // // assign o_a_err = ( r_a_owner) ? i_err : 1'b0;",
            "assign o_b_err = (!r_a_owner) ? i_err : 1'b0; // }}} end endgenerate // }}} // Make Verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_reset }; // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL `ifdef WBARBITER `define ASSUME assume `else `define ASSUME assert `endif",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "initial `ASSUME(!i_a_cyc);",
            "initial `ASSUME(!i_a_stb);",
            "initial `ASSUME(!i_b_cyc);",
            "initial `ASSUME(!i_b_stb);",
            "initial `ASSUME(!i_ack);",
            "initial `ASSUME(!i_err);",
            "always @(*) if (!f_past_valid) `ASSUME(i_reset);",
            "always @(posedge i_clk) begin if (o_cyc) assert((i_a_cyc)||(i_b_cyc)); if ((f_past_valid)&&($past(o_cyc))&&(o_cyc)) assert($past(r_a_owner) == r_a_owner); end fwb_master #( // {{{ .DW(DW), .AW(AW), .F_MAX_STALL(F_MAX_STALL), .F_LGDEPTH(F_LGDEPTH), .F_MAX_ACK_DELAY(F_MAX_ACK_DELAY), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1), .F_OPT_CLK2FFLOGIC(1'b0) // }}} ) f_wbm ( // {{{ i_clk, i_reset, o_cyc, o_stb, o_we, o_adr, o_dat, o_sel, i_ack, i_stall, 32'h0, i_err, f_nreqs, f_nacks, f_outstanding // }}} ); fwb_slave #( // {{{ .DW(DW), .AW(AW), .F_MAX_STALL(0), .F_LGDEPTH(F_LGDEPTH), .F_MAX_ACK_DELAY(0), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1), .F_OPT_CLK2FFLOGIC(1'b0) // }}} ) f_wba ( // {{{ i_clk, i_reset, i_a_cyc, i_a_stb, i_a_we, i_a_adr, i_a_dat, i_a_sel, o_a_ack, o_a_stall, 32'h0, o_a_err, f_a_nreqs, f_a_nacks, f_a_outstanding // }}} ); fwb_slave #( // {{{ .DW(DW), .AW(AW), .F_MAX_STALL(0), .F_LGDEPTH(F_LGDEPTH), .F_MAX_ACK_DELAY(0), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1), .F_OPT_CLK2FFLOGIC(1'b0) // }}} ) f_wbb ( // {{{ i_clk, i_reset, i_b_cyc, i_b_stb, i_b_we, i_b_adr, i_b_dat, i_b_sel, o_b_ack, o_b_stall, 32'h0, o_b_err, f_b_nreqs, f_b_nacks, f_b_outstanding // }}} ); // Induction properties, relating nreqs and nacks to r_a_owner // {{{",
            "always @(posedge i_clk) if (r_a_owner) begin assert(f_b_nreqs == 0); assert(f_b_nacks == 0); assert(f_a_outstanding == f_outstanding); end else begin assert(f_a_nreqs == 0); assert(f_a_nacks == 0); assert(f_b_outstanding == f_outstanding); end // }}}",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&($past(i_a_stb))&&(!$past(i_b_cyc))) assert(r_a_owner);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&(!$past(i_a_cyc))&&($past(i_b_stb))) assert(!r_a_owner);",
            "always @(posedge i_clk) if ((f_past_valid)&&(r_a_owner != $past(r_a_owner))) assert(!$past(o_cyc)); `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "wbdblpriarb.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/wbdblpriarb.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: wbdblpriarb.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This should almost be identical to the priority arbiter, save // for a simple diffence: it allows the arbitration of two // separate wishbone buses. The purpose of this is to push the address // resolution back one cycle, so that by the first clock visible to this // core, it is known which of two parts of the bus the desired address // will be on, save that we still use the arbiter since the underlying // device doesn't know that there are two wishbone buses. // // So at this point we've deviated from the WB spec somewhat, by allowing // two CYC and two STB lines. Everything else is the same. This allows // (in this case the Zip CPU) to determine whether or not the access // will be to the local ZipSystem bus or the external WB bus on the clock // before the local bus access, otherwise peripherals were needing to do // multiple device selection comparisons/test within a clock: 1) is this // for the local or external bus, and 2) is this referencing me as a // peripheral. This then caused the ZipCPU to fail all timing specs. // By creating the two pairs of lines, CYC_A/STB_A and CYC_B/STB_B, the // determination of local vs external can be made one clock earlier // where there's still time for the",
            "logic , and the second comparison // now has time to complete. // // So let me try to explain this again. To use this arbiter, one of the // two masters sets CYC and STB before, only the master determines which // of two address spaces the CYC and STB apply to before the clock and // only sets the appropriate CYC and STB lines. Then, on the clock tick, // the arbiter determines who gets *both* busses, as they both share every // other WB line. Thus, only one of CYC_A and CYC_B going out will ever // be high at a given time. // // Hopefully this makes more sense than it sounds. If not, check out the // code below for a better explanation. // // 20150919 -- Added supported for the WB error signal. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module wbdblpriarb #( // {{{",
            "parameter DW=32, AW=32, // OPT_ZERO_ON_IDLE // {{{ // OPT_ZERO_ON_IDLE uses more",
            "logic than the alternative. It // should be useful for reducing power, as these circuits tend // to drive",
            "wire s all the way across the design, but it may also // slow down the master clock. I've used it as an option when // using VER1LATOR, 'cause zeroing things on idle can make them // stand out all the more when staring at",
            "wire s and dumps and // such.",
            "parameter [0:0] OPT_ZERO_ON_IDLE = 1'b0 // }}} `ifdef FORMAL // Parameters used in the formal proof only , parameter F_LGDEPTH = 3, parameter F_MAX_STALL = 0, parameter F_MAX_ACK_DELAY=0 `endif // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Bus A // {{{",
            "input wire i_a_cyc_a, i_a_cyc_b, i_a_stb_a, i_a_stb_b, i_a_we, input wire [(AW-1):0] i_a_adr, input wire [(DW-1):0] i_a_dat, input wire [(DW/8-1):0] i_a_sel, output wire o_a_stall, o_a_ack, o_a_err, // }}} // Bus B // {{{",
            "input wire i_b_cyc_a, i_b_cyc_b, i_b_stb_a, i_b_stb_b, i_b_we, input wire [(AW-1):0] i_b_adr, input wire [(DW-1):0] i_b_dat, input wire [(DW/8-1):0] i_b_sel, output wire o_b_stall, o_b_ack, o_b_err, // }}} // Both buses (i.e. the outgoing, arbitrated bus) // {{{",
            "output wire o_cyc_a, o_cyc_b, o_stb_a, o_stb_b, o_we, output wire [(AW-1):0] o_adr, output wire [(DW-1):0] o_dat, output wire [(DW/8-1):0] o_sel, input wire i_stall, i_ack, i_err // }}} `ifdef FORMAL // {{{ // These",
            "wire s are relics from when the ZipCPU was verified // with this arbiter internal to it. Since this is no longer // the case, they're now no more than declarations , output wire [(F_LGDEPTH-1):0] f_nreqs_a, f_nacks_a, f_outstanding_a, f_nreqs_b, f_nacks_b, f_outstanding_b, f_a_nreqs_a, f_a_nacks_a, f_a_outstanding_a, f_a_nreqs_b, f_a_nacks_b, f_a_outstanding_b, f_b_nreqs_a, f_b_nacks_a, f_b_outstanding_a, f_b_nreqs_b, f_b_nacks_b, f_b_outstanding_b // }}} `endif // }}} ); // r_a_owner // {{{ // All of our",
            "logic is really captured in the 'r_a_owner'",
            "reg ister. // This",
            "reg ister determines who owns the bus. If no one is requesting // the bus, ownership goes to A on the next clock. Otherwise, if B is // requesting the bus and A is not, then ownership goes to not A on // the next clock. (Sounds simple ...) // // The CYC",
            "logic is here to make certain that, by the time we determine // who the bus owner is, we can do so based upon determined criteria.",
            "reg r_a_owner;",
            "initial r_a_owner = 1'b1;",
            "always @(posedge i_clk) if (i_reset) r_a_owner <= 1'b1; /* // Remain with the \"last owner\" until 1) the other bus requests // access, and 2) the last owner no longer wants it. This // logic \"idles\" on the last owner. // // This is an alternating bus owner strategy // else if ((!o_cyc_a)&&(!o_cyc_b)) r_a_owner <= ((i_b_stb_a)||(i_b_stb_b))? 1'b0:1'b1; // // Expanding this out // // else if ((r_a_owner)&&((i_a_cyc_a)||(i_a_cyc_b))) // r_a_owner <= 1'b1; // else if ((!r_a_owner)&&((i_b_cyc_a)||(i_b_cyc_b))) // r_a_owner <= 1'b0; // else if ((r_a_owner)&&((i_b_stb_a)||(i_b_stb_b))) // r_a_owner <= 1'b0; // else if ((!r_a_owner)&&((i_a_stb_a)||(i_a_stb_b))) // r_a_owner <= 1'b0; // // Logic required: // // Reset line // + 9",
            "input s (data) // + 9",
            "input s (CE) // Could be done with three LUTs // First two evaluate o_cyc_a and o_cyc_b (above) */ // Option 2: // // \"Idle\" on A as the owner. // If a request is made from B, AND A is idle, THEN // switch. Otherwise, if B is ever idle, revert back to A // reg ardless of whether A wants it or not. else if ((!i_b_cyc_a)&&(!i_b_cyc_b)) r_a_owner <= 1'b1; else if ((!i_a_cyc_a)&&(!i_a_cyc_b) &&((i_b_stb_a)||(i_b_stb_b))) r_a_owner <= 1'b0; // }}} // o_cyc*, o_stb*, o_we // {{{ // Realistically, if neither master owns the bus, the",
            "output is a // don't care. Thus we trigger off whether or not 'A' owns the bus. // If 'B' owns it all we care is that 'A' does not. Likewise, if // neither owns the bus than the values on these various lines are // irrelevant.",
            "assign o_cyc_a = ((r_a_owner) ? i_a_cyc_a : i_b_cyc_a);",
            "assign o_cyc_b = ((r_a_owner) ? i_a_cyc_b : i_b_cyc_b);",
            "assign o_stb_a = (r_a_owner) ? i_a_stb_a : i_b_stb_a;",
            "assign o_stb_b = (r_a_owner) ? i_a_stb_b : i_b_stb_b;",
            "assign o_we = (r_a_owner) ? i_a_we : i_b_we; // }}} // Other bus",
            "output s and returns // {{{ generate if (OPT_ZERO_ON_IDLE) begin : OPT_LOWPOWER // {{{",
            "wire o_cyc, o_stb;",
            "assign o_cyc = ((o_cyc_a)||(o_cyc_b));",
            "assign o_stb = ((o_stb_a)||(o_stb_b));",
            "assign o_adr = (o_stb)?((r_a_owner) ? i_a_adr : i_b_adr):0;",
            "assign o_dat = (o_stb)?((r_a_owner) ? i_a_dat : i_b_dat):0;",
            "assign o_sel = (o_stb)?((r_a_owner) ? i_a_sel : i_b_sel):0;",
            "assign o_a_ack = (o_cyc)&&( r_a_owner) ? i_ack : 1'b0;",
            "assign o_b_ack = (o_cyc)&&(!r_a_owner) ? i_ack : 1'b0;",
            "assign o_a_stall = (o_cyc)&&( r_a_owner) ? i_stall : 1'b1;",
            "assign o_b_stall = (o_cyc)&&(!r_a_owner) ? i_stall : 1'b1;",
            "assign o_a_err = (o_cyc)&&( r_a_owner) ? i_err : 1'b0;",
            "assign o_b_err = (o_cyc)&&(!r_a_owner) ? i_err : 1'b0; // }}} end else begin : OPT_LOWLOGIC // {{{",
            "assign o_adr = (r_a_owner) ? i_a_adr : i_b_adr;",
            "assign o_dat = (r_a_owner) ? i_a_dat : i_b_dat;",
            "assign o_sel = (r_a_owner) ? i_a_sel : i_b_sel; // We cannot allow the return acknowledgement to ever go high if // the master in question does not own the bus. Hence we force it // low if the particular master doesn't own the bus.",
            "assign o_a_ack = ( r_a_owner) ? i_ack : 1'b0;",
            "assign o_b_ack = (!r_a_owner) ? i_ack : 1'b0; // Stall must be asserted on the same cycle the",
            "input master asserts // the bus, if the bus isn't granted to him.",
            "assign o_a_stall = ( r_a_owner) ? i_stall : 1'b1;",
            "assign o_b_stall = (!r_a_owner) ? i_stall : 1'b1; // // assign o_a_err = ( r_a_owner) ? i_err : 1'b0;",
            "assign o_b_err = (!r_a_owner) ? i_err : 1'b0; // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL `define ASSERT assert `ifdef WBDBLPRIARB `define ASSUME assume `else `define ASSUME assert `endif",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "initial `ASSUME(i_reset);",
            "always @(*) if (!f_past_valid) `ASSUME(i_reset);",
            "initial `ASSUME(!i_a_cyc_a);",
            "initial `ASSUME(!i_a_stb_a);",
            "initial `ASSUME(!i_a_cyc_b);",
            "initial `ASSUME(!i_a_stb_b);",
            "initial `ASSUME(!i_b_cyc_a);",
            "initial `ASSUME(!i_b_stb_a);",
            "initial `ASSUME(!i_b_cyc_b);",
            "initial `ASSUME(!i_b_stb_b);",
            "initial `ASSUME(!i_ack);",
            "initial `ASSUME(!i_err);",
            "always @(*) `ASSUME((!i_a_cyc_a)||(!i_a_cyc_b));",
            "always @(*) `ASSUME((!i_b_cyc_a)||(!i_b_cyc_b));",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_a_cyc_a))) `ASSUME(!i_a_cyc_b);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_a_cyc_b))) `ASSUME(!i_a_cyc_a);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_b_cyc_a))) `ASSUME(!i_b_cyc_b);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_b_cyc_b))) `ASSUME(!i_b_cyc_a);",
            "wire f_cyc, f_stb;",
            "assign f_cyc = (o_cyc_a)||(o_cyc_b);",
            "assign f_stb = (o_stb_a)||(o_stb_b);",
            "always @(posedge i_clk) begin if (o_cyc_a) `ASSERT((i_a_cyc_a)||(i_b_cyc_a)); if (o_cyc_b) `ASSERT((i_a_cyc_b)||(i_b_cyc_b)); `ASSERT((!o_cyc_a)||(!o_cyc_b)); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))) begin if ($past(f_cyc)) begin if (($past(o_cyc_a))&&(o_cyc_a)) `ASSERT($past(r_a_owner) == r_a_owner); if (($past(o_cyc_b))&&(o_cyc_b)) `ASSERT($past(r_a_owner) == r_a_owner); end else begin if (($past(i_a_stb_a))||($past(i_a_stb_b))) `ASSERT(r_a_owner); if (($past(i_b_stb_a))||($past(i_b_stb_b))) `ASSERT(!r_a_owner); end end fwb_master #( // {{{ .AW(AW), .DW(DW), .F_MAX_STALL(F_MAX_STALL), .F_LGDEPTH(F_LGDEPTH), .F_MAX_ACK_DELAY(F_MAX_ACK_DELAY), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1) // }}} ) f_wbm_a ( // {{{ i_clk, i_reset, o_cyc_a, o_stb_a, o_we, o_adr, o_dat, o_sel, (o_cyc_a)&&(i_ack), i_stall, 32'h0, (o_cyc_a)&&(i_err), f_nreqs_a, f_nacks_a, f_outstanding_a // }}} ); fwb_master #( // {{{ .AW(AW), .DW(DW), .F_MAX_STALL(F_MAX_STALL), .F_MAX_ACK_DELAY(F_MAX_ACK_DELAY), .F_LGDEPTH(F_LGDEPTH), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1) // }}} ) f_wbm_b( // {{{ i_clk, i_reset, o_cyc_b, o_stb_b, o_we, o_adr, o_dat, o_sel, (o_cyc_b)&&(i_ack), i_stall, 32'h0, (o_cyc_b)&&(i_err), f_nreqs_b, f_nacks_b, f_outstanding_b // }}} ); `ifdef WBDBLPRIARB `define F_SLAVE fwb_slave `else `define F_SLAVE fwb_counter `endif `F_SLAVE #( // {{{ .AW(AW), .DW(DW), .F_MAX_STALL(0), .F_LGDEPTH(F_LGDEPTH), .F_MAX_ACK_DELAY(0), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1) // }}} ) f_wba_a( // {{{ i_clk, i_reset, i_a_cyc_a, i_a_stb_a, i_a_we, i_a_adr, i_a_dat, i_a_sel, (o_cyc_a)&&(o_a_ack), o_a_stall, 32'h0, (o_cyc_a)&&(o_a_err), f_a_nreqs_a, f_a_nacks_a, f_a_outstanding_a // }}} ); `F_SLAVE #( // {{{ .AW(AW), .DW(DW), .F_MAX_STALL(0), .F_LGDEPTH(F_LGDEPTH), .F_MAX_ACK_DELAY(0), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1) // }}} ) f_wba_b( // {{{ i_clk, i_reset, i_a_cyc_b, i_a_stb_b, i_a_we, i_a_adr, i_a_dat, i_a_sel, (o_cyc_b)&&(o_a_ack), o_a_stall, 32'h0, (o_cyc_b)&&(o_a_err), f_a_nreqs_b, f_a_nacks_b, f_a_outstanding_b // }}} ); `F_SLAVE #( // {{{ .AW(AW), .DW(DW), .F_MAX_STALL(0), .F_LGDEPTH(F_LGDEPTH), .F_MAX_ACK_DELAY(0), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1) // }}} ) f_wbb_a( // {{{ i_clk, i_reset, i_b_cyc_a, i_b_stb_a, i_b_we, i_b_adr, i_b_dat, i_b_sel, (o_cyc_a)&&(o_b_ack), o_b_stall, 32'h0, (o_cyc_a)&&(o_b_err), f_b_nreqs_a, f_b_nacks_a, f_b_outstanding_a // }}} ); `F_SLAVE #( // {{{ .AW(AW), .DW(DW), .F_MAX_STALL(0), .F_LGDEPTH(F_LGDEPTH), .F_MAX_ACK_DELAY(0), .F_OPT_RMW_BUS_OPTION(1), .F_OPT_DISCONTINUOUS(1) // }}} ) f_wbb_b( // {{{ i_clk, i_reset, i_b_cyc_b, i_b_stb_b, i_b_we, i_b_adr, i_b_dat, i_b_sel, (o_cyc_b)&&(o_b_ack), o_b_stall, 32'h0, (o_cyc_b)&&(o_b_err), f_b_nreqs_b, f_b_nacks_b, f_b_outstanding_b // }}} ); // Induction properties, relating nreqs and nacks to r_a_owner // {{{",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))) begin if (r_a_owner) begin : A_IS_OWNER // {{{ `ASSERT(f_b_nreqs_a == 0); `ASSERT(f_b_nreqs_b == 0); // `ASSERT(f_b_nacks_a == 0); `ASSERT(f_b_nacks_b == 0); // if (i_a_cyc_a) begin `ASSERT(f_a_outstanding_a == f_outstanding_a); `ASSERT(f_a_outstanding_b == 0); `ASSERT(f_outstanding_b == 0); `ASSERT(f_a_nreqs_b == 0); `ASSERT(f_a_nacks_b == 0); end else if (i_a_cyc_b) begin `ASSERT(f_a_outstanding_b == f_outstanding_b); `ASSERT(f_a_outstanding_a == 0); `ASSERT(f_outstanding_a == 0); `ASSERT(f_a_nreqs_a == 0); `ASSERT(f_a_nacks_a == 0); end // }}} end else begin : B_IS_OWNER // {{{ `ASSERT(f_a_nreqs_a == 0); `ASSERT(f_a_nreqs_b == 0); // `ASSERT(f_a_nacks_a == 0); `ASSERT(f_a_nacks_b == 0); // if (i_b_cyc_a) begin `ASSERT(f_b_outstanding_a == f_outstanding_a); `ASSERT(f_b_outstanding_b == 0); `ASSERT(f_outstanding_b == 0); `ASSERT(f_b_nreqs_b == 0); `ASSERT(f_b_nacks_b == 0); end else if (i_b_cyc_b) begin `ASSERT(f_b_outstanding_b == f_outstanding_b); `ASSERT(f_b_outstanding_a == 0); `ASSERT(f_outstanding_a == 0); `ASSERT(f_b_nreqs_a == 0); `ASSERT(f_b_nacks_a == 0); end // }}} end end // }}}",
            "always @(posedge i_clk) if ((r_a_owner)&&(i_b_cyc_a)) `ASSUME((i_b_stb_a)&&(!i_b_stb_b));",
            "always @(posedge i_clk) if ((r_a_owner)&&(i_b_cyc_b)) `ASSUME((i_b_stb_b)&&(!i_b_stb_a));",
            "always @(posedge i_clk) if ((!r_a_owner)&&(i_a_cyc_a)) `ASSUME((i_a_stb_a)&&(!i_a_stb_b));",
            "always @(posedge i_clk) if ((!r_a_owner)&&(i_a_cyc_b)) `ASSUME((i_a_stb_b)&&(!i_a_stb_a)); `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "wbdmac.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/wbdmac.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: wbdmac.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Wishbone DMA controller // // This",
            "module is controllable via the wishbone, and moves values from // one location in the wishbone address space to another. The amount of // memory moved at any given time can be up to 4kB, or equivalently 1kW. // Four",
            "reg isters control this DMA controller: a control/status",
            "reg ister, // a length",
            "reg ister, a source WB address and a destination WB address. // These",
            "reg ister may be read at any time, but they may only be written // to when the controller is idle. // // The meanings of three of the setup",
            "reg isters should be self explanatory: // - The length",
            "reg ister controls the total number of words to // transfer. // - The source address",
            "reg ister controls where the DMA controller // reads from. This address may or may not be incremented // after each read, depending upon the setting in the // control/status",
            "reg ister. // - The destination address",
            "reg ister, which controls where the DMA // controller writes to. This address may or may not be // incremented after each write, also depending upon the // setting in the control/status",
            "reg ister. // // It is the control/status",
            "reg ister, at local address zero, that needs // more definition: // // Bits: // 31 R Write protect If this is set to one, it means the // write protect bit is set and the controller // is therefore idle. This bit will be set upon // completing any transfer. // 30 R Error. The controller stopped mid-transfer // after receiving a bus error. // 29 R/W inc_s_n If set to one, the source address // will not increment from one read to the next. // 28 R/W inc_d_n If set to one, the destination address // will not increment from one write to the next. // 27 R Always 0 // 26..16 R nread Indicates how many words have been read, // and not necessarily written (yet). This // combined with the cfg_len",
            "parameter should tell // exactly where the controller is at mid-transfer. // 27..16 W WriteProtect When a 12'h3db is written to these // bits, the write protect bit will be cleared. // // 15 R/W on_dev_trigger When set to '1', the controller will // wait for an external interrupt before starting. // 14..10 R/W device_id This determines which external interrupt // will trigger a transfer. // 9..0 R/W transfer_len How many bytes to transfer at one time. // The minimum transfer length is one, while zero // is mapped to a transfer length of 1kW. // // Write 32'hffed00 to halt an ongoing transaction, completing anything // remaining, or 32'hafed00 to abort the current transaction leaving // any unfinished read/write in an undetermined state. // // // To use this, follow this checklist: // 1. Wait for any prior DMA operation to complete // (Read address 0, wait 'till either top bit is set or cfg_len==0) // 2. Write values into length, source and destination address. // (writei(3, &vals) should be sufficient for this.) // 3. Enable the DMAC interrupt in whatever interrupt controller is present // on the system. // 4. Write the final start command to the setup/control/status",
            "reg ister: // Set inc_s_n, inc_d_n, on_dev_trigger, dev_trigger, // appropriately for your task // Write 12'h3db to the upper word. // Set the lower word to either all zeros, or a smaller transfer // length if desired. // 5. wait() for the interrupt and the operation to complete. // Prior to completion, number of items successfully transferred // be read from the length",
            "reg ister. If the internal buffer is // being used, then you can read how much has been read into that // buffer by reading from bits 25..16 of this control/status // reg ister. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module wbdmac #( // {{{",
            "parameter ADDRESS_WIDTH=30, LGMEMLEN = 10, parameter SLV_WIDTH=32, parameter BUS_WIDTH=32, localparam AW=ADDRESS_WIDTH // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Slave port // {{{ // Slave/control wishbone",
            "input s",
            "input wire i_swb_cyc, i_swb_stb, i_swb_we, input wire [1:0] i_swb_addr, input wire [(SLV_WIDTH-1):0] i_swb_data, // Slave/control wishbone",
            "output s",
            "output wire o_swb_stall, output reg o_swb_ack, output reg [(SLV_WIDTH-1):0] o_swb_data, // }}} // Master/DMA port // {{{",
            "output wire o_mwb_cyc, o_mwb_stb, o_mwb_we, output reg [(AW-1):0] o_mwb_addr, output reg [(BUS_WIDTH-1):0] o_mwb_data, // Master/DMA wishbone responses from the bus",
            "input wire i_mwb_stall, i_mwb_ack, input wire [(BUS_WIDTH-1):0] i_mwb_data, input wire i_mwb_err, // }}} // The interrupt device interrupt lines",
            "input wire [31:0] i_dev_ints, // An interrupt to be set upon completion",
            "output reg o_interrupt // }}} ); // Local declarations // {{{",
            "localparam LGDV=5;",
            "localparam [2:0] DMA_IDLE = 3'b000, DMA_WAIT = 3'b001, DMA_READ_REQ = 3'b010, DMA_READ_ACK = 3'b011, DMA_PRE_WRITE = 3'b100, DMA_WRITE_REQ = 3'b101, DMA_WRITE_ACK = 3'b110;",
            "wire s_cyc, s_stb, s_we;",
            "wire [1:0] s_addr;",
            "wire [SLV_WIDTH-1:0] s_data;",
            "reg [2:0] dma_state;",
            "reg cfg_err, cfg_len_nonzero;",
            "reg [(AW-1):0] cfg_waddr, cfg_raddr, cfg_len;",
            "reg [(LGMEMLEN-1):0] cfg_blocklen_sub_one;",
            "reg cfg_incs, cfg_incd;",
            "reg [(LGDV-1):0] cfg_dev_trigger;",
            "reg cfg_on_dev_trigger; // Single block operations: We'll read, then write, up to a single // memory block here.",
            "reg [BUS_WIDTH-1:0] dma_mem [0:(((1<<LGMEMLEN))-1)];",
            "reg [(LGMEMLEN):0] nread, nwritten, nwacks, nracks;",
            "wire [(AW-1):0] bus_nracks;",
            "reg last_read_request, last_read_ack, last_write_request, last_write_ack;",
            "reg trigger, abort, user_halt;",
            "wire [(LGMEMLEN):0] next_nread;",
            "reg [(LGMEMLEN-1):0] rdaddr; // }}}",
            "localparam [0:0] OPT_DELAY_BUS_ACCESS = 1; generate if (OPT_DELAY_BUS_ACCESS) begin : DELAY_ACCESS // {{{",
            "reg r_s_cyc, r_s_stb, r_s_we;",
            "reg [1:0] r_s_addr;",
            "reg [SLV_WIDTH-1:0] r_s_data;",
            "always @(posedge i_clk) r_s_cyc <= i_swb_cyc;",
            "always @(posedge i_clk) if (i_reset) r_s_stb <= 1'b0; else r_s_stb <= i_swb_stb;",
            "always @(posedge i_clk) r_s_we <= i_swb_we;",
            "always @(posedge i_clk) r_s_addr<= i_swb_addr;",
            "always @(posedge i_clk) r_s_data<= i_swb_data;",
            "assign s_cyc = r_s_cyc;",
            "assign s_stb = r_s_stb;",
            "assign s_we = r_s_we;",
            "assign s_addr= r_s_addr;",
            "assign s_data= r_s_data; // }}} end else begin : STRAIGHT_SLAVE_ACCESS // {{{",
            "assign s_cyc = i_swb_cyc;",
            "assign s_stb = i_swb_stb;",
            "assign s_we = i_swb_we;",
            "assign s_addr= i_swb_addr;",
            "assign s_data= i_swb_data; // }}} end endgenerate",
            "assign bus_nracks = { {(AW-LGMEMLEN-1){1'b0}}, nracks }; // Monster state machine // {{{",
            "initial dma_state = DMA_IDLE;",
            "initial o_interrupt = 1'b0;",
            "initial cfg_blocklen_sub_one = {(LGMEMLEN){1'b1}};",
            "initial cfg_on_dev_trigger = 1'b0;",
            "always @(posedge i_clk) if (i_reset) begin // {{{ dma_state <= DMA_IDLE; cfg_on_dev_trigger <= 1'b0; cfg_incs <= 1'b0; cfg_incd <= 1'b0; // }}} end else case(dma_state) DMA_IDLE: begin // {{{ o_mwb_addr <= cfg_raddr; // When the slave wishbone writes, and we are in this // (ready) configuration, then allow the DMA to be controlled // and thus to start. if ((s_stb)&&(s_we)) begin case(s_addr) 2'b00: begin if ((s_data[27:16] == 12'hfed) &&(s_data[31:30] == 2'b00) &&(cfg_len_nonzero)) dma_state <= DMA_WAIT; cfg_blocklen_sub_one <= s_data[(LGMEMLEN-1):0] + {(LGMEMLEN){1'b1}}; // i.e. -1; cfg_dev_trigger <= s_data[14:10]; cfg_on_dev_trigger <= s_data[15]; cfg_incs <= !s_data[29]; cfg_incd <= !s_data[28]; end 2'b01: begin end // This is done elsewhere 2'b10: cfg_raddr <= s_data[$clog2(BUS_WIDTH/8) +: AW]; 2'b11: cfg_waddr <= s_data[$clog2(BUS_WIDTH/8) +: AW]; endcase end end // }}} DMA_WAIT: begin // {{{ o_mwb_addr <= cfg_raddr; if (abort) dma_state <= DMA_IDLE; else if (user_halt) dma_state <= DMA_IDLE; else if (trigger) dma_state <= DMA_READ_REQ; end // }}} DMA_READ_REQ: begin // {{{ if (!i_mwb_stall) begin // Number of read acknowledgements needed if ((last_read_request)||(user_halt)) //((nracks == {1'b0, cfg_blocklen_sub_one})||(bus_nracks == cfg_len-1)) // Wishbone interruptus dma_state <= DMA_READ_ACK; if (cfg_incs) o_mwb_addr <= o_mwb_addr + {{(AW-1){1'b0}},1'b1}; end if ((i_mwb_err)||(abort)) dma_state <= DMA_IDLE; else if (i_mwb_ack) begin if (cfg_incs) cfg_raddr <= cfg_raddr + {{(AW-1){1'b0}},1'b1}; if (last_read_ack) dma_state <= DMA_PRE_WRITE; end end // }}} DMA_READ_ACK: begin // {{{ if ((i_mwb_err)||(abort)) dma_state <= DMA_IDLE; else if (i_mwb_ack) begin if (last_read_ack) // (nread+1 == nracks) dma_state <= DMA_PRE_WRITE; if (user_halt) dma_state <= DMA_IDLE; if (cfg_incs) cfg_raddr <= cfg_raddr + {{(AW-1){1'b0}},1'b1}; end end // }}} DMA_PRE_WRITE: begin // {{{ o_mwb_addr <= cfg_waddr; dma_state <= (abort)? DMA_IDLE : DMA_WRITE_REQ; end // }}} DMA_WRITE_REQ: begin // {{{ if (!i_mwb_stall) begin if (last_write_request) // (nwritten == nread-1) // Wishbone interruptus dma_state <= DMA_WRITE_ACK; if (cfg_incd) begin o_mwb_addr <= o_mwb_addr + {{(AW-1){1'b0}},1'b1}; cfg_waddr <= cfg_waddr + {{(AW-1){1'b0}},1'b1}; end end if ((i_mwb_err)||(abort)) dma_state <= DMA_IDLE; else if ((i_mwb_ack)&&(last_write_ack)) dma_state <= (cfg_len <= 1) ? DMA_IDLE: DMA_WAIT; else if (!cfg_len_nonzero) dma_state <= DMA_IDLE; end // }}} DMA_WRITE_ACK: begin // {{{ if ((i_mwb_err)||(abort)) dma_state <= DMA_IDLE; else if ((i_mwb_ack)&&(last_write_ack)) // (nwacks+1 == nwritten) dma_state <= (cfg_len <= 1)? DMA_IDLE: DMA_WAIT; else if (!cfg_len_nonzero) dma_state <= DMA_IDLE; end // }}} default: dma_state <= DMA_IDLE; endcase // }}} // o_interrupt // {{{",
            "initial o_interrupt = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_interrupt <= 1'b0; else o_interrupt <= ((dma_state == DMA_WRITE_ACK)&&(i_mwb_ack) &&(last_write_ack) &&(cfg_len == {{(AW-1){1'b0}},1'b1})) ||((dma_state != DMA_IDLE)&&(i_mwb_err)); // }}} // cfg_len, cfg_len_nonzero // {{{",
            "initial cfg_len = 0;",
            "initial cfg_len_nonzero = 1'b0;",
            "always @(posedge i_clk) if (i_reset) begin cfg_len <= 0; cfg_len_nonzero <= 1'b0; end else if ((dma_state == DMA_IDLE) &&(s_stb)&&(s_we)&&(s_addr == 2'b01)) begin cfg_len <= s_data[(AW-1):0]; cfg_len_nonzero <= (|s_data[(AW-1):0]); end else if ((o_mwb_cyc)&&(o_mwb_we)&&(i_mwb_ack)) begin cfg_len <= cfg_len - 1'b1; cfg_len_nonzero <= (cfg_len > 1); end // }}} // nracks // {{{",
            "initial nracks = 0;",
            "always @(posedge i_clk) if (i_reset) nracks <= 0; else if ((dma_state == DMA_IDLE)||(dma_state == DMA_WAIT)) nracks <= 0; else if ((o_mwb_stb)&&(!o_mwb_we)&&(!i_mwb_stall)) nracks <= nracks + 1'b1; // }}} // nread // {{{",
            "initial nread = 0;",
            "always @(posedge i_clk) if (i_reset) nread <= 0; else if ((dma_state == DMA_IDLE)||(dma_state == DMA_WAIT)) nread <= 0; else if ((!o_mwb_we)&&(i_mwb_ack)) nread <= nread + 1'b1; // }}} // nwritten // {{{",
            "initial nwritten = 0;",
            "always @(posedge i_clk) if (i_reset) nwritten <= 0; else if ((!o_mwb_cyc)||(!o_mwb_we)) nwritten <= 0; else if ((o_mwb_stb)&&(!i_mwb_stall)) nwritten <= nwritten + 1'b1; // }}} // nwacks // {{{",
            "initial nwacks = 0;",
            "always @(posedge i_clk) if (i_reset) nwacks <= 0; else if ((!o_mwb_cyc)||(!o_mwb_we)) nwacks <= 0; else if (i_mwb_ack) nwacks <= nwacks + 1'b1; // }}} // cfg_err // {{{",
            "initial cfg_err = 1'b0;",
            "always @(posedge i_clk) if (i_reset) cfg_err <= 1'b0; else if (dma_state == DMA_IDLE) begin if ((s_stb)&&(s_we)&&(s_addr==2'b00)) cfg_err <= 1'b0; end else if (((i_mwb_err)&&(o_mwb_cyc))||(abort)) cfg_err <= 1'b1; // }}} // last_read_request // {{{",
            "initial last_read_request = 1'b0;",
            "always @(posedge i_clk) if (i_reset) last_read_request <= 1'b0; else if ((dma_state == DMA_WAIT)||(dma_state == DMA_READ_REQ)) begin if ((!i_mwb_stall)&&(dma_state == DMA_READ_REQ)) begin last_read_request <= (nracks + 1 == { 1'b0, cfg_blocklen_sub_one}) ||(bus_nracks == cfg_len-2); end else last_read_request <= (nracks== { 1'b0, cfg_blocklen_sub_one}) ||(bus_nracks == cfg_len-1); end else last_read_request <= 1'b0; // }}}",
            "assign next_nread = nread + 1'b1; // last_read_ack // {{{",
            "initial last_read_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) last_read_ack <= 0; else if (dma_state == DMA_READ_REQ) begin if ((i_mwb_ack)&&((!o_mwb_stb)||(i_mwb_stall))) last_read_ack <= (next_nread == { 1'b0, cfg_blocklen_sub_one }); else last_read_ack <= (nread == { 1'b0, cfg_blocklen_sub_one }); end else if (dma_state == DMA_READ_ACK) begin if ((i_mwb_ack)&&((!o_mwb_stb)||(i_mwb_stall))) last_read_ack <= (nread+2 == nracks); else last_read_ack <= (next_nread == nracks); end else last_read_ack <= 1'b0; // }}} // last_write_request // {{{",
            "initial last_write_request = 1'b0;",
            "always @(posedge i_clk) if (i_reset) last_write_request <= 1'b0; else if (dma_state == DMA_PRE_WRITE) last_write_request <= (nread <= 1); else if (dma_state == DMA_WRITE_REQ) begin if (i_mwb_stall) last_write_request <= (nwritten >= nread-1); else last_write_request <= (nwritten >= nread-2); end else last_write_request <= 1'b0; // }}} // last_write_ack // {{{",
            "initial last_write_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) last_write_ack <= 1'b0; else if((dma_state == DMA_WRITE_REQ)||(dma_state == DMA_WRITE_ACK)) begin if ((i_mwb_ack)&&((!o_mwb_stb)||(i_mwb_stall))) last_write_ack <= (nwacks+2 == nwritten); else last_write_ack <= (nwacks+1 == nwritten); end else last_write_ack <= 1'b0; // }}}",
            "assign o_mwb_cyc = (dma_state == DMA_READ_REQ) ||(dma_state == DMA_READ_ACK) ||(dma_state == DMA_WRITE_REQ) ||(dma_state == DMA_WRITE_ACK);",
            "assign o_mwb_stb = (dma_state == DMA_READ_REQ) ||(dma_state == DMA_WRITE_REQ);",
            "assign o_mwb_we = (dma_state == DMA_PRE_WRITE) ||(dma_state == DMA_WRITE_REQ) ||(dma_state == DMA_WRITE_ACK); // rdaddr // {{{ // This is tricky. In order for Vivado to consider dma_mem to be a // proper memory, it must have a simple address fed into it. Hence // the read_address (rdaddr)",
            "reg ister. The problem is that this // reg ister must",
            "always be one greater than the address we actually // want to read from, unless we are idling. So ... the math is touchy. // initial rdaddr = 0;",
            "always @(posedge i_clk) if (i_reset) rdaddr <= 0; else if((dma_state == DMA_IDLE)||(dma_state == DMA_WAIT) ||(dma_state == DMA_WRITE_ACK)) rdaddr <= 0; else if ((dma_state == DMA_PRE_WRITE) ||((dma_state == DMA_WRITE_REQ)&&(!i_mwb_stall))) rdaddr <= rdaddr + {{(LGMEMLEN-1){1'b0}},1'b1}; // }}} // o_mwb_data // {{{",
            "always @(posedge i_clk) // if (i_reset) // o_mwb_data <= 0; // else if ((dma_state != DMA_WRITE_REQ)||(!i_mwb_stall)) o_mwb_data <= dma_mem[rdaddr];",
            "always @(posedge i_clk) if((dma_state == DMA_READ_REQ)||(dma_state == DMA_READ_ACK)) dma_mem[nread[(LGMEMLEN-1):0]] <= i_mwb_data; // }}} // o_swb_data // {{{",
            "always @(posedge i_clk) if (i_reset) o_swb_data <= 0; else casez(s_addr) 2'b00: o_swb_data <= { (dma_state != DMA_IDLE), cfg_err, !cfg_incs, !cfg_incd, 1'b0, nread, cfg_on_dev_trigger, cfg_dev_trigger, cfg_blocklen_sub_one }; 2'b01: o_swb_data <= { {(SLV_WIDTH-AW){1'b0}}, cfg_len }; 2'b10: o_swb_data <= { {(SLV_WIDTH-$clog2(BUS_WIDTH/8)-AW){1'b0}}, cfg_raddr, {($clog2(BUS_WIDTH/8)){1'b0}} }; 2'b11: o_swb_data <= { {(SLV_WIDTH-$clog2(BUS_WIDTH/8)-AW){1'b0}}, cfg_waddr, {($clog2(BUS_WIDTH/8)){1'b0}} }; endcase // }}} // trigger // {{{ // This causes us to wait a minimum of two clocks before starting: One // to go into the wait state, and then one while in the wait state to // develop the trigger.",
            "initial trigger = 1'b0;",
            "always @(posedge i_clk) if (i_reset) trigger <= 1'b0; else trigger <= (dma_state == DMA_WAIT) &&((!cfg_on_dev_trigger) ||(i_dev_ints[cfg_dev_trigger])); // }}} // o_swb_ack // {{{ // Ack any access. We'll quietly ignore any access where we are busy, // but ack it anyway. In other words, before writing to the device, // double check that it isn't busy, and then write.",
            "initial o_swb_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_swb_ack <= 1'b0; else if (!i_swb_cyc) o_swb_ack <= 1'b0; else o_swb_ack <= (s_stb); // }}}",
            "assign o_swb_stall = 1'b0; // abort // {{{",
            "initial abort = 1'b0;",
            "always @(posedge i_clk) if (i_reset) abort <= 1'b0; else if (dma_state == DMA_IDLE) abort <= 1'b0; else abort <= ((s_stb)&&(s_we) &&(s_addr == 2'b00) &&(s_data == 32'hffed0000)); // }}} // user_halt // {{{",
            "initial user_halt = 1'b0;",
            "always @(posedge i_clk) if (i_reset) user_halt <= 1'b0; else user_halt <= ((user_halt)&&(dma_state != DMA_IDLE)) ||((s_stb)&&(s_we)&&(dma_state != DMA_IDLE) &&(s_addr == 2'b00) &&(s_data == 32'hafed0000)); // }}} // Make verilator happy // {{{ // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = s_cyc; // verilator lint_on UNUSED // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "reg f_past_valid;",
            "wire [LGMEMLEN:0] f_npending;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "always @(*) if (!f_past_valid) assume(i_reset);",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) assert(dma_state == DMA_IDLE); //////////////////////////////////////////////////////////////////////// // // Bus properties // {{{ //////////////////////////////////////////////////////////////////////// // // parameter F_SLV_LGDEPTH = 3;",
            "parameter F_MSTR_LGDEPTH = LGMEMLEN+1;",
            "wire [F_SLV_LGDEPTH-1:0] f_swb_nreqs, f_swb_nacks, f_swb_outstanding;",
            "wire [F_MSTR_LGDEPTH-1:0] f_mwb_nreqs, f_mwb_nacks, f_mwb_outstanding; fwb_slave #( // {{{ .AW(2), .DW(SLV_WIDTH), .F_MAX_STALL(0), .F_MAX_ACK_DELAY(2), .F_LGDEPTH(F_SLV_LGDEPTH) // }}} ) control_port( // {{{ i_clk, i_reset, i_swb_cyc, i_swb_stb, i_swb_we, i_swb_addr, i_swb_data,4'b1111, o_swb_ack, o_swb_stall, o_swb_data, 1'b0, f_swb_nreqs, f_swb_nacks, f_swb_outstanding // }}} );",
            "always @(*) assert(o_swb_stall == 0); generate if (OPT_DELAY_BUS_ACCESS) begin : F_DELAY_BUS // {{{",
            "always @(*) if ((!i_reset)&&(i_swb_cyc)) begin if ((!s_stb)&&(!o_swb_ack)) begin assert(f_swb_outstanding == 0); end else if ((s_stb)&&(!o_swb_ack)) begin assert(f_swb_outstanding == 1); end else if ((!s_stb)&&(o_swb_ack)) begin assert(f_swb_outstanding == 1); end else if ((s_stb)&&(o_swb_ack)) assert(f_swb_outstanding == 2); end // }}} end else begin // {{{",
            "always @(*) if (!i_reset) assert(f_swb_outstanding == (o_swb_ack ? 1:0)); // }}} end endgenerate fwb_master #( // {{{ .AW(AW), .DW(BUS_WIDTH), .F_MAX_STALL(4), .F_MAX_ACK_DELAY(8), .F_LGDEPTH(F_MSTR_LGDEPTH), .F_OPT_RMW_BUS_OPTION(1'b1), .F_OPT_DISCONTINUOUS(1'b0), .F_OPT_SOURCE(1'b1) // }}} ) external_bus( // {{{ i_clk, i_reset, o_mwb_cyc, o_mwb_stb, o_mwb_we, o_mwb_addr, o_mwb_data, {(BUS_WIDTH/8){1'b1}}, i_mwb_ack, i_mwb_stall, i_mwb_data, i_mwb_err, f_mwb_nreqs, f_mwb_nacks, f_mwb_outstanding // }}} );",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(dma_state == DMA_IDLE))) assert(o_mwb_cyc == 1'b0);",
            "always @(*) if ((o_mwb_cyc)&&(!o_mwb_we)) begin assert(nracks == f_mwb_nreqs); assert(nread == f_mwb_nacks); end",
            "always @(*) if ((o_mwb_cyc)&&(o_mwb_we)) begin assert(nwacks == f_mwb_nacks); assert(nwritten == f_mwb_nreqs); end // }}}",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(abort))&&($past(dma_state != DMA_IDLE))) assert(dma_state == DMA_IDLE);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_mwb_cyc))&&(o_mwb_cyc)&&( (( !cfg_incs)&&(!o_mwb_we)) ||((!cfg_incd)&&( o_mwb_we)))) begin assert(o_mwb_addr == $past(o_mwb_addr)); end",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_mwb_cyc))&&( ((!cfg_incs)||($past(o_mwb_we))||(!$past(i_mwb_ack))))) assert(cfg_raddr == $past(cfg_raddr));",
            "always @(posedge i_clk) if ((f_past_valid)&&(dma_state == DMA_WRITE_REQ)) assert(cfg_waddr == o_mwb_addr);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&($past(o_mwb_stb))&&(!$past(i_mwb_stall))) begin assert( ((!cfg_incs)&&(!$past(o_mwb_we))) ||((!cfg_incd)&&( $past(o_mwb_we))) ||(o_mwb_addr==$past(o_mwb_addr)+1'b1)); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(o_mwb_cyc))&&(o_mwb_cyc)) begin if (o_mwb_we) begin assert(o_mwb_addr == cfg_waddr); end else assert(o_mwb_addr == cfg_raddr); end",
            "always @(*) assert(cfg_len_nonzero == (cfg_len != 0));",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_reset))) begin assert(cfg_len == 0); assert(!cfg_len_nonzero); end else if ((f_past_valid)&&($past(o_mwb_cyc))) begin if (($past(i_mwb_ack))&&($past(o_mwb_we))) begin assert(cfg_len == $past(cfg_len)-1'b1); end else assert(cfg_len == $past(cfg_len)); end else if ((f_past_valid)&&(($past(dma_state) != DMA_IDLE) ||(!$past(s_stb))||(!$past(s_we)) ||($past(s_addr)!=2'b01))) assert(cfg_len == $past(cfg_len));",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_mwb_cyc))&&($past(cfg_len == 0)) &&(!$past(user_halt))) begin assert(cfg_len == 0); assert((dma_state != $past(dma_state))||(!o_mwb_cyc)); end",
            "always @(posedge i_clk) if (cfg_len == 0) assert(!o_mwb_stb);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(dma_state) != DMA_IDLE)) begin assert(cfg_incs == $past(cfg_incs)); assert(cfg_incd == $past(cfg_incd)); assert(cfg_blocklen_sub_one == $past(cfg_blocklen_sub_one)); end",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(dma_state) == DMA_IDLE)) assert(cfg_len_nonzero == (cfg_len != 0));",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(o_mwb_cyc))||(!$past(o_mwb_we))) assert((nwritten == 0)&&(nwacks == 0));",
            "always @(posedge i_clk) if ((o_mwb_cyc)&&(!o_mwb_we)) assert(bus_nracks <= cfg_len);",
            "always @(posedge i_clk) if ((o_mwb_cyc)&&(!o_mwb_we)) assert(nread <= nracks);",
            "always @(posedge i_clk) if ((o_mwb_cyc)&&(o_mwb_we)) assert(nwritten-nwacks +((o_mwb_stb)? 1'b1:1'b0) - f_mwb_outstanding // -((i_mwb_ack)? 1'b1:1'b0) <= cfg_len);",
            "always @(*) assert(f_mwb_outstanding + ((o_mwb_stb)? 1'b1:1'b0) <= cfg_len);",
            "wire [LGMEMLEN:0] f_cfg_blocklen;",
            "assign f_cfg_blocklen = { 1'b0, cfg_blocklen_sub_one} + 1'b1;",
            "always @(*) if (dma_state == DMA_WAIT) assert(cfg_len > 0);",
            "always @(*) if ((o_mwb_stb)&&(o_mwb_we)) assert(nread == nracks);",
            "always @(*) if (o_mwb_stb) assert(nwritten <= cfg_blocklen_sub_one);",
            "always @(posedge i_clk) assert(nwritten <= f_cfg_blocklen);",
            "always @(*) if ((o_mwb_stb)&&(!o_mwb_we)) begin assert(nracks < f_cfg_blocklen); end else assert(nracks <= f_cfg_blocklen);",
            "always @(*) if ((o_mwb_cyc)&&(i_mwb_ack)&&(!o_mwb_we)) assert(nread < f_cfg_blocklen);",
            "always @(*) assert(nread <= nracks);",
            "always @(*) if ((o_mwb_cyc)&&(o_mwb_we)&&(!user_halt)) assert(nread == nracks);",
            "always @(*) if ((o_mwb_cyc)&&(o_mwb_we)) assert(nwritten >= nwacks);",
            "always @(*) if (dma_state == DMA_WRITE_REQ) assert(last_write_request == (nwritten == nread-1));",
            "always @(*) assert(nwritten >= nwacks);",
            "always @(*) assert(nread >= nwritten);",
            "always @(*) assert(nracks >= nread);",
            "assign f_npending = nread-nwacks;",
            "always @(*) if (dma_state != DMA_IDLE) assert({ {(AW-LGMEMLEN-1){1'b0}}, f_npending} <= cfg_len);",
            "always @(posedge i_clk) begin assert(cfg_len_nonzero == (cfg_len != 0)); if ((f_past_valid)&&($past(dma_state != DMA_IDLE))&&($past(cfg_len == 0))) assert(cfg_len == 0); end `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "ziptimer.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/ziptimer.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: ziptimer.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A lighter weight implementation of the Zip Timer. // // Interface: // Two options: // 1. One combined",
            "reg ister for both control and value, and ... // The reload value is set any time the timer data value is \"set\". // Reading the",
            "reg ister returns the timer value. Controls are // set so that writing a value to the timer automatically starts // it counting down. // 2. Two",
            "reg isters, one for control one for value. // The control",
            "reg ister would have the reload value in it. // On the clock when the interface is set to zero the interrupt is set. // Hence setting the timer to zero will disable the timer without // setting any interrupts. Thus setting it to five will count // 5 clocks: 5, 4, 3, 2, 1, Interrupt. // // // Control bits: // (Start_n/Stop. This bit has been dropped. Writing to this // timer any value but zero starts it. Writing a zero // clears and stops it.) // AutoReload. If set, then on reset the timer automatically // loads the last set value and starts over. This is // useful for distinguishing between a one-time interrupt // timer, and a repetitive interval timer. // (INTEN. Interrupt enable--reaching zero",
            "always creates an // interrupt, so this control bit isn't needed. The // interrupt controller can be used to mask the interrupt.) // (COUNT-DOWN/UP: This timer is *only* a count-down timer. // There is no means of setting it to count up.) // WatchDog // This timer can be implemented as a watchdog timer simply by // connecting the interrupt line to the reset line of the CPU. // When the timer then expires, it will trigger a CPU reset. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module ziptimer #( // {{{",
            "parameter BW = 32, VW = (BW-1), parameter [0:0] RELOADABLE = 1 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, i_ce, // Wishbone",
            "input s",
            "input wire i_wb_cyc, i_wb_stb, i_wb_we, input wire [BW-1:0] i_wb_data, input wire [BW/8-1:0] i_wb_sel, // Wishbone",
            "output s",
            "output wire o_wb_stall, output reg o_wb_ack, output wire [BW-1:0] o_wb_data, // Interrupt line",
            "output reg o_int // }}} ); // Local declarations // {{{",
            "reg r_running;",
            "reg r_zero = 1'b1;",
            "reg [(VW-1):0] r_value;",
            "wire wb_write;",
            "wire auto_reload;",
            "wire [(VW-1):0] interval_count; // }}}",
            "assign wb_write = ((i_wb_stb)&&(i_wb_we)); // r_running // {{{",
            "initial r_running = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_running <= 1'b0; else if (wb_write) r_running <= (|i_wb_data[(VW-1):0]); else if ((r_zero)&&(!auto_reload)) r_running <= 1'b0; // }}} // r_auto_reload, r_interval_count // {{{ generate if (RELOADABLE != 0) begin : GEN_RELOAD // {{{",
            "reg r_auto_reload;",
            "reg [(VW-1):0] r_interval_count; // r_auto_reload // {{{",
            "initial r_auto_reload = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_auto_reload <= 1'b0; else if (wb_write) r_auto_reload <= (i_wb_data[(BW-1)]) &&(|i_wb_data[(VW-1):0]); // }}}",
            "assign auto_reload = r_auto_reload; // r_interval_count // {{{ // If setting auto-reload mode, and the value to other // than zero, set the auto-reload value",
            "always @(posedge i_clk) if (i_reset) r_interval_count <= 0; else if (wb_write) r_interval_count <= i_wb_data[(VW-1):0]; // }}}",
            "assign interval_count = r_interval_count; // }}} end else begin : NO_AUTO_RELOAD // {{{",
            "assign auto_reload = 1'b0;",
            "assign interval_count = 0; // }}} end endgenerate // }}} // r_value // {{{",
            "initial r_value = 0;",
            "always @(posedge i_clk) if (i_reset) r_value <= 0; else if (wb_write) r_value <= i_wb_data[(VW-1):0]; else if ((i_ce)&&(r_running)) begin if (!r_zero) r_value <= r_value - 1'b1; else if (auto_reload) r_value <= interval_count; end // }}} // r_zero // {{{",
            "always @(posedge i_clk) if (i_reset) r_zero <= 1'b1; else if (wb_write) r_zero <= (i_wb_data[(VW-1):0] == 0); else if ((r_running)&&(i_ce)) begin if (r_value == { {(VW-1){1'b0}}, 1'b1 }) r_zero <= 1'b1; else if ((r_zero)&&(auto_reload)) r_zero <= 1'b0; end // }}} // o_int // {{{ // Set the interrupt on our last tick, as we transition from one to // zero.",
            "initial o_int = 1'b0;",
            "always @(posedge i_clk) if ((i_reset)||(wb_write)||(!i_ce)) o_int <= 1'b0; else // if (i_ce) o_int <= (r_value == { {(VW-1){1'b0}}, 1'b1 }); // }}} // o_wb_ack // {{{",
            "initial o_wb_ack = 1'b0;",
            "always @(posedge i_clk) o_wb_ack <= (!i_reset)&&(i_wb_stb); // }}}",
            "assign o_wb_stall = 1'b0; // o_wb_data // {{{ generate if (VW < BW-1) begin : GEN_TRIM",
            "assign o_wb_data = { auto_reload, {(BW-1-VW){1'b0}}, r_value }; end else begin : NO_TRIM",
            "assign o_wb_data = { auto_reload, r_value }; end endgenerate // }}} // Make verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_wb_cyc, i_wb_data, i_wb_sel }; // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "initial assume(i_reset);",
            "always @(*) if (!f_past_valid) assume(i_reset);",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) begin assert(r_value == 0); assert(r_running == 0); assert(auto_reload == 0); assert(r_zero == 1'b1); end",
            "always @(*) if (i_wb_stb) assume(i_wb_cyc);",
            "always @(*) assert(r_zero == (r_value == 0));",
            "always @(*) if (r_value != 0) assert(r_running);",
            "always @(*) if (auto_reload) assert(r_running);",
            "always @(*) if (!RELOADABLE) assert(auto_reload == 0);",
            "always @(*) if (auto_reload) assert(interval_count != 0);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(r_value)==0) &&(!$past(wb_write))&&(!$past(auto_reload))) assert(r_value == 0);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&(!$past(wb_write)) &&($past(r_value)==0)&&($past(auto_reload))) begin if ($past(i_ce)) begin assert(r_value == interval_count); end else assert(r_value == $past(r_value)); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&(!$past(wb_write))&&($past(r_value)!=0)) begin if ($past(i_ce)) begin assert(r_value == $past(r_value)-1'b1); end else assert(r_value == $past(r_value)); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(wb_write))) assert(r_value == $past(i_wb_data[(VW-1):0])); // Check auto_reload // {{{",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset) || !RELOADABLE) begin assert(!auto_reload); end else if ($past(wb_write)) begin if (!$past(i_wb_data[BW-1])) begin assert(!auto_reload); end else assert(auto_reload == $past(|i_wb_data[VW-1:0])); end else assert($stable(auto_reload)); // }}}",
            "always @(posedge i_clk) if (!(f_past_valid)||($past(i_reset))) begin assert(!o_int); end else if (($past(wb_write))||(!$past(i_ce))) begin assert(!o_int); end else assert(o_int == ((r_running)&&(r_value == 0)));",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) begin assert(!o_wb_ack); end else if ($past(i_wb_stb)) assert(o_wb_ack);",
            "always @(*) assert(!o_wb_stall);",
            "always @(*) assert(o_wb_data[BW-1] == auto_reload);",
            "always @(*) assert(o_wb_data[VW-1:0] == r_value); `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipjiffies.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/zipjiffies.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipjiffies.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This peripheral is motivated by the Linux use of 'jiffies'. // A process, in Linux, can request to be put to sleep until a certain // number of 'jiffies' have elapsed. Using this interface, the CPU can // read the number of 'jiffies' from this peripheral (it only has the // one location in address space), add the sleep length to it, and // write the result back to the peripheral. The zipjiffies peripheral // will record the value written to it only if it is nearer the current // counter value than the last current waiting interrupt time. If no // other interrupts are waiting, and this time is in the future, it will // be enabled. (There is currrently no way to disable a jiffie interrupt // once set.) The processor may then place this sleep request into a // list among other sleep requests. Once the timer expires, it would // write the next jiffy request to the peripheral and wake up the process // whose timer had expired. // // Quite elementary, really. // // Interface: // This peripheral contains one",
            "reg ister: a counter. Reads from the // reg ister return the current value of the counter. Writes within // the (N-1) bit space following the current time set an interrupt. // Writes of values that occurred in the last 2^(N-1) ticks will be // ignored. The timer then interrupts when its value equals that time. // Multiple writes cause the jiffies timer to select the nearest possible // interrupt. Upon an interrupt, the next interrupt time/value is cleared // and will need to be reset if the CPU wants to get notified again. With // only the single interface, there is no way of knowing when the next // interrupt is scheduled for, neither is there any way to slow down the // interrupt timer in case you don't want it overflowing as often and you // wish to wait more jiffies than it supports. Thus, currently, if you // have a timer you wish to wait upon that is more than 2^31 into the // future, you would need to set timers along the way, wake up on those // timers, and set further timer's until you finally get to your // destination. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipjiffies #(",
            "parameter BW = 32 ) ( // {{{",
            "input wire i_clk, i_reset, i_ce, // Wishbone",
            "input s",
            "input wire i_wb_cyc, i_wb_stb, i_wb_we, input wire [(BW-1):0] i_wb_data, input wire [BW/8-1:0] i_wb_sel, // Wishbone",
            "output s",
            "output wire o_wb_stall, output reg o_wb_ack, output wire [(BW-1):0] o_wb_data, // Interrupt line",
            "output reg o_int // }}} ); // Local declarations // {{{",
            "reg [(BW-1):0] r_counter; // reg int_set, new_set, int_now;",
            "reg [(BW-1):0] int_when, new_when;",
            "reg signed [(BW-1):0] till_wb, till_when; // }}} // r_counter // {{{ // Our counter",
            "logic : The counter is",
            "always counting up--it cannot // be stopped or altered. It's really quite simple. Okay, not quite. // We still support the clock enable line. We do this in order to // support debugging, so that if we get everything running inside a // debugger, the timer's all slow down so that everything can be stepped // together, one clock at a time. // initial r_counter = 0;",
            "always @(posedge i_clk) if (i_reset) r_counter <= 0; else if (i_ce) r_counter <= r_counter+1; // }}} // int_now // {{{",
            "initial int_now = 0;",
            "always @(posedge i_clk) if (i_reset) int_now <= 0; else if (i_ce) int_now <= ((r_counter + 1) == (int_when)); else int_now <= 1'b0; // }}} // new_set, new_when // {{{ // Writes to the counter set an interrupt--but only if they are in the // future as determined by the signed result of an unsigned subtract. // // assign till_when = int_when-r_counter; // assign till_wb = new_when-r_counter;",
            "initial new_set = 1'b0;",
            "always @(posedge i_clk) begin // Delay WB commands (writes) by a clock to simplify our",
            "logic new_set <= (i_wb_stb && i_wb_we); // new_when is a don't care when new_set = 0, so don't worry // about setting it at all times. new_when<= i_wb_data; till_wb <= (i_wb_data - r_counter - (i_ce ? 1:0)); till_when <= (int_when - i_wb_data); if (i_reset) new_set <= 1'b0; end // }}} // o_int, int_set // {{{",
            "initial o_int = 1'b0;",
            "initial int_set = 1'b0;",
            "always @(posedge i_clk) if (i_reset) begin // {{{ o_int <= 0; int_set <= 0; // }}} end else begin // {{{ o_int <= 1'b0; if ((i_ce)&&(int_set)&&(r_counter == int_when)) // Interrupts are self-clearing o_int <= 1'b1; // Set the interrupt flag for one clock else if ((new_set)&&(till_wb <= 0)) o_int <= 1'b1; if ((new_set)&&(till_wb > 0)) int_set <= 1'b1; else if (int_now) int_set <= 1'b0; // }}} end // }}} // int_when // {{{",
            "always @(posedge i_clk) if ((new_set)&&(till_wb > 0)&&((till_when[BW-1])||(!int_set))) int_when <= new_when; // }}} // o_wb_ack // {{{ // Acknowledge any wishbone accesses -- everything we did took only // one clock anyway. // initial o_wb_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_wb_ack <= 1'b0; else o_wb_ack <= i_wb_stb; // }}}",
            "assign o_wb_data = r_counter;",
            "assign o_wb_stall = 1'b0; // Make verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_wb_cyc, i_wb_sel }; // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; //////////////////////////////////////////////////////////////////////// // // Assumptions about our",
            "input s // {{{ //////////////////////////////////////////////////////////////////////// // // // One basic WB assumtion // Anytime the stb is high, the cycle line must also be high",
            "always @(posedge i_clk) assume((!i_wb_stb)||(i_wb_cyc)); // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about our bus",
            "output s // {{{ //////////////////////////////////////////////////////////////////////// // // // We never stall the bus",
            "always @(*) assert(!o_wb_stall); // We",
            "always ack every transaction on the following clock",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_stb))) begin assert(o_wb_ack); end else assert(!o_wb_ack); // }}} /////////////////////////////////////////////////////////////////////// // // Assumptions about our internal state and our",
            "output s // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if ((f_past_valid)&&($past(i_reset))) begin assert(!o_wb_ack); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_stb)) &&($past(i_wb_we))) assert(new_when == $past(i_wb_data));",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_stb)) &&($past(i_wb_we))) begin assert(new_set); end else assert(!new_set); // // // always @(posedge i_clk) if ((f_past_valid)&&($past(i_reset))) assert(!o_int);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_reset))) begin assert(!int_set); assert(!new_set); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(new_set)) &&(!$past(till_wb[BW-1])) &&($past(till_wb) > 0)) assert(int_set);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_ce)) &&($past(r_counter)==$past(int_when))) begin assert((o_int)||(!$past(int_set))); // assert((!int_set)||($past(new_set))); // !!!!! end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&(!$past(new_set))&&(!$past(int_set))) assert(!int_set);",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) begin assert(!o_int); end else if (($past(new_set))&&($past(till_wb) < 0)) assert(o_int);",
            "always @(posedge i_clk) if ((f_past_valid)&& ((!$past(new_set)) ||($past(till_wb[BW-1])) ||($past(till_wb == 0)))) assert(int_when == $past(int_when)); // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "zipmmu.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/zipmmu.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipmmu.v // {{{ // Project: Zip CPU backend for the GNU Compiler Collection // // Purpose: To provide a \"bump-in-the-line\" wishbone memory management // unit, that is configured from one wishbone bus and modifies a // separate wishbone bus. Both busses will not be active at the same time. // // The idea is that the CPU can use one portion of its peripheral // system memory space to configure the MMU, and another portion of its // memory space to access the MMU. Even more, configuring the MMU is to // be done when the CPU is in supervisor mode. This means that all // high-memory, system-peripheral accesses will be enabled *only* when // the CPU is in supervisor mode. // // There is a very specific reason for this design choice: by designing // the MMU in this fashion, the MMU may then be inluded (or not) at the // discretion of the individual assembling the ZipSystem (or equivalent) // module . // // Design Goals: // // Since we're trying to design this for disadvantaged, limited CPUs, // we should be able to offer such CPUs only as much MMU as they want. // Therefore, it should be possible to scale the MMU up and/or down in // LUT space. // // Memory space: // 1. On access via the memory bus, the MMU should provide for a speed // going through it such that any access is delayed by only one // clock cycle. Further, multiple accesses to the same page // should not take any longer than the one cycle delay. Accesses // to other pages should take a minimum number of clocks. // Accesses from one page to the next, such as from one page to // the next subsequent one, should cost no delays. // // 2. One independent control word to set the current context // // - When context = 0, virtual page = physical page, page table is an // unused pass through. // - When context != 0, MMU translation is active anytime the GIE is // set. Pages must match context, as well as virtual address. // // - Contains 4 RdOnly bits indicating the log address size for the // machine, offset by 17. Thus, the build will have an address // bus of width (lgpage+17), or a memory space of (2^(lgpage+17)). // Under this formula, the number of valid address bits can range // from 17 to 32. // - Contains 4 RdOnly bits indicating log_2 TLB table size. // Size is given by (2^(lgsize)). I'm considering sizes of 6,7&8 // - Contains 4 RdOnly bits indicating the log page size, offset by // eight. Page sizes are therefore given by (2^(lgpage+8)), and // the smallest page size is 256 words. // - Contains 4 RdOnly bits indicating the log context size, offset by 1. // The number of bits in the context word therefore run from 1 to // (lgcontext+1)-1, supporting between (2^1)-1=3 and // (2^16)-1 = 65535 contexts. (The zero context is not being // counted here, as it is special.) // // +------+------+------+------+--------------------+ // | | | | | | // | 4b | 4b | 4b | 4b | 16-bit | // | LGADR| LGTBL|LGPGSZ|LGCTXT| Context word | // | | | | | | // +------+------+------+------+--------------------+ // // Supervisor *cannot* have page table entries, since there are no // interrupts (page faults) allowed in supervisor context. // // To be valid, // Context Size (1..16), NFlags ( 4) < Page Size (8-23 bits) // Page size (8-23 bits) > NFlags bits (4) // // Small page sizes, then, mean fewer contexts are possible // // 3. One status word, which contains the address that failed and some // flags: // // Top Virtual address bits indicate which page ... caused a problem. // These will be the top N bits of the word, where N is the size // of the virtual address bits. (Bits are cleared upon any write.) // // Flags: (Up to 12 bits, all zeros means no fault. Bits are cleared upon // write) // - 4: Multiple page table matches // - 2: Attempt to write a read-only page // - 1: Page not found // // 3. Two words per active page table entry, accessed through two bus // addresses. This word contains: // // 16-bits Page context // 20-bits Virtual address // 20-bits Physical address // A physical address of all ones means that the // page does not exist, and any attempt to access // the virtual address associated with this page // should fault. // // Flags: // 1-bit Read-only / ~written (user set/read/written) // If set, this page will cause a fault on any // attempt to write this memory. // 1-bit This page may be executed // 1-bit Cacheable // This is not a hardware page, but a memory page. // Therefore, the values within this page may be // cached. // 1-bit Accessed // This an be used to implement a least-recently // used measure. The hardware will set this value // when the page is accessed. The user can also // set or clear this at will. // // (Loaded flag Not necessary, just map the physical page to 0) // // We could equivalently do a 16-bit V&P addresses, for a 28-bit total // address space, if we didn't want to support the entire 32-bit space. // // // 4. Can read/write this word in two parts: // // (20-bit Virtual )(8-bits lower context)(4-bit flags), and // (20-bit Physical)(8-bits upper context)(4-bit flags) // // Actual bit lengths will vary as the MMU configuration changes, // however the flags will",
            "always be the low order four bits, // and the virtual/physical address flags will",
            "always consume // 32 bits minus the page table size. The context bits will // always be split into upper and lower context bits. If there // are more context bits than can fit in the space, then the // upper bits of the context field will be filled with zeros. // // On any write, the context bits will be set from the context // bits in the control",
            "reg ister. // // +----+----+-----+----+----+----+----+--+--+--+--+ // | | Lower 8b| R| E| C| A| // | 20-bit Virtual page ID | Context | O| X| C| C| // |(top 20 bits of the addr)| ID | n| E| H| C| // | | | W| F| E| S| // +----+----+-----+----+----+----+----+--+--+--+--+ // // +----+----+-----+----+----+----+----+--+--+--+--+ // | | Upper 8b| R| A| C| T| // | 20-bit Physical pg ID | Context | O| C| C| H| // |(top 20 bits of the | ID | n| C| H| S| // | physical address) | | W| S| E| P| // +----+----+-----+----+----+----+----+--+--+--+--+ // // 5. PF Cache--handles words in both physical and virtual // - On any pf-read, the MMU returns the current pagetable/TBL mapping // This consists of [Context,Va,Pa]. // - The PF cache stores this with the address tag. (If the PF is reading, // the VP should match, only the physical page ID needs to be // sored ...) // - At the end of any cache line read, the page table/TBL mapping address // will have long been available, the \"Valid\" bit will be turned // on and associated with the physical mapping. // - On any data-write (pf doesn't write), MMU sends [Context,Va,Pa] // TLB mapping to the pf-cache. // - If the write matches any physical PF-cache addresses (???), the // pfcache declares that address line invalid, and just plain // clears the valid bit for that page. // // Since the cache lines sizes are smaller than the page table sizes, // failure to match the address means ... what? // // // 6. Normal operation and timing: // - One clock lost if still on the same page as last time, or in the // supervisor (physical pages only) context ... // - Two clocks (1-more delay) if opening a new page. // (1-clock to look up the entry--comparing against all entries, // 1-clock to read it, next clock the access goes forward.) // - No more than two stalls for any access, pipelineable. Thus, once // you've stalled by both clocks, you'll not stall again during // any pipeline operation. // // Status: // At one point, this MMU was partially integrated into the ZipCPU. That // is, it was integrated far enough into the ZipSystem that a test might // have been written, but never into any of the other wrappers. Since // then, the ZipCPU has been refactored so that it can support multiple // bus structures and a",
            "parameter ized bus width. This MMU now needs to // be similarly refactored to match, so that it can integrate into the // ZipCPU *between* the ZipCore and its memory access components--whether // instruction or data memory access. This refactor has not (yet) taken // place, and until it does so this MMU implementation should be // considered ... // // *DEPRECATED*. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2016-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // // License: GPL, v3, as defined and found on www.gnu.org, // http://www.gnu.org/licenses/gpl.html // // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // `define ROFLAG 3 // Read-only flag `define EXEFLG 2 // No-execute flag (invalid for I-cache) `define CHFLAG 1 // Cachable flag `define AXFLAG 0 // Accessed flag // }}}",
            "module zipmmu(i_clk, i_reset, i_wbs_cyc_stb, i_wbs_we, i_wbs_addr, i_wbs_data, o_wbs_stall, o_wbs_ack, o_wbs_data, i_wbm_cyc, i_wbm_stb, i_wbm_we, i_wbm_exe, i_wbm_addr, i_wbm_data, i_wbm_sel, i_gie, o_cyc, o_stb, o_we, o_addr, o_data, o_sel, i_stall, i_ack, i_err, i_data, o_rtn_stall, o_rtn_ack, o_rtn_err, o_rtn_miss, o_rtn_data, pf_return_stb, pf_return_we, pf_return_p, pf_return_v, pf_return_cachable);",
            "parameter // The size of the address bus. Actual addressable // size will likely be 2^(ADDRESS_WIDTH+2) octets ADDRESS_WIDTH=28, // Number of page table entries `ifdef FORMAL LGTBL=4'h2, `else LGTBL=4'h6, `endif // The requested log page size in 8-bit bytes PLGPGSZB=20, // Number of bits describing context `ifdef FORMAL PLGCTXT=2; `else PLGCTXT=16; `endif",
            "parameter [0:0] OPT_DELAY_RETURN = 1'b0;",
            "localparam // And for our derived",
            "parameter s (don't set these ...) // Width of the data bus is 32-bits. This may be hard // to change. DW = 32, // AW is just shorthand for the name ADDRESS_WIDTH AW = ADDRESS_WIDTH, // Page sizes must allow for a minimum of one context // bit per page, plus four flag bits, hence the minimum // number of bits for an address within a page is 5 LGPGSZB=(PLGPGSZB < 5)? 5:PLGPGSZB, // in bytes LGPGSZW=LGPGSZB-2, // in words // The context value for a given page can be split // across both virtual and physical words. It cannot // have so many bits to it that it takes more bits // then are available. LGCTXT=((2*LGPGSZB-4)>PLGCTXT)? PLGCTXT:(2*LGPGSZB-4), // LGLCTX is the number of context bits in the low word LGLCTX=(LGCTXT > (LGPGSZB-4))?(LGPGSZB-4):LGCTXT, // LGHCTX is the number of context bits in the high word LGHCTX= (LGCTXT-LGLCTX>0)?(LGCTXT-LGLCTX):0, VAW=(DW-LGPGSZB), // Virtual address width, in bytes PAW=(AW-LGPGSZW), // Physical address width, in words TBL_BITS = LGTBL, // Bits necessary to addr tbl TBL_SIZE=(1<<TBL_BITS);// Number of table entries",
            "input wire i_clk, i_reset; // input wire i_wbs_cyc_stb;",
            "input wire i_wbs_we;",
            "input wire [(LGTBL+1):0] i_wbs_addr;",
            "input wire [(DW-1):0] i_wbs_data;",
            "output wire o_wbs_stall;",
            "output reg o_wbs_ack;",
            "output reg [(DW-1):0] o_wbs_data; // input wire i_wbm_cyc, i_wbm_stb; // input wire i_wbm_we, i_wbm_exe;",
            "input wire [(DW-2-1):0] i_wbm_addr;",
            "input wire [(DW-1):0] i_wbm_data;",
            "input wire [(DW/8-1):0] i_wbm_sel;",
            "input wire i_gie; // // Here's where we drive the slave side of the bus",
            "output reg o_cyc;",
            "output wire o_stb, o_we;",
            "output reg [(AW-1):0] o_addr;",
            "output reg [(DW-1):0] o_data;",
            "output reg [(DW/8-1):0] o_sel; // and get our return information from driving the slave ...",
            "input wire i_stall, i_ack, i_err;",
            "input wire [(DW-1):0] i_data; // // Here's where we return information on either our slave/control bus // or the memory bus we are controlled from. Note that we share these // wire s ...",
            "output wire o_rtn_stall;",
            "output wire o_rtn_ack;",
            "output wire o_rtn_err, o_rtn_miss;",
            "output wire [(DW-1):0] o_rtn_data; // Finally, to allow the prefetch to snoop on the MMU conversion ...",
            "output wire pf_return_stb, // snoop data is valid pf_return_we; // snoop data is chnging",
            "output wire [(PAW-1):0] pf_return_p;",
            "output wire [(VAW-1):0] pf_return_v;",
            "output wire pf_return_cachable; // // // // // reg [3:0] tlb_flags [0:(TBL_SIZE-1)];",
            "wire [3:0] s_tlb_flags;",
            "reg [(LGCTXT-1):0] tlb_cdata [0:(TBL_SIZE-1)];",
            "reg [(VAW-1):0] tlb_vdata [0:(TBL_SIZE-1)];",
            "reg [(PAW-1):0] tlb_pdata [0:(TBL_SIZE-1)];",
            "reg [(TBL_SIZE-1):0] tlb_valid, tlb_accessed;",
            "wire adr_control, adr_vtable, adr_ptable;",
            "wire wr_control, wr_vtable, wr_ptable;",
            "wire [(LGTBL-1):0] wr_tlb_addr;",
            "assign wr_tlb_addr= i_wbs_addr[(LGTBL):1]; // Leave bottom for V/P",
            "assign adr_control= (i_wbs_cyc_stb)&&(~i_wbs_addr[(LGTBL+1)])&&(~i_wbs_addr[0]);",
            "assign adr_vtable = (i_wbs_cyc_stb)&&( i_wbs_addr[(LGTBL+1)])&&(~i_wbs_addr[0]);",
            "assign adr_ptable = (i_wbs_cyc_stb)&&( i_wbs_addr[(LGTBL+1)])&&( i_wbs_addr[0]);",
            "assign wr_control = (adr_control)&&(i_wbs_we);",
            "assign wr_vtable = (adr_vtable )&&(i_wbs_we);",
            "assign wr_ptable = (adr_ptable )&&(i_wbs_we);",
            "reg z_context;",
            "wire kernel_context;",
            "reg [(LGCTXT-1):0] r_context_word; // wire [31:0] w_control_data, w_ptable_",
            "reg ;",
            "reg [31:0] w_vtable_",
            "reg ;",
            "reg [31:0] status_word; // // reg r_pending, r_we, r_exe, r_valid, last_page_valid, last_ro, last_exe;",
            "reg [(DW-3):0] r_addr;",
            "reg [(DW-1):0] r_data;",
            "wire [(VAW-1):0] vpage;",
            "wire [AW-LGPGSZW-1:0] ppage;",
            "reg [(DW/8-1):0] r_sel;",
            "reg [(PAW-1):0] last_ppage;",
            "reg [(VAW-1):0] last_vpage; // wire [(TBL_SIZE-1):0] r_tlb_match;",
            "reg [(LGTBL-1):0] s_tlb_addr, last_tlb;",
            "reg s_tlb_miss, s_tlb_hit, s_pending; // wire ro_flag, exe_flag, simple_miss, ro_miss, exe_miss, table_err, cachable;",
            "reg pf_stb, pf_cachable;",
            "reg miss_pending; // reg rtn_err;",
            "wire this_page_valid, pending_page_valid;",
            "assign this_page_valid = ((last_page_valid) &&(i_wbm_addr[(DW-3):(DW-2-VAW)]==last_vpage) &&((!last_ro)||(!i_wbm_we)) &&((!last_exe)||(!i_wbm_exe)));",
            "assign pending_page_valid = ((s_pending)&&(s_tlb_hit) &&((!r_we)||(!ro_flag)) &&((!r_exe)||(exe_flag))); ////////////////////////////////////////// // // // Step one -- handle the control bus--i_wbs_cyc_stb // // ////////////////////////////////////////// always @(posedge i_clk) begin // Write to the Translation lookaside buffer if (wr_vtable) tlb_vdata[wr_tlb_addr]<=i_wbs_data[(DW-1):LGPGSZB]; if (wr_ptable) tlb_pdata[wr_tlb_addr]<=i_wbs_data[(AW+1):LGPGSZB]; // Set the context",
            "reg ister for the page if (wr_vtable) tlb_flags[wr_tlb_addr] <= { i_wbs_data[3:1], 1'b0 }; if (wr_vtable) tlb_cdata[wr_tlb_addr][(LGLCTX-1):0] <= i_wbs_data[(LGLCTX+4-1):4]; end",
            "initial tlb_accessed = 0;",
            "always @(posedge i_clk) if (i_reset) tlb_accessed <= 0; else begin if (wr_vtable) tlb_accessed[wr_tlb_addr] <= 1'b0; // Otherwise, keep track of the accessed bit if we // ever access this page else if ((!kernel_context)&&(pending_page_valid)) tlb_accessed[s_tlb_addr] <= 1'b1; else if ((!kernel_context)&&(this_page_valid)) tlb_accessed[last_tlb] <= 1'b1; end generate if (LGHCTX > 0) begin : HCTX",
            "always @(posedge i_clk) if (wr_ptable) tlb_cdata[wr_tlb_addr][(LGCTXT-1):LGLCTX] <= i_wbs_data[(LGHCTX+4-1):4]; end endgenerate // Writing to the control word",
            "initial z_context = 1'b1;",
            "initial r_context_word = 0;",
            "always @(posedge i_clk) if (wr_control) begin r_context_word <= i_wbs_data[(LGCTXT-1):0]; z_context <= (i_wbs_data[(LGCTXT-1):0] == {(LGCTXT){1'b0}}); end",
            "assign kernel_context = (z_context)||(!i_gie); // Status words cannot be written to",
            "always @(posedge i_clk) if (i_reset) tlb_valid <= 0; else if (wr_ptable) tlb_valid[wr_tlb_addr]<=1'b1; //(i_wbs_data[(AW+1):LGPGSZB]!=0); /* v*rilator lint_off WIDTH */",
            "assign w_control_data[31:28] = AW[3:0]-4'd1;",
            "assign w_control_data[27:24] = LGTBL[3:0];",
            "assign w_control_data[23:20] = LGPGSZB[3:0]-4'd10;",
            "assign w_control_data[19:16] = LGCTXT[3:0]-1'b1; /* v*rilator lint_on WIDTH */",
            "assign w_control_data[15: 0] = {{(16-LGCTXT){1'b0}}, r_context_word}; // always @(*) begin w_vtable_",
            "reg = 0; w_vtable_",
            "reg [(DW-1):LGPGSZB] = tlb_vdata[wr_tlb_addr]; w_vtable_",
            "reg [(LGLCTX+4-1):4] = { tlb_cdata[wr_tlb_addr][(LGLCTX-1):0] }; w_vtable_",
            "reg [ 3:0] = { tlb_flags[wr_tlb_addr][3:1], tlb_accessed[wr_tlb_addr] }; end // assign w_ptable_",
            "reg [(DW-1):LGPGSZB] = { {(DW-PAW-LGPGSZB){1'b0}}, tlb_pdata[wr_tlb_addr] };",
            "assign w_ptable_",
            "reg [ 3:0] = 4'h0; // generate if (4+LGHCTX-1>4) begin : PTABLE_REG_LIL",
            "assign w_ptable_",
            "reg [(4+LGHCTX-1):4] = { tlb_cdata[wr_tlb_addr][(LGCTXT-1):LGLCTX] }; end if (LGPGSZB > LGLCTX+4) begin : VTABLE_REG",
            "assign w_vtable_",
            "reg [(LGPGSZB-1):(LGLCTX+4)] = 0; end if (LGPGSZB > LGHCTX+4) begin : PTABLE_REG",
            "assign w_ptable_",
            "reg [(LGPGSZB-1):(LGHCTX+4)] = 0; end endgenerate // // Now, reading from the bus /* wire [(LGCTXT-1):0] w_ctable_",
            "reg ;",
            "assign w_ctable_",
            "reg = tlb_cdata[wr_tlb_addr];",
            "reg setup_this_page_flag;",
            "reg [(LGCTXT-1):0] setup_page;",
            "initial setup_this_page_flag = 1'b0;",
            "always @(posedge i_clk) setup_page <= w_ctable_",
            "reg ;",
            "always @(posedge i_clk) setup_this_page_flag <= (!i_reset)&&(i_wbs_cyc_stb)&&(i_wbs_addr[LGTBL+1]); */ ////////////////////////////////////////// // // // Step two -- handle the page lookup on the master bus // // ////////////////////////////////////////// // // // First clock, and the r_",
            "reg ister, copies the bus data from the bus. // While this increases the bus latency, it also gives us a moment to // work. // // wire [(VAW-1):0] r_vpage;",
            "wire [(PAW-1):0] r_ppage;",
            "assign r_vpage = (r_addr[(DW-3):(DW-2-VAW)]);",
            "assign r_ppage = (o_addr[(AW-1):LGPGSZW]);",
            "initial s_pending = 1'b0;",
            "initial r_pending = 1'b0;",
            "initial r_valid = 1'b0;",
            "always @(posedge i_clk) if (i_reset) begin r_pending <= 1'b0; r_valid <= 1'b0; o_addr <= 0; r_we <= 0; r_exe <= 0; r_addr <= 0; r_data <= 0; r_sel <= 0; // s_pending <= 1'b0; end else begin if (!o_rtn_stall) begin r_pending <= (i_wbm_stb)&&(!kernel_context) &&(!this_page_valid); r_we <= i_wbm_we; r_exe <= i_wbm_exe; o_addr <= { { (kernel_context)? i_wbm_addr[(AW-1):LGPGSZW] : last_ppage }, i_wbm_addr[(LGPGSZW-1):0] }; r_addr <= i_wbm_addr; r_data <= i_wbm_data; r_sel <= i_wbm_sel; r_valid <= (i_wbm_stb)&&((kernel_context)||(this_page_valid)); s_pending <= 1'b0; end else if (!r_valid) begin r_valid <= (pending_page_valid); o_addr <= { ppage , r_addr[(LGPGSZW-1):0] }; r_pending<= (r_pending)&&(!pending_page_valid); s_pending <=(r_pending)&&(!pending_page_valid); end else begin r_pending <= 1'b0; s_pending <= 1'b0; end if ((!i_wbm_cyc)||(o_rtn_err)||((o_cyc)&&(i_err))) begin s_pending <= 1'b0; r_pending <= 1'b0; r_valid <= 1'b0; end end `ifdef FORMAL",
            "reg f_past_valid;",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(r_pending))&&(r_pending)&&($past(o_rtn_stall))&&(i_wbm_cyc)&&(!o_stb)) assert(s_pending); `endif // Second clock: know which buffer entry this belong in. // If we don't already know, then the pipeline must be stalled for a // while ... genvar k; // s; generate for(k=0; k<TBL_SIZE; k = k + 1)",
            "assign r_tlb_match[k] = // The page must be valid (tlb_valid[k]) // Virtual address must match &&(tlb_vdata[k] == r_vpage) // Context must match as well &&(tlb_cdata[k][LGCTXT-1:1] == r_context_word[LGCTXT-1:1]) &&((!tlb_cdata[k][0])||(r_context_word[0])); endgenerate",
            "initial s_tlb_miss = 1'b0;",
            "initial s_tlb_hit = 1'b0; generate integer i;",
            "always @(posedge i_clk) begin // valid when s_ becomes valid s_tlb_addr <= {(LGTBL){1'b0}}; for(i=0; i<TBL_SIZE; i=i+1) if (r_tlb_match[i]) s_tlb_addr <= i[(LGTBL-1):0]; s_tlb_miss <= (r_pending)&&(r_tlb_match == 0); s_tlb_hit <= 1'b0; for(i=0; i<TBL_SIZE; i=i+1) if (r_tlb_match == (1<<i)) s_tlb_hit <= (r_pending)&&(!r_valid)&&(i_wbm_cyc); end endgenerate // Third clock: Read from the address the virtual table offset, // whether read-only, etc.",
            "assign s_tlb_flags = tlb_flags[s_tlb_addr];",
            "assign ro_flag = s_tlb_flags[`ROFLAG];",
            "assign exe_flag = s_tlb_flags[`EXEFLG];",
            "assign cachable = s_tlb_flags[`CHFLAG];",
            "assign simple_miss = (s_pending)&&(s_tlb_miss);",
            "assign ro_miss = (s_pending)&&(s_tlb_hit)&&(r_we)&&(ro_flag);",
            "assign exe_miss = (s_pending)&&(s_tlb_hit)&&(r_exe)&&(!exe_flag);",
            "assign table_err = (s_pending)&&(!s_tlb_miss)&&(!s_tlb_hit);",
            "assign vpage = tlb_vdata[s_tlb_addr];",
            "assign ppage = tlb_pdata[s_tlb_addr];",
            "initial pf_cachable = 1'b0;",
            "always @(posedge i_clk) if (i_reset) pf_cachable <= 1'b0; else pf_cachable <= cachable;",
            "initial pf_stb = 1'b0;",
            "initial last_ppage = 0;",
            "initial last_vpage = 0;",
            "always @(posedge i_clk) if (i_reset) begin pf_stb <= 1'b0; last_ppage <= 0; last_vpage <= 0; last_tlb <= 0; end else if ((!kernel_context)&&(r_pending)&&(!last_page_valid)) begin last_tlb <= s_tlb_addr; last_ppage <= ppage; last_vpage <= vpage; last_exe <= exe_flag; last_ro <= ro_flag; pf_stb <= 1'b1; end else pf_stb <= 1'b0;",
            "initial status_word = 0;",
            "always @(posedge i_clk) if (i_reset) status_word <= 0; else if (wr_control) status_word <= 0; else if ((table_err)||(ro_miss)||(simple_miss)||(exe_miss)) status_word <= { r_vpage, {(LGPGSZB-4){1'b0}}, (table_err), (exe_miss), (ro_miss), (simple_miss) };",
            "initial last_page_valid = 1'b0;",
            "always @(posedge i_clk) if (i_reset) last_page_valid <= 1'b0; else if ((i_wbs_cyc_stb)&&(i_wbs_we)) last_page_valid <= 1'b0; else if (!kernel_context) begin if (!o_rtn_stall) // A new bus request last_page_valid <= (last_page_valid) &&(i_wbm_addr[(DW-3):(DW-2-VAW)] == last_vpage); else if ((r_pending)&&(!last_page_valid)) last_page_valid <= (s_pending)&&(s_tlb_hit); end",
            "parameter LGFIFO = 6;",
            "reg [LGFIFO-1:0] bus_outstanding;",
            "initial bus_outstanding = 0;",
            "always @(posedge i_clk) if (i_reset) bus_outstanding <= 0; else if (!o_cyc) bus_outstanding <= 0; else case({ (o_stb)&&(!i_stall), (i_ack)||(i_err) } ) 2'b01: bus_outstanding <= bus_outstanding - 1'b1; 2'b10: bus_outstanding <= bus_outstanding + 1'b1; default: begin end endcase",
            "reg bus_pending;",
            "initial bus_pending = 0;",
            "always @(posedge i_clk) if (i_reset) bus_pending <= 0; else if (!o_cyc) bus_pending <= 1'b0; else case({ (o_stb)&&(!i_stall), ((i_ack)||(i_err)) }) 2'b01: bus_pending <= (bus_outstanding > 1); 2'b10: bus_pending <= 1'b1; default: begin end endcase",
            "initial rtn_err = 1'b0;",
            "initial o_cyc = 1'b0;",
            "always @(posedge i_clk) if (i_reset) begin o_cyc <= 1'b0; rtn_err <= 1'b0; end else begin o_cyc <= (i_wbm_cyc)&&(!o_rtn_err)&&((!i_err)||(!o_cyc)); /// &&((o_cyc)||(r_valid)); rtn_err <= (i_wbm_cyc)&&(i_err)&&(o_cyc); end generate if (OPT_DELAY_RETURN) begin : GEN_DELAYED_RETURN",
            "reg r_rtn_ack;",
            "reg [31:0] r_rtn_data;",
            "initial r_rtn_data = 0;",
            "initial r_rtn_ack = 0;",
            "always @(posedge i_clk) if (i_reset) begin r_rtn_ack <= 0; r_rtn_data <= 0; end else begin r_rtn_ack <= (i_wbm_cyc)&&(i_ack)&&(o_cyc); r_rtn_data <= i_data; end",
            "assign o_rtn_ack = r_rtn_ack;",
            "assign o_rtn_data = r_rtn_data; end else begin : GEN_DIRECT_RETURN",
            "assign o_rtn_ack = (i_ack)&&(o_cyc);",
            "assign o_rtn_data = i_data; end endgenerate",
            "assign o_stb = (r_valid);",
            "assign o_we = (r_we);",
            "assign o_rtn_stall = (i_wbm_cyc)&&( (o_rtn_err) ||((r_pending)&&(!r_valid)) ||((o_stb)&&(i_stall)) ||(miss_pending));",
            "initial miss_pending = 0;",
            "always @(posedge i_clk) if (i_reset) miss_pending <= 0; else if (!i_wbm_cyc) miss_pending <= 0; else miss_pending <= (i_wbm_cyc)&&( (simple_miss)||(ro_miss)||(exe_miss) ||((s_pending)&&(!s_tlb_miss)&&(!s_tlb_hit)));",
            "assign o_rtn_miss = (miss_pending)&&(!bus_pending);",
            "assign o_rtn_err = (rtn_err);",
            "assign o_sel = r_sel;",
            "assign o_data = r_data; // assign o_wbs_stall = 1'b0;",
            "initial o_wbs_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_wbs_ack <= 1'b0; else o_wbs_ack <= (i_wbs_cyc_stb);",
            "always @(posedge i_clk) if (i_reset) o_wbs_data <= 0; else case({i_wbs_addr[LGTBL+1],i_wbs_addr[0]}) 2'b00: o_wbs_data <= w_control_data; 2'b01: o_wbs_data <= status_word; 2'b10: o_wbs_data <= w_vtable_",
            "reg ; 2'b11: o_wbs_data <= w_ptable_",
            "reg ; endcase // // Bus snooping returns ... // assign pf_return_stb = pf_stb;",
            "assign pf_return_we = r_we;",
            "assign pf_return_p = last_ppage;",
            "assign pf_return_v = last_vpage;",
            "assign pf_return_cachable = pf_cachable; // Also requires being told when/if the page changed // So, on a page change, // pf_return_we = 1 // pf_stb = 1 // and pf_return_p has the physical address // Make verilator happy // verilator lint_off UNUSED",
            "wire [(PAW-1):0] unused;",
            "assign unused = r_ppage; generate if (4+LGCTXT < LGPGSZB) begin : GEN_UNUSED",
            "wire unused_data;",
            "assign unused_data = { 1'b0, i_wbs_data[LGPGSZB-1:4+LGCTXT] }; end endgenerate",
            "wire unused_",
            "always ;",
            "assign unused_",
            "always = s_tlb_flags[0]; // verilator lint_on UNUSED `ifdef FORMAL",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "initial assume(i_reset);",
            "always @(*) if (!f_past_valid) assume(i_reset);",
            "always @(*) if (i_reset) assume(!i_wbs_cyc_stb);",
            "always @(posedge i_clk) if (f_past_valid) assert(o_wbs_ack == $past(i_wbs_cyc_stb));",
            "always @(*) assert(o_wbs_stall == 1'b0);",
            "always @(*) assume((!i_wbm_cyc)||(!i_wbs_cyc_stb));",
            "localparam F_LGDEPTH = 6;",
            "reg [F_LGDEPTH-1:0] fv_nreqs, fv_nacks, fv_outstanding, fp_nreqs, fp_nacks, fp_outstanding;",
            "localparam F_MAX_STALL = 3, F_MAX_WAIT = 2, F_MAX_REQ = 9; // // The stall period needs to be long enough to allow all in-progress // transactions to complete, as in the case of a page miss. Hence, // the max stall amount depends upon the max wait time for the // physical half of the interaction. It is artificially limited here // in order to limit the amount of proof time required. // fwb_slave #( // {{{ .F_MAX_STALL(F_MAX_STALL+(F_MAX_WAIT*F_MAX_REQ)+2), .AW(DW-2), .F_MAX_ACK_DELAY(F_MAX_STALL+F_MAX_WAIT+5), .F_MAX_REQUESTS(F_MAX_REQ), .F_LGDEPTH(F_LGDEPTH), .F_OPT_MINCLOCK_DELAY(0) // }}} ) busslave( // {{{ i_clk, i_reset, i_wbm_cyc, i_wbm_stb, i_wbm_we, i_wbm_addr, i_wbm_data, i_wbm_sel, o_rtn_ack, o_rtn_stall, o_rtn_data, o_rtn_err|o_rtn_miss, fv_nreqs, fv_nacks, fv_outstanding // }}} ); fwb_master #( // {{{ .F_MAX_STALL(F_MAX_STALL), .AW(ADDRESS_WIDTH), .F_MAX_ACK_DELAY(F_MAX_WAIT), .F_MAX_REQUESTS(F_MAX_REQ), .F_LGDEPTH(F_LGDEPTH), .F_OPT_MINCLOCK_DELAY(0) // }}} ) busmaster( // {{{ i_clk, i_reset, o_cyc, o_stb, o_we, o_addr, o_data, o_sel, i_ack, i_stall, i_data, i_err, fp_nreqs, fp_nacks, fp_outstanding // }}} );",
            "always @(*) assert((!o_cyc)||(fp_outstanding == bus_outstanding));",
            "always @(*) assume(fv_nreqs < F_MAX_REQ);",
            "always @(*) if ((i_wbm_cyc)&&(o_cyc)&&(fv_outstanding == fp_outstanding)) assert(fv_nreqs == fp_nreqs);",
            "always @(*) if ((i_wbm_cyc)&&(o_cyc)) begin assert(fp_nreqs <= fv_nreqs); assert(fp_nacks >= fv_nacks); end",
            "reg [F_LGDEPTH-1:0] f_expected, f_ex_nreqs, f_ex_nacks;",
            "always @(*) if (!i_wbm_cyc) begin f_ex_nreqs = 0; f_ex_nacks = 0; f_expected = 0; end else if (OPT_DELAY_RETURN) begin if (r_pending) begin f_ex_nreqs = fp_nreqs + 1'b1; f_ex_nacks = fp_nacks + o_rtn_ack; f_expected = fp_outstanding + 1'b1 + o_rtn_ack; end else begin f_expected = fp_outstanding + (o_stb) + (o_rtn_ack); f_ex_nreqs = fp_nreqs + o_stb; f_ex_nacks = fp_nacks + o_rtn_ack; end end else begin if (r_pending) begin f_ex_nreqs = fp_nreqs + 1'b1; f_ex_nacks = fp_nacks; f_expected = fp_outstanding + 1'b1; end else begin f_ex_nreqs = fp_nreqs + o_stb; f_ex_nacks = fp_nacks; f_expected = fp_outstanding + (o_stb); end end",
            "reg f_kill_",
            "input ;",
            "initial f_kill_",
            "input = 1'b0;",
            "always @(posedge i_clk) f_kill_",
            "input <= (i_wbm_cyc)&&( (i_reset) ||(o_rtn_miss) ||(o_rtn_err));",
            "always @(*) if (f_kill_",
            "input ) assume(!i_wbm_cyc);",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_rtn_miss))&&($past(i_wbm_cyc))) begin assume(!o_cyc); assume(!i_wbm_cyc); end",
            "wire fv_is_one, fp_is_zero;",
            "assign fv_is_one = (fv_outstanding == 1);",
            "assign fp_is_zero = (fp_outstanding == 0);",
            "always @(*) if ((i_wbm_cyc)&&(o_cyc)) begin if (o_rtn_miss) begin assert(fp_outstanding == 0); assert(fv_outstanding == 1); assert(fv_is_one); assert(fp_is_zero); end else begin assert(fv_nreqs == f_ex_nreqs); assert(fv_nacks == f_ex_nacks); assert(fv_outstanding >= fp_outstanding); assert(fv_outstanding == f_expected); end end",
            "always @(*) assert(z_context == (r_context_word == 0));",
            "always @(*) assert(kernel_context == ( ((r_context_word == 0)||(!i_gie)) ? 1'b1 : 1'b0));",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_wbs_cyc_stb))) assume(!i_wbm_cyc);",
            "always @(*) if (o_wbs_ack) assume(!i_wbm_cyc);",
            "always @(*) assert((!i_wbm_cyc)||(!o_wbs_ack));",
            "always @(posedge i_clk) if ((f_past_valid)&&(r_pending)&&($past(kernel_context)) &&($past(i_wbm_stb))&&(!$past(i_stall))&&(i_wbm_cyc) &&(!o_rtn_stall)) assert(o_addr[(AW-1):0] == $past(i_wbm_addr[(AW-1):0]));",
            "always @(*) assert(bus_pending == (bus_outstanding > 0));",
            "always @(*) if ((s_pending)&&(!s_tlb_miss)) assert(r_tlb_match[s_tlb_addr]); // Check out all of the criteria which should clear these flags",
            "always @(posedge i_clk) if ((f_past_valid)&&(($past(i_reset)) ||(!$past(i_wbm_cyc)) ||(!$past(o_rtn_stall)))) begin assert(!simple_miss); assert(!ro_miss); assert(!exe_miss); assert(!table_err); if (!$past(i_wbm_we)) assert(!ro_miss); if (!kernel_context) begin assert((!o_stb)||(!(simple_miss|ro_miss|table_err))); // This doesn't belong on the clear list, but on the // should be set list // assert((!o_stb)||(!s_tlb_hit)); end end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_wbm_cyc)) &&(!$past(o_rtn_stall))) begin if ((!$past(kernel_context))&&(o_stb)) assert((last_page_valid)||(s_tlb_hit)); end",
            "reg [(LGTBL-1):0] f_last_page;",
            "always @(posedge i_clk) if ((f_past_valid)&&(!kernel_context)&&(r_pending)&&(!last_page_valid)) f_last_page <= s_tlb_addr;",
            "wire [3:0] tlb_flag_last_page;",
            "assign tlb_flag_last_page = tlb_flags[f_last_page];",
            "always @(*) if (last_page_valid) begin assert(tlb_valid[f_last_page]); assert(last_tlb == f_last_page); assert(last_ppage == tlb_pdata[f_last_page]); assert(last_vpage == tlb_vdata[f_last_page]); assert(last_ro == tlb_flag_last_page[`ROFLAG]); assert(last_exe == tlb_flag_last_page[`EXEFLG]); assert(r_context_word[LGCTXT-1:1] == tlb_cdata[f_last_page][LGCTXT-1:1]); if (!r_context_word[0]) assert(!tlb_cdata[f_last_page][0]); assert((!r_context_word[0])||(r_context_word[0])); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&($past(last_page_valid))&&(!$past(kernel_context)) &&($past(o_stb))&&($past(i_wbm_cyc))) assert(tlb_accessed[$past(last_tlb)]);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&($past(pending_page_valid))&&(!$past(kernel_context)) &&($past(o_stb))&&($past(i_wbm_cyc))) assert(tlb_accessed[$past(s_tlb_addr)]);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(kernel_context))&&(o_stb)) begin assert(last_page_valid); assert(r_ppage == last_ppage); assert((!last_ro)||(!o_we)); end",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_stb))&&(o_stb)&&(i_wbm_cyc)) assert((last_page_valid)||(kernel_context));",
            "always @(*) assert((!s_tlb_hit)||(!s_tlb_miss)); // always @(*) // if ((fp_outstanding > 0)&&(o_cyc)&&(!o_stb)&&(!r_pending)&&(!kernel_context)) // assert(last_page_valid); // always @(*) assume(kernel_context);",
            "always @(*) assume((!i_wbs_cyc_stb)||(!i_gie));",
            "reg f_past_gie, f_past_wbm_cyc;",
            "initial f_past_gie = 1'b0;",
            "always @(posedge i_clk) f_past_gie <= i_gie;",
            "initial f_past_wbm_cyc = 1'b0;",
            "always @(posedge i_clk) f_past_wbm_cyc <= i_wbm_cyc;",
            "always @(*) if ((f_past_valid)&&(bus_pending)) assume(i_gie == f_past_gie);",
            "always @(*) if ((f_past_wbm_cyc)&&(i_wbm_cyc)) assume(i_gie == f_past_gie);",
            "always @(posedge i_clk) if ((f_past_valid)&&(i_wbm_cyc)&&($past(i_wbm_cyc))) assume(i_gie == $past(i_gie));",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_reset))) assume(!i_gie);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(i_wbm_cyc)) &&($past(!kernel_context)) &&($past(r_pending)) &&(!$past(last_page_valid))) begin if (($past(s_tlb_hit)) &&(!$past(ro_miss)) &&(!$past(exe_miss))) begin assert(last_vpage == $past(r_vpage)); assert(last_page_valid); assert(!miss_pending); assert(tlb_accessed[s_tlb_addr]); end else if (($past(s_tlb_hit))&&($past(ro_miss))) begin assert(miss_pending); assert(last_page_valid); assert(status_word[3:0] == 4'h2); end else if (($past(s_tlb_hit))&&($past(exe_miss))) begin assert(miss_pending); assert(last_page_valid); assert(status_word[3:0] == 4'h4); end else if (($past(s_tlb_hit))&&($past(simple_miss))) begin assert(miss_pending); assert(last_page_valid); assert(status_word[3:0] == 4'h1); end else if (!$past(s_tlb_hit)) begin assert(!last_page_valid); end end",
            "always @(*) assert((!ro_miss)||(!exe_miss)||(!simple_miss)||(!table_err));",
            "reg [4:0] f_tlb_pipe;",
            "initial f_tlb_pipe = 5'h0;",
            "always @(posedge i_clk) if (i_reset) f_tlb_pipe <= 5'h0; else if ((!r_pending)||(o_stb)) f_tlb_pipe <= 5'h0; else if ((r_pending)&&(!r_valid)&&(!miss_pending)) f_tlb_pipe <= { f_tlb_pipe[3:0], 1'b1 };",
            "always @(*) assert(f_tlb_pipe != 5'h1f);",
            "always @(*) // WE or EXE, never both assume((!i_wbm_stb)||(!i_wbm_we)||(!i_wbm_exe));",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_wbm_stb))&&($past(o_rtn_stall))) assume(i_wbm_exe == $past(i_wbm_exe));",
            "always @(*) assert((!r_pending)||(!o_stb));",
            "always @(*) assert((!s_pending)||(!o_stb));",
            "always @(*) assert((!s_pending)||(r_pending));",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(i_wbm_cyc))) assume(!i_wbs_cyc_stb);",
            "always @(posedge i_clk) if ((f_past_valid)&&(|status_word[3:0])&&(!$past(i_wbm_cyc))) assume(!i_gie); `endif",
            "endmodule"
        ]
    },
    {
        "file_name": "zipcounter.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/zipcounter.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipcounter.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: // A very, _very_ simple counter. It's purpose doesn't really // include rollover, but it will interrupt on rollover. It can be set, // although my design concept is that it can be reset. It cannot be // halted. It will",
            "always produce interrupts--whether or not they are // handled interrupts is another question--that's up to the interrupt // controller. // // My intention is to use this counter for process accounting: I should // be able to use this to count clock ticks of processor time",
            "assign ed to // each task by resetting the counter at the beginning of every task // interval, and reading the result at the end of the interval. As long // as the interval is less than 2^32 clocks, there should be no problem. // Similarly, this can be used to measure CPU wishbone bus stalls, // prefetch stalls, or other CPU stalls (i.e. stalling as part of a JMP // instruction, or a read from the condition codes following a write). // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module zipcounter #( // {{{",
            "parameter BW = 32 `ifdef FORMAL , localparam F_LGDEPTH = 2 `endif // }}} ) ( // {{{",
            "input wire i_clk, i_reset, i_event, // Wishbone",
            "input s",
            "input wire i_wb_cyc, i_wb_stb, i_wb_we, input wire [(BW-1):0] i_wb_data, // Wishbone",
            "output s",
            "output wire o_wb_stall, output reg o_wb_ack, output reg [(BW-1):0] o_wb_data, // Interrupt line",
            "output reg o_int // }}} ); // o_int, o_wb_data // {{{",
            "initial o_int = 0;",
            "initial o_wb_data = 32'h00;",
            "always @(posedge i_clk) if (i_reset) { o_int, o_wb_data } <= 0; else if ((i_wb_stb)&&(i_wb_we)) { o_int, o_wb_data } <= { 1'b0, i_wb_data }; else if (i_event) { o_int, o_wb_data } <= o_wb_data+{{(BW-1){1'b0}},1'b1}; else o_int <= 1'b0; // }}} // o_wb_ack // {{{",
            "initial o_wb_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_wb_ack <= 1'b0; else o_wb_ack <= i_wb_stb; // }}}",
            "assign o_wb_stall = 1'b0; // Make verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_wb_cyc }; // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "always @(*) if (!f_past_valid) assume(i_reset); //////////////////////////////////////////////////////////////////////// // // Assumptions about our",
            "input s // {{{ //////////////////////////////////////////////////////////////////////// // // // }}} //////////////////////////////////////////////////////////////////////// // // Bus interface properties // {{{ //////////////////////////////////////////////////////////////////////// // // // We never stall the bus",
            "always @(*) assert(!o_wb_stall); // We",
            "always ack every transaction on the following clock",
            "always @(posedge i_clk) assert(o_wb_ack == ((f_past_valid)&&(!$past(i_reset)) &&($past(i_wb_stb))));",
            "wire [(F_LGDEPTH-1):0] f_nreqs, f_nacks, f_outstanding; fwb_slave #( // {{{ .AW(1), .F_MAX_STALL(0), .F_MAX_ACK_DELAY(1), .F_LGDEPTH(F_LGDEPTH) // }}} ) fwbi( // {{{ i_clk, i_reset, i_wb_cyc, i_wb_stb, i_wb_we, 1'b0, i_wb_data, 4'hf, o_wb_ack, o_wb_stall, o_wb_data, 1'b0, f_nreqs, f_nacks, f_outstanding // }}} );",
            "always @(*) if ((o_wb_ack)&&(i_wb_cyc)) begin assert(f_outstanding==1); end else assert(f_outstanding == 0); // }}} //////////////////////////////////////////////////////////////////////// // // Assumptions about our",
            "output s // {{{ //////////////////////////////////////////////////////////////////////// // // // Drop the interrupt line and reset the counter on any reset // {{{",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset)) assert((!o_int)&&(o_wb_data == 0)); // }}} // Clear the interrupt and set the counter on any write (other than // during a reset) // {{{",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset)) &&($past(i_wb_stb))&&($past(i_wb_we))) assert((!o_int)&&(o_wb_data == $past(i_wb_data))); // }}} // Normal",
            "logic of the routine itself // {{{",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&(!$past(i_wb_stb))) begin if (!$past(i_event)) begin // If the CE line wasn't set on the last clock, then the // counter must not change, and the interrupt line must // be low. assert(o_wb_data == $past(o_wb_data)); assert(!o_int); end else // if ($past(i_event)) begin // Otherwise, if the CE line was high on the last clock, // then our counter should have incremented. assert(o_wb_data == $past(o_wb_data) + 1'b1); // Likewise, if the counter rolled over, then the // output interrupt, o_int, should be true. if ($past(o_wb_data)=={(BW){1'b1}}) begin assert(o_int); end else // In all other circumstances it should be clear assert(!o_int); end end // ?}}} // The",
            "output interrupt should never be true two clocks in a row // {{{",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(o_int))) assert(!o_int); // }}} // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "icontrol.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/icontrol.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: icontrol.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: An interrupt controller, for managing many interrupt sources. // // This interrupt controller started from the question of how best to // design a simple interrupt controller. As such, it has a few nice // qualities to it: // 1. This is wishbone compliant // 2. It sits on a 32-bit wishbone data bus // 3. It only consumes one address on that wishbone bus. // 4. There is no extra delays associated with reading this // device. // 5. Common operations can all be done in one clock. // // So, how shall this be used? First, the 32-bit word is broken down as // follows: // // Bit 31 - This is the global interrupt enable bit. If set, interrupts // will be generated and passed on as they come in. // Bits 16-30 - These are specific interrupt enable lines. If set, // interrupts from source (bit#-16) will be enabled. // To set this line and enable interrupts from this source, write // to the",
            "reg ister with this bit set and the global enable set. // To disable this line, write to this",
            "reg ister with global enable // bit not set, but this bit set. (Writing a zero to any of these // bits has no effect, either setting or unsetting them.) // Bit 15 - This is the any interrupt pin. If any interrupt is pending, // this bit will be set. // Bits 0-14 - These are interrupt bits. When set, an interrupt is // pending from the corresponding source--",
            "reg ardless of whether // it was enabled. (If not enabled, it won't generate an // interrupt, but it will still",
            "reg ister here.) To clear any // of these bits, write a '1' to the corresponding bit. Writing // a zero to any of these bits has no effect. // // The peripheral also sports a",
            "parameter , IUSED, which can be set // to any value between 1 and (buswidth/2-1, or) 15 inclusive. This will // be the number of interrupts handled by this routine. (Without the // parameter , Vivado was complaining about unused bits. With it, we can // keep the complaints down and still use the routine). // // To get access to more than 15 interrupts, chain these together, so // that one interrupt controller device feeds another. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module icontrol #( // {{{",
            "parameter IUSED = 12, DW=32 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, input wire i_wb_cyc, i_wb_stb, i_wb_we, input wire [DW-1:0] i_wb_data, input wire [DW/8-1:0] i_wb_sel, output wire o_wb_stall, o_wb_ack, output reg [DW-1:0] o_wb_data, input wire [(IUSED-1):0] i_brd_ints, output reg o_interrupt // }}} ); // Local declarations // {{{",
            "reg [(IUSED-1):0] r_int_state;",
            "reg [(IUSED-1):0] r_int_enable;",
            "reg r_mie;",
            "wire w_any;",
            "wire wb_write, enable_ints, disable_ints; // }}}",
            "assign wb_write = (i_wb_stb)&&(i_wb_we);",
            "assign enable_ints = (wb_write)&&( i_wb_data[15]);",
            "assign disable_ints = (wb_write)&&(!i_wb_data[15]); // r_int_state // {{{ // First step: figure out which interrupts have triggered. An // interrupt \"triggers\" when the incoming interrupt",
            "wire is high, and // stays triggered until cleared by the bus.",
            "initial r_int_state = 0;",
            "always @(posedge i_clk) if (i_reset) r_int_state <= 0; else if (wb_write) r_int_state <= i_brd_ints | (r_int_state & (~i_wb_data[(IUSED-1):0])); else r_int_state <= (r_int_state | i_brd_ints); // }}} // r_int_enable // {{{ // Second step: determine which interrupts are enabled. // Only interrupts that are enabled will be propagated forward on // the global interrupt line.",
            "initial r_int_enable = 0;",
            "always @(posedge i_clk) if (i_reset) r_int_enable <= 0; else if (enable_ints) r_int_enable <= r_int_enable | i_wb_data[16 +: IUSED]; else if (disable_ints) r_int_enable <= r_int_enable & (~ i_wb_data[16 +: IUSED]); // }}} // r_mie // {{{ // Third step: The master (global) interrupt enable bit.",
            "initial r_mie = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_mie <= 1'b0; else if (enable_ints && i_wb_data[DW-1]) r_mie <= 1'b1; else if (disable_ints && i_wb_data[DW-1]) r_mie <= 1'b0; // }}} // // Have \"any\" enabled interrupts triggered?",
            "assign w_any = ((r_int_state & r_int_enable) != 0); // o_interrupt // {{{ // How then shall the interrupt",
            "wire be set?",
            "initial o_interrupt = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_interrupt <= 1'b0; else o_interrupt <= (r_mie)&&(w_any); // }}} // o_wb_data // {{{ // Create the",
            "output data. Place this into the next clock, to keep // it synchronous with w_any.",
            "initial o_wb_data = 0;",
            "always @(posedge i_clk) begin o_wb_data <= 0; o_wb_data[31] <= r_mie; o_wb_data[15] <= w_any; o_wb_data[16 +: IUSED] <= r_int_enable; o_wb_data[ 0 +: IUSED] <= r_int_state; end // }}}",
            "assign o_wb_ack = i_wb_stb;",
            "assign o_wb_stall = 1'b0; // Make verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED generate if (IUSED < 15) begin : UNUSED_INTS",
            "wire unused_int;",
            "assign unused_int = &{ 1'b0, i_wb_data[32-2:(16+IUSED)], i_wb_data[16-2:IUSED] }; end endgenerate",
            "wire unused;",
            "assign unused = &{ 1'b0, i_wb_cyc, i_wb_sel }; // verilator lint_on UNUSED // verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties section // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // {{{ `ifdef ICONTROL `define ASSUME assume `else `define ASSUME assert `endif",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; // }}} //////////////////////////////////////////////////////////////////////// // // Reset handling // {{{ //////////////////////////////////////////////////////////////////////// // // initial `ASSUME(i_reset);",
            "always @(*) if (!f_past_valid) `ASSUME(i_reset);",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) begin assert(r_int_state == 0); assert(r_int_enable == 0); assert(w_any == 0); assert(o_interrupt == 0); assert(r_mie == 0); end // }}} //////////////////////////////////////////////////////////////////////// // // Formal contract // {{{ //////////////////////////////////////////////////////////////////////// // // // Rule #1: An interrupt should be able to set the r_int_state bits // always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))) assert((r_int_state & $past(i_brd_ints))==$past(i_brd_ints)); // Rule #2: An interrupt should be generated if received and enabled // // Make sure any enabled interrupt generates an outgoing interrupt // ... assuming the master interrupt enable is true and the // individual interrupt enable is true as well.",
            "always @(posedge i_clk) if (((f_past_valid)&&(!$past(i_reset))) &&(|$past(r_int_state & r_int_enable)) &&($past(r_mie)) ) assert(o_interrupt); // Rule #3: If the global interrupt enable bit is off, then no // interrupts shall be asserted // always @(posedge i_clk) if ((f_past_valid)&&(!$past(r_mie))) assert(!o_interrupt); // Rule #4: If no active interrupts are enabled, then no outgoing // interrupt shall be asserted either",
            "always @(posedge i_clk) if ((f_past_valid)&&(0 == |$past(r_int_state & r_int_enable))) assert(!o_interrupt); // Bus rules // // Rule #5: It should be possible to disable one (or all) interrupts",
            "always @(posedge i_clk) if ((f_past_valid)&&($past(disable_ints))) assert(($past({i_wb_data[31],i_wb_data[16 +: IUSED]}) & { r_mie, r_int_enable }) == 0); // Rule #6: It should be possible to enable one (or all) interrupts",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(enable_ints))) assert(($past({i_wb_data[31],i_wb_data[16 +: IUSED]}) & { r_mie, r_int_enable }) == $past({i_wb_data[31],i_wb_data[16 +: IUSED]})); // Rule #7: It shoule be possible to acknowledge an interrupt, and so // deactivate it",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&($past(wb_write))) assert(r_int_state == $past(i_brd_ints | (r_int_state & ~i_wb_data[IUSED-1:0]))); // Rule #8: The interrupt enables should be stable without a write",
            "always @(posedge i_clk) if ((f_past_valid) && (!$past(i_reset)) && (!$past(wb_write))) assert($stable({r_mie, r_int_enable})); // }}} //////////////////////////////////////////////////////////////////////// // // Bus properties // {{{ //////////////////////////////////////////////////////////////////////// // wire [1:0] f_nreqs, f_nacks, f_outstanding;",
            "reg past_stb;",
            "always @(*) if (i_wb_stb) assume(i_wb_cyc);",
            "always @(posedge i_clk) if (!f_past_valid || $past(i_reset)) assume(!i_wb_cyc); fwb_slave #(.DW(DW), .AW(1), .F_MAX_STALL(0), .F_MAX_ACK_DELAY(1), .F_LGDEPTH(2), .F_MAX_REQUESTS(1), .F_OPT_MINCLOCK_DELAY(0)) fwb(i_clk, i_reset, i_wb_cyc, i_wb_stb, i_wb_we, 1'b0, i_wb_data, 4'hf, o_wb_ack, o_wb_stall, o_wb_data, 1'b0, f_nreqs, f_nacks, f_outstanding);",
            "always @(*) assert(f_outstanding == 0); // }}} //////////////////////////////////////////////////////////////////////// // // Other consistency",
            "logic // {{{ //////////////////////////////////////////////////////////////////////// // // Without a write or a reset, past interrupts should remain // enabled.",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(wb_write))&&(!$past(i_reset))) begin assert(($past(r_int_state)& ~r_int_state)==0); assert((!$past(w_any)) || w_any); end // The outgoing interrupt should never be high unless w_any // is also high",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(w_any))) assert(!o_interrupt); // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) cover(o_interrupt);",
            "always @(posedge i_clk) if (!f_past_valid) cover($fell(w_any) && $stable(r_int_enable));",
            "always @(posedge i_clk) if (f_past_valid) begin cover(!o_interrupt && $past(w_any)); cover(!o_interrupt && $past(r_mie) && $past(|r_int_state)); end // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "axilperiphs.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/axilperiphs.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: axilperiphs // {{{ // Project: WB2AXIPSP: bus bridges and other odds and ends // // Purpose: // Registers: // 0x00 PIC Interrupt controller // 0x04 Watchdog // 0x08 (Reserved) // 0x0c CTRIC Secondary interrupt controller // 0x10 TMRA // 0x14 TMRB // 0x18 TMRC // 0x1c JIFF // (No User counters) // (No DMA) // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2020-2024, Gisselquist Technology, LLC // {{{ // // This file is part of the WB2AXIP project. // // The WB2AXIP project contains free software and gateware, licensed under the // Apache License, Version 2.0 (the \"License\"). You may not use this project, // or this file, except in compliance with the License. You may obtain a copy // of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT // WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the // License for the specific language governing permissions and limitations // under the License. // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module axilperiphs #( // {{{ // // Size of the AXI-lite bus. These are fixed, since 1) AXI-lite // is fixed at a width of 32-bits by Xilinx def'n, and 2) since // we only ever have 4 configuration words.",
            "parameter C_AXI_ADDR_WIDTH = 6, localparam C_AXI_DATA_WIDTH = 32, parameter [0:0] OPT_SKIDBUFFER = 1'b1, parameter [0:0] OPT_LOWPOWER = 0, parameter EXTERNAL_INTERRUPTS = 1, parameter [0:0] OPT_COUNTERS = 1, localparam ADDRLSB = $clog2(C_AXI_DATA_WIDTH)-3 // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, // AXI-lite interface // {{{",
            "input wire S_AXI_AWVALID, output wire S_AXI_AWREADY, input wire [C_AXI_ADDR_WIDTH-1:0] S_AXI_AWADDR, input wire [2:0] S_AXI_AWPROT, // input wire S_AXI_WVALID, output wire S_AXI_WREADY, input wire [C_AXI_DATA_WIDTH-1:0] S_AXI_WDATA, input wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB, // output wire S_AXI_BVALID, input wire S_AXI_BREADY, output wire [1:0] S_AXI_BRESP, // input wire S_AXI_ARVALID, output wire S_AXI_ARREADY, input wire [C_AXI_ADDR_WIDTH-1:0] S_AXI_ARADDR, input wire [2:0] S_AXI_ARPROT, // output wire S_AXI_RVALID, input wire S_AXI_RREADY, output wire [C_AXI_DATA_WIDTH-1:0] S_AXI_RDATA, output wire [1:0] S_AXI_RRESP, // }}}",
            "input wire i_cpu_reset, input wire i_cpu_halted, input wire i_cpu_gie, input wire i_cpu_pfstall, input wire i_cpu_opstall, input wire i_cpu_icount, input wire [EXTERNAL_INTERRUPTS-1:0] i_ivec, output wire o_interrupt, output wire o_watchdog_reset // }}} ); //////////////////////////////////////////////////////////////////////// // // Register/",
            "wire signal declarations // {{{ //////////////////////////////////////////////////////////////////////// // // localparam [3:0] ADR_PIC = 4'h0, ADR_WATCHDOG = 4'h1, ADR_APIC = 4'h2; // No bus watchdog",
            "localparam [3:0] ADR_TIMERA = 4'h4, ADR_TIMERB = 4'h5, ADR_TIMERC = 4'h6, ADR_JIFFIES= 4'h7;",
            "localparam [3:0] ADR_MCLOCKS = 4'h8, ADR_MOPSTALL = 4'h9, ADR_MPFSTALL = 4'ha, ADR_MICOUNT = 4'hb;",
            "localparam [3:0] ADR_UCLOCKS = 4'hc, ADR_UOPSTALL = 4'hd, ADR_UPFSTALL = 4'he, ADR_UICOUNT = 4'hf;",
            "wire i_reset = !S_AXI_ARESETN;",
            "wire axil_write_ready;",
            "wire [C_AXI_ADDR_WIDTH-ADDRLSB-1:0] awskd_addr; // wire [C_AXI_DATA_WIDTH-1:0] wskd_data;",
            "wire [C_AXI_DATA_WIDTH/8-1:0] wskd_strb;",
            "reg axil_bvalid; // wire axil_read_ready;",
            "wire [C_AXI_ADDR_WIDTH-ADDRLSB-1:0] arskd_addr;",
            "reg [C_AXI_DATA_WIDTH-1:0] axil_read_data;",
            "reg axil_read_valid;",
            "wire pic_stall, pic_ack;",
            "wire [31:0] pic_data;",
            "wire wdog_stall, wdog_ack;",
            "wire [31:0] wdog_data;",
            "wire apic_stall, apic_ack, apic_int;",
            "wire [31:0] apic_data;",
            "wire tmra_stall, tmra_ack, tmra_int;",
            "wire [31:0] tmra_data;",
            "wire tmrb_stall, tmrb_ack, tmrb_int;",
            "wire [31:0] tmrb_data;",
            "wire tmrc_stall, tmrc_ack, tmrc_int;",
            "wire [31:0] tmrc_data;",
            "wire jif_stall, jif_ack, jif_int;",
            "wire [31:0] jif_data; // }}} //////////////////////////////////////////////////////////////////////// // // AXI-lite signaling // {{{ //////////////////////////////////////////////////////////////////////// // // // // Write signaling // // {{{ generate if (OPT_SKIDBUFFER) begin : SKIDBUFFER_WRITE",
            "wire awskd_valid, wskd_valid; skidbuffer #(.OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(C_AXI_ADDR_WIDTH-ADDRLSB)) axilawskid(// .i_clk(S_AXI_ACLK), .i_reset(i_reset), .i_valid(S_AXI_AWVALID), .o_ready(S_AXI_AWREADY), .i_data(S_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB]), .o_valid(awskd_valid), .i_ready(axil_write_ready), .o_data(awskd_addr)); skidbuffer #(.OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(C_AXI_DATA_WIDTH+C_AXI_DATA_WIDTH/8)) axilwskid(// .i_clk(S_AXI_ACLK), .i_reset(i_reset), .i_valid(S_AXI_WVALID), .o_ready(S_AXI_WREADY), .i_data({ S_AXI_WDATA, S_AXI_WSTRB }), .o_valid(wskd_valid), .i_ready(axil_write_ready), .o_data({ wskd_data, wskd_strb }));",
            "assign axil_write_ready = awskd_valid && wskd_valid && (!S_AXI_BVALID || S_AXI_BREADY); end else begin : SIMPLE_WRITES",
            "reg axil_awready;",
            "initial axil_awready = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axil_awready <= 1'b0; else axil_awready <= !axil_awready && (S_AXI_AWVALID && S_AXI_WVALID) && (!S_AXI_BVALID || S_AXI_BREADY);",
            "assign S_AXI_AWREADY = axil_awready;",
            "assign S_AXI_WREADY = axil_awready;",
            "assign awskd_addr = S_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB];",
            "assign wskd_data = S_AXI_WDATA;",
            "assign wskd_strb = S_AXI_WSTRB;",
            "assign axil_write_ready = axil_awready; end endgenerate",
            "initial axil_bvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (i_reset) axil_bvalid <= 0; else if (axil_write_ready) axil_bvalid <= 1; else if (S_AXI_BREADY) axil_bvalid <= 0;",
            "assign S_AXI_BVALID = axil_bvalid;",
            "assign S_AXI_BRESP = 2'b00; // }}} // // Read signaling // // {{{ generate if (OPT_SKIDBUFFER) begin : SKIDBUFFER_READ",
            "wire arskd_valid; skidbuffer #(.OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(C_AXI_ADDR_WIDTH-ADDRLSB)) axilarskid(// .i_clk(S_AXI_ACLK), .i_reset(i_reset), .i_valid(S_AXI_ARVALID), .o_ready(S_AXI_ARREADY), .i_data(S_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB]), .o_valid(arskd_valid), .i_ready(axil_read_ready), .o_data(arskd_addr));",
            "assign axil_read_ready = arskd_valid && (!axil_read_valid || S_AXI_RREADY); end else begin : SIMPLE_READS",
            "reg axil_arready;",
            "always @(*) axil_arready = !S_AXI_RVALID;",
            "assign arskd_addr = S_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB];",
            "assign S_AXI_ARREADY = axil_arready;",
            "assign axil_read_ready = (S_AXI_ARVALID && S_AXI_ARREADY); end endgenerate",
            "initial axil_read_valid = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (i_reset) axil_read_valid <= 1'b0; else if (axil_read_ready) axil_read_valid <= 1'b1; else if (S_AXI_RREADY) axil_read_valid <= 1'b0;",
            "assign S_AXI_RVALID = axil_read_valid;",
            "assign S_AXI_RDATA = axil_read_data;",
            "assign S_AXI_RRESP = 2'b00; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // AXI-lite",
            "reg ister",
            "logic // {{{ //////////////////////////////////////////////////////////////////////// // // //////////////////////////////////////////////////////////////////////// // // Interrupt handling // {{{ //////////////////////////////////////////////////////////////////////// // // reg [30:0] int_vector; // Generate the interrupt vector // {{{ generate if (EXTERNAL_INTERRUPTS == 0) begin : NO_EXTERNAL_INTERRUPTS // {{{",
            "always @(*) begin int_vector = 0; int_vector[5:0] = { apic_int, tmra_int, tmrb_int, tmrc_int, jif_int, 1'b0 }; end // }}} end else if (EXTERNAL_INTERRUPTS == 1) begin : SINGLE_EXTERNAL_INTERRUPT // {{{",
            "always @(*) begin int_vector = 0; int_vector[5:0] = { apic_int, tmra_int, tmrb_int, tmrc_int, jif_int, i_ivec[0] }; end // }}} end else begin : MANY_EXTERNAL_INTERRUPTS // {{{",
            "always @(*) begin int_vector = 0; int_vector[5:0] = { apic_int, tmra_int, tmrb_int, tmrc_int, jif_int, i_ivec[0] }; int_vector[EXTERNAL_INTERRUPTS+5-1:6] = i_ivec[EXTERNAL_INTERRUPTS-1:1]; end // }}} end endgenerate // }}} icontrol #(.IUSED(15)) pic( // {{{ .i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset), .i_wb_cyc(axil_write_ready), .i_wb_stb(axil_write_ready && awskd_addr == ADR_PIC), .i_wb_we(1'b1), .i_wb_data(wskd_data), .i_wb_sel(wskd_strb), .o_wb_stall(pic_stall), .o_wb_ack(pic_ack),.o_wb_data(pic_data), .i_brd_ints(int_vector[14:0]), .o_interrupt(o_interrupt) // }}} ); ziptimer #(32,31,0) watchdog( // {{{ .i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset), .i_ce(!i_cpu_halted), .i_wb_cyc(1'b1), .i_wb_stb(axil_write_ready && awskd_addr == ADR_WATCHDOG), .i_wb_we(1'b1), .i_wb_data(wskd_data), .i_wb_sel(wskd_strb), .o_wb_stall(wdog_stall), .o_wb_ack(wdog_ack), .o_wb_data(wdog_data), .o_int(o_watchdog_reset) // }}} ); // APIC // {{{ generate if (EXTERNAL_INTERRUPTS > 15) begin : APIC icontrol #(.IUSED(15)) apic( // {{{ .i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset), .i_wb_cyc(axil_write_ready), .i_wb_stb(axil_write_ready && awskd_addr == ADR_APIC), .i_wb_we(1'b1), .i_wb_data(wskd_data), .i_wb_sel(wskd_strb), .o_wb_stall(apic_stall), .o_wb_ack(apic_ack), .o_wb_data(apic_data), .i_brd_ints(int_vector[30:15]), .o_interrupt(o_interrupt) // }}} ); end else begin : NO_APIC",
            "assign apic_data = 0;",
            "assign apic_stall = 0;",
            "assign apic_ack = 0;",
            "assign apic_int = 0; end endgenerate // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Timers // {{{ //////////////////////////////////////////////////////////////////////// // // ziptimer timer_a( // {{{ .i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset), .i_ce(!i_cpu_halted), .i_wb_cyc(1'b1), .i_wb_stb(axil_write_ready && awskd_addr == ADR_TIMERA), .i_wb_we(1'b1), .i_wb_data(wskd_data), .i_wb_sel(wskd_strb), .o_wb_stall(tmra_stall), .o_wb_ack(tmra_ack), .o_wb_data(tmra_data), .o_int(tmra_int) // }}} ); ziptimer timer_b( // {{{ .i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset), .i_ce(!i_cpu_halted), .i_wb_cyc(1'b1), .i_wb_stb(axil_write_ready && awskd_addr == ADR_TIMERB), .i_wb_we(1'b1), .i_wb_data(wskd_data), .i_wb_sel(wskd_strb), .o_wb_stall(tmrb_stall), .o_wb_ack(tmrb_ack), .o_wb_data(tmrb_data), .o_int(tmrb_int) // }}} ); ziptimer timer_c( // {{{ .i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset), .i_ce(!i_cpu_halted), .i_wb_cyc(1'b1), .i_wb_stb(axil_write_ready && awskd_addr == ADR_TIMERC), .i_wb_we(1'b1), .i_wb_data(wskd_data), .i_wb_sel(wskd_strb), .o_wb_stall(tmrc_stall), .o_wb_ack(tmrc_ack), .o_wb_data(tmrc_data), .o_int(tmrc_int) // }}} ); zipjiffies jiffies( // {{{ .i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset), .i_ce(!i_cpu_halted), .i_wb_cyc(1'b1), .i_wb_stb(axil_write_ready && awskd_addr == ADR_JIFFIES), .i_wb_we(1'b1), .i_wb_data(wskd_data), .i_wb_sel(wskd_strb), .o_wb_stall(jif_stall), .o_wb_ack(jif_ack), .o_wb_data(jif_data), .o_int(jif_int) // }}} ); // }}} //////////////////////////////////////////////////////////////////////// // // Optional performance counters // {{{ //////////////////////////////////////////////////////////////////////// // // wire [31:0] mtask, mopstall, mpfstall, micount;",
            "wire [31:0] utask, uopstall, upfstall, uicount; generate if (OPT_COUNTERS) begin : ACCOUNTING_COUNTERS // {{{",
            "reg [31:0] r_mtask, r_mopstall, r_mpfstall, r_micount;",
            "reg [31:0] r_utask, r_uopstall, r_upfstall, r_uicount;",
            "initial { r_mtask, r_mopstall, r_mpfstall, r_micount } = 0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset) { r_mtask, r_mopstall, r_mpfstall, r_micount } <= 0; else begin if (!i_cpu_halted) r_mtask <= r_mtask + 1; if (i_cpu_opstall) r_mopstall <= mopstall + 1; if (i_cpu_pfstall) r_mpfstall <= r_mpfstall + 1; if (i_cpu_icount) r_micount <= r_micount + 1; if (axil_write_ready) case(awskd_addr) ADR_MCLOCKS: begin // {{{ if(wskd_strb[0]) r_mtask[ 7: 0]<=wskd_data[ 7: 0]; if(wskd_strb[1]) r_mtask[15: 8]<=wskd_data[15: 8]; if(wskd_strb[2]) r_mtask[23:16]<=wskd_data[23:16]; if(wskd_strb[3]) r_mtask[31:24]<=wskd_data[31:24]; end // }}} ADR_MOPSTALL: begin // {{{ if(wskd_strb[0]) r_mopstall[ 7: 0]<=wskd_data[ 7: 0]; if(wskd_strb[1]) r_mopstall[15: 8]<=wskd_data[15: 8]; if(wskd_strb[2]) r_mopstall[23:16]<=wskd_data[23:16]; if(wskd_strb[3]) r_mopstall[31:24]<=wskd_data[31:24]; end // }}} ADR_MPFSTALL: begin // {{{ if(wskd_strb[0]) r_mpfstall[ 7: 0]<=wskd_data[ 7: 0]; if(wskd_strb[1]) r_mpfstall[15: 8]<=wskd_data[15: 8]; if(wskd_strb[2]) r_mpfstall[23:16]<=wskd_data[23:16]; if(wskd_strb[3]) r_mpfstall[31:24]<=wskd_data[31:24]; end // }}} ADR_MICOUNT: begin // {{{ if(wskd_strb[0]) r_micount[ 7: 0]<=wskd_data[ 7: 0]; if(wskd_strb[1]) r_micount[15: 8]<=wskd_data[15: 8]; if(wskd_strb[2]) r_micount[23:16]<=wskd_data[23:16]; if(wskd_strb[3]) r_micount[31:24]<=wskd_data[31:24]; end // }}} default: begin end endcase end",
            "initial { r_utask, r_uopstall, r_upfstall, r_uicount } = 0;",
            "always @(posedge S_AXI_ACLK) if (i_cpu_reset) { r_utask, r_uopstall, r_upfstall, r_uicount } <= 0; else begin if (!i_cpu_halted && i_cpu_gie) r_utask <= r_utask + 1; if (i_cpu_opstall && i_cpu_gie) r_uopstall <= r_uopstall + 1; if (i_cpu_pfstall && i_cpu_gie) r_upfstall <= r_upfstall + 1; if (i_cpu_icount && i_cpu_gie) r_uicount <= r_uicount + 1; if (axil_write_ready) case(awskd_addr) ADR_UCLOCKS: begin // {{{ if(wskd_strb[0]) r_utask[ 7: 0]<=wskd_data[ 7: 0]; if(wskd_strb[1]) r_utask[15: 8]<=wskd_data[15: 8]; if(wskd_strb[2]) r_utask[23:16]<=wskd_data[23:16]; if(wskd_strb[3]) r_utask[31:24]<=wskd_data[31:24]; end // }}} ADR_UOPSTALL: begin // {{{ if(wskd_strb[0]) r_uopstall[ 7: 0]<=wskd_data[ 7: 0]; if(wskd_strb[1]) r_uopstall[15: 8]<=wskd_data[15: 8]; if(wskd_strb[2]) r_uopstall[23:16]<=wskd_data[23:16]; if(wskd_strb[3]) r_uopstall[31:24]<=wskd_data[31:24]; end // }}} ADR_UPFSTALL: begin // {{{ if(wskd_strb[0]) r_upfstall[ 7: 0]<=wskd_data[ 7: 0]; if(wskd_strb[1]) r_upfstall[15: 8]<=wskd_data[15: 8]; if(wskd_strb[2]) r_upfstall[23:16]<=wskd_data[23:16]; if(wskd_strb[3]) r_upfstall[31:24]<=wskd_data[31:24]; end // }}} ADR_UICOUNT: begin // {{{ if(wskd_strb[0]) r_uicount[ 7: 0]<=wskd_data[ 7: 0]; if(wskd_strb[1]) r_uicount[15: 8]<=wskd_data[15: 8]; if(wskd_strb[2]) r_uicount[23:16]<=wskd_data[23:16]; if(wskd_strb[3]) r_uicount[31:24]<=wskd_data[31:24]; end // }}} default: begin end endcase end",
            "assign { mtask, mopstall, mpfstall, micount } = { r_mtask, r_mopstall, r_mpfstall, r_micount };",
            "assign { utask, uopstall, upfstall, uicount } = { r_utask, r_uopstall, r_upfstall, r_uicount }; // }}} end else begin : NO_ACCOUNTING",
            "assign { mtask, mopstall, mpfstall, micount } = 0;",
            "assign { utask, uopstall, upfstall, uicount } = 0; end endgenerate // }}} // axil_read_data // {{{",
            "initial axil_read_data = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) axil_read_data <= 0; else if (!S_AXI_RVALID || S_AXI_RREADY) begin axil_read_data <= 0; case({ (OPT_COUNTERS & arskd_addr[3]), arskd_addr[2:0] }) ADR_PIC: axil_read_data <= pic_data; ADR_WATCHDOG: axil_read_data <= wdog_data; // 3'b10: axil_read_data <= watchdog_data; ADR_APIC: axil_read_data <= apic_data; ADR_TIMERA: axil_read_data <= tmra_data; ADR_TIMERB: axil_read_data <= tmrb_data; ADR_TIMERC: axil_read_data <= tmrc_data; ADR_JIFFIES: axil_read_data <= jif_data; // Supervisor counters ADR_MCLOCKS: axil_read_data <= mtask; ADR_MOPSTALL: axil_read_data <= mopstall; ADR_MPFSTALL: axil_read_data <= mpfstall; ADR_MICOUNT: axil_read_data <= micount; // User counters ADR_UCLOCKS: axil_read_data <= utask; ADR_UOPSTALL: axil_read_data <= uopstall; ADR_UPFSTALL: axil_read_data <= upfstall; ADR_UICOUNT: axil_read_data <= uicount; default: axil_read_data <= 0; endcase if (OPT_LOWPOWER && !axil_read_ready) axil_read_data <= 0; end // }}} // apply_wstrb // {{{ // Verilator coverage_off function automatic [C_AXI_DATA_WIDTH-1:0] apply_wstrb;",
            "input [C_AXI_DATA_WIDTH-1:0] prior_data;",
            "input [C_AXI_DATA_WIDTH-1:0] new_data;",
            "input [C_AXI_DATA_WIDTH/8-1:0] wstrb; integer k; for(k=0; k<C_AXI_DATA_WIDTH/8; k=k+1) begin apply_wstrb[k*8 +: 8] = wstrb[k] ? new_data[k*8 +: 8] : prior_data[k*8 +: 8]; end endfunction // Verilator coverage_on // }}} // }}} // Make Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, S_AXI_AWPROT, S_AXI_ARPROT, S_AXI_ARADDR[ADDRLSB-1:0], S_AXI_AWADDR[ADDRLSB-1:0], wskd_strb, int_vector[30:6], int_vector[0], pic_stall, wdog_stall, apic_stall, pic_ack, wdog_ack, apic_ack, tmra_stall, tmrb_stall, tmrc_stall, jif_stall, tmra_ack, tmrb_ack, tmrc_ack, jif_ack }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} `ifdef FORMAL //////////////////////////////////////////////////////////////////////// // // Formal properties used in verfiying this core // //////////////////////////////////////////////////////////////////////// // // {{{",
            "reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge S_AXI_ACLK) f_past_valid <= 1; //////////////////////////////////////////////////////////////////////// // // The AXI-lite control interface // //////////////////////////////////////////////////////////////////////// // // {{{",
            "localparam F_AXIL_LGDEPTH = 4;",
            "wire [F_AXIL_LGDEPTH-1:0] faxil_rd_outstanding, faxil_wr_outstanding, faxil_awr_outstanding; faxil_slave #( // {{{ .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH), .F_LGDEPTH(F_AXIL_LGDEPTH), .F_AXI_MAXWAIT(2), .F_AXI_MAXDELAY(2), .F_AXI_MAXRSTALL(3), .F_OPT_COVER_BURST(4) // }}} ) faxil( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // .i_axi_awvalid(S_AXI_AWVALID), .i_axi_awready(S_AXI_AWREADY), .i_axi_awaddr( S_AXI_AWADDR), .i_axi_awprot( S_AXI_AWPROT), // .i_axi_wvalid(S_AXI_WVALID), .i_axi_wready(S_AXI_WREADY), .i_axi_wdata( S_AXI_WDATA), .i_axi_wstrb( S_AXI_WSTRB), // .i_axi_bvalid(S_AXI_BVALID), .i_axi_bready(S_AXI_BREADY), .i_axi_bresp( S_AXI_BRESP), // .i_axi_arvalid(S_AXI_ARVALID), .i_axi_arready(S_AXI_ARREADY), .i_axi_araddr( S_AXI_ARADDR), .i_axi_arprot( S_AXI_ARPROT), // .i_axi_rvalid(S_AXI_RVALID), .i_axi_rready(S_AXI_RREADY), .i_axi_rdata( S_AXI_RDATA), .i_axi_rresp( S_AXI_RRESP), // .f_axi_rd_outstanding(faxil_rd_outstanding), .f_axi_wr_outstanding(faxil_wr_outstanding), .f_axi_awr_outstanding(faxil_awr_outstanding) // }}} );",
            "always @(*) if (OPT_SKIDBUFFER) begin assert(faxil_awr_outstanding== (S_AXI_BVALID ? 1:0) +(S_AXI_AWREADY ? 0:1)); assert(faxil_wr_outstanding == (S_AXI_BVALID ? 1:0) +(S_AXI_WREADY ? 0:1)); assert(faxil_rd_outstanding == (S_AXI_RVALID ? 1:0) +(S_AXI_ARREADY ? 0:1)); end else begin assert(faxil_wr_outstanding == (S_AXI_BVALID ? 1:0)); assert(faxil_awr_outstanding == faxil_wr_outstanding); assert(faxil_rd_outstanding == (S_AXI_RVALID ? 1:0)); end // // Check that our low-power only",
            "logic works by verifying that anytime // S_AXI_RVALID is inactive, then the outgoing data is also zero. // always @(*) if (OPT_LOWPOWER && !S_AXI_RVALID) assert(S_AXI_RDATA == 0); // }}} //////////////////////////////////////////////////////////////////////// // // Cover checks // //////////////////////////////////////////////////////////////////////// // // {{{ // While there are already cover properties in the formal property // set above, you'll probably still want to cover something // application specific here // }}} // }}} `endif",
            "endmodule"
        ]
    },
    {
        "file_name": "wbwatchdog.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/wbwatchdog.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: wbwatchdog.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A Zip timer, redesigned to be a bus watchdog // // This is basically a timer, but there are some unique features to it. // // 1. There is no way to \"write\" the timeout to this watchdog. It is // fixed with an",
            "input (that is assumed to be constant) // 2. The counter returns to i_timer and the interrupt is cleared on any // reset. // 3. Between resets, the counter counts down to zero. Once (and if) it // hits zero, it will remain at zero until reset. // 4. Any time the counter is at zero, and until the reset that resets // the counter, the",
            "output interrupt will be set. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module wbwatchdog #(",
            "parameter BW = 32 ) ( // {{{",
            "input wire i_clk, i_reset, // Inputs (these were at one time wishbone controlled ...)",
            "input wire [(BW-1):0] i_timeout, // Interrupt line",
            "output reg o_int // }}} );",
            "reg [(BW-1):0] r_value; // r_value // {{{",
            "initial r_value = {(BW){1'b1}};",
            "always @(posedge i_clk) if (i_reset) r_value <= i_timeout[(BW-1):0]; else if (!o_int) r_value <= r_value + {(BW){1'b1}}; // r_value - 1; // }}} // Set the interrupt on our last tick. // {{{",
            "initial o_int = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_int <= 1'b0; else if (!o_int) o_int <= (r_value == { {(BW-1){1'b0}}, 1'b1 }); // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "reg f_past_valid;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1; //////////////////////////////////////////////////////////////////////// // // Assumptions about our",
            "input s // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) assume(i_timeout > 1);",
            "always @(posedge i_clk) if (f_past_valid) assume(i_timeout == $past(i_timeout)); // }}} //////////////////////////////////////////////////////////////////////// // // Assertions about our internal state and our",
            "output s // {{{ //////////////////////////////////////////////////////////////////////// // // always @(posedge i_clk) if ((f_past_valid)&&($past(o_int))&&(!$past(i_reset))) assert(o_int);",
            "always @(*) assert(o_int == (r_value == 0));",
            "always @(posedge i_clk) if ((f_past_valid)&&(!$past(i_reset))&&(!$past(o_int))) begin assert(r_value == $past(r_value)-1'b1); end",
            "always @(posedge i_clk) if ((!f_past_valid)||($past(i_reset))) begin if (!f_past_valid) begin assert(r_value == {(BW){1'b1}}); end else // if ($past(i_reset)) assert(r_value == $past(i_timeout)); assert(!o_int); end // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "wbdown.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/wbdown.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: wbdown.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Downconvert a Wishbone bus from a wider width to a smaller one. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2022-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module wbdown #( // {{{",
            "parameter ADDRESS_WIDTH = 28, // Byte address width",
            "parameter WIDE_DW = 64, parameter SMALL_DW = 32, parameter [0:0] OPT_LITTLE_ENDIAN = 1'b0, parameter [0:0] OPT_LOWPOWER = 1'b0, parameter [0:0] OPT_LOWLOGIC = 1'b0, localparam WIDE_AW = ADDRESS_WIDTH-$clog2(WIDE_DW/8), localparam SMALL_AW = ADDRESS_WIDTH-$clog2(SMALL_DW/8) // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // Incoming wide port // {{{",
            "input wire i_wcyc, i_wstb, i_wwe, input wire [WIDE_AW-1:0] i_waddr, input wire [WIDE_DW-1:0] i_wdata, input wire [WIDE_DW/8-1:0] i_wsel, output wire o_wstall, output wire o_wack, output wire [WIDE_DW-1:0] o_wdata, output wire o_werr, // }}} // Outgoing, small bus size, port // {{{",
            "output wire o_cyc, o_stb, o_we, output wire [SMALL_AW-1:0] o_addr, output wire [SMALL_DW-1:0] o_data, output wire [SMALL_DW/8-1:0] o_sel, input wire i_stall, input wire i_ack, input wire [SMALL_DW-1:0] i_data, input wire i_err // }}} // }}} ); // Verilator lint_off UNUSED",
            "localparam WBLSB = $clog2(WIDE_DW/SMALL_DW); // Verilator lint_on UNUSED generate if (WIDE_DW == SMALL_DW) begin : NO_ADJUSTMENT // {{{",
            "assign o_cyc = i_wcyc;",
            "assign o_stb = i_wstb;",
            "assign o_we = i_wwe;",
            "assign o_addr = i_waddr;",
            "assign o_data = i_wdata;",
            "assign o_sel = i_wsel;",
            "assign o_wstall = i_stall;",
            "assign o_wack = i_ack;",
            "assign o_wdata = i_data;",
            "assign o_werr = i_err; // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_clk, i_reset }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} // }}} end else if (OPT_LOWLOGIC) begin : CHEAP_DOWNSIZER // {{{ // Local declarations // {{{",
            "localparam LGFIFO = 5;",
            "reg r_cyc, r_stb, r_we, r_ack, r_err;",
            "reg [SMALL_AW-1:0] r_addr;",
            "reg [WIDE_DW-1:0] s_data, r_data;",
            "reg [WIDE_DW/8-1:0] s_sel;",
            "reg [WBLSB:0] s_count;",
            "wire fifo_full, ign_fifo_empty, fifo_ack;",
            "wire [LGFIFO:0] ign_fifo_fill; `ifdef FORMAL",
            "wire [LGFIFO:0] f_first_addr, f_second_addr;",
            "wire f_first_data, f_second_data;",
            "wire f_first_in_fifo, f_second_in_fifo;",
            "wire [LGFIFO:0] f_distance_to_first, f_distance_to_second; `endif // }}} // r_cyc // {{{",
            "initial r_cyc = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !i_wcyc ||(o_cyc && i_err) || o_werr) r_cyc <= 1'b0; else if (i_wcyc && i_wstb) r_cyc <= 1'b1; // }}}",
            "initial r_stb = 1'b0;",
            "initial r_we = 1'b0;",
            "initial r_addr = 0;",
            "initial s_data = 0;",
            "initial s_sel = 0;",
            "initial s_count = 0;",
            "always @(posedge i_clk) if (i_reset || !i_wcyc || o_werr || (o_cyc && i_err)) begin // {{{ r_stb <= 1'b0; r_we <= 1'b0; r_addr <= 0; s_data <= 0; s_sel <= 0; s_count <= 0; // }}} end else if (i_wstb && !o_wstall) // New request begin // {{{ r_stb <= 1'b1; r_we <= i_wwe; r_addr <= { i_waddr, {($clog2(WIDE_DW/SMALL_DW)){1'b0}} }; s_data <= i_wdata; s_sel <= i_wsel; // Verilator lint_off WIDTH s_count <= (WIDE_DW/SMALL_DW); // Verilator lint_on WIDTH // }}} end else if (o_stb && !i_stall) begin // {{{ s_count <= s_count - 1; r_stb <= (s_count > 1); r_addr[$clog2(WIDE_DW/SMALL_DW)-1:0] <= r_addr[$clog2(WIDE_DW/SMALL_DW)-1:0] + 1; if (OPT_LITTLE_ENDIAN) begin // Verilator coverage_off s_data <= s_data >> SMALL_DW; s_sel <= s_sel >> (SMALL_DW/8); // Verilator coverage_on end else begin s_data <= s_data << SMALL_DW; s_sel <= s_sel << (SMALL_DW/8); end // }}} end",
            "assign o_cyc = r_cyc;",
            "assign o_stb = r_stb && !fifo_full;",
            "assign o_we = r_we;",
            "assign o_addr= r_addr; if (OPT_LITTLE_ENDIAN) begin : OPT_LILEND_DATA // Verilator coverage_off",
            "assign o_data = s_data[SMALL_DW-1:0];",
            "assign o_sel = s_sel[SMALL_DW/8-1:0]; // Verilator coverage_on end else begin : OPT_BIGEND_DATA",
            "assign o_data =s_data[WIDE_DW-1:WIDE_DW-SMALL_DW];",
            "assign o_sel =s_sel[WIDE_DW/8-1:(WIDE_DW-SMALL_DW)/8]; end sfifo #( .BW(1), .LGFLEN(LGFIFO), .OPT_WRITE_ON_FULL(1'b1), .OPT_READ_ON_EMPTY(1'b1) ) u_fifo ( // {{{ .i_clk(i_clk), .i_reset(i_reset || !i_wcyc), .i_wr(o_stb && !i_stall), .i_data({ (s_count == 1) ? 1'b1 : 1'b0 }), .o_full(fifo_full), .o_fill(ign_fifo_fill), .i_rd(i_ack), .o_data(fifo_ack), .o_empty(ign_fifo_empty) `ifdef FORMAL , .f_first_addr(f_first_addr), .f_second_addr(f_second_addr), .f_first_data(f_first_data), .f_second_data(f_second_data), .f_first_in_fifo(f_first_in_fifo), .f_second_in_fifo(f_second_in_fifo), .f_distance_to_first(f_distance_to_first), .f_distance_to_second(f_distance_to_second) `endif // }}} ); // r_data // {{{",
            "initial r_data = 0;",
            "always @(posedge i_clk) if (OPT_LOWPOWER && (!i_wcyc || !o_cyc || i_err)) r_data <= 0; else if (i_ack) begin if (OPT_LITTLE_ENDIAN) // Verilator coverage_off r_data<= { i_data, r_data[WIDE_DW-1:SMALL_DW] }; // Verilator coverage_on else r_data<={r_data[WIDE_DW-SMALL_DW-1:0], i_data }; end // }}} // r_ack // {{{",
            "initial r_ack = 0;",
            "always @(posedge i_clk) if (i_reset || !i_wcyc || !o_cyc) r_ack <= 1'b0; else r_ack <= i_ack && fifo_ack; // }}} // r_err // {{{",
            "initial r_err = 0;",
            "always @(posedge i_clk) if (i_reset || !i_wcyc || !o_cyc) r_err <= 1'b0; else r_err <= i_err; // }}}",
            "assign o_wdata = r_data;",
            "assign o_wack = r_ack;",
            "assign o_werr = r_err;",
            "assign o_wstall = (r_stb && (fifo_full || i_stall)) || (s_count > 1); // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, ign_fifo_fill, ign_fifo_empty }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "parameter F_LGDEPTH = LGFIFO+1;",
            "reg f_past_valid;",
            "wire [F_LGDEPTH-1:0] fslv_nreqs, fslv_nacks,fslv_outstanding;",
            "wire [F_LGDEPTH-1:0] fmst_nreqs, fmst_nacks,fmst_outstanding;",
            "wire f_first_ack, f_second_ack;",
            "reg [LGFIFO:0] f_acks_in_fifo;",
            "reg [WBLSB-1:0] f_first_subaddr, f_second_subaddr, f_this_subaddr;",
            "reg [WIDE_DW/8-1:0] f_mask;",
            "reg f_subsequent;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1;",
            "always @(*) if (!f_past_valid) assume(i_reset); fwb_slave #( .AW(WIDE_AW), .DW(WIDE_DW), ) fslv ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // .i_wb_cyc(i_wcyc), .i_wb_stb(i_wstb), .i_wb_we(i_wwe), .i_wb_addr(i_waddr), .i_wb_data(i_wdata), .i_wb_sel(i_wsel), .i_wb_stall(o_wstall), .i_wb_ack(o_wack), .i_wb_idata(o_wdata), .i_wb_err(o_werr), // .f_nreqs(fslv_nreqs), .f_nacks(fslv_nacks), .f_outstanding(fslv_outstanding) // }}} ); fwb_master #( .AW(SMALL_AW), .DW(SMALL_DW), ) fmst ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // .i_wb_cyc(o_cyc), .i_wb_stb(o_stb), .i_wb_we(o_we), .i_wb_addr(o_addr), .i_wb_data(o_data), .i_wb_sel(o_sel), .i_wb_stall(i_stall), .i_wb_ack(i_ack), .i_wb_idata(i_data), .i_wb_err(i_err), // .f_nreqs(fmst_nreqs), .f_nacks(fmst_nacks), .f_outstanding(fmst_outstanding) // }}} );",
            "always @(*) if (r_stb) begin assert(s_count > 0); end else begin assert(s_count == 0); end",
            "always @(*) if (!i_reset && o_cyc && i_wcyc) assert(ign_fifo_fill == fmst_outstanding);",
            "always @(*) if (!i_reset && !o_cyc && i_wcyc && !o_werr) assert(ign_fifo_fill == 0);",
            "always @(*) if (!o_cyc) assert(!r_stb);",
            "always @(*) if ((r_stb || fslv_outstanding > 0) && i_wcyc && o_cyc) assert(o_we == i_wwe);",
            "always @(*) if (i_wcyc && fslv_outstanding > 0 && !o_werr) assert(o_cyc);",
            "initial f_acks_in_fifo = 0;",
            "always @(posedge i_clk) if (i_reset || !i_wcyc) f_acks_in_fifo <= 0; else case({ o_stb && !i_stall && (s_count == 1), (i_ack && fifo_ack) }) 2'b01: f_acks_in_fifo <= f_acks_in_fifo - 1; 2'b10: f_acks_in_fifo <= f_acks_in_fifo + 1; endcase",
            "always @(*) if (!i_reset && i_wcyc && o_cyc) begin assert(f_acks_in_fifo + (s_count > 0 ? 1:0) + (o_wack ? 1:0) == fslv_outstanding); if (s_count == 0 && fslv_outstanding > (o_wack ? 1:0)) assert(f_acks_in_fifo > 0); end",
            "assign f_first_ack = f_first_data;",
            "assign f_second_ack = f_second_data;",
            "always @(*) begin // f_first_subaddr = f_first_data[WBLSB-1:0]; // f_second_subaddr = f_second_data[WBLSB-1:0]; f_first_subaddr = (r_stb ? o_addr[WBLSB-1:0] : {(WBLSB){1'b0}}) - ign_fifo_fill[WBLSB-1:0] + f_distance_to_first[WBLSB-1:0]; f_second_subaddr = (r_stb ? o_addr[WBLSB-1:0] : {(WBLSB){1'b0}}) - ign_fifo_fill[WBLSB-1:0] + f_distance_to_second[WBLSB-1:0]; f_this_subaddr = (r_stb ? o_addr[WBLSB-1:0] : {(WBLSB){1'b0}}) - ign_fifo_fill[WBLSB-1:0]; end",
            "always @(*) begin if (!i_reset && o_cyc && i_wcyc && f_first_in_fifo) begin assert(f_first_ack == (&f_first_subaddr[WBLSB-1:0])); end if (!i_reset && o_cyc && i_wcyc && f_second_in_fifo) begin assert(f_second_ack == (&f_second_subaddr[WBLSB-1:0])); end assert(f_acks_in_fifo <= ign_fifo_fill); assert(!ign_fifo_empty || f_acks_in_fifo == 0); assert(f_acks_in_fifo >= ((f_first_in_fifo && f_first_ack) ? 1:0) + ((f_second_in_fifo && f_second_ack) ? 1:0)); assert(ign_fifo_fill - f_acks_in_fifo >= ((f_first_in_fifo && !f_first_ack) ? 1:0) + ((f_second_in_fifo && !f_second_ack) ? 1:0)); if (o_cyc && f_first_in_fifo && f_distance_to_first == ign_fifo_fill - 1) assert(f_first_ack || s_count > 0); if (o_cyc && f_second_in_fifo && f_distance_to_second == ign_fifo_fill - 1) assert(f_second_ack || s_count > 0); if (!i_reset && i_wcyc && o_cyc && ign_fifo_fill > 0 && s_count == 0) assert(f_acks_in_fifo > 0); if (o_cyc&& i_wcyc && f_first_in_fifo && s_count == 0 && !o_werr && f_distance_to_first + 1 < ign_fifo_fill) assert(f_acks_in_fifo > (f_first_ack ? 1:0)); if (o_cyc && i_wcyc && f_second_in_fifo && s_count == 0 && !o_werr && f_distance_to_second + 1 < ign_fifo_fill) assert(f_acks_in_fifo > ((f_first_in_fifo && f_first_ack) ? 1:0) + (f_second_ack ? 1:0)); end",
            "always @(*) begin if (f_second_in_fifo) f_subsequent = (f_distance_to_second + 1 < ign_fifo_fill); else if (f_first_in_fifo) f_subsequent = (f_distance_to_first + 1 < ign_fifo_fill); else f_subsequent = (f_acks_in_fifo > 0 && s_count == 0); end",
            "always @(*) if ((!f_first_in_fifo || f_distance_to_first > 0) &&(!f_second_in_fifo || f_distance_to_second > 0) && !ign_fifo_empty) begin assume(!fifo_ack || (f_acks_in_fifo > ((f_subsequent) ? 1:0) + ((f_first_in_fifo && f_first_ack) ? 1:0) + ((f_second_in_fifo && f_second_ack) ? 1:0))); assume(fifo_ack || (ign_fifo_fill - f_acks_in_fifo > ((f_first_in_fifo && !f_first_ack) ? 1:0) + ((f_second_in_fifo && !f_second_ack) ? 1:0))); if (f_acks_in_fifo == 1 && s_count == 0 && ign_fifo_fill > 1) assume(!fifo_ack); assume(fifo_ack == (&f_this_subaddr)); end",
            "always @(*) if (!i_reset && o_cyc && i_wcyc) begin if (f_first_in_fifo && f_second_in_fifo) begin assert(f_second_subaddr > f_first_subaddr || f_first_ack); end else if (f_first_in_fifo && !f_first_ack) begin assert(s_count > 0 && o_addr[WBLSB-1:0] > f_first_subaddr); end end",
            "always @(*) if (!i_reset && o_cyc && i_wcyc) begin assert(s_count <= (1<<WBLSB)); if (r_stb) assert(s_count+o_addr[WBLSB-1:0] == (1<<WBLSB)); end",
            "always @(*) if (!i_reset && o_cyc && i_wcyc && f_first_in_fifo && f_second_in_fifo) begin assert(f_second_subaddr > f_first_subaddr || f_first_ack); end",
            "always @(*) if (OPT_LITTLE_ENDIAN) // Verilator coverage_off f_mask = {(WIDE_DW/8){1'b1}} >> (o_addr[WBLSB-1:0] * SMALL_DW/8); // Verilator coverage_on else f_mask = {(WIDE_DW/8){1'b1}} << (o_addr[WBLSB-1:0] * SMALL_DW/8);",
            "always @(*) if (s_count > 0) begin assert((s_sel & (~f_mask)) == 0); end `endif // }}} // }}} end else begin : DOWNSIZE // {{{ // Local declarations // {{{",
            "localparam LGFIFO = 5;",
            "reg r_cyc, r_stb, r_we, r_ack, r_err;",
            "reg [SMALL_AW-1:0] r_addr;",
            "reg s_null;",
            "reg [WIDE_DW-1:0] s_data, r_data, nxt_mask, nxt_data;",
            "wire [WIDE_DW/8-1:0] i_nxtsel, s_nxtsel;",
            "reg [WIDE_DW/8-1:0] s_sel;",
            "reg [WBLSB:0] s_count;",
            "wire [WBLSB-1:0] fifo_addr, i_subaddr,s_subaddr;",
            "wire fifo_full, fifo_empty, fifo_ack;",
            "wire [LGFIFO:0] ign_fifo_fill; `ifdef FORMAL",
            "wire [LGFIFO:0] f_first_addr, f_second_addr;",
            "wire [WBLSB:0] f_first_data, f_second_data;",
            "wire f_first_in_fifo, f_second_in_fifo;",
            "wire [LGFIFO:0] f_distance_to_first, f_distance_to_second; `endif // }}} // r_cyc // {{{",
            "initial r_cyc = 1'b0;",
            "always @(posedge i_clk) if (i_reset || !i_wcyc ||(o_cyc && i_err) || o_werr) r_cyc <= 1'b0; else if (i_wcyc && i_wstb) r_cyc <= 1'b1; // }}} // i_subaddr, s_subaddr, i_nxtsel, s_nxtsel // {{{",
            "assign i_subaddr = subaddr_fn(i_wsel); if (OPT_LITTLE_ENDIAN) begin : OPT_LILEND_SHIFT",
            "assign i_nxtsel = i_wsel >> (i_subaddr * SMALL_DW/8);",
            "assign s_subaddr= 1 + subaddr_fn({ {(SMALL_DW/8){1'b0}}, s_sel[WIDE_DW/8-1:SMALL_DW/8] });",
            "assign s_nxtsel = s_sel >> (s_subaddr * SMALL_DW/8); end else begin : OPT_BIGEND_SHIFT",
            "assign i_nxtsel = i_wsel << (i_subaddr * SMALL_DW/8);",
            "assign s_subaddr= 1 + subaddr_fn( { s_sel[WIDE_DW/8-SMALL_DW/8-1:0], {(SMALL_DW/8){1'b0}} } );",
            "assign s_nxtsel = s_sel << (s_subaddr * SMALL_DW/8); end // }}}",
            "initial r_stb = 1'b0;",
            "initial r_we = 1'b0;",
            "initial r_addr = 0;",
            "initial s_data = 0;",
            "initial s_sel = 0;",
            "initial s_count = 0;",
            "always @(posedge i_clk) if (i_reset || !i_wcyc || o_werr || (o_cyc && i_err)) begin // {{{ r_stb <= 1'b0; r_we <= 1'b0; r_addr <= 0; s_data <= 0; s_sel <= 0; s_count <= 0; s_null <= 0; // }}} end else if (i_wstb && !o_wstall) // New request begin // {{{ r_stb <= (i_wsel != 0); r_we <= i_wwe; r_addr <= { i_waddr, i_subaddr }; s_null <= (i_wsel == 0); // Verilator lint_off WIDTH s_count <= (WIDE_DW/SMALL_DW) - i_subaddr; // Verilator lint_on WIDTH if (OPT_LITTLE_ENDIAN) begin // Verilator coverage_off s_data <= i_wdata >> (i_subaddr * SMALL_DW); s_sel <= i_nxtsel; if (i_nxtsel[WIDE_DW/8-1:SMALL_DW/8] == 0) s_count <= 1; // Verilator coverage_on end else begin s_data <= i_wdata << (i_subaddr * SMALL_DW); s_sel <= i_nxtsel; if (i_nxtsel[WIDE_DW/8-SMALL_DW/8-1:0] == 0) s_count <= 1; end if (i_wsel == 0) s_count <= 0; // }}} end else if (o_stb && !i_stall) begin // {{{ s_count <= s_count - s_subaddr; r_stb <= (s_count > 1); r_addr[WBLSB-1:0] <= r_addr[WBLSB-1:0] + s_subaddr; if (OPT_LITTLE_ENDIAN) begin // Verilator coverage_off s_data <= s_data >> (s_subaddr *SMALL_DW); s_sel <= s_nxtsel; if (s_count > 1 && s_nxtsel[WIDE_DW/8-1:SMALL_DW/8] == 0) s_count <= 1; // Verilator coverage_on end else begin s_data <= s_data << (s_subaddr *SMALL_DW); s_sel <= s_nxtsel; if (s_count > 1 && s_nxtsel[WIDE_DW/8-SMALL_DW/8-1:0] == 0) s_count <= 1; end // }}} end else if (fifo_empty) s_null <= 0;",
            "assign o_cyc = r_cyc;",
            "assign o_stb = r_stb && !fifo_full;",
            "assign o_we = r_we;",
            "assign o_addr= r_addr; if (OPT_LITTLE_ENDIAN) begin : OPT_LILODATA",
            "assign o_data = s_data[SMALL_DW-1:0];",
            "assign o_sel = s_sel[SMALL_DW/8-1:0]; end else begin : OPT_BIGODATA",
            "assign o_data =s_data[WIDE_DW-1:WIDE_DW-SMALL_DW];",
            "assign o_sel =s_sel[WIDE_DW/8-1:(WIDE_DW-SMALL_DW)/8]; end sfifo #( .BW(1+WBLSB), .LGFLEN(LGFIFO), .OPT_WRITE_ON_FULL(1'b1), .OPT_READ_ON_EMPTY(1'b1) ) u_fifo ( // {{{ .i_clk(i_clk), .i_reset(i_reset || !i_wcyc), .i_wr(o_stb && !i_stall), .i_data({ {(s_count == 1) ? 1'b1 : 1'b0 }, o_addr[WBLSB-1:0] }), .o_full(fifo_full), .o_fill(ign_fifo_fill), .i_rd(i_ack), .o_data({ fifo_ack, fifo_addr }), .o_empty(fifo_empty) `ifdef FORMAL , .f_first_addr(f_first_addr), .f_second_addr(f_second_addr), .f_first_data(f_first_data), .f_second_data(f_second_data), .f_first_in_fifo(f_first_in_fifo), .f_second_in_fifo(f_second_in_fifo), .f_distance_to_first(f_distance_to_first), .f_distance_to_second(f_distance_to_second) `endif // }}} ); // nxt_data, r_data // {{{",
            "always @(*) begin nxt_data = r_data; if (o_wack) nxt_data = 0; nxt_mask = {(WIDE_DW){1'b0}}; if (i_ack) begin if (OPT_LITTLE_ENDIAN) begin // Verilator coverage_off nxt_mask = { {(WIDE_DW-SMALL_DW){1'b0}}, {(SMALL_DW){1'b1}} }; nxt_mask = nxt_mask << (fifo_addr * SMALL_DW); nxt_mask = ~nxt_mask; nxt_data = (nxt_data & nxt_mask) | ({ {(WIDE_DW-SMALL_DW){1'b0}}, i_data } << (fifo_addr * SMALL_DW)); // Verilator coverage_on end else begin nxt_mask = { {(SMALL_DW){1'b1}}, {(WIDE_DW-SMALL_DW){1'b0}} }; nxt_mask = nxt_mask >> (fifo_addr * SMALL_DW); nxt_mask = ~nxt_mask; nxt_data = (nxt_data & nxt_mask) | ({ i_data, {(WIDE_DW-SMALL_DW){1'b0}} } >> (fifo_addr * SMALL_DW)); end end end",
            "initial r_data = 0;",
            "always @(posedge i_clk) if (i_reset || !i_wcyc || !o_cyc || i_err) r_data <= 0; else r_data <= nxt_data; // }}} // r_ack // {{{",
            "initial r_ack = 0;",
            "always @(posedge i_clk) if (i_reset || !i_wcyc || !o_cyc) r_ack <= 1'b0; else if (!fifo_empty) r_ack <= fifo_ack && i_ack; else r_ack <= s_null; // }}} // r_err // {{{",
            "initial r_err = 0;",
            "always @(posedge i_clk) if (i_reset || !i_wcyc || !o_cyc) r_err <= 0; else r_err <= i_err; // }}}",
            "assign o_wdata = r_data;",
            "assign o_wack = r_ack;",
            "assign o_werr = r_err;",
            "assign o_wstall= (r_stb && (fifo_full || i_stall)) || (s_null && !fifo_empty) || (s_count > 1); function [WBLSB-1:0] subaddr_fn(",
            "input [WIDE_DW/8-1:0] sel); // {{{ integer fnk, fm; begin subaddr_fn = 0; for(fnk=0; fnk<WIDE_DW/SMALL_DW; fnk=fnk+1) begin fm = WIDE_DW/SMALL_DW-1-fnk; if (OPT_LITTLE_ENDIAN) begin // Verilator coverage_off if (sel[fm*SMALL_DW/8 +: SMALL_DW/8] != 0) subaddr_fn = fm[WBLSB-1:0]; // Verilator coverage_on end else begin if (sel[fnk*SMALL_DW/8 +: SMALL_DW/8] != 0) subaddr_fn = fm[WBLSB-1:0]; end end end endfunction // }}} // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, ign_fifo_fill, fifo_empty }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "parameter F_LGDEPTH = LGFIFO+1;",
            "reg f_past_valid;",
            "wire [F_LGDEPTH-1:0] fslv_nreqs, fslv_nacks,fslv_outstanding;",
            "wire [F_LGDEPTH-1:0] fmst_nreqs, fmst_nacks,fmst_outstanding;",
            "wire f_first_ack, f_second_ack;",
            "reg [LGFIFO:0] f_acks_in_fifo;",
            "wire [WBLSB-1:0] f_first_subaddr, f_second_subaddr;",
            "reg [WIDE_DW/8-1:0] f_mask;",
            "reg f_subsequent;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1;",
            "always @(*) if (!f_past_valid) assume(i_reset); fwb_slave #( .AW(WIDE_AW), .DW(WIDE_DW), ) fslv ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // .i_wb_cyc(i_wcyc), .i_wb_stb(i_wstb), .i_wb_we(i_wwe), .i_wb_addr(i_waddr), .i_wb_data(i_wdata), .i_wb_sel(i_wsel), .i_wb_stall(o_wstall), .i_wb_ack(o_wack), .i_wb_idata(o_wdata), .i_wb_err(o_werr), // .f_nreqs(fslv_nreqs), .f_nacks(fslv_nacks), .f_outstanding(fslv_outstanding) // }}} ); fwb_master #( .AW(SMALL_AW), .DW(SMALL_DW), ) fmst ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // .i_wb_cyc(o_cyc), .i_wb_stb(o_stb), .i_wb_we(o_we), .i_wb_addr(o_addr), .i_wb_data(o_data), .i_wb_sel(o_sel), .i_wb_stall(i_stall), .i_wb_ack(i_ack), .i_wb_idata(i_data), .i_wb_err(i_err), // .f_nreqs(fmst_nreqs), .f_nacks(fmst_nacks), .f_outstanding(fmst_outstanding) // }}} );",
            "always @(*) if (r_stb) begin assert(s_count > 0); assert(o_sel != 0); end else begin assert(s_sel == 0); assert(s_count == 0); end",
            "always @(*) assert(!r_stb || !s_null);",
            "always @(*) if (r_stb) begin assert(o_sel != 0); if (OPT_LITTLE_ENDIAN) begin assert((s_count == 1) == (s_sel[WIDE_DW/8-1:SMALL_DW/8] == 0)); end else begin assert((s_count == 1) == (s_sel[WIDE_DW/8-SMALL_DW/8-1:0] == 0)); end end",
            "always @(*) if (!i_reset && o_cyc && i_wcyc) assert(ign_fifo_fill == fmst_outstanding);",
            "always @(*) if (!i_reset && !o_cyc && i_wcyc && !o_werr) assert(ign_fifo_fill == 0);",
            "always @(*) if (!o_cyc) assert(!r_stb);",
            "always @(*) if ((r_stb || fslv_outstanding > 0) && i_wcyc && o_cyc) assert(o_we == i_wwe);",
            "always @(*) if (i_wcyc && fslv_outstanding > 0 && !o_werr) assert(o_cyc);",
            "always @(*) if (i_wcyc && !o_wack && fmst_outstanding == 0 && s_count == 0) assert(r_data == 0);",
            "initial f_acks_in_fifo = 0;",
            "always @(posedge i_clk) if (i_reset || !i_wcyc) f_acks_in_fifo <= 0; else case({ o_stb && !i_stall && (s_count == 1), (i_ack && fifo_ack) }) 2'b01: f_acks_in_fifo <= f_acks_in_fifo - 1; 2'b10: f_acks_in_fifo <= f_acks_in_fifo + 1; endcase",
            "always @(*) if (!i_reset && i_wcyc && o_cyc) begin assert(f_acks_in_fifo + (s_count > 0 ? 1:0) + (s_null ? 1:0) + (o_wack ? 1:0) == fslv_outstanding); if (s_count == 0 && fslv_outstanding > (s_null ? 1:0) + (o_wack ? 1:0)) assert(f_acks_in_fifo > 0); end",
            "assign f_first_ack = f_first_data[WBLSB];",
            "assign f_second_ack = f_second_data[WBLSB];",
            "assign f_first_subaddr = f_first_data[WBLSB-1:0];",
            "assign f_second_subaddr = f_second_data[WBLSB-1:0];",
            "always @(*) begin assert(f_acks_in_fifo <= ign_fifo_fill); assert(!fifo_empty || f_acks_in_fifo == 0); assert(f_acks_in_fifo >= ((f_first_in_fifo && f_first_ack) ? 1:0) + ((f_second_in_fifo && f_second_ack) ? 1:0)); assert(ign_fifo_fill - f_acks_in_fifo >= ((f_first_in_fifo && !f_first_ack) ? 1:0) + ((f_second_in_fifo && !f_second_ack) ? 1:0)); if (o_cyc && f_first_in_fifo && f_distance_to_first == ign_fifo_fill - 1) assert(f_first_ack || s_count > 0); if (o_cyc && f_second_in_fifo && f_distance_to_second == ign_fifo_fill - 1) assert(f_second_ack || s_count > 0); if (!i_reset && i_wcyc && o_cyc && ign_fifo_fill > 0 && s_count == 0) assert(f_acks_in_fifo > 0); if (o_cyc&& i_wcyc && f_first_in_fifo && s_count == 0 && !o_werr && f_distance_to_first + 1 < ign_fifo_fill) assert(f_acks_in_fifo > (f_first_ack ? 1:0)); if (o_cyc && i_wcyc && f_second_in_fifo && s_count == 0 && !o_werr && f_distance_to_second + 1 < ign_fifo_fill) assert(f_acks_in_fifo > ((f_first_in_fifo && f_first_ack) ? 1:0) + (f_second_ack ? 1:0)); end",
            "always @(*) begin if (f_second_in_fifo) f_subsequent = (f_distance_to_second + 1 < ign_fifo_fill); else if (f_first_in_fifo) f_subsequent = (f_distance_to_first + 1 < ign_fifo_fill); else f_subsequent = (f_acks_in_fifo > 0 && s_count == 0); end",
            "always @(*) if ((!f_first_in_fifo || f_distance_to_first > 0) &&(!f_second_in_fifo || f_distance_to_second > 0) && !fifo_empty) begin assume(!fifo_ack || (f_acks_in_fifo > ((f_subsequent) ? 1:0) + ((f_first_in_fifo && f_first_ack) ? 1:0) + ((f_second_in_fifo && f_second_ack) ? 1:0))); assume(fifo_ack || (ign_fifo_fill - f_acks_in_fifo > ((f_first_in_fifo && !f_first_ack) ? 1:0) + ((f_second_in_fifo && !f_second_ack) ? 1:0))); if (f_acks_in_fifo == 1 && s_count == 0 && ign_fifo_fill > 1) assume(!fifo_ack); end",
            "always @(*) if (!i_reset && o_cyc && i_wcyc) begin if (f_first_in_fifo && f_second_in_fifo) begin assert(f_second_subaddr > f_first_subaddr || f_first_ack); end else if (f_first_in_fifo && !f_first_ack) begin assert(s_count > 0 && o_addr[WBLSB-1:0] > f_first_subaddr); end end",
            "always @(*) if (!i_reset && o_cyc && i_wcyc) begin assert(s_count <= (1<<WBLSB)); assert(s_count + o_addr[WBLSB-1:0] <= (1<<WBLSB)); if (s_count > 1) assert(s_count + o_addr[WBLSB-1:0]==(1<<WBLSB)); end",
            "always @(*) if (f_first_in_fifo && f_second_in_fifo) begin assert(f_second_subaddr > f_first_subaddr || f_first_ack); end",
            "always @(*) if (OPT_LITTLE_ENDIAN) f_mask = {(WIDE_DW/8){1'b1}} >> (o_addr[WBLSB-1:0] * SMALL_DW/8); else f_mask = {(WIDE_DW/8){1'b1}} << (o_addr[WBLSB-1:0] * SMALL_DW/8);",
            "always @(*) if (s_count > 0) begin assert((s_sel & (~f_mask)) == 0); end `endif // }}} // }}} end endgenerate",
            "endmodule"
        ]
    },
    {
        "file_name": "addrdecode.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/addrdecode.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/addrdecode.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2019-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module addrdecode #( // {{{",
            "parameter NS=8, parameter AW = 32, DW=32+32/8+1+1, // // SLAVE_ADDR contains address",
            "assign ments for each of the // various slaves we are adjudicating between.",
            "parameter [NS*AW-1:0] SLAVE_ADDR = { { 3'b111, {(AW-3){1'b0}} }, { 3'b110, {(AW-3){1'b0}} }, { 3'b101, {(AW-3){1'b0}} }, { 3'b100, {(AW-3){1'b0}} }, { 3'b011, {(AW-3){1'b0}} }, { 3'b010, {(AW-3){1'b0}} }, { 4'b0010, {(AW-4){1'b0}} }, { 4'b0000, {(AW-4){1'b0}} }}, // // SLAVE_MASK contains a mask of those address bits in // SLAVE_ADDR which are relevant. It shall be true that if // !SLAVE_MASK[k] then !SLAVE_ADDR[k], for any bits of k",
            "parameter [NS*AW-1:0] SLAVE_MASK = (NS <= 1) ? 0 : { {(NS-2){ 3'b111, {(AW-3){1'b0}} }}, {(2){ 4'b1111, {(AW-4){1'b0}} }} }, // // ACCESS_ALLOWED is a bit-wise mask indicating which slaves // may get access to the bus. If ACCESS_ALLOWED[slave] is true, // then a master can connect to the slave via this method. This // parameter is primarily here to support AXI (or other similar // buses) which may have separate accesses for both read and // write. By using this, a read-only slave can be connected, // which would also naturally create an error on any attempt to // write to it.",
            "parameter [NS-1:0] ACCESS_ALLOWED = -1, // // If OPT_REGISTERED is set, address decoding will take an extra // clock, and will",
            "reg ister the results of the decoding // operation.",
            "parameter [0:0] OPT_REGISTERED = 0, // // If OPT_LOWPOWER is set, then whenever the",
            "output is not // valid, any respective data linse will also be forced to zero // in an effort to minimize power.",
            "parameter [0:0] OPT_LOWPOWER = 0 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // input wire i_valid, output reg o_stall, input wire [AW-1:0] i_addr, input wire [DW-1:0] i_data, // output reg o_valid, input wire i_stall, output reg [NS:0] o_decode, output reg [AW-1:0] o_addr, output reg [DW-1:0] o_data // }}} ); // Local declarations // {{{ // // OPT_NONESEL controls whether or not the address lines are fully // proscribed, or whether or not a \"no-slave identified\" slave should // be created. To avoid a \"no-slave selected\"",
            "output , slave zero must // have no mask bits set (and therefore no address bits set), and it // must also allow access.",
            "localparam [0:0] OPT_NONESEL = (!ACCESS_ALLOWED[0]) || (SLAVE_MASK[AW-1:0] != 0); // wire [NS:0] request;",
            "reg [NS-1:0] prerequest; integer iM; // }}} // prerequest // {{{",
            "always @(*) for(iM=0; iM<NS; iM=iM+1) prerequest[iM] = (((i_addr ^ SLAVE_ADDR[iM*AW +: AW]) &SLAVE_MASK[iM*AW +: AW])==0) &&(ACCESS_ALLOWED[iM]); // }}} // request // {{{ generate if (OPT_NONESEL) begin : NO_DEFAULT_REQUEST // {{{",
            "reg [NS-1:0] r_request; // Need to create a slave to describe when nothing is selected // always @(*) begin for(iM=0; iM<NS; iM=iM+1) r_request[iM] = i_valid && prerequest[iM]; if (!OPT_NONESEL && (NS > 1 && |prerequest[NS-1:1])) r_request[0] = 1'b0; end",
            "assign request[NS-1:0] = r_request; // }}} end else if (NS == 1) begin : SINGLE_SLAVE // {{{",
            "assign request[0] = i_valid; // }}} end else begin : LCL_NOSEL // {{{",
            "reg [NS-1:0] r_request;",
            "always @(*) begin for(iM=0; iM<NS; iM=iM+1) r_request[iM] = i_valid && prerequest[iM]; if (!OPT_NONESEL && (NS > 1 && |prerequest[NS-1:1])) r_request[0] = 1'b0; end",
            "assign request[NS-1:0] = r_request; // }}} end endgenerate // }}} // request[NS] // {{{ generate if (OPT_NONESEL) begin : OPT_NONESEL_REQUEST",
            "reg r_request_NS, r_none_sel;",
            "always @(*) begin // Let's assume nothing's been selected, and then check // to prove ourselves wrong. // // Note that none_sel will be considered an error // condition in the follow-on processing. Therefore // it's important to clear it if no request is pending. r_none_sel = i_valid && (prerequest == 0); // // request[NS] indicates a request for a non-existent // slave. A request that should (eventually) return a // bus error // r_request_NS = r_none_sel; end",
            "assign request[NS] = r_request_NS; end else begin : NO_NONESEL_REQUEST",
            "assign request[NS] = 1'b0; end endgenerate // }}} // o_valid, o_addr, o_data, o_decode, o_stall // {{{ generate if (OPT_REGISTERED) begin : GEN_REGISTERED_OUTS // o_valid // {{{",
            "initial o_valid = 0;",
            "always @(posedge i_clk) if (i_reset) o_valid <= 0; else if (!o_stall) o_valid <= i_valid; // }}} // o_addr, o_data // {{{",
            "initial o_addr = 0;",
            "initial o_data = 0;",
            "always @(posedge i_clk) if (i_reset && OPT_LOWPOWER) begin o_addr <= 0; o_data <= 0; end else if ((!o_valid || !i_stall) && (i_valid || !OPT_LOWPOWER)) begin o_addr <= i_addr; o_data <= i_data; end else if (OPT_LOWPOWER && !i_stall) begin o_addr <= 0; o_data <= 0; end // }}} // o_decode // {{{",
            "initial o_decode = 0;",
            "always @(posedge i_clk) if (i_reset) o_decode <= 0; else if ((!o_valid || !i_stall) && (i_valid || !OPT_LOWPOWER)) o_decode <= request; else if (OPT_LOWPOWER && !i_stall) o_decode <= 0; // }}} // o_stall // {{{",
            "always @(*) o_stall = (o_valid && i_stall); // }}} end else begin : COMB_OUTPUTS",
            "always @(*) begin o_valid = i_valid; o_stall = i_stall; o_addr = i_addr; o_data = i_data; o_decode = request; end // Make Verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, `ifdef VERILATOR // Can't declare the clock as unused for formal, // lest it not be recognized as *the* clock i_clk, `endif i_reset }; // verilator lint_on UNUSED // verilator coverage_on // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid <= 1;",
            "reg [AW+DW-1:0] f_idata;",
            "always @(*) f_idata = { i_addr, i_data }; `ifdef ADDRDECODE",
            "always @(posedge i_clk) if (!f_past_valid) assume(i_reset); `else",
            "always @(posedge i_clk) if (!f_past_valid) assert(i_reset); `endif // ADDRDECODE",
            "always @(posedge i_clk) if (OPT_REGISTERED && (!f_past_valid || $past(i_reset))) begin assert(!o_valid); assert(o_decode == 0); end else if ($past(o_valid && i_stall) && OPT_REGISTERED) begin assert($stable(o_addr)); assert($stable(o_decode)); assert($stable(o_data)); end // If the",
            "output is ever valid, there must be at least one // decoded",
            "output always @(*) assert(o_valid == (o_decode != 0));",
            "always @(*) for(iM=0; iM<NS; iM=iM+1) if (o_decode[iM]) begin // The address must match assert((((o_addr ^ SLAVE_ADDR[iM*AW +: AW]) & SLAVE_MASK[iM*AW +: AW])==0) && ACCESS_ALLOWED[iM]); // // And nothing else must match assert(o_decode == (1<<iM)); end",
            "always @(*) for(iM=0; iM<NS; iM=iM+1) if (!ACCESS_ALLOWED[iM]) assert(!o_decode[iM]); // LOWPOWER check // {{{ generate if (OPT_LOWPOWER && OPT_REGISTERED) begin",
            "always @(*) if (!o_valid) begin assert(o_addr == 0); assert(o_decode == 0); assert(o_data == 0); end end endgenerate // }}} // // The",
            "output decoded value may only ever have one value high, // never more--i.e. $onehot0 // {{{ `ifdef VERIFIC",
            "always @(*) assert($onehot0(request)); `else",
            "reg onehot_request;",
            "always @(*) begin onehot_request = 0; for(iM=0; iM<NS+1; iM=iM+1) if ((request ^ (1<<iM))==0) onehot_request = 1; end",
            "always @(*) if (request != 0) assert(onehot_request); `endif // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // // // Make sure all addresses are reachable // reg [NS:0] f_reached;",
            "always @(posedge i_clk) cover(i_valid);",
            "always @(posedge i_clk) cover(o_valid);",
            "always @(posedge i_clk) cover(o_valid && !i_stall);",
            "initial f_reached = 0;",
            "always @(posedge i_clk) if (i_reset) f_reached = 0; else if (o_valid) f_reached = f_reached | o_decode; generate if (!OPT_NONESEL && ACCESS_ALLOWED[0] && SLAVE_MASK == 0 && NS == 1) begin",
            "always @(*) cover(f_reached[0]);",
            "always @(posedge i_clk) if (f_past_valid && $stable(o_valid)) assert($stable(o_decode)); end else begin",
            "always @(*) cover(&f_reached);",
            "always @(posedge i_clk) if (f_past_valid && $stable(o_valid)) cover($changed(o_decode)); end endgenerate // }}} `endif // FORMAL // }}}",
            "endmodule `ifndef YOSYS `default_nettype",
            "wire `endif"
        ]
    },
    {
        "file_name": "axilxbar.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axilxbar.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/axilxbar.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Create a full crossbar between NM AXI-lite sources (masters), // and NS AXI-lite slaves. Every master can talk to any slave, // provided it isn't already busy. // // Performance: This core has been designed with the goal of being able to push // one transaction through the interconnect, from any master to // any slave, per clock cycle. This may perhaps be its most unique // feature. While throughput is good, latency is something else. // // The arbiter requires a clock to switch, then another clock to send data // downstream. This creates a minimum two clock latency up front. The // return path suffers another clock of latency as well, placing the // minimum latency at four clocks. The minimum write latency is at // least one clock longer, since the write data must wait for the write // address before proceeeding. // // Usage: To use, you must first set NM and NS to the number of masters // and the number of slaves you wish to connect to. You then need to // adjust the addresses of the slaves, found SLAVE_ADDR array. Those // bits that are relevant in SLAVE_ADDR to then also be set in SLAVE_MASK. // Adjusting the data and address widths go without saying. // // Lower numbered masters are given priority in any \"fight\". // // Channel grants are given on the condition that 1) they are requested, // 2) no other channel has a grant, 3) all of the responses have been // received from the current channel, and 4) the internal counters are // not overflowing. // // The core limits the number of outstanding transactions on any channel to // 1<<LGMAXBURST-1. // // Channel grants are lost 1) after OPT_LINGER clocks of being idle, or // 2) when another master requests an idle (but still lingering) channel // assign ment, or 3) once all the responses have been returned to the // current channel, and the current master is requesting another channel. // // A special slave is allocated for the case of no valid address. // // Since the write channel has no address information, the write data // channel",
            "always be delayed by at least one clock from the write address // channel. // // If OPT_LOWPOWER is set, then unused values will be set to zero. // This can also be used to help identify relevant values within any // trace. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2019-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module axilxbar #( // {{{",
            "parameter integer C_AXI_DATA_WIDTH = 32, parameter integer C_AXI_ADDR_WIDTH = 32, // // NM is the number of master interfaces this core supports",
            "parameter NM = 4, // // NS is the number of slave interfaces",
            "parameter NS = 8, // // AW, and DW, are short-hand abbreviations used locally.",
            "localparam AW = C_AXI_ADDR_WIDTH, localparam DW = C_AXI_DATA_WIDTH, // SLAVE_ADDR is a bit vector containing AW bits for each of the // slaves indicating the base address of the slave. This // goes with SLAVE_MASK below.",
            "parameter [NS*AW-1:0] SLAVE_ADDR = { 3'b111, {(AW-3){1'b0}}, 3'b110, {(AW-3){1'b0}}, 3'b101, {(AW-3){1'b0}}, 3'b100, {(AW-3){1'b0}}, 3'b011, {(AW-3){1'b0}}, 3'b010, {(AW-3){1'b0}}, 4'b0001, {(AW-4){1'b0}}, 4'b0000, {(AW-4){1'b0}} }, // // SLAVE_MASK indicates which bits in the SLAVE_ADDR bit vector // need to be checked to determine if a given address request // maps to the given slave or not // Verilator lint_off WIDTH",
            "parameter [NS*AW-1:0] SLAVE_MASK = (NS <= 1) ? { 4'b1111, {(AW-4){1'b0}} } : { {(NS-2){ 3'b111, {(AW-3){1'b0}} }}, {(2){ 4'b1111, {(AW-4){1'b0}} }} }, // Verilator lint_on WIDTH // // If set, OPT_LOWPOWER will set all unused",
            "reg isters, both // internal and external, to zero anytime their corresponding // *VALID bit is clear",
            "parameter [0:0] OPT_LOWPOWER = 1, // // OPT_LINGER is the number of cycles to wait, following a // transaction, before tearing down the bus grant.",
            "parameter OPT_LINGER = 4, // // LGMAXBURST is the log (base two) of the maximum number of // requests that can be outstanding on any given channel at any // given time. It is used within this core to control the // counters that are used to determine if a particular channel // grant must stay open, or if it may be closed.",
            "parameter LGMAXBURST = 5 // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, // Incoming AXI4-lite slave port(s) // {{{",
            "input wire [NM*C_AXI_ADDR_WIDTH-1:0] S_AXI_AWADDR, input wire [NM*3-1:0] S_AXI_AWPROT, input wire [NM-1:0] S_AXI_AWVALID, output wire [NM-1:0] S_AXI_AWREADY, // input wire [NM*C_AXI_DATA_WIDTH-1:0] S_AXI_WDATA, input wire [NM*C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB, input wire [NM-1:0] S_AXI_WVALID, output wire [NM-1:0] S_AXI_WREADY, // output wire [NM*2-1:0] S_AXI_BRESP, output wire [NM-1:0] S_AXI_BVALID, input wire [NM-1:0] S_AXI_BREADY, // input wire [NM*C_AXI_ADDR_WIDTH-1:0] S_AXI_ARADDR, input wire [NM*3-1:0] S_AXI_ARPROT, input wire [NM-1:0] S_AXI_ARVALID, output wire [NM-1:0] S_AXI_ARREADY, // output wire [NM*C_AXI_DATA_WIDTH-1:0] S_AXI_RDATA, output wire [NM*2-1:0] S_AXI_RRESP, output wire [NM-1:0] S_AXI_RVALID, input wire [NM-1:0] S_AXI_RREADY, // }}} // Outgoing AXI4-lite master port(s) // {{{",
            "output wire [NS*C_AXI_ADDR_WIDTH-1:0] M_AXI_AWADDR, output wire [NS*3-1:0] M_AXI_AWPROT, output wire [NS-1:0] M_AXI_AWVALID, input wire [NS-1:0] M_AXI_AWREADY, // output wire [NS*C_AXI_DATA_WIDTH-1:0] M_AXI_WDATA, output wire [NS*C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB, output wire [NS-1:0] M_AXI_WVALID, input wire [NS-1:0] M_AXI_WREADY, // input wire [NS*2-1:0] M_AXI_BRESP, input wire [NS-1:0] M_AXI_BVALID, output wire [NS-1:0] M_AXI_BREADY, // output wire [NS*C_AXI_ADDR_WIDTH-1:0] M_AXI_ARADDR, output wire [NS*3-1:0] M_AXI_ARPROT, output wire [NS-1:0] M_AXI_ARVALID, input wire [NS-1:0] M_AXI_ARREADY, // input wire [NS*C_AXI_DATA_WIDTH-1:0] M_AXI_RDATA, input wire [NS*2-1:0] M_AXI_RRESP, input wire [NS-1:0] M_AXI_RVALID, output wire [NS-1:0] M_AXI_RREADY // }}} // }}} ); // // Local",
            "parameter s, derived from those above // {{{",
            "localparam LGLINGER = (OPT_LINGER>1) ? $clog2(OPT_LINGER+1) : 1; // localparam LGNM = (NM>1) ? $clog2(NM) : 1;",
            "localparam LGNS = (NS>1) ? $clog2(NS+1) : 1; // // In order to use indexes, and hence fully balanced mux trees, it helps // to make certain that we have a power of two based lookup. NMFULL // is the number of masters in this lookup, with potentially some // unused extra ones. NSFULL is defined similarly.",
            "localparam NMFULL = (NM>1) ? (1<<LGNM) : 1;",
            "localparam NSFULL = (NS>1) ? (1<<LGNS) : 2; // localparam [1:0] INTERCONNECT_ERROR = 2'b11;",
            "localparam [0:0] OPT_SKID_INPUT = 0;",
            "localparam [0:0] OPT_BUFFER_DECODER = 1; genvar N,M; integer iN, iM; // }}} // {{{",
            "reg [NSFULL-1:0] wrequest [0:NM-1];",
            "reg [NSFULL-1:0] rrequest [0:NM-1];",
            "reg [NSFULL-1:0] wrequested [0:NM];",
            "reg [NSFULL-1:0] rrequested [0:NM];",
            "reg [NS:0] wgrant [0:NM-1];",
            "reg [NS:0] rgrant [0:NM-1];",
            "reg [NM-1:0] swgrant;",
            "reg [NM-1:0] srgrant;",
            "reg [NS-1:0] mwgrant;",
            "reg [NS-1:0] mrgrant; // verilator lint_off UNUSED",
            "wire [LGMAXBURST-1:0] w_sawpending [0:NM-1];",
            "wire [LGMAXBURST-1:0] w_swpending [0:NM-1];",
            "wire [LGMAXBURST-1:0] w_srpending [0:NM-1]; // verilator lint_on UNUSED",
            "reg [NM-1:0] swfull;",
            "reg [NM-1:0] srfull;",
            "reg [NM-1:0] swempty;",
            "reg [NM-1:0] srempty; // wire [LGNS-1:0] swindex [0:NMFULL-1];",
            "wire [LGNS-1:0] srindex [0:NMFULL-1];",
            "wire [LGNM-1:0] mwindex [0:NSFULL-1];",
            "wire [LGNM-1:0] mrindex [0:NSFULL-1];",
            "wire [NM-1:0] wdata_expected; // The shadow buffers",
            "wire [NMFULL-1:0] m_awvalid, m_wvalid, m_arvalid;",
            "wire [NM-1:0] dcd_awvalid, dcd_arvalid;",
            "wire [C_AXI_ADDR_WIDTH-1:0] m_awaddr [0:NMFULL-1];",
            "wire [2:0] m_awprot [0:NMFULL-1];",
            "wire [C_AXI_DATA_WIDTH-1:0] m_wdata [0:NMFULL-1];",
            "wire [C_AXI_DATA_WIDTH/8-1:0] m_wstrb [0:NMFULL-1];",
            "wire [C_AXI_ADDR_WIDTH-1:0] m_araddr [0:NMFULL-1];",
            "wire [2:0] m_arprot [0:NMFULL-1]; // wire [NM-1:0] skd_awvalid, skd_awstall, skd_wvalid;",
            "wire [NM-1:0] skd_arvalid, skd_arstall;",
            "wire [AW-1:0] skd_awaddr [0:NM-1];",
            "wire [3-1:0] skd_awprot [0:NM-1];",
            "wire [AW-1:0] skd_araddr [0:NM-1];",
            "wire [3-1:0] skd_arprot [0:NM-1];",
            "reg r_bvalid [0:NM-1];",
            "reg [1:0] r_bresp [0:NM-1];",
            "reg [NSFULL-1:0] m_axi_awvalid;",
            "reg [NSFULL-1:0] m_axi_awready;",
            "reg [NSFULL-1:0] m_axi_wvalid;",
            "reg [NSFULL-1:0] m_axi_wready;",
            "reg [NSFULL-1:0] m_axi_bvalid; `ifdef FORMAL",
            "reg [NSFULL-1:0] m_axi_bready; `endif",
            "reg [1:0] m_axi_bresp [0:NSFULL-1];",
            "reg [NSFULL-1:0] m_axi_arvalid; // Verilator lint_off UNUSED",
            "reg [NSFULL-1:0] m_axi_arready; // Verilator lint_on UNUSED",
            "reg [NSFULL-1:0] m_axi_rvalid; // Verilator lint_off UNUSED",
            "reg [NSFULL-1:0] m_axi_rready; // Verilator lint_on UNUSED",
            "reg r_rvalid [0:NM-1];",
            "reg [1:0] r_rresp [0:NM-1];",
            "reg [DW-1:0] r_rdata [0:NM-1];",
            "reg [DW-1:0] m_axi_rdata [0:NSFULL-1];",
            "reg [1:0] m_axi_rresp [0:NSFULL-1];",
            "reg [NM-1:0] slave_awaccepts;",
            "reg [NM-1:0] slave_waccepts;",
            "reg [NM-1:0] slave_raccepts; // }}} // m_axi_[aw|w|b]* // {{{",
            "always @(*) begin m_axi_awvalid = -1; m_axi_awready = -1; m_axi_wvalid = -1; m_axi_wready = -1; m_axi_bvalid = 0; m_axi_awvalid[NS-1:0] = M_AXI_AWVALID; m_axi_awready[NS-1:0] = M_AXI_AWREADY; m_axi_wvalid[NS-1:0] = M_AXI_WVALID; m_axi_wready[NS-1:0] = M_AXI_WREADY; m_axi_bvalid[NS-1:0] = M_AXI_BVALID; for(iM=0; iM<NS; iM=iM+1) begin m_axi_bresp[iM] = M_AXI_BRESP[iM* 2 +: 2]; m_axi_rdata[iM] = M_AXI_RDATA[iM*DW +: DW]; m_axi_rresp[iM] = M_AXI_RRESP[iM* 2 +: 2]; end for(iM=NS; iM<NSFULL; iM=iM+1) begin m_axi_bresp[iM] = INTERCONNECT_ERROR; m_axi_rdata[iM] = 0; m_axi_rresp[iM] = INTERCONNECT_ERROR; end `ifdef FORMAL m_axi_bready = -1; m_axi_bready[NS-1:0] = M_AXI_BREADY; `endif end // }}} generate for(N=0; N<NM; N=N+1) begin : DECODE_WRITE_REQUEST // {{{",
            "wire [NS:0] wdecode;",
            "reg r_mawvalid, r_mwvalid; // awskid // {{{ skidbuffer #( // {{{ .DW(AW+3), .OPT_OUTREG(OPT_SKID_INPUT) // }}} ) awskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, S_AXI_AWVALID[N], S_AXI_AWREADY[N], { S_AXI_AWADDR[N*AW +: AW], S_AXI_AWPROT[N*3 +: 3] }, skd_awvalid[N], !skd_awstall[N], { skd_awaddr[N], skd_awprot[N] } // }}} ); // }}} // write address decoding // {{{ addrdecode #( // {{{ .AW(AW), .DW(3), .NS(NS), .SLAVE_ADDR(SLAVE_ADDR), .SLAVE_MASK(SLAVE_MASK), .OPT_REGISTERED(OPT_BUFFER_DECODER) // }}} ) wraddr( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(skd_awvalid[N]), .o_stall(skd_awstall[N]), .i_addr(skd_awaddr[N]), .i_data(skd_awprot[N]), .o_valid(dcd_awvalid[N]), .i_stall(!dcd_awvalid[N]||!slave_awaccepts[N]), .o_decode(wdecode), .o_addr(m_awaddr[N]), .o_data(m_awprot[N]) // }}} ); // }}} // wskid // {{{ skidbuffer #( // {{{ .DW(DW+DW/8), .OPT_OUTREG(OPT_SKID_INPUT) // }}} ) wskid // {{{ (S_AXI_ACLK, !S_AXI_ARESETN, S_AXI_WVALID[N], S_AXI_WREADY[N], { S_AXI_WDATA[N*DW +: DW], S_AXI_WSTRB[N*DW/8 +: DW/8]}, skd_wvalid[N], (m_wvalid[N] && slave_waccepts[N]), { m_wdata[N], m_wstrb[N] } // }}} ); // }}} // slave_awaccepts // {{{",
            "always @(*) begin slave_awaccepts[N] = 1'b1; if (!swgrant[N]) slave_awaccepts[N] = 1'b0; if (swfull[N]) slave_awaccepts[N] = 1'b0; if (!wrequest[N][swindex[N]]) slave_awaccepts[N] = 1'b0; if (!wgrant[N][NS]&&(m_axi_awvalid[swindex[N]] && !m_axi_awready[swindex[N]])) slave_awaccepts[N] = 1'b0; // ERRORs are",
            "always accepted // back pressure is handled in the write side end // }}} // slave_waccepts // {{{",
            "always @(*) begin slave_waccepts[N] = 1'b1; if (!swgrant[N]) slave_waccepts[N] = 1'b0; if (!wdata_expected[N]) slave_waccepts[N] = 1'b0; if (!wgrant[N][NS] &&(m_axi_wvalid[swindex[N]] && !m_axi_wready[swindex[N]])) slave_waccepts[N] = 1'b0; if (wgrant[N][NS]&&(S_AXI_BVALID[N]&& !S_AXI_BREADY[N])) slave_waccepts[N] = 1'b0; end // }}} // {{{",
            "always @(*) begin r_mawvalid= dcd_awvalid[N] && !swfull[N]; r_mwvalid = skd_wvalid[N]; wrequest[N]= 0; if (!swfull[N]) wrequest[N][NS:0] = wdecode; end",
            "assign m_awvalid[N] = r_mawvalid;",
            "assign m_wvalid[N] = r_mwvalid; // }}} // }}} end for (N=NM; N<NMFULL; N=N+1) begin : UNUSED_WSKID_BUFFERS // {{{",
            "assign m_awvalid[N] = 0;",
            "assign m_awaddr[N] = 0;",
            "assign m_awprot[N] = 0;",
            "assign m_wdata[N] = 0;",
            "assign m_wstrb[N] = 0; // }}} end endgenerate generate for(N=0; N<NM; N=N+1) begin : DECODE_READ_REQUEST // {{{",
            "wire [NS:0] rdecode;",
            "reg r_marvalid; // arskid // {{{ skidbuffer #( // {{{ .DW(AW+3), .OPT_OUTREG(OPT_SKID_INPUT) // }}} ) arskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, S_AXI_ARVALID[N], S_AXI_ARREADY[N], { S_AXI_ARADDR[N*AW +: AW], S_AXI_ARPROT[N*3 +: 3] }, skd_arvalid[N], !skd_arstall[N], { skd_araddr[N], skd_arprot[N] } // }}} ); // }}} // Read address decoding // {{{ addrdecode #( // {{{ .AW(AW), .DW(3), .NS(NS), .SLAVE_ADDR(SLAVE_ADDR), .SLAVE_MASK(SLAVE_MASK), .OPT_REGISTERED(OPT_BUFFER_DECODER) // }}} ) rdaddr( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(skd_arvalid[N]), .o_stall(skd_arstall[N]), .i_addr(skd_araddr[N]), .i_data(skd_arprot[N]), .o_valid(dcd_arvalid[N]), .i_stall(!m_arvalid[N] || !slave_raccepts[N]), .o_decode(rdecode), .o_addr(m_araddr[N]), .o_data(m_arprot[N]) // }}} ); // }}} // m_arvalid[N] // {{{",
            "always @(*) begin r_marvalid = dcd_arvalid[N] && !srfull[N]; rrequest[N] = 0; if (!srfull[N]) rrequest[N][NS:0] = rdecode; end",
            "assign m_arvalid[N] = r_marvalid; // }}} // slave_raccepts // {{{",
            "always @(*) begin slave_raccepts[N] = 1'b1; if (!srgrant[N]) slave_raccepts[N] = 1'b0; if (srfull[N]) slave_raccepts[N] = 1'b0; // verilator lint_off WIDTH if (!rrequest[N][srindex[N]]) slave_raccepts[N] = 1'b0; // verilator lint_on WIDTH if (!rgrant[N][NS]) begin if (m_axi_arvalid[srindex[N]] && !m_axi_arready[srindex[N]]) slave_raccepts[N] = 1'b0; end else if (S_AXI_RVALID[N] && !S_AXI_RREADY[N]) slave_raccepts[N] = 1'b0; end // }}} // }}} end for (N=NM; N<NMFULL; N=N+1) begin : UNUSED_RSKID_BUFFERS // {{{",
            "assign m_arvalid[N] = 0;",
            "assign m_araddr[N] = 0;",
            "assign m_arprot[N] = 0; // }}} end endgenerate // wrequested // {{{",
            "always @(*) begin : DECONFLICT_WRITE_REQUESTS for(iN=1; iN<NM ; iN=iN+1) wrequested[iN] = 0; // Vivado may complain about too many bits for wrequested. // This is (currrently) expected. swindex is used to index // into wrequested, and swindex has LGNS bits, where LGNS // is $clog2(NS+1) rather than $clog2(NS). The extra bits // are defined to be zeros, but the point is there are defined. // Therefore, no matter what swindex is, it will",
            "always // reference something valid. wrequested[NM] = 0; for(iM=0; iM<NS; iM=iM+1) begin wrequested[0][iM] = 1'b0; for(iN=1; iN<NM ; iN=iN+1) begin // Continue to request any channel with // a grant and pending operations if (wrequest[iN-1][iM] && wgrant[iN-1][iM]) wrequested[iN][iM] = 1; if (wrequest[iN-1][iM] && (!swgrant[iN-1]||swempty[iN-1])) wrequested[iN][iM] = 1; // Otherwise, if it's already claimed, then // it can't be claimed again if (wrequested[iN-1][iM]) wrequested[iN][iM] = 1; end wrequested[NM][iM] = wrequest[NM-1][iM] || wrequested[NM-1][iM]; end end // }}} // rrequested // {{{",
            "always @(*) begin : DECONFLICT_READ_REQUESTS for(iN=0; iN<NM ; iN=iN+1) rrequested[iN] = 0; // See the note above for wrequested. This applies to // rrequested as well. rrequested[NM] = 0; for(iM=0; iM<NS; iM=iM+1) begin rrequested[0][iM] = 0; for(iN=1; iN<NM ; iN=iN+1) begin // Continue to request any channel with // a grant and pending operations if (rrequest[iN-1][iM] && rgrant[iN-1][iM]) rrequested[iN][iM] = 1; if (rrequest[iN-1][iM] && (!srgrant[iN-1] || srempty[iN-1])) rrequested[iN][iM] = 1; // Otherwise, if it's already claimed, then // it can't be claimed again if (rrequested[iN-1][iM]) rrequested[iN][iM] = 1; end rrequested[NM][iM] = rrequest[NM-1][iM] || rrequested[NM-1][iM]; end end // }}} // mwgrant, mrgrant // {{{ generate for(M=0; M<NS; M=M+1) begin // {{{",
            "initial mwgrant[M] = 0;",
            "always @(*) begin mwgrant[M] = 0; for(iN=0; iN<NM; iN=iN+1) if (wgrant[iN][M]) mwgrant[M] = 1; end",
            "always @(*) begin mrgrant[M] = 0; for(iN=0; iN<NM; iN=iN+1) if (rgrant[iN][M]) mrgrant[M] = 1; end // }}} end endgenerate // }}} generate for(N=0; N<NM; N=N+1) begin : ARBITRATE_WRITE_REQUESTS // {{{ // Declarations // {{{",
            "reg stay_on_channel;",
            "reg requested_channel_is_available;",
            "reg leave_channel;",
            "reg [LGNS-1:0] requested_index; // }}} // stay_on_channel // {{{",
            "always @(*) begin stay_on_channel = |(wrequest[N][NS:0] & wgrant[N]); if (swgrant[N] && !swempty[N]) stay_on_channel = 1; end // }}} // requested_channel_is_available // {{{",
            "always @(*) begin requested_channel_is_available = |(wrequest[N][NS-1:0] & ~mwgrant & ~wrequested[N][NS-1:0]); if (wrequest[N][NS]) requested_channel_is_available = 1; if (NM < 2) requested_channel_is_available = m_awvalid[N]; end // }}}",
            "wire linger; if (OPT_LINGER == 0) begin : NO_LINGER // {{{",
            "assign linger = 0; // }}} end else begin : WRITE_LINGER // {{{",
            "reg [LGLINGER-1:0] linger_counter;",
            "reg r_linger;",
            "initial r_linger = 0;",
            "initial linger_counter = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || wgrant[N][NS]) begin r_linger <= 0; linger_counter <= 0; end else if (!swempty[N] || S_AXI_BVALID[N]) begin linger_counter <= OPT_LINGER; r_linger <= 1; end else if (linger_counter > 0) begin r_linger <= (linger_counter > 1); linger_counter <= linger_counter - 1; end else r_linger <= 0;",
            "assign linger = r_linger; `ifdef FORMAL // {{{",
            "always @(*) assert(linger == (linger_counter != 0)); // }}} `endif // }}} end // leave_channel // {{{",
            "always @(*) begin leave_channel = 0; if (!m_awvalid[N] && (!linger || wrequested[NM][swindex[N]])) // Leave the channel after OPT_LINGER counts // of the channel being idle, or when someone // else asks for the channel leave_channel = 1; if (m_awvalid[N] && !wrequest[N][swindex[N]]) // Need to leave this channel to connect // to any other channel leave_channel = 1; end // }}} // wgrant, swgrant // {{{",
            "initial wgrant[N] = 0;",
            "initial swgrant[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin wgrant[N] <= 0; swgrant[N] <= 0; end else if (!stay_on_channel) begin if (requested_channel_is_available) begin // Switching channels swgrant[N] <= 1'b1; wgrant[N] <= wrequest[N][NS:0]; end else if (leave_channel) begin swgrant[N] <= 1'b0; wgrant[N] <= 0; end end // }}} // requested_index // {{{",
            "always @(wrequest[N]) begin requested_index = 0; for(iM=0; iM<=NS; iM=iM+1) if (wrequest[N][iM]) requested_index= requested_index | iM[LGNS-1:0]; end // }}} // Now for swindex // {{{",
            "reg [LGNS-1:0] r_swindex;",
            "initial r_swindex = 0;",
            "always @(posedge S_AXI_ACLK) if (!stay_on_channel && requested_channel_is_available) r_swindex <= requested_index;",
            "assign swindex[N] = r_swindex; // }}} // }}} end for (N=NM; N<NMFULL; N=N+1) begin // {{{",
            "assign swindex[N] = 0; // }}} end endgenerate generate for(N=0; N<NM; N=N+1) begin : ARBITRATE_READ_REQUESTS // {{{ // Declarations // {{{",
            "reg stay_on_channel;",
            "reg requested_channel_is_available;",
            "reg leave_channel;",
            "reg [LGNS-1:0] requested_index; // }}} // stay_on_channel // {{{",
            "always @(*) begin stay_on_channel = |(rrequest[N][NS:0] & rgrant[N]); if (srgrant[N] && !srempty[N]) stay_on_channel = 1; end // }}} // requested_channel_is_available // {{{",
            "always @(*) begin requested_channel_is_available = |(rrequest[N][NS-1:0] & ~mrgrant & ~rrequested[N][NS-1:0]); if (rrequest[N][NS]) requested_channel_is_available = 1; if (NM < 2) requested_channel_is_available = m_arvalid[N]; end // }}}",
            "wire linger; if (OPT_LINGER == 0) begin : NO_LINGER // {{{",
            "assign linger = 0; // }}} end else begin : READ_LINGER // {{{",
            "reg [LGLINGER-1:0] linger_counter;",
            "reg r_linger;",
            "initial r_linger = 0;",
            "initial linger_counter = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || rgrant[N][NS]) begin r_linger <= 0; linger_counter <= 0; end else if (!srempty[N] || S_AXI_RVALID[N]) begin linger_counter <= OPT_LINGER; r_linger <= 1; end else if (linger_counter > 0) begin r_linger <= (linger_counter > 1); linger_counter <= linger_counter - 1; end else r_linger <= 0;",
            "assign linger = r_linger; `ifdef FORMAL // {{{",
            "always @(*) assert(linger == (linger_counter != 0)); // }}} `endif // }}} end // leave_channel // {{{",
            "always @(*) begin leave_channel = 0; if (!m_arvalid[N] && (!linger || rrequested[NM][srindex[N]])) // Leave the channel after OPT_LINGER counts // of the channel being idle, or when someone // else asks for the channel leave_channel = 1; if (m_arvalid[N] && !rrequest[N][srindex[N]]) // Need to leave this channel to connect // to any other channel leave_channel = 1; end // }}} // rgrant, srgrant // {{{",
            "initial rgrant[N] = 0;",
            "initial srgrant[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin rgrant[N] <= 0; srgrant[N] <= 0; end else if (!stay_on_channel) begin if (requested_channel_is_available) begin // Switching channels srgrant[N] <= 1'b1; rgrant[N] <= rrequest[N][NS:0]; end else if (leave_channel) begin srgrant[N] <= 1'b0; rgrant[N] <= 0; end end // }}} // requested_index // {{{",
            "always @(rrequest[N]) begin requested_index = 0; for(iM=0; iM<=NS; iM=iM+1) if (rrequest[N][iM]) requested_index = requested_index|iM[LGNS-1:0]; end // }}} // Now for srindex // {{{",
            "reg [LGNS-1:0] r_srindex;",
            "initial r_srindex = 0;",
            "always @(posedge S_AXI_ACLK) if (!stay_on_channel && requested_channel_is_available) r_srindex <= requested_index;",
            "assign srindex[N] = r_srindex; // }}} // }}} end for (N=NM; N<NMFULL; N=N+1) begin : UNUSED_SRINDEX // {{{",
            "assign srindex[N] = 0; // }}} end endgenerate // Calculate mwindex generate for (M=0; M<NS; M=M+1) begin : SLAVE_WRITE_INDEX // {{{ if (NM <= 1) begin : SINGLE_MASTER // {{{",
            "assign mwindex[M] = 0; // }}} end else begin : MULTIPLE_MASTERS // {{{",
            "reg [LGNM-1:0] reswindex;",
            "reg [LGNM-1:0] r_mwindex;",
            "always @(*) begin reswindex = 0; for(iN=0; iN<NM; iN=iN+1) if ((!swgrant[iN] || swempty[iN]) &&(wrequest[iN][M] && !wrequested[iN][M])) reswindex = reswindex | iN[LGNM-1:0]; end",
            "always @(posedge S_AXI_ACLK) if (!mwgrant[M]) r_mwindex <= reswindex;",
            "assign mwindex[M] = r_mwindex; // }}} end // }}} end for (M=NS; M<NSFULL; M=M+1) begin : NO_WINDEX // {{{",
            "assign mwindex[M] = 0; // }}} end endgenerate // Calculate mrindex generate for (M=0; M<NS; M=M+1) begin : SLAVE_READ_INDEX // {{{ if (NM <= 1) begin : SINGLE_MASTER // {{{",
            "assign mrindex[M] = 0; // }}} end else begin : MULTIPLE_MASTERS // {{{",
            "reg [LGNM-1:0] resrindex;",
            "reg [LGNM-1:0] r_mrindex;",
            "always @(*) begin resrindex = 0; for(iN=0; iN<NM; iN=iN+1) if ((!srgrant[iN] || srempty[iN]) &&(rrequest[iN][M] && !rrequested[iN][M])) resrindex = resrindex | iN[LGNM-1:0]; end",
            "always @(posedge S_AXI_ACLK) if (!mrgrant[M]) r_mrindex <= resrindex;",
            "assign mrindex[M] = r_mrindex; // }}} end // }}} end for (M=NS; M<NSFULL; M=M+1) begin // {{{",
            "assign mrindex[M] = 0; // }}} end endgenerate // Assign",
            "output s to the various slaves generate for(M=0; M<NS; M=M+1) begin : WRITE_SLAVE_OUTPUTS // {{{ // Declarations // {{{",
            "reg axi_awvalid;",
            "reg [AW-1:0] axi_awaddr;",
            "reg [2:0] axi_awprot;",
            "reg axi_wvalid;",
            "reg [DW-1:0] axi_wdata;",
            "reg [DW/8-1:0] axi_wstrb; // reg axi_bready;",
            "wire sawstall, swstall, mbstall; // }}}",
            "assign sawstall= (M_AXI_AWVALID[M]&& !M_AXI_AWREADY[M]);",
            "assign swstall = (M_AXI_WVALID[M] && !M_AXI_WREADY[M]);",
            "assign mbstall = (S_AXI_BVALID[mwindex[M]] && !S_AXI_BREADY[mwindex[M]]); // axi_awvalid // {{{",
            "initial axi_awvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !mwgrant[M]) axi_awvalid <= 0; else if (!sawstall) begin axi_awvalid <= m_awvalid[mwindex[M]] &&(slave_awaccepts[mwindex[M]]); end // }}} // axi_awaddr, axi_awprot // {{{",
            "initial axi_awaddr = 0;",
            "initial axi_awprot = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) begin axi_awaddr <= 0; axi_awprot <= 0; end else if (OPT_LOWPOWER && !mwgrant[M]) begin axi_awaddr <= 0; axi_awprot <= 0; end else if (!sawstall) begin if (!OPT_LOWPOWER||(m_awvalid[mwindex[M]]&&slave_awaccepts[mwindex[M]])) begin axi_awaddr <= m_awaddr[mwindex[M]]; axi_awprot <= m_awprot[mwindex[M]]; end else begin axi_awaddr <= 0; axi_awprot <= 0; end end // }}} // axi_wvalid // {{{",
            "initial axi_wvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !mwgrant[M]) axi_wvalid <= 0; else if (!swstall) begin axi_wvalid <= (m_wvalid[mwindex[M]]) &&(slave_waccepts[mwindex[M]]); end // }}} // axi_wdata, axi_wstrb // {{{",
            "initial axi_wdata = 0;",
            "initial axi_wstrb = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) begin axi_wdata <= 0; axi_wstrb <= 0; end else if (OPT_LOWPOWER && !mwgrant[M]) begin axi_wdata <= 0; axi_wstrb <= 0; end else if (!swstall) begin if (!OPT_LOWPOWER || (m_wvalid[mwindex[M]]&&slave_waccepts[mwindex[M]])) begin axi_wdata <= m_wdata[mwindex[M]]; axi_wstrb <= m_wstrb[mwindex[M]]; end else begin axi_wdata <= 0; axi_wstrb <= 0; end end // }}} // axi_bready // {{{",
            "initial axi_bready = 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !mwgrant[M]) axi_bready <= 1; else if (!mbstall) axi_bready <= 1; else if (M_AXI_BVALID[M]) // && mbstall axi_bready <= 0; // }}} // assign M_AXI_AWVALID[M] = axi_awvalid;",
            "assign M_AXI_AWADDR[M*AW +: AW] = axi_awaddr;",
            "assign M_AXI_AWPROT[M*3 +: 3] = axi_awprot; // // assign M_AXI_WVALID[M] = axi_wvalid;",
            "assign M_AXI_WDATA[M*DW +: DW] = axi_wdata;",
            "assign M_AXI_WSTRB[M*DW/8 +: DW/8] = axi_wstrb; // // assign M_AXI_BREADY[M] = axi_bready; // `ifdef FORMAL // {{{ if (OPT_LOWPOWER) begin",
            "always @(*) if (!axi_awvalid) begin assert(axi_awaddr == 0); assert(axi_awprot == 0); end",
            "always @(*) if (!axi_wvalid) begin assert(axi_wdata == 0); assert(axi_wstrb == 0); end end // }}} `endif // }}} end endgenerate generate for(M=0; M<NS; M=M+1) begin : READ_SLAVE_OUTPUTS // {{{ // Declarations // {{{",
            "reg axi_arvalid;",
            "reg [C_AXI_ADDR_WIDTH-1:0] axi_araddr;",
            "reg [2:0] axi_arprot; // reg axi_rready;",
            "wire arstall, srstall; // }}}",
            "assign arstall= (M_AXI_ARVALID[M]&& !M_AXI_ARREADY[M]);",
            "assign srstall = (S_AXI_RVALID[mrindex[M]] && !S_AXI_RREADY[mrindex[M]]); // axi_arvalid // {{{",
            "initial axi_arvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !mrgrant[M]) axi_arvalid <= 0; else if (!arstall) begin axi_arvalid <= m_arvalid[mrindex[M]] && slave_raccepts[mrindex[M]]; end // }}} // axi_araddr, axi_arprot // {{{",
            "initial axi_araddr = 0;",
            "initial axi_arprot = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) begin axi_araddr <= 0; axi_arprot <= 0; end else if (OPT_LOWPOWER && !mrgrant[M]) begin axi_araddr <= 0; axi_arprot <= 0; end else if (!arstall) begin if (!OPT_LOWPOWER || (m_arvalid[mrindex[M]] && slave_raccepts[mrindex[M]])) begin if (NM == 1) begin axi_araddr <= m_araddr[0]; axi_arprot <= m_arprot[0]; end else begin axi_araddr <= m_araddr[mrindex[M]]; axi_arprot <= m_arprot[mrindex[M]]; end end else begin axi_araddr <= 0; axi_arprot <= 0; end end // }}} // axi_rready // {{{",
            "initial axi_rready = 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !mrgrant[M]) axi_rready <= 1; else if (!srstall) axi_rready <= 1; else if (M_AXI_RVALID[M] && M_AXI_RREADY[M]) // && srstall axi_rready <= 0; // }}} // assign M_AXI_ARVALID[M] = axi_arvalid;",
            "assign M_AXI_ARADDR[M*AW +: AW] = axi_araddr;",
            "assign M_AXI_ARPROT[M*3 +: 3] = axi_arprot; // assign M_AXI_RREADY[M] = axi_rready; // `ifdef FORMAL // {{{ if (OPT_LOWPOWER) begin",
            "always @(*) if (!axi_arvalid) begin assert(axi_araddr == 0); assert(axi_arprot == 0); end end // }}} `endif // }}} end endgenerate // Return values generate for (N=0; N<NM; N=N+1) begin : WRITE_RETURN_CHANNEL // {{{",
            "reg axi_bvalid;",
            "reg [1:0] axi_bresp;",
            "reg i_axi_bvalid;",
            "wire [1:0] i_axi_bresp;",
            "wire mbstall;",
            "initial i_axi_bvalid = 1'b0;",
            "always @(*) if (wgrant[N][NS]) i_axi_bvalid = m_wvalid[N] && slave_waccepts[N]; else i_axi_bvalid = m_axi_bvalid[swindex[N]];",
            "assign i_axi_bresp = m_axi_bresp[swindex[N]];",
            "assign mbstall = S_AXI_BVALID[N] && !S_AXI_BREADY[N]; // r_bvalid // {{{",
            "initial r_bvalid[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_bvalid[N] <= 0; else if (mbstall && !r_bvalid[N] && !wgrant[N][NS]) r_bvalid[N] <= swgrant[N] && i_axi_bvalid; else if (!mbstall) r_bvalid[N] <= 1'b0; // }}} // r_bresp // {{{",
            "initial r_bresp[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) r_bresp[N] <= 0; else if (OPT_LOWPOWER && (!swgrant[N] || S_AXI_BREADY[N])) r_bresp[N] <= 0; else if (!r_bvalid[N]) begin if (!OPT_LOWPOWER ||(i_axi_bvalid && !wgrant[N][NS] && mbstall)) begin r_bresp[N] <= i_axi_bresp; end else r_bresp[N] <= 0; end // }}} // axi_bvalid // {{{",
            "initial axi_bvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_bvalid <= 0; else if (!mbstall) axi_bvalid <= swgrant[N] && (r_bvalid[N] || i_axi_bvalid); // }}} // axi_bresp // {{{",
            "initial axi_bresp = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) axi_bresp <= 0; else if (OPT_LOWPOWER && !swgrant[N]) axi_bresp <= 0; else if (!mbstall) begin if (r_bvalid[N]) axi_bresp <= r_bresp[N]; else if (!OPT_LOWPOWER || i_axi_bvalid) axi_bresp <= i_axi_bresp; else axi_bresp <= 0; if (wgrant[N][NS] && (!OPT_LOWPOWER || i_axi_bvalid)) axi_bresp <= INTERCONNECT_ERROR; end // }}} // assign S_AXI_BVALID[N] = axi_bvalid;",
            "assign S_AXI_BRESP[N*2 +: 2] = axi_bresp; `ifdef FORMAL // {{{",
            "always @(*) if (r_bvalid[N]) assert(r_bresp[N] != 2'b01);",
            "always @(*) if (swgrant[N]) assert(m_axi_bready[swindex[N]] == !r_bvalid[N]); else assert(!r_bvalid[N]);",
            "always @(*) if (OPT_LOWPOWER && !r_bvalid[N]) assert(r_bresp[N] == 0);",
            "always @(*) if (OPT_LOWPOWER && !axi_bvalid) assert(axi_bresp == 0); // }}} `endif // }}} end endgenerate // m_axi_?r* values // {{{",
            "always @(*) begin m_axi_arvalid = 0; m_axi_arready = 0; m_axi_rvalid = 0; m_axi_rready = 0; m_axi_arvalid[NS-1:0] = M_AXI_ARVALID; m_axi_arready[NS-1:0] = M_AXI_ARREADY; m_axi_rvalid[NS-1:0] = M_AXI_RVALID; m_axi_rready[NS-1:0] = M_AXI_RREADY; end // }}} // Return values generate for (N=0; N<NM; N=N+1) begin : READ_RETURN_CHANNEL // {{{",
            "reg axi_rvalid;",
            "reg [1:0] axi_rresp;",
            "reg [DW-1:0] axi_rdata;",
            "wire srstall;",
            "reg i_axi_rvalid;",
            "initial i_axi_rvalid = 1'b0;",
            "always @(*) if (rgrant[N][NS]) i_axi_rvalid = m_arvalid[N] && slave_raccepts[N]; else i_axi_rvalid = m_axi_rvalid[srindex[N]];",
            "assign srstall = S_AXI_RVALID[N] && !S_AXI_RREADY[N];",
            "initial r_rvalid[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_rvalid[N] <= 0; else if (srstall && !r_rvalid[N]) r_rvalid[N] <= srgrant[N] && !rgrant[N][NS]&&i_axi_rvalid; else if (!srstall) r_rvalid[N] <= 0;",
            "initial r_rresp[N] = 0;",
            "initial r_rdata[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) begin r_rresp[N] <= 0; r_rdata[N] <= 0; end else if (OPT_LOWPOWER && (!srgrant[N] || S_AXI_RREADY[N])) begin r_rresp[N] <= 0; r_rdata[N] <= 0; end else if (!r_rvalid[N]) begin if (!OPT_LOWPOWER || (i_axi_rvalid && !rgrant[N][NS] && srstall)) begin if (NS == 1) begin r_rresp[N] <= m_axi_rresp[0]; r_rdata[N] <= m_axi_rdata[0]; end else begin r_rresp[N] <= m_axi_rresp[srindex[N]]; r_rdata[N] <= m_axi_rdata[srindex[N]]; end end else begin r_rresp[N] <= 0; r_rdata[N] <= 0; end end",
            "initial axi_rvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_rvalid <= 0; else if (!srstall) axi_rvalid <= srgrant[N] && (r_rvalid[N] || i_axi_rvalid);",
            "initial axi_rresp = 0;",
            "initial axi_rdata = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) begin axi_rresp <= 0; axi_rdata <= 0; end else if (OPT_LOWPOWER && !srgrant[N]) begin axi_rresp <= 0; axi_rdata <= 0; end else if (!srstall) begin if (r_rvalid[N]) begin axi_rresp <= r_rresp[N]; axi_rdata <= r_rdata[N]; end else if (!OPT_LOWPOWER || i_axi_rvalid) begin if (NS == 1) begin axi_rresp <= m_axi_rresp[0]; axi_rdata <= m_axi_rdata[0]; end else begin axi_rresp <= m_axi_rresp[srindex[N]]; axi_rdata <= m_axi_rdata[srindex[N]]; end if (rgrant[N][NS]) axi_rresp <= INTERCONNECT_ERROR; end else begin axi_rresp <= 0; axi_rdata <= 0; end end",
            "assign S_AXI_RVALID[N] = axi_rvalid;",
            "assign S_AXI_RRESP[N*2 +: 2] = axi_rresp;",
            "assign S_AXI_RDATA[N*DW +: DW]= axi_rdata; `ifdef FORMAL // {{{",
            "always @(*) if (r_rvalid[N]) assert(r_rresp[N] != 2'b01);",
            "always @(*) if (srgrant[N] && !rgrant[N][NS]) assert(m_axi_rready[srindex[N]] == !r_rvalid[N]); else assert(!r_rvalid[N]);",
            "always @(*) if (OPT_LOWPOWER && !r_rvalid[N]) begin assert(r_rresp[N] == 0); assert(r_rdata[N] == 0); end",
            "always @(*) if (OPT_LOWPOWER && !axi_rvalid) begin assert(axi_rresp == 0); assert(axi_rdata == 0); end // }}} `endif // }}} end endgenerate // Count pending transactions generate for (N=0; N<NM; N=N+1) begin : COUNT_PENDING // {{{",
            "reg [LGMAXBURST-1:0] wpending, awpending, rpending, missing_wdata; // reg rempty, awempty; // wempty;",
            "reg r_wdata_expected;",
            "initial awpending = 0;",
            "initial swempty[N] = 1;",
            "initial swfull[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin awpending <= 0; swempty[N] <= 1; swfull[N] <= 0; end else case ({(m_awvalid[N] && slave_awaccepts[N]), (S_AXI_BVALID[N] && S_AXI_BREADY[N])}) 2'b01: begin awpending <= awpending - 1; swempty[N] <= (awpending <= 1); swfull[N] <= 0; end 2'b10: begin awpending <= awpending + 1; swempty[N] <= 0; swfull[N] <= &awpending[LGMAXBURST-1:1]; end default: begin end endcase",
            "initial wpending = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) wpending <= 0; else case ({(m_wvalid[N] && slave_waccepts[N]), (S_AXI_BVALID[N] && S_AXI_BREADY[N])}) 2'b01: wpending <= wpending - 1; 2'b10: wpending <= wpending + 1; default: begin end endcase",
            "initial missing_wdata = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) missing_wdata <= 0; else begin missing_wdata <= missing_wdata +((m_awvalid[N] && slave_awaccepts[N])? 1:0) -((m_wvalid[N] && slave_waccepts[N])? 1:0); end",
            "initial r_wdata_expected = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_wdata_expected <= 0; else case({ m_awvalid[N] && slave_awaccepts[N], m_wvalid[N] && slave_waccepts[N] }) 2'b10: r_wdata_expected <= 1; 2'b01: r_wdata_expected <= (missing_wdata > 1); default: begin end endcase",
            "initial rpending = 0;",
            "initial srempty[N] = 1;",
            "initial srfull[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin rpending <= 0; srempty[N]<= 1; srfull[N] <= 0; end else case ({(m_arvalid[N] && slave_raccepts[N]), (S_AXI_RVALID[N] && S_AXI_RREADY[N])}) 2'b01: begin rpending <= rpending - 1; srempty[N] <= (rpending == 1); srfull[N] <= 0; end 2'b10: begin rpending <= rpending + 1; srfull[N] <= &rpending[LGMAXBURST-1:1]; srempty[N] <= 0; end default: begin end endcase",
            "assign w_sawpending[N] = awpending;",
            "assign w_swpending[N] = wpending;",
            "assign w_srpending[N] = rpending;",
            "assign wdata_expected[N] = r_wdata_expected; `ifdef FORMAL // {{{",
            "reg [LGMAXBURST-1:0] f_missing_wdata;",
            "always @(*) assert(missing_wdata == awpending - wpending);",
            "always @(*) assert(r_wdata_expected == (missing_wdata > 0));",
            "always @(*) assert(awpending >= wpending); // }}} `endif // }}} end endgenerate // Property validation // {{{",
            "initial begin if (NM == 0) begin $display(\"At least one master must be defined\"); $stop; end if (NS == 0) begin $display(\"At least one slave must be defined\"); $stop; end end // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties used to verify this core // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Local declarations // {{{",
            "localparam F_LGDEPTH = LGMAXBURST+1;",
            "wire [F_LGDEPTH-1:0] fm_rd_outstanding [0:NM-1];",
            "wire [F_LGDEPTH-1:0] fm_wr_outstanding [0:NM-1];",
            "wire [F_LGDEPTH-1:0] fm_awr_outstanding [0:NM-1];",
            "wire [F_LGDEPTH-1:0] fs_rd_outstanding [0:NS-1];",
            "wire [F_LGDEPTH-1:0] fs_wr_outstanding [0:NS-1];",
            "wire [F_LGDEPTH-1:0] fs_awr_outstanding [0:NS-1];",
            "initial assert(NS >= 1);",
            "initial assert(NM >= 1); // }}} `ifdef VERIFIC",
            "reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge S_AXI_ACLK) f_past_valid <= 1; //////////////////////////////////////////////////////////////////////// // // Initial value checks // {{{ //////////////////////////////////////////////////////////////////////// // // `ifdef VERIFIC `define INITIAL_CHECK assume `else `define INITIAL_CHECK assert `endif // VERIFIC",
            "always @(*) if (!f_past_valid) begin `INITIAL_CHECK(!S_AXI_ARESETN); `INITIAL_CHECK(S_AXI_BVALID == 0); `INITIAL_CHECK(S_AXI_RVALID == 0); `INITIAL_CHECK(swgrant == 0); `INITIAL_CHECK(srgrant == 0); `INITIAL_CHECK(swfull == 0); `INITIAL_CHECK(srfull == 0); `INITIAL_CHECK(&swempty); `INITIAL_CHECK(&srempty); for(iN=0; iN<NM; iN=iN+1) begin `INITIAL_CHECK(wgrant[iN] == 0); assume(swindex[iN] == 0); `INITIAL_CHECK(rgrant[iN] == 0); assume(srindex[iN] == 0); `INITIAL_CHECK(r_bvalid[iN] == 0); `INITIAL_CHECK(r_rvalid[iN] == 0); // `INITIAL_CHECK(r_bresp[iN] == 0); // `INITIAL_CHECK(r_rresp[iN] == 0); `INITIAL_CHECK(r_rdata[iN] == 0); end `INITIAL_CHECK(M_AXI_AWVALID == 0); `INITIAL_CHECK(M_AXI_WVALID == 0); `INITIAL_CHECK(M_AXI_RVALID == 0); end `endif // }}} generate for(N=0; N<NM; N=N+1) begin : CHECK_MASTER_GRANTS // {{{ //////////////////////////////////////////////////////////////// // Write grant checks // {{{",
            "always @(*) for(iM=0; iM<=NS; iM=iM+1) begin if (wgrant[N][iM]) begin assert((wgrant[N] ^ (1<<iM))==0); assert(swgrant[N]); assert(swindex[N] == iM); if (iM < NS) begin assert(mwgrant[iM]); assert(mwindex[iM] == N); end end end",
            "always @(*) if (swgrant[N]) assert(wgrant[N] != 0);",
            "always @(*) if (wrequest[N][NS]) assert(wrequest[N][NS-1:0] == 0); // }}} //////////////////////////////////////////////////////////////// // // Read grant checking // {{{",
            "always @(*) for(iM=0; iM<=NS; iM=iM+1) begin if (rgrant[N][iM]) begin assert((rgrant[N] ^ (1<<iM))==0); assert(srgrant[N]); assert(srindex[N] == iM); if (iM < NS) begin assert(mrgrant[iM]); assert(mrindex[iM] == N); end end end",
            "always @(*) if (srgrant[N]) assert(rgrant[N] != 0);",
            "always @(*) if (rrequest[N][NS]) assert(rrequest[N][NS-1:0] == 0); // }}} // }}} end endgenerate generate for(N=0; N<NM; N=N+1) begin : CHECK_MASTERS // {{{ faxil_slave #( .C_AXI_DATA_WIDTH(DW), .C_AXI_ADDR_WIDTH(AW), .F_OPT_ASSUME_RESET(1'b1), .F_AXI_MAXWAIT(0), .F_AXI_MAXDELAY(0), .F_LGDEPTH(F_LGDEPTH)) mstri(.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // .i_axi_awvalid(S_AXI_AWVALID[N]), .i_axi_awready(S_AXI_AWREADY[N]), .i_axi_awaddr(S_AXI_AWADDR[N*AW +: AW]), .i_axi_awprot(S_AXI_AWPROT[N*3 +: 3]), // .i_axi_wvalid(S_AXI_WVALID[N]), .i_axi_wready(S_AXI_WREADY[N]), .i_axi_wdata( S_AXI_WDATA[N*DW +: DW]), .i_axi_wstrb( S_AXI_WSTRB[N*DW/8 +: DW/8]), // .i_axi_bvalid(S_AXI_BVALID[N]), .i_axi_bready(S_AXI_BREADY[N]), .i_axi_bresp( S_AXI_BRESP[N*2 +: 2]), // .i_axi_arvalid(S_AXI_ARVALID[N]), .i_axi_arready(S_AXI_ARREADY[N]), .i_axi_araddr( S_AXI_ARADDR[N*AW +: AW]), .i_axi_arprot( S_AXI_ARPROT[N*3 +: 3]), // // .i_axi_rvalid(S_AXI_RVALID[N]), .i_axi_rready(S_AXI_RREADY[N]), .i_axi_rdata( S_AXI_RDATA[N*DW +: DW]), .i_axi_rresp( S_AXI_RRESP[N*2 +: 2]), // .f_axi_rd_outstanding( fm_rd_outstanding[N]), .f_axi_wr_outstanding( fm_wr_outstanding[N]), .f_axi_awr_outstanding(fm_awr_outstanding[N])); // // Check write counters // always @(*) if (S_AXI_ARESETN) assert(fm_awr_outstanding[N] == { 1'b0, w_sawpending[N] } +((OPT_BUFFER_DECODER & dcd_awvalid[N]) ? 1:0) + (S_AXI_AWREADY[N] ? 0:1));",
            "always @(*) if (S_AXI_ARESETN) assert(fm_wr_outstanding[N] == { 1'b0, w_swpending[N] } + (S_AXI_WREADY[N] ? 0:1));",
            "always @(*) if (S_AXI_ARESETN) assert(fm_awr_outstanding[N] >= (S_AXI_AWREADY[N] ? 0:1) +((OPT_BUFFER_DECODER & dcd_awvalid[N]) ? 1:0) + (S_AXI_BVALID[N] ? 1:0));",
            "always @(*) if (S_AXI_ARESETN) assert(fm_wr_outstanding[N] >= (S_AXI_WREADY[N] ? 0:1) + (S_AXI_BVALID[N]? 1:0));",
            "always @(*) if (S_AXI_ARESETN) assert(fm_wr_outstanding[N]-(S_AXI_WREADY[N] ? 0:1) <= fm_awr_outstanding[N]-(S_AXI_AWREADY[N] ? 0:1));",
            "always @(*) if (S_AXI_ARESETN && wgrant[N][NS]) assert(fm_wr_outstanding[N] == (S_AXI_WREADY[N] ? 0:1) + (S_AXI_BVALID[N] ? 1:0));",
            "always @(*) if (S_AXI_ARESETN && !swgrant[N]) begin assert(!S_AXI_BVALID[N]); assert(fm_awr_outstanding[N]==(S_AXI_AWREADY[N] ? 0:1) +((OPT_BUFFER_DECODER & dcd_awvalid[N]) ? 1:0)); assert(fm_wr_outstanding[N] == (S_AXI_WREADY[N] ? 0:1)); assert(w_sawpending[N] == 0); assert(w_swpending[N] == 0); end // // Check read counters // always @(*) if (S_AXI_ARESETN) assert(fm_rd_outstanding[N] >= (S_AXI_ARREADY[N] ? 0:1) +(S_AXI_RVALID[N] ? 1:0));",
            "always @(*) if (S_AXI_ARESETN && (!srgrant[N] || rgrant[N][NS])) assert(fm_rd_outstanding[N] == (S_AXI_ARREADY[N] ? 0:1) +((OPT_BUFFER_DECODER & dcd_arvalid[N]) ? 1:0) +(S_AXI_RVALID[N] ? 1:0));",
            "always @(*) if (S_AXI_ARESETN) assert(fm_rd_outstanding[N] == { 1'b0, w_srpending[N] } +((OPT_BUFFER_DECODER & dcd_arvalid[N]) ? 1:0) + (S_AXI_ARREADY[N] ? 0:1));",
            "always @(*) if (S_AXI_ARESETN && rgrant[N][NS]) assert(fm_rd_outstanding[N] == (S_AXI_ARREADY[N] ? 0:1) +((OPT_BUFFER_DECODER & dcd_arvalid[N]) ? 1:0) +(S_AXI_RVALID[N] ? 1:0));",
            "always @(*) if (S_AXI_ARESETN && !srgrant[N]) begin assert(!S_AXI_RVALID[N]); assert(fm_rd_outstanding[N]== (S_AXI_ARREADY[N] ? 0:1) +((OPT_BUFFER_DECODER && dcd_arvalid[N])? 1:0)); assert(w_srpending[N] == 0); end // // Check full/empty flags // localparam [LGMAXBURST-1:0] NEAR_THRESHOLD = -2;",
            "always @(*) begin assert(swfull[N] == &w_sawpending[N]); assert(swempty[N] == (w_sawpending[N] == 0)); end",
            "always @(*) begin assert(srfull[N] == &w_srpending[N]); assert(srempty[N] == (w_srpending[N] == 0)); end // }}} end endgenerate generate for(M=0; M<NS; M=M+1) begin : CHECK_SLAVES // {{{ faxil_master #( .C_AXI_DATA_WIDTH(DW), .C_AXI_ADDR_WIDTH(AW), .F_OPT_ASSUME_RESET(1'b1), .F_AXI_MAXRSTALL(0), .F_LGDEPTH(F_LGDEPTH)) slvi(.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // .i_axi_awvalid(M_AXI_AWVALID[M]), .i_axi_awready(M_AXI_AWREADY[M]), .i_axi_awaddr(M_AXI_AWADDR[M*AW +: AW]), .i_axi_awprot(M_AXI_AWPROT[M*3 +: 3]), // .i_axi_wvalid(M_AXI_WVALID[M]), .i_axi_wready(M_AXI_WREADY[M]), .i_axi_wdata( M_AXI_WDATA[M*DW +: DW]), .i_axi_wstrb( M_AXI_WSTRB[M*DW/8 +: DW/8]), // .i_axi_bvalid(M_AXI_BVALID[M]), .i_axi_bready(M_AXI_BREADY[M]), .i_axi_bresp( M_AXI_BRESP[M*2 +: 2]), // .i_axi_arvalid(M_AXI_ARVALID[M]), .i_axi_arready(M_AXI_ARREADY[M]), .i_axi_araddr( M_AXI_ARADDR[M*AW +: AW]), .i_axi_arprot( M_AXI_ARPROT[M*3 +: 3]), // // .i_axi_rvalid(M_AXI_RVALID[M]), .i_axi_rready(M_AXI_RREADY[M]), .i_axi_rdata( M_AXI_RDATA[M*DW +: DW]), .i_axi_rresp( M_AXI_RRESP[M*2 +: 2]), // .f_axi_rd_outstanding( fs_rd_outstanding[M]), .f_axi_wr_outstanding( fs_wr_outstanding[M]), .f_axi_awr_outstanding(fs_awr_outstanding[M]));",
            "always @(*) assert(fs_wr_outstanding[M] + (M_AXI_WVALID[M] ? 1:0) <= fs_awr_outstanding[M] + (M_AXI_AWVALID[M]? 1:0));",
            "always @(*) if (!mwgrant[M]) begin assert(fs_awr_outstanding[M] == 0); assert(fs_wr_outstanding[M] == 0); end",
            "always @(*) if (!mrgrant[M]) assert(fs_rd_outstanding[M] == 0);",
            "always @(*) assert(fs_awr_outstanding[M] < { 1'b1, {(F_LGDEPTH-1){1'b0}} });",
            "always @(*) assert(fs_wr_outstanding[M] < { 1'b1, {(F_LGDEPTH-1){1'b0}} });",
            "always @(*) assert(fs_rd_outstanding[M] < { 1'b1, {(F_LGDEPTH-1){1'b0}} });",
            "always @(*) if (M_AXI_AWVALID[M]) assert(((M_AXI_AWADDR[M*AW +: AW] ^ SLAVE_ADDR[M*AW +: AW]) & SLAVE_MASK[M*AW +: AW]) == 0);",
            "always @(*) if (M_AXI_ARVALID[M]) assert(((M_AXI_ARADDR[M*AW +: AW] ^ SLAVE_ADDR[M*AW +: AW]) & SLAVE_MASK[M*AW +: AW]) == 0); // }}} end endgenerate generate for(N=0; N<NM; N=N+1) begin : CORRELATE_OUTSTANDING // {{{",
            "always @(*) if (S_AXI_ARESETN && (swgrant[N] && (swindex[N] < NS))) begin assert((fm_awr_outstanding[N] - (S_AXI_AWREADY[N] ? 0:1) -((OPT_BUFFER_DECODER && dcd_awvalid[N]) ? 1:0) - (S_AXI_BVALID[N] ? 1:0)) == (fs_awr_outstanding[swindex[N]] + (m_axi_awvalid[swindex[N]] ? 1:0) + (m_axi_bready[swindex[N]] ? 0:1))); assert((fm_wr_outstanding[N] - (S_AXI_WREADY[N] ? 0:1) - (S_AXI_BVALID[N] ? 1:0)) == (fs_wr_outstanding[swindex[N]] + (m_axi_wvalid[swindex[N]] ? 1:0) + (m_axi_bready[swindex[N]] ? 0:1))); end else if (S_AXI_ARESETN && (!swgrant[N] || (swindex[N]==NS))) begin if (!swgrant[N]) assert(fm_awr_outstanding[N] == (S_AXI_AWREADY[N] ? 0:1) +((OPT_BUFFER_DECODER && dcd_awvalid[N]) ? 1:0) +(S_AXI_BVALID[N] ? 1:0)); else assert(fm_awr_outstanding[N] >= (S_AXI_AWREADY[N] ? 0:1) +((OPT_BUFFER_DECODER && dcd_awvalid[N]) ? 1:0) +(S_AXI_BVALID[N] ? 1:0)); assert(fm_wr_outstanding[N] == (S_AXI_WREADY[N] ? 0:1) +(S_AXI_BVALID[N] ? 1:0)); end",
            "always @(*) if (srgrant[N] && (srindex[N] < NS)) begin assert((fm_rd_outstanding[N]//17 - (S_AXI_ARREADY[N] ? 0:1)//1 -((OPT_BUFFER_DECODER && dcd_arvalid[N]) ? 1:0) - (S_AXI_RVALID[N] ? 1:0))//0 == (fs_rd_outstanding[srindex[N]]//16 + (m_axi_arvalid[srindex[N]] ? 1:0)//0 + (m_axi_rready[srindex[N]] ? 0:1)));//0 end // }}} end endgenerate //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // // Can every master reach every slave? // Can things transition without dropping the request line(s)? generate for(N=0; N<NM; N=N+1) begin : COVER_CONNECTIVITY_FROM_MASTER",
            "reg [3:0] w_returns, r_returns;",
            "reg err_wr_return, err_rd_return;",
            "reg [NS-1:0] w_every, r_every;",
            "reg was_wevery, was_revery, whsreturn, rhsreturn; // w_returns is a speed check: Can we return one write // acknowledgement per clock cycle?",
            "initial w_returns = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) w_returns = 0; else begin w_returns <= { w_returns[2:0], 1'b0 }; if (S_AXI_BVALID[N] && S_AXI_BREADY[N] && !wgrant[N][NS]) w_returns[0] <= 1'b1; end",
            "initial whsreturn = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) whsreturn <= 0; else whsreturn <= whsreturn || (&w_returns); // w_every is a connectivity test: Can we get a return from // every slave?",
            "initial w_every = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) w_every <= 0; else if (!S_AXI_AWVALID[N]) w_every <= 0; else begin if (S_AXI_BVALID[N] && S_AXI_BREADY[N] && !wgrant[N][NS]) w_every[swindex[N]] <= 1'b1; end",
            "always @(posedge S_AXI_ACLK) if (S_AXI_BVALID[N]) assert($stable(swindex[N]));",
            "initial was_wevery = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) was_wevery <= 0; else was_wevery <= was_wevery || (&w_every); // err_wr_return is a test to make certain we can return a // bus error on the write channel.",
            "initial err_wr_return = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) err_wr_return = 0; else if (wgrant[N][NS] && S_AXI_BVALID[N] && (S_AXI_BRESP[2*N+:2]==INTERCONNECT_ERROR)) err_wr_return = 1; `ifndef VERILATOR",
            "always @(*) cover(!swgrant[N] && whsreturn);",
            "always @(*) cover(!swgrant[N] && was_wevery);",
            "always @(*) cover(S_AXI_ARESETN && wrequest[N][NS]);",
            "always @(*) cover(S_AXI_ARESETN && wrequest[N][NS] && slave_awaccepts[N]);",
            "always @(*) cover(err_wr_return);",
            "always @(*) cover(!swgrant[N] && err_wr_return); `endif",
            "always @(*) if (S_AXI_BVALID[N]) assert(swgrant[N]); // r_returns is a speed check: Can we return one read // acknowledgment per clock cycle?",
            "initial r_returns = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_returns = 0; else begin r_returns <= { r_returns[2:0], 1'b0 }; if (S_AXI_RVALID[N] && S_AXI_RREADY[N]) r_returns[0] <= 1'b1; end",
            "initial rhsreturn = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) rhsreturn <= 0; else rhsreturn <= rhsreturn || (&r_returns); // r_every is a connectivity test: Can we get a read return from // every slave?",
            "initial r_every = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_every = 0; else if (!S_AXI_ARVALID[N]) r_every = 0; else begin if (S_AXI_RVALID[N] && S_AXI_RREADY[N]) r_every[srindex[N]] <= 1'b1; end // was_revery is a return to idle check following the // connectivity test. Since the connectivity test is cleared // if there's ever a drop in the valid line, we need a separate // wire to check that this master can return to idle again.",
            "initial was_revery = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) was_revery <= 0; else was_revery <= was_revery || (&r_every);",
            "always @(posedge S_AXI_ACLK) if (S_AXI_RVALID[N]) assert($stable(srindex[N]));",
            "initial err_rd_return = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) err_rd_return = 0; else if (rgrant[N][NS] && S_AXI_RVALID[N] && (S_AXI_RRESP[2*N+:2]==INTERCONNECT_ERROR)) err_rd_return = 1; `ifndef VERILATOR",
            "always @(*) cover(!srgrant[N] && rhsreturn); // @26",
            "always @(*) cover(!srgrant[N] && was_revery); // @26",
            "always @(*) cover(S_AXI_ARVALID[N] && rrequest[N][NS]);",
            "always @(*) cover(rgrant[N][NS]);",
            "always @(*) cover(err_rd_return);",
            "always @(*) cover(!srgrant[N] && err_rd_return); //@! `endif",
            "always @(*) if (S_AXI_BVALID[N] && wgrant[N][NS]) assert(S_AXI_BRESP[2*N+:2]==INTERCONNECT_ERROR);",
            "always @(*) if (S_AXI_RVALID[N] && rgrant[N][NS]) assert(S_AXI_RRESP[2*N+:2]==INTERCONNECT_ERROR); end endgenerate",
            "reg multi_write_hit, multi_read_hit;",
            "initial multi_write_hit = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) multi_write_hit <= 0; else if (fm_awr_outstanding[0] > 2 && !wgrant[0][NS]) multi_write_hit <= 1;",
            "initial multi_read_hit = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) multi_read_hit <= 0; else if (fm_rd_outstanding[0] > 2 && !rgrant[0][NS]) multi_read_hit <= 1;",
            "always @(*) cover(multi_write_hit);",
            "always @(*) cover(multi_read_hit);",
            "always @(*) cover(S_AXI_ARESETN && multi_write_hit & mwgrant == 0 && M_AXI_BVALID == 0);",
            "always @(*) cover(S_AXI_ARESETN && multi_read_hit & mrgrant == 0 && M_AXI_RVALID == 0); // }}} //////////////////////////////////////////////////////////////////////// // // Negation check // {{{ // Pick a particular value. Assume the value doesn't show up on the // input . Prove it doesn't show up on the",
            "output . This will check for // ... // 1. Stuck bits on the",
            "output channel // 2. Cross-talk between channels // //////////////////////////////////////////////////////////////////////// // // (* anyconst *)",
            "reg [LGNM-1:0] f_const_source; (* anyconst *)",
            "reg [AW-1:0] f_const_addr; (* anyconst *)",
            "reg [AW-1:0] f_const_addr_n; (* anyconst *)",
            "reg [DW-1:0] f_const_data_n; (* anyconst *)",
            "reg [DW/8-1:0] f_const_strb_n; (* anyconst *)",
            "reg [3-1:0] f_const_prot_n; (* anyconst *)",
            "reg [2-1:0] f_const_resp_n;",
            "reg [LGNS-1:0] f_const_slave;",
            "always @(*) assume(f_const_source < NM);",
            "always @(*) begin f_const_slave = NS; for(iM=0; iM<NS; iM=iM+1) begin if (((f_const_addr ^ SLAVE_ADDR[iM*AW+:AW]) &SLAVE_MASK[iM*AW+:AW])==0) f_const_slave = iM; end assume(f_const_slave < NS); end",
            "reg [AW-1:0] f_awaddr;",
            "reg [AW-1:0] f_araddr;",
            "always @(*) f_awaddr = S_AXI_AWADDR[f_const_source * AW +: AW];",
            "always @(*) f_araddr = S_AXI_ARADDR[f_const_source * AW +: AW]; // The assumption check: assume our negated values are not found on // the",
            "input s",
            "always @(*) begin if (S_AXI_AWVALID[f_const_source]) begin assume(f_awaddr != f_const_addr_n); assume(S_AXI_AWPROT[f_const_source*3+:3] != f_const_prot_n); end if (m_wvalid) begin assume(m_wdata[f_const_source] != f_const_data_n); assume(m_wstrb[f_const_source] != f_const_strb_n); end if (S_AXI_ARVALID[f_const_source]) begin assume(f_araddr != f_const_addr_n); assume(S_AXI_ARPROT[f_const_source*3+:3] != f_const_prot_n); end if (M_AXI_BVALID[f_const_slave] && wgrant[f_const_source][f_const_slave]) begin assume(m_axi_bresp[f_const_slave] != f_const_resp_n); end if (M_AXI_RVALID[f_const_slave] && rgrant[f_const_source][f_const_slave]) begin assume(m_axi_rdata[f_const_slave] != f_const_data_n); assume(m_axi_rresp[f_const_slave] != f_const_resp_n); end end // Proof check: Prove these values are not found on our",
            "output s",
            "always @(*) begin if (skd_awvalid[f_const_source]) begin assert(skd_awaddr[f_const_source] != f_const_addr_n); assert(skd_awprot[f_const_source] != f_const_prot_n); end if (dcd_awvalid[f_const_source]) begin assert(m_awaddr[f_const_source] != f_const_addr_n); assert(m_awprot[f_const_source] != f_const_prot_n); end if (M_AXI_AWVALID[f_const_slave] && wgrant[f_const_source][f_const_slave]) begin assert(M_AXI_AWADDR[f_const_slave*AW+:AW] != f_const_addr_n); assert(M_AXI_AWPROT[f_const_slave*3+:3] != f_const_prot_n); end if (M_AXI_WVALID[f_const_slave] && wgrant[f_const_source][f_const_slave]) begin assert(M_AXI_WDATA[f_const_slave*DW+:DW] != f_const_data_n); assert(M_AXI_WSTRB[f_const_slave*(DW/8)+:(DW/8)] != f_const_strb_n); end if (skd_arvalid[f_const_source]) begin assert(skd_araddr[f_const_source] != f_const_addr_n); assert(skd_arprot[f_const_source] != f_const_prot_n); end if (dcd_arvalid[f_const_source]) begin assert(m_araddr[f_const_source] != f_const_addr_n); assert(m_arprot[f_const_source] != f_const_prot_n); end if (M_AXI_ARVALID[f_const_slave] && rgrant[f_const_source][f_const_slave]) begin assert(M_AXI_ARADDR[f_const_slave*AW+:AW] != f_const_addr_n); assert(M_AXI_ARPROT[f_const_slave*3+:3] != f_const_prot_n); end // if (r_bvalid[f_const_source] && wgrant[f_const_source][f_const_slave]) assert(r_bresp[f_const_source] != f_const_resp_n); if (S_AXI_BVALID[f_const_source] && wgrant[f_const_source][f_const_slave]) assert(S_AXI_BRESP[f_const_source*2+:2] != f_const_resp_n); if (r_rvalid[f_const_source] && rgrant[f_const_source][f_const_slave]) begin assert(r_rresp[f_const_source] != f_const_resp_n); assert(r_rdata[f_const_source] != f_const_data_n); end if (S_AXI_RVALID[f_const_source] && rgrant[f_const_source][f_const_slave]) begin assert(S_AXI_RRESP[f_const_source*2+:2]!=f_const_resp_n); assert(S_AXI_RDATA[f_const_source*DW+:DW]!=f_const_data_n); end end // }}} //////////////////////////////////////////////////////////////////////// // // (Careless) constraining assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // generate for(N=0; N<NM; N=N+1) begin end endgenerate // }}} `endif // }}}",
            "endmodule `ifndef YOSYS `default_nettype",
            "wire `endif"
        ]
    },
    {
        "file_name": "zipdma_check.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/zipdma_check.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: zipdma_check.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: ZipDMA -- // // // Creator: Sukru Uzun // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2022-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// `timescale 1ns/1ps `default_nettype none // }}}",
            "module zipdma_check #(",
            "parameter ADDRESS_WIDTH = 30, parameter BUS_WIDTH = 64 ) ( // {{{",
            "input wire i_clk, i_reset, // High-speed, high width Wishbone test/data port // {{{",
            "input wire i_wb_cyc, i_wb_stb, input wire i_wb_we, input wire [AW-1:0] i_wb_addr, input wire [DW-1:0] i_wb_data, input wire [DW/8-1:0] i_wb_sel, // // verilator coverage_off",
            "output wire o_wb_stall, // verilator coverage_on",
            "output reg o_wb_ack, output wire [DW-1:0] o_wb_data, // verilator coverage_off",
            "output wire o_wb_err, // verilator coverage_on // }}} // Wishbone status port // {{{",
            "input wire i_st_cyc, i_st_stb, input wire i_st_we, input wire i_st_addr, input wire [31:0] i_st_data, input wire [3:0] i_st_sel, // // verilator coverage_off",
            "output wire o_st_stall, // verilator coverage_on",
            "output reg o_st_ack, output reg [31:0] o_st_data, // verilator coverage_off",
            "output wire o_st_err // verilator coverage_on // }}} // }}} ); // Local declarations // {{{",
            "localparam DW = BUS_WIDTH;",
            "localparam AW = ADDRESS_WIDTH-$clog2(DW/8);",
            "localparam BW = DW/8; // BIT_WIDTH",
            "reg [DW-1:0] lfsr_state;",
            "wire rd_data_en, wr_data_en;",
            "reg [11:0] rd_count, wr_count;",
            "reg [11:0] rd_count_",
            "reg , wr_count_",
            "reg ; // }}} // rd_data_en, wr_data_en",
            "assign rd_data_en = i_wb_stb && !i_wb_we && (i_wb_sel != 0);",
            "assign wr_data_en = i_wb_stb && i_wb_we && (i_wb_sel != 0); // Wishbone",
            "output s",
            "assign o_wb_stall = 1'b0;",
            "assign o_wb_err = 1'b0;",
            "assign o_wb_data = lfsr_state;",
            "assign o_st_stall = 1'b0;",
            "assign o_st_err = 1'b0; // o_st_ack",
            "always @(posedge i_clk) if (i_reset) o_st_ack <= 1'b0; else o_st_ack <= i_st_stb; // lfsr_state // {{{",
            "always @(posedge i_clk) if (i_reset) lfsr_state <= 0; // initial state else begin if (i_st_stb && i_st_we && (i_st_sel != 0)) begin // set an",
            "initial per-test state lfsr_state <= 0; for (int i = 0; i < 4; i++) if (i_st_sel[i]) lfsr_state[(DW-32) + (i*8) +: 8] <= i_st_data[(i*8) +: 8]; end // feedback if (rd_data_en) lfsr_state <= {lfsr_state[DW-2:0], lfsr_state[DW-1] ^ lfsr_state[DW-2]}; end // }}} // o_wb_ack // {{{",
            "initial o_wb_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_wb_ack <= 0; else o_wb_ack <= i_wb_stb && !o_wb_stall; // }}} // rd_count, wr_count // {{{",
            "always @(*) begin rd_count = rd_count_",
            "reg ; wr_count = wr_count_",
            "reg ; // reset counter after lfsr",
            "initial ization if (i_st_stb && i_st_we && (i_st_sel != 0)) begin rd_count = 0; wr_count = 0; end else for (int i = 0; i < BW; i++) if (i_wb_sel[i]) begin rd_count = rd_count + (rd_data_en ? 1 : 0); wr_count = wr_count + (wr_data_en ? 1 : 0); end end",
            "always @(posedge i_clk) if (i_reset) begin rd_count_",
            "reg <= 0; wr_count_",
            "reg <= 0; end else begin rd_count_",
            "reg <= rd_count; wr_count_",
            "reg <= wr_count; end // }}} // o_st_data: Error detect\u0131on (might need more error flags) // {{{",
            "always @(posedge i_clk) if (i_reset) o_st_data <= 32'b0; else begin o_st_data[15:4] <= rd_count; o_st_data[31:20] <= wr_count; for (int i = 0; i < BW; i++) if (wr_data_en && i_wb_sel[i]) begin if (i_wb_data[(i*8)+:8] != lfsr_state[(i*8)+:8]) o_st_data[0] <= 1'b1; else o_st_data[0] <= 1'b0; end if (i_st_stb && i_st_we) o_st_data[0] <= 1'b0; end // }}} // Keep Verilator happy // {{{ // verilator coverage_off // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_wb_cyc, i_st_cyc, i_st_addr, i_wb_addr }; // verilator lint_on UNUSED // verilator coverage_on // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "wbxbar.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/wbxbar.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/wbxbar.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A Configurable wishbone cross-bar interconnect, conforming // to the WB-B4 pipeline specification, as described on the // ZipCPU blog. // // Performance: // Throughput: One transaction per clock // Latency: One clock to get access to an unused channel, another to // place the results on the slave bus, and another to return, or a minimum // of three clocks. // // Usage: To use, you'll need to set NM and NS to the number of masters // (",
            "input ports) and the number of slaves respectively. You'll then // want to set the addresses for the slaves in the SLAVE_ADDR array, // together with the SLAVE_MASK array indicating which SLAVE_ADDRs // are valid. Address and data widths should be adjusted at the same // time. // // Voila, you are now set up! // // Now let's fine tune this: // // LGMAXBURST can be set to control the maximum number of outstanding // transactions. An LGMAXBURST of 6 will allow 63 outstanding // transactions. // // OPT_TIMEOUT, if set to a non-zero value, is a number of clock periods // to wait for a slave to respond. Should the timeout expire and the // slave not respond, a bus error will be returned and the slave will // be issued a bus abort signal (CYC will be dropped). // // OPT_STARVATION_TIMEOUT, if set, applies the OPT_TIMEOUT counter to // how long a particular master waits for arbitration. If the master is // \"starved\", a bus error will be returned. // // OPT_DBLBUFFER is used to increase clock speed by",
            "reg istering all // output s. // // OPT_LOWPOWER is an experimental feature that, if set, will cause any // unused FFs to be set to zero rather than flopping in the electronic // wind, in an effort to minimize transitions over bus",
            "wire s. This will // cost some extra",
            "logic , for ... an uncertain power savings. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2019-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module wbxbar #( // i_sstall, i_sack, i_sdata, i_serr); // {{{",
            "parameter NM = 4, NS=8, parameter AW = 32, DW=32, parameter [NS*AW-1:0] SLAVE_ADDR = { { 3'b111, {(AW-3){1'b0}} }, { 3'b110, {(AW-3){1'b0}} }, { 3'b101, {(AW-3){1'b0}} }, { 3'b100, {(AW-3){1'b0}} }, { 3'b011, {(AW-3){1'b0}} }, { 3'b010, {(AW-3){1'b0}} }, { 4'b0010, {(AW-4){1'b0}} }, { 4'b0000, {(AW-4){1'b0}} } }, parameter [NS*AW-1:0] SLAVE_MASK = (NS <= 1) ? 0 : { {(NS-2){ 3'b111, {(AW-3){1'b0}} }}, {(2){ 4'b1111, {(AW-4){1'b0}} }} }, // // LGMAXBURST is the log_2 of the length of the longest burst // that might be seen. It's used to set the size of the // internal counters that are used to make certain that the // cross bar doesn't switch while still waiting on a response.",
            "parameter LGMAXBURST=6, // // OPT_TIMEOUT is used to help recover from a misbehaving slave. // If set, this value will determine the number of clock cycles // to wait for a misbehaving slave before returning a bus error. // Alternatively, if set to zero, this functionality will be // removed.",
            "parameter OPT_TIMEOUT = 0, // 1023; // // If OPT_TIMEOUT is set, then OPT_STARVATION_TIMEOUT may also // be set. The starvation timeout adds to the bus error timeout // generation the possibility that a master will wait // OPT_TIMEOUT counts without receiving the bus. This may be // the case, for example, if one bus master is consuming a // peripheral to such an extent that there's no time/room for // another bus master to use it. In that case, when the timeout // runs out, the waiting bus master will be given a bus error.",
            "parameter [0:0] OPT_STARVATION_TIMEOUT = 1'b0 && (OPT_TIMEOUT > 0), // // OPT_DBLBUFFER is used to",
            "reg ister all of the",
            "output s, and // thus avoid adding additional combinational latency through // the core that might require a slower clock speed.",
            "parameter [0:0] OPT_DBLBUFFER = 1'b0, // // OPT_LOWPOWER adds",
            "logic to try to force unused values to // zero, rather than to allow a variety of",
            "logic optimizations // that could be used to reduce the",
            "logic count of the device. // Hence, OPT_LOWPOWER will use more",
            "logic , but it won't drive // bus",
            "wire s unless there's a value to drive onto them.",
            "parameter [0:0] OPT_LOWPOWER = 1'b1 // }}} ) ( // {{{",
            "input wire i_clk, i_reset, // // Here are the bus",
            "input s from each of the WB bus masters",
            "input wire [NM-1:0] i_mcyc, i_mstb, i_mwe, input wire [NM*AW-1:0] i_maddr, input wire [NM*DW-1:0] i_mdata, input wire [NM*DW/8-1:0] i_msel, // // .... and their return data",
            "output wire [NM-1:0] o_mstall, output wire [NM-1:0] o_mack, output reg [NM*DW-1:0] o_mdata, output wire [NM-1:0] o_merr, // // // Here are the",
            "output ports, used to control each of the // various slave ports that we are connected to",
            "output reg [NS-1:0] o_scyc, o_sstb, o_swe, output reg [NS*AW-1:0] o_saddr, output reg [NS*DW-1:0] o_sdata, output reg [NS*DW/8-1:0] o_ssel, // // ... and their return data back to us.",
            "input wire [NS-1:0] i_sstall, i_sack, input wire [NS*DW-1:0] i_sdata, input wire [NS-1:0] i_serr // }}} ); // // //////////////////////////////////////////////////////////////////////// // // Register declarations // {{{ // // TIMEOUT_WIDTH is the number of bits in counter used to check // on a timeout.",
            "localparam TIMEOUT_WIDTH = $clog2(OPT_TIMEOUT); // // LGNM is the log (base two) of the number of bus masters // connecting to this crossbar",
            "localparam LGNM = (NM>1) ? $clog2(NM) : 1; // // LGNS is the log (base two) of the number of slaves plus one // come out of the system. The extra \"plus one\" is used for a // pseudo slave representing the case where the given address // doesn't connect to any of the slaves. This address will // generate a bus error.",
            "localparam LGNS = $clog2(NS+1); // At one time I used o_macc and o_sacc to put into the outgoing // trace file, just enough",
            "logic to tell me if a transaction was // taking place on the given clock. // // assign o_macc = (i_mstb & ~o_mstall); // assign o_sacc = (o_sstb & ~i_sstall); // // These definitions work with Veri1ator, just not with Yosys // reg [NM-1:0][NS:0] request; // reg [NM-1:0][NS-1:0] requested; // reg [NM-1:0][NS:0] grant; // // These definitions work with both",
            "wire [NS:0] request [0:NM-1];",
            "reg [NS-1:0] requested [0:NM-1];",
            "reg [NS:0] grant [0:NM-1];",
            "reg [NM-1:0] mgrant;",
            "reg [NS-1:0] sgrant; // Verilator lint_off UNUSED",
            "wire [LGMAXBURST-1:0] w_mpending [0:NM-1]; // Verilator lint_on UNUSED",
            "reg [NM-1:0] mfull, mnearfull, mempty;",
            "wire [NM-1:0] timed_out;",
            "localparam NMFULL = (NM > 1) ? (1<<LGNM) : 1;",
            "localparam NSFULL = (1<<LGNS);",
            "wire [LGNS-1:0] mindex [0:NMFULL-1];",
            "wire [LGNM-1:0] sindex [0:NSFULL-1];",
            "wire [NMFULL-1:0] m_cyc;",
            "wire [NMFULL-1:0] m_stb;",
            "wire [NMFULL-1:0] m_we;",
            "wire [AW-1:0] m_addr [0:NMFULL-1];",
            "wire [DW-1:0] m_data [0:NMFULL-1];",
            "wire [DW/8-1:0] m_sel [0:NMFULL-1];",
            "reg [NM-1:0] m_stall; // wire [NSFULL-1:0] s_stall;",
            "wire [DW-1:0] s_data [0:NSFULL-1];",
            "wire [NSFULL-1:0] s_ack;",
            "wire [NSFULL-1:0] s_err;",
            "wire [NM-1:0] dcd_stb;",
            "localparam [0:0] OPT_BUFFER_DECODER=(NS != 1 || SLAVE_MASK != 0); // }}} //////////////////////////////////////////////////////////////////////// // // Incoming signal arbitration // {{{ //////////////////////////////////////////////////////////////////////// // // genvar N, M; integer iN, iM; generate for(N=0; N<NM; N=N+1) begin : DECODE_REQUEST // {{{ // Register declarations // {{{",
            "wire skd_stb, skd_stall;",
            "wire skd_we;",
            "wire [AW-1:0] skd_addr;",
            "wire [DW-1:0] skd_data;",
            "wire [DW/8-1:0] skd_sel;",
            "wire [NS:0] decoded;",
            "wire iskd_ready; // }}} skidbuffer #( // {{{ // Can't run OPT_LOWPOWER here, less we mess up the // consistency in skd_we following // // .OPT_LOWPOWER(OPT_LOWPOWER), .DW(1+AW+DW+DW/8), `ifdef FORMAL .OPT_PASSTHROUGH(1), `endif .OPT_OUTREG(0) // }}} ) iskid ( // {{{ .i_clk(i_clk), .i_reset(i_reset || !i_mcyc[N]), .i_valid(i_mstb[N]), .o_ready(iskd_ready), .i_data({ i_mwe[N], i_maddr[N*AW +: AW], i_mdata[N*DW +: DW], i_msel[N*DW/8 +: DW/8] }), .o_valid(skd_stb), .i_ready(!skd_stall), .o_data({ skd_we, skd_addr, skd_data, skd_sel }) // }}} );",
            "assign o_mstall[N] = !iskd_ready; addrdecode #( // {{{ // Can't run OPT_LOWPOWER here, less we mess up the // consistency in m_we following // // .OPT_LOWPOWER(OPT_LOWPOWER), .NS(NS), .AW(AW), .DW(DW+DW/8+1), .SLAVE_ADDR(SLAVE_ADDR), .SLAVE_MASK(SLAVE_MASK), .OPT_REGISTERED(OPT_BUFFER_DECODER) // }}} ) adcd( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_valid(skd_stb && i_mcyc[N]), .o_stall(skd_stall), .i_addr(skd_addr), .i_data({ skd_we, skd_data, skd_sel }), .o_valid(dcd_stb[N]), .i_stall(m_stall[N]&&i_mcyc[N]), .o_decode(decoded), .o_addr(m_addr[N]), .o_data({ m_we[N], m_data[N], m_sel[N] }) // }}} );",
            "assign request[N] = (m_cyc[N] && dcd_stb[N]) ? decoded : 0;",
            "assign m_cyc[N] = i_mcyc[N];",
            "assign m_stb[N] = i_mcyc[N] && dcd_stb[N] && !mfull[N]; // }}} end for(N=NM; N<NMFULL; N=N+1) begin : UNUSED_MASTER_SIGNALS // {{{ // in case NM isn't one less than a power of two, complete // the set",
            "assign m_cyc[N] = 0;",
            "assign m_stb[N] = 0;",
            "assign m_we[N] = 0;",
            "assign m_addr[N] = 0;",
            "assign m_data[N] = 0;",
            "assign m_sel[N] = 0; // }}} end endgenerate // requested // {{{",
            "always @(*) begin for(iM=0; iM<NS; iM=iM+1) begin // For each slave requested[0][iM] = 0; for(iN=1; iN<NM; iN=iN+1) begin // This slave has been requested if a prior // master has requested it // // This includes any master before the last one requested[iN][iM] = requested[iN-1][iM]; // // As well as if the last master has requested // this slave. Only count this request, though, // if this master could act upon it. if (request[iN-1][iM] && (grant[iN-1][iM] || (!mgrant[iN-1]||mempty[iN-1]))) requested[iN][iM] = 1; end end end // }}} generate for(M=0; M<NS; M=M+1) begin : SLAVE_GRANT // {{{ `define REGISTERED_SGRANT `ifdef REGISTERED_SGRANT // {{{",
            "reg drop_sgrant; // drop_sgrant // {{{",
            "always @(*) begin drop_sgrant = !m_cyc[sindex[M]]; if (!request[sindex[M]][M] && m_stb[sindex[M]] && mempty[sindex[M]]) drop_sgrant = 1; if (!sgrant[M]) drop_sgrant = 0; if (i_reset) drop_sgrant = 1; end // }}} // sgrant // {{{",
            "initial sgrant[M] = 0;",
            "always @(posedge i_clk) begin sgrant[M] <= sgrant[M]; for(iN=0; iN<NM; iN=iN+1) if (request[iN][M] && (!mgrant[iN] || mempty[iN])) sgrant[M] <= 1; if (drop_sgrant) sgrant[M] <= 0; end // }}} // }}} `else // {{{ // sgrant // {{{",
            "always @(*) begin sgrant[M] = 0; for(iN=0; iN<NM; iN=iN+1) if (grant[iN][M]) sgrant[M] = 1; end // }}} // }}} `endif",
            "assign s_data[M] = i_sdata[M*DW +: DW];",
            "assign s_stall[M] = o_sstb[M] && i_sstall[M];",
            "assign s_ack[M] = o_scyc[M] && i_sack[M];",
            "assign s_err[M] = o_scyc[M] && i_serr[M]; // }}} end for(M=NS; M<NSFULL; M=M+1) begin : UNUSED_SLAVE_SIGNALS // {{{",
            "assign s_data[M] = 0;",
            "assign s_stall[M] = 1;",
            "assign s_ack[M] = 0;",
            "assign s_err[M] = 1; // }}} end endgenerate // // Arbitrate among masters to determine who gets to access a given // channel generate for(N=0; N<NM; N=N+1) begin : ARBITRATE_REQUESTS // {{{ // Register declarations // {{{",
            "wire [NS:0]",
            "reg rant;",
            "wire [LGNS-1:0] reindex; // This is done using a couple of variables. // // request[N][M] // This is true if master N is requesting to access slave // M. It is combinatorial, so it will be true if the // request is being made on the current clock. // // requested[N][M] // True if some other master, prior to N, has requested // channel M. This creates a basic priority arbiter, // such that lower numbered masters have access before // a greater numbered master // // grant[N][M] // True if a grant has been made for master N to access // slave channel M // // mgrant[N] // True if master N has been granted access to some slave // channel, any channel. // // mindex[N] // This is the number of the slave channel that master // N has been given access to // // sgrant[M] // True if there exists some master, N, that has been // granted access to this slave, hence grant[N][M] must // also be true // // sindex[M] // This is the index of the master that has access to // slave M, assuming sgrant[M]. Hence, if sgrant[M] // then grant[sindex[M]][M] must be true // reg stay_on_channel;",
            "reg requested_channel_is_available; // }}} // stay_on_channel // {{{",
            "always @(*) begin stay_on_channel = |(request[N] & grant[N]); if (mgrant[N] && !mempty[N]) stay_on_channel = 1; end // }}} // requested_channel_is_available // {{{",
            "always @(*) begin requested_channel_is_available = |(request[N][NS-1:0]& ~sgrant & ~requested[N][NS-1:0]); if (request[N][NS]) requested_channel_is_available = 1; if (NM < 2) requested_channel_is_available = m_stb[N]; end // }}} // grant, mgrant // {{{",
            "initial grant[N] = 0;",
            "initial mgrant[N] = 0;",
            "always @(posedge i_clk) if (i_reset || !i_mcyc[N]) begin grant[N] <= 0; mgrant[N] <= 0; end else if (!stay_on_channel) begin if (requested_channel_is_available) begin mgrant[N] <= 1'b1; grant[N] <= request[N]; end else if (m_stb[N]) begin mgrant[N] <= 1'b0; grant[N] <= 0; end end // }}} if (NS == 1) begin : MINDEX_ONE_SLAVE // {{{",
            "assign mindex[N] = 0;",
            "assign reg rant = 0;",
            "assign reindex = 0; // }}} end else begin : MINDEX_MULTIPLE_SLAVES // {{{",
            "reg [LGNS-1:0] r_mindex; `define NEW_MINDEX_CODE `ifdef NEW_MINDEX_CODE // {{{",
            "reg [NS:0] r_",
            "reg rant;",
            "reg [LGNS-1:0] r_reindex; // r_",
            "reg rant // {{{",
            "always @(*) begin r_",
            "reg rant = 0; for(iM=0; iM<NS; iM=iM+1) begin if (grant[N][iM]) // Maintain any open channels r_",
            "reg rant[iM] = 1'b1; else if (!sgrant[iM]&&!requested[N][iM]) r_",
            "reg rant[iM] = 1'b1; if (!request[N][iM]) r_",
            "reg rant[iM] = 1'b0; end if (grant[N][NS]) r_",
            "reg rant[NS] = 1; if (!request[N][NS]) r_",
            "reg rant[NS] = 0; if (mgrant[N] && !mempty[N]) r_",
            "reg rant = 0; end // }}} // r_reindex // {{{ // Verilator lint_off BLKSEQ",
            "always @(r_",
            "reg rant, reg rant) begin r_reindex = 0; for(iM=0; iM<=NS; iM=iM+1) if (r_",
            "reg rant[iM]) r_reindex = r_reindex | iM[LGNS-1:0]; if (",
            "reg rant == 0) r_reindex = r_mindex; end // Verilator lint_on BLKSEQ // }}}",
            "always @(posedge i_clk) r_mindex <= reindex;",
            "assign reindex = r_reindex;",
            "assign reg rant = r_",
            "reg rant; // }}} `else // {{{",
            "always @(posedge i_clk) if (!mgrant[N] || mempty[N]) begin for(iM=0; iM<NS; iM=iM+1) begin if (request[N][iM] && grant[N][iM]) begin // Maintain any open channels r_mindex <= iM; end else if (request[N][iM] && !sgrant[iM] && !requested[N][iM]) begin // Open a new channel // if necessary r_mindex <= iM; end end end // }}} `endif // NEW_MINDEX_CODE",
            "assign mindex[N] = r_mindex; // }}} end // }}} end for (N=NM; N<NMFULL; N=N+1) begin : UNUSED_MINDEXES // {{{",
            "assign mindex[N] = 0; // }}} end endgenerate // Calculate sindex. sindex[M] (indexed by slave ID) // references the master controlling this slave. This makes for // faster/cheaper",
            "logic on the return path, since we can now use // a fully populated LUT rather than a priority based return scheme generate for(M=0; M<NS; M=M+1) begin : GEN_SINDEX // {{{ if (NM <= 1) begin : SINDEX_SINGLE_MASTER // {{{ // If there will only ever be one master, then we // can assume all slave indexes point to that master",
            "assign sindex[M] = 0; // }}} end else begin : SINDEX_MORE_THAN_ONE_MASTER // {{{",
            "reg [LGNM-1:0] r_sindex; `define NEW_SINDEX_CODE `ifdef NEW_SINDEX_CODE // {{{",
            "reg [NM-1:0]",
            "reg rant;",
            "reg [LGNM-1:0] reindex;",
            "always @(*) begin",
            "reg rant = 0; for (iN=0; iN<NM; iN=iN+1) begin // Each bit depends upon 6",
            "input s, so // one 6-LUT should be sufficient if (grant[iN][M])",
            "reg rant[iN] = 1; else if (!sgrant[M]&& !requested[iN][M])",
            "reg rant[iN] = 1; if (!request[iN][M])",
            "reg rant[iN] = 0; if (mgrant[iN] && !mempty[iN])",
            "reg rant[iN] = 0; end end",
            "always @(*) begin reindex = 0; // Each bit in reindex depends upon all of the // bits in",
            "reg rant--should still be one LUT // per bit though if (",
            "reg rant == 0) reindex = sindex[M]; else for(iN=0; iN<NM; iN=iN+1) if (",
            "reg rant[iN]) reindex = reindex | iN[LGNM-1:0]; end",
            "always @(posedge i_clk) r_sindex <= reindex;",
            "assign sindex[M] = r_sindex; // }}} `else // {{{",
            "always @(posedge i_clk) for (iN=0; iN<NM; iN=iN+1) begin if (!mgrant[iN] || mempty[iN]) begin if (request[iN][M] && grant[iN][M]) r_sindex <= iN; else if (request[iN][M] && !sgrant[M] && !requested[iN][M]) r_sindex <= iN; end end",
            "assign sindex[M] = r_sindex; // }}} `endif // }}} end // }}} end for(M=NS; M<NSFULL; M=M+1) begin : UNUSED_SINDEXES // {{{ // Assign the unused slave indexes to zero // // Remember, to full out a full 2^something set of slaves, // we may have more slave indexes than we actually have slaves",
            "assign sindex[M] = 0; // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Assign",
            "output s to the slaves // {{{ //////////////////////////////////////////////////////////////////////// // // // // Part one // // In this part, we",
            "assign the difficult",
            "output s: o_scyc and o_sstb generate for(M=0; M<NS; M=M+1) begin : GEN_CYC_STB // {{{",
            "initial o_scyc[M] = 0;",
            "initial o_sstb[M] = 0;",
            "always @(posedge i_clk) begin if (sgrant[M]) begin if (!i_mcyc[sindex[M]]) begin o_scyc[M] <= 1'b0; o_sstb[M] <= 1'b0; end else begin o_scyc[M] <= 1'b1; if (!o_sstb[M] || !s_stall[M]) o_sstb[M]<=request[sindex[M]][M] && !mfull[sindex[M]]; end end else begin o_scyc[M] <= 1'b0; o_sstb[M] <= 1'b0; end if (i_reset || s_err[M]) begin o_scyc[M] <= 1'b0; o_sstb[M] <= 1'b0; end end // }}} end endgenerate // // Part two // // These are the easy(er)",
            "output s, since there are fewer properties // riding on them generate if ((NM == 1) && (!OPT_LOWPOWER)) begin : ONE_MASTER // {{{",
            "reg r_swe;",
            "reg [AW-1:0] r_saddr;",
            "reg [DW-1:0] r_sdata;",
            "reg [DW/8-1:0] r_ssel; // // This is the low",
            "logic version of our bus data",
            "output s. // It only works if we only have one master. // // The basic idea here is that we share all of our bus",
            "output s // between all of the various slaves. Since we only have one // bus master, this works. // always @(posedge i_clk) begin r_swe <= o_swe[0]; r_saddr <= o_saddr[0+:AW]; r_sdata <= o_sdata[0+:DW]; r_ssel <=o_ssel[0+:DW/8]; // Verilator lint_off WIDTH if (sgrant[mindex[0]] && !s_stall[mindex[0]]) // Verilator lint_on WIDTH begin r_swe <= m_we[0]; r_saddr <= m_addr[0]; r_sdata <= m_data[0]; r_ssel <= m_sel[0]; end end // // The original version set o_s*[0] above, and then // combinatorially the rest of o_s* here below. That broke // Veri1ator. Hence, we're using r_s* and setting all of o_s* // here. for(M=0; M<NS; M=M+1) begin : FOREACH_SLAVE_PORT",
            "always @(*) begin o_swe[M] = r_swe; o_saddr[M*AW +: AW] = r_saddr[AW-1:0]; o_sdata[M*DW +: DW] = r_sdata[DW-1:0]; o_ssel[M*DW/8+:DW/8]= r_ssel[DW/8-1:0]; end end // }}} end else begin : J for(M=0; M<NS; M=M+1) begin : GEN_DOWNSTREAM // {{{",
            "always @(posedge i_clk) begin if (OPT_LOWPOWER && !sgrant[M]) begin o_swe[M] <= 1'b0; o_saddr[M*AW +: AW] <= 0; o_sdata[M*DW +: DW] <= 0; o_ssel[M*(DW/8)+:DW/8]<= 0; end else if (!s_stall[M]) begin o_swe[M] <= m_we[sindex[M]]; o_saddr[M*AW +: AW] <= m_addr[sindex[M]]; if (OPT_LOWPOWER && !m_we[sindex[M]]) o_sdata[M*DW +: DW] <= 0; else o_sdata[M*DW +: DW] <= m_data[sindex[M]]; o_ssel[M*(DW/8)+:DW/8]<= m_sel[sindex[M]]; end end // }}} end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Assign return values to the masters // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_DBLBUFFER) begin : DOUBLE_BUFFERRED_STALL // {{{",
            "reg [NM-1:0] r_mack, r_merr; for(N=0; N<NM; N=N+1) begin : FOREACH_MASTER_PORT // m_stall isn't buffered, since it depends upon // the already existing buffer within the address // decoder",
            "always @(*) begin if (grant[N][NS]) m_stall[N] = 1; else if (mgrant[N] && request[N][mindex[N]]) m_stall[N] = mfull[N] || s_stall[mindex[N]]; else m_stall[N] = m_stb[N]; if (o_merr[N]) m_stall[N] = 0; end",
            "initial r_mack[N] = 0;",
            "initial r_merr[N] = 0;",
            "always @(posedge i_clk) begin // Verilator lint_off WIDTH iM = mindex[N]; // Verilator lint_on WIDTH r_mack[N] <= mgrant[N] && s_ack[mindex[N]]; r_merr[N] <= mgrant[N] && s_err[mindex[N]]; if (OPT_LOWPOWER && !mgrant[N]) o_mdata[N*DW +: DW] <= 0; else o_mdata[N*DW +: DW] <= s_data[mindex[N]]; if (grant[N][NS]||(timed_out[N] && !o_mack[N])) begin r_mack[N] <= 1'b0; r_merr[N] <= !o_merr[N]; end if (i_reset || !i_mcyc[N] || o_merr[N]) begin r_mack[N] <= 1'b0; r_merr[N] <= 1'b0; end end",
            "assign o_mack[N] = r_mack[N];",
            "assign o_merr[N] = (!OPT_STARVATION_TIMEOUT || i_mcyc[N]) && r_merr[N]; end // }}} end else if (NS == 1) // && !OPT_DBLBUFFER begin : SINGLE_SLAVE // {{{ for(N=0; N<NM; N=N+1) begin : FOREACH_MASTER_PORT",
            "reg r_mack, r_merr;",
            "always @(*) begin m_stall[N] = !mgrant[N] || s_stall[0] || (m_stb[N] && !request[N][0]); r_mack = mgrant[N] && i_sack[0]; r_merr = mgrant[N] && i_serr[0]; o_mdata[N*DW +: DW] = (!mgrant[N] && OPT_LOWPOWER) ? 0 : i_sdata; if (mfull[N]) m_stall[N] = 1'b1; if (timed_out[N] && !r_mack) begin m_stall[N] = 1'b0; r_mack = 1'b0; r_merr = 1'b1; end if (grant[N][NS] && m_stb[N]) begin m_stall[N] = 1'b0; r_mack = 1'b0; r_merr = 1'b1; end if (!m_cyc[N]) begin r_mack = 1'b0; r_merr = 1'b0; end end",
            "assign o_mack[N] = r_mack;",
            "assign o_merr[N] = r_merr; end // }}} end else begin : SINGLE_BUFFER_STALL // {{{ for(N=0; N<NM; N=N+1) begin : FOREACH_MASTER_PORT // initial o_mstall[N] = 0; // initial o_mack[N] = 0;",
            "reg r_mack, r_merr;",
            "always @(*) begin m_stall[N] = 1; r_mack = mgrant[N] && s_ack[mindex[N]]; r_merr = mgrant[N] && s_err[mindex[N]]; if (OPT_LOWPOWER && !mgrant[N]) o_mdata[N*DW +: DW] = 0; else o_mdata[N*DW +: DW] = s_data[mindex[N]]; if (mgrant[N]) // Possibly lower the stall signal m_stall[N] = s_stall[mindex[N]] || !request[N][mindex[N]]; if (mfull[N]) m_stall[N] = 1'b1; if (grant[N][NS] ||(timed_out[N] && !r_mack)) begin m_stall[N] = 1'b0; r_mack = 1'b0; r_merr = 1'b1; end if (!m_cyc[N]) begin r_mack = 1'b0; r_merr = 1'b0; end end",
            "assign o_mack[N] = r_mack;",
            "assign o_merr[N] = r_merr; end // }}} end endgenerate // // Count the pending transactions per master generate for(N=0; N<NM; N=N+1) begin : COUNT_PENDING_TRANSACTIONS // {{{",
            "reg [LGMAXBURST-1:0] lclpending;",
            "initial lclpending = 0;",
            "initial mempty[N] = 1;",
            "initial mnearfull[N] = 0;",
            "initial mfull[N] = 0;",
            "always @(posedge i_clk) if (i_reset || !i_mcyc[N] || o_merr[N]) begin lclpending <= 0; mfull[N] <= 0; mempty[N] <= 1'b1; mnearfull[N]<= 0; end else case({ (m_stb[N] && !m_stall[N]), o_mack[N] }) 2'b01: begin lclpending <= lclpending - 1'b1; mnearfull[N]<= mfull[N]; mfull[N] <= 1'b0; mempty[N] <= (lclpending == 1); end 2'b10: begin lclpending <= lclpending + 1'b1; mnearfull[N]<= (&lclpending[LGMAXBURST-1:2])&&(lclpending[1:0] != 0); mfull[N] <= mnearfull[N]; mempty[N] <= 1'b0; end default: begin end endcase",
            "assign w_mpending[N] = lclpending; // }}} end endgenerate generate if (OPT_TIMEOUT > 0) begin : CHECK_TIMEOUT // {{{ for(N=0; N<NM; N=N+1) begin : FOREACH_MASTER_PORT",
            "reg [TIMEOUT_WIDTH-1:0] deadlock_timer;",
            "reg r_timed_out;",
            "initial deadlock_timer = OPT_TIMEOUT;",
            "initial r_timed_out = 0;",
            "always @(posedge i_clk) if (i_reset || !i_mcyc[N] ||((w_mpending[N] == 0) && !m_stb[N]) ||(m_stb[N] && !m_stall[N]) ||(o_mack[N] || o_merr[N]) ||(!OPT_STARVATION_TIMEOUT&&!mgrant[N])) begin deadlock_timer <= OPT_TIMEOUT; r_timed_out <= 0; end else if (deadlock_timer > 0) begin deadlock_timer <= deadlock_timer - 1; r_timed_out <= (deadlock_timer <= 1); end",
            "assign timed_out[N] = r_timed_out; end // }}} end else begin : NO_TIMEOUT // {{{",
            "assign timed_out = 0; // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Parameter consistency check // {{{ //////////////////////////////////////////////////////////////////////// // // initial begin : PARAMETER_CONSISTENCY_CHECK // {{{ if (NM == 0) begin $display(\"ERROR: At least one master must be defined\"); $stop; end if (NS == 0) begin $display(\"ERROR: At least one slave must be defined\"); $stop; end if (OPT_STARVATION_TIMEOUT != 0 && OPT_TIMEOUT == 0) begin $display(\"ERROR: The starvation timeout is implemented as part of the",
            "reg ular timeout\"); $display(\" Without a timeout, the starvation timeout will not work\"); $stop; end // }}} end // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties used to verify the core // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // Register declarations // {{{",
            "localparam F_MAX_DELAY = 4;",
            "localparam F_LGDEPTH = LGMAXBURST; // reg f_past_valid; // // Our bus checker keeps track of the number of requests, // acknowledgments, and the number of outstanding transactions on // every channel, both the masters driving us",
            "wire [F_LGDEPTH-1:0] f_mreqs [0:NM-1];",
            "wire [F_LGDEPTH-1:0] f_macks [0:NM-1];",
            "wire [F_LGDEPTH-1:0] f_moutstanding [0:NM-1]; // // as well as the slaves that we drive ourselves",
            "wire [F_LGDEPTH-1:0] f_sreqs [0:NS-1];",
            "wire [F_LGDEPTH-1:0] f_sacks [0:NS-1];",
            "wire [F_LGDEPTH-1:0] f_soutstanding [0:NS-1]; // }}}",
            "initial assert(!OPT_STARVATION_TIMEOUT || OPT_TIMEOUT > 0);",
            "initial f_past_valid = 0;",
            "always @(posedge i_clk) f_past_valid = 1'b1;",
            "always @(*) if (!f_past_valid) assume(i_reset); generate for(N=0; N<NM; N=N+1) begin : GRANT_CHECKING // {{{",
            "reg checkgrant;",
            "always @(*) if (f_past_valid) for(iN=N+1; iN<NM; iN=iN+1) // Can't grant the same channel to two separate // masters. This applies to all but the error or // no-slave-selected channel assert((grant[N][NS-1:0] & grant[iN][NS-1:0])==0); for(M=1; M<=NS; M=M+1) begin // Can't grant two channels to the same master",
            "always @(*) if (f_past_valid && grant[N][M]) assert(grant[N][M-1:0] == 0); end",
            "always @(*) if (&w_mpending[N]) assert(o_merr[N] || m_stall[N]);",
            "always @(*) if (f_past_valid) begin checkgrant = 0; for(iM=0; iM<NS; iM=iM+1) if (grant[N][iM]) checkgrant = 1; if (grant[N][NS]) checkgrant = 1; assert(checkgrant == mgrant[N]); end // }}} end endgenerate // Double check the grant mechanism and its dependent variables generate for(N=0; N<NM; N=N+1) begin : CHECK_GRANTS // {{{ for(M=0; M<NS; M=M+1) begin",
            "always @(*) if ((f_past_valid)&&grant[N][M]) begin assert(mgrant[N]); assert(mindex[N] == M); assert(sgrant[M]); assert(sindex[M] == N); end end // }}} end endgenerate generate for(M=0; M<NS; M=M+1) begin : CHECK_SGRANT // {{{",
            "reg f_sgrant;",
            "always @(*) if (sgrant[M]) assert(grant[sindex[M]][M]);",
            "always @(*) begin f_sgrant = 0; for(iN=0; iN<NM; iN=iN+1) if (grant[iN][M]) f_sgrant = 1; end",
            "always @(*) assert(sgrant[M] == f_sgrant); // }}} end endgenerate // Double check the timeout flags for consistency generate for(N=0; N<NM; N=N+1) begin : F_CHECK_TIMEOUT // {{{",
            "always @(*) if (f_past_valid) begin assert(mempty[N] == (w_mpending[N] == 0)); assert(mnearfull[N]==(&w_mpending[N][LGMAXBURST-1:1])); assert(mfull[N] == (&w_mpending[N])); end // }}} end endgenerate `ifdef VERIFIC // {{{ // The Verific parser is currently broken, and doesn't allow // initial assumes or asserts. The following lines get us around that // always @(*) if (!f_past_valid) assume(sgrant == 0); generate for(M=0; M<NS; M=M+1) begin",
            "always @(*) if (!f_past_valid) begin assume(o_scyc[M] == 0); assume(o_sstb[M] == 0); assume(sgrant[M] == 0); end end endgenerate generate for(N=0; N<NM; N=N+1) begin",
            "always @(*) if (!f_past_valid) begin assume(grant[N] == 0); assume(mgrant[N] == 0); end end endgenerate // }}} `endif //////////////////////////////////////////////////////////////////////// // // BUS CHECK // {{{ //////////////////////////////////////////////////////////////////////// // // // Verify that every channel, whether master or slave, follows the rules // of the WB road. // generate for(N=0; N<NM; N=N+1) begin : WB_SLAVE_CHECK // {{{ fwb_slave #( .AW(AW), .DW(DW), .F_LGDEPTH(LGMAXBURST), .F_MAX_ACK_DELAY(0), .F_MAX_STALL(0) ) slvi(i_clk, i_reset, i_mcyc[N], i_mstb[N], i_mwe[N], i_maddr[N*AW +: AW], i_mdata[N*DW +: DW], i_msel[N*(DW/8) +: (DW/8)], o_mack[N], o_mstall[N], o_mdata[N*DW +: DW], o_merr[N], f_mreqs[N], f_macks[N], f_moutstanding[N]);",
            "always @(*) if ((f_past_valid)&&(grant[N][NS])) assert(f_moutstanding[N] <= 1);",
            "always @(*) if (f_past_valid && grant[N][NS] && i_mcyc[N]) assert(m_stall[N] || o_merr[N]);",
            "always @(posedge i_clk) if (f_past_valid && $past(!i_reset && i_mstb[N] && o_mstall[N])) assume($stable(i_mdata[N*DW +: DW])); // }}} end endgenerate generate for(M=0; M<NS; M=M+1) begin : WB_MASTER_CHECK // {{{ fwb_master #( .AW(AW), .DW(DW), .F_LGDEPTH(LGMAXBURST), .F_MAX_ACK_DELAY(F_MAX_DELAY), .F_MAX_STALL(2) ) mstri(i_clk, i_reset, o_scyc[M], o_sstb[M], o_swe[M], o_saddr[M*AW +: AW], o_sdata[M*DW +: DW], o_ssel[M*(DW/8) +: (DW/8)], i_sack[M], i_sstall[M], s_data[M], i_serr[M], f_sreqs[M], f_sacks[M], f_soutstanding[M]); // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Correlate outstanding numbers // {{{ //////////////////////////////////////////////////////////////////////// // // generate for(N=0; N<NM; N=N+1) begin : CHECK_OUTSTANDING // {{{",
            "always @(*) if (mfull[N]) assert(m_stall[N]);",
            "always @(posedge i_clk) if (i_mcyc[N]) assert(f_moutstanding[N] == w_mpending[N] +((OPT_BUFFER_DECODER & dcd_stb[N]) ? 1:0));",
            "reg [LGMAXBURST:0] n_outstanding;",
            "always @(*) if (i_mcyc[N]) assert(f_moutstanding[N] >= ((OPT_BUFFER_DECODER && dcd_stb[N]) ? 1:0) + (o_mack[N] && OPT_DBLBUFFER) ? 1:0);",
            "always @(*) n_outstanding = f_moutstanding[N] - ((OPT_BUFFER_DECODER && dcd_stb[N]) ? 1:0) - ((o_mack[N] && OPT_DBLBUFFER) ? 1:0);",
            "always @(posedge i_clk) if (i_mcyc[N] && !mgrant[N] && !o_merr[N]) assert(f_moutstanding[N] == ((OPT_BUFFER_DECODER & dcd_stb[N]) ? 1:0)); else if (i_mcyc[N] && mgrant[N] && !i_reset) for(iM=0; iM<NS; iM=iM+1) if (grant[N][iM] && o_scyc[iM] && !i_serr[iM] && !o_merr[N]) assert(n_outstanding == {1'b0,f_soutstanding[iM]} +(o_sstb[iM] ? 1:0));",
            "always @(*) if (!i_reset) begin for(iM=0; iM<NS; iM=iM+1) if (grant[N][iM] && i_mcyc[N]) begin if (f_soutstanding[iM] > 0) assert(i_mwe[N] == o_swe[iM]); if (o_sstb[iM]) assert(i_mwe[N] == o_swe[iM]); if (o_mack[N]) assert(i_mwe[N] == o_swe[iM]); if (o_scyc[iM] && i_sack[iM]) assert(i_mwe[N] == o_swe[iM]); if (o_merr[N] && !timed_out[N]) assert(i_mwe[N] == o_swe[iM]); if (o_scyc[iM] && i_serr[iM]) assert(i_mwe[N] == o_swe[iM]); end end",
            "always @(*) if (!i_reset && OPT_BUFFER_DECODER && i_mcyc[N]) begin if (dcd_stb[N]) assert(i_mwe[N] == m_we[N]); end // }}} end endgenerate generate for(M=0; M<NS; M=M+1) begin : ASSERT_NOT_CYC_WO_GRANT // {{{",
            "always @(posedge i_clk) if (!$past(sgrant[M])) assert(!o_scyc[M]); // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // CONTRACT SECTION // {{{ //////////////////////////////////////////////////////////////////////// // // // Here's the contract, in two parts: // {{{ // 1. Should ever a master (any master) wish to read from a slave // (any slave), he should be able to read a known value // from that slave (any value) from any arbitrary address // he might wish to read from (any address) // // 2. Should ever a master (any master) wish to write to a slave // (any slave), he should be able to write the exact // value he wants (any value) to the exact address he wants // (any address) // // special_master is an arbitrary constant chosen by the solver, // which can reference *any* possible master // special_address is an arbitrary constant chosen by the solver, // which can reference *any* possible address the master // might wish to access // special_value is an arbitrary value (at least during // induction) representing the current value within the // slave at the given address // }}} // //////////////////////////////////////////////////////////////////////// // // Now let's pay attention to a special bus master and a special // address referencing a special bus slave. We'd like to assert // that we can access the values of every slave from every master. (* anyconst *)",
            "reg [(NM<=1)?0:(LGNM-1):0] special_master;",
            "reg [(NS<=1)?0:(LGNS-1):0] special_slave; (* anyconst *)",
            "reg [AW-1:0] special_address;",
            "reg [DW-1:0] special_value;",
            "always @(*) if (NM <= 1) assume(special_master == 0);",
            "always @(*) if (NS <= 1) assume(special_slave == 0); // // Decode the special address to discover the slave associated with it",
            "always @(*) begin special_slave = NS; for(iM=0; iM<NS; iM = iM+1) begin if (((special_address ^ SLAVE_ADDR[iM*AW +: AW]) &SLAVE_MASK[iM*AW +: AW]) == 0) special_slave = iM; end end generate if (NS > 1) begin : DOUBLE_ADDRESS_CHECK // {{{ // // Check that no slave address has been",
            "assign ed twice. // This check only needs to be done once at the beginning // of the run, during the BMC section.",
            "reg address_found;",
            "always @(*) if (!f_past_valid) begin address_found = 0; for(iM=0; iM<NS; iM = iM+1) begin if (((special_address ^ SLAVE_ADDR[iM*AW +: AW]) &SLAVE_MASK[iM*AW +: AW]) == 0) begin assert(address_found == 0); address_found = 1; end end end // }}} end endgenerate // // Let's assume this slave will acknowledge any request on the next // bus cycle after the stall goes low. Further, lets assume that // it never creates an error, and that it",
            "always responds to our special // address with the special data value given above. To do this, we'll // also need to make certain that the special value will change // following any write. // // These are the \"assumptions\" associated with our fictitious slave. `ifdef VERIFIC",
            "always @(*) if (!f_past_valid) assume(special_value == 0); `else",
            "initial assume(special_value == 0); `endif",
            "always @(posedge i_clk) if (special_slave < NS) begin // {{{ if ($past(o_sstb[special_slave] && !i_sstall[special_slave])) begin assume(i_sack[special_slave]); if ($past(!o_swe[special_slave]) &&($past(o_saddr[special_slave*AW +: AW]) == special_address)) assume(i_sdata[special_slave*DW+: DW] == special_value); end else assume(!i_sack[special_slave]); assume(!i_serr[special_slave]); if (o_scyc[special_slave]) assert(f_soutstanding[special_slave] == i_sack[special_slave]); if (o_sstb[special_slave] && !i_sstall[special_slave] && o_swe[special_slave]) begin for(iM=0; iM < DW/8; iM=iM+1) if (o_ssel[special_slave * DW/8 + iM]) special_value[iM*8 +: 8] <= o_sdata[special_slave * DW + iM*8 +: 8]; end // }}} end // // Now its time to make some assertions. Specifically, we want to // assert that any time we read from this special slave, the special // value is returned.",
            "reg [2:0] f_read_seq;",
            "reg f_read_ack, f_read_sstall;",
            "initial f_read_sstall = 0;",
            "always @(posedge i_clk) f_read_sstall <= s_stall[special_slave];",
            "always @(*) f_read_ack = (f_read_seq[2] || ((!OPT_DBLBUFFER)&&f_read_seq[1] && !f_read_sstall));",
            "initial f_read_seq = 0;",
            "always @(posedge i_clk) if ((special_master < NM)&&(special_slave < NS) &&(i_mcyc[special_master]) &&(!timed_out[special_master])) begin f_read_seq <= 0; if ((grant[special_master][special_slave]) &&(m_stb[special_master]) &&(m_addr[special_master] == special_address) &&(!m_we[special_master]) ) begin f_read_seq[0] <= 1; end if (|f_read_seq) begin assert(grant[special_master][special_slave]); assert(mgrant[special_master]); assert(sgrant[special_slave]); assert(mindex[special_master] == special_slave); assert(sindex[special_slave] == special_master); assert(!o_merr[special_master]); end if (f_read_seq[0] && !$past(s_stall[special_slave])) begin assert(o_scyc[special_slave]); assert(o_sstb[special_slave]); assert(!o_swe[special_slave]); assert(o_saddr[special_slave*AW +: AW] == special_address); f_read_seq[1] <= 1; end else if (f_read_seq[0] && $past(s_stall[special_slave])) begin assert($stable(m_stb[special_master])); assert(!m_we[special_master]); assert(m_addr[special_master] == special_address); f_read_seq[0] <= 1; end if (f_read_seq[1] && $past(s_stall[special_slave])) begin assert(o_scyc[special_slave]); assert(o_sstb[special_slave]); assert(!o_swe[special_slave]); assert(o_saddr[special_slave*AW +: AW] == special_address); f_read_seq[1] <= 1; end else if (f_read_seq[1] && !$past(s_stall[special_slave])) begin assert(i_sack[special_slave]); assert(i_sdata[special_slave*DW +: DW] == $past(special_value)); if (OPT_DBLBUFFER) f_read_seq[2] <= 1; end if (f_read_ack) begin assert(o_mack[special_master]); assert(o_mdata[special_master * DW +: DW] == $past(special_value,2)); end end else f_read_seq <= 0;",
            "always @(*) cover(i_mcyc[special_master] && f_read_ack); // // Let's try a write assertion now. Specifically, on any request to // write to our special address, we want to assert that the special // value at that address can be written.",
            "reg [2:0] f_write_seq;",
            "reg f_write_ack, f_write_sstall;",
            "initial f_write_sstall = 0;",
            "always @(posedge i_clk) f_write_sstall = s_stall[special_slave];",
            "always @(*) f_write_ack = (f_write_seq[2] || ((!OPT_DBLBUFFER)&&f_write_seq[1] && !f_write_sstall));",
            "initial f_write_seq = 0;",
            "always @(posedge i_clk) if ((special_master < NM)&&(special_slave < NS) &&(i_mcyc[special_master]) &&(!timed_out[special_master])) begin f_write_seq <= 0; if ((grant[special_master][special_slave]) &&(m_stb[special_master]) &&(m_addr[special_master] == special_address) &&(m_we[special_master])) begin // Our write sequence begins when our special master // has access to the bus, *and* he is trying to write // to our special address. f_write_seq[0] <= 1; end if (|f_write_seq) begin assert(grant[special_master][special_slave]); assert(mgrant[special_master]); assert(sgrant[special_slave]); assert(mindex[special_master] == special_slave); assert(sindex[special_slave] == special_master); assert(!o_merr[special_master]); end if (f_write_seq[0] && !$past(s_stall[special_slave])) begin assert(o_scyc[special_slave]); assert(o_sstb[special_slave]); assert(o_swe[special_slave]); assert(o_saddr[special_slave*AW +: AW] == special_address); assert(o_sdata[special_slave*DW +: DW] == $past(m_data[special_master])); assert(o_ssel[special_slave*DW/8 +: DW/8] == $past(m_sel[special_master])); f_write_seq[1] <= 1; end else if (f_write_seq[0] && $past(s_stall[special_slave])) begin assert($stable(m_stb[special_master])); assert(m_we[special_master]); assert(m_addr[special_master] == special_address); assert($stable(m_data[special_master])); assert($stable(m_sel[special_master])); f_write_seq[0] <= 1; end if (f_write_seq[1] && $past(s_stall[special_slave])) begin assert(o_scyc[special_slave]); assert(o_sstb[special_slave]); assert(o_swe[special_slave]); assert(o_saddr[special_slave*AW +: AW] == special_address); assert($stable(o_sdata[special_slave*DW +: DW])); assert($stable(o_ssel[special_slave*DW/8 +: DW/8])); f_write_seq[1] <= 1; end else if (f_write_seq[1] && !$past(s_stall[special_slave])) begin for(iM=0; iM<DW/8; iM=iM+1) begin if ($past(o_ssel[special_slave * DW/8 + iM])) assert(special_value[iM*8 +: 8] == $past(o_sdata[special_slave*DW+iM*8 +: 8])); end assert(i_sack[special_slave]); if (OPT_DBLBUFFER) f_write_seq[2] <= 1; end if (f_write_seq[2] || ((!OPT_DBLBUFFER) && f_write_seq[1] && !$past(s_stall[special_slave]))) assert(o_mack[special_master]); end else f_write_seq <= 0;",
            "always @(*) cover(i_mcyc[special_master] && f_write_ack); // }}} //////////////////////////////////////////////////////////////////////// // // COVER: Full connectivity check // {{{ //////////////////////////////////////////////////////////////////////// // // reg [NM-1:0] f_m_ackd;",
            "reg [NS-1:0] f_s_ackd;",
            "reg f_cvr_aborted;",
            "initial f_cvr_aborted = 0;",
            "always @(posedge i_clk) if (!f_past_valid || i_reset) f_cvr_aborted <= 0; else for(iN=0; iN<NM; iN=iN+1) begin if (request[iN][NS]) f_cvr_aborted = 1; if ($fell(i_mcyc[iN])) begin if (f_macks[iN] != f_mreqs[iN]) f_cvr_aborted = 1; end end",
            "initial f_m_ackd = 0; generate for (N=0; N<NM; N=N+1) begin : GEN_FM_ACKD",
            "always @(posedge i_clk) if (i_reset) f_m_ackd[N] <= 0; else if (o_mack[N]) f_m_ackd[N] <= 1'b1; end endgenerate",
            "always @(posedge i_clk) cover(!f_cvr_aborted && (&f_m_ackd)); generate if (NM > 1) begin",
            "always @(posedge i_clk) cover(!f_cvr_aborted && (&f_m_ackd[1:0])); end endgenerate",
            "initial f_s_ackd = 0; generate for (M=0; M<NS; M=M+1) begin : GEN_FS_ACKD",
            "always @(posedge i_clk) if (i_reset) f_s_ackd[M] <= 1'b0; else if (sgrant[M] && o_mack[sindex[M]]) f_s_ackd[M] <= 1'b1; end endgenerate",
            "always @(posedge i_clk) cover(!f_cvr_aborted && (&f_s_ackd[NS-1:0])); generate if (NS > 1) begin",
            "always @(posedge i_clk) cover(!f_cvr_aborted && (&f_s_ackd[NS-1:0])); end endgenerate // }}} `endif // }}}",
            "endmodule `ifndef YOSYS `default_nettype",
            "wire `endif"
        ]
    },
    {
        "file_name": "axilite2axi.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axilite2axi.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/axilite2axi.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2019-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module axilite2axi #( // {{{",
            "parameter C_AXI_ID_WIDTH = 4, C_AXI_ADDR_WIDTH= 32, C_AXI_DATA_WIDTH= 32, parameter [C_AXI_ID_WIDTH-1:0] C_AXI_WRITE_ID = 0, C_AXI_READ_ID = 0 // }}} ) ( // {{{",
            "input wire ACLK, input wire ARESETN, // Slave AXI interface // {{{ // Slave write signals",
            "input wire S_AXI_AWVALID, output wire S_AXI_AWREADY, input wire [C_AXI_ADDR_WIDTH-1:0] S_AXI_AWADDR, // Verilator coverage_off",
            "input wire [3-1:0] S_AXI_AWPROT, // Verilator coverage_on // Slave write data signals",
            "input wire S_AXI_WVALID, output wire S_AXI_WREADY, input wire [C_AXI_DATA_WIDTH-1:0] S_AXI_WDATA, input wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB, // Slave return write response",
            "output wire S_AXI_BVALID, input wire S_AXI_BREADY, output wire [2-1:0] S_AXI_BRESP, // Slave read signals",
            "input wire S_AXI_ARVALID, output wire S_AXI_ARREADY, input wire [C_AXI_ADDR_WIDTH-1:0] S_AXI_ARADDR, input wire [3-1:0] S_AXI_ARPROT, // Slave read data signals",
            "output wire S_AXI_RVALID, input wire S_AXI_RREADY, output wire [C_AXI_DATA_WIDTH-1:0] S_AXI_RDATA, output wire [2-1:0] S_AXI_RRESP, // }}} // Master AXI interface // {{{ // Master interface write address",
            "output wire M_AXI_AWVALID, input wire M_AXI_AWREADY, // Verilator coverage_off",
            "output wire [C_AXI_ID_WIDTH-1:0] M_AXI_AWID, // Verilator coverage_on",
            "output wire [C_AXI_ADDR_WIDTH-1:0] M_AXI_AWADDR, // Verilator coverage_off",
            "output wire [8-1:0] M_AXI_AWLEN, output wire [3-1:0] M_AXI_AWSIZE, output wire [2-1:0] M_AXI_AWBURST, output wire M_AXI_AWLOCK, output wire [4-1:0] M_AXI_AWCACHE, output wire [3-1:0] M_AXI_AWPROT, output wire [4-1:0] M_AXI_AWQOS, // Verilator coverage_on // Master write data",
            "output wire M_AXI_WVALID, input wire M_AXI_WREADY, output wire [C_AXI_DATA_WIDTH-1:0] M_AXI_WDATA, output wire [C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB, output wire M_AXI_WLAST, // Master write response",
            "input wire M_AXI_BVALID, output wire M_AXI_BREADY, input wire [C_AXI_ID_WIDTH-1:0] M_AXI_BID, // Verilator coverage_off",
            "input wire [1:0] M_AXI_BRESP, // Verilator coverage_on // Master interface read address",
            "output wire M_AXI_ARVALID, input wire M_AXI_ARREADY, output wire [C_AXI_ID_WIDTH-1:0] M_AXI_ARID, output wire [C_AXI_ADDR_WIDTH-1:0] M_AXI_ARADDR, // Verilator coverage_off",
            "output wire [8-1:0] M_AXI_ARLEN, output wire [3-1:0] M_AXI_ARSIZE, output wire [2-1:0] M_AXI_ARBURST, output wire M_AXI_ARLOCK, output wire [4-1:0] M_AXI_ARCACHE, output wire [3-1:0] M_AXI_ARPROT, output wire [4-1:0] M_AXI_ARQOS, // Verilator coverage_on // Master interface read data return",
            "input wire M_AXI_RVALID, output wire M_AXI_RREADY, // Verilator coverage_off",
            "input wire [C_AXI_ID_WIDTH-1:0] M_AXI_RID, // Verilator coverage_on",
            "input wire [C_AXI_DATA_WIDTH-1:0] M_AXI_RDATA, input wire M_AXI_RLAST, input wire [2-1:0] M_AXI_RRESP // }}} // }}} );",
            "localparam ADDRLSB = $clog2(C_AXI_DATA_WIDTH)-3;",
            "assign M_AXI_AWID = C_AXI_WRITE_ID;",
            "assign M_AXI_AWADDR = S_AXI_AWADDR;",
            "assign M_AXI_AWLEN = 0;",
            "assign M_AXI_AWSIZE = ADDRLSB[2:0];",
            "assign M_AXI_AWBURST = 0;",
            "assign M_AXI_AWLOCK = 0;",
            "assign M_AXI_AWCACHE = 4'b0011; // As recommended by Xilinx UG1037",
            "assign M_AXI_AWPROT = S_AXI_AWPROT;",
            "assign M_AXI_AWQOS = 0;",
            "assign M_AXI_AWVALID = S_AXI_AWVALID;",
            "assign S_AXI_AWREADY = M_AXI_AWREADY; // Master write data",
            "assign M_AXI_WDATA = S_AXI_WDATA;",
            "assign M_AXI_WLAST = 1;",
            "assign M_AXI_WSTRB = S_AXI_WSTRB;",
            "assign M_AXI_WVALID = S_AXI_WVALID;",
            "assign S_AXI_WREADY = M_AXI_WREADY; // Master write response",
            "assign S_AXI_BRESP = M_AXI_BRESP;",
            "assign S_AXI_BVALID = M_AXI_BVALID;",
            "assign M_AXI_BREADY = S_AXI_BREADY; // // assign M_AXI_ARID = C_AXI_READ_ID;",
            "assign M_AXI_ARADDR = S_AXI_ARADDR;",
            "assign M_AXI_ARLEN = 0;",
            "assign M_AXI_ARSIZE = ADDRLSB[2:0];",
            "assign M_AXI_ARBURST = 0;",
            "assign M_AXI_ARLOCK = 0;",
            "assign M_AXI_ARCACHE = 4'b0011; // As recommended by Xilinx UG1037",
            "assign M_AXI_ARPROT = S_AXI_ARPROT;",
            "assign M_AXI_ARQOS = 0;",
            "assign M_AXI_ARVALID = S_AXI_ARVALID;",
            "assign S_AXI_ARREADY = M_AXI_ARREADY; // assign S_AXI_RDATA = M_AXI_RDATA;",
            "assign S_AXI_RRESP = M_AXI_RRESP;",
            "assign S_AXI_RVALID = M_AXI_RVALID;",
            "assign M_AXI_RREADY = S_AXI_RREADY; // Make Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, ACLK, ARESETN, M_AXI_RLAST, M_AXI_RID, M_AXI_BID }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} `ifdef FORMAL // // The following are some of the properties used to verify this design // localparam F_LGDEPTH = 10;",
            "wire [F_LGDEPTH-1:0] faxil_awr_outstanding, faxil_wr_outstanding, faxil_rd_outstanding; faxil_slave #( .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .F_LGDEPTH(10), .F_AXI_MAXRSTALL(4), .F_AXI_MAXWAIT(9), .F_AXI_MAXDELAY(0) ) faxil(.i_clk(ACLK), .i_axi_reset_n(ARESETN), // .i_axi_awvalid(S_AXI_AWVALID), .i_axi_awready(S_AXI_AWREADY), .i_axi_awaddr( S_AXI_AWADDR), .i_axi_awprot( S_AXI_AWPROT), // .i_axi_wvalid(S_AXI_WVALID), .i_axi_wready(S_AXI_WREADY), .i_axi_wdata( S_AXI_WDATA), .i_axi_wstrb( S_AXI_WSTRB), // .i_axi_bvalid(S_AXI_BVALID), .i_axi_bready(S_AXI_BREADY), .i_axi_bresp( S_AXI_BRESP), // .i_axi_arvalid(S_AXI_ARVALID), .i_axi_arready(S_AXI_ARREADY), .i_axi_araddr( S_AXI_ARADDR), .i_axi_arprot( S_AXI_ARPROT), // // .i_axi_rvalid(S_AXI_RVALID), .i_axi_rready(S_AXI_RREADY), .i_axi_rdata( S_AXI_RDATA), .i_axi_rresp( S_AXI_RRESP), // .f_axi_awr_outstanding(faxil_awr_outstanding), .f_axi_wr_outstanding(faxil_wr_outstanding), .f_axi_rd_outstanding(faxil_rd_outstanding)); // // ... // faxi_master #( .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH), .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .OPT_MAXBURST(0), .OPT_EXCLUSIVE(1'b0), .OPT_NARROW_BURST(1'b0), .F_OPT_NO_RESET(1'b1), .F_LGDEPTH(10), .F_AXI_MAXSTALL(4), .F_AXI_MAXRSTALL(0), .F_AXI_MAXDELAY(4) ) faxi(.i_clk(ACLK), .i_axi_reset_n(ARESETN), // .i_axi_awready(M_AXI_AWREADY), .i_axi_awid( M_AXI_AWID), .i_axi_awaddr( M_AXI_AWADDR), .i_axi_awlen( M_AXI_AWLEN), .i_axi_awsize( M_AXI_AWSIZE), .i_axi_awburst(M_AXI_AWBURST), .i_axi_awlock( M_AXI_AWLOCK), .i_axi_awcache(M_AXI_AWCACHE), .i_axi_awprot( M_AXI_AWPROT), .i_axi_awqos( M_AXI_AWQOS), .i_axi_awvalid(M_AXI_AWVALID), // .i_axi_wready(M_AXI_WREADY), .i_axi_wdata( M_AXI_WDATA), .i_axi_wstrb( M_AXI_WSTRB), .i_axi_wlast( M_AXI_WLAST), .i_axi_wvalid(M_AXI_WVALID), // .i_axi_bready(M_AXI_BREADY), .i_axi_bid( M_AXI_BID), .i_axi_bresp( M_AXI_BRESP), .i_axi_bvalid(M_AXI_BVALID), // .i_axi_arready(M_AXI_ARREADY), .i_axi_arid( M_AXI_ARID), .i_axi_araddr( M_AXI_ARADDR), .i_axi_arlen( M_AXI_ARLEN), .i_axi_arsize( M_AXI_ARSIZE), .i_axi_arburst(M_AXI_ARBURST), .i_axi_arlock( M_AXI_ARLOCK), .i_axi_arcache(M_AXI_ARCACHE), .i_axi_arprot( M_AXI_ARPROT), .i_axi_arqos( M_AXI_ARQOS), .i_axi_arvalid(M_AXI_ARVALID), // .i_axi_rid( M_AXI_RID), .i_axi_rdata( M_AXI_RDATA), .i_axi_rready(M_AXI_RREADY), .i_axi_rresp( M_AXI_RRESP), .i_axi_rvalid(M_AXI_RVALID), // .f_axi_awr_nbursts(faxi_awr_nbursts), .f_axi_wr_pending(faxi_wr_pending), .f_axi_rd_nbursts(faxi_rd_nbursts), .f_axi_rd_outstanding(faxi_rd_outstanding) // // ... // ); //////////////////////////////////////////////////////////////////////// // // Induction rule checks // //////////////////////////////////////////////////////////////////////// // // // First rule: the AXI solver isn't permitted to have any more write // bursts outstanding than the AXI-lite interface has.",
            "always @(*) assert(faxi_awr_nbursts == faxil_awr_outstanding); // // Second: Since our bursts are limited to one value each, and since // we can't send address bursts ahead of their data counterparts, // (AXI property limitation) faxi_wr_pending can only ever be one or // zero, and the counters must match",
            "always @(*) begin // // ... // if (faxil_awr_outstanding != 0) begin assert((faxil_awr_outstanding == faxil_wr_outstanding) ||(faxil_awr_outstanding-1 == faxil_wr_outstanding)); end if (faxil_awr_outstanding == 0) assert(faxil_wr_outstanding == 0); end // // ... // //////////////////////////////////////////////////////////////////////// // // Known \"bugs\" // //////////////////////////////////////////////////////////////////////// // // These are really more limitations in the AXI properties than // bugs in the code, but they need to be documented here. // generate if (C_AXI_DATA_WIDTH > 8) begin // The AXI-lite property checker doesn't validate WSTRB // values like it should. If we don't force the AWADDR // LSBs to zero, the solver will pick an invalid WSTRB. // always @(*) assume(S_AXI_AWADDR[$clog2(C_AXI_DATA_WIDTH)-3:0] == 0);",
            "always @(*) assert(faxi_wr_addr[$clog2(C_AXI_DATA_WIDTH)-3:0] == 0); end endgenerate // // The AXI solver can't handle write transactions without either a // concurrent or proceeding write address burst. Here we make that // plain. It's not likely to cause any problems, but still worth // noting.",
            "always @(*) if (faxil_awr_outstanding == faxil_wr_outstanding) assume(S_AXI_AWVALID || !S_AXI_WVALID); else if (faxil_awr_outstanding > faxil_wr_outstanding) assume(!S_AXI_AWVALID); // // We need to make certain that our counters never overflow. This is // an assertion within the property checkers, so we need an appropriate // matching assumption here. In practice, F_LGDEPTH could be set // so arbitrarily large that this assumption would never get hit, // but the solver doesn't know that.",
            "always @(*) if (faxil_rd_outstanding >= {{(F_LGDEPTH-1){1'b1}}, 1'b0 }) assume(!S_AXI_ARVALID);",
            "always @(*) if (faxil_awr_outstanding >= {{(F_LGDEPTH-1){1'b1}}, 1'b0 }) assume(!S_AXI_AWVALID); `endif",
            "endmodule `ifndef YOSYS `default_nettype",
            "wire `endif"
        ]
    },
    {
        "file_name": "memdev.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/memdev.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/memdev.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This file is really simple: it creates an on-chip memory, // accessible via the wishbone bus, that can be used in this // project. The memory has single cycle pipeline access, although the // memory pipeline here still costs a cycle and there may be other cycles // lost between the ZipCPU (or whatever is the master of the bus) and this, // thus costing more cycles in access. Either way, operations can be // pipelined for single cycle access on subsequent transactions. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module memdev #( // {{{",
            "parameter LGMEMSZ=15, DW=32, EXTRACLOCK= 1, parameter HEXFILE=\"\", parameter [0:0] OPT_ROM = 1'b0, localparam AW = LGMEMSZ - $clog2(DW/8) // }}} ) ( // {{{",
            "input wire i_clk, i_reset, input wire i_wb_cyc, i_wb_stb, i_wb_we, input wire [(AW-1):0] i_wb_addr, input wire [(DW-1):0] i_wb_data, input wire [(DW/8-1):0] i_wb_sel, output wire o_wb_stall, output reg o_wb_ack, output reg [(DW-1):0] o_wb_data // }}} ); // Local declarations // {{{",
            "wire w_wstb, w_stb;",
            "wire [(DW-1):0] w_data;",
            "wire [(AW-1):0] w_addr;",
            "wire [(DW/8-1):0] w_sel;",
            "reg [(DW-1):0] mem [0:((1<<AW)-1)]; // }}} // Pre-load the memory // {{{ generate if (HEXFILE != 0) begin : PRELOAD_MEMORY",
            "initial $readmemh(HEXFILE, mem); end endgenerate // }}} // Delay request if necessary // {{{ generate if (EXTRACLOCK == 0) begin : NO_EXTRA_CLOCK // {{{",
            "assign w_wstb = (i_wb_stb)&&(i_wb_we);",
            "assign w_stb = i_wb_stb;",
            "assign w_addr = i_wb_addr;",
            "assign w_data = i_wb_data;",
            "assign w_sel = i_wb_sel; // }}} end else begin : EXTRA_MEM_CLOCK_CYCLE // {{{",
            "reg last_wstb, last_stb;",
            "reg [(AW-1):0] last_addr;",
            "reg [(DW-1):0] last_data;",
            "reg [(DW/8-1):0] last_sel;",
            "initial last_wstb = 0;",
            "always @(posedge i_clk) if (i_reset) last_wstb <= 0; else last_wstb <= (i_wb_stb)&&(i_wb_we);",
            "initial last_stb = 1'b0;",
            "always @(posedge i_clk) if (i_reset) last_stb <= 1'b0; else last_stb <= (i_wb_stb);",
            "always @(posedge i_clk) last_data <= i_wb_data;",
            "always @(posedge i_clk) last_addr <= i_wb_addr;",
            "always @(posedge i_clk) last_sel <= i_wb_sel;",
            "assign w_wstb = last_wstb;",
            "assign w_stb = last_stb;",
            "assign w_addr = last_addr;",
            "assign w_data = last_data;",
            "assign w_sel = last_sel; // }}} end endgenerate // }}} // Read from memory // {{{",
            "always @(posedge i_clk) o_wb_data <= mem[w_addr]; // }}} // Write to memory (if not a ROM) // {{{ generate if (!OPT_ROM) begin : WRITE_TO_MEMORY // {{{ integer ik;",
            "always @(posedge i_clk) if (w_wstb) begin for(ik=0; ik<DW/8; ik=ik+1) if (w_sel[ik]) mem[w_addr][ik*8 +: 8] <= w_data[ik*8 +: 8]; end `ifdef VERILATOR end else begin : VERILATOR_ROM // Make Verilator happy // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire rom_unused;",
            "assign rom_unused = &{ 1'b0, w_wstb, w_data, w_sel }; // Verilator lint_on UNUSED // Verilator coverage_on `endif // }}} end endgenerate // }}} // o_wb_ack // {{{",
            "initial o_wb_ack = 1'b0;",
            "always @(posedge i_clk) if (i_reset) o_wb_ack <= 1'b0; else o_wb_ack <= (w_stb)&&(i_wb_cyc); // }}}",
            "assign o_wb_stall = 1'b0; // Make verilator happy // {{{ // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = { 1'b0 }; // verilator lint_on UNUSED // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "localparam F_LGDEPTH = 2;",
            "reg f_past_valid;",
            "wire [F_LGDEPTH-1:0] f_nreqs, f_nacks, f_outstanding;",
            "wire [(AW-1):0] f_addr;",
            "reg [31:0] f_data;",
            "initial f_past_valid = 1'b0;",
            "always @(posedge i_clk) f_past_valid <= 1'b1;",
            "always @(*) if (!f_past_valid) assume(i_reset); fwb_slave #( .AW(AW), .DW(DW), .F_MAX_STALL(1), .F_MAX_ACK_DELAY(2), .F_OPT_DISCONTINUOUS(1), .F_LGDEPTH(F_LGDEPTH) ) fwb(i_clk, i_reset, i_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel, o_wb_ack, o_wb_stall, o_wb_data, 1'b0, f_nreqs, f_nacks, f_outstanding); generate if (EXTRACLOCK) begin",
            "always @(posedge i_clk) if ((f_past_valid)&&(!i_reset)&&(i_wb_cyc)&&($past(i_wb_cyc))) assert((f_outstanding == 0) == ((!$past(w_stb))&&(!$past(i_wb_stb))));",
            "always @(posedge i_clk) if ((f_past_valid)&&(!i_reset)&&(i_wb_cyc)) assert((f_outstanding == 1) == ( (($past(w_stb))&&($past(i_wb_cyc))) ^($past(i_wb_stb))));",
            "always @(posedge i_clk) if ((f_past_valid)&&(!i_reset)&&(i_wb_cyc)) assert((f_outstanding == 2'h2) == (($past(w_stb))&&($past(i_wb_cyc)) &&($past(i_wb_stb))));",
            "always @(posedge i_clk) assert(f_outstanding <= 2); end else begin",
            "always @(posedge i_clk) if (f_outstanding > 0) assert(o_wb_ack);",
            "always @(posedge i_clk) assert(f_outstanding <= 1);",
            "always @(posedge i_clk) if ((f_past_valid)&&(!i_reset)&&(i_wb_cyc)&&($past(i_wb_stb))) assert(f_outstanding == 1); end endgenerate",
            "always @(*) assert(!o_wb_stall); (* anyconst *)",
            "wire [(AW-1):0] f_addr; (* anyconst *)",
            "wire [DW-1:0] f_first;",
            "reg [DW-1:0] f_data; generate if (OPT_ROM) begin : F_MATCH_WRITES // This just guarantees *something* drives f_data. Otherwise // it is held as 'x, and the assumptions below don't help us.",
            "always @(posedge i_clk) if (!f_past_valid) f_data <= f_first; end else if (EXTRACLOCK) begin integer fk;",
            "always @(posedge i_clk) if (f_past_valid && !$past(i_reset) && $past(i_wb_stb && i_wb_we) && $past(i_wb_addr == f_addr)) begin for(fk=0; fk<DW/8; fk=fk+1) if ($past(i_wb_sel[fk])) f_data[8*fk +: 8] <= $past(i_wb_data[8*fk +: 8]); end end else begin integer fk;",
            "always @(posedge i_clk) if (i_wb_stb && i_wb_we && i_wb_addr == f_addr) begin for(fk=0; fk<DW/8; fk=fk+1) if (i_wb_sel[fk]) f_data[8*fk +: 8] <= i_wb_data[8*fk +: 8]; end end endgenerate",
            "always @(*) if (!f_past_valid) begin assume(mem[f_addr] == f_data); assume(f_data == f_first); end else begin assert(mem[f_addr] == f_data); end",
            "always @(posedge i_clk) if ((f_past_valid)&&(OPT_ROM)) assert($stable(f_data)); `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "axi_tb.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axi_tb.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/axi_tb.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Top level test infrastructure for all AXI and AXI-lite // configurations of the ZipCPU. Contains: // // - Memory // - Console port (Not a serial port--$write's directly to console here) // - External debug access // - WBScope // // Since these are the capabilities that will be required to test the // ZipCPU. // // The goal is to be able to run the CPU test program, in all of the // ZipCPU's various AXI and AXI-lite configurations, and by using it to // routinely smoke out any bugs before making any releases. // // A similar test bench exists for testing the Wishbone version(s) of // the ZipCPU. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2022-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none `timescale 1ns/1ns // }}}",
            "module axi_tb #( // {{{",
            "parameter ADDRESS_WIDTH = 28, //Width in bytes",
            "parameter BUS_WIDTH = 32, // Verilator lint_off WIDTH",
            "parameter [0:0] OPT_ZIPAXIL = 1'b1, parameter [0:0] OPT_PIPELINED = 1'b1, parameter OPT_LGICACHE = 12, parameter OPT_LGDCACHE = 12, parameter OPT_MPY = 3, parameter [0:0] OPT_DIV = 1'b1, parameter [0:0] OPT_SHIFTS = 1'b1, parameter [0:0] OPT_LOCK = 1'b1, parameter [0:0] OPT_EARLY_BRANCHING = 1'b1, parameter [0:0] OPT_LOWPOWER = 1'b1, parameter [0:0] OPT_DISTRIBUTED_REGS = 1'b1, parameter [0:0] OPT_USERMODE = 1'b1, parameter [0:0] OPT_CLKGATE = 1'b1, parameter [0:0] OPT_DBGPORT = 1'b1, parameter [0:0] OPT_TRACE_PORT = 1'b1, parameter [0:0] OPT_CIS = 1'b1, // verilator lint_off UNUSED",
            "parameter [0:0] OPT_WRAP = 1'b1, // verilator lint_on UNUSED",
            "parameter OPT_SMP = 1, parameter MEM_FILE = \"cput3st\", parameter CONSOLE_FILE = \"console.txt\", parameter ID_WIDTH = 4, localparam IW = ID_WIDTH, parameter LGMEMSZ = ADDRESS_WIDTH-2, // Verilator lint_off UNUSED",
            "parameter [0:0] DUMP_TO_VCD = 1'b0, parameter VCD_FILE = \"dump.vcd\" // Verilator lint_on UNUSED // Verilator lint_on WIDTH // }}} ) ( // {{{ `ifdef VERILATOR",
            "input wire i_aclk, i_aresetn, // Sim control",
            "input (s) // {{{",
            "input wire sim_awvalid, output wire sim_awready, input wire [ADDRESS_WIDTH:0] sim_awaddr, input wire [2:0] sim_awprot, input wire sim_wvalid, output wire sim_wready, input wire [31:0] sim_wdata, input wire [3:0] sim_wstrb, output wire sim_bvalid, input wire sim_bready, output wire [1:0] sim_bresp, input wire sim_arvalid, output wire sim_arready, input wire [ADDRESS_WIDTH:0] sim_araddr, input wire [2:0] sim_arprot, output wire sim_rvalid, input wire sim_rready, output wire [31:0] sim_rdata, output wire [1:0] sim_rresp, // }}}",
            "input wire i_sim_int, // // \"Profiler\" support. This is a simulation only port. // {{{",
            "output wire o_prof_stb, output wire [ADDRESS_WIDTH-1:0] o_prof_addr, output wire [31:0] o_prof_ticks // }}} `endif // }}} ); // Local declarations // {{{ genvar gk;",
            "parameter [31:0] RESET_ADDRESS = { {(32-ADDRESS_WIDTH){1'b0}}, MEMORY_ADDR };",
            "localparam AW = ADDRESS_WIDTH;",
            "parameter [AW-1:0] SCOPE_ADDR = { 4'b0001, {(AW-4){1'b0}} };",
            "parameter [AW-1:0] CONSOLE_ADDR = { 4'b0010, {(AW-4){1'b0}} };",
            "parameter [AW-1:0] SMP_BASE_ADDR= { 4'b0011, {(AW-4){1'b0}} };",
            "parameter [AW-1:0] MEMORY_ADDR = { 2'b01, {(AW-2){1'b0}} };",
            "parameter [AW-1:0] AXILP_ADDR = { {(AW-24){1'b1}},{(24){1'b0}} };",
            "localparam MIN_SMP = (OPT_SMP < 2) ? 1:OPT_SMP;",
            "parameter [OPT_SMP*AW-1:0] SMP_ADDR= SMP_ADDR_fn(MIN_SMP);",
            "parameter [OPT_SMP*AW-1:0] SMP_MASK= SMP_MASK_fn(MIN_SMP); // Verilator coverage_off // Verilator lint_off UNUSED function automatic [OPT_SMP*AW-1:0] SMP_ADDR_fn(",
            "input integer min_smp); // {{{ integer ik, offset; begin SMP_ADDR_fn = {(OPT_SMP){SMP_BASE_ADDR}}; for(ik=1; ik<OPT_SMP; ik=ik+1) begin offset = ik; SMP_ADDR_fn[ik * AW + 9 +: $clog2(OPT_SMP)+1] = offset[$clog2(OPT_SMP):0]; end end endfunction // }}} function automatic [OPT_SMP*AW-1:0] SMP_MASK_fn(",
            "input integer min_smp); // {{{ integer ik; begin SMP_MASK_fn = {(OPT_SMP){ 4'b1111, {(AW-4){1'b0}} }}; for(ik=0; ik<OPT_SMP; ik=ik+1) begin SMP_MASK_fn[ik * AW + 9 +: $clog2(OPT_SMP)+1] = {($clog2(OPT_SMP)+1){1'b1}}; end end endfunction // }}} // Verilator coverage_on // Verilator lint_on UNUSED // localparam LGFIFO = 4; // CPU declarations // {{{",
            "localparam RESET_DURATION = 10;",
            "localparam [0:0] OPT_SIM = 1'b1; `ifdef VERILATOR",
            "localparam [0:0] OPT_PROFILER = 1'b1; `else",
            "localparam [0:0] OPT_PROFILER = 1'b0; `endif // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire cpu_int; // Verilator lint_on UNUSED",
            "wire scope_int;",
            "wire [31:0] cpu_trace; // Verilator coverage_on",
            "wire [OPT_SMP-1:0] cpu_reset;",
            "wire [OPT_SMP-1:0] cpu_halted;",
            "wire [OPT_SMP-1:0] cpu_gie;",
            "wire [OPT_SMP-1:0] cpu_op_stall, cpu_pf_stall, cpu_i_count;",
            "wire pic_interrupt, watchdog_reset; // dbg* // {{{",
            "wire dbg_awvalid, dbg_awready;",
            "wire [AW:0] dbg_awaddr;",
            "wire [2:0] dbg_awprot;",
            "wire dbg_wvalid, dbg_wready;",
            "wire [31:0] dbg_wdata;",
            "wire [3:0] dbg_wstrb;",
            "wire dbg_bvalid, dbg_bready;",
            "wire [1:0] dbg_bresp;",
            "wire dbg_arvalid, dbg_arready;",
            "wire [AW:0] dbg_araddr;",
            "wire [2:0] dbg_arprot;",
            "wire dbg_rvalid, dbg_rready;",
            "wire [31:0] dbg_rdata;",
            "wire [1:0] dbg_rresp; // }}} // cpui* // {{{",
            "wire [OPT_SMP-1:0] cpui_awvalid, cpui_awready;",
            "wire [OPT_SMP*IW-1:0] cpui_awid;",
            "wire [OPT_SMP*AW-1:0] cpui_awaddr;",
            "wire [OPT_SMP*8-1:0] cpui_awlen;",
            "wire [OPT_SMP*3-1:0] cpui_awsize;",
            "wire [OPT_SMP*2-1:0] cpui_awburst;",
            "wire [OPT_SMP-1:0] cpui_awlock;",
            "wire [OPT_SMP*4-1:0] cpui_awcache;",
            "wire [OPT_SMP*3-1:0] cpui_awprot;",
            "wire [OPT_SMP*4-1:0] cpui_awqos;",
            "wire [OPT_SMP-1:0] cpui_wvalid, cpui_wready;",
            "wire [OPT_SMP*BUS_WIDTH-1:0] cpui_wdata;",
            "wire [OPT_SMP*BUS_WIDTH/8-1:0] cpui_wstrb;",
            "wire [OPT_SMP-1:0] cpui_wlast;",
            "wire [OPT_SMP-1:0] cpui_bvalid, cpui_bready;",
            "wire [OPT_SMP*IW-1:0] cpui_bid;",
            "wire [OPT_SMP*2-1:0] cpui_bresp;",
            "wire [OPT_SMP-1:0] cpui_arvalid, cpui_arready;",
            "wire [OPT_SMP*IW-1:0] cpui_arid;",
            "wire [OPT_SMP*AW-1:0] cpui_araddr;",
            "wire [OPT_SMP*8-1:0] cpui_arlen;",
            "wire [OPT_SMP*3-1:0] cpui_arsize;",
            "wire [OPT_SMP*2-1:0] cpui_arburst;",
            "wire [OPT_SMP-1:0] cpui_arlock;",
            "wire [OPT_SMP*4-1:0] cpui_arcache;",
            "wire [OPT_SMP*3-1:0] cpui_arprot;",
            "wire [OPT_SMP*4-1:0] cpui_arqos;",
            "wire [OPT_SMP-1:0] cpui_rvalid, cpui_rready;",
            "wire [OPT_SMP*IW-1:0] cpui_rid;",
            "wire [OPT_SMP*BUS_WIDTH-1:0] cpui_rdata;",
            "wire [OPT_SMP*2-1:0] cpui_rresp;",
            "wire [OPT_SMP-1:0] cpui_rlast; // }}} // cpud* // {{{",
            "wire [OPT_SMP-1:0] cpud_awvalid, cpud_awready;",
            "wire [OPT_SMP*IW-1:0] cpud_awid;",
            "wire [OPT_SMP*AW-1:0] cpud_awaddr;",
            "wire [OPT_SMP*8-1:0] cpud_awlen;",
            "wire [OPT_SMP*3-1:0] cpud_awsize;",
            "wire [OPT_SMP*2-1:0] cpud_awburst;",
            "wire [OPT_SMP-1:0] cpud_awlock;",
            "wire [OPT_SMP*4-1:0] cpud_awcache;",
            "wire [OPT_SMP*3-1:0] cpud_awprot;",
            "wire [OPT_SMP*4-1:0] cpud_awqos;",
            "wire [OPT_SMP-1:0] cpud_wvalid, cpud_wready;",
            "wire [OPT_SMP*BUS_WIDTH-1:0] cpud_wdata;",
            "wire [OPT_SMP*BUS_WIDTH/8-1:0] cpud_wstrb;",
            "wire [OPT_SMP-1:0] cpud_wlast;",
            "wire [OPT_SMP-1:0] cpud_bvalid, cpud_bready;",
            "wire [OPT_SMP*IW-1:0] cpud_bid;",
            "wire [OPT_SMP*2-1:0] cpud_bresp;",
            "wire [OPT_SMP-1:0] cpud_arvalid, cpud_arready;",
            "wire [OPT_SMP*IW-1:0] cpud_arid;",
            "wire [OPT_SMP*AW-1:0] cpud_araddr;",
            "wire [OPT_SMP*8-1:0] cpud_arlen;",
            "wire [OPT_SMP*3-1:0] cpud_arsize;",
            "wire [OPT_SMP*2-1:0] cpud_arburst;",
            "wire [OPT_SMP-1:0] cpud_arlock;",
            "wire [OPT_SMP*4-1:0] cpud_arcache;",
            "wire [OPT_SMP*3-1:0] cpud_arprot;",
            "wire [OPT_SMP*4-1:0] cpud_arqos;",
            "wire [OPT_SMP-1:0] cpud_rvalid, cpud_rready;",
            "wire [OPT_SMP*IW-1:0] cpud_rid;",
            "wire [OPT_SMP*BUS_WIDTH-1:0] cpud_rdata;",
            "wire [OPT_SMP*2-1:0] cpud_rresp;",
            "wire [OPT_SMP-1:0] cpud_rlast; // }}} // smpfull* // {{{",
            "wire [OPT_SMP-1:0] smpfull_awvalid, smpfull_awready;",
            "wire [OPT_SMP*IW-1:0] smpfull_awid;",
            "wire [OPT_SMP*AW-1:0] smpfull_awaddr;",
            "wire [OPT_SMP*8-1:0] smpfull_awlen;",
            "wire [OPT_SMP*3-1:0] smpfull_awsize;",
            "wire [OPT_SMP*2-1:0] smpfull_awburst;",
            "wire [OPT_SMP-1:0] smpfull_awlock;",
            "wire [OPT_SMP*4-1:0] smpfull_awcache;",
            "wire [OPT_SMP*3-1:0] smpfull_awprot;",
            "wire [OPT_SMP*4-1:0] smpfull_awqos;",
            "wire [OPT_SMP-1:0] smpfull_wvalid, smpfull_wready;",
            "wire [OPT_SMP*BUS_WIDTH-1:0] smpfull_wdata;",
            "wire [OPT_SMP*BUS_WIDTH/8-1:0] smpfull_wstrb;",
            "wire [OPT_SMP-1:0] smpfull_wlast;",
            "wire [OPT_SMP-1:0] smpfull_bvalid, smpfull_bready;",
            "wire [OPT_SMP*IW-1:0] smpfull_bid;",
            "wire [OPT_SMP*2-1:0] smpfull_bresp;",
            "wire [OPT_SMP-1:0] smpfull_arvalid, smpfull_arready;",
            "wire [OPT_SMP*IW-1:0] smpfull_arid;",
            "wire [OPT_SMP*AW-1:0] smpfull_araddr;",
            "wire [OPT_SMP*8-1:0] smpfull_arlen;",
            "wire [OPT_SMP*3-1:0] smpfull_arsize;",
            "wire [OPT_SMP*2-1:0] smpfull_arburst;",
            "wire [OPT_SMP-1:0] smpfull_arlock;",
            "wire [OPT_SMP*4-1:0] smpfull_arcache;",
            "wire [OPT_SMP*3-1:0] smpfull_arprot;",
            "wire [OPT_SMP*4-1:0] smpfull_arqos;",
            "wire [OPT_SMP-1:0] smpfull_rvalid, smpfull_rready;",
            "wire [OPT_SMP*IW-1:0] smpfull_rid;",
            "wire [OPT_SMP*BUS_WIDTH-1:0] smpfull_rdata;",
            "wire [OPT_SMP*2-1:0] smpfull_rresp;",
            "wire [OPT_SMP-1:0] smpfull_rlast; // }}} // }}} // Memory declarations // {{{ integer rk;",
            "wire ram_we, ram_rd;",
            "wire [LGMEMSZ-$clog2(BUS_WIDTH/8)-1:0] ram_waddr, ram_raddr;",
            "wire [BUS_WIDTH-1:0] ram_wdata;",
            "wire [BUS_WIDTH/8-1:0] ram_wstrb;",
            "wire [BUS_WIDTH-1:0] ram_rdata;",
            "wire [BUS_WIDTH-1:0] ram_wdata_swap;",
            "reg [BUS_WIDTH-1:0] ram_rdata_swap;",
            "wire [BUS_WIDTH/8-1:0] ram_wstrb_swap;",
            "reg [BUS_WIDTH-1:0] ram [0:(1<<(LGMEMSZ-$clog2(BUS_WIDTH/8)))-1]; // mem* // {{{",
            "wire mem_awvalid, mem_awready;",
            "wire [IW-1:0] mem_awid;",
            "wire [AW-1:0] mem_awaddr;",
            "wire [7:0] mem_awlen;",
            "wire [2:0] mem_awsize;",
            "wire [1:0] mem_awburst;",
            "wire mem_awlock;",
            "wire [3:0] mem_awcache;",
            "wire [2:0] mem_awprot;",
            "wire [3:0] mem_awqos;",
            "wire mem_wvalid, mem_wready;",
            "wire [BUS_WIDTH-1:0] mem_wdata;",
            "wire [BUS_WIDTH/8-1:0] mem_wstrb;",
            "wire mem_wlast;",
            "wire mem_bvalid, mem_bready;",
            "wire [IW-1:0] mem_bid;",
            "wire [1:0] mem_bresp;",
            "wire mem_arvalid, mem_arready;",
            "wire [IW-1:0] mem_arid;",
            "wire [AW-1:0] mem_araddr;",
            "wire [7:0] mem_arlen;",
            "wire [2:0] mem_arsize;",
            "wire [1:0] mem_arburst;",
            "wire mem_arlock;",
            "wire [3:0] mem_arcache;",
            "wire [2:0] mem_arprot;",
            "wire [3:0] mem_arqos;",
            "wire mem_rvalid, mem_rready;",
            "wire [IW-1:0] mem_rid;",
            "wire [BUS_WIDTH-1:0] mem_rdata;",
            "wire [1:0] mem_rresp;",
            "wire mem_rlast; // }}} // }}} // Console declarations // {{{ // con* // {{{",
            "wire con_awvalid, con_awready;",
            "wire [IW-1:0] con_awid;",
            "wire [AW-1:0] con_awaddr;",
            "wire [7:0] con_awlen;",
            "wire [2:0] con_awsize;",
            "wire [1:0] con_awburst;",
            "wire con_awlock;",
            "wire [3:0] con_awcache;",
            "wire [2:0] con_awprot;",
            "wire [3:0] con_awqos;",
            "wire con_wvalid, con_wready;",
            "wire [BUS_WIDTH-1:0] con_wdata;",
            "wire [BUS_WIDTH/8-1:0] con_wstrb;",
            "wire con_wlast;",
            "wire con_bvalid, con_bready;",
            "wire [IW-1:0] con_bid;",
            "wire [1:0] con_bresp;",
            "wire con_arvalid, con_arready;",
            "wire [IW-1:0] con_arid;",
            "wire [AW-1:0] con_araddr;",
            "wire [7:0] con_arlen;",
            "wire [2:0] con_arsize;",
            "wire [1:0] con_arburst;",
            "wire con_arlock;",
            "wire [3:0] con_arcache;",
            "wire [2:0] con_arprot;",
            "wire [3:0] con_arqos;",
            "wire con_rvalid, con_rready;",
            "wire [IW-1:0] con_rid;",
            "wire [BUS_WIDTH-1:0] con_rdata;",
            "wire [1:0] con_rresp;",
            "wire con_rlast; // }}} // conl* // {{{",
            "wire conl_awvalid, conl_awready;",
            "wire [AW-4:0] conl_awaddr;",
            "wire [2:0] conl_awprot;",
            "wire conl_wvalid, conl_wready;",
            "wire [31:0] conl_wdata;",
            "wire [3:0] conl_wstrb;",
            "wire conl_bvalid, conl_bready;",
            "wire [1:0] conl_bresp;",
            "wire conl_arvalid, conl_arready;",
            "wire [AW-4:0] conl_araddr;",
            "wire [2:0] conl_arprot;",
            "wire conl_rvalid, conl_rready;",
            "wire [31:0] conl_rdata;",
            "wire [1:0] conl_rresp; // }}} // }}} // scope* // {{{",
            "wire scope_awvalid, scope_awready;",
            "wire [IW-1:0] scope_awid;",
            "wire [AW-1:0] scope_awaddr;",
            "wire [7:0] scope_awlen;",
            "wire [2:0] scope_awsize;",
            "wire [1:0] scope_awburst;",
            "wire scope_awlock;",
            "wire [3:0] scope_awcache;",
            "wire [2:0] scope_awprot;",
            "wire [3:0] scope_awqos;",
            "wire scope_wvalid, scope_wready;",
            "wire [BUS_WIDTH-1:0] scope_wdata;",
            "wire [BUS_WIDTH/8-1:0] scope_wstrb;",
            "wire scope_wlast;",
            "wire scope_bvalid, scope_bready;",
            "wire [IW-1:0] scope_bid;",
            "wire [1:0] scope_bresp;",
            "wire scope_arvalid, scope_arready;",
            "wire [IW-1:0] scope_arid;",
            "wire [AW-1:0] scope_araddr;",
            "wire [7:0] scope_arlen;",
            "wire [2:0] scope_arsize;",
            "wire [1:0] scope_arburst;",
            "wire scope_arlock;",
            "wire [3:0] scope_arcache;",
            "wire [2:0] scope_arprot;",
            "wire [3:0] scope_arqos;",
            "wire scope_rvalid, scope_rready;",
            "wire [IW-1:0] scope_rid;",
            "wire [BUS_WIDTH-1:0] scope_rdata;",
            "wire [1:0] scope_rresp;",
            "wire scope_rlast; // }}} // AXI Peripheral set declarations // {{{ // axip_* - The AXI4 (full) connection to the peripheral set // {{{",
            "wire axip_awvalid, axip_awready;",
            "wire [IW-1:0] axip_awid;",
            "wire [AW-1:0] axip_awaddr;",
            "wire [7:0] axip_awlen;",
            "wire [2:0] axip_awsize;",
            "wire [1:0] axip_awburst;",
            "wire axip_awlock;",
            "wire [3:0] axip_awcache;",
            "wire [2:0] axip_awprot;",
            "wire [3:0] axip_awqos;",
            "wire axip_wvalid, axip_wready;",
            "wire [BUS_WIDTH-1:0] axip_wdata;",
            "wire [BUS_WIDTH/8-1:0] axip_wstrb;",
            "wire axip_wlast;",
            "wire axip_bvalid, axip_bready;",
            "wire [IW-1:0] axip_bid;",
            "wire [1:0] axip_bresp;",
            "wire axip_arvalid, axip_arready;",
            "wire [IW-1:0] axip_arid;",
            "wire [AW-1:0] axip_araddr;",
            "wire [7:0] axip_arlen;",
            "wire [2:0] axip_arsize;",
            "wire [1:0] axip_arburst;",
            "wire axip_arlock;",
            "wire [3:0] axip_arcache;",
            "wire [2:0] axip_arprot;",
            "wire [3:0] axip_arqos;",
            "wire axip_rvalid, axip_rready;",
            "wire [IW-1:0] axip_rid;",
            "wire [BUS_WIDTH-1:0] axip_rdata;",
            "wire [1:0] axip_rresp;",
            "wire axip_rlast; // }}} // axilp_* - The AXI-Lite connection to the peripheral set // {{{",
            "wire axilp_awvalid, axilp_awready;",
            "wire [AW-4:0] axilp_awaddr;",
            "wire [2:0] axilp_awprot;",
            "wire axilp_wvalid, axilp_wready;",
            "wire [31:0] axilp_wdata;",
            "wire [3:0] axilp_wstrb;",
            "wire axilp_bvalid, axilp_bready;",
            "wire [1:0] axilp_bresp;",
            "wire axilp_arvalid, axilp_arready;",
            "wire [AW-4:0] axilp_araddr;",
            "wire [2:0] axilp_arprot;",
            "wire axilp_rvalid, axilp_rready;",
            "wire [31:0] axilp_rdata;",
            "wire [1:0] axilp_rresp; // }}} // }}} `ifdef VERILATOR // simfull_* // {{{",
            "wire simfull_awvalid;",
            "wire simfull_awready;",
            "wire [IW-1:0] simfull_awid;",
            "wire [ADDRESS_WIDTH:0] simwide_awaddr;",
            "wire [ADDRESS_WIDTH-1:0] simfull_awaddr;",
            "wire [7:0] simfull_awlen;",
            "wire [2:0] simfull_awsize;",
            "wire [1:0] simfull_awburst;",
            "wire simfull_awlock;",
            "wire [3:0] simfull_awcache;",
            "wire [2:0] simfull_awprot;",
            "wire [3:0] simfull_awqos;",
            "wire simfull_wvalid;",
            "wire simfull_wready;",
            "wire [BUS_WIDTH-1:0] simfull_wdata;",
            "wire [BUS_WIDTH/8-1:0] simfull_wstrb;",
            "wire simfull_wlast;",
            "wire simfull_bvalid;",
            "wire simfull_bready;",
            "wire [IW-1:0] simfull_bid;",
            "wire [1:0] simfull_bresp;",
            "wire simfull_arvalid;",
            "wire simfull_arready;",
            "wire [IW-1:0] simfull_arid;",
            "wire [ADDRESS_WIDTH:0] simwide_araddr;",
            "wire [ADDRESS_WIDTH-1:0] simfull_araddr;",
            "wire [7:0] simfull_arlen;",
            "wire [2:0] simfull_arsize;",
            "wire [1:0] simfull_arburst;",
            "wire simfull_arlock;",
            "wire [3:0] simfull_arcache;",
            "wire [2:0] simfull_arprot;",
            "wire [3:0] simfull_arqos;",
            "wire simfull_rvalid;",
            "wire simfull_rready;",
            "wire [IW-1:0] simfull_rid;",
            "wire [BUS_WIDTH-1:0] simfull_rdata;",
            "wire simfull_rlast;",
            "wire [1:0] simfull_rresp; // }}} `else // Traditional TB only declarations // {{{ // sim* // {{{",
            "wire sim_awvalid;",
            "wire sim_awready;",
            "wire [ADDRESS_WIDTH-1:0] sim_awaddr;",
            "wire [2:0] sim_awprot;",
            "wire sim_wvalid;",
            "wire sim_wready;",
            "wire [31:0] sim_wdata;",
            "wire [3:0] sim_wstrb;",
            "wire sim_bvalid;",
            "wire sim_bready;",
            "wire [1:0] sim_bresp;",
            "wire sim_arvalid;",
            "wire sim_arready;",
            "wire [ADDRESS_WIDTH-1:0] sim_araddr;",
            "wire [2:0] sim_arprot;",
            "wire sim_rvalid;",
            "wire sim_rready;",
            "wire [31:0] sim_rdata;",
            "wire [1:0] sim_rresp; // }}}",
            "wire i_sim_int;",
            "wire o_prof_stb; // wire [31:0] o_prof_addr;",
            "wire [ADDRESS_WIDTH-1:0] o_prof_addr;",
            "wire [31:0] o_prof_ticks;",
            "reg i_aclk, i_aresetn, reset_pipe; // }}} `endif // Watchdog timer // {{{",
            "localparam TB_WATCHDOG_TIMEOUT = 1_000_00; // 1ms",
            "reg [$clog2(TB_WATCHDOG_TIMEOUT+2)-1:0] watchdog_counter; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Traditional TB support // {{{ //////////////////////////////////////////////////////////////////////// // // `ifndef VERILATOR",
            "initial i_aclk = 0;",
            "always #5 i_aclk = !i_aclk;",
            "initial { i_aresetn, reset_pipe } = 0;",
            "always @(posedge i_aclk) { i_aresetn, reset_pipe } <= { reset_pipe, 1'b1 }; // Tie off (unused) Sim control",
            "input (s) // {{{",
            "assign sim_awvalid = 1'b0;",
            "assign sim_awaddr = 0;",
            "assign sim_awprot = 0;",
            "assign sim_wvalid = 1'b0;",
            "assign sim_wdata = 0;",
            "assign sim_wstrb = 0;",
            "assign sim_bready = 1'b1;",
            "assign sim_arvalid = 1'b0;",
            "assign sim_araddr = 0;",
            "assign sim_arprot = 0;",
            "assign sim_rready = 1'b1; // }}}",
            "assign i_sim_int = 1'b0; `endif // }}} //////////////////////////////////////////////////////////////////////// // // External sim port: Either controls ZipCPU or wide WB bus // {{{ //////////////////////////////////////////////////////////////////////// // // `ifdef VERILATOR // Only required if we are using Verilator. Other test benches won't // use this",
            "input port",
            "wire simsub_arvalid, simsub_arready;",
            "wire [31:0] simsub_wdata, simsub_rdata;",
            "wire [3:0] simsub_wstrb; axilxbar #( // {{{ .NM(1), .NS(2), .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH+1), .C_AXI_DATA_WIDTH(32), .SLAVE_ADDR({ { 1'b0, {(ADDRESS_WIDTH){1'b0}} }, { 1'b1, {(ADDRESS_WIDTH){1'b0}} }}), // CPU .SLAVE_MASK({ { 1'b0, {(ADDRESS_WIDTH){1'b0}} }, { 1'b1, {(ADDRESS_WIDTH){1'b0}} }}) // CPU // }}} ) simxbar ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), // One master: the SIM bus",
            "input // {{{ .S_AXI_AWVALID(sim_awvalid), .S_AXI_AWREADY(sim_awready), .S_AXI_AWADDR(sim_awaddr), .S_AXI_AWPROT(sim_awprot), // .S_AXI_WVALID(sim_wvalid), .S_AXI_WREADY(sim_wready), .S_AXI_WDATA(sim_wdata), .S_AXI_WSTRB(sim_wstrb), // .S_AXI_BVALID(sim_bvalid), .S_AXI_BREADY(sim_bready), .S_AXI_BRESP(sim_bresp), // .S_AXI_ARVALID(sim_arvalid), .S_AXI_ARREADY(sim_arready), .S_AXI_ARADDR(sim_araddr), .S_AXI_ARPROT(sim_arprot), // .S_AXI_RVALID(sim_rvalid), .S_AXI_RREADY(sim_rready), .S_AXI_RDATA(sim_rdata), .S_AXI_RRESP(sim_rresp), // }}} // Two slaves: The wide bus the ZipCPU masters, and the ZipCPU's // debug port // {{{ .M_AXI_AWVALID({ simfull_awvalid, dbg_awvalid }), .M_AXI_AWREADY({ simfull_awready, dbg_awready }), .M_AXI_AWADDR({ simwide_awaddr, dbg_awaddr }), .M_AXI_AWPROT({ simfull_awprot, dbg_awprot }), // .M_AXI_WVALID({ simfull_wvalid, dbg_wvalid }), .M_AXI_WREADY({ simfull_wready, dbg_wready }), .M_AXI_WDATA({ simsub_wdata, dbg_wdata }), .M_AXI_WSTRB({ simsub_wstrb, dbg_wstrb }), // .M_AXI_BVALID({ simfull_bvalid, dbg_bvalid }), .M_AXI_BREADY({ simfull_bready, dbg_bready }), .M_AXI_BRESP({ simfull_bresp, dbg_bresp }), // .M_AXI_ARVALID({ simsub_arvalid, dbg_arvalid }), .M_AXI_ARREADY({ simsub_arready, dbg_arready }), .M_AXI_ARADDR({ simwide_araddr, dbg_araddr }), .M_AXI_ARPROT({ simfull_arprot, dbg_arprot }), // .M_AXI_RVALID({ simfull_rvalid, dbg_rvalid }), .M_AXI_RREADY({ simfull_rready, dbg_rready }), .M_AXI_RDATA({ simsub_rdata, dbg_rdata }), .M_AXI_RRESP({ simfull_rresp, dbg_rresp }) // }}} // }}} );",
            "assign simfull_awid = 0;",
            "assign simfull_awaddr = simwide_awaddr[ADDRESS_WIDTH-1:0];",
            "assign simfull_awlen = 0;",
            "assign simfull_awsize = 3'h2;",
            "assign simfull_awburst = 2'b01;",
            "assign simfull_awlock = 1'b0;",
            "assign simfull_awcache = 4'h3;",
            "assign simfull_awqos = 0;",
            "assign simfull_wdata = {(BUS_WIDTH/32){simsub_wdata}}; generate if (BUS_WIDTH == 32) begin : GEN_SIMFULL",
            "assign simfull_wstrb = simsub_wstrb; end else begin : GEN_SIMWIDE",
            "assign simfull_wstrb = { {((BUS_WIDTH-32)/8){1'b0}}, simsub_wstrb } << (simfull_awaddr[$clog2(BUS_WIDTH/8)-1:2]*4); end endgenerate",
            "assign simfull_wlast = 1;",
            "assign simfull_arid = 0;",
            "assign simfull_araddr = simwide_araddr[ADDRESS_WIDTH-1:0];",
            "assign simfull_arlen = 0;",
            "assign simfull_arsize = 3'h2;",
            "assign simfull_arburst = 2'b01;",
            "assign simfull_arlock = 1'b0;",
            "assign simfull_arcache = 4'h3;",
            "assign simfull_arqos = 0; generate if (BUS_WIDTH == 32) begin : NO_RETURN_DATA_SHIFT",
            "assign simfull_arvalid = simsub_arvalid;",
            "assign simsub_arready = simfull_arready;",
            "assign simsub_rdata = simfull_rdata; end else begin : SHIFT_RETURN_DATA // {{{",
            "localparam LGFIFO = 5;",
            "wire rfif_full, rfif_empty;",
            "wire [$clog2(BUS_WIDTH/32)-1:0] rfif_shift;",
            "wire [LGFIFO:0] rfif_fill;",
            "wire [BUS_WIDTH-1:0] shifted_rdata; sfifo #( .LGFLEN(LGFIFO), .BW($clog2(BUS_WIDTH/32)) ) rdata_addr_fifo ( .i_clk(i_aclk), .i_reset(!i_aresetn), .i_wr(simfull_arvalid && simfull_arready), .i_data(simfull_araddr[$clog2(BUS_WIDTH/32)+1:2]), .o_full(rfif_full), .o_fill(rfif_fill), .i_rd(simfull_rvalid && simfull_rready), .o_data(rfif_shift), .o_empty(rfif_empty) );",
            "assign shifted_rdata = simfull_rdata >> (rfif_shift*32);",
            "assign simsub_rdata = shifted_rdata[31:0];",
            "assign simfull_arvalid = simsub_arvalid && !rfif_full;",
            "assign simsub_arready = !rfif_full && simfull_arready; // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_rfif;",
            "assign unused_rfif = &{ 1'b0, rfif_fill, rfif_empty, shifted_rdata[BUS_WIDTH-1:32] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} end endgenerate // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_sim;",
            "assign unused_sim = &{ 1'b0, simwide_awaddr[ADDRESS_WIDTH], simwide_araddr[ADDRESS_WIDTH], simfull_rlast, simfull_bid, simfull_rid, dbg_awaddr[AW:8], dbg_araddr[AW:8] }; // Verilator lint_on UNUSED // Verilator coverage_on `else // If we aren't using Verilator, then there's no external bus driver. // Cap off the debug port therefore. // assign dbg_awvalid= 1'b0;",
            "assign dbg_awaddr = 0;",
            "assign dbg_awprot = 0;",
            "assign dbg_wvalid= 1'b0;",
            "assign dbg_wdata = 0;",
            "assign dbg_wstrb = 0;",
            "assign dbg_bready = 1'b0;",
            "assign dbg_arvalid= 1'b0;",
            "assign dbg_araddr = 0;",
            "assign dbg_arprot = 0;",
            "assign dbg_rready = 1'b0; `endif // }}} //////////////////////////////////////////////////////////////////////// // // The CPU itself // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_ZIPAXIL) begin : GEN_ZIPAXIL // Local declarations // {{{",
            "wire cpuil_awvalid, cpuil_awready;",
            "wire [AW-1:0] cpuil_awaddr;",
            "wire [2:0] cpuil_awprot;",
            "wire cpuil_wvalid, cpuil_wready;",
            "wire [BUS_WIDTH-1:0] cpuil_wdata;",
            "wire [BUS_WIDTH/8-1:0] cpuil_wstrb;",
            "wire cpuil_bvalid, cpuil_bready;",
            "wire [1:0] cpuil_bresp;",
            "wire cpuil_arvalid, cpuil_arready;",
            "wire [AW-1:0] cpuil_araddr;",
            "wire [2:0] cpuil_arprot;",
            "wire cpuil_rvalid, cpuil_rready;",
            "wire [BUS_WIDTH-1:0] cpuil_rdata;",
            "wire [1:0] cpuil_rresp; // wire cpudl_awvalid, cpudl_awready;",
            "wire [AW-1:0] cpudl_awaddr;",
            "wire [2:0] cpudl_awprot;",
            "wire cpudl_wvalid, cpudl_wready;",
            "wire [BUS_WIDTH-1:0] cpudl_wdata;",
            "wire [BUS_WIDTH/8-1:0] cpudl_wstrb;",
            "wire cpudl_bvalid, cpudl_bready;",
            "wire [1:0] cpudl_bresp;",
            "wire cpudl_arvalid, cpudl_arready;",
            "wire [AW-1:0] cpudl_araddr;",
            "wire [2:0] cpudl_arprot;",
            "wire cpudl_rvalid, cpudl_rready;",
            "wire [BUS_WIDTH-1:0] cpudl_rdata;",
            "wire [1:0] cpudl_rresp; // }}} zipaxil #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH), .RESET_ADDRESS(RESET_ADDRESS[ADDRESS_WIDTH-1:0]), .OPT_PIPELINED(OPT_PIPELINED), .C_AXI_DATA_WIDTH(BUS_WIDTH), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_LGICACHE(OPT_LGICACHE), .OPT_LGDCACHE(OPT_LGDCACHE), .START_HALTED(1'b0), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .OPT_LOCK(OPT_LOCK), .OPT_CIS(OPT_CIS), .OPT_USERMODE(OPT_USERMODE), .OPT_DBGPORT(OPT_DBGPORT), .OPT_TRACE_PORT(OPT_TRACE_PORT), .OPT_PROFILER(OPT_PROFILER), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_SIM(OPT_SIM), .OPT_CLKGATE(OPT_CLKGATE), .RESET_DURATION(RESET_DURATION) // }}} ) u_cpu ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), .i_interrupt(pic_interrupt), .i_cpu_reset(!i_aresetn || watchdog_reset), // Debug control port // {{{ .S_DBG_AWVALID(dbg_awvalid), .S_DBG_AWREADY(dbg_awready), .S_DBG_AWADDR(dbg_awaddr[7:0]), .S_DBG_AWPROT(dbg_awprot), // .S_DBG_WVALID(dbg_wvalid), .S_DBG_WREADY(dbg_wready), .S_DBG_WDATA( dbg_wdata), .S_DBG_WSTRB( dbg_wstrb), // .S_DBG_BVALID(dbg_bvalid), .S_DBG_BREADY(dbg_bready), .S_DBG_BRESP( dbg_bresp), // .S_DBG_ARVALID(dbg_arvalid), .S_DBG_ARREADY(dbg_arready), .S_DBG_ARADDR(dbg_araddr[7:0]), .S_DBG_ARPROT(dbg_arprot), // .S_DBG_RVALID(dbg_rvalid), .S_DBG_RREADY(dbg_rready), .S_DBG_RDATA( dbg_rdata), .S_DBG_RRESP( dbg_rresp), // }}} // Master instruction bus // {{{ .M_INSN_AWVALID(cpuil_awvalid), .M_INSN_AWREADY(cpuil_awready), .M_INSN_AWADDR(cpuil_awaddr), .M_INSN_AWPROT(cpuil_awprot), // .M_INSN_WVALID(cpuil_wvalid), .M_INSN_WREADY(cpuil_wready), .M_INSN_WDATA( cpuil_wdata), .M_INSN_WSTRB( cpuil_wstrb), // .M_INSN_BVALID(cpuil_bvalid), .M_INSN_BREADY(cpuil_bready), .M_INSN_BRESP( cpuil_bresp), // .M_INSN_ARVALID(cpuil_arvalid), .M_INSN_ARREADY(cpuil_arready), .M_INSN_ARADDR( cpuil_araddr), .M_INSN_ARPROT( cpuil_arprot), // .M_INSN_RVALID(cpuil_rvalid), .M_INSN_RREADY(cpuil_rready), .M_INSN_RDATA( cpuil_rdata), .M_INSN_RRESP( cpuil_rresp), // }}} // Master data bus // {{{ .M_DATA_AWVALID(cpudl_awvalid), .M_DATA_AWREADY(cpudl_awready), .M_DATA_AWADDR( cpudl_awaddr), .M_DATA_AWPROT( cpudl_awprot), // .M_DATA_WVALID(cpudl_wvalid), .M_DATA_WREADY(cpudl_wready), .M_DATA_WDATA( cpudl_wdata), .M_DATA_WSTRB( cpudl_wstrb), // .M_DATA_BVALID(cpudl_bvalid), .M_DATA_BREADY(cpudl_bready), .M_DATA_BRESP( cpudl_bresp), // .M_DATA_ARVALID(cpudl_arvalid), .M_DATA_ARREADY(cpudl_arready), .M_DATA_ARADDR( cpudl_araddr), .M_DATA_ARPROT( cpudl_arprot), // .M_DATA_RVALID(cpudl_rvalid), .M_DATA_RREADY(cpudl_rready), .M_DATA_RDATA( cpudl_rdata), .M_DATA_RRESP( cpudl_rresp), // }}} .o_cpu_debug(cpu_trace), // Accounting",
            "output s // {{{ .o_cmd_reset(cpu_reset[0]), .o_halted( cpu_halted[0]), .o_gie( cpu_gie[0]), .o_op_stall( cpu_op_stall[0]), .o_pf_stall( cpu_pf_stall[0]), .o_i_count( cpu_i_count[0]), // }}} // (Optional) Profiler // {{{ .o_prof_stb( o_prof_stb), .o_prof_addr( o_prof_addr), .o_prof_ticks(o_prof_ticks) // }}} // }}} ); axilite2axi #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_ADDR_WIDTH(AW), .C_AXI_DATA_WIDTH(BUS_WIDTH) // }}} ) u_iaxi ( .ACLK(i_aclk), .ARESETN(i_aresetn), // Slave interface, from CPU // {{{ .S_AXI_AWVALID(cpuil_awvalid), .S_AXI_AWREADY(cpuil_awready), .S_AXI_AWADDR( cpuil_awaddr), .S_AXI_AWPROT( cpuil_awprot), .S_AXI_WVALID(cpuil_wvalid), .S_AXI_WREADY(cpuil_wready), .S_AXI_WDATA( cpuil_wdata), .S_AXI_WSTRB( cpuil_wstrb), .S_AXI_BVALID(cpuil_bvalid), .S_AXI_BREADY(cpuil_bready), .S_AXI_BRESP( cpuil_bresp), .S_AXI_ARVALID(cpuil_arvalid), .S_AXI_ARREADY(cpuil_arready), .S_AXI_ARADDR( cpuil_araddr), .S_AXI_ARPROT( cpuil_arprot), .S_AXI_RVALID(cpuil_rvalid), .S_AXI_RREADY(cpuil_rready), .S_AXI_RDATA( cpuil_rdata), .S_AXI_RRESP( cpuil_rresp), // }}} // Master interface, to the bus // {{{ .M_AXI_AWVALID(cpui_awvalid[0]), .M_AXI_AWREADY(cpui_awready[0]), .M_AXI_AWID( cpui_awid[IW-1:0]), .M_AXI_AWADDR( cpui_awaddr[AW-1:0]), .M_AXI_AWLEN( cpui_awlen[7:0]), .M_AXI_AWSIZE( cpui_awsize[2:0]), .M_AXI_AWBURST(cpui_awburst[1:0]), .M_AXI_AWLOCK( cpui_awlock[0]), .M_AXI_AWCACHE(cpui_awcache[3:0]), .M_AXI_AWPROT( cpui_awprot[2:0]), .M_AXI_AWQOS( cpui_awqos[3:0]), .M_AXI_WVALID(cpui_wvalid[0]), .M_AXI_WREADY(cpui_wready[0]), .M_AXI_WDATA( cpui_wdata[BUS_WIDTH-1:0]), .M_AXI_WSTRB( cpui_wstrb[BUS_WIDTH/8-1:0]), .M_AXI_WLAST( cpui_wlast[0]), .M_AXI_BVALID(cpui_bvalid[0]), .M_AXI_BREADY(cpui_bready[0]), .M_AXI_BID( cpui_bid[IW-1:0]), .M_AXI_BRESP( cpui_bresp[1:0]), .M_AXI_ARVALID(cpui_arvalid[0]), .M_AXI_ARREADY(cpui_arready[0]), .M_AXI_ARID( cpui_arid[IW-1:0]), .M_AXI_ARADDR( cpui_araddr[AW-1:0]), .M_AXI_ARLEN( cpui_arlen[7:0]), .M_AXI_ARSIZE( cpui_arsize[2:0]), .M_AXI_ARBURST(cpui_arburst[1:0]), .M_AXI_ARLOCK( cpui_arlock[0]), .M_AXI_ARCACHE(cpui_arcache[3:0]), .M_AXI_ARPROT( cpui_arprot[2:0]), .M_AXI_ARQOS( cpui_arqos[3:0]), .M_AXI_RVALID(cpui_rvalid[0]), .M_AXI_RREADY(cpui_rready[0]), .M_AXI_RID( cpui_rid[IW-1:0]), .M_AXI_RDATA( cpui_rdata[BUS_WIDTH-1:0]), .M_AXI_RLAST( cpui_rlast[0]), .M_AXI_RRESP( cpui_rresp[1:0]) // }}} ); axilite2axi #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_ADDR_WIDTH(AW), .C_AXI_DATA_WIDTH(BUS_WIDTH) // }}} ) u_daxi ( .ACLK(i_aclk), .ARESETN(i_aresetn), // Slave interface, from CPU // {{{ .S_AXI_AWVALID(cpudl_awvalid), .S_AXI_AWREADY(cpudl_awready), .S_AXI_AWADDR( cpudl_awaddr), .S_AXI_AWPROT( cpudl_awprot), .S_AXI_WVALID(cpudl_wvalid), .S_AXI_WREADY(cpudl_wready), .S_AXI_WDATA( cpudl_wdata), .S_AXI_WSTRB( cpudl_wstrb), .S_AXI_BVALID(cpudl_bvalid), .S_AXI_BREADY(cpudl_bready), .S_AXI_BRESP( cpudl_bresp), .S_AXI_ARVALID(cpudl_arvalid), .S_AXI_ARREADY(cpudl_arready), .S_AXI_ARADDR( cpudl_araddr), .S_AXI_ARPROT( cpudl_arprot), .S_AXI_RVALID(cpudl_rvalid), .S_AXI_RREADY(cpudl_rready), .S_AXI_RDATA( cpudl_rdata), .S_AXI_RRESP( cpudl_rresp), // }}} // Master interface, to the bus // {{{ .M_AXI_AWVALID(cpud_awvalid[0]), .M_AXI_AWREADY(cpud_awready[0]), .M_AXI_AWID( cpud_awid[IW-1:0]), .M_AXI_AWADDR( cpud_awaddr[AW-1:0]), .M_AXI_AWLEN( cpud_awlen[7:0]), .M_AXI_AWSIZE( cpud_awsize[2:0]), .M_AXI_AWBURST(cpud_awburst[1:0]), .M_AXI_AWLOCK( cpud_awlock[0]), .M_AXI_AWCACHE(cpud_awcache[3:0]), .M_AXI_AWPROT( cpud_awprot[2:0]), .M_AXI_AWQOS( cpud_awqos[3:0]), .M_AXI_WVALID(cpud_wvalid[0]), .M_AXI_WREADY(cpud_wready[0]), .M_AXI_WDATA( cpud_wdata[BUS_WIDTH-1:0]), .M_AXI_WSTRB( cpud_wstrb[BUS_WIDTH/8-1:0]), .M_AXI_WLAST( cpud_wlast[0]), .M_AXI_BVALID(cpud_bvalid[0]), .M_AXI_BREADY(cpud_bready[0]), .M_AXI_BID( cpud_bid[IW-1:0]), .M_AXI_BRESP( cpud_bresp[1:0]), .M_AXI_ARVALID(cpud_arvalid[0]), .M_AXI_ARREADY(cpud_arready[0]), .M_AXI_ARID( cpud_arid[IW-1:0]), .M_AXI_ARADDR( cpud_araddr[AW-1:0]), .M_AXI_ARLEN( cpud_arlen[7:0]), .M_AXI_ARSIZE( cpud_arsize[2:0]), .M_AXI_ARBURST(cpud_arburst[1:0]), .M_AXI_ARLOCK( cpud_arlock[0]), .M_AXI_ARCACHE(cpud_arcache[3:0]), .M_AXI_ARPROT( cpud_arprot[2:0]), .M_AXI_ARQOS( cpud_arqos[3:0]), .M_AXI_RVALID(cpud_rvalid[0]), .M_AXI_RREADY(cpud_rready[0]), .M_AXI_RID( cpud_rid[IW-1:0]), .M_AXI_RDATA( cpud_rdata[BUS_WIDTH-1:0]), .M_AXI_RLAST( cpud_rlast[0]), .M_AXI_RRESP( cpud_rresp[1:0]) // }}} ); end else begin : GEN_ZIPAXI zipaxi #( // {{{ .RESET_ADDRESS(RESET_ADDRESS[ADDRESS_WIDTH-1:0]), .ADDRESS_WIDTH(ADDRESS_WIDTH), .C_AXI_ID_WIDTH(IW), .C_AXI_DATA_WIDTH(BUS_WIDTH), .OPT_PIPELINED(OPT_PIPELINED), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_LGICACHE(OPT_LGICACHE), .OPT_LGDCACHE(OPT_LGDCACHE), .START_HALTED(1'b0), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .OPT_LOCK(OPT_LOCK), .OPT_CIS(OPT_CIS), .OPT_WRAP(OPT_WRAP), .OPT_USERMODE(OPT_USERMODE), .OPT_DBGPORT(OPT_DBGPORT), .OPT_TRACE_PORT(OPT_TRACE_PORT), .OPT_PROFILER(OPT_PROFILER), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_SIM(OPT_SIM), .OPT_CLKGATE(OPT_CLKGATE), .RESET_DURATION(RESET_DURATION) // }}} ) u_cpu ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), .i_interrupt(pic_interrupt), .i_cpu_reset(!i_aresetn || watchdog_reset), // Debug control port // {{{ .S_DBG_AWVALID(dbg_awvalid), .S_DBG_AWREADY(dbg_awready), .S_DBG_AWADDR(dbg_awaddr[7:0]), .S_DBG_AWPROT(dbg_awprot), // .S_DBG_WVALID(dbg_wvalid), .S_DBG_WREADY(dbg_wready), .S_DBG_WDATA( dbg_wdata), .S_DBG_WSTRB( dbg_wstrb), // .S_DBG_BVALID(dbg_bvalid), .S_DBG_BREADY(dbg_bready), .S_DBG_BRESP( dbg_bresp), // .S_DBG_ARVALID(dbg_arvalid), .S_DBG_ARREADY(dbg_arready), .S_DBG_ARADDR(dbg_araddr[7:0]), .S_DBG_ARPROT(dbg_arprot), // .S_DBG_RVALID(dbg_rvalid), .S_DBG_RREADY(dbg_rready), .S_DBG_RDATA( dbg_rdata), .S_DBG_RRESP( dbg_rresp), // }}} // Master instruction bus // {{{ .M_INSN_AWVALID(cpui_awvalid[0]), .M_INSN_AWREADY(cpui_awready[0]), .M_INSN_AWID( cpui_awid[ 0 +: IW]), .M_INSN_AWADDR( cpui_awaddr[ 0 +: AW]), .M_INSN_AWLEN( cpui_awlen[ 0 +: 8]), .M_INSN_AWSIZE( cpui_awsize[ 0 +: 3]), .M_INSN_AWBURST(cpui_awburst[0 +: 2]), .M_INSN_AWLOCK( cpui_awlock[ 0]), .M_INSN_AWCACHE(cpui_awcache[0 +: 4]), .M_INSN_AWPROT( cpui_awprot[ 0 +: 3]), .M_INSN_AWQOS( cpui_awqos[ 0 +: 4]), // .M_INSN_WVALID(cpui_wvalid[0]), .M_INSN_WREADY(cpui_wready[0]), .M_INSN_WDATA( cpui_wdata[0 +: BUS_WIDTH]), .M_INSN_WSTRB( cpui_wstrb[0 +: BUS_WIDTH/8]), .M_INSN_WLAST( cpui_wlast[0]), // .M_INSN_BVALID(cpui_bvalid[0]), .M_INSN_BREADY(cpui_bready[0]), .M_INSN_BID( cpui_bid[ 0*IW +: IW]), .M_INSN_BRESP( cpui_bresp[0*2 +: 2]), // .M_INSN_ARVALID(cpui_arvalid[0]), .M_INSN_ARREADY(cpui_arready[0]), .M_INSN_ARID( cpui_arid[ 0*IW +: IW]), .M_INSN_ARADDR( cpui_araddr[ 0*AW +: AW]), .M_INSN_ARLEN( cpui_arlen[ 0 *8 +: 8]), .M_INSN_ARSIZE( cpui_arsize[ 0 *3 +: 3]), .M_INSN_ARBURST(cpui_arburst[0 *2 +: 2]), .M_INSN_ARLOCK( cpui_arlock[ 0]), .M_INSN_ARCACHE(cpui_arcache[0 *4 +: 4]), .M_INSN_ARPROT( cpui_arprot[ 0 *3 +: 3]), .M_INSN_ARQOS( cpui_arqos[ 0 *4 +: 4]), // .M_INSN_RVALID(cpui_rvalid[0]), .M_INSN_RREADY(cpui_rready[0]), .M_INSN_RID( cpui_rid[0*IW +: IW]), .M_INSN_RDATA( cpui_rdata[0*BUS_WIDTH +: BUS_WIDTH]), .M_INSN_RLAST( cpui_rlast[0]), .M_INSN_RRESP( cpui_rresp[0 *2 +: 2]), // }}} // Master data bus // {{{ .M_DATA_AWVALID(cpud_awvalid[0]), .M_DATA_AWREADY(cpud_awready[0]), .M_DATA_AWID( cpud_awid[0*IW +: IW]), .M_DATA_AWADDR( cpud_awaddr[0*AW +: AW]), .M_DATA_AWLEN( cpud_awlen[0*8 +: 8]), .M_DATA_AWSIZE( cpud_awsize[0*3 +: 3]), .M_DATA_AWBURST(cpud_awburst[0*2 +: 2]), .M_DATA_AWLOCK( cpud_awlock[0]), .M_DATA_AWCACHE(cpud_awcache[0*4 +: 4]), .M_DATA_AWPROT( cpud_awprot[0*3 +: 3]), .M_DATA_AWQOS( cpud_awqos[0*4 +: 4]), // .M_DATA_WVALID(cpud_wvalid[0]), .M_DATA_WREADY(cpud_wready[0]), .M_DATA_WDATA( cpud_wdata[0*BUS_WIDTH +: BUS_WIDTH]), .M_DATA_WSTRB( cpud_wstrb[0*BUS_WIDTH/8 +: BUS_WIDTH/8]), .M_DATA_WLAST( cpud_wlast[0]), // .M_DATA_BVALID(cpud_bvalid[0]), .M_DATA_BREADY(cpud_bready[0]), .M_DATA_BID( cpud_bid[0*IW +: IW]), .M_DATA_BRESP( cpud_bresp[0*2 +: 2]), // .M_DATA_ARVALID(cpud_arvalid[0]), .M_DATA_ARREADY(cpud_arready[0]), .M_DATA_ARID( cpud_arid[0*IW +: IW]), .M_DATA_ARADDR( cpud_araddr[0*AW +: AW]), .M_DATA_ARLEN( cpud_arlen[0*8 +: 8]), .M_DATA_ARSIZE( cpud_arsize[0*3 +: 3]), .M_DATA_ARBURST(cpud_arburst[0*2 +: 2]), .M_DATA_ARLOCK( cpud_arlock[0]), .M_DATA_ARCACHE(cpud_arcache[0*4 +: 4]), .M_DATA_ARPROT( cpud_arprot[0*3 +: 3]), .M_DATA_ARQOS( cpud_arqos[0*4 +: 4]), // .M_DATA_RVALID(cpud_rvalid[0]), .M_DATA_RREADY(cpud_rready[0]), .M_DATA_RID( cpud_rid[0*IW +: IW]), .M_DATA_RDATA( cpud_rdata[0*BUS_WIDTH +: BUS_WIDTH]), .M_DATA_RLAST( cpud_rlast[0]), .M_DATA_RRESP( cpud_rresp[0*2 +: 2]), // }}} .o_cpu_debug(cpu_trace), // Accounting",
            "output s // {{{ .o_cmd_reset(cpu_reset[0]), .o_halted( cpu_halted[0]), .o_gie( cpu_gie[0]), .o_op_stall( cpu_op_stall[0]), .o_pf_stall( cpu_pf_stall[0]), .o_i_count( cpu_i_count[0]), // }}} // (Optional) Profiler // {{{ .o_prof_stb( o_prof_stb), .o_prof_addr( o_prof_addr), .o_prof_ticks(o_prof_ticks) // }}} // }}} ); end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Extra CPU's, if running in multiprocessor mode (OPT_SMP > 1) // {{{ //////////////////////////////////////////////////////////////////////// // // // Nothing at the first SMP control address // {{{ axiempty #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_ADDR_WIDTH(AW), .C_AXI_DATA_WIDTH(BUS_WIDTH) // }}} ) u_nosmp ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), // .S_AXI_AWVALID(smpfull_awvalid[0]), .S_AXI_AWREADY(smpfull_awready[0]), .S_AXI_AWID( smpfull_awid[IW-1:0]), // .S_AXI_AWADDR( smpfull_awaddr), // .S_AXI_AWLEN( smpfull_awlen), // .S_AXI_AWSIZE( smpfull_awsize), // .S_AXI_AWBURST(smpfull_awburst), // .S_AXI_AWLOCK( smpfull_awlock), // .S_AXI_AWCACHE(smpfull_awcache), // .S_AXI_AWPROT( smpfull_awprot), // .S_AXI_AWQOS( smpfull_awqos), // .S_AXI_WVALID(smpfull_wvalid[0]), .S_AXI_WREADY(smpfull_wready[0]), // .S_AXI_WDATA( smpfull_wdata), // .S_AXI_WSTRB( smpfull_wstrb), .S_AXI_WLAST( smpfull_wlast[0]), // .S_AXI_BVALID(smpfull_bvalid[0]), .S_AXI_BREADY(smpfull_bready[0]), .S_AXI_BID( smpfull_bid[IW-1:0]), .S_AXI_BRESP( smpfull_bresp[1:0]), // .S_AXI_ARVALID(smpfull_arvalid[0]), .S_AXI_ARREADY(smpfull_arready[0]), .S_AXI_ARID( smpfull_arid[IW-1:0]), // .S_AXI_ARADDR( smpfull_araddr), .S_AXI_ARLEN( smpfull_arlen[7:0]), // .S_AXI_ARSIZE( smpfull_arsize), // .S_AXI_ARBURST(smpfull_arburst), // .S_AXI_ARLOCK( smpfull_arlock), // .S_AXI_ARCACHE(smpfull_arcache), // .S_AXI_ARPROT( smpfull_arprot), // .S_AXI_ARQOS( smpfull_arqos), // .S_AXI_RVALID(smpfull_rvalid[0]), .S_AXI_RREADY(smpfull_rready[0]), .S_AXI_RID( smpfull_rid[IW-1:0]), .S_AXI_RDATA( smpfull_rdata[BUS_WIDTH-1:0]), .S_AXI_RRESP( smpfull_rresp[1:0]), .S_AXI_RLAST( smpfull_rlast[0]) // }}} ); // Keep Verilator happy for this set // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_base_smp;",
            "assign unused_base_smp = &{ 1'b0, smpfull_awaddr[AW-1:0], smpfull_awlen[7:0], smpfull_awsize[2:0], smpfull_awburst[1:0], smpfull_awlock[0], smpfull_awcache[3:0], smpfull_awprot[2:0], smpfull_awqos[3:0], smpfull_wdata[BUS_WIDTH-1:0], smpfull_wstrb[BUS_WIDTH/8-1:0], smpfull_araddr[AW-1:0], smpfull_arsize[2:0], smpfull_arburst[1:0], smpfull_arlock[0], smpfull_arcache[3:0], smpfull_arprot[2:0], smpfull_arqos[3:0] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} // }}} generate for(gk=1; gk<OPT_SMP; gk=gk+1) begin : GEN_SMPCPU // Local declarations // {{{",
            "wire [31:0] smp_trace;",
            "wire smp_prof_stb;",
            "wire [ADDRESS_WIDTH-1:0] smp_prof_addr;",
            "wire [31:0] smp_prof_ticks;",
            "wire smp_awvalid, smp_awready;",
            "wire [8-1:0] smp_awaddr;",
            "wire [3-1:0] smp_awprot;",
            "wire smp_wvalid, smp_wready;",
            "wire [32-1:0] smp_wdata;",
            "wire [4-1:0] smp_wstrb;",
            "wire smp_bvalid, smp_bready;",
            "wire [2-1:0] smp_bresp;",
            "wire smp_arvalid, smp_arready;",
            "wire [8-1:0] smp_araddr;",
            "wire [3-1:0] smp_arprot;",
            "wire smp_rvalid, smp_rready;",
            "wire [32-1:0] smp_rdata;",
            "wire [2-1:0] smp_rresp; // }}} axi2axilsub #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_ADDR_WIDTH(8), .C_S_AXI_DATA_WIDTH(BUS_WIDTH), .C_M_AXI_DATA_WIDTH(32), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_WRITES(1), .OPT_READS(1) // }}} ) u_smpdown ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), // The \"Wide\" slave connection // {{{ .S_AXI_AWVALID(smpfull_awvalid[ gk]), .S_AXI_AWREADY(smpfull_awready[ gk]), .S_AXI_AWID( smpfull_awid[ gk*IW +: IW]), .S_AXI_AWADDR( smpfull_awaddr[ gk*AW +: 8]), .S_AXI_AWLEN( smpfull_awlen[ gk*8 +: 8]), .S_AXI_AWSIZE( smpfull_awsize[ gk*3 +: 3]), .S_AXI_AWBURST(smpfull_awburst[ gk*2 +: 2]), .S_AXI_AWLOCK( smpfull_awlock[ gk]), .S_AXI_AWCACHE(smpfull_awcache[ gk*4 +: 4]), .S_AXI_AWPROT( smpfull_awprot[ gk*3 +: 3]), .S_AXI_AWQOS( smpfull_awqos[ gk*4 +: 4]), .S_AXI_WVALID(smpfull_wvalid[gk]), .S_AXI_WREADY(smpfull_wready[gk]), .S_AXI_WDATA( smpfull_wdata[ gk*BUS_WIDTH +: BUS_WIDTH]), .S_AXI_WSTRB( smpfull_wstrb[ gk*BUS_WIDTH/8 +: BUS_WIDTH/8]), .S_AXI_WLAST( smpfull_wlast[ gk]), .S_AXI_BVALID(smpfull_bvalid[gk]), .S_AXI_BREADY(smpfull_bready[gk]), .S_AXI_BID( smpfull_bid[gk*IW +: IW]), .S_AXI_BRESP( smpfull_bresp[gk*2 +: 2]), .S_AXI_ARVALID(smpfull_arvalid[gk]), .S_AXI_ARREADY(smpfull_arready[gk]), .S_AXI_ARID( smpfull_arid[ gk*IW +: IW]), .S_AXI_ARADDR( smpfull_araddr[ gk*AW +: 8]), .S_AXI_ARLEN( smpfull_arlen[ gk*8 +: 8]), .S_AXI_ARSIZE( smpfull_arsize[ gk*3 +: 3]), .S_AXI_ARBURST(smpfull_arburst[gk*2 +: 2]), .S_AXI_ARLOCK( smpfull_arlock[ gk]), .S_AXI_ARCACHE(smpfull_arcache[gk*4 +: 4]), .S_AXI_ARPROT( smpfull_arprot[ gk*3 +: 3]), .S_AXI_ARQOS( smpfull_arqos[ gk*4 +: 4]), .S_AXI_RVALID(smpfull_rvalid[gk]), .S_AXI_RREADY(smpfull_rready[gk]), .S_AXI_RID( smpfull_rid[ gk*IW +: IW]), .S_AXI_RDATA( smpfull_rdata[gk*BUS_WIDTH +: BUS_WIDTH]), .S_AXI_RLAST( smpfull_rlast[gk]), .S_AXI_RRESP( smpfull_rresp[gk*2 +: 2]), // }}} // The downsized connection // {{{ .M_AXI_AWVALID(smp_awvalid), .M_AXI_AWREADY(smp_awready), .M_AXI_AWADDR( smp_awaddr), .M_AXI_AWPROT( smp_awprot), .M_AXI_WVALID(smp_wvalid), .M_AXI_WREADY(smp_wready), .M_AXI_WDATA( smp_wdata), .M_AXI_WSTRB( smp_wstrb), .M_AXI_BVALID(smp_bvalid), .M_AXI_BREADY(smp_bready), .M_AXI_BRESP( smp_bresp), .M_AXI_ARVALID(smp_arvalid), .M_AXI_ARREADY(smp_arready), .M_AXI_ARADDR( smp_araddr), .M_AXI_ARPROT( smp_arprot), .M_AXI_RVALID(smp_rvalid), .M_AXI_RREADY(smp_rready), .M_AXI_RDATA( smp_rdata), .M_AXI_RRESP( smp_rresp) // }}} // }}} ); if (OPT_ZIPAXIL) begin : GEN_ZIPAXIL // Local declarations // {{{",
            "wire cpuil_awvalid, cpuil_awready;",
            "wire [AW-1:0] cpuil_awaddr;",
            "wire [2:0] cpuil_awprot;",
            "wire cpuil_wvalid, cpuil_wready;",
            "wire [BUS_WIDTH-1:0] cpuil_wdata;",
            "wire [BUS_WIDTH/8-1:0] cpuil_wstrb;",
            "wire cpuil_bvalid, cpuil_bready;",
            "wire [1:0] cpuil_bresp;",
            "wire cpuil_arvalid, cpuil_arready;",
            "wire [AW-1:0] cpuil_araddr;",
            "wire [2:0] cpuil_arprot;",
            "wire cpuil_rvalid, cpuil_rready;",
            "wire [BUS_WIDTH-1:0] cpuil_rdata;",
            "wire [1:0] cpuil_rresp; // wire cpudl_awvalid, cpudl_awready;",
            "wire [AW-1:0] cpudl_awaddr;",
            "wire [2:0] cpudl_awprot;",
            "wire cpudl_wvalid, cpudl_wready;",
            "wire [BUS_WIDTH-1:0] cpudl_wdata;",
            "wire [BUS_WIDTH/8-1:0] cpudl_wstrb;",
            "wire cpudl_bvalid, cpudl_bready;",
            "wire [1:0] cpudl_bresp;",
            "wire cpudl_arvalid, cpudl_arready;",
            "wire [AW-1:0] cpudl_araddr;",
            "wire [2:0] cpudl_arprot;",
            "wire cpudl_rvalid, cpudl_rready;",
            "wire [BUS_WIDTH-1:0] cpudl_rdata;",
            "wire [1:0] cpudl_rresp; // }}} zipaxil #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH), .RESET_ADDRESS(RESET_ADDRESS[ADDRESS_WIDTH-1:0]), .OPT_PIPELINED(OPT_PIPELINED), .C_AXI_DATA_WIDTH(BUS_WIDTH), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_LGICACHE(OPT_LGICACHE), .OPT_LGDCACHE(OPT_LGDCACHE), .START_HALTED(1'b1), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .OPT_LOCK(OPT_LOCK), .OPT_CIS(OPT_CIS), .OPT_USERMODE(OPT_USERMODE), .OPT_DBGPORT(1'b1 || OPT_DBGPORT), .OPT_TRACE_PORT(OPT_TRACE_PORT), .OPT_PROFILER(OPT_PROFILER), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_SIM(OPT_SIM), .OPT_CLKGATE(OPT_CLKGATE), .RESET_DURATION(RESET_DURATION) // }}} ) u_cpu ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), .i_interrupt(pic_interrupt), .i_cpu_reset(!i_aresetn || watchdog_reset), // Debug control port // {{{ .S_DBG_AWVALID(smp_awvalid), .S_DBG_AWREADY(smp_awready), .S_DBG_AWADDR(smp_awaddr), .S_DBG_AWPROT(smp_awprot), // .S_DBG_WVALID(smp_wvalid), .S_DBG_WREADY(smp_wready), .S_DBG_WDATA( smp_wdata), .S_DBG_WSTRB( smp_wstrb), // .S_DBG_BVALID(smp_bvalid), .S_DBG_BREADY(smp_bready), .S_DBG_BRESP( smp_bresp), // .S_DBG_ARVALID(smp_arvalid), .S_DBG_ARREADY(smp_arready), .S_DBG_ARADDR(smp_araddr), .S_DBG_ARPROT(smp_arprot), // .S_DBG_RVALID(smp_rvalid), .S_DBG_RREADY(smp_rready), .S_DBG_RDATA( smp_rdata), .S_DBG_RRESP( smp_rresp), // }}} // Master instruction bus // {{{ .M_INSN_AWVALID(cpuil_awvalid), .M_INSN_AWREADY(cpuil_awready), .M_INSN_AWADDR(cpuil_awaddr), .M_INSN_AWPROT(cpuil_awprot), // .M_INSN_WVALID(cpuil_wvalid), .M_INSN_WREADY(cpuil_wready), .M_INSN_WDATA( cpuil_wdata), .M_INSN_WSTRB( cpuil_wstrb), // .M_INSN_BVALID(cpuil_bvalid), .M_INSN_BREADY(cpuil_bready), .M_INSN_BRESP( cpuil_bresp), // .M_INSN_ARVALID(cpuil_arvalid), .M_INSN_ARREADY(cpuil_arready), .M_INSN_ARADDR( cpuil_araddr), .M_INSN_ARPROT( cpuil_arprot), // .M_INSN_RVALID(cpuil_rvalid), .M_INSN_RREADY(cpuil_rready), .M_INSN_RDATA( cpuil_rdata), .M_INSN_RRESP( cpuil_rresp), // }}} // Master data bus // {{{ .M_DATA_AWVALID(cpudl_awvalid), .M_DATA_AWREADY(cpudl_awready), .M_DATA_AWADDR( cpudl_awaddr), .M_DATA_AWPROT( cpudl_awprot), // .M_DATA_WVALID(cpudl_wvalid), .M_DATA_WREADY(cpudl_wready), .M_DATA_WDATA( cpudl_wdata), .M_DATA_WSTRB( cpudl_wstrb), // .M_DATA_BVALID(cpudl_bvalid), .M_DATA_BREADY(cpudl_bready), .M_DATA_BRESP( cpudl_bresp), // .M_DATA_ARVALID(cpudl_arvalid), .M_DATA_ARREADY(cpudl_arready), .M_DATA_ARADDR( cpudl_araddr), .M_DATA_ARPROT( cpudl_arprot), // .M_DATA_RVALID(cpudl_rvalid), .M_DATA_RREADY(cpudl_rready), .M_DATA_RDATA( cpudl_rdata), .M_DATA_RRESP( cpudl_rresp), // }}} .o_cpu_debug(smp_trace), // Accounting",
            "output s // {{{ .o_cmd_reset(cpu_reset[gk]), .o_halted( cpu_halted[gk]), .o_gie( cpu_gie[gk]), .o_op_stall( cpu_op_stall[gk]), .o_pf_stall( cpu_pf_stall[gk]), .o_i_count( cpu_i_count[gk]), // }}} // (Optional) Profiler // {{{ .o_prof_stb( smp_prof_stb), .o_prof_addr( smp_prof_addr), .o_prof_ticks(smp_prof_ticks) // }}} // }}} ); axilite2axi #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_ADDR_WIDTH(AW), .C_AXI_DATA_WIDTH(BUS_WIDTH) // }}} ) u_iaxi ( .ACLK(i_aclk), .ARESETN(i_aresetn), // Slave interface, from CPU // {{{ .S_AXI_AWVALID(cpuil_awvalid), .S_AXI_AWREADY(cpuil_awready), .S_AXI_AWADDR( cpuil_awaddr), .S_AXI_AWPROT( cpuil_awprot), .S_AXI_WVALID(cpuil_wvalid), .S_AXI_WREADY(cpuil_wready), .S_AXI_WDATA( cpuil_wdata), .S_AXI_WSTRB( cpuil_wstrb), .S_AXI_BVALID(cpuil_bvalid), .S_AXI_BREADY(cpuil_bready), .S_AXI_BRESP( cpuil_bresp), .S_AXI_ARVALID(cpuil_arvalid), .S_AXI_ARREADY(cpuil_arready), .S_AXI_ARADDR( cpuil_araddr), .S_AXI_ARPROT( cpuil_arprot), .S_AXI_RVALID(cpuil_rvalid), .S_AXI_RREADY(cpuil_rready), .S_AXI_RDATA( cpuil_rdata), .S_AXI_RRESP( cpuil_rresp), // }}} // Master interface, to the bus // {{{ .M_AXI_AWVALID(cpui_awvalid[gk]), .M_AXI_AWREADY(cpui_awready[gk]), .M_AXI_AWID( cpui_awid[ gk*IW +: IW]), .M_AXI_AWADDR( cpui_awaddr[ gk*AW +: AW]), .M_AXI_AWLEN( cpui_awlen[ gk*8 +: 8]), .M_AXI_AWSIZE( cpui_awsize[ gk*3 +: 3]), .M_AXI_AWBURST(cpui_awburst[gk*2 +: 2]), .M_AXI_AWLOCK( cpui_awlock[ gk]), .M_AXI_AWCACHE(cpui_awcache[gk*4 +: 4]), .M_AXI_AWPROT( cpui_awprot[ gk*3 +: 3]), .M_AXI_AWQOS( cpui_awqos[ gk*4 +: 4]), .M_AXI_WVALID(cpui_wvalid[gk]), .M_AXI_WREADY(cpui_wready[gk]), .M_AXI_WDATA( cpui_wdata[gk * BUS_WIDTH +: BUS_WIDTH]), .M_AXI_WSTRB( cpui_wstrb[gk * BUS_WIDTH/8 +: BUS_WIDTH/8]), .M_AXI_WLAST( cpui_wlast[gk]), .M_AXI_BVALID(cpui_bvalid[gk]), .M_AXI_BREADY(cpui_bready[gk]), .M_AXI_BID( cpui_bid [gk*IW +: IW]), .M_AXI_BRESP( cpui_bresp[gk*2 +: 2]), .M_AXI_ARVALID(cpui_arvalid[gk]), .M_AXI_ARREADY(cpui_arready[gk]), .M_AXI_ARID( cpui_arid[ gk*IW +: IW]), .M_AXI_ARADDR( cpui_araddr[ gk*AW +: AW]), .M_AXI_ARLEN( cpui_arlen[ gk*8 +: 8]), .M_AXI_ARSIZE( cpui_arsize[ gk*3 +: 3]), .M_AXI_ARBURST(cpui_arburst[gk*2 +: 2]), .M_AXI_ARLOCK( cpui_arlock[ gk]), .M_AXI_ARCACHE(cpui_arcache[gk*4 +: 4]), .M_AXI_ARPROT( cpui_arprot[ gk*3 +: 3]), .M_AXI_ARQOS( cpui_arqos[ gk*4 +: 4]), .M_AXI_RVALID(cpui_rvalid[gk]), .M_AXI_RREADY(cpui_rready[gk]), .M_AXI_RID( cpui_rid[gk * IW +: IW]), .M_AXI_RDATA( cpui_rdata[gk * BUS_WIDTH +: BUS_WIDTH]), .M_AXI_RLAST( cpui_rlast[gk]), .M_AXI_RRESP( cpui_rresp[gk*2 +: 2]) // }}} ); axilite2axi #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_ADDR_WIDTH(AW), .C_AXI_DATA_WIDTH(BUS_WIDTH) // }}} ) u_daxi ( .ACLK(i_aclk), .ARESETN(i_aresetn), // Slave interface, from CPU // {{{ .S_AXI_AWVALID(cpudl_awvalid), .S_AXI_AWREADY(cpudl_awready), .S_AXI_AWADDR( cpudl_awaddr), .S_AXI_AWPROT( cpudl_awprot), .S_AXI_WVALID(cpudl_wvalid), .S_AXI_WREADY(cpudl_wready), .S_AXI_WDATA( cpudl_wdata), .S_AXI_WSTRB( cpudl_wstrb), .S_AXI_BVALID(cpudl_bvalid), .S_AXI_BREADY(cpudl_bready), .S_AXI_BRESP( cpudl_bresp), .S_AXI_ARVALID(cpudl_arvalid), .S_AXI_ARREADY(cpudl_arready), .S_AXI_ARADDR( cpudl_araddr), .S_AXI_ARPROT( cpudl_arprot), .S_AXI_RVALID(cpudl_rvalid), .S_AXI_RREADY(cpudl_rready), .S_AXI_RDATA( cpudl_rdata), .S_AXI_RRESP( cpudl_rresp), // }}} // Master interface, to the bus // {{{ .M_AXI_AWVALID(cpud_awvalid[gk]), .M_AXI_AWREADY(cpud_awready[gk]), .M_AXI_AWID( cpud_awid[ gk*IW +: IW]), .M_AXI_AWADDR( cpud_awaddr[ gk*AW +: AW]), .M_AXI_AWLEN( cpud_awlen[ gk*8 +: 8]), .M_AXI_AWSIZE( cpud_awsize[ gk*3 +: 3]), .M_AXI_AWBURST(cpud_awburst[gk*2 +: 2]), .M_AXI_AWLOCK( cpud_awlock[ gk]), .M_AXI_AWCACHE(cpud_awcache[gk*4 +: 4]), .M_AXI_AWPROT( cpud_awprot[ gk*3 +: 3]), .M_AXI_AWQOS( cpud_awqos[ gk*4 +: 4]), .M_AXI_WVALID(cpud_wvalid[gk]), .M_AXI_WREADY(cpud_wready[gk]), .M_AXI_WDATA( cpud_wdata[gk * BUS_WIDTH +: BUS_WIDTH]), .M_AXI_WSTRB( cpud_wstrb[gk * BUS_WIDTH/8 +: BUS_WIDTH/8]), .M_AXI_WLAST( cpud_wlast[gk]), .M_AXI_BVALID(cpud_bvalid[gk]), .M_AXI_BREADY(cpud_bready[gk]), .M_AXI_BID( cpud_bid[ gk*IW +: IW]), .M_AXI_BRESP( cpud_bresp[gk*2 +: 2]), .M_AXI_ARVALID(cpud_arvalid[gk]), .M_AXI_ARREADY(cpud_arready[gk]), .M_AXI_ARID( cpud_arid[ gk*IW +: IW]), .M_AXI_ARADDR( cpud_araddr[ gk*AW +: AW]), .M_AXI_ARLEN( cpud_arlen[ gk*8 +: 8]), .M_AXI_ARSIZE( cpud_arsize[ gk*3 +: 3]), .M_AXI_ARBURST(cpud_arburst[gk*2 +: 2]), .M_AXI_ARLOCK( cpud_arlock[ gk]), .M_AXI_ARCACHE(cpud_arcache[gk*4 +: 4]), .M_AXI_ARPROT( cpud_arprot[ gk*3 +: 3]), .M_AXI_ARQOS( cpud_arqos[ gk*4 +: 4]), .M_AXI_RVALID(cpud_rvalid[gk]), .M_AXI_RREADY(cpud_rready[gk]), .M_AXI_RID( cpud_rid[gk*IW +: IW]), .M_AXI_RDATA( cpud_rdata[gk * BUS_WIDTH +: BUS_WIDTH]), .M_AXI_RLAST( cpud_rlast[gk]), .M_AXI_RRESP( cpud_rresp[gk*2 +: 2]) // }}} ); end else begin : GEN_ZIPAXI zipaxi #( // {{{ .RESET_ADDRESS(RESET_ADDRESS[ADDRESS_WIDTH-1:0]), .ADDRESS_WIDTH(ADDRESS_WIDTH), .C_AXI_ID_WIDTH(IW), .C_AXI_DATA_WIDTH(BUS_WIDTH), .OPT_PIPELINED(OPT_PIPELINED), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_LGICACHE(OPT_LGICACHE), .OPT_LGDCACHE(OPT_LGDCACHE), .START_HALTED(1'b1), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .OPT_LOCK(OPT_LOCK), .OPT_CIS(OPT_CIS), .OPT_USERMODE(OPT_USERMODE), .OPT_DBGPORT(1'b1 || OPT_DBGPORT), .OPT_TRACE_PORT(OPT_TRACE_PORT), .OPT_PROFILER(OPT_PROFILER), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_SIM(OPT_SIM), .OPT_CLKGATE(OPT_CLKGATE), .RESET_DURATION(RESET_DURATION) // }}} ) u_cpu ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), .i_interrupt(pic_interrupt), .i_cpu_reset(!i_aresetn || watchdog_reset), // Debug control port // {{{ .S_DBG_AWVALID(smp_awvalid), .S_DBG_AWREADY(smp_awready), .S_DBG_AWADDR(smp_awaddr), .S_DBG_AWPROT(smp_awprot), // .S_DBG_WVALID(smp_wvalid), .S_DBG_WREADY(smp_wready), .S_DBG_WDATA( smp_wdata), .S_DBG_WSTRB( smp_wstrb), // .S_DBG_BVALID(smp_bvalid), .S_DBG_BREADY(smp_bready), .S_DBG_BRESP( smp_bresp), // .S_DBG_ARVALID(smp_arvalid), .S_DBG_ARREADY(smp_arready), .S_DBG_ARADDR(smp_araddr), .S_DBG_ARPROT(smp_arprot), // .S_DBG_RVALID(smp_rvalid), .S_DBG_RREADY(smp_rready), .S_DBG_RDATA( smp_rdata), .S_DBG_RRESP( smp_rresp), // }}} // Master instruction bus // {{{ .M_INSN_AWVALID(cpui_awvalid[gk]), .M_INSN_AWREADY(cpui_awready[gk]), .M_INSN_AWID( cpui_awid[ gk*IW +: IW]), .M_INSN_AWADDR( cpui_awaddr[ gk*AW +: AW]), .M_INSN_AWLEN( cpui_awlen[ gk*8 +: 8]), .M_INSN_AWSIZE( cpui_awsize[ gk*3 +: 3]), .M_INSN_AWBURST(cpui_awburst[gk*2 +: 2]), .M_INSN_AWLOCK( cpui_awlock[ gk]), .M_INSN_AWCACHE(cpui_awcache[gk*4 +: 4]), .M_INSN_AWPROT( cpui_awprot[ gk*3 +: 3]), .M_INSN_AWQOS( cpui_awqos[ gk*4 +: 4]), // .M_INSN_WVALID(cpui_wvalid[gk]), .M_INSN_WREADY(cpui_wready[gk]), .M_INSN_WDATA( cpui_wdata[gk*BUS_WIDTH +: BUS_WIDTH]), .M_INSN_WSTRB( cpui_wstrb[gk*BUS_WIDTH/8 +: BUS_WIDTH/8]), .M_INSN_WLAST( cpui_wlast[gk]), // .M_INSN_BVALID(cpui_bvalid[gk]), .M_INSN_BREADY(cpui_bready[gk]), .M_INSN_BID( cpui_bid[gk*IW +: IW]), .M_INSN_BRESP( cpui_bresp[gk*2 +: 2]), // .M_INSN_ARVALID(cpui_arvalid[gk]), .M_INSN_ARREADY(cpui_arready[gk]), .M_INSN_ARID( cpui_arid[ gk*IW +: IW]), .M_INSN_ARADDR( cpui_araddr[ gk*AW +: AW]), .M_INSN_ARLEN( cpui_arlen[ gk*8 +: 8]), .M_INSN_ARSIZE( cpui_arsize[ gk*3 +: 3]), .M_INSN_ARBURST(cpui_arburst[gk*2 +: 2]), .M_INSN_ARLOCK( cpui_arlock[ gk]), .M_INSN_ARCACHE(cpui_arcache[gk*4 +: 4]), .M_INSN_ARPROT( cpui_arprot[ gk*3 +: 3]), .M_INSN_ARQOS( cpui_arqos[ gk*4 +: 4]), // .M_INSN_RVALID(cpui_rvalid[gk]), .M_INSN_RREADY(cpui_rready[gk]), .M_INSN_RID( cpui_rid[gk*IW +: IW]), .M_INSN_RDATA( cpui_rdata[gk*BUS_WIDTH +: BUS_WIDTH]), .M_INSN_RLAST( cpui_rlast[gk]), .M_INSN_RRESP( cpui_rresp[gk*2 +: 2]), // }}} // Master data bus // {{{ .M_DATA_AWVALID(cpud_awvalid[gk]), .M_DATA_AWREADY(cpud_awready[gk]), .M_DATA_AWID( cpud_awid[ gk*IW +: IW]), .M_DATA_AWADDR( cpud_awaddr[ gk*AW +: AW]), .M_DATA_AWLEN( cpud_awlen[ gk*8 +: 8]), .M_DATA_AWSIZE( cpud_awsize[ gk*3 +: 3]), .M_DATA_AWBURST(cpud_awburst[gk*2 +: 2]), .M_DATA_AWLOCK( cpud_awlock[ gk]), .M_DATA_AWCACHE(cpud_awcache[gk*4 +: 4]), .M_DATA_AWPROT( cpud_awprot[ gk*3 +: 3]), .M_DATA_AWQOS( cpud_awqos[ gk*4 +: 4]), // .M_DATA_WVALID(cpud_wvalid[gk]), .M_DATA_WREADY(cpud_wready[gk]), .M_DATA_WDATA( cpud_wdata[gk*BUS_WIDTH +: BUS_WIDTH]), .M_DATA_WSTRB( cpud_wstrb[gk*BUS_WIDTH/8 +: BUS_WIDTH/8]), .M_DATA_WLAST( cpud_wlast[gk]), // .M_DATA_BVALID(cpud_bvalid[gk]), .M_DATA_BREADY(cpud_bready[gk]), .M_DATA_BID( cpud_bid[ gk*IW +: IW]), .M_DATA_BRESP( cpud_bresp[ gk*2 +: 2]), // .M_DATA_ARVALID(cpud_arvalid[gk]), .M_DATA_ARREADY(cpud_arready[gk]), .M_DATA_ARID( cpud_arid[ gk*IW +: IW]), .M_DATA_ARADDR( cpud_araddr[ gk*AW +: AW]), .M_DATA_ARLEN( cpud_arlen[ gk*8 +: 8]), .M_DATA_ARSIZE( cpud_arsize[ gk*3 +: 3]), .M_DATA_ARBURST(cpud_arburst[gk*2 +: 2]), .M_DATA_ARLOCK( cpud_arlock[ gk]), .M_DATA_ARCACHE(cpud_arcache[gk*4 +: 4]), .M_DATA_ARPROT( cpud_arprot[ gk*3 +: 3]), .M_DATA_ARQOS( cpud_arqos[ gk*4 +: 4]), // .M_DATA_RVALID(cpud_rvalid[gk]), .M_DATA_RREADY(cpud_rready[gk]), .M_DATA_RID( cpud_rid[gk*IW +: IW]), .M_DATA_RDATA( cpud_rdata[gk*BUS_WIDTH +: BUS_WIDTH]), .M_DATA_RLAST( cpud_rlast[gk]), .M_DATA_RRESP( cpud_rresp[gk*2 +: 2]), // }}} .o_cpu_debug(smp_trace), // Accounting",
            "output s // {{{ .o_cmd_reset(cpu_reset[gk]), .o_halted( cpu_halted[gk]), .o_gie( cpu_gie[gk]), .o_op_stall( cpu_op_stall[gk]), .o_pf_stall( cpu_pf_stall[gk]), .o_i_count( cpu_i_count[gk]), // }}} // (Optional) Profiler // {{{ .o_prof_stb( smp_prof_stb), .o_prof_addr( smp_prof_addr), .o_prof_ticks(smp_prof_ticks) // }}} // }}} ); end // Keep Verilator happy with our unused ports // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_smp;",
            "assign unused_smp = &{ 1'b0, smp_prof_stb, smp_prof_addr, smpfull_awaddr[gk*AW+8 +: (AW-8)], smpfull_araddr[gk*AW+8 +: (AW-8)], smp_prof_ticks, smp_trace, cpu_reset[gk], cpu_gie[gk], cpu_op_stall[gk], cpu_pf_stall[gk], cpu_i_count[gk] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // The wide bus interconnect // {{{ //////////////////////////////////////////////////////////////////////// // // axixbar #( // {{{ `ifdef VERILATOR .NM(1+2*OPT_SMP), `else .NM(2*OPT_SMP), // ZipAXI(l) CPU is two masters each `endif .NS(4+OPT_SMP), .C_AXI_ID_WIDTH(IW), .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH), .C_AXI_DATA_WIDTH(BUS_WIDTH), .OPT_LOWPOWER(OPT_LOWPOWER), .SLAVE_ADDR({ AXILP_ADDR, SMP_ADDR, CONSOLE_ADDR, SCOPE_ADDR, MEMORY_ADDR }), .SLAVE_MASK({ { {(AW-24){1'b1}}, {(24){1'b0}} }, // AXI-Lite Periph Set SMP_MASK, // SMP { 4'b1111, {(AW-4){1'b0}} }, // Console { 4'b1111, {(AW-4){1'b0}} }, // Scope { 2'b11, {(AW-2){1'b0}} } }) // Memory // }}} ) u_main_crossbar ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), // Slave ports from the various bus masters // {{{ `ifdef VERILATOR // Three bus masters: the external SIM",
            "input , and the CPU .S_AXI_AWVALID({ simfull_awvalid, cpui_awvalid, cpud_awvalid }), .S_AXI_AWREADY({ simfull_awready, cpui_awready, cpud_awready }), .S_AXI_AWID({ simfull_awid, cpui_awid, cpud_awid }), .S_AXI_AWADDR({ simfull_awaddr, cpui_awaddr, cpud_awaddr }), .S_AXI_AWLEN({ simfull_awlen, cpui_awlen, cpud_awlen }), .S_AXI_AWSIZE({ simfull_awsize, cpui_awsize, cpud_awsize }), .S_AXI_AWBURST({ simfull_awburst, cpui_awburst, cpud_awburst }), .S_AXI_AWLOCK({ simfull_awlock, cpui_awlock, cpud_awlock }), .S_AXI_AWCACHE({ simfull_awcache, cpui_awcache, cpud_awcache }), .S_AXI_AWPROT({ simfull_awprot, cpui_awprot, cpud_awprot }), .S_AXI_AWQOS({ simfull_awqos, cpui_awqos, cpud_awqos }), .S_AXI_WVALID({ simfull_wvalid, cpui_wvalid, cpud_wvalid }), .S_AXI_WREADY({ simfull_wready, cpui_wready, cpud_wready }), .S_AXI_WDATA({ simfull_wdata, cpui_wdata, cpud_wdata }), .S_AXI_WSTRB({ simfull_wstrb, cpui_wstrb, cpud_wstrb }), .S_AXI_WLAST({ simfull_wlast, cpui_wlast, cpud_wlast }), .S_AXI_BVALID({ simfull_bvalid, cpui_bvalid, cpud_bvalid }), .S_AXI_BREADY({ simfull_bready, cpui_bready, cpud_bready }), .S_AXI_BID({ simfull_bid, cpui_bid, cpud_bid }), .S_AXI_BRESP({ simfull_bresp, cpui_bresp, cpud_bresp }), .S_AXI_ARVALID({ simfull_arvalid, cpui_arvalid, cpud_arvalid }), .S_AXI_ARREADY({ simfull_arready, cpui_arready, cpud_arready }), .S_AXI_ARID({ simfull_arid, cpui_arid, cpud_arid }), .S_AXI_ARADDR({ simfull_araddr, cpui_araddr, cpud_araddr }), .S_AXI_ARLEN({ simfull_arlen, cpui_arlen, cpud_arlen }), .S_AXI_ARSIZE({ simfull_arsize, cpui_arsize, cpud_arsize }), .S_AXI_ARBURST({ simfull_arburst, cpui_arburst, cpud_arburst }), .S_AXI_ARLOCK({ simfull_arlock, cpui_arlock, cpud_arlock }), .S_AXI_ARCACHE({ simfull_arcache, cpui_arcache, cpud_arcache }), .S_AXI_ARPROT({ simfull_arprot, cpui_arprot, cpud_arprot }), .S_AXI_ARQOS({ simfull_arqos, cpui_arqos, cpud_arqos }), .S_AXI_RVALID({ simfull_rvalid, cpui_rvalid, cpud_rvalid }), .S_AXI_RREADY({ simfull_rready, cpui_rready, cpud_rready }), .S_AXI_RID({ simfull_rid, cpui_rid, cpud_rid }), .S_AXI_RDATA({ simfull_rdata, cpui_rdata, cpud_rdata }), .S_AXI_RLAST({ simfull_rlast, cpui_rlast, cpud_rlast }), .S_AXI_RRESP({ simfull_rresp, cpui_rresp, cpud_rresp }), `else // With no external CPU",
            "input , there is no simulation port .S_AXI_AWVALID({ cpui_awvalid, cpud_awvalid }), .S_AXI_AWREADY({ cpui_awready, cpud_awready }), .S_AXI_AWID({ cpui_awid, cpud_awid }), .S_AXI_AWADDR({ cpui_awaddr, cpud_awaddr }), .S_AXI_AWLEN({ cpui_awlen, cpud_awlen }), .S_AXI_AWSIZE({ cpui_awsize, cpud_awsize }), .S_AXI_AWBURST({ cpui_awburst, cpud_awburst }), .S_AXI_AWLOCK({ cpui_awlock, cpud_awlock }), .S_AXI_AWCACHE({ cpui_awcache, cpud_awcache }), .S_AXI_AWPROT({ cpui_awprot, cpud_awprot }), .S_AXI_AWQOS({ cpui_awqos, cpud_awqos }), .S_AXI_WVALID({ cpui_wvalid, cpud_wvalid }), .S_AXI_WREADY({ cpui_wready, cpud_wready }), .S_AXI_WDATA({ cpui_wdata, cpud_wdata }), .S_AXI_WSTRB({ cpui_wstrb, cpud_wstrb }), .S_AXI_WLAST({ cpui_wlast, cpud_wlast }), .S_AXI_BVALID({ cpui_bvalid, cpud_bvalid }), .S_AXI_BREADY({ cpui_bready, cpud_bready }), .S_AXI_BID({ cpui_bid, cpud_bid }), .S_AXI_BRESP({ cpui_bresp, cpud_bresp }), .S_AXI_ARVALID({ cpui_arvalid, cpud_arvalid }), .S_AXI_ARREADY({ cpui_arready, cpud_arready }), .S_AXI_ARID({ cpui_arid, cpud_arid }), .S_AXI_ARADDR({ cpui_araddr, cpud_araddr }), .S_AXI_ARLEN({ cpui_arlen, cpud_arlen }), .S_AXI_ARSIZE({ cpui_arsize, cpud_arsize }), .S_AXI_ARBURST({ cpui_arburst, cpud_arburst }), .S_AXI_ARLOCK({ cpui_arlock, cpud_arlock }), .S_AXI_ARCACHE({ cpui_arcache, cpud_arcache }), .S_AXI_ARPROT({ cpui_arprot, cpud_arprot }), .S_AXI_ARQOS({ cpui_arqos, cpud_arqos }), .S_AXI_RVALID({ cpui_rvalid, cpud_rvalid }), .S_AXI_RREADY({ cpui_rready, cpud_rready }), .S_AXI_RID({ cpui_rid, cpud_rid }), .S_AXI_RDATA({ cpui_rdata, cpud_rdata }), .S_AXI_RLAST({ cpui_rlast, cpud_rlast }), .S_AXI_RRESP({ cpui_rresp, cpud_rresp }), `endif // }}} // Master port ... to control the slaves w/in this design // {{{ .M_AXI_AWVALID({ axip_awvalid, smpfull_awvalid, con_awvalid, scope_awvalid, mem_awvalid }), .M_AXI_AWREADY({ axip_awready, smpfull_awready, con_awready, scope_awready, mem_awready }), .M_AXI_AWID({ axip_awid, smpfull_awid, con_awid, scope_awid, mem_awid }), .M_AXI_AWADDR({ axip_awaddr, smpfull_awaddr, con_awaddr, scope_awaddr, mem_awaddr }), .M_AXI_AWLEN({ axip_awlen, smpfull_awlen, con_awlen, scope_awlen, mem_awlen }), .M_AXI_AWSIZE({ axip_awsize, smpfull_awsize, con_awsize, scope_awsize, mem_awsize }), .M_AXI_AWBURST({ axip_awburst, smpfull_awburst, con_awburst, scope_awburst, mem_awburst }), .M_AXI_AWLOCK({ axip_awlock, smpfull_awlock, con_awlock, scope_awlock, mem_awlock }), .M_AXI_AWCACHE({ axip_awcache, smpfull_awcache, con_awcache, scope_awcache, mem_awcache }), .M_AXI_AWPROT({ axip_awprot, smpfull_awprot, con_awprot, scope_awprot, mem_awprot }), .M_AXI_AWQOS({ axip_awqos, smpfull_awqos, con_awqos, scope_awqos, mem_awqos }), // .M_AXI_WVALID({ axip_wvalid, smpfull_wvalid, con_wvalid, scope_wvalid, mem_wvalid }), .M_AXI_WREADY({ axip_wready, smpfull_wready, con_wready, scope_wready, mem_wready }), .M_AXI_WDATA({ axip_wdata, smpfull_wdata, con_wdata, scope_wdata, mem_wdata }), .M_AXI_WSTRB({ axip_wstrb, smpfull_wstrb, con_wstrb, scope_wstrb, mem_wstrb }), .M_AXI_WLAST({ axip_wlast, smpfull_wlast, con_wlast, scope_wlast, mem_wlast }), // .M_AXI_BVALID({ axip_bvalid, smpfull_bvalid, con_bvalid, scope_bvalid, mem_bvalid }), .M_AXI_BREADY({ axip_bready, smpfull_bready, con_bready, scope_bready, mem_bready }), .M_AXI_BID({ axip_bid, smpfull_bid, con_bid, scope_bid, mem_bid }), .M_AXI_BRESP({ axip_bresp, smpfull_bresp, con_bresp, scope_bresp, mem_bresp }), // .M_AXI_ARVALID({ axip_arvalid, smpfull_arvalid, con_arvalid, scope_arvalid, mem_arvalid }), .M_AXI_ARREADY({ axip_arready, smpfull_arready, con_arready, scope_arready, mem_arready }), .M_AXI_ARID({ axip_arid, smpfull_arid, con_arid, scope_arid, mem_arid }), .M_AXI_ARADDR({ axip_araddr, smpfull_araddr, con_araddr, scope_araddr, mem_araddr }), .M_AXI_ARLEN({ axip_arlen, smpfull_arlen, con_arlen, scope_arlen, mem_arlen }), .M_AXI_ARSIZE({ axip_arsize, smpfull_arsize, con_arsize, scope_arsize, mem_arsize }), .M_AXI_ARBURST({ axip_arburst, smpfull_arburst, con_arburst, scope_arburst, mem_arburst }), .M_AXI_ARLOCK({ axip_arlock, smpfull_arlock, con_arlock, scope_arlock, mem_arlock }), .M_AXI_ARCACHE({ axip_arcache, smpfull_arcache, con_arcache, scope_arcache, mem_arcache }), .M_AXI_ARPROT({ axip_arprot, smpfull_arprot, con_arprot, scope_arprot, mem_arprot }), .M_AXI_ARQOS({ axip_arqos, smpfull_arqos, con_arqos, scope_arqos, mem_arqos }), // .M_AXI_RVALID({ axip_rvalid, smpfull_rvalid, con_rvalid, scope_rvalid, mem_rvalid }), .M_AXI_RREADY({ axip_rready, smpfull_rready, con_rready, scope_rready, mem_rready }), .M_AXI_RID({ axip_rid, smpfull_rid, con_rid, scope_rid, mem_rid }), .M_AXI_RDATA({ axip_rdata, smpfull_rdata, con_rdata, scope_rdata, mem_rdata }), .M_AXI_RLAST({ axip_rlast, smpfull_rlast, con_rlast, scope_rlast, mem_rlast }), .M_AXI_RRESP({ axip_rresp, smpfull_rresp, con_rresp, scope_rresp, mem_rresp }) // }}} // }}} ); // }}} //////////////////////////////////////////////////////////////////////// // // Memory // {{{ //////////////////////////////////////////////////////////////////////// // // demofull #( // {{{ .C_S_AXI_ID_WIDTH(IW), .C_S_AXI_DATA_WIDTH(BUS_WIDTH), .C_S_AXI_ADDR_WIDTH(LGMEMSZ), .OPT_LOCK(1'b1) // }}} ) u_memaxi ( // {{{ .o_we(ram_we), .o_waddr(ram_waddr), .o_wdata(ram_wdata), .o_wstrb(ram_wstrb), .o_rd(ram_rd), .o_raddr(ram_raddr), .i_rdata(ram_rdata), // .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), // .S_AXI_AWVALID(mem_awvalid), .S_AXI_AWREADY(mem_awready), .S_AXI_AWID( mem_awid), .S_AXI_AWADDR( mem_awaddr[LGMEMSZ-1:0]), .S_AXI_AWLEN( mem_awlen), .S_AXI_AWSIZE( mem_awsize), .S_AXI_AWBURST(mem_awburst), .S_AXI_AWLOCK( mem_awlock), .S_AXI_AWCACHE(mem_awcache), .S_AXI_AWPROT( mem_awprot), .S_AXI_AWQOS( mem_awqos), // .S_AXI_WVALID(mem_wvalid), .S_AXI_WREADY(mem_wready), .S_AXI_WDATA( mem_wdata), .S_AXI_WSTRB( mem_wstrb), .S_AXI_WLAST( mem_wlast), // .S_AXI_BVALID(mem_bvalid), .S_AXI_BREADY(mem_bready), .S_AXI_BID( mem_bid), .S_AXI_BRESP( mem_bresp), // .S_AXI_ARVALID(mem_arvalid), .S_AXI_ARREADY(mem_arready), .S_AXI_ARID( mem_arid), .S_AXI_ARADDR( mem_araddr[LGMEMSZ-1:0]), .S_AXI_ARLEN( mem_arlen), .S_AXI_ARSIZE( mem_arsize), .S_AXI_ARBURST(mem_arburst), .S_AXI_ARLOCK( mem_arlock), .S_AXI_ARCACHE(mem_arcache), .S_AXI_ARPROT( mem_arprot), .S_AXI_ARQOS( mem_arqos), // .S_AXI_RVALID(mem_rvalid), .S_AXI_RREADY(mem_rready), .S_AXI_RID( mem_rid), .S_AXI_RDATA( mem_rdata), .S_AXI_RLAST( mem_rlast), .S_AXI_RRESP( mem_rresp) // }}} );",
            "initial begin $display(\"MEM_FILE = %s\", MEM_FILE); $display(\"CONSOLE_FILE = %s\", CONSOLE_FILE); $readmemh(MEM_FILE, ram); end generate for(gk=0; gk<BUS_WIDTH/32; gk=gk+1) begin : SWAP_RAM_WORDS // The ZipCPU's AXI interface currently maintains a little // endian word order, while using big endian word order within // a word.",
            "assign ram_wstrb_swap[ 4*gk +: 4] = ram_wstrb[ 4*(BUS_WIDTH/32-gk-1) +: 4];",
            "assign ram_wdata_swap[32*gk +: 32] = ram_wdata[32*(BUS_WIDTH/32-gk-1) +:32];",
            "assign ram_rdata[32*gk +: 32] = ram_rdata_swap[32*(BUS_WIDTH/32-gk-1) +:32]; end endgenerate",
            "always @(posedge i_aclk) if (ram_we) for(rk=0; rk<BUS_WIDTH/8; rk=rk+1) if (ram_wstrb_swap[rk]) ram[ram_waddr][rk*8 +: 8] <= ram_wdata_swap[rk*8 +: 8];",
            "always @(posedge i_aclk) if (ram_rd) ram_rdata_swap <= ram[ram_raddr]; // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_mem;",
            "assign unused_mem = &{ 1'b0, mem_awaddr[AW-1:LGMEMSZ], mem_araddr[AW-1:LGMEMSZ] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////// // // Console // {{{ //////////////////////////////////////////////////////////////////////// // // axi2axilsub #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH-3), .C_S_AXI_DATA_WIDTH(BUS_WIDTH), .C_M_AXI_DATA_WIDTH(32), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_WRITES(1), .OPT_READS(1) // }}} ) u_condown ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), // The \"Wide\" slave connection // {{{ .S_AXI_AWVALID(con_awvalid), .S_AXI_AWREADY(con_awready), .S_AXI_AWID( con_awid), .S_AXI_AWADDR( con_awaddr[AW-4:0]), .S_AXI_AWLEN( con_awlen), .S_AXI_AWSIZE( con_awsize), .S_AXI_AWBURST(con_awburst), .S_AXI_AWLOCK( con_awlock), .S_AXI_AWCACHE(con_awcache), .S_AXI_AWPROT( con_awprot), .S_AXI_AWQOS( con_awqos), .S_AXI_WVALID(con_wvalid), .S_AXI_WREADY(con_wready), .S_AXI_WDATA( con_wdata), .S_AXI_WSTRB( con_wstrb), .S_AXI_WLAST( con_wlast), .S_AXI_BVALID(con_bvalid), .S_AXI_BREADY(con_bready), .S_AXI_BID( con_bid), .S_AXI_BRESP( con_bresp), .S_AXI_ARVALID(con_arvalid), .S_AXI_ARREADY(con_arready), .S_AXI_ARID( con_arid), .S_AXI_ARADDR( con_araddr[AW-4:0]), .S_AXI_ARLEN( con_arlen), .S_AXI_ARSIZE( con_arsize), .S_AXI_ARBURST(con_arburst), .S_AXI_ARLOCK( con_arlock), .S_AXI_ARCACHE(con_arcache), .S_AXI_ARPROT( con_arprot), .S_AXI_ARQOS( con_arqos), .S_AXI_RVALID(con_rvalid), .S_AXI_RREADY(con_rready), .S_AXI_RID( con_rid), .S_AXI_RDATA( con_rdata), .S_AXI_RLAST( con_rlast), .S_AXI_RRESP( con_rresp), // }}} // The downsized connection // {{{ .M_AXI_AWVALID(conl_awvalid), .M_AXI_AWREADY(conl_awready), .M_AXI_AWADDR( conl_awaddr), .M_AXI_AWPROT( conl_awprot), .M_AXI_WVALID(conl_wvalid), .M_AXI_WREADY(conl_wready), .M_AXI_WDATA( conl_wdata), .M_AXI_WSTRB( conl_wstrb), .M_AXI_BVALID(conl_bvalid), .M_AXI_BREADY(conl_bready), .M_AXI_BRESP( conl_bresp), .M_AXI_ARVALID(conl_arvalid), .M_AXI_ARREADY(conl_arready), .M_AXI_ARADDR( conl_araddr), .M_AXI_ARPROT( conl_arprot), .M_AXI_RVALID(conl_rvalid), .M_AXI_RREADY(conl_rready), .M_AXI_RDATA( conl_rdata), .M_AXI_RRESP( conl_rresp) // }}} // }}} ); axilcon #( .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_SKIDBUFFER(1'b1), .CONSOLE_FILE(CONSOLE_FILE) ) u_console ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), // Slave bus connection(s) // {{{ .S_AXI_AWVALID(conl_awvalid), .S_AXI_AWREADY(conl_awready), .S_AXI_AWADDR( conl_awaddr[3:0]), .S_AXI_AWPROT( conl_awprot), .S_AXI_WVALID(conl_wvalid), .S_AXI_WREADY(conl_wready), .S_AXI_WDATA( conl_wdata), .S_AXI_WSTRB( conl_wstrb), .S_AXI_BVALID(conl_bvalid), .S_AXI_BREADY(conl_bready), .S_AXI_BRESP( conl_bresp), .S_AXI_ARVALID(conl_arvalid), .S_AXI_ARREADY(conl_arready), .S_AXI_ARADDR( conl_araddr[3:0]), .S_AXI_ARPROT( conl_arprot), .S_AXI_RVALID(conl_rvalid), .S_AXI_RREADY(conl_rready), .S_AXI_RDATA( conl_rdata), .S_AXI_RRESP( conl_rresp) // }}} // }}} ); // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_con;",
            "assign unused_con = &{ 1'b0, con_awaddr[AW-1:AW-4], con_araddr[AW-1:AW-4], conl_awaddr[AW-4:4], conl_araddr[AW-4:4] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////// // // AXI-Lite peripheral set (timers, counters, PIC, etc.) // {{{ //////////////////////////////////////////////////////////////////////// // // axi2axilsub #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH-3), .C_S_AXI_DATA_WIDTH(BUS_WIDTH), .C_M_AXI_DATA_WIDTH(32), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_WRITES(1), .OPT_READS(1) // }}} ) u_axilpdown ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), // The \"Wide\" slave connection // {{{ .S_AXI_AWVALID(axip_awvalid), .S_AXI_AWREADY(axip_awready), .S_AXI_AWID( axip_awid), .S_AXI_AWADDR( axip_awaddr[AW-4:0]), .S_AXI_AWLEN( axip_awlen), .S_AXI_AWSIZE( axip_awsize), .S_AXI_AWBURST(axip_awburst), .S_AXI_AWLOCK( axip_awlock), .S_AXI_AWCACHE(axip_awcache), .S_AXI_AWPROT( axip_awprot), .S_AXI_AWQOS( axip_awqos), .S_AXI_WVALID(axip_wvalid), .S_AXI_WREADY(axip_wready), .S_AXI_WDATA( axip_wdata), .S_AXI_WSTRB( axip_wstrb), .S_AXI_WLAST( axip_wlast), .S_AXI_BVALID(axip_bvalid), .S_AXI_BREADY(axip_bready), .S_AXI_BID( axip_bid), .S_AXI_BRESP( axip_bresp), .S_AXI_ARVALID(axip_arvalid), .S_AXI_ARREADY(axip_arready), .S_AXI_ARID( axip_arid), .S_AXI_ARADDR( axip_araddr[AW-4:0]), .S_AXI_ARLEN( axip_arlen), .S_AXI_ARSIZE( axip_arsize), .S_AXI_ARBURST(axip_arburst), .S_AXI_ARLOCK( axip_arlock), .S_AXI_ARCACHE(axip_arcache), .S_AXI_ARPROT( axip_arprot), .S_AXI_ARQOS( axip_arqos), .S_AXI_RVALID(axip_rvalid), .S_AXI_RREADY(axip_rready), .S_AXI_RID( axip_rid), .S_AXI_RDATA( axip_rdata), .S_AXI_RLAST( axip_rlast), .S_AXI_RRESP( axip_rresp), // }}} // The downsized connection // {{{ .M_AXI_AWVALID(axilp_awvalid), .M_AXI_AWREADY(axilp_awready), .M_AXI_AWADDR( axilp_awaddr), .M_AXI_AWPROT( axilp_awprot), .M_AXI_WVALID(axilp_wvalid), .M_AXI_WREADY(axilp_wready), .M_AXI_WDATA( axilp_wdata), .M_AXI_WSTRB( axilp_wstrb), .M_AXI_BVALID(axilp_bvalid), .M_AXI_BREADY(axilp_bready), .M_AXI_BRESP( axilp_bresp), .M_AXI_ARVALID(axilp_arvalid), .M_AXI_ARREADY(axilp_arready), .M_AXI_ARADDR( axilp_araddr), .M_AXI_ARPROT( axilp_arprot), .M_AXI_RVALID(axilp_rvalid), .M_AXI_RREADY(axilp_rready), .M_AXI_RDATA( axilp_rdata), .M_AXI_RRESP( axilp_rresp) // }}} // }}} ); axilperiphs #( .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_SKIDBUFFER(1'b1), .OPT_COUNTERS(1'b1), .EXTERNAL_INTERRUPTS(2) ) u_axilp ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), // Slave bus connection(s) // {{{ .S_AXI_AWVALID(axilp_awvalid), .S_AXI_AWREADY(axilp_awready), .S_AXI_AWADDR( axilp_awaddr[5:0]), .S_AXI_AWPROT( axilp_awprot), .S_AXI_WVALID(axilp_wvalid), .S_AXI_WREADY(axilp_wready), .S_AXI_WDATA( axilp_wdata), .S_AXI_WSTRB( axilp_wstrb), .S_AXI_BVALID(axilp_bvalid), .S_AXI_BREADY(axilp_bready), .S_AXI_BRESP( axilp_bresp), .S_AXI_ARVALID(axilp_arvalid), .S_AXI_ARREADY(axilp_arready), .S_AXI_ARADDR( axilp_araddr[5:0]), .S_AXI_ARPROT( axilp_arprot), .S_AXI_RVALID(axilp_rvalid), .S_AXI_RREADY(axilp_rready), .S_AXI_RDATA( axilp_rdata), .S_AXI_RRESP( axilp_rresp), // }}} .i_cpu_reset(cpu_reset[0]), .i_cpu_halted(cpu_halted[0]), .i_cpu_gie(cpu_gie[0]), .i_cpu_pfstall(cpu_pf_stall[0]), .i_cpu_opstall(cpu_op_stall[0]), .i_cpu_icount(cpu_i_count[0]), .i_ivec({ scope_int, i_sim_int }), .o_interrupt(pic_interrupt), .o_watchdog_reset(watchdog_reset) // }}} ); // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_axip;",
            "assign unused_axip = &{ 1'b0, axip_awaddr[AW-1:AW-4], axip_araddr[AW-1:AW-4], axilp_awaddr[AW-4:4], axilp_araddr[AW-4:4] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////// // // (Optional) AXIL Scope // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_TRACE_PORT) begin : GEN_AXILSCOPE // {{{",
            "wire scopel_awvalid, scopel_awready;",
            "wire [AW-4:0] scopel_awaddr;",
            "wire [2:0] scopel_awprot;",
            "wire scopel_wvalid, scopel_wready;",
            "wire [BUS_WIDTH-1:0] scopel_wdata;",
            "wire [BUS_WIDTH/8-1:0] scopel_wstrb;",
            "wire scopel_bvalid, scopel_bready;",
            "wire [1:0] scopel_bresp;",
            "wire scopel_arvalid, scopel_arready;",
            "wire [AW-4:0] scopel_araddr;",
            "wire [2:0] scopel_arprot;",
            "wire scopel_rvalid, scopel_rready;",
            "wire [BUS_WIDTH-1:0] scopel_rdata;",
            "wire [1:0] scopel_rresp; // axi2axilsub #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH-3), .C_S_AXI_DATA_WIDTH(BUS_WIDTH), .C_M_AXI_DATA_WIDTH(32), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_WRITES(1), .OPT_READS(1) // }}} ) u_scopedown ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), // The \"Wide\" slave connection // {{{ .S_AXI_AWVALID(scope_awvalid), .S_AXI_AWREADY(scope_awready), .S_AXI_AWID( scope_awid), .S_AXI_AWADDR( scope_awaddr[AW-4:0]), .S_AXI_AWLEN( scope_awlen), .S_AXI_AWSIZE( scope_awsize), .S_AXI_AWBURST(scope_awburst), .S_AXI_AWLOCK( scope_awlock), .S_AXI_AWCACHE(scope_awcache), .S_AXI_AWPROT( scope_awprot), .S_AXI_AWQOS( scope_awqos), .S_AXI_WVALID(scope_wvalid), .S_AXI_WREADY(scope_wready), .S_AXI_WDATA( scope_wdata), .S_AXI_WSTRB( scope_wstrb), .S_AXI_WLAST( scope_wlast), .S_AXI_BVALID(scope_bvalid), .S_AXI_BREADY(scope_bready), .S_AXI_BID( scope_bid), .S_AXI_BRESP( scope_bresp), .S_AXI_ARVALID(scope_arvalid), .S_AXI_ARREADY(scope_arready), .S_AXI_ARID( scope_arid), .S_AXI_ARADDR( scope_araddr[AW-4:0]), .S_AXI_ARLEN( scope_arlen), .S_AXI_ARSIZE( scope_arsize), .S_AXI_ARBURST(scope_arburst), .S_AXI_ARLOCK( scope_arlock), .S_AXI_ARCACHE(scope_arcache), .S_AXI_ARPROT( scope_arprot), .S_AXI_ARQOS( scope_arqos), .S_AXI_RVALID(scope_rvalid), .S_AXI_RREADY(scope_rready), .S_AXI_RID( scope_rid), .S_AXI_RDATA( scope_rdata), .S_AXI_RLAST( scope_rlast), .S_AXI_RRESP( scope_rresp), // }}} // The downsized connection // {{{ .M_AXI_AWVALID(scopel_awvalid), .M_AXI_AWREADY(scopel_awready), .M_AXI_AWADDR( scopel_awaddr), .M_AXI_AWPROT( scopel_awprot), .M_AXI_WVALID(scopel_wvalid), .M_AXI_WREADY(scopel_wready), .M_AXI_WDATA( scopel_wdata), .M_AXI_WSTRB( scopel_wstrb), .M_AXI_BVALID(scopel_bvalid), .M_AXI_BREADY(scopel_bready), .M_AXI_BRESP( scopel_bresp), .M_AXI_ARVALID(scopel_arvalid), .M_AXI_ARREADY(scopel_arready), .M_AXI_ARADDR( scopel_araddr), .M_AXI_ARPROT( scopel_arprot), .M_AXI_RVALID(scopel_rvalid), .M_AXI_RREADY(scopel_rready), .M_AXI_RDATA( scopel_rdata), .M_AXI_RRESP( scopel_rresp) // }}} // }}} ); axilscope #( .LGMEM(12) ) u_scope ( // {{{ .i_data_clk(i_aclk), .i_ce(1'b1), .i_trigger(1'b0), .i_data(cpu_trace), .o_interrupt(scope_int), // .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), // Slave bus connection(s) // {{{ .S_AXI_AWVALID(scopel_awvalid), .S_AXI_AWREADY(scopel_awready), .S_AXI_AWADDR( scopel_awaddr[2:0]), .S_AXI_AWPROT( scopel_awprot), .S_AXI_WVALID(scopel_wvalid), .S_AXI_WREADY(scopel_wready), .S_AXI_WDATA( scopel_wdata), .S_AXI_WSTRB( scopel_wstrb), .S_AXI_BVALID(scopel_bvalid), .S_AXI_BREADY(scopel_bready), .S_AXI_BRESP( scopel_bresp), .S_AXI_ARVALID(scopel_arvalid), .S_AXI_ARREADY(scopel_arready), .S_AXI_ARADDR( scopel_araddr[2:0]), .S_AXI_ARPROT( scopel_arprot), .S_AXI_RVALID(scopel_rvalid), .S_AXI_RREADY(scopel_rready), .S_AXI_RDATA( scopel_rdata), .S_AXI_RRESP( scopel_rresp) // }}} // }}} ); // }}} end else begin : NO_SCOPE // {{{ // The (NULL) slave that does nothing but (validly) return bus // errors axiempty #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_DATA_WIDTH(BUS_WIDTH), .C_AXI_ADDR_WIDTH(ADDRESS_WIDTH) // }}} ) u_noscope ( // {{{ .S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn), .S_AXI_AWVALID(scope_awvalid), .S_AXI_AWREADY(scope_awready), .S_AXI_AWID( scope_awid), .S_AXI_WVALID(scope_wvalid), .S_AXI_WREADY(scope_wready), .S_AXI_WLAST( scope_wlast), .S_AXI_BVALID(scope_bvalid), .S_AXI_BREADY(scope_bready), .S_AXI_BID( scope_bid), .S_AXI_BRESP( scope_bresp), .S_AXI_ARVALID(scope_arvalid), .S_AXI_ARREADY(scope_arready), .S_AXI_ARID( scope_arid), .S_AXI_ARLEN( scope_arlen), .S_AXI_RVALID(scope_rvalid), .S_AXI_RREADY(scope_rready), .S_AXI_RID( scope_rid), .S_AXI_RDATA( scope_rdata), .S_AXI_RLAST( scope_rlast), .S_AXI_RRESP( scope_rresp) // }}} );",
            "assign scope_int = 1'b0; // }}} // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_scope;",
            "assign unused_scope = &{ 1'b0, cpu_trace, scope_awaddr, scope_awlen, scope_awlock, scope_awburst, scope_awsize, scope_awcache, scope_awprot, scope_awqos, scope_wdata, scope_wstrb, scope_araddr, scope_arlen, scope_arlock, scope_arburst, scope_arsize, scope_arcache, scope_arprot, scope_arqos }; // Verilator lint_on UNUSED // Verilator coverage_on end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // (Optional) VCD generation // {{{ //////////////////////////////////////////////////////////////////////// // // `ifndef VERILATOR",
            "initial if (DUMP_TO_VCD) begin $dumpfile(VCD_FILE); $dumpvars(0, axi_tb); end `endif // }}} //////////////////////////////////////////////////////////////////////// // // Test bench watchdog // {{{ //////////////////////////////////////////////////////////////////////// // // // Don't let the simulation hang. Let's place a watchdog timeout on the // CPU's data bus. If the databus becomes idle for too long, then // stop the simulation with an error.",
            "initial watchdog_counter = 0;",
            "always @(posedge i_aclk) // if (!i_aresetn) // watchdog_counter <= 0; // else if (|(cpud_awvalid & cpud_awready) || |(cpud_arvalid & cpud_arready)) watchdog_counter <= 0; else watchdog_counter <= watchdog_counter + 1;",
            "always @(posedge i_aclk) if (watchdog_counter > TB_WATCHDOG_TIMEOUT) begin $display(\"\\nERROR: Watchdog timeout!\"); $finish; end",
            "always @(posedge i_aclk) if (i_aresetn && (&cpu_halted)) begin $display(\"\\nCPU Halted without error: PASS\\n\"); $finish; end // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "wb_tb.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/wb_tb.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/wb_tb.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Top level test infrastructure for all Wishbone configurations // of the ZipCPU. Contains: // // - Memory // - Console port (Not a serial port--$write's directly to console here) // - External debug access // - WBScope // // Since these are the capabilities that will be required to test the // ZipCPU. // // The goal is to be able to run the CPU test program, in all of the // ZipCPU's various Wishbone configurations, and by using it to routinely // smoke out any bugs before making any releases. // // A similar test bench exists for for testing the Wishbone version(s) of // the ZipCPU. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2022-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none `timescale 1ns/1ns // }}}",
            "module wb_tb #( // {{{",
            "parameter ADDRESS_WIDTH = 28, //Width in bytes",
            "parameter BUS_WIDTH = 32, // Verilator lint_off WIDTH",
            "parameter [0:0] OPT_ZIPBONES = 1'b1, parameter [0:0] OPT_PIPELINED = 1'b1, parameter OPT_LGICACHE = 12, parameter OPT_LGDCACHE = 12, parameter OPT_MPY = 3, parameter [0:0] OPT_DIV = 1'b1, parameter [0:0] OPT_SHIFTS = 1'b1, parameter [0:0] OPT_LOCK = 1'b1, parameter [0:0] OPT_EARLY_BRANCHING = 1'b1, parameter [0:0] OPT_LOWPOWER = 1'b1, parameter [0:0] OPT_DISTRIBUTED_REGS = 1'b1, parameter [0:0] OPT_USERMODE = 1'b1, parameter [0:0] OPT_CLKGATE = 1'b1, parameter [0:0] OPT_DBGPORT = 1'b1, parameter [0:0] OPT_TRACE_PORT = 1'b1, parameter [0:0] OPT_CIS = 1'b1, parameter [0:0] OPT_DMA = 1'b1, parameter OPT_SMP = 1, // Must be > 0",
            "parameter MEM_FILE = \"cputest\", parameter CONSOLE_FILE = \"console.txt\", parameter LGMEMSZ = ADDRESS_WIDTH-2, // parameter [0:0] DUMP_TO_VCD = 1'b0, parameter VCD_FILE = \"dump.vcd\" // Verilator lint_on WIDTH // }}} ) ( // {{{ `ifdef VERILATOR",
            "input wire i_clk, i_reset, // Sim control",
            "input (s) // {{{",
            "input wire i_sim_cyc, i_sim_stb, i_sim_we, input wire [ADDRESS_WIDTH-2:0] i_sim_addr, input wire [31:0] i_sim_data, input wire [3:0] i_sim_sel, output wire o_sim_stall, output wire o_sim_ack, output wire [31:0] o_sim_data, output wire o_sim_err, // }}}",
            "input wire i_sim_int, // // \"Profiler\" support. This is a simulation only port. // {{{",
            "output wire o_prof_stb, output wire [ADDRESS_WIDTH-1:0] o_prof_addr, output wire [31:0] o_prof_ticks // }}} `endif // }}} ); // Local declarations // {{{ genvar gk;",
            "localparam WBLSB = $clog2(BUS_WIDTH/8);",
            "parameter [31:0] RESET_ADDRESS = { {(32-ADDRESS_WIDTH){1'b0}}, MEMORY_ADDR, {(WBLSB){1'b0}} };",
            "localparam WAW = ADDRESS_WIDTH-WBLSB;",
            "parameter [WAW-1:0] SCOPE_ADDR = { 4'b0001, {(WAW-4){1'b0}} };",
            "parameter [WAW-1:0] CONSOLE_ADDR = { 4'b0010, {(WAW-4){1'b0}} };",
            "parameter [WAW-1:0] SMP_BASE_ADDR = { 4'b0011, {(WAW-4){1'b0}} };",
            "parameter [WAW-1:0] ZDMA_CHECK_ADDR = { 4'b0101, {(WAW-4){1'b0}} };",
            "parameter [WAW-1:0] ZDMA_CHECKST_ADDR = { 4'b0110, {(WAW-4){1'b0}} };",
            "parameter [WAW-1:0] ZSYS_ADDR = { {(ADDRESS_WIDTH-24){1'b1}}, {(24-WBLSB){1'b0}} };",
            "parameter [WAW-1:0] MEMORY_ADDR = { 2'b01, {(WAW-2){1'b0}} };",
            "localparam LGFIFO = 4;",
            "localparam MIN_SMP = (OPT_SMP < 2) ? 1 : OPT_SMP;",
            "parameter [OPT_SMP*WAW-1:0] SMP_ADDR = SMP_ADDR_fn(MIN_SMP);",
            "parameter [OPT_SMP*WAW-1:0] SMP_MASK = SMP_MASK_fn(MIN_SMP); // Verilator lint_off UNUSED function [OPT_SMP*WAW-1:0] SMP_ADDR_fn(",
            "input integer min_smp); // {{{ integer ik, offset; begin SMP_ADDR_fn = {(OPT_SMP){SMP_BASE_ADDR}}; for(ik=1; ik < OPT_SMP; ik=ik+1) begin offset = ik; SMP_ADDR_fn[ik*WAW+(9-WBLSB) +: $clog2(OPT_SMP)+1] = offset[$clog2(OPT_SMP):0]; end end endfunction // }}} function [OPT_SMP*WAW-1:0] SMP_MASK_fn(",
            "input integer min_smp); // {{{ integer ik; begin SMP_MASK_fn = {(OPT_SMP){ 4'b1111, {(WAW-4){1'b0}} }}; for(ik=0; ik < OPT_SMP; ik=ik+1) begin SMP_MASK_fn[ik*WAW+(9-WBLSB) +: $clog2(OPT_SMP)+1] = {($clog2(OPT_SMP)+1){1'b1}}; end end endfunction // Verilator lint_on UNUSED // }}}",
            "wire [OPT_SMP-1:0] cpu_int; // Verilator lint_off UNUSED",
            "wire [OPT_SMP-1:0] cpu_halted, cpu_op_stall, cpu_pf_stall, cpu_i_count, cpu_gie; // Verilator lint_on UNUSED",
            "wire scope_int;",
            "wire [31:0] cpu_trace;",
            "wire dbg_cyc, dbg_stb, dbg_we, dbg_stall, dbg_ack, dbg_err;",
            "wire [ADDRESS_WIDTH+1-$clog2(32/8)-1:0] dbg_addr;",
            "wire [31:0] dbg_data, dbg_idata;",
            "wire [3:0] dbg_sel;",
            "wire [OPT_SMP-1:0] smpw_cyc, smpw_stb, smpw_we, smpw_stall, smpw_ack, smpw_err;",
            "wire [OPT_SMP*WAW-1:0] smpw_addr;",
            "wire [OPT_SMP*BUS_WIDTH-1:0] smpw_data, smpw_idata;",
            "wire [OPT_SMP*BUS_WIDTH/8-1:0] smpw_sel;",
            "wire pic_int, timer_a_int, timer_b_int, timer_c_int, jiffies_int; //////////////////////////////////////////////////////////////////////// // // CPU bus declarations // {{{",
            "wire [OPT_SMP-1:0] cpu_cyc, cpu_stb, cpu_we, cpu_ack, cpu_stall, cpu_err;",
            "wire [OPT_SMP*WAW-1:0] cpu_addr;",
            "wire [OPT_SMP*BUS_WIDTH-1:0] cpu_data, cpu_idata;",
            "wire [OPT_SMP*BUS_WIDTH/8-1:0] cpu_sel; // }}} //////////////////////////////////////////////////////////////////////// // // Memory bus declarations // {{{",
            "wire mem_cyc, mem_stb, mem_we, mem_ack, mem_stall, mem_err;",
            "wire [WAW-1:0] mem_addr;",
            "wire [BUS_WIDTH-1:0] mem_data, mem_idata;",
            "wire [BUS_WIDTH/8-1:0] mem_sel; // }}} //////////////////////////////////////////////////////////////////////// // // Console bus declarations // {{{",
            "wire conw_cyc, conw_stb, conw_we, conw_ack, conw_stall, conw_err;",
            "wire [WAW-1:0] conw_addr;",
            "wire [BUS_WIDTH-1:0] conw_data, conw_idata;",
            "wire [BUS_WIDTH/8-1:0] conw_sel;",
            "wire con_cyc, con_stb, con_we, con_ack, con_stall, con_err;",
            "wire [ADDRESS_WIDTH-3-$clog2(32/8)-1:0] con_addr;",
            "wire [31:0] con_data, con_idata;",
            "wire [3:0] con_sel;",
            "reg r_con_ack; // }}} //////////////////////////////////////////////////////////////////////// // // ZipCPU System bus declarations // {{{",
            "wire zsysw_cyc, zsysw_stb, zsysw_we, zsysw_ack, zsysw_stall, zsysw_err;",
            "wire [WAW-1:0] zsysw_addr;",
            "wire [BUS_WIDTH-1:0] zsysw_data, zsysw_idata;",
            "wire [BUS_WIDTH/8-1:0] zsysw_sel;",
            "wire zsys_cyc, zsys_stb, zsys_we, zsys_ack, zsys_stall, zsys_err;",
            "wire [WAW+WBLSB-$clog2(32/8)-5:0] zsys_addr;",
            "wire [31:0] zsys_data, zsys_idata;",
            "wire [3:0] zsys_sel;",
            "reg r_zsys_ack;",
            "reg [31:0] r_zsys_data; // }}} //////////////////////////////////////////////////////////////////////// // // (Optional) DMA bus declarations // {{{",
            "wire dmac_cyc, dmac_stb, dmac_we;",
            "wire [WAW-1:0] dmac_addr;",
            "wire [BUS_WIDTH-1:0] dmac_data;",
            "wire [BUS_WIDTH/8-1:0] dmac_sel; // Verilator lint_off UNUSED",
            "wire dmac_int;",
            "wire dmac_ack, dmac_stall, dmac_err;",
            "wire [BUS_WIDTH-1:0] dmac_return; // Verilator lint_on UNUSED // }}} //////////////////////////////////////////////////////////////////////// // // Optional SCOPE // {{{",
            "wire scopew_cyc, scopew_stb, scopew_we, scopew_ack, scopew_stall, scopew_err;",
            "wire [ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)-1:0] scopew_addr;",
            "wire [BUS_WIDTH-1:0] scopew_data, scopew_idata;",
            "wire [BUS_WIDTH/8-1:0] scopew_sel; // }}} //////////////////////////////////////////////////////////////////////// // // Optional ZIPDMA_Check // {{{",
            "wire zdmacw_cyc, zdmacw_stb, zdmacw_we, zdmacw_ack, zdmacw_stall, zdmacw_err;",
            "wire [ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)-1:0] zdmacw_addr;",
            "wire [BUS_WIDTH-1:0] zdmacw_data, zdmacw_idata;",
            "wire [BUS_WIDTH/8-1:0] zdmacw_sel;",
            "wire zdmacstw_cyc, zdmacstw_stb, zdmacstw_we, zdmacstw_ack, zdmacstw_stall, zdmacstw_err;",
            "wire [ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)-1:0] zdmacstw_addr;",
            "wire [BUS_WIDTH-1:0] zdmacstw_data, zdmacstw_idata;",
            "wire [BUS_WIDTH/8-1:0] zdmacstw_sel;",
            "wire zdmacst_cyc, zdmacst_stb, zdmacst_we;",
            "wire [ADDRESS_WIDTH-3-$clog2(32/8)-1:0] zdmacst_addr;",
            "wire [31:0] zdmacst_data, zdmacst_idata;",
            "wire [3:0] zdmacst_sel;",
            "wire zdmacst_stall, zdmacst_ack, zdmacst_err; // }}} //////////////////////////////////////////////////////////////////////// // // ZipSystem replacement(s) // {{{",
            "wire pic_stall, pic_ack;",
            "wire [31:0] pic_data;",
            "wire timer_a_stall, timer_b_stall, timer_c_stall, jiffies_stall; // Jiffies",
            "wire timer_a_ack, timer_b_ack, timer_c_ack, jiffies_ack; // Jiffies",
            "wire [31:0] timer_a_data, timer_b_data, timer_c_data, jiffies_data; // Jiffies",
            "wire [31:0] dma_slv_data;",
            "wire [31:0] mtc_data, moc_data, mpc_data, mic_data;",
            "wire [31:0] utc_data, uoc_data, upc_data, uic_data; // Verilator lint_off UNUSED",
            "wire ign_mtc_stall, ign_moc_stall, ign_mpc_stall, ign_mic_stall;",
            "wire ign_utc_stall, ign_uoc_stall, ign_upc_stall, ign_uic_stall;",
            "wire ign_mtc_ack, ign_moc_ack, ign_mpc_ack, ign_mic_ack;",
            "wire ign_utc_ack, ign_uoc_ack, ign_upc_ack, ign_uic_ack;",
            "wire mtc_int, moc_int, mpc_int, mic_int;",
            "wire utc_int, uoc_int, upc_int, uic_int; // Verilator lint_on UNUSED",
            "reg zsys_stb_d;",
            "reg [WAW+WBLSB-$clog2(32/8)-5:0] zsys_addr_d; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Traditional TB support // {{{ //////////////////////////////////////////////////////////////////////// // // `ifndef VERILATOR",
            "wire i_sim_cyc, i_sim_stb, i_sim_we;",
            "wire [ADDRESS_WIDTH-2:0] i_sim_addr;",
            "wire [31:0] i_sim_data;",
            "wire [3:0] i_sim_sel;",
            "wire o_sim_stall;",
            "wire o_sim_ack;",
            "wire [31:0] o_sim_data;",
            "wire o_sim_err;",
            "wire i_sim_int;",
            "wire o_prof_stb; // wire [31:0] o_prof_addr;",
            "wire [ADDRESS_WIDTH-1:0] o_prof_addr;",
            "wire [31:0] o_prof_ticks;",
            "reg i_clk, i_reset, reset_pipe;",
            "initial i_clk = 0;",
            "always #5 i_clk = !i_clk;",
            "initial { i_reset, reset_pipe } = -1;",
            "always @(posedge i_clk) { i_reset, reset_pipe } <= { reset_pipe, 1'b0 }; // Tie off (unused) Sim control",
            "input (s) // {{{",
            "assign i_sim_cyc = 1'b0;",
            "assign i_sim_stb = 1'b0;",
            "assign i_sim_we = 1'b0;",
            "assign i_sim_addr = 0;",
            "assign i_sim_data = 0;",
            "assign i_sim_sel = 0; // }}}",
            "assign i_sim_int = 1'b0; `endif // }}} //////////////////////////////////////////////////////////////////////// // // External sim port: Either controls ZipCPU or wide WB bus // {{{ //////////////////////////////////////////////////////////////////////// // // `ifdef VERILATOR // Only required if we are using Verilator. Other test benches won't // use this",
            "input port",
            "wire sim_cyc, sim_stb, sim_we, sim_stall, sim_ack, sim_err;",
            "wire [ADDRESS_WIDTH+1-$clog2(32/8)-1:0] sim_addr;",
            "wire [31:0] sim_data, sim_idata;",
            "wire [32/8-1:0] sim_sel;",
            "wire simw_cyc, simw_stb, simw_we, simw_stall, simw_ack, simw_err;",
            "wire [ADDRESS_WIDTH+1-$clog2(BUS_WIDTH/8)-1:0] simw_addr;",
            "wire [BUS_WIDTH-1:0] simw_data, simw_idata;",
            "wire [BUS_WIDTH/8-1:0] simw_sel; wbxbar #( // {{{ .NM(1), .NS(2), .AW(ADDRESS_WIDTH+1-$clog2(32/8)), .DW(32), .SLAVE_ADDR({ { 1'b0, {(ADDRESS_WIDTH-$clog2(32/8)){1'b0}} }, { 1'b1, {(ADDRESS_WIDTH-$clog2(32/8)){1'b0}} }}), // CPU .SLAVE_MASK({ { 1'b0, {(ADDRESS_WIDTH-$clog2(32/8)){1'b0}} }, { 1'b1, {(ADDRESS_WIDTH-$clog2(32/8)){1'b0}} }}) // CPU // }}} ) simxbar ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // One master: the SIM bus",
            "input // {{{ .i_mcyc(i_sim_cyc), .i_mstb(i_sim_stb), .i_mwe(i_sim_we), .i_maddr(i_sim_addr), .i_mdata(i_sim_data), .i_msel(i_sim_sel), // .o_mstall(o_sim_stall), .o_mack(o_sim_ack),.o_mdata(o_sim_data), .o_merr(o_sim_err), // }}} // Two slaves: The wide bus the ZipCPU masters, and the ZipCPU's // debug port // {{{ .o_scyc({ sim_cyc, dbg_cyc }), .o_sstb({ sim_stb, dbg_stb }), .o_swe({ sim_we, dbg_we }), .o_saddr({ sim_addr,dbg_addr }), .o_sdata({ sim_data,dbg_data }), .o_ssel({ sim_sel, dbg_sel }), // .i_sstall({ sim_stall, dbg_stall }), .i_sack({ sim_ack, dbg_ack }), .i_sdata({ sim_idata, dbg_idata }), .i_serr({ sim_err, dbg_err }) // }}} // }}} );",
            "assign simw_cyc = sim_cyc;",
            "assign simw_we = sim_we;",
            "assign sim_ack = simw_ack;",
            "assign sim_err = simw_err; generate if (BUS_WIDTH == 32) begin : NO_EXPAND_SIMBUS // {{{",
            "assign simw_stb = sim_stb;",
            "assign simw_addr = sim_addr;",
            "assign simw_data = sim_data;",
            "assign simw_sel = sim_sel;",
            "assign sim_stall = simw_stall;",
            "assign sim_idata = simw_idata; // }}} end else begin : GEN_EXPAND_SIMBUS // {{{",
            "wire fifo_full, fifo_empty;",
            "wire [LGFIFO:0] fifo_fill;",
            "wire [$clog2(BUS_WIDTH/8)-$clog2(32/8)-1:0] fifo_addr;",
            "wire [BUS_WIDTH-1:0] wide_idata;",
            "assign simw_stb = sim_stb && !fifo_full;",
            "assign sim_stall = simw_stall || fifo_full;",
            "assign simw_addr = sim_addr[ADDRESS_WIDTH+1-$clog2(32/8)-1:$clog2(BUS_WIDTH/32)];",
            "assign simw_sel = { sim_sel, {(BUS_WIDTH/8-4){1'b0}} } >> (4*simw_addr[$clog2(BUS_WIDTH/8)-1:2]);",
            "assign simw_data = { sim_data, {(BUS_WIDTH-32){1'b0}} } >> (32*simw_addr[$clog2(BUS_WIDTH/8)-1:2]); sfifo #( // {{{ .LGFLEN(LGFIFO), .OPT_READ_ON_EMPTY(1'b1), .BW($clog2(BUS_WIDTH/32)) // }}} ) u_simaddr_fifo ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_wr(simw_stb && !sim_stall), .i_data(simw_addr[$clog2(BUS_WIDTH/8)-1:2]), .o_full(fifo_full), .o_fill(fifo_fill), .i_rd(simw_ack), .o_data(fifo_addr), .o_empty(fifo_empty) // }}} );",
            "assign wide_idata = simw_idata << (32*fifo_addr);",
            "assign sim_idata = wide_idata[BUS_WIDTH-1:BUS_WIDTH-32]; // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_sim_expander;",
            "assign unused_sim_expander = &{ 1'b0, fifo_fill, fifo_empty, wide_idata[BUS_WIDTH-32-1:0], sim_addr[$clog2(BUS_WIDTH/32):0] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} // }}} end endgenerate `else // If we aren't using Verilator, then there's no external bus driver. // Cap off the debug port therefore. // assign dbg_cyc = 1'b0;",
            "assign dbg_stb = 1'b0;",
            "assign dbg_we = 1'b0;",
            "assign dbg_data= 32'h0;",
            "assign dbg_sel = 4'h0; `endif // }}} //////////////////////////////////////////////////////////////////////// // // The CPU itself // {{{ //////////////////////////////////////////////////////////////////////// // // localparam RESET_DURATION = 10;",
            "localparam [0:0] OPT_SIM = 1'b1; `ifdef VERILATOR",
            "localparam [0:0] OPT_PROFILER = 1'b1; `else",
            "localparam [0:0] OPT_PROFILER = 1'b0; `endif generate if (OPT_ZIPBONES) begin : GEN_ZIPBONES zipbones #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH), .RESET_ADDRESS(RESET_ADDRESS), .OPT_PIPELINED(OPT_PIPELINED), .BUS_WIDTH(BUS_WIDTH), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_LGICACHE(OPT_LGICACHE), .OPT_LGDCACHE(OPT_LGDCACHE), .START_HALTED(1'b0), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .OPT_LOCK(OPT_LOCK), .OPT_CIS(OPT_CIS), .OPT_USERMODE(OPT_USERMODE), .OPT_DBGPORT(OPT_DBGPORT), .OPT_TRACE_PORT(OPT_TRACE_PORT), .OPT_PROFILER(OPT_PROFILER), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_SIM(OPT_SIM), .OPT_CLKGATE(OPT_CLKGATE), .RESET_DURATION(RESET_DURATION) // }}} ) u_cpu ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // Master bus // {{{ .o_wb_cyc(cpu_cyc[0]), .o_wb_stb(cpu_stb[0]), .o_wb_we(cpu_we[0]), .o_wb_addr(cpu_addr[WAW-1:0]), .o_wb_data(cpu_data[BUS_WIDTH-1:0]), .o_wb_sel(cpu_sel[BUS_WIDTH/8-1:0]), .i_wb_stall(cpu_stall[0]), .i_wb_ack(cpu_ack[0]), .i_wb_data(cpu_idata[BUS_WIDTH-1:0]), .i_wb_err(cpu_err[0]), // }}} .i_ext_int(pic_int), .o_ext_int(cpu_int[0]), // Debug control port // {{{ .i_dbg_cyc(dbg_cyc), .i_dbg_stb(dbg_stb), .i_dbg_we(dbg_we), .i_dbg_addr(dbg_addr[5:0]), .i_dbg_data(dbg_data), .i_dbg_sel(dbg_sel), .o_dbg_stall(dbg_stall), .o_dbg_ack(dbg_ack), .o_dbg_data(dbg_idata), // }}} .o_cpu_debug(cpu_trace), // (Optional) Profiler // {{{ .o_prof_stb(o_prof_stb), .o_prof_addr(o_prof_addr), .o_prof_ticks(o_prof_ticks) // }}} // }}} );",
            "assign cpu_halted[0] = u_cpu.cpu_has_halted;",
            "assign cpu_op_stall[0] = u_cpu.cpu_op_stall;",
            "assign cpu_pf_stall[0] = u_cpu.cpu_pf_stall;",
            "assign cpu_i_count[0] = u_cpu.cpu_i_count;",
            "assign cpu_gie[0] = u_cpu.cpu_dbg_cc[1]; end else begin : GEN_ZIPSYSTEM zipsystem #( // {{{ .RESET_ADDRESS(RESET_ADDRESS), .ADDRESS_WIDTH(ADDRESS_WIDTH), .BUS_WIDTH(BUS_WIDTH), .OPT_PIPELINED(OPT_PIPELINED), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_LGICACHE(OPT_LGICACHE), .OPT_LGDCACHE(OPT_LGDCACHE), .START_HALTED(1'b0), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .OPT_LOCK(OPT_LOCK), .OPT_CIS(OPT_CIS), .OPT_USERMODE(OPT_USERMODE), .OPT_DBGPORT(OPT_DBGPORT), .OPT_TRACE_PORT(OPT_TRACE_PORT), .OPT_PROFILER(OPT_PROFILER), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_SIM(OPT_SIM), .OPT_CLKGATE(OPT_CLKGATE), .RESET_DURATION(RESET_DURATION), // ZipSystem only",
            "parameter s .OPT_DMA(OPT_DMA), .OPT_ACCOUNTING(1'b1), .EXTERNAL_INTERRUPTS(1) // }}} ) u_cpu ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // Master bus // {{{ .o_wb_cyc(cpu_cyc[0]), .o_wb_stb(cpu_stb[0]), .o_wb_we(cpu_we[0]), .o_wb_addr(cpu_addr[WAW-1:0]), .o_wb_data(cpu_data[BUS_WIDTH-1:0]), .o_wb_sel(cpu_sel[BUS_WIDTH/8-1:0]), .i_wb_stall(cpu_stall[0]), .i_wb_ack(cpu_ack[0]), .i_wb_data(cpu_idata[BUS_WIDTH-1:0]), .i_wb_err(cpu_err[0]), // }}} .i_ext_int({ i_sim_int }), .o_ext_int(cpu_int[0]), // Debug control port // {{{ .i_dbg_cyc(dbg_cyc), .i_dbg_stb(dbg_stb), .i_dbg_we(dbg_we), .i_dbg_addr(dbg_addr[6:0]), .i_dbg_data(dbg_data), .i_dbg_sel(dbg_sel), .o_dbg_stall(dbg_stall), .o_dbg_ack(dbg_ack), .o_dbg_data(dbg_idata), // }}} .o_cpu_debug(cpu_trace), // (Optional) Profiler // {{{ .o_prof_stb(o_prof_stb), .o_prof_addr(o_prof_addr), .o_prof_ticks(o_prof_ticks) // }}} // }}} );",
            "assign cpu_halted[0] = u_cpu.cpu_has_halted;",
            "assign cpu_op_stall[0] = u_cpu.cpu_op_stall;",
            "assign cpu_pf_stall[0] = u_cpu.cpu_pf_stall;",
            "assign cpu_i_count[0] = u_cpu.cpu_i_count;",
            "assign cpu_gie[0] = u_cpu.cpu_gie; // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_zipsys;",
            "assign unused_zipsys = &{ 1'b0, pic_int }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} end endgenerate",
            "assign dbg_err = 1'b0; // }}} //////////////////////////////////////////////////////////////////////// // // Extra CPU's, if running in multiprocessor mode (OPT_SMP > 1) // {{{ //////////////////////////////////////////////////////////////////////// // // // No slave connection // {{{",
            "reg r_smp_err;",
            "initial r_smp_err = 1'b0;",
            "always @(posedge i_clk) if (i_reset) r_smp_err <= 1'b0; else r_smp_err <= smpw_stb[0];",
            "assign smpw_stall[0] = 1'b0;",
            "assign smpw_ack[0] = 1'b0;",
            "assign smpw_idata[BUS_WIDTH-1:0] = {(BUS_WIDTH){1'b0}};",
            "assign smpw_err[0] = r_smp_err; // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_smpw;",
            "assign unused_smpw = &{ 1'b0, smpw_cyc[0], smpw_we[0], smpw_addr[WAW-1:0], smpw_data[BUS_WIDTH-1:0], smpw_sel[BUS_WIDTH/8-1:0] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} // }}} generate for (gk=1; gk<OPT_SMP; gk=gk+1) begin : GEN_SMPCPU // Local declarations // {{{",
            "wire [31:0] smp_trace;",
            "wire smp_prof_stb;",
            "wire [ADDRESS_WIDTH-1:0] smp_prof_addr;",
            "wire [31:0] smp_prof_ticks;",
            "wire smp_cyc, smp_stb, smp_we;",
            "wire [6:0] smp_addr;",
            "wire [31:0] smp_data;",
            "wire [3:0] smp_sel;",
            "wire smp_stall, smp_ack, smp_err;",
            "wire [31:0] smp_idata; // }}} wbdown #( // {{{ .ADDRESS_WIDTH(9), .WIDE_DW(BUS_WIDTH), .SMALL_DW(32) // }}} ) u_smpdown ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // The \"Wide\" connection // {{{ .i_wcyc(smpw_cyc[gk]), .i_wstb(smpw_stb[gk]), .i_wwe(smpw_we[gk]), .i_waddr(smpw_addr[gk * WAW +: (9-WBLSB)]), .i_wdata(smpw_data[gk*BUS_WIDTH +: BUS_WIDTH]), .i_wsel(smpw_sel[gk*BUS_WIDTH/8 +: BUS_WIDTH/8]), // .o_wstall(smpw_stall[gk]), .o_wack(smpw_ack[gk]), .o_wdata(smpw_idata[gk*BUS_WIDTH +: BUS_WIDTH]), .o_werr(smpw_err[gk]), // }}} // The downsized connection // {{{ .o_cyc(smp_cyc), .o_stb(smp_stb), .o_we(smp_we), .o_addr(smp_addr), .o_data(smp_data), .o_sel(smp_sel), // .i_stall(smp_stall), .i_ack(smp_ack), .i_data(smp_idata), .i_err(smp_err) // }}} // }}} );",
            "assign smp_err = 1'b0; if (OPT_ZIPBONES) begin : GEN_ZIPBONES zipbones #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH), .RESET_ADDRESS(RESET_ADDRESS), .OPT_PIPELINED(OPT_PIPELINED), .BUS_WIDTH(BUS_WIDTH), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_LGICACHE(OPT_LGICACHE), .OPT_LGDCACHE(OPT_LGDCACHE), .START_HALTED(1'b1), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .OPT_LOCK(OPT_LOCK), .OPT_CIS(OPT_CIS), .OPT_USERMODE(OPT_USERMODE), .OPT_DBGPORT(OPT_DBGPORT), .OPT_TRACE_PORT(OPT_TRACE_PORT), .OPT_PROFILER(OPT_PROFILER), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_SIM(OPT_SIM), .OPT_CLKGATE(OPT_CLKGATE), .RESET_DURATION(RESET_DURATION) // }}} ) u_smp ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // Master bus // {{{ .o_wb_cyc(cpu_cyc[gk]), .o_wb_stb(cpu_stb[gk]), .o_wb_we(cpu_we[gk]), .o_wb_addr(cpu_addr[gk*WAW +: WAW]), .o_wb_data(cpu_data[gk*BUS_WIDTH +: BUS_WIDTH]), .o_wb_sel(cpu_sel[gk*BUS_WIDTH/8 +: BUS_WIDTH/8]), .i_wb_stall(cpu_stall[gk]), .i_wb_ack(cpu_ack[gk]), .i_wb_data(cpu_idata[gk*BUS_WIDTH +: BUS_WIDTH]), .i_wb_err(cpu_err[gk]), // }}} .i_ext_int(pic_int), .o_ext_int(cpu_int[gk]), // Debug control port // {{{ .i_dbg_cyc(smp_cyc), .i_dbg_stb(smp_stb), .i_dbg_we(smp_we), .i_dbg_addr(smp_addr[5:0]), .i_dbg_data(smp_data), .i_dbg_sel(smp_sel), .o_dbg_stall(smp_stall), .o_dbg_ack(smp_ack), .o_dbg_data(smp_idata), // }}} .o_cpu_debug(smp_trace), // (Optional) Profiler // {{{ .o_prof_stb(smp_prof_stb), .o_prof_addr(smp_prof_addr), .o_prof_ticks(smp_prof_ticks) // }}} // }}} );",
            "assign cpu_halted[gk] = u_smp.cpu_has_halted;",
            "assign cpu_op_stall[gk] = u_smp.cpu_op_stall;",
            "assign cpu_pf_stall[gk] = u_smp.cpu_pf_stall;",
            "assign cpu_i_count[gk] = u_smp.cpu_i_count;",
            "assign cpu_gie[gk] = u_smp.cpu_dbg_cc[1]; end else begin : GEN_ZIPSYSTEM zipsystem #( // {{{ .RESET_ADDRESS(RESET_ADDRESS), .ADDRESS_WIDTH(ADDRESS_WIDTH), .BUS_WIDTH(BUS_WIDTH), .OPT_PIPELINED(OPT_PIPELINED), .OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING), .OPT_LGICACHE(OPT_LGICACHE), .OPT_LGDCACHE(OPT_LGDCACHE), .START_HALTED(1'b1), .OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS), .OPT_MPY(OPT_MPY), .OPT_DIV(OPT_DIV), .OPT_SHIFTS(OPT_SHIFTS), .OPT_LOCK(OPT_LOCK), .OPT_CIS(OPT_CIS), .OPT_USERMODE(OPT_USERMODE), .OPT_DBGPORT(1'b1), .OPT_TRACE_PORT(1'b0), .OPT_PROFILER(1'b0), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_SIM(OPT_SIM), .OPT_CLKGATE(OPT_CLKGATE), .RESET_DURATION(RESET_DURATION), // ZipSystem only",
            "parameter s .OPT_DMA(OPT_DMA), .OPT_ACCOUNTING(1'b1), .EXTERNAL_INTERRUPTS(1) // }}} ) u_smp ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // Master bus // {{{ .o_wb_cyc(cpu_cyc[gk]), .o_wb_stb(cpu_stb[gk]), .o_wb_we(cpu_we[gk]), .o_wb_addr(cpu_addr[gk*WAW +: WAW]), .o_wb_data(cpu_data[gk*BUS_WIDTH +: BUS_WIDTH]), .o_wb_sel(cpu_sel[gk*BUS_WIDTH/8 +: BUS_WIDTH/8]), .i_wb_stall(cpu_stall[gk]), .i_wb_ack(cpu_ack[gk]), .i_wb_data(cpu_idata[gk*BUS_WIDTH +: BUS_WIDTH]), .i_wb_err(cpu_err[gk]), // }}} .i_ext_int({ i_sim_int }), .o_ext_int(cpu_int[gk]), // Debug control port // {{{ .i_dbg_cyc(smp_cyc), .i_dbg_stb(smp_stb), .i_dbg_we(smp_we), .i_dbg_addr(smp_addr[6:0]), .i_dbg_data(smp_data), .i_dbg_sel(smp_sel), .o_dbg_stall(smp_stall), .o_dbg_ack(smp_ack), .o_dbg_data(smp_idata), // }}} .o_cpu_debug(smp_trace), // (Optional) Profiler // {{{ .o_prof_stb(smp_prof_stb), .o_prof_addr(smp_prof_addr), .o_prof_ticks(smp_prof_ticks) // }}} // }}} );",
            "assign cpu_halted[gk] = u_smp.cpu_has_halted;",
            "assign cpu_op_stall[gk] = u_smp.cpu_op_stall;",
            "assign cpu_pf_stall[gk] = u_smp.cpu_pf_stall;",
            "assign cpu_i_count[gk] = u_smp.cpu_i_count;",
            "assign cpu_gie[gk] = u_smp.cpu_gie; // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_zipsys;",
            "assign unused_zipsys = &{ 1'b0, pic_int }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} end // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_smp;",
            "assign unused_smp = &{ 1'b0, smp_prof_stb, smp_prof_addr, smp_prof_ticks, smp_trace, cpu_int[gk], smp_addr[6], smpw_addr[gk*WAW + (9-WBLSB) +: (WAW-(9-WBLSB))] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // The wide bus interconnect // {{{ //////////////////////////////////////////////////////////////////////// // // wbxbar #( // {{{ `ifdef VERILATOR .NM(1+1+OPT_SMP), `else .NM(1+OPT_SMP), `endif .NS(6+OPT_SMP), .AW(ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)), .DW(BUS_WIDTH), .SLAVE_ADDR({ ZSYS_ADDR, SMP_ADDR, ZDMA_CHECKST_ADDR, ZDMA_CHECK_ADDR, CONSOLE_ADDR, SCOPE_ADDR, MEMORY_ADDR }), .SLAVE_MASK({ { {(ADDRESS_WIDTH-24){1'b1}},{(24-WBLSB){1'b0}} }, // ZipSys SMP_MASK, // SMP { 4'b1111, {(WAW-4){1'b0}} }, // ZDMA_Check { 4'b1111, {(WAW-4){1'b0}} }, // ZDMA_Check Status { 4'b1111, {(WAW-4){1'b0}} }, // Console { 4'b1111, {(WAW-4){1'b0}} }, // Scope { 2'b11, {(WAW-2){1'b0}} } }) // Memory // }}} ) main_crossbar ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // Slave ports from the various bus masters // {{{ `ifdef VERILATOR // Two bus masters: the external SIM",
            "input , and the CPU .i_mcyc({ simw_cyc, dmac_cyc, cpu_cyc }), .i_mstb({ simw_stb, dmac_stb, cpu_stb }), .i_mwe({ simw_we, dmac_we, cpu_we }), .i_maddr({ simw_addr[ADDRESS_WIDTH-WBLSB-1:0], dmac_addr, cpu_addr }), .i_mdata({ simw_data, dmac_data, cpu_data }), .i_msel({ simw_sel, dmac_sel, cpu_sel }), .o_mstall({ simw_stall, dmac_stall,cpu_stall }), .o_mack({ simw_ack, dmac_ack, cpu_ack }), .o_mdata({ simw_idata, dmac_return,cpu_idata }), .o_merr({ simw_err, dmac_err, cpu_err }), `else // With no external CPU",
            "input , there is no simulation port .i_mcyc({ dmac_cyc, cpu_cyc }), .i_mstb({ dmac_stb, cpu_stb }), .i_mwe({ dmac_we, cpu_we }), .i_maddr({ dmac_addr, cpu_addr }), .i_mdata({ dmac_data, cpu_data }), .i_msel({ dmac_sel, cpu_sel }), .o_mstall({ dmac_stall, cpu_stall }), .o_mack({ dmac_ack, cpu_ack }), .o_mdata({ dmac_return, cpu_idata }), .o_merr({ dmac_err, cpu_err }), `endif // }}} // Master port ... to control the slaves w/in this design // {{{ .o_scyc({ zsysw_cyc, smpw_cyc, zdmacstw_cyc, zdmacw_cyc, conw_cyc, scopew_cyc, mem_cyc }), .o_sstb({ zsysw_stb, smpw_stb, zdmacstw_stb, zdmacw_stb, conw_stb, scopew_stb, mem_stb }), .o_swe({ zsysw_we, smpw_we, zdmacstw_we, zdmacw_we, conw_we, scopew_we, mem_we }), .o_saddr({ zsysw_addr, smpw_addr, zdmacstw_addr, zdmacw_addr, conw_addr, scopew_addr, mem_addr }), .o_sdata({ zsysw_data, smpw_data, zdmacstw_data, zdmacw_data, conw_data, scopew_data, mem_data }), .o_ssel({ zsysw_sel, smpw_sel, zdmacstw_sel, zdmacw_sel, conw_sel, scopew_sel, mem_sel }), // .i_sstall({ zsysw_stall,smpw_stall, zdmacstw_stall, zdmacw_stall, conw_stall, scopew_stall, mem_stall }), .i_sack({ zsysw_ack, smpw_ack, zdmacstw_ack, zdmacw_ack, conw_ack, scopew_ack, mem_ack }), .i_sdata({ zsysw_idata,smpw_idata, zdmacstw_idata, zdmacw_idata, conw_idata, scopew_idata, mem_idata }), .i_serr({ zsysw_err, smpw_err, zdmacstw_err, zdmacw_err, conw_err, scopew_err, mem_err }) // }}} // }}} ); // }}} //////////////////////////////////////////////////////////////////////// // // Memory // {{{ //////////////////////////////////////////////////////////////////////// // // memdev #( // {{{ .LGMEMSZ(LGMEMSZ), .DW(BUS_WIDTH), .HEXFILE(MEM_FILE), .OPT_ROM(1'b0) // }}} ) u_mem ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_wb_cyc(mem_cyc), .i_wb_stb(mem_stb), .i_wb_we(mem_we), .i_wb_addr(mem_addr[LGMEMSZ-WBLSB-1:0]), .i_wb_data(mem_data), .i_wb_sel(mem_sel), .o_wb_stall(mem_stall), .o_wb_ack(mem_ack), .o_wb_data(mem_idata) // }}} );",
            "assign mem_err = 1'b0; // }}} //////////////////////////////////////////////////////////////////////// // // Console // {{{ //////////////////////////////////////////////////////////////////////// // // reg con_write_en;",
            "reg [7:0] con_write_byte; integer sim_console; wbdown #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH-3), .WIDE_DW(BUS_WIDTH), .SMALL_DW(32) // }}} ) u_condown ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // The \"Wide\" connection // {{{ .i_wcyc(conw_cyc), .i_wstb(conw_stb), .i_wwe(conw_we), .i_waddr(conw_addr[WAW-4:0]), .i_wdata(conw_data), .i_wsel(conw_sel), // .o_wstall(conw_stall), .o_wack(conw_ack), .o_wdata(conw_idata), .o_werr(conw_err), // }}} // The downsized connection // {{{ .o_cyc(con_cyc), .o_stb(con_stb), .o_we(con_we), .o_addr(con_addr), .o_data(con_data), .o_sel(con_sel), // .i_stall(con_stall), .i_ack(con_ack), .i_data(con_idata), .i_err(con_err) // }}} // }}} );",
            "assign con_stall = 1'b0;",
            "initial r_con_ack = 1'b0;",
            "always @(posedge i_clk) r_con_ack <= !i_reset && con_stb;",
            "assign con_ack = r_con_ack;",
            "initial begin sim_console = $fopen(CONSOLE_FILE); end // Make sure we can read the outgoing console data from the trace",
            "initial con_write_en = 1'b0;",
            "always @(posedge i_clk) if (i_reset) con_write_en <= 1'b0; else if (con_stb && con_we && con_addr[1:0] == 2'b11 && con_sel[0]) con_write_en <= 1'b1; else con_write_en <= 1'b0;",
            "initial con_write_byte = 8'h0;",
            "always @(posedge i_clk) if (con_stb && con_we && con_addr[1:0] == 2'b11 && con_sel[0]) con_write_byte <= con_data[7:0];",
            "always @(posedge i_clk) if (!i_reset && con_write_en) begin $fwrite(sim_console, \"%1s\", con_write_byte); $write(\"%1s\", con_write_byte); end",
            "assign con_idata = 32'h0;",
            "assign con_err = 1'b0; // }}} //////////////////////////////////////////////////////////////////////// // // Artificial ZipCPU System components, for when running with ZipBones // {{{ //////////////////////////////////////////////////////////////////////// // // wbdown #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH-4), .WIDE_DW(BUS_WIDTH), .SMALL_DW(32) // }}} ) u_zsysdown ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // The \"Wide\" connection // {{{ .i_wcyc(zsysw_cyc), .i_wstb(zsysw_stb), .i_wwe(zsysw_we), .i_waddr(zsysw_addr[WAW-5:0]), .i_wdata(zsysw_data), .i_wsel(zsysw_sel), // .o_wstall(zsysw_stall), .o_wack(zsysw_ack), .o_wdata(zsysw_idata), .o_werr(zsysw_err), // }}} // The downsized connection // {{{ .o_cyc(zsys_cyc), .o_stb(zsys_stb), .o_we(zsys_we), .o_addr(zsys_addr), .o_data(zsys_data), .o_sel(zsys_sel), // .i_stall(zsys_stall), .i_ack(zsys_ack), .i_data(zsys_idata), .i_err(zsys_err) // }}} // }}} );",
            "initial zsys_stb_d = 1'b0;",
            "always @(posedge i_clk) zsys_stb_d <= !i_reset && zsys_stb;",
            "always @(posedge i_clk) zsys_addr_d <= zsys_addr;",
            "assign zsys_stall = 1'b0;",
            "initial r_zsys_ack = 1'b0;",
            "always @(posedge i_clk) r_zsys_ack <= !i_reset && zsys_stb_d;",
            "assign zsys_ack = r_zsys_ack;",
            "assign zsys_idata = 32'h0;",
            "assign zsys_err = 1'b0; // SMP[0] Master counters // {{{ zipcounter mtask_ctr ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_event(!cpu_halted[0]), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h8), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .o_wb_stall(ign_mtc_stall), .o_wb_ack(ign_mtc_ack), .o_wb_data(mtc_data), .o_int(mtc_int) // }}} ); /* zipcounter mmstall_ctr ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_event(!halt), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h8), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .o_wb_stall(ign_mtc_stall), .o_wb_ack(ign_mtc_ack), .o_wb_data(mtc_data), .o_int(mtc_int) // }}} ); */",
            "assign { ign_moc_ack, ign_moc_stall, moc_int, moc_data } = 35'h0; /* zipcounter mpstall_ctr ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_event(!halt), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h8), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .o_wb_stall(ign_mtc_stall), .o_wb_ack(ign_mtc_ack), .o_wb_data(mtc_data), .o_int(mtc_int) // }}} ); */",
            "assign { ign_mpc_ack, ign_mpc_stall, mpc_int, mpc_data } = 35'h0; zipcounter mins_ctr ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_event(cpu_i_count[0]), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'hb), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .o_wb_stall(ign_mic_stall), .o_wb_ack(ign_mic_ack), .o_wb_data(mic_data), .o_int(mic_int) // }}} ); // }}} // SMP[0] User counters // {{{ zipcounter utask_ctr ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_event(!cpu_halted[0]), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'hc), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .o_wb_stall(ign_utc_stall), .o_wb_ack(ign_utc_ack), .o_wb_data(utc_data), .o_int(utc_int) // }}} ); /* zipcounter umstall_ctr ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_event(cpu_op_stall[0]), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'hd), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .o_wb_stall(ign_uoc_stall), .o_wb_ack(ign_uoc_ack), .o_wb_data(uoc_data), .o_int(uoc_int) // }}} ); */",
            "assign { ign_uoc_ack, ign_uoc_stall, uoc_int, uoc_data } = 35'h0; /* zipcounter mpstall_ctr ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_event(cpu_pf_stall[0]), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'he), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .o_wb_stall(ign_mpc_stall), .o_wb_ack(ign_mpc_ack), .o_wb_data(mpc_data), .o_int(mpc_int) // }}} ); */",
            "assign { ign_upc_ack, ign_upc_stall, upc_int, upc_data } = 35'h0; zipcounter uins_ctr ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_event(cpu_gie[0] && cpu_i_count[0]), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'hf), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .o_wb_stall(ign_uic_stall), .o_wb_ack(ign_uic_ack), .o_wb_data(uic_data), .o_int(uic_int) // }}} ); // }}}",
            "always @(posedge i_clk) if (zsys_stb_d) begin r_zsys_data <= 32'h0; case(zsys_addr_d) 0: r_zsys_data <= pic_data; // PIC 1: begin end // Watchdog 2: begin end // APIC 3: begin end // Bus Watchdog 4: r_zsys_data <= timer_a_data; // Timer A 5: r_zsys_data <= timer_b_data; // Timer B 6: r_zsys_data <= timer_c_data; // Timer C 7: r_zsys_data <= jiffies_data; // Jiffies 8: r_zsys_data <= mtc_data; 9: r_zsys_data <= moc_data; 10: r_zsys_data <= mpc_data; 11: r_zsys_data <= mic_data; 12: r_zsys_data <= utc_data; 13: r_zsys_data <= uoc_data; 14: r_zsys_data <= upc_data; 15: r_zsys_data <= uic_data; 16: r_zsys_data <= dma_slv_data; 17: r_zsys_data <= dma_slv_data; 18: r_zsys_data <= dma_slv_data; 19: r_zsys_data <= dma_slv_data; endcase end else r_zsys_data <= 32'h0;",
            "assign zsys_idata = r_zsys_data; icontrol #( .IUSED(16) ) u_pic ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h0), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .i_wb_sel(zsys_sel), .o_wb_stall(pic_stall), .o_wb_ack(pic_ack), .o_wb_data(pic_data), .i_brd_ints({ 9'h0, i_sim_int, 1'b0, timer_a_int, timer_b_int, timer_c_int, jiffies_int, dmac_int }), .o_interrupt(pic_int) // }}} ); ziptimer u_timer_a ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_ce(1'b1), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h4), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .i_wb_sel(zsys_sel), .o_wb_stall(timer_a_stall), .o_wb_ack(timer_a_ack), .o_wb_data(timer_a_data), .o_int(timer_a_int) // }}} ); ziptimer u_timer_b ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_ce(1'b1), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h5), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .i_wb_sel(zsys_sel), .o_wb_stall(timer_b_stall), .o_wb_ack(timer_b_ack), .o_wb_data(timer_b_data), .o_int(timer_b_int) // }}} ); ziptimer u_timer_c ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_ce(1'b1), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h6), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .i_wb_sel(zsys_sel), .o_wb_stall(timer_c_stall), .o_wb_ack(timer_c_ack), .o_wb_data(timer_c_data), .o_int(timer_c_int) // }}} ); zipjiffies u_jiffies ( // {{{ .i_clk(i_clk), .i_reset(i_reset), .i_ce(1'b1), .i_wb_cyc(zsys_cyc), .i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h7), .i_wb_we(zsys_we), .i_wb_data(zsys_data), .i_wb_sel(zsys_sel), .o_wb_stall(jiffies_stall), .o_wb_ack(jiffies_ack), .o_wb_data(jiffies_data), .o_int(jiffies_int) // }}} ); generate if (OPT_ZIPBONES && OPT_DMA) begin : GEN_BONES_DMA // {{{",
            "localparam DMA_LGMEM = 10;",
            "wire ign_dmac_stall, ign_dmac_ack;",
            "wire [31:0] dmac_int_vec;",
            "assign dmac_int_vec = { 16'h0, 9'h0, i_sim_int, 1'b0, timer_a_int, timer_b_int, timer_c_int, jiffies_int, 1'b0 }; zipdma #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH), .LGMEMLEN(DMA_LGMEM), .BUS_WIDTH(BUS_WIDTH), .OPT_LITTLE_ENDIAN(1'b1) // }}} ) u_dma ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // Slave port // {{{ .i_swb_cyc(zsys_cyc), .i_swb_stb(zsys_stb && zsys_addr[4:2]== 3'b100), .i_swb_we(zsys_we), .i_swb_addr(zsys_addr[1:0]), .i_swb_data(zsys_data), .i_swb_sel(zsys_sel), .o_swb_stall(ign_dmac_stall), .o_swb_ack(ign_dmac_ack), .o_swb_data(dma_slv_data), // }}} .o_mwb_cyc(dmac_cyc), .o_mwb_stb(dmac_stb), .o_mwb_we(dmac_we), .o_mwb_addr(dmac_addr), .o_mwb_data(dmac_data), .o_mwb_sel(dmac_sel), .i_mwb_stall(dmac_stall), .i_mwb_ack(dmac_ack), .i_mwb_data(dmac_return), .i_mwb_err(dmac_err), .i_dev_ints(dmac_int_vec), .o_interrupt(dmac_int) // }}} ); // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_dmac;",
            "assign unused_dmac = &{ 1'b0, ign_dmac_stall, ign_dmac_ack }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} // }}} end else begin : NO_EXTERNAL_DMA",
            "assign dmac_int = 1'b0;",
            "assign dma_slv_data = 0;",
            "assign { dmac_cyc, dmac_stb, dmac_we } = 3'h0;",
            "assign dmac_addr = 0;",
            "assign dmac_data = 0;",
            "assign dmac_sel = 0; end endgenerate // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_zsys;",
            "assign unused_zsys = &{ 1'b0, pic_stall, pic_ack, timer_a_stall, timer_a_ack, timer_b_stall, timer_b_ack, timer_c_stall, timer_c_ack, jiffies_stall, jiffies_ack }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} // }}} //////////////////////////////////////////////////////////////////////// // // (Optional) WB Scope // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_TRACE_PORT) begin : GEN_WBSCOPE // {{{",
            "wire scope_cyc, scope_stb, scope_we; // Verilator lint_off UNUSED",
            "wire [ADDRESS_WIDTH-3-$clog2(32/8)-1:0] scope_addr; // Verilator lint_on UNUSED",
            "wire [31:0] scope_data, scope_idata;",
            "wire [3:0] scope_sel;",
            "wire scope_stall, scope_ack, scope_err; wbdown #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH-3), .WIDE_DW(BUS_WIDTH), .SMALL_DW(32) // }}} ) u_scopedown ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // The \"Wide\" connection // {{{ .i_wcyc(scopew_cyc), .i_wstb(scopew_stb), .i_wwe(scopew_we), .i_waddr(scopew_addr[WAW-4:0]), .i_wdata(scopew_data), .i_wsel(scopew_sel), // .o_wstall(scopew_stall), .o_wack(scopew_ack), .o_wdata(scopew_idata), .o_werr(scopew_err), // }}} // The downsized connection // {{{ .o_cyc(scope_cyc), .o_stb(scope_stb), .o_we(scope_we), .o_addr(scope_addr), .o_data(scope_data), .o_sel(scope_sel), // .i_stall(scope_stall), .i_ack(scope_ack), .i_data(scope_idata), .i_err(scope_err) // }}} // }}} ); wbscope #( .LGMEM(12) ) u_scope ( // {{{ .i_data_clk(i_clk), .i_trigger(1'b0), .i_ce(1'b1), .i_data(cpu_trace), // .i_wb_clk(i_clk), .i_wb_cyc(scope_cyc), .i_wb_stb(scope_stb), .i_wb_we(scope_we), .i_wb_addr(scope_addr[0]), .i_wb_data(scope_data), .i_wb_sel(scope_sel), // .o_wb_stall(scope_stall), .o_wb_ack(scope_ack), .o_wb_data(scope_idata), // .o_interrupt(scope_int) // }}} );",
            "assign scope_err = 1'b0; // }}} end else begin : NO_SCOPE // {{{",
            "reg r_scope_ack;",
            "initial r_scope_ack = 1'b0;",
            "always @(posedge i_clk) r_scope_ack <= scopew_stb && !i_reset;",
            "assign scopew_stall = 1'b0;",
            "assign scopew_ack = r_scope_ack;",
            "assign scopew_idata = {(BUS_WIDTH){1'b0}};",
            "assign scopew_err = 1'b0;",
            "assign scope_int = 1'b0; // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_scope;",
            "assign unused_scope = &{ 1'b0, scopew_cyc, scopew_we, scopew_data, scopew_sel, cpu_trace }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // (Optional) ZIPDMA_Check // {{{ //////////////////////////////////////////////////////////////////////// // // wbdown #( // {{{ .ADDRESS_WIDTH(ADDRESS_WIDTH-3), .WIDE_DW(BUS_WIDTH), .SMALL_DW(32) // }}} ) u_zdmacstdown ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // The \"Wide\" connection // {{{ .i_wcyc(zdmacstw_cyc), .i_wstb(zdmacstw_stb), .i_wwe(zdmacstw_we), .i_waddr(zdmacstw_addr[WAW-4:0]), .i_wdata(zdmacstw_data), .i_wsel(zdmacstw_sel), // .o_wstall(zdmacstw_stall), .o_wack(zdmacstw_ack), .o_wdata(zdmacstw_idata), .o_werr(zdmacstw_err), // }}} // The downsized connection // {{{ .o_cyc(zdmacst_cyc), .o_stb(zdmacst_stb), .o_we(zdmacst_we), .o_addr(zdmacst_addr), .o_data(zdmacst_data), .o_sel(zdmacst_sel), // .i_stall(zdmacst_stall), .i_ack(zdmacst_ack), .i_data(zdmacst_idata), .i_err(zdmacst_err) // }}} ); zipdma_check #( .ADDRESS_WIDTH(ADDRESS_WIDTH), .BUS_WIDTH(BUS_WIDTH) ) u_zipdma_check ( // {{{ .i_clk(i_clk), .i_reset(i_reset), // mm2s, s2mm .i_wb_cyc(zdmacw_cyc), .i_wb_stb(zdmacw_stb), .i_wb_we(zdmacw_we), .i_wb_addr(zdmacw_addr), .i_wb_data(zdmacw_data), .i_wb_sel(zdmacw_sel), // .o_wb_stall(zdmacw_stall), .o_wb_ack(zdmacw_ack), .o_wb_data(zdmacw_idata), .o_wb_err(zdmacw_err), // status .i_st_cyc(zdmacst_cyc), .i_st_stb(zdmacst_stb), .i_st_we(zdmacst_we), .i_st_addr(zdmacst_addr[0]), .i_st_data(zdmacst_data), .i_st_sel(zdmacst_sel), // .o_st_stall(zdmacst_stall), .o_st_ack(zdmacst_ack), .o_st_data(zdmacst_idata), .o_st_err(zdmacst_err) // }}} ); // }}} // }}} //////////////////////////////////////////////////////////////////////// // // (Optional) VCD generation // {{{ //////////////////////////////////////////////////////////////////////// // // `ifndef VERILATOR",
            "initial if (DUMP_TO_VCD) begin $dumpfile(VCD_FILE); $dumpvars(0, wb_tb); end `endif // }}} //////////////////////////////////////////////////////////////////////// // // Test bench watchdog // {{{",
            "localparam TB_WATCHDOG_TIMEOUT = 1_000_00; // 1ms",
            "reg [$clog2(TB_WATCHDOG_TIMEOUT+2)-1:0] watchdog_counter;",
            "initial watchdog_counter = 0;",
            "always @(posedge i_clk) // if (i_reset) // watchdog_counter <= 0; // else if (|(cpu_stb & ~cpu_stall)) watchdog_counter <= 0; else watchdog_counter <= watchdog_counter + 1;",
            "always @(posedge i_clk) if (watchdog_counter > TB_WATCHDOG_TIMEOUT) begin $display(\"\\nERROR: Watchdog timeout!\"); $finish; end",
            "always @(posedge i_clk) if (!i_reset && cpu_int[0]) $display(\"\\nCPU Halted without error: PASS\\n\"); // }}} // Keep Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, DUMP_TO_VCD, VCD_FILE, conw_addr, scopew_addr, zsysw_addr, zsysw_addr, `ifdef VERILATOR simw_addr, `endif con_addr, zsys_addr, mem_addr, dbg_addr, con_cyc, con_data[31:8], con_sel[3:1], timer_a_int, timer_b_int, timer_c_int, jiffies_int, timer_a_ack, timer_b_ack, timer_c_ack, jiffies_ack, timer_a_stall, timer_b_stall, timer_c_stall, jiffies_stall, scope_int, zdmacst_addr[ADDRESS_WIDTH-3-$clog2(32/8)-1:1], zdmacstw_addr[ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)-1-:3] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "axilempty.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axilempty.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/axilempty.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Modifies the simple AXI-lite interface to be an empty shell // // This is useful for a bus with masters but no slaves. When used, // the interconnect can connect those masters to this slave to know // that requests will still be properly handled--and get proper error // returns. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2020-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module axilempty #( // {{{ // // Size of the AXI-lite bus. These are fixed, since 1) AXI-lite // is fixed at a width of 32-bits by Xilinx def'n, and 2) since // we only ever have 4 configuration words. // Verilator lint_off UNUSED",
            "parameter C_AXI_ADDR_WIDTH = 4, // Verilator lint_on UNUSED",
            "localparam C_AXI_DATA_WIDTH = 32, parameter [0:0] OPT_SKIDBUFFER = 1'b0, parameter [0:0] OPT_LOWPOWER = 0 // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, // input wire S_AXI_AWVALID, output wire S_AXI_AWREADY, // input wire S_AXI_WVALID, output wire S_AXI_WREADY, // output wire S_AXI_BVALID, input wire S_AXI_BREADY, output wire [1:0] S_AXI_BRESP, // input wire S_AXI_ARVALID, output wire S_AXI_ARREADY, // output wire S_AXI_RVALID, input wire S_AXI_RREADY, output wire [C_AXI_DATA_WIDTH-1:0] S_AXI_RDATA, output wire [1:0] S_AXI_RRESP // }}} ); //////////////////////////////////////////////////////////////////////// // // Register/",
            "wire signal declarations // //////////////////////////////////////////////////////////////////////// // // {{{",
            "wire i_reset = !S_AXI_ARESETN;",
            "wire axil_write_ready; // reg axil_bvalid; // wire axil_read_ready;",
            "reg axil_read_valid; //////////////////////////////////////////////////////////////////////// // // AXI-lite signaling // //////////////////////////////////////////////////////////////////////// // // {{{ // // Write signaling // // {{{ generate if (OPT_SKIDBUFFER) begin : SKIDBUFFER_WRITE",
            "wire awskd_valid, wskd_valid, awskd_unused, wskd_unused; skidbuffer #(.OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(1)) axilawskid(// .i_clk(S_AXI_ACLK), .i_reset(i_reset), .i_valid(S_AXI_AWVALID), .o_ready(S_AXI_AWREADY), .i_data(1'b0), .o_valid(awskd_valid), .i_ready(axil_write_ready), .o_data(awskd_unused)); `ifdef FORMAL",
            "always @(*) if (awskd_valid) assert(awskd_unused == 0); `endif skidbuffer #(.OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(1)) axilwskid(// .i_clk(S_AXI_ACLK), .i_reset(i_reset), .i_valid(S_AXI_WVALID), .o_ready(S_AXI_WREADY), .i_data({ 1'b0 }), .o_valid(wskd_valid), .i_ready(axil_write_ready), .o_data(wskd_unused)); `ifdef FORMAL",
            "always @(*) if (wskd_valid) assert(wskd_unused == 0); `endif",
            "assign axil_write_ready = awskd_valid && wskd_valid && (!S_AXI_BVALID || S_AXI_BREADY); // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, awskd_unused, wskd_unused }; // Verilator lint_on UNUSED end else begin : SIMPLE_WRITES",
            "reg axil_awready;",
            "initial axil_awready = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axil_awready <= 1'b0; else axil_awready <= !axil_awready && (S_AXI_AWVALID && S_AXI_WVALID) && (!S_AXI_BVALID || S_AXI_BREADY);",
            "assign S_AXI_AWREADY = axil_awready;",
            "assign S_AXI_WREADY = axil_awready;",
            "assign axil_write_ready = axil_awready; end endgenerate",
            "initial axil_bvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (i_reset) axil_bvalid <= 0; else if (axil_write_ready) axil_bvalid <= 1; else if (S_AXI_BREADY) axil_bvalid <= 0;",
            "assign S_AXI_BVALID = axil_bvalid;",
            "assign S_AXI_BRESP = 2'b11; // }}} // // Read signaling // // {{{ generate if (OPT_SKIDBUFFER) begin : SKIDBUFFER_READ",
            "wire arskd_valid, arskd_unused; skidbuffer #(.OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(1)) axilarskid(// .i_clk(S_AXI_ACLK), .i_reset(i_reset), .i_valid(S_AXI_ARVALID), .o_ready(S_AXI_ARREADY), .i_data( 1'b0 ), .o_valid(arskd_valid), .i_ready(axil_read_ready), .o_data(arskd_unused));",
            "assign axil_read_ready = arskd_valid && (!axil_read_valid || S_AXI_RREADY); `ifdef FORMAL",
            "always @(*) if (arskd_valid) assert(arskd_unused == 0); `endif // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, arskd_unused }; // Verilator lint_on UNUSED end else begin : SIMPLE_READS",
            "reg axil_arready;",
            "always @(*) axil_arready = !S_AXI_RVALID;",
            "assign S_AXI_ARREADY = axil_arready;",
            "assign axil_read_ready = (S_AXI_ARVALID && S_AXI_ARREADY); end endgenerate",
            "initial axil_read_valid = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (i_reset) axil_read_valid <= 1'b0; else if (axil_read_ready) axil_read_valid <= 1'b1; else if (S_AXI_RREADY) axil_read_valid <= 1'b0;",
            "assign S_AXI_RVALID = axil_read_valid;",
            "assign S_AXI_RDATA = 0;",
            "assign S_AXI_RRESP = 2'b11; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // AXI-lite",
            "reg ister",
            "logic // //////////////////////////////////////////////////////////////////////// // // {{{ // }}} // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0 }; // Verilator lint_on UNUSED // }}} `ifdef FORMAL //////////////////////////////////////////////////////////////////////// // // Formal properties used in verfiying this core // //////////////////////////////////////////////////////////////////////// // // {{{",
            "reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge S_AXI_ACLK) f_past_valid <= 1; //////////////////////////////////////////////////////////////////////// // // The AXI-lite control interface // //////////////////////////////////////////////////////////////////////// // // {{{",
            "localparam F_AXIL_LGDEPTH = 4;",
            "wire [F_AXIL_LGDEPTH-1:0] faxil_rd_outstanding, faxil_wr_outstanding, faxil_awr_outstanding; faxil_slave #( // {{{ .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH), .F_LGDEPTH(F_AXIL_LGDEPTH), .F_AXI_MAXWAIT(2), .F_AXI_MAXDELAY(2), .F_AXI_MAXRSTALL(3), .F_OPT_COVER_BURST(0) // }}} ) faxil( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // .i_axi_awvalid(S_AXI_AWVALID), .i_axi_awready(S_AXI_AWREADY), .i_axi_awaddr({(C_AXI_ADDR_WIDTH){1'b0}}), .i_axi_awprot( 3'h0), // .i_axi_wvalid(S_AXI_WVALID), .i_axi_wready(S_AXI_WREADY), .i_axi_wdata( {(C_AXI_DATA_WIDTH){1'b0}}), .i_axi_wstrb( {(C_AXI_DATA_WIDTH/8){1'b0}}), // .i_axi_bvalid(S_AXI_BVALID), .i_axi_bready(S_AXI_BREADY), .i_axi_bresp( S_AXI_BRESP), // .i_axi_arvalid(S_AXI_ARVALID), .i_axi_arready(S_AXI_ARREADY), .i_axi_araddr( {(C_AXI_ADDR_WIDTH){1'b0}}), .i_axi_arprot( 3'h0), // .i_axi_rvalid(S_AXI_RVALID), .i_axi_rready(S_AXI_RREADY), .i_axi_rdata( S_AXI_RDATA), .i_axi_rresp( S_AXI_RRESP), // .f_axi_rd_outstanding(faxil_rd_outstanding), .f_axi_wr_outstanding(faxil_wr_outstanding), .f_axi_awr_outstanding(faxil_awr_outstanding) // }}} );",
            "always @(*) if (OPT_SKIDBUFFER) begin assert(faxil_awr_outstanding== (S_AXI_BVALID ? 1:0) +(S_AXI_AWREADY ? 0:1)); assert(faxil_wr_outstanding == (S_AXI_BVALID ? 1:0) +(S_AXI_WREADY ? 0:1)); assert(faxil_rd_outstanding == (S_AXI_RVALID ? 1:0) +(S_AXI_ARREADY ? 0:1)); end else begin assert(faxil_wr_outstanding == (S_AXI_BVALID ? 1:0)); assert(faxil_awr_outstanding == faxil_wr_outstanding); assert(faxil_rd_outstanding == (S_AXI_RVALID ? 1:0)); end // // Check that our low-power only",
            "logic works by verifying that anytime // S_AXI_RVALID is inactive, then the outgoing data is also zero. // always @(*) assert(S_AXI_RDATA == 0);",
            "always @(*) assert(S_AXI_RRESP == 2'b11);",
            "always @(*) assert(S_AXI_BRESP == 2'b11); // }}} //////////////////////////////////////////////////////////////////////// // // Cover checks // //////////////////////////////////////////////////////////////////////// // // {{{ // While there are already cover properties in the formal property // set above, you'll probably still want to cover something // application specific here // }}} // }}} `endif",
            "endmodule"
        ]
    },
    {
        "file_name": "axi2axilsub.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axi2axilsub.v",
        "chunks": [
            "/////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/axi2axilsub.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Convert from AXI to AXI-lite with no performance loss, and to // a potentially smaller bus width. // // Performance: The goal of this converter is to convert from AXI to an AXI-lite // bus of a smaller width, while still maintaining the one-clock // per transaction speed of AXI. It currently achieves this goal. The // design needs very little configuration to be useful, but you might // wish to resize the FIFOs within depending upon the length of your // slave's data path. The current FIFO length, LGFIFO=4, is sufficient to // maintain full speed. If the slave, however, can maintain full speed but // requires a longer processing cycle, then you may need longer FIFOs. // // The AXI specification does require an additional 2 clocks per // transaction when using this core, so your latency will go up. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2019-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // `ifdef FORMAL `ifdef BMC `define BMC_ASSERT assert `else `define BMC_ASSERT assume `endif `endif // // }}}",
            "module axi2axilsub #( // {{{",
            "parameter integer C_AXI_ID_WIDTH = 2, parameter integer C_S_AXI_DATA_WIDTH = 64, parameter integer C_M_AXI_DATA_WIDTH = 32, parameter integer C_AXI_ADDR_WIDTH = 6, parameter [0:0] OPT_LOWPOWER = 1, parameter [0:0] OPT_WRITES = 1, parameter [0:0] OPT_READS = 1, parameter SLVSZ = $clog2(C_S_AXI_DATA_WIDTH/8), parameter MSTSZ = $clog2(C_M_AXI_DATA_WIDTH/8), // Log (based two) of the maximum number of outstanding AXI // (not AXI-lite) transactions. If you multiply 2^LGFIFO * 256, // you'll get the maximum number of outstanding AXI-lite // transactions",
            "parameter LGFIFO = 4 // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, // AXI4 slave interface // {{{ // Write address channel // {{{",
            "input wire S_AXI_AWVALID, output wire S_AXI_AWREADY, input wire [C_AXI_ID_WIDTH-1:0] S_AXI_AWID, input wire [C_AXI_ADDR_WIDTH-1:0] S_AXI_AWADDR, input wire [7:0] S_AXI_AWLEN, input wire [2:0] S_AXI_AWSIZE, input wire [1:0] S_AXI_AWBURST, input wire S_AXI_AWLOCK, input wire [3:0] S_AXI_AWCACHE, input wire [2:0] S_AXI_AWPROT, input wire [3:0] S_AXI_AWQOS, // }}} // Write data channel // {{{",
            "input wire S_AXI_WVALID, output wire S_AXI_WREADY, input wire [C_S_AXI_DATA_WIDTH-1:0] S_AXI_WDATA, input wire [(C_S_AXI_DATA_WIDTH/8)-1:0] S_AXI_WSTRB, input wire S_AXI_WLAST, // }}} // Write return channel // {{{",
            "output wire S_AXI_BVALID, input wire S_AXI_BREADY, output wire [C_AXI_ID_WIDTH-1:0] S_AXI_BID, output wire [1:0] S_AXI_BRESP, // }}} // Read address channel // {{{",
            "input wire S_AXI_ARVALID, output wire S_AXI_ARREADY, input wire [C_AXI_ID_WIDTH-1:0] S_AXI_ARID, input wire [C_AXI_ADDR_WIDTH-1:0] S_AXI_ARADDR, input wire [7:0] S_AXI_ARLEN, input wire [2:0] S_AXI_ARSIZE, input wire [1:0] S_AXI_ARBURST, input wire S_AXI_ARLOCK, input wire [3:0] S_AXI_ARCACHE, input wire [2:0] S_AXI_ARPROT, input wire [3:0] S_AXI_ARQOS, // }}} // Read data channel // {{{",
            "output wire S_AXI_RVALID, input wire S_AXI_RREADY, output wire [C_AXI_ID_WIDTH-1:0] S_AXI_RID, output wire [C_S_AXI_DATA_WIDTH-1:0] S_AXI_RDATA, output wire [1:0] S_AXI_RRESP, output wire S_AXI_RLAST, // }}} // }}} // AXI-lite master interface // {{{ // AXI-lite Write interface // {{{",
            "output wire [C_AXI_ADDR_WIDTH-1:0] M_AXI_AWADDR, output wire [2 : 0] M_AXI_AWPROT, output wire M_AXI_AWVALID, input wire M_AXI_AWREADY, output wire [C_M_AXI_DATA_WIDTH-1:0] M_AXI_WDATA, output wire [(C_M_AXI_DATA_WIDTH/8)-1:0] M_AXI_WSTRB, output wire M_AXI_WVALID, input wire M_AXI_WREADY, input wire [1 : 0] M_AXI_BRESP, input wire M_AXI_BVALID, output wire M_AXI_BREADY, // }}} // AXI-lite read interface // {{{",
            "output wire [C_AXI_ADDR_WIDTH-1:0] M_AXI_ARADDR, output wire [2:0] M_AXI_ARPROT, output wire M_AXI_ARVALID, input wire M_AXI_ARREADY, // input wire M_AXI_RVALID, output wire M_AXI_RREADY, input wire [C_M_AXI_DATA_WIDTH-1 : 0] M_AXI_RDATA, input wire [1 : 0] M_AXI_RRESP // }}} // }}} // }}} ); // Local",
            "parameter s, reg ister, and net declarations // {{{ // Verilator lint_off UNUSED",
            "localparam [1:0] OKAY = 2'b00, EXOKAY = 2'b01, SLVERR = 2'b10; // localparam [1:0] DECERR = 2'b10; // Verilator lint_on UNUSED",
            "localparam AW = C_AXI_ADDR_WIDTH;",
            "localparam SLVDW = C_S_AXI_DATA_WIDTH;",
            "localparam MSTDW = C_M_AXI_DATA_WIDTH;",
            "localparam IW = C_AXI_ID_WIDTH; // localparam LSB = $clog2(C_AXI_DATA_WIDTH)-3; // }}} // Register declarations // {{{ // // }}} //////////////////////////////////////////////////////////////////////// // // Write",
            "logic // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_WRITES && SLVDW == MSTDW) begin : IMPLEMENT_AXI2AXILITE_WRITES // {{{ // (Unused) signal declarations // {{{ // Verilator lint_off UNUSED",
            "wire ign_arready, ign_rvalid, ign_rlast, ign_arvalid, ign_rready;",
            "wire [IW-1:0] ign_rid;",
            "wire [SLVDW-1:0] ign_rdata;",
            "wire [1:0] ign_rresp;",
            "wire [AW-1:0] ign_araddr;",
            "wire [2:0] ign_arprot; // Verilator lint_on UNUSED // }}} axi2axilite #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_DATA_WIDTH(SLVDW), .C_AXI_ADDR_WIDTH(AW), .OPT_WRITES(1), .OPT_READS(0), .LGFIFO(LGFIFO) // }}} ) axilwrite ( // {{{ .S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN), // AXI4 slave interface // {{{ // Write address channel // {{{ .S_AXI_AWVALID(S_AXI_AWVALID), .S_AXI_AWREADY(S_AXI_AWREADY), .S_AXI_AWID( S_AXI_AWID), .S_AXI_AWADDR( S_AXI_AWADDR), .S_AXI_AWLEN( S_AXI_AWLEN), .S_AXI_AWSIZE( S_AXI_AWSIZE), .S_AXI_AWBURST(S_AXI_AWBURST), .S_AXI_AWLOCK( S_AXI_AWLOCK), .S_AXI_AWCACHE(S_AXI_AWCACHE), .S_AXI_AWPROT( S_AXI_AWPROT), .S_AXI_AWQOS( S_AXI_AWQOS), // }}} // Write data channel // {{{ .S_AXI_WVALID(S_AXI_WVALID), .S_AXI_WREADY(S_AXI_WREADY), .S_AXI_WDATA( S_AXI_WDATA), .S_AXI_WSTRB( S_AXI_WSTRB), .S_AXI_WLAST( S_AXI_WLAST), // }}} // Write return channel // {{{ .S_AXI_BVALID(S_AXI_BVALID), .S_AXI_BREADY(S_AXI_BREADY), .S_AXI_BID( S_AXI_BID), .S_AXI_BRESP( S_AXI_BRESP), // }}} // Read address channel // {{{ .S_AXI_ARVALID(1'b0), .S_AXI_ARREADY(ign_arready), .S_AXI_ARID( {(IW){1'b0}}), .S_AXI_ARADDR( {(AW){1'b0}}), .S_AXI_ARLEN( 8'h0), .S_AXI_ARSIZE( 3'h0), .S_AXI_ARBURST(2'h0), .S_AXI_ARLOCK( 1'b0), .S_AXI_ARCACHE(4'h0), .S_AXI_ARPROT( 3'h0), .S_AXI_ARQOS( 4'h0), // }}} // Read data channel // {{{ .S_AXI_RVALID(ign_rvalid), .S_AXI_RREADY(1'b1), .S_AXI_RID( ign_rid), .S_AXI_RDATA( ign_rdata), .S_AXI_RRESP( ign_rresp), .S_AXI_RLAST( ign_rlast), // }}} // }}} // AXI-lite master interface // {{{ // AXI-lite Write interface // {{{ .M_AXI_AWVALID(M_AXI_AWVALID), .M_AXI_AWREADY(M_AXI_AWREADY), .M_AXI_AWADDR(M_AXI_AWADDR), .M_AXI_AWPROT(M_AXI_AWPROT), // .M_AXI_WVALID(M_AXI_WVALID), .M_AXI_WREADY(M_AXI_WREADY), .M_AXI_WDATA(M_AXI_WDATA), .M_AXI_WSTRB(M_AXI_WSTRB), // .M_AXI_BVALID(M_AXI_BVALID), .M_AXI_BREADY(M_AXI_BREADY), .M_AXI_BRESP(M_AXI_BRESP), // }}} // AXI-lite read interface // {{{ .M_AXI_ARVALID(ign_arvalid), .M_AXI_ARREADY(1'b1), .M_AXI_ARADDR(ign_araddr), .M_AXI_ARPROT(ign_arprot), // .M_AXI_RVALID(1'b0), .M_AXI_RREADY(ign_rready), .M_AXI_RDATA({(MSTDW){1'b0}}), .M_AXI_RRESP(2'b00) // }}} // }}} // }}} ); // }}} end else begin : WDN if (OPT_WRITES) begin : IMPLEMENT_WRITES // {{{ // Register declarations // {{{",
            "localparam BIDFIFOBW = IW+1+(SLVSZ-MSTSZ+1); // // S_AXI_AW* skid buffer",
            "wire skids_awvalid;",
            "wire skids_awready;",
            "wire [IW-1:0] skids_awid;",
            "wire [AW-1:0] skids_awaddr;",
            "wire [7:0] skids_awlen;",
            "wire [2:0] skids_awsize;",
            "wire [1:0] skids_awburst;",
            "wire [2:0] skids_awprot; // // S_AXI_W* skid buffer",
            "wire skids_wvalid, skids_wready;",
            "wire [SLVDW-1:0] skids_wdata;",
            "wire [SLVDW/8-1:0] skids_wstrb;",
            "wire slv_awready, slv_wready;",
            "reg [SLVDW-1:0] slv_wdata;",
            "reg [SLVDW/8-1:0] slv_wstrb;",
            "reg [IW-1:0] slv_awid;",
            "reg [AW-1:0] slv_awaddr, slv_next_awaddr;",
            "reg [2:0] slv_awsize;",
            "reg [1:0] slv_awburst;",
            "reg [7:0] slv_awlen;",
            "reg [8:0] slv_wlen;",
            "reg slv_awlast; // Write",
            "reg isters",
            "reg m_axi_awvalid;",
            "reg bfifo_write, wfifo_wlast;",
            "reg [IW+1+SLVSZ-MSTSZ:0] bfifo_wdata;",
            "wire [LGFIFO:0] wfifo_count;",
            "wire wfifo_full;",
            "wire wfifo_empty;",
            "wire [SLVSZ-MSTSZ:0] wfifo_subcount;",
            "wire [IW-1:0] wfifo_bid;",
            "reg [SLVSZ-MSTSZ:0] bcounts;",
            "reg [IW-1:0] s_axi_bid, bid;",
            "reg blast;",
            "reg [1:0] s_axi_bresp, bresp;",
            "reg s_axi_bvalid;",
            "reg b_return_stall;",
            "wire read_from_wrfifo; // // S_AXI_B* skid buffer isn't needed // // M_AXI_AW* skid buffer isn't needed // // M_AXI_W* skid buffer isn't needed // // M_AXI_B* skid buffer",
            "wire skidm_bvalid, skidm_bready;",
            "wire [1:0] skidm_bresp;",
            "reg m_axi_wvalid;",
            "reg [AW-1:0] mst_awaddr;",
            "reg [2:0] mst_awprot;",
            "reg [SLVSZ-MSTSZ:0] mst_awbeats, mst_wbeats, next_slv_beats; // }}} //////////////////////////////////////////////////////////////// // // Incoming write address / data handling // {{{ //////////////////////////////////////////////////////////////// // // //////////////////////////////////////// // // Clock #1: The skid buffer // {{{ // The write address channel's skid buffer // {{{ skidbuffer #( // {{{ .DW(IW+AW+8+3+2+3), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_OUTREG(0) // }}} ) awskid( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(S_AXI_AWVALID), .o_ready(S_AXI_AWREADY), .i_data({ S_AXI_AWID, S_AXI_AWADDR, S_AXI_AWLEN, S_AXI_AWSIZE, S_AXI_AWBURST, S_AXI_AWPROT }), .o_valid(skids_awvalid), .i_ready(skids_awready), .o_data({ skids_awid, skids_awaddr, skids_awlen, skids_awsize, skids_awburst, skids_awprot }) // }}} ); // }}} // // The write data channel's skid buffer (S_AXI_W*) // {{{ skidbuffer #( // {{{ .DW(SLVDW+SLVDW/8), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_OUTREG(0) // }}} ) wskid( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(S_AXI_WVALID), .o_ready(S_AXI_WREADY), .i_data({ S_AXI_WDATA, S_AXI_WSTRB }), .o_valid(skids_wvalid), .i_ready(skids_wready), .o_data({ skids_wdata, skids_wstrb }) // }}} ); // }}}",
            "assign skids_awready = skids_wvalid && skids_wready && slv_awlast;",
            "assign skids_wready = slv_wready; // }}} //////////////////////////////////////// // // Clock 2: slv_* clock // {{{ // When are we ready for a next SLAVE beat?",
            "assign slv_awready = (skids_wvalid && skids_wready); // slv_aw* // {{{ // slv_awaddr is the address of the value *CURRENTLY* in the // buffer, *NOT* the next address.",
            "initial slv_awlast = 1;",
            "always @(posedge S_AXI_ACLK) if (skids_awvalid && skids_awready) begin slv_awid <= skids_awid; slv_awaddr <= skids_awaddr; slv_awlen <= skids_awlen; slv_awsize <= skids_awsize; slv_awburst <= skids_awburst; end else if (slv_awready && slv_wlen > 0) begin // Step forward a full beat -- but only when we have // the data to do so slv_awaddr <= slv_next_awaddr; end // }}} // slv_awlast // {{{",
            "initial slv_awlast = 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) slv_awlast <= 1; else if (skids_awvalid && skids_awready) slv_awlast <= (skids_awlen == 0); else if (skids_wvalid && skids_wready) slv_awlast <= (slv_wlen <= 2); `ifdef FORMAL",
            "always @(*) assert(slv_awlast == (slv_wlen <= 1)); `endif // }}} // slv_wlen = Number of beats remaining // {{{ // ... in the slave's data space, to include the one we've // just ingested. Therefore, this is a 1-up counter. If // slv_wlen == 0, then we are idle.",
            "initial slv_wlen = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) slv_wlen <= 0; else if (skids_awvalid && skids_awready) begin slv_wlen <= skids_awlen + 1; end else if (skids_wvalid && skids_wready) // (slv_awready && slv_wlen > 0) begin slv_wlen <= slv_wlen - 1; `ifdef FORMAL assert(slv_wlen > 0); `endif end else if (slv_wlen == 1 && slv_wready) slv_wlen <= 0; // }}} // next_slv_beats // {{{",
            "always @(*) begin // Verilator lint_off WIDTH next_slv_beats = (1<<(skids_awsize-MSTSZ[2:0])) - (skids_awaddr[SLVSZ-1:0] >> skids_awsize); if (skids_awsize <= MSTSZ[2:0]) next_slv_beats = 1; // Verilator lint_on WIDTH end // }}} // slv_next_awaddr // {{{ axi_addr #( // {{{ .AW(AW), .DW(SLVDW) // }}} ) get_next_slave_addr ( // {{{ .i_last_addr(slv_awaddr), .i_size(slv_awsize), .i_burst(slv_awburst), .i_len(slv_awlen), .o_next_addr(slv_next_awaddr) // }}} ); // }}}",
            "assign slv_wready = (mst_awbeats <= (M_AXI_AWREADY ? 1:0)) && (mst_wbeats <= (M_AXI_WREADY ? 1:0)) && (!bfifo_write || !wfifo_full); // slv_wstrb, slv_wdata // {{{",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) { slv_wstrb, slv_wdata } <= 0; else if (skids_awready) begin slv_wstrb <= skids_wstrb >> (skids_awaddr[SLVSZ-1:MSTSZ]*MSTDW/8); slv_wdata <= skids_wdata >> (skids_awaddr[SLVSZ-1:MSTSZ]*MSTDW); if (OPT_LOWPOWER && !skids_awvalid) begin slv_wstrb <= 0; slv_wdata <= 0; end end else if (skids_wready) begin slv_wstrb <= skids_wstrb >> (slv_next_awaddr[SLVSZ-1:MSTSZ]*MSTDW/8); slv_wdata <= skids_wdata >> (slv_next_awaddr[SLVSZ-1:MSTSZ]*MSTDW); if (OPT_LOWPOWER && !skids_wvalid) begin slv_wstrb <= 0; slv_wdata <= 0; end end else if (M_AXI_WVALID && M_AXI_WREADY) begin slv_wstrb <= slv_wstrb >> (MSTDW/8); slv_wdata <= slv_wdata >> (MSTDW); end // }}} // }}} //////////////////////////////////////// // // Clock 2 (continued): mst_* = M_AXI_* // {{{ // mst_awaddr, mst_awprot, mst_awbeats // {{{",
            "initial mst_awaddr = 0;",
            "initial mst_awprot = 0;",
            "always @(posedge S_AXI_ACLK) begin if (!M_AXI_AWVALID || M_AXI_AWREADY) begin if (skids_awvalid && skids_awready) begin mst_awaddr <= skids_awaddr; mst_awprot <= skids_awprot; mst_awbeats<= next_slv_beats; end else if (skids_wvalid && skids_wready) begin mst_awaddr <= slv_next_awaddr; mst_awbeats<= 1; if (slv_awsize >= MSTSZ[2:0]) mst_awbeats <= (1<<(slv_awsize - MSTSZ[2:0])); end else begin if (mst_awbeats > 1) begin mst_awaddr <= mst_awaddr + (1<<MSTSZ); mst_awaddr[MSTSZ-1:0] <= 0; end else if (OPT_LOWPOWER) begin mst_awaddr <= 0; end if (mst_awbeats > 0) mst_awbeats <= mst_awbeats - 1; end end if (!S_AXI_ARESETN) begin // {{{ mst_awbeats <= 0; if (OPT_LOWPOWER) begin mst_awaddr <= 0; mst_awprot <= 0; end // }}} end end `ifdef FORMAL",
            "always @(*) if(S_AXI_ARESETN && OPT_LOWPOWER && mst_awbeats == 0) begin assert(mst_awaddr == 0); end",
            "always @(*) if (S_AXI_ARESETN) assert(m_axi_awvalid == (mst_awbeats > 0)); `endif // }}} // m_axi_awvalid // {{{",
            "initial m_axi_awvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) m_axi_awvalid <= 0; else if (!M_AXI_AWVALID || M_AXI_AWREADY) begin if (skids_wvalid && skids_wready) m_axi_awvalid <= 1'b1; else if (mst_awbeats == 1) m_axi_awvalid <= 1'b0; end // }}}",
            "assign M_AXI_AWVALID = m_axi_awvalid;",
            "assign M_AXI_AWVALID = m_axi_awvalid;",
            "assign M_AXI_AWADDR = mst_awaddr;",
            "assign M_AXI_AWPROT = mst_awprot; // M_AXI_WVALID, mst_wbeats // {{{",
            "initial m_axi_wvalid = 0;",
            "initial mst_wbeats = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin m_axi_wvalid <= 0; mst_wbeats <= 0; end else if (!M_AXI_WVALID || M_AXI_WREADY) begin if (skids_wvalid && skids_wready) begin m_axi_wvalid <= 1'b1; if (skids_awvalid && skids_awready) mst_wbeats <= next_slv_beats; else if (slv_awsize <= MSTSZ[2:0]) mst_wbeats <= 1; else mst_wbeats <= (1<<(slv_awsize - MSTSZ[2:0])); end else begin if (mst_wbeats <= 1) m_axi_wvalid <= 1'b0; if (mst_wbeats > 0) mst_wbeats <= mst_wbeats - 1; end end `ifdef FORMAL",
            "always @(*) if (S_AXI_ARESETN) assert(M_AXI_WVALID == (mst_wbeats > 0)); `endif // }}} // M_AXI_WDATA, M_AXI_WSTRB // {{{",
            "assign M_AXI_WDATA = slv_wdata[MSTDW-1:0];",
            "assign M_AXI_WSTRB = slv_wstrb[MSTDW/8-1:0]; // }}}",
            "assign M_AXI_WVALID = m_axi_wvalid;",
            "assign M_AXI_WDATA = slv_wdata[MSTDW-1:0];",
            "assign M_AXI_WSTRB = slv_wstrb[MSTDW/8-1:0]; // }}} //////////////////////////////////////// // // Clock 3: The B FIFO // {{{ // bfifo_write // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) bfifo_write <= 0; else if (!bfifo_write || !wfifo_full) bfifo_write <= skids_wvalid && skids_wready; // }}} // bfifo_wdata // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) bfifo_wdata <= 0; else if (skids_awvalid && skids_awready) begin bfifo_wdata[SLVSZ-MSTSZ:0] <= next_slv_beats; bfifo_wdata[SLVSZ-MSTSZ+1] <= (skids_awlen == 0); bfifo_wdata[SLVSZ-MSTSZ+2 +: IW] <= skids_awid; `ifdef FORMAL assert(skids_wvalid && skids_wready); `endif end else if (skids_wvalid && skids_wready) begin bfifo_wdata[SLVSZ-MSTSZ+2 +: IW] <= slv_awid; bfifo_wdata[SLVSZ-MSTSZ+1] <= (slv_wlen <= 2) ? 1'b1 : 1'b0; if (slv_awsize <= MSTSZ[2:0]) bfifo_wdata[SLVSZ-MSTSZ:0] <= 1; else bfifo_wdata[SLVSZ-MSTSZ:0] <= (1<<(slv_awsize - MSTSZ[2:0])); end // }}} // BFIFO // {{{ sfifo #( // {{{ .BW(BIDFIFOBW), .LGFLEN(LGFIFO) // }}} ) bidlnfifo( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_wr(bfifo_write), .i_data(bfifo_wdata), .o_full(wfifo_full), .o_fill(wfifo_count), .i_rd(read_from_wrfifo), .o_data({ wfifo_bid, wfifo_wlast,wfifo_subcount }), .o_empty(wfifo_empty) // }}} ); // }}} // read_from_wrfifo // {{{",
            "assign read_from_wrfifo = (bcounts <= 1)&&(!wfifo_empty) &&(skidm_bvalid && skidm_bready); // }}} // }}} //////////////////////////////////////// // // Return clock 1: the skid buffer // {{{ // // The downstream AXI-lite response (M_AXI_B*) skid buffer skidbuffer #( // {{{ .DW(2), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_OUTREG(0) // }}} ) bskid( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(M_AXI_BVALID), .o_ready(M_AXI_BREADY), .i_data({ M_AXI_BRESP }), .o_valid(skidm_bvalid), .i_ready(skidm_bready), .o_data({ skidm_bresp }) // }}} );",
            "assign skidm_bready = ((bcounts > 0)||(!wfifo_empty)) && !b_return_stall; // }}} //////////////////////////////////////// // // Return staging: Counting returns // {{{ // bcounts // {{{ // Return counts",
            "initial bcounts = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) bcounts <= 0; else if (skidm_bvalid && skidm_bready) begin if (read_from_wrfifo) begin /* if (bcounts == 0 && wfifo_subcount <= 1 && wfifo_wlast) // Go straight to S_AXI_BVALID, no // more bursts to count here bcounts <= 0; else */ bcounts <= wfifo_subcount + bcounts - 1; end else bcounts <= bcounts - 1; end // }}} // blast // {{{",
            "always @(posedge S_AXI_ACLK) if (read_from_wrfifo) blast <= wfifo_wlast; // }}} // bid // {{{",
            "always @(posedge S_AXI_ACLK) if (read_from_wrfifo) bid <= wfifo_bid; // }}} // bresp // {{{",
            "initial bresp = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) bresp <= OKAY; else if (!S_AXI_BVALID || S_AXI_BREADY) bresp <= OKAY; else if (skidm_bvalid && skidm_bready) begin // Let SLVERR take priority over DECERR casez({ bresp, skidm_bresp }) 4'b??0?: bresp <= bresp; 4'b0?1?: bresp <= skidm_bresp; 4'b1?10: bresp <= SLVERR; 4'b1011: bresp <= SLVERR; 4'b1111: bresp <= skidm_bresp; endcase if (blast) bresp <= OKAY; end // }}} // }}} //////////////////////////////////////// // // Return clock 2: S_AXI_* returns // {{{ // s_axi_bid // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_BVALID || S_AXI_BREADY) begin if (bcounts > 0 && blast) s_axi_bid <= bid; else if (read_from_wrfifo) s_axi_bid <= wfifo_bid; else s_axi_bid <= bid; end // }}} // s_axi_bvalid, b_return_stall // {{{",
            "always @(*) begin // Force simulation evaluation on reset if (!S_AXI_ARESETN) b_return_stall = 0; // Default: stalled if the",
            "output is stalled b_return_stall = S_AXI_BVALID && !S_AXI_BREADY; if (bcounts > 1) b_return_stall = 0; else if (bcounts == 1 && !blast) b_return_stall = 0; else if (bcounts == 0 && (wfifo_subcount > 1 || !wfifo_wlast)) b_return_stall = 0; end",
            "initial s_axi_bvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) s_axi_bvalid <= 0; else if (!S_AXI_BVALID || S_AXI_BREADY) begin s_axi_bvalid <= 0; if (skidm_bvalid && skidm_bready) s_axi_bvalid <= ((bcounts == 1)&& blast) ||((bcounts == 0) && (!wfifo_empty) && (wfifo_subcount <= 1)&& wfifo_wlast); end // }}} // s_axi_bresp // {{{",
            "initial s_axi_bresp = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) s_axi_bresp <= OKAY; else if (!S_AXI_BVALID || S_AXI_BREADY) begin if (skidm_bvalid && skidm_bready) begin // Let SLVERR take priority over DECERR casez({ bresp, skidm_bresp[1] }) 3'b??0: s_axi_bresp <= s_axi_bresp; 3'b0?1: s_axi_bresp <= skidm_bresp; 3'b101: s_axi_bresp <= SLVERR; 3'b111: s_axi_bresp <= skidm_bresp; endcase end else s_axi_bresp <= bresp; end // }}} // S_AXI_B*",
            "assign ments // {{{",
            "assign S_AXI_BID = s_axi_bid;",
            "assign S_AXI_BRESP = s_axi_bresp;",
            "assign S_AXI_BVALID = s_axi_bvalid; // }}} // }}} // }}} // Make Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused_write;",
            "assign unused_write = &{ 1'b0, wfifo_count, S_AXI_WLAST }; // Verilator lint_on UNUSED // }}} //////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////// // // Formal properties, write half // {{{ //////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////// `ifdef FORMAL // These are only a subset of the formal properties used to // verify this design. While I will warrant that the full // property set will work, I don't really expect the below // properties to be sufficient or for that matter even // syntactically correct. // // Register declarations // {{{",
            "localparam F_LGDEPTH = LGFIFO+1+8;",
            "wire [F_LGDEPTH-1:0] faxi_awr_nbursts;",
            "wire [9-1:0] faxi_wr_pending;",
            "wire [F_LGDEPTH-1:0] faxi_rd_nbursts;",
            "wire [F_LGDEPTH-1:0] faxi_rd_outstanding; // // ... // localparam F_AXIL_LGDEPTH = F_LGDEPTH;",
            "wire [F_AXIL_LGDEPTH-1:0] faxil_rd_outstanding, faxil_wr_outstanding, faxil_awr_outstanding; // }}} //////////////////////////////////////////////////////////////// // // AXI channel properties // {{{ //////////////////////////////////////////////////////////////// // // faxi_slave #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_DATA_WIDTH(SLVDW), .C_AXI_ADDR_WIDTH(AW), .F_LGDEPTH(F_AXIL_LGDEPTH), .OPT_EXCLUSIVE(0) // ... // }}} ) faxi( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // Write address // {{{ .i_axi_awvalid(skids_awvalid), .i_axi_awready(skids_awready), .i_axi_awid( skids_awid), .i_axi_awaddr( skids_awaddr), .i_axi_awlen( skids_awlen), .i_axi_awsize( skids_awsize), .i_axi_awburst(skids_awburst), .i_axi_awlock( 0), .i_axi_awcache(0), .i_axi_awprot( skids_awprot), .i_axi_awqos( 0), // }}} // Write data // {{{ .i_axi_wvalid( skids_wvalid), .i_axi_wready( skids_wready), .i_axi_wdata( skids_wdata), .i_axi_wstrb( skids_wstrb), .i_axi_wlast( S_AXI_WLAST), // }}} // Write return response // {{{ .i_axi_bvalid( S_AXI_BVALID), .i_axi_bready( S_AXI_BREADY), .i_axi_bid( S_AXI_BID), .i_axi_bresp( S_AXI_BRESP), // }}} // Read address // {{{ .i_axi_arvalid(1'b0), .i_axi_arready(1'b0), .i_axi_arid( skids_awid), .i_axi_araddr( skids_awaddr), .i_axi_arlen( skids_awlen), .i_axi_arsize( skids_awsize), .i_axi_arburst(skids_awburst), .i_axi_arlock( 0), .i_axi_arcache(0), .i_axi_arprot( 0), .i_axi_arqos( 0), // }}} // Read response // {{{ .i_axi_rvalid( 1'b0), .i_axi_rready( 1'b0), .i_axi_rid( S_AXI_RID), .i_axi_rdata( S_AXI_RDATA), .i_axi_rlast( S_AXI_RLAST), .i_axi_rresp( S_AXI_RRESP), // }}} // Formal property data // {{{ .f_axi_awr_nbursts( faxi_awr_nbursts), .f_axi_wr_pending( faxi_wr_pending), .f_axi_rd_nbursts( faxi_rd_nbursts), .f_axi_rd_outstanding(faxi_rd_outstanding) // // ... // // }}} // }}} );",
            "always @(*) begin // ... assert(faxi_rd_nbursts == 0); end // }}} //////////////////////////////////////////////////////////////// // // AXI-lite properties // {{{ //////////////////////////////////////////////////////////////// // // faxil_master #( // {{{ .C_AXI_DATA_WIDTH(MSTDW), .C_AXI_ADDR_WIDTH(AW), .F_OPT_NO_RESET(1), .F_AXI_MAXWAIT(5), .F_AXI_MAXDELAY(4), .F_AXI_MAXRSTALL(0), .F_OPT_WRITE_ONLY(1), .F_OPT_READ_ONLY(1'b0), .F_LGDEPTH(F_AXIL_LGDEPTH) // }}} ) faxil( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // Write address channel // {{{ .i_axi_awvalid(M_AXI_AWVALID), .i_axi_awready(M_AXI_AWREADY), .i_axi_awaddr( M_AXI_AWADDR), .i_axi_awprot( M_AXI_AWPROT), // }}} // Write data // {{{ .i_axi_wvalid( M_AXI_WVALID), .i_axi_wready( M_AXI_WREADY), .i_axi_wdata( M_AXI_WDATA), .i_axi_wstrb( M_AXI_WSTRB), // }}} // Write response // {{{ .i_axi_bvalid( skidm_bvalid), .i_axi_bready( skidm_bready), .i_axi_bresp( skidm_bresp), // }}} // Read address // {{{ .i_axi_arvalid(M_AXI_ARVALID), .i_axi_arready(M_AXI_ARREADY), .i_axi_araddr( M_AXI_ARADDR), .i_axi_arprot( M_AXI_ARPROT), // }}} // Read data return // {{{ .i_axi_rvalid( 1'b0), .i_axi_rready( 1'b1), .i_axi_rdata( {(C_M_AXI_DATA_WIDTH){1'b0}}), .i_axi_rresp( 2'b00), // }}} // Formal check variables // {{{ .f_axi_rd_outstanding(faxil_rd_outstanding), .f_axi_wr_outstanding(faxil_wr_outstanding), .f_axi_awr_outstanding(faxil_awr_outstanding) // }}} // }}} );",
            "always @(*) if (S_AXI_ARESETN) begin assert(faxil_rd_outstanding == 0); assert(faxil_awr_outstanding + ((mst_awbeats > 0) ? mst_awbeats : 0) == f_wfifo_beats + (bfifo_write ? bfifo_wdata[SLVSZ-MSTSZ:0] : 0) + bcounts); assert(faxil_wr_outstanding + ((mst_wbeats > 0) ? mst_wbeats : 0) == f_wfifo_beats + (bfifo_write ? bfifo_wdata[SLVSZ-MSTSZ:0] : 0) + bcounts); end",
            "always @(*) assert(faxil_awr_outstanding <= { 1'b1, {(LGFIFO+8){1'b0}} } + bcounts);",
            "always @(*) assert(faxil_wr_outstanding <= { 1'b1, {(LGFIFO+8){1'b0}} } + bcounts); // }}} //////////////////////////////////////////////////////////////// // // BFIFO property checking // {{{ //////////////////////////////////////////////////////////////// // // // // ... // always @(posedge S_AXI_ACLK) if (S_AXI_ARESETN) begin assert(faxi_awr_nbursts == f_bfifo_packets + (slv_awvalid ? 1:0)); assert(f_bfifo_packets <= wfifo_count); // ... end // // ... // // }}} `endif // }}} // }}} end else begin : NO_WRITE_SUPPORT // {{{",
            "assign S_AXI_AWREADY = 0;",
            "assign S_AXI_WREADY = 0;",
            "assign S_AXI_BID = 0;",
            "assign S_AXI_BRESP = 2'b11;",
            "assign S_AXI_BVALID = 0;",
            "assign S_AXI_BID = 0; // assign M_AXI_AWVALID = 0;",
            "assign M_AXI_AWADDR = 0;",
            "assign M_AXI_AWPROT = 0; // assign M_AXI_WVALID = 0;",
            "assign M_AXI_WDATA = 0;",
            "assign M_AXI_WSTRB = 0; // assign M_AXI_BREADY = 0; // }}} end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Read",
            "logic // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_READS && SLVDW == MSTDW) begin : IMPLEMENT_AXI2AXILITE_READS // {{{ // (Unused) signal declarations // {{{ // Verilator lint_off UNUSED",
            "wire ign_awready, ign_wready, ign_bvalid;",
            "wire [IW-1:0] ign_bid;",
            "wire [1:0] ign_bresp;",
            "wire ign_awvalid, ign_wvalid, ign_bready;",
            "wire [AW-1:0] ign_awaddr;",
            "wire [2:0] ign_awprot;",
            "wire [MSTDW-1:0] ign_wdata;",
            "wire [MSTDW/8-1:0] ign_wstrb; // Verilator lint_on UNUSED // }}} axi2axilite #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_DATA_WIDTH(SLVDW), .C_AXI_ADDR_WIDTH(AW), .OPT_WRITES(0), .OPT_READS(1), .LGFIFO(LGFIFO) // }}} ) axilread ( // {{{ .S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN), // AXI4 slave interface // {{{ // Write address channel // {{{ .S_AXI_AWVALID(1'b0), .S_AXI_AWREADY(ign_awready), .S_AXI_AWID( {(IW){1'b0}} ), .S_AXI_AWADDR( {(AW){1'b0}} ), .S_AXI_AWLEN( 8'h0), .S_AXI_AWSIZE( 3'h0), .S_AXI_AWBURST(2'h0), .S_AXI_AWLOCK( 1'b0), .S_AXI_AWCACHE(4'h0), .S_AXI_AWPROT( 3'h0), .S_AXI_AWQOS( 4'h0), // }}} // Write data channel // {{{ .S_AXI_WVALID(1'b0), .S_AXI_WREADY(ign_wready), .S_AXI_WDATA( {(SLVDW){1'b0}}), .S_AXI_WSTRB( {(SLVDW/8){1'b0}}), .S_AXI_WLAST( 1'b0), // }}} // Write return channel // {{{ .S_AXI_BVALID(ign_bvalid), .S_AXI_BREADY(1'b1), .S_AXI_BID( ign_bid), .S_AXI_BRESP( ign_bresp), // }}} // Read address channel // {{{ .S_AXI_ARVALID(S_AXI_ARVALID), .S_AXI_ARREADY(S_AXI_ARREADY), .S_AXI_ARID( S_AXI_ARID), .S_AXI_ARADDR( S_AXI_ARADDR), .S_AXI_ARLEN( S_AXI_ARLEN), .S_AXI_ARSIZE( S_AXI_ARSIZE), .S_AXI_ARBURST(S_AXI_ARBURST), .S_AXI_ARLOCK( S_AXI_ARLOCK), .S_AXI_ARCACHE(S_AXI_ARCACHE), .S_AXI_ARPROT( S_AXI_ARPROT), .S_AXI_ARQOS( S_AXI_ARQOS), // }}} // Read data channel // {{{ .S_AXI_RVALID(S_AXI_RVALID), .S_AXI_RREADY(S_AXI_RREADY), .S_AXI_RID( S_AXI_RID), .S_AXI_RDATA( S_AXI_RDATA), .S_AXI_RRESP( S_AXI_RRESP), .S_AXI_RLAST( S_AXI_RLAST), // }}} // }}} // AXI-lite master interface // {{{ // AXI-lite Write interface // {{{ .M_AXI_AWVALID(ign_awvalid), .M_AXI_AWREADY(1'b1), .M_AXI_AWADDR(ign_awaddr), .M_AXI_AWPROT(ign_awprot), // .M_AXI_WVALID(ign_wvalid), .M_AXI_WREADY(1'b1), .M_AXI_WDATA(ign_wdata), .M_AXI_WSTRB(ign_wstrb), // .M_AXI_BVALID(1'b0), .M_AXI_BREADY(ign_bready), .M_AXI_BRESP(2'b00), // }}} // AXI-lite read interface // {{{ .M_AXI_ARVALID(M_AXI_ARVALID), .M_AXI_ARREADY(M_AXI_ARREADY), .M_AXI_ARADDR(M_AXI_ARADDR), .M_AXI_ARPROT(M_AXI_ARPROT), // .M_AXI_RVALID(M_AXI_RVALID), .M_AXI_RREADY(M_AXI_RREADY), .M_AXI_RDATA(M_AXI_RDATA), .M_AXI_RRESP(M_AXI_RRESP) // }}} // }}} // }}} ); // }}} end else begin : RDN if (OPT_READS) begin : IMPLEMENT_READS // {{{ // Declarations // {{{",
            "wire slv_arvalid, slv_arready;",
            "reg [IW-1:0] slv_arid, mst_arid;",
            "reg [AW-1:0] slv_araddr, mst_araddr;",
            "wire [AW-1:0] slv_next_araddr;",
            "reg [7:0] slv_arlen;",
            "reg slv_arlast, mst_arlast, mst_arsublast;",
            "reg [2:0] slv_arprot, mst_arprot;",
            "reg [2:0] slv_arsize;",
            "reg [1:0] slv_arburst;",
            "reg [SLVSZ-MSTSZ:0] slv_arbeats, mst_arbeats;",
            "reg [8:0] slv_rlen;",
            "wire [SLVSZ-MSTSZ-1:0] rfifo_addr;",
            "wire rfifo_end_of_beat, rfifo_rlast;",
            "wire [4:0] rfifo_count; // reg m_axi_arvalid;",
            "wire rfifo_full;",
            "wire rfifo_empty;",
            "reg s_axi_rvalid;",
            "reg [1:0] s_axi_rresp;",
            "reg [IW-1:0] s_axi_rid;",
            "wire [IW-1:0] rfifo_rid;",
            "reg [SLVDW-1:0] s_axi_rdata, next_rdata;",
            "reg s_axi_rlast;",
            "reg [IW-1:0] rid;",
            "wire read_from_rdfifo; // // // S_AXI_AR* skid buffer",
            "wire skids_arvalid, skids_arready;",
            "wire [IW-1:0] skids_arid;",
            "wire [AW-1:0] skids_araddr;",
            "wire [7:0] skids_arlen;",
            "wire [2:0] skids_arsize, skids_arprot;",
            "wire [1:0] skids_arburst; // // S_AXI_R* skid buffer isn't needed // // M_AXI_AR* skid buffer isn't needed // M_AXI_R* skid buffer",
            "wire skidm_rvalid, skidm_rready;",
            "wire [MSTDW-1:0] skidm_rdata;",
            "wire [1:0] skidm_rresp; // }}} // S_AXI_AR* skid buffer // {{{ skidbuffer #( // {{{ .DW(IW+AW+8+3+2+3), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_OUTREG(0) // }}} ) arskid( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(S_AXI_ARVALID), .o_ready(S_AXI_ARREADY), .i_data({ S_AXI_ARID, S_AXI_ARADDR, S_AXI_ARLEN, S_AXI_ARSIZE, S_AXI_ARBURST, S_AXI_ARPROT }), .o_valid(skids_arvalid), .i_ready(skids_arready), .o_data({ skids_arid, skids_araddr, skids_arlen, skids_arsize, skids_arburst, skids_arprot }) // }}} ); // }}} // M_AXI_R* skid buffer // {{{ skidbuffer #( // {{{ .DW(MSTDW+2), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_OUTREG(0) // }}} ) rskid( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(M_AXI_RVALID), .o_ready(M_AXI_RREADY), .i_data({ M_AXI_RDATA, M_AXI_RRESP }), .o_valid(skidm_rvalid), .i_ready(skidm_rready), .o_data({ skidm_rdata, skidm_rresp }) // }}} ); // }}}",
            "assign skids_arready = (slv_rlen <= (slv_arready ? 1:0)) &&(mst_arbeats <=(M_AXI_ARREADY ? 1:0)); // slv_* // {{{",
            "always @(posedge S_AXI_ACLK) begin if (OPT_LOWPOWER && (slv_rlen <= (slv_arready ? 1:0))) begin // {{{ slv_arid <= 0; slv_araddr <= 0; slv_arlen <= 0; slv_arsize <= 0; slv_arburst <= 0; slv_arprot <= 0; slv_rlen <= 0; // }}} end if (skids_arvalid && skids_arready) begin // {{{ slv_arid <= skids_arid; slv_araddr <= skids_araddr; slv_arlen <= skids_arlen; slv_arsize <= skids_arsize; slv_arburst <= skids_arburst; slv_arlast <= (skids_arlen == 0); slv_arprot <= skids_arprot; slv_rlen <= skids_arlen+1; // }}} end else if (slv_arready && slv_rlen > 0) begin // {{{ slv_araddr <= (!OPT_LOWPOWER || slv_rlen > 1) ? slv_next_araddr : 0; slv_rlen <= slv_rlen - 1; slv_arlast <= (slv_rlen <= 2); // }}} end if (OPT_LOWPOWER && !S_AXI_ARESETN) begin // {{{ slv_arid <= 0; slv_araddr <= 0; slv_arlen <= 0; slv_arsize <= 0; slv_arburst <= 0; slv_arprot <= 0; slv_arlast <= 1; // }}} end if (!S_AXI_ARESETN) slv_rlen <= 0; end",
            "assign slv_arvalid = (slv_rlen > 0); `ifdef FORMAL",
            "always @(*) if (S_AXI_ARESETN) begin assert(slv_arlast == (slv_rlen <= 1)); assert(slv_rlen <= (slv_arlen + 1)); end `endif // }}} // slv_next_araddr // {{{ axi_addr #( // {{{ .AW(AW), .DW(SLVDW) // }}} ) get_next_slave_addr ( // {{{ .i_last_addr(slv_araddr), .i_size(slv_arsize), .i_burst(slv_arburst), .i_len(slv_arlen), .o_next_addr(slv_next_araddr) // }}} ); // }}} // slv_arbeats // {{{",
            "always @(*) if (slv_rlen > 0) begin // Master beats to turn this slave beat into if (slv_arsize >= MSTSZ[2:0]) slv_arbeats = (1<<(slv_arsize-MSTSZ[2:0])) - (slv_araddr[MSTSZ-1:0] >> slv_arsize); else slv_arbeats = 1; end else slv_arbeats = 0; // }}} // mst_araddr, mst_arprot, mst_arbeats // {{{",
            "always @(posedge S_AXI_ACLK) begin if (slv_arready) begin // {{{ mst_arid <= slv_arid; mst_araddr <= slv_araddr; mst_arprot <= slv_arprot; // Beats to turn this beat into mst_arbeats <= slv_arbeats; mst_arlast <= slv_arlast; mst_arsublast <= (slv_arbeats <= 1); if (OPT_LOWPOWER && slv_rlen == 0) begin mst_arid <= 0; mst_araddr <= 0; mst_arprot <= 0; end // }}} end else if ((mst_arbeats > 0) &&(M_AXI_ARVALID && M_AXI_ARREADY)) begin // {{{ mst_araddr <= mst_araddr + (1<<MSTSZ); mst_araddr[MSTSZ-1:0] <= 0; mst_arbeats <= mst_arbeats - 1; mst_arsublast <= (mst_arbeats <= 2); // }}} end if (!S_AXI_ARESETN) begin // {{{ mst_arbeats <= 0; if (OPT_LOWPOWER) begin mst_arid <= 0; mst_araddr <= 0; mst_arprot <= 0; end // }}} end end `ifdef FORMAL",
            "always @(*) if(OPT_LOWPOWER && S_AXI_ARESETN && mst_arbeats == 0) begin assert(mst_arid == 0); assert(mst_araddr == 0); assert(mst_arprot == 0); end `endif // }}} // m_axi_arvalid // {{{",
            "initial m_axi_arvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) m_axi_arvalid <= 0; else if (slv_arvalid && slv_arready) m_axi_arvalid <= 1; else if (M_AXI_ARVALID && M_AXI_ARREADY) m_axi_arvalid <= (mst_arbeats > 1);",
            "assign M_AXI_ARVALID = m_axi_arvalid; `ifdef FORMAL",
            "always @(*) if (S_AXI_ARESETN) assert(M_AXI_ARVALID == (mst_arbeats > 0)); `endif // }}}",
            "assign slv_arready = (mst_arbeats <= (M_AXI_ARREADY ? 1:0));",
            "assign read_from_rdfifo = skidm_rvalid && skidm_rready &&(!S_AXI_RVALID || S_AXI_RREADY); // Read ID FIFO // {{{ sfifo #( // {{{ .BW(IW+2+SLVSZ-MSTSZ), .LGFLEN(LGFIFO) // }}} ) ridlnfifo( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), // .i_wr(M_AXI_ARVALID && M_AXI_ARREADY), .i_data({ mst_arid, mst_arlast, mst_arsublast, M_AXI_ARADDR[SLVSZ-1:MSTSZ] }), .o_full(rfifo_full), .o_fill(rfifo_count), // .i_rd(read_from_rdfifo), .o_data({ rfifo_rid, rfifo_rlast, rfifo_end_of_beat, rfifo_addr }), .o_empty(rfifo_empty) // }}} ); // }}}",
            "assign skidm_rready = (!S_AXI_RVALID || S_AXI_RREADY) && !rfifo_empty; // s_axi_rvalid // {{{",
            "initial s_axi_rvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) s_axi_rvalid <= 0; else if (skidm_rvalid && skidm_rready && rfifo_end_of_beat) s_axi_rvalid <= 1'b1; else if (S_AXI_RREADY) s_axi_rvalid <= 0; // }}} // s_axi_rdata // {{{",
            "always @(*) begin next_rdata = s_axi_rdata; if (S_AXI_RVALID) next_rdata = 0; if (skidm_rvalid) next_rdata = next_rdata | ({ {(SLVDW-MSTDW){1'b0}}, skidm_rdata } << (rfifo_addr * MSTDW)); end",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) s_axi_rdata <= 0; else if (!S_AXI_RVALID || S_AXI_RREADY) s_axi_rdata <= next_rdata; // }}} // s_axi_rresp // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) s_axi_rresp <= OKAY; else if (!S_AXI_RVALID || S_AXI_RREADY) begin if (S_AXI_RVALID) s_axi_rresp <= (skidm_rvalid) ? skidm_rresp : OKAY; else if (skidm_rvalid) casez({ s_axi_rresp, skidm_rresp[1] }) // Let SLVERR take priority over DECERR 3'b??0: s_axi_rresp <= s_axi_rresp; 3'b0?1: s_axi_rresp <= skidm_rresp; 3'b101: s_axi_rresp <= SLVERR; 3'b111: s_axi_rresp <= skidm_rresp; endcase end // }}} // rid // {{{",
            "initial rid = 0;",
            "always @(posedge S_AXI_ACLK) if (read_from_rdfifo) rid <= rfifo_rid; // }}} // s_axi_rlast // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_RVALID || S_AXI_RREADY) begin if (read_from_rdfifo) s_axi_rlast <= rfifo_rlast; else s_axi_rlast <= 0; end // }}} // s_axi_rid // {{{",
            "initial s_axi_rid = 0;",
            "always @(posedge S_AXI_ACLK) if ((S_AXI_RVALID && S_AXI_RREADY && S_AXI_RLAST) ||(!S_AXI_RVALID && rfifo_end_of_beat)) s_axi_rid <= (read_from_rdfifo && rfifo_end_of_beat)?rfifo_rid : rid; // }}} // M_AXI_AR* // {{{",
            "assign M_AXI_ARVALID= m_axi_arvalid;",
            "assign M_AXI_ARADDR = mst_araddr;",
            "assign M_AXI_ARPROT = mst_arprot; // }}} // S_AXI_R* // {{{",
            "assign S_AXI_RVALID = s_axi_rvalid;",
            "assign S_AXI_RDATA = s_axi_rdata;",
            "assign S_AXI_RRESP = s_axi_rresp;",
            "assign S_AXI_RLAST = s_axi_rlast;",
            "assign S_AXI_RID = s_axi_rid; // }}} // Make Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_read;",
            "assign unused_read = &{ 1'b0, /* S_AXI_AWID, S_AXI_AWVALID, S_AXI_AWLEN, S_AXI_AWBURST, S_AXI_AWSIZE, S_AXI_AWADDR, S_AXI_WVALID, S_AXI_WDATA, S_AXI_WSTRB, S_AXI_WLAST, S_AXI_BREADY, M_AXI_AWREADY, M_AXI_WREADY, M_AXI_BRESP, M_AXI_BVALID, */ rfifo_count, rfifo_full }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////// // // Formal properties, read half // {{{ //////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////// `ifdef FORMAL // As with the write half, the following is a subset of the // formal properties used to verify this section of the core. // It may, or may not, be syntactically correct. I don't // warrant this version of the design. // // Register declarations // {{{",
            "localparam F_LGDEPTH = LGFIFO+1+8;",
            "wire [F_LGDEPTH-1:0] faxi_awr_nbursts;",
            "wire [9-1:0] faxi_wr_pending;",
            "wire [F_LGDEPTH-1:0] faxi_rd_nbursts;",
            "wire [F_LGDEPTH-1:0] faxi_rd_outstanding; // // ... // localparam F_AXIL_LGDEPTH = F_LGDEPTH;",
            "wire [F_AXIL_LGDEPTH-1:0] faxil_rd_outstanding, faxil_wr_outstanding, faxil_awr_outstanding; // }}} //////////////////////////////////////////////////////////////// // // AXI channel properties // {{{ //////////////////////////////////////////////////////////////// // // faxi_slave #( // {{{ .C_AXI_ID_WIDTH(IW), .C_AXI_DATA_WIDTH(SLVDW), .C_AXI_ADDR_WIDTH(AW), .OPT_EXCLUSIVE(0) // ... // }}} ) faxi( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // Write address // {{{ .i_axi_awvalid(1'b0), .i_axi_awready(1'b0), .i_axi_awid( skids_arid), .i_axi_awaddr( skids_araddr), .i_axi_awlen( 8'h0), .i_axi_awsize( 3'h0), .i_axi_awburst(2'h0), .i_axi_awlock( 0), .i_axi_awcache(0), .i_axi_awprot( 0), .i_axi_awqos( 0), // }}} // Write data // {{{ .i_axi_wvalid( 1'b0), .i_axi_wready( 1'b0), .i_axi_wdata( {(C_S_AXI_DATA_WIDTH ){1'b0}}), .i_axi_wstrb( {(C_S_AXI_DATA_WIDTH/8){1'b0}}), .i_axi_wlast( 1'b0), // }}} // Write return response // {{{ .i_axi_bvalid( 1'b0), .i_axi_bready( 1'b0), .i_axi_bid( S_AXI_BID), .i_axi_bresp( 2'b00), // }}} // Read address // {{{ .i_axi_arready(skids_arready), .i_axi_arid( skids_arid), .i_axi_araddr( skids_araddr), .i_axi_arlen( skids_arlen), .i_axi_arsize( skids_arsize), .i_axi_arburst(skids_arburst), .i_axi_arlock( 0), .i_axi_arcache(0), .i_axi_arprot( 0), .i_axi_arqos( 0), .i_axi_arvalid(skids_arvalid), // }}} // Read response // {{{ .i_axi_rid( S_AXI_RID), .i_axi_rresp( S_AXI_RRESP), .i_axi_rvalid( S_AXI_RVALID), .i_axi_rdata( S_AXI_RDATA), .i_axi_rlast( S_AXI_RLAST), .i_axi_rready( S_AXI_RREADY), // }}} // Formal property data // {{{ .f_axi_awr_nbursts( faxi_awr_nbursts), .f_axi_wr_pending( faxi_wr_pending), .f_axi_rd_nbursts( faxi_rd_nbursts), .f_axi_rd_outstanding(faxi_rd_outstanding), // // ... // // }}} // }}} );",
            "always @(*) begin assert(faxi_awr_nbursts == 0); assert(faxi_wr_pending == 0); assert(faxi_wr_ckvalid == 0); end // }}} //////////////////////////////////////////////////////////////// // // AXI-lite properties // {{{ //////////////////////////////////////////////////////////////// // // faxil_master #( // {{{ .C_AXI_DATA_WIDTH(MSTDW), .C_AXI_ADDR_WIDTH(AW), .F_OPT_NO_RESET(1), .F_AXI_MAXWAIT(5), .F_AXI_MAXDELAY(4), .F_AXI_MAXRSTALL(0), .F_OPT_WRITE_ONLY(1'b0), .F_OPT_READ_ONLY(1'b1), .F_LGDEPTH(F_AXIL_LGDEPTH) // }}} ) faxil( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // Write address channel // {{{ .i_axi_awvalid(1'b0), .i_axi_awready(1'b0), .i_axi_awaddr( M_AXI_AWADDR), .i_axi_awprot( 3'h0), // }}} // Write data // {{{ .i_axi_wvalid( 1'b0), .i_axi_wready( 1'b0), .i_axi_wdata( {(C_M_AXI_DATA_WIDTH ){1'b0}}), .i_axi_wstrb( {(C_M_AXI_DATA_WIDTH/8){1'b0}}), // }}} // Write response // {{{ .i_axi_bvalid( 1'b0), .i_axi_bready( 1'b0), .i_axi_bresp( 2'b00), // }}} // Read address // {{{ .i_axi_arvalid(M_AXI_ARVALID), .i_axi_arready(M_AXI_ARREADY), .i_axi_araddr( M_AXI_ARADDR), .i_axi_arprot( M_AXI_ARPROT), // }}} // Read data return // {{{ .i_axi_rvalid( skidm_rvalid), .i_axi_rready( skidm_rready), .i_axi_rdata( skidm_rdata), .i_axi_rresp( skidm_rresp), // }}} // Formal check variables // {{{ .f_axi_rd_outstanding(faxil_rd_outstanding), .f_axi_wr_outstanding(faxil_wr_outstanding), .f_axi_awr_outstanding(faxil_awr_outstanding) // }}} // }}} );",
            "always @(*) begin assert(faxil_awr_outstanding == 0); assert(faxil_wr_outstanding == 0); end // }}} `endif // }}} // }}} end else begin : NO_READ_SUPPORT // if (!OPT_READS) // {{{",
            "assign M_AXI_ARVALID= 0;",
            "assign M_AXI_ARADDR = 0;",
            "assign M_AXI_ARPROT = 0;",
            "assign M_AXI_RREADY = 0; // assign S_AXI_ARREADY= 0;",
            "assign S_AXI_RVALID = 0;",
            "assign S_AXI_RDATA = 0;",
            "assign S_AXI_RRESP = 0;",
            "assign S_AXI_RLAST = 0;",
            "assign S_AXI_RID = 0; // Make Verilator happy // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_read;",
            "assign unused_read = &{ 1'b0, M_AXI_ARREADY, M_AXI_RVALID, M_AXI_RDATA, M_AXI_RRESP, S_AXI_RREADY, S_AXI_ARLEN, S_AXI_ARSIZE, S_AXI_ARBURST, S_AXI_ARADDR, S_AXI_ARVALID, S_AXI_ARID }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} end end endgenerate // }}} // Minimal",
            "parameter validation // {{{",
            "initial begin if (SLVDW < MSTDW) begin $fatal; // Fatal elaboration error $stop; // Stop any simulation end end // }}} // Make Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, S_AXI_AWLOCK, S_AXI_AWCACHE, S_AXI_AWPROT, S_AXI_AWQOS, // skids_wlast, wfifo_count, rfifo_count S_AXI_ARLOCK, S_AXI_ARCACHE, S_AXI_ARPROT, S_AXI_ARQOS }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL //////////////////////////////////////////////////////////////////////// // // Assume that the two write channels stay within an appropriate // distance of each other. This is to make certain that the property // file features are not violated, although not necessary true for // actual operation // //////////////////////////////////////////////////////////////////////// // // Select only write or only read operation // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (!OPT_WRITES) begin",
            "always @(*) begin assume(!S_AXI_AWVALID); assume(!S_AXI_WVALID); assert(!M_AXI_AWVALID); assert(!M_AXI_WVALID); assume(!M_AXI_BVALID); assert(!S_AXI_BVALID); end end endgenerate generate if (!OPT_READS) begin",
            "always @(*) begin assume(!S_AXI_ARVALID); assert(!M_AXI_ARVALID); end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Lowpower assertions // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_LOWPOWER) begin : F_LOWPOWER",
            "always @(*) if (S_AXI_ARESETN) begin if (!M_AXI_AWVALID) begin // Not supported. // assert(M_AXI_AWADDR == 0); // assert(M_AXI_AWPROT == 0); end if (!M_AXI_WVALID) begin // assert(M_AXI_WDATA == 0); // assert(M_AXI_WSTRB == 0); end if (!M_AXI_ARVALID) begin assert(M_AXI_ARADDR == 0); assert(M_AXI_ARPROT == 0); end if (!S_AXI_RVALID) begin // These items build over the course of a // returned burst, so they might not be // zero when RVALID is zero. // // assert(S_AXI_RLAST == 0); // assert(S_AXI_RDATA == 0); // assert(S_AXI_RID == 0); end end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Cover statements, to show performance // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_READS) begin // {{{",
            "reg [3:0] cvr_read_count, cvr_read_count_simple;",
            "initial cvr_read_count_simple = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) cvr_read_count_simple <= 0; else if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN == 0) cvr_read_count_simple <= cvr_read_count_simple + 1;",
            "initial cvr_read_count = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) cvr_read_count <= 0; else if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN > 2) cvr_read_count <= cvr_read_count + 1; // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // \"Careless\" assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // }}} `undef BMC_ASSERT `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "wbscope.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/wbscope.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/wbscope.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This is a generic/library routine for providing a bus accessed // 'scope' or (perhaps more appropriately) a bus accessed",
            "logic analyzer. // The general operation is such that this 'scope' can record and report // on any 32 bit value transiting through the FPGA. Once started and // reset, the scope records a copy of the",
            "input data every time the clock // ticks with the circuit enabled. That is, it records these values up // until the trigger. Once the trigger goes high, the scope will record // for br_holdoff more counts before stopping. Values may then be read // from the buffer, oldest to most recent. After reading, the scope may // then be reset for another run. // // In general, therefore, operation happens in this fashion: // 1. A reset is issued. // 2. Recording starts, in a circular buffer, and continues until // 3. The trigger line is asserted. // The scope",
            "reg isters the asserted trigger by setting // the 'o_triggered'",
            "output flag. // 4. A counter then ticks until the last value is written // The scope",
            "reg isters that it has stopped recording by // setting the 'o_stopped'",
            "output flag. // 5. The scope recording is then paused until the next reset. // 6. While stopped, the CPU can read the data from the scope // 7. -- oldest to most recent // 8. -- one value per i_rd&i_data_clk // 9. Writes to the data",
            "reg ister reset the address to the // beginning of the buffer // // Although the data width DW is",
            "parameter ized, it is not very changable, // since the width is tied to the width of the data bus, as is the // control word. Therefore changing the data width would require changing // the interface. It's doable, but it would be a change to the interface. // // The SYNCHRONOUS",
            "parameter turns on and off meta-stability // synchronization. Ideally a wishbone scope able to handle one or two // clocks would have a changing number of ports as this SYNCHRONOUS // parameter changed. Other than running another script to modify // this, I don't know how to do that so ... we'll just leave it running // off of two clocks or not. // // // Internal to this routine, reg isters and",
            "wire s are named with one of the // following prefixes: // // i_ An",
            "input port to the routine // o_ An",
            "output port of the routine // br_ A",
            "reg ister, controlled by the bus clock // dr_ A",
            "reg ister, controlled by the data clock // bw_ A",
            "wire /net, controlled by the bus clock // dw_ A",
            "wire /net, controlled by the data clock // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module wbscope #( // {{{",
            "parameter [4:0] LGMEM = 5'd10, parameter BUSW = 32, parameter [0:0] SYNCHRONOUS=1, parameter HOLDOFFBITS = 20, parameter [(HOLDOFFBITS-1):0] DEFAULT_HOLDOFF = ((1<<(LGMEM-1))-4) // }}} ) ( // {{{ // The",
            "input signals that we wish to record",
            "input wire i_data_clk, i_ce, i_trigger, input wire [(BUSW-1):0] i_data, // The WISHBONE bus for reading and configuring this scope // {{{",
            "input wire i_wb_clk, i_wb_cyc, i_wb_stb, i_wb_we, input wire i_wb_addr, // One address line only",
            "input wire [(BUSW-1):0] i_wb_data, input wire [(BUSW/8-1):0] i_wb_sel, output wire o_wb_stall, o_wb_ack, output wire [(BUSW-1):0] o_wb_data, // }}} // And, finally, for a final flair --- offer to interrupt the // CPU after our trigger has gone off. This line is equivalent // to the scope being stopped. It is not maskable here.",
            "output wire o_interrupt // }}} ); // Signal declarations // {{{",
            "wire bus_clock;",
            "wire read_from_data;",
            "wire write_stb;",
            "wire write_to_control;",
            "reg read_address;",
            "wire [31:0] i_bus_data;",
            "reg [(LGMEM-1):0] raddr;",
            "reg [(BUSW-1):0] mem[0:((1<<LGMEM)-1)];",
            "wire bw_reset_request, bw_manual_trigger, bw_disable_trigger, bw_reset_complete;",
            "reg [2:0] br_config;",
            "reg [(HOLDOFFBITS-1):0] br_holdoff;",
            "wire dw_reset, dw_manual_trigger, dw_disable_trigger;",
            "reg dr_triggered, dr_primed;",
            "wire dw_trigger; (* ASYNC_REG=\"TRUE\" *)",
            "reg [(HOLDOFFBITS-1):0] counter;",
            "reg dr_stopped;",
            "reg [(LGMEM-1):0] waddr;",
            "localparam STOPDELAY = 1; // Calibrated value--don't change this",
            "wire [(BUSW-1):0] wr_piped_data;",
            "wire bw_stopped, bw_triggered, bw_primed;",
            "reg br_wb_ack, br_pre_wb_ack;",
            "wire bw_cyc_stb;",
            "reg [(LGMEM-1):0] this_addr;",
            "reg [31:0] nxt_mem;",
            "wire [19:0] full_holdoff;",
            "reg [31:0] o_bus_data;",
            "wire [4:0] bw_lgmem;",
            "reg br_level_interrupt; // }}}",
            "assign bus_clock = i_wb_clk; //////////////////////////////////////////////////////////////////////// // // Decode and handle the bus signaling in a (somewhat) portable manner // {{{ //////////////////////////////////////////////////////////////////////// // /////////////////////////////////////////////////// // // assign i_bus_data = i_wb_data;",
            "assign o_wb_stall = 1'b0;",
            "assign read_from_data = i_wb_stb && !i_wb_we && i_wb_addr && (&i_wb_sel);",
            "assign write_stb = (i_wb_stb)&&(i_wb_we);",
            "assign write_to_control = write_stb && !i_wb_addr && (&i_wb_sel);",
            "always @(posedge bus_clock) read_address <= i_wb_addr; // }}} //////////////////////////////////////////////////////////////////////// // // Our status/config",
            "reg ister // {{{ //////////////////////////////////////////////////////////////////////// // // Now that we've finished reading/writing from the // bus, ... or at least acknowledging reads and // writes from and to the bus--even if they haven't // happened yet, now we implement our actual scope. // This includes implementing the actual reads/writes // from/to the bus. // // From here on down, is the heart of the scope itself. // // Our status/config",
            "reg ister",
            "initial br_config = 3'b0;",
            "initial br_holdoff = DEFAULT_HOLDOFF;",
            "always @(posedge bus_clock) begin if (write_to_control) begin br_config[1:0] <= { i_bus_data[27], i_bus_data[26] }; if (!i_bus_data[31] && br_config[2]) br_holdoff <= i_bus_data[(HOLDOFFBITS-1):0]; end // // Reset",
            "logic if (bw_reset_complete) // Clear the reset request, reg ardless of the write br_config[2] <= 1'b1; else if (!br_config[2]) // Reset request is already pending--don't change it br_config[2] <= 1'b0; else if (write_to_control && !i_bus_data[31]) // Initiate a new reset request // Note that we won't initiate a new reset request // while one is already pending. Once the pending // one completes we'll be in the reset state anyway br_config[2] <= 1'b0; // if (i_reset) // br_config[2] <= 1'b0; end",
            "assign bw_reset_request = (!br_config[2]);",
            "assign bw_manual_trigger = (br_config[1]);",
            "assign bw_disable_trigger = (br_config[0]); generate if (SYNCHRONOUS > 0) begin : GEN_SYNCHRONOUS",
            "assign dw_reset = bw_reset_request;",
            "assign dw_manual_trigger = bw_manual_trigger;",
            "assign dw_disable_trigger = bw_disable_trigger;",
            "assign bw_reset_complete = bw_reset_request; end else begin : GEN_ASYNC",
            "reg r_reset_complete; (* ASYNC_REG = \"TRUE\" *)",
            "reg [2:0] q_iflags;",
            "reg [2:0] r_iflags; // Resets are synchronous to the bus clock, not the data clock // so do a clock transfer here",
            "initial { q_iflags, r_iflags } = 6'h0;",
            "initial r_reset_complete = 1'b0;",
            "always @(posedge i_data_clk) begin q_iflags <= { bw_reset_request, bw_manual_trigger, bw_disable_trigger }; r_iflags <= q_iflags; r_reset_complete <= (dw_reset); end",
            "assign dw_reset = r_iflags[2];",
            "assign dw_manual_trigger = r_iflags[1];",
            "assign dw_disable_trigger = r_iflags[0]; (* ASYNC_REG = \"TRUE\" *)",
            "reg q_reset_complete, qq_reset_complete; // Pass an acknowledgement back from the data clock to the bus // clock that the reset has been accomplished",
            "initial q_reset_complete = 1'b0;",
            "initial qq_reset_complete = 1'b0;",
            "always @(posedge bus_clock) begin q_reset_complete <= r_reset_complete; qq_reset_complete <= q_reset_complete; end",
            "assign bw_reset_complete = qq_reset_complete; `ifdef FORMAL",
            "always @(posedge gbl_clk) if (f_past_valid_data) begin if ($rose(r_reset_complete)) assert(bw_reset_request); end",
            "always @(*) case({ bw_reset_request, q_iflags[2], dw_reset, q_reset_complete, qq_reset_complete }) 5'h00: begin end 5'h10: begin end 5'h18: begin end 5'h1c: begin end 5'h1e: begin end 5'h1f: begin end 5'h0f: begin end 5'h07: begin end 5'h03: begin end 5'h01: begin end default: assert(0); endcase `endif end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Set up the trigger // {{{ //////////////////////////////////////////////////////////////////////// // // // dw_trigger -- trigger",
            "wire , defined on the data clock // {{{ // Write with the i_clk, or",
            "input clock. All",
            "output s read with the // bus clock, or i_wb_clk as we've called it here.",
            "assign dw_trigger = (dr_primed)&&( ((i_trigger)&&(!dw_disable_trigger)) ||(dw_manual_trigger)); // }}} // dr_triggered // {{{",
            "initial dr_triggered = 1'b0;",
            "always @(posedge i_data_clk) if (dw_reset) dr_triggered <= 1'b0; else if ((i_ce)&&(dw_trigger)) dr_triggered <= 1'b1; // }}} // // Determine when memory is full and capture is complete // // Writes take place on the data clock // counter // {{{ // The counter is unsigned",
            "initial counter = 0;",
            "always @(posedge i_data_clk) if (dw_reset) counter <= 0; else if ((i_ce)&&(dr_triggered)&&(!dr_stopped)) counter <= counter + 1'b1; `ifdef FORMAL",
            "always @(*) if (!dw_reset && !bw_reset_request) assert(counter <= br_holdoff+1'b1);",
            "always @(posedge i_data_clk) assume(!(&br_holdoff));",
            "always @(posedge i_data_clk) if (!dr_triggered) assert(counter == 0); `endif // }}} // dr_stopped // {{{",
            "initial dr_stopped = 1'b0;",
            "always @(posedge i_data_clk) if ((!dr_triggered)||(dw_reset)) dr_stopped <= 1'b0; else if (!dr_stopped) begin if (HOLDOFFBITS > 1) // if (i_ce) dr_stopped <= (counter >= br_holdoff); else if (HOLDOFFBITS <= 1) dr_stopped <= ((i_ce)&&(dw_trigger)); end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Write to memory // {{{ //////////////////////////////////////////////////////////////////////// // // // // Actually do our writes to memory. Record, via 'primed' when // the memory is full. // // The 'waddr' address that we are using really crosses two clock // domains. While writing and changing, it's in the data clock // domain. Once stopped, it becomes part of the bus clock domain. // The clock transfer on the stopped line handles the clock // transfer for these signals. // // waddr, dr_primed // {{{",
            "initial waddr = {(LGMEM){1'b0}};",
            "initial dr_primed = 1'b0;",
            "always @(posedge i_data_clk) if (dw_reset) // For simulation purposes, supply a valid value begin waddr <= 0; // upon reset. dr_primed <= 1'b0; end else if (i_ce && !dr_stopped) begin // mem[waddr] <= i_data; waddr <= waddr + {{(LGMEM-1){1'b0}},1'b1}; if (!dr_primed) dr_primed <= (&waddr); end // }}} // wr_piped_data -- delay data to match the trigger // {{{ // Delay the incoming data so that we can get our trigger // logic to line up with the data. The goal is to have a // hold off of zero place the trigger in the last memory // address. generate if (STOPDELAY == 0) begin : NO_STOPDLY // No delay ... just",
            "assign the",
            "wire s to our",
            "input lines",
            "assign wr_piped_data = i_data; end else if (STOPDELAY == 1) begin : GEN_ONE_STOPDLY // // Delay by one means just",
            "reg ister this once",
            "reg [(BUSW-1):0] data_pipe;",
            "always @(posedge i_data_clk) if (i_ce) data_pipe <= i_data;",
            "assign wr_piped_data = data_pipe; end else begin : GEN_STOPDELAY // Arbitrary delay ... use a longer pipe",
            "reg [(STOPDELAY*BUSW-1):0] data_pipe;",
            "always @(posedge i_data_clk) if (i_ce) data_pipe <= { data_pipe[((STOPDELAY-1)*BUSW-1):0], i_data };",
            "assign wr_piped_data = { data_pipe[(STOPDELAY*BUSW-1):((STOPDELAY-1)*BUSW)] }; end endgenerate // }}} // mem[] <= wr_piped_data // {{{",
            "always @(posedge i_data_clk) if ((i_ce)&&(!dr_stopped)) mem[waddr] <= wr_piped_data; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Move the status signals back to the bus clock // {{{ //////////////////////////////////////////////////////////////////////// // generate if (SYNCHRONOUS > 0) begin : SYNCHRONOUS_RETURN",
            "assign bw_stopped = dr_stopped;",
            "assign bw_triggered = dr_triggered;",
            "assign bw_primed = dr_primed; end else begin : ASYNC_STATUS // {{{ // These aren't a problem, since none of these are strobe // signals. They goes from low to high, and then stays high // for many clocks. Swapping is thus easy--two flip flops to // protect against meta-stability and we're done. // (* ASYNC_REG = \"TRUE\" *)",
            "reg [2:0] q_oflags;",
            "reg [2:0] r_oflags;",
            "initial q_oflags = 3'h0;",
            "initial r_oflags = 3'h0;",
            "always @(posedge bus_clock) if (bw_reset_request) begin q_oflags <= 3'h0; r_oflags <= 3'h0; end else begin q_oflags <= { dr_stopped, dr_triggered, dr_primed }; r_oflags <= q_oflags; end",
            "assign bw_stopped = r_oflags[2];",
            "assign bw_triggered = r_oflags[1];",
            "assign bw_primed = r_oflags[0]; // }}} `ifdef FORMAL",
            "always @(*) if (!bw_reset_request) begin if (bw_primed) assert(q_oflags[0] && dr_primed); else if (q_oflags[0]) assert(dr_primed); if (bw_triggered) assert(q_oflags[1] && dr_triggered); else if (q_oflags[1]) assert(dr_triggered); if (bw_stopped) assert(q_oflags[2] && dr_stopped); else if (q_oflags[2]) assert(dr_stopped); end `endif end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Read from the memory, using the bus clock. Otherwise respond to bus // {{{ //////////////////////////////////////////////////////////////////////// // // // Reads use the bus clock",
            "assign bw_cyc_stb = (i_wb_stb);",
            "initial br_pre_wb_ack = 1'b0;",
            "initial br_wb_ack = 1'b0;",
            "always @(posedge bus_clock) begin if ((bw_reset_request)||(write_to_control)) raddr <= 0; else if ((read_from_data)&&(bw_stopped)) raddr <= raddr + 1'b1; // Data read, when stopped br_pre_wb_ack <= bw_cyc_stb; br_wb_ack <= (br_pre_wb_ack)&&(i_wb_cyc); end",
            "assign o_wb_ack = (i_wb_cyc)&&(br_wb_ack);",
            "always @(posedge bus_clock) if (read_from_data) this_addr <= raddr + waddr + 1'b1; else this_addr <= raddr + waddr;",
            "always @(posedge bus_clock) nxt_mem <= mem[this_addr]; // holdoff sub-",
            "reg ister // {{{",
            "assign full_holdoff[(HOLDOFFBITS-1):0] = br_holdoff; generate if (HOLDOFFBITS < 20) begin : GEN_FULL_HOLDOFF",
            "assign full_holdoff[19:(HOLDOFFBITS)] = 0; end endgenerate // }}}",
            "assign bw_lgmem = LGMEM; // Bus read // {{{",
            "always @(posedge bus_clock) begin if (!read_address) // Control",
            "reg ister read o_bus_data <= { bw_reset_request, bw_stopped, bw_triggered, bw_primed, bw_manual_trigger, bw_disable_trigger, (raddr == {(LGMEM){1'b0}}), bw_lgmem, full_holdoff }; else if (!bw_stopped) // read, prior to stopping // // *WARNING*: THIS READ IS NOT PROTECTED FROM // ASYNCHRONOUS COHERENCE ISSUES! // o_bus_data <= i_data; else // if (i_wb_addr) // Read from FIFO memory o_bus_data <= nxt_mem; // mem[raddr+waddr]; end // }}}",
            "assign o_wb_data = o_bus_data; // }}} //////////////////////////////////////////////////////////////////////// // // Interrupt generation // {{{ //////////////////////////////////////////////////////////////////////// // // initial br_level_interrupt = 1'b0;",
            "always @(posedge bus_clock) if ((bw_reset_complete)||(bw_reset_request)) br_level_interrupt<= 1'b0; else br_level_interrupt<= (bw_stopped)&&(!bw_disable_trigger);",
            "assign o_interrupt = (bw_stopped)&&(!bw_disable_trigger) &&(!br_level_interrupt); // }}} // Make verilator happy // {{{ // verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, i_bus_data[30:28], i_bus_data[25:0], i_wb_sel }; // verilator lint_on UNUSED // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "iscachable.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/iscachable.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/iscachable.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A helper function to both dcache and its formal properties, // used to determine when a particular address is cachable. This // module must be built of entirely combinatorial",
            "logic and nothing more. // // This particular version is taylored to the test bench configuration // of the ZipCPU. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2018-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module iscachable #( // {{{",
            "parameter ADDRESS_WIDTH=28, localparam AW = ADDRESS_WIDTH, // Just for ease of notation below",
            "parameter [AW-1:0] MEM_ADDR = {4'b0100, {(ADDRESS_WIDTH-4){1'b0}} }, parameter [AW-1:0] MEM_MASK = {4'b1111, {(ADDRESS_WIDTH-4){1'b0}} } // }}} ) ( // {{{",
            "input wire [AW-1:0] i_addr, output reg o_cachable // }}} );",
            "always @(*) begin o_cachable = 1'b0; if ((MEM_ADDR !=0)&&((i_addr & MEM_MASK)== MEM_ADDR)) o_cachable = 1'b1; end",
            "endmodule"
        ]
    },
    {
        "file_name": "axilcon.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axilcon.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/axilcon // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A basic AXI-Lite console port controller. It has the same // interface as the WBUART core in the same directory. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2020-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}} // module axilcon #( // {{{ // Size of the AXI-lite bus. These are fixed, since 1) AXI-lite // is fixed at a width of 32-bits by Xilinx def'n, and 2) since // we only ever have 4 configuration words.",
            "parameter C_AXI_ADDR_WIDTH = 4, localparam C_AXI_DATA_WIDTH = 32, parameter [0:0] OPT_SKIDBUFFER = 1'b0, parameter [0:0] OPT_LOWPOWER = 0, localparam ADDRLSB = $clog2(C_AXI_DATA_WIDTH)-3, parameter CONSOLE_FILE = 0 // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, // input wire S_AXI_AWVALID, output wire S_AXI_AWREADY, input wire [C_AXI_ADDR_WIDTH-1:0] S_AXI_AWADDR, // verilator coverage_off",
            "input wire [2:0] S_AXI_AWPROT, // verilator coverage_on // input wire S_AXI_WVALID, output wire S_AXI_WREADY, input wire [C_AXI_DATA_WIDTH-1:0] S_AXI_WDATA, input wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB, // output wire S_AXI_BVALID, input wire S_AXI_BREADY, // verilator coverage_off",
            "output wire [1:0] S_AXI_BRESP, // verilator coverage_on // input wire S_AXI_ARVALID, output wire S_AXI_ARREADY, input wire [C_AXI_ADDR_WIDTH-1:0] S_AXI_ARADDR, input wire [2:0] S_AXI_ARPROT, // output wire S_AXI_RVALID, input wire S_AXI_RREADY, // verilator coverage_off",
            "output wire [C_AXI_DATA_WIDTH-1:0] S_AXI_RDATA, output wire [1:0] S_AXI_RRESP // verilator coverage_on // }}} ); //////////////////////////////////////////////////////////////////////// // // Register/",
            "wire signal declarations // {{{ //////////////////////////////////////////////////////////////////////// // // integer sim_console;",
            "wire i_reset = !S_AXI_ARESETN;",
            "wire axil_write_ready;",
            "wire [C_AXI_ADDR_WIDTH-ADDRLSB-1:0] awskd_addr; // wire [C_AXI_DATA_WIDTH-1:0] wskd_data;",
            "wire [C_AXI_DATA_WIDTH/8-1:0] wskd_strb;",
            "reg axil_bvalid; // wire axil_read_ready;",
            "wire [C_AXI_ADDR_WIDTH-ADDRLSB-1:0] arskd_addr;",
            "reg [C_AXI_DATA_WIDTH-1:0] axil_read_data;",
            "reg axil_read_valid; // // wire [31:0] axil_rx_data;",
            "wire [31:0] axil_tx_data; // }}} //////////////////////////////////////////////////////////////////////// // // AXI-lite signaling // {{{ //////////////////////////////////////////////////////////////////////// // // // // Write signaling // // {{{ generate if (OPT_SKIDBUFFER) begin : SKIDBUFFER_WRITE",
            "wire awskd_valid, wskd_valid; skidbuffer #(.OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(C_AXI_ADDR_WIDTH-ADDRLSB)) axilawskid(// .i_clk(S_AXI_ACLK), .i_reset(i_reset), .i_valid(S_AXI_AWVALID), .o_ready(S_AXI_AWREADY), .i_data(S_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB]), .o_valid(awskd_valid), .i_ready(axil_write_ready), .o_data(awskd_addr)); skidbuffer #(.OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(C_AXI_DATA_WIDTH+C_AXI_DATA_WIDTH/8)) axilwskid(// .i_clk(S_AXI_ACLK), .i_reset(i_reset), .i_valid(S_AXI_WVALID), .o_ready(S_AXI_WREADY), .i_data({ S_AXI_WDATA, S_AXI_WSTRB }), .o_valid(wskd_valid), .i_ready(axil_write_ready), .o_data({ wskd_data, wskd_strb }));",
            "assign axil_write_ready = awskd_valid && wskd_valid && (!S_AXI_BVALID || S_AXI_BREADY); end else begin : SIMPLE_WRITES",
            "reg axil_awready;",
            "initial axil_awready = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axil_awready <= 1'b0; else axil_awready <= !axil_awready && (S_AXI_AWVALID && S_AXI_WVALID) && (!S_AXI_BVALID || S_AXI_BREADY);",
            "assign S_AXI_AWREADY = axil_awready;",
            "assign S_AXI_WREADY = axil_awready;",
            "assign awskd_addr = S_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB];",
            "assign wskd_data = S_AXI_WDATA;",
            "assign wskd_strb = S_AXI_WSTRB;",
            "assign axil_write_ready = axil_awready; end endgenerate",
            "initial axil_bvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (i_reset) axil_bvalid <= 0; else if (axil_write_ready) axil_bvalid <= 1; else if (S_AXI_BREADY) axil_bvalid <= 0;",
            "assign S_AXI_BVALID = axil_bvalid;",
            "assign S_AXI_BRESP = 2'b00; // }}} // // Read signaling // // {{{ generate if (OPT_SKIDBUFFER) begin : SKIDBUFFER_READ",
            "wire arskd_valid; skidbuffer #(.OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER), .DW(C_AXI_ADDR_WIDTH-ADDRLSB)) axilarskid(// .i_clk(S_AXI_ACLK), .i_reset(i_reset), .i_valid(S_AXI_ARVALID), .o_ready(S_AXI_ARREADY), .i_data(S_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB]), .o_valid(arskd_valid), .i_ready(axil_read_ready), .o_data(arskd_addr)); // High bandwidth reads",
            "assign axil_read_ready = arskd_valid && (!axil_read_valid || S_AXI_RREADY); end else begin : SIMPLE_READS",
            "reg axil_arready;",
            "initial axil_arready = 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axil_arready <= 1; else if (S_AXI_ARVALID && S_AXI_ARREADY) axil_arready <= 0; else if (S_AXI_RVALID && S_AXI_RREADY) axil_arready <= 1;",
            "assign arskd_addr = S_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB];",
            "assign S_AXI_ARREADY = axil_arready;",
            "assign axil_read_ready = (S_AXI_ARVALID && S_AXI_ARREADY); end endgenerate",
            "initial axil_read_valid = 1'b0;",
            "always @(posedge S_AXI_ACLK) if (i_reset) axil_read_valid <= 1'b0; else if (!S_AXI_RVALID || S_AXI_RREADY) axil_read_valid <= axil_read_ready;",
            "assign S_AXI_RVALID = axil_read_valid;",
            "assign S_AXI_RDATA = axil_read_data;",
            "assign S_AXI_RRESP = 2'b00; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // AXI-lite",
            "reg ister",
            "logic // {{{ //////////////////////////////////////////////////////////////////////// // // localparam [1:0] UART_SETUP = 2'b00, UART_FIFO = 2'b01, UART_RXREG = 2'b10, UART_TXREG = 2'b11;",
            "assign axil_rx_data = 32'h0;",
            "initial if (CONSOLE_FILE != 0) begin sim_console = $fopen(CONSOLE_FILE); end",
            "always @(posedge S_AXI_ACLK) if (axil_write_ready && awskd_addr == UART_TXREG && wskd_strb[0]) begin if (CONSOLE_FILE != 0) begin $fwrite(sim_console, \"%1s\", wskd_data[7:0]); if (wskd_data[7:0] == 8'h0a) $fflush(sim_console); end $write(\"%1s\", wskd_data[7:0]); end",
            "assign axil_tx_data = 32'h0; // Finally, set the return data. This data must be valid on the same // clock S_AXI_RVALID is high. On all other clocks, it is // irrelelant--since no one cares, no one is reading it, it gets lost // in the mux in the interconnect, etc. For this reason, we can just // simplify our",
            "logic .",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_RVALID || S_AXI_RREADY) begin casez(arskd_addr) UART_SETUP: axil_read_data <= 32'h0; UART_FIFO: axil_read_data <= 32'h0; UART_RXREG: axil_read_data <= axil_rx_data; UART_TXREG: axil_read_data <= axil_tx_data; endcase if (OPT_LOWPOWER && !axil_read_ready) axil_read_data <= 0; end // }}} //////////////////////////////////////////////////////////////////////// // // Veri1ator lint-check // {{{ // verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, S_AXI_AWPROT, S_AXI_ARPROT, S_AXI_ARADDR[ADDRLSB-1:0], S_AXI_AWADDR[ADDRLSB-1:0], wskd_data[31:8], wskd_strb[3:1] }; // Verilator lint_on UNUSED // verilator coverage_on // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "demofull.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/demofull.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/demofull.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Demonstrate a formally verified AXI4 core with a (basic) // interface. This interface is explained below. // // Performance: This core has been designed for a total throughput of one beat // per clock cycle. Both read and write channels can achieve // this. The write channel will also introduce two clocks of latency, // assuming no other latency from the master. This means it will take // a minimum of 3+AWLEN clock cycles per transaction of (1+AWLEN) beats, // including both address and acknowledgment cycles. The read channel // will introduce a single clock of latency, requiring 2+ARLEN cycles // per transaction of 1+ARLEN beats. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2019-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module demofull #( // {{{",
            "parameter integer C_S_AXI_ID_WIDTH = 2, parameter integer C_S_AXI_DATA_WIDTH = 32, parameter integer C_S_AXI_ADDR_WIDTH = 6, parameter [0:0] OPT_LOCK = 1'b0, parameter [0:0] OPT_LOCKID = 1'b1, parameter [0:0] OPT_LOWPOWER = 1'b0, // Some useful short-hand definitions",
            "localparam LSB = $clog2(C_S_AXI_DATA_WIDTH)-3 // }}} ) ( // {{{ // User ports // {{{ // A very basic protocol-independent peripheral interface // 1. A value will be written any time o_we is true // 2. A value will be read any time o_rd is true // 3. Such a slave might just as easily be written as: // // always @(posedge S_AXI_ACLK) // if (o_we) // begin // for(k=0; k<C_S_AXI_DATA_WIDTH/8; k=k+1) // begin // if (o_wstrb[k]) // mem[o_waddr][k*8+:8] <= o_wdata[k*8+:8] // end // end // // always @(posedge S_AXI_ACLK) // if (o_rd) // i_rdata <= mem[o_raddr]; // // 4. The rule on the",
            "input is that i_rdata must be",
            "reg istered, // and that it must only change if o_rd is true. Violating // this rule will cause this core to violate the AXI // protocol standard, as this value is not",
            "reg istered within // this core",
            "output reg o_we, output reg [C_S_AXI_ADDR_WIDTH-LSB-1:0] o_waddr, output reg [C_S_AXI_DATA_WIDTH-1:0] o_wdata, output reg [C_S_AXI_DATA_WIDTH/8-1:0] o_wstrb, // output reg o_rd, output reg [C_S_AXI_ADDR_WIDTH-LSB-1:0] o_raddr, input wire [C_S_AXI_DATA_WIDTH-1:0] i_rdata, // // User ports ends // }}} // Do not modify the ports beyond this line // AXI signals // {{{ // Global Clock Signal",
            "input wire S_AXI_ACLK, // Global Reset Signal. This Signal is Active LOW",
            "input wire S_AXI_ARESETN, // Write address channel // {{{ // Write Address ID",
            "input wire [C_S_AXI_ID_WIDTH-1 : 0] S_AXI_AWID, // Write address",
            "input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR, // Burst length. The burst length gives the exact number of // transfers in a burst",
            "input wire [7 : 0] S_AXI_AWLEN, // Burst size. This signal indicates the size of each transfer // in the burst",
            "input wire [2 : 0] S_AXI_AWSIZE, // Burst type. The burst type and the size information, // determine how the address for each transfer within the burst // is calculated.",
            "input wire [1 : 0] S_AXI_AWBURST, // Lock type. Provides additional information about the // atomic characteristics of the transfer.",
            "input wire S_AXI_AWLOCK, // Memory type. This signal indicates how transactions // are required to progress through a system.",
            "input wire [3 : 0] S_AXI_AWCACHE, // Verilator coverage_off // Protection type. This signal indicates the privilege // and security level of the transaction, and whether // the transaction is a data access or an instruction access.",
            "input wire [2 : 0] S_AXI_AWPROT, // Quality of Service, QoS identifier sent for each // write transaction.",
            "input wire [3 : 0] S_AXI_AWQOS, // Verilator coverage_on // Write address valid. This signal indicates that // the channel is signaling valid write address and // control information.",
            "input wire S_AXI_AWVALID, // Write address ready. This signal indicates that // the slave is ready to accept an address and associated // control signals.",
            "output wire S_AXI_AWREADY, // }}} // Write data channel // {{{ // Write Data",
            "input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA, // Write strobes. This signal indicates which byte // lanes hold valid data. There is one write strobe // bit for each eight bits of the write data bus.",
            "input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB, // Write last. This signal indicates the last transfer // in a write burst.",
            "input wire S_AXI_WLAST, // Optional User-defined signal in the write data channel. // Write valid. This signal indicates that valid write // data and strobes are available.",
            "input wire S_AXI_WVALID, // Write ready. This signal indicates that the slave // can accept the write data.",
            "output wire S_AXI_WREADY, // }}} // Write response channel // {{{ // Response ID tag. This signal is the ID tag of the // write response.",
            "output wire [C_S_AXI_ID_WIDTH-1 : 0] S_AXI_BID, // Write response. This signal indicates the status // of the write transaction.",
            "output wire [1 : 0] S_AXI_BRESP, // Optional User-defined signal in the write response channel. // Write response valid. This signal indicates that the // channel is signaling a valid write response.",
            "output wire S_AXI_BVALID, // Response ready. This signal indicates that the master // can accept a write response.",
            "input wire S_AXI_BREADY, // }}} // Read address channel // {{{ // Read address ID. This signal is the identification // tag for the read address group of signals.",
            "input wire [C_S_AXI_ID_WIDTH-1 : 0] S_AXI_ARID, // Read address. This signal indicates the",
            "initial // address of a read burst transaction.",
            "input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR, // Burst length. The burst length gives the exact number of // transfers in a burst",
            "input wire [7 : 0] S_AXI_ARLEN, // Burst size. This signal indicates the size of each transfer // in the burst",
            "input wire [2 : 0] S_AXI_ARSIZE, // Burst type. The burst type and the size information, // determine how the address for each transfer within the // burst is calculated.",
            "input wire [1 : 0] S_AXI_ARBURST, // Lock type. Provides additional information about the // atomic characteristics of the transfer.",
            "input wire S_AXI_ARLOCK, // Memory type. This signal indicates how transactions // are required to progress through a system.",
            "input wire [3 : 0] S_AXI_ARCACHE, // // Verilator coverage_off // Protection type. This signal indicates the privilege // and security level of the transaction, and whether // the transaction is a data access or an instruction access.",
            "input wire [2 : 0] S_AXI_ARPROT, // Quality of Service, QoS identifier sent for each // read transaction.",
            "input wire [3 : 0] S_AXI_ARQOS, // Verilator coverage_on // // Write address valid. This signal indicates that // the channel is signaling valid read address and // control information.",
            "input wire S_AXI_ARVALID, // Read address ready. This signal indicates that // the slave is ready to accept an address and associated // control signals.",
            "output wire S_AXI_ARREADY, // }}} // Read data (return) channel // {{{ // Read ID tag. This signal is the identification tag // for the read data group of signals generated by the slave.",
            "output wire [C_S_AXI_ID_WIDTH-1 : 0] S_AXI_RID, // Read Data",
            "output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA, // Read response. This signal indicates the status of // the read transfer.",
            "output wire [1 : 0] S_AXI_RRESP, // Read last. This signal indicates the last transfer // in a read burst.",
            "output wire S_AXI_RLAST, // Optional User-defined signal in the read address channel. // Read valid. This signal indicates that the channel // is signaling the required read data.",
            "output wire S_AXI_RVALID, // Read ready. This signal indicates that the master can // accept the read data and response information.",
            "input wire S_AXI_RREADY // }}} // }}} // }}} ); // Local declarations // {{{ // More useful shorthand definitions",
            "localparam AW = C_S_AXI_ADDR_WIDTH;",
            "localparam DW = C_S_AXI_DATA_WIDTH;",
            "localparam IW = C_S_AXI_ID_WIDTH; // Double buffer the write response channel only",
            "reg [IW-1 : 0] r_bid;",
            "reg r_bvalid;",
            "reg [IW-1 : 0] axi_bid;",
            "reg axi_bvalid;",
            "reg axi_awready, axi_wready;",
            "reg [AW-1:0] waddr;",
            "wire [AW-1:0] next_wr_addr; // Vivado will warn about wlen only using 4-bits. This is // to be expected, since the axi_addr",
            "module only needs to use // the bottom four bits of wlen to determine address increments",
            "reg [7:0] wlen; // Vivado will also warn about the top bit of wsize being unused. // This is also to be expected for a DATA_WIDTH of 32-bits.",
            "reg [2:0] wsize;",
            "reg [1:0] wburst;",
            "wire m_awvalid, m_awlock;",
            "reg m_awready;",
            "wire [AW-1:0] m_awaddr;",
            "wire [1:0] m_awburst;",
            "wire [2:0] m_awsize;",
            "wire [7:0] m_awlen;",
            "wire [IW-1:0] m_awid;",
            "wire [AW-1:0] next_rd_addr; // Vivado will warn about rlen only using 4-bits. This is // to be expected, since for a DATA_WIDTH of 32-bits, the axi_addr // module only uses the bottom four bits of rlen to determine // address increments",
            "reg [7:0] rlen; // Vivado will also warn about the top bit of wsize being unused. // This is also to be expected for a DATA_WIDTH of 32-bits.",
            "reg [2:0] rsize;",
            "reg [1:0] rburst;",
            "reg [IW-1:0] rid;",
            "reg rlock;",
            "reg axi_arready;",
            "reg [8:0] axi_rlen;",
            "reg [AW-1:0] raddr; // Read skid buffer",
            "reg rskd_valid, rskd_last, rskd_lock;",
            "wire rskd_ready;",
            "reg [IW-1:0] rskd_id; // Exclusive address",
            "reg ister checking",
            "reg exclusive_write, block_write;",
            "wire write_lock_valid;",
            "reg axi_exclusive_write; // }}} //////////////////////////////////////////////////////////////////////// // // AW Skid buffer // {{{ //////////////////////////////////////////////////////////////////////// // // skidbuffer #( // {{{ .DW(AW+2+3+1+8+IW), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_OUTREG(1'b0) // }}} ) awbuf( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(S_AXI_AWVALID), .o_ready(S_AXI_AWREADY), .i_data({ S_AXI_AWADDR, S_AXI_AWBURST, S_AXI_AWSIZE, S_AXI_AWLOCK, S_AXI_AWLEN, S_AXI_AWID }), .o_valid(m_awvalid), .i_ready(m_awready), .o_data({ m_awaddr, m_awburst, m_awsize, m_awlock, m_awlen, m_awid }) // }}} ); // }}} //////////////////////////////////////////////////////////////////////// // // Write processing // {{{ //////////////////////////////////////////////////////////////////////// // // // axi_awready, axi_wready // {{{",
            "initial axi_awready = 1;",
            "initial axi_wready = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin axi_awready <= 1; axi_wready <= 0; end else if (m_awvalid && m_awready) begin axi_awready <= 0; axi_wready <= 1; end else if (S_AXI_WVALID && S_AXI_WREADY) begin axi_awready <= (S_AXI_WLAST)&&(!S_AXI_BVALID || S_AXI_BREADY); axi_wready <= (!S_AXI_WLAST); end else if (!axi_awready) begin if (S_AXI_WREADY) axi_awready <= 1'b0; else if (r_bvalid && !S_AXI_BREADY) axi_awready <= 1'b0; else axi_awready <= 1'b1; end // }}} // Exclusive write calculation // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !OPT_LOCK) begin exclusive_write <= 0; block_write <= 0; end else if (m_awvalid && m_awready) begin exclusive_write <= 1'b0; block_write <= 1'b0; if (write_lock_valid) exclusive_write <= 1'b1; else if (m_awlock) block_write <= 1'b1; end else if (m_awready) begin exclusive_write <= 1'b0; block_write <= 1'b0; end",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !OPT_LOCK) axi_exclusive_write <= 0; else if (!S_AXI_BVALID || S_AXI_BREADY) begin axi_exclusive_write <= exclusive_write; if (OPT_LOWPOWER && (!S_AXI_WVALID || !S_AXI_WREADY || !S_AXI_WLAST) && !r_bvalid) axi_exclusive_write <= 0; end // }}} // Next write address calculation // {{{",
            "always @(posedge S_AXI_ACLK) if (m_awready) begin waddr <= m_awaddr; wburst <= m_awburst; wsize <= m_awsize; wlen <= m_awlen; end else if (S_AXI_WVALID) waddr <= next_wr_addr; axi_addr #( // {{{ .AW(AW), .DW(DW) // }}} ) get_next_wr_addr( // {{{ waddr, wsize, wburst, wlen, next_wr_addr // }}} ); // }}} // o_w* // {{{",
            "always @(posedge S_AXI_ACLK) begin o_we <= (S_AXI_WVALID && S_AXI_WREADY); o_waddr <= waddr[AW-1:LSB]; o_wdata <= S_AXI_WDATA; if (block_write) o_wstrb <= 0; else o_wstrb <= S_AXI_WSTRB; if (!S_AXI_ARESETN) o_we <= 0; if (OPT_LOWPOWER && (!S_AXI_ARESETN || !S_AXI_WVALID || !S_AXI_WREADY)) begin o_waddr <= 0; o_wdata <= 0; o_wstrb <= 0; end end // }}} // // Write return path // {{{ // r_bvalid // {{{",
            "initial r_bvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_bvalid <= 1'b0; else if (S_AXI_WVALID && S_AXI_WREADY && S_AXI_WLAST &&(S_AXI_BVALID && !S_AXI_BREADY)) r_bvalid <= 1'b1; else if (S_AXI_BREADY) r_bvalid <= 1'b0; // }}} // r_bid, axi_bid // {{{",
            "initial r_bid = 0;",
            "initial axi_bid = 0;",
            "always @(posedge S_AXI_ACLK) begin if (m_awready && (!OPT_LOWPOWER || m_awvalid)) r_bid <= m_awid; if (!S_AXI_BVALID || S_AXI_BREADY) axi_bid <= r_bid; if (OPT_LOWPOWER && !S_AXI_ARESETN) begin r_bid <= 0; axi_bid <= 0; end end // }}} // axi_bvalid // {{{",
            "initial axi_bvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_bvalid <= 0; else if (S_AXI_WVALID && S_AXI_WREADY && S_AXI_WLAST) axi_bvalid <= 1; else if (S_AXI_BREADY) axi_bvalid <= r_bvalid; // }}} // m_awready // {{{",
            "always @(*) begin m_awready = axi_awready; if (S_AXI_WVALID && S_AXI_WREADY && S_AXI_WLAST && (!S_AXI_BVALID || S_AXI_BREADY)) m_awready = 1; end // }}} // At one time, axi_awready was the same as S_AXI_AWREADY. Now, though, // with the extra write address skid buffer, this is no longer the case. // S_AXI_AWREADY is handled/created/managed by the skid buffer. // // assign S_AXI_AWREADY = axi_awready; // // The rest of these signals can be set according to their",
            "reg istered // values above.",
            "assign S_AXI_WREADY = axi_wready;",
            "assign S_AXI_BVALID = axi_bvalid;",
            "assign S_AXI_BID = axi_bid; // // This core does not produce any bus errors, nor does it support // exclusive access, so 2'b00 will",
            "always be the correct response.",
            "assign S_AXI_BRESP = { 1'b0, axi_exclusive_write }; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Read processing // {{{ //////////////////////////////////////////////////////////////////////// // // // axi_arready // {{{",
            "initial axi_arready = 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_arready <= 1; else if (S_AXI_ARVALID && S_AXI_ARREADY) axi_arready <= (S_AXI_ARLEN==0)&&(o_rd); else if (o_rd) axi_arready <= (axi_rlen <= 1); // }}} // axi_rlen // {{{",
            "initial axi_rlen = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_rlen <= 0; else if (S_AXI_ARVALID && S_AXI_ARREADY) axi_rlen <= S_AXI_ARLEN + (o_rd ? 0:1); else if (o_rd) axi_rlen <= axi_rlen - 1; // }}} // Next read address calculation // {{{",
            "always @(posedge S_AXI_ACLK) if (o_rd) raddr <= next_rd_addr; else if (S_AXI_ARREADY) begin raddr <= S_AXI_ARADDR; if (OPT_LOWPOWER && !S_AXI_ARVALID) raddr <= 0; end // r* // {{{",
            "always @(posedge S_AXI_ACLK) if (S_AXI_ARREADY) begin rburst <= S_AXI_ARBURST; rsize <= S_AXI_ARSIZE; rlen <= S_AXI_ARLEN; rid <= S_AXI_ARID; rlock <= S_AXI_ARLOCK && S_AXI_ARVALID && OPT_LOCK; if (OPT_LOWPOWER && !S_AXI_ARVALID) begin rburst <= 0; rsize <= 0; rlen <= 0; rid <= 0; rlock <= 0; end end // }}} axi_addr #( // {{{ .AW(AW), .DW(DW) // }}} ) get_next_rd_addr( // {{{ (S_AXI_ARREADY ? S_AXI_ARADDR : raddr), (S_AXI_ARREADY ? S_AXI_ARSIZE : rsize), (S_AXI_ARREADY ? S_AXI_ARBURST: rburst), (S_AXI_ARREADY ? S_AXI_ARLEN : rlen), next_rd_addr // }}} ); // }}} // o_rd, o_raddr // {{{",
            "always @(*) begin o_rd = (S_AXI_ARVALID || !S_AXI_ARREADY); if (S_AXI_RVALID && !S_AXI_RREADY) o_rd = 0; if (rskd_valid && !rskd_ready) o_rd = 0; o_raddr = (S_AXI_ARREADY ? S_AXI_ARADDR[AW-1:LSB] : raddr[AW-1:LSB]); end // }}} // rskd_valid // {{{",
            "initial rskd_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) rskd_valid <= 0; else if (o_rd) rskd_valid <= 1; else if (rskd_ready) rskd_valid <= 0; // }}} // rskd_id // {{{",
            "always @(posedge S_AXI_ACLK) if (!rskd_valid || rskd_ready) begin if (S_AXI_ARVALID && S_AXI_ARREADY) rskd_id <= S_AXI_ARID; else rskd_id <= rid; end // }}} // rskd_last // {{{",
            "initial rskd_last = 0;",
            "always @(posedge S_AXI_ACLK) if (!rskd_valid || rskd_ready) begin rskd_last <= 0; if (o_rd && axi_rlen == 1) rskd_last <= 1; if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN == 0) rskd_last <= 1; end // }}} // rskd_lock // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !OPT_LOCK) rskd_lock <= 1'b0; else if (!rskd_valid || rskd_ready) begin rskd_lock <= 0; if (!OPT_LOWPOWER || o_rd) begin if (S_AXI_ARVALID && S_AXI_ARREADY) rskd_lock <= S_AXI_ARLOCK; else rskd_lock <= rlock; end end // }}} // Outgoing read skidbuffer // {{{ skidbuffer #( // {{{ .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_OUTREG(1), .DW(IW+2+DW) // }}} ) rskid ( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(rskd_valid), .o_ready(rskd_ready), .i_data({ rskd_id, rskd_lock, rskd_last, i_rdata }), .o_valid(S_AXI_RVALID), .i_ready(S_AXI_RREADY), .o_data({ S_AXI_RID, S_AXI_RRESP[0], S_AXI_RLAST, S_AXI_RDATA }) // }}} ); // }}}",
            "assign S_AXI_RRESP[1] = 1'b0;",
            "assign S_AXI_ARREADY = axi_arready; // }}} //////////////////////////////////////////////////////////////////////// // // Exclusive address caching // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_LOCK && !OPT_LOCKID) begin : EXCLUSIVE_ACCESS_BLOCK // {{{ // The AXI4 specification requires that we check one address // per ID. This isn't that. This algorithm checks one ID, // whichever the last ID was. It's designed to be lighter on // the",
            "logic requirements, and (unnoticably) not (fully) spec // compliant. (The difference, if noticed at all, will be in // performance when multiple masters try to perform an exclusive // transaction at once.) // Local declarations // {{{",
            "reg w_valid_lock_request, w_cancel_lock, w_lock_request, lock_valid, returned_lock_valid;",
            "reg [AW-LSB-1:0] lock_start, lock_end;",
            "reg [3:0] lock_len;",
            "reg [1:0] lock_burst;",
            "reg [2:0] lock_size;",
            "reg [IW-1:0] lock_id;",
            "reg w_write_lock_valid; // }}} // w_lock_request // {{{",
            "always @(*) begin w_lock_request = 0; if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLOCK) w_lock_request = 1; end // }}} // w_valid_lock_request // {{{",
            "always @(*) begin w_valid_lock_request = 0; if (w_lock_request) w_valid_lock_request = 1; if (o_we && o_waddr == S_AXI_ARADDR[AW-1:LSB]) w_valid_lock_request = 0; end // }}} // returned_lock_valid // {{{",
            "initial returned_lock_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) returned_lock_valid <= 0; else if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLOCK && S_AXI_ARID== lock_id) returned_lock_valid <= 0; else if (w_cancel_lock) returned_lock_valid <= 0; else if (rskd_valid && rskd_lock && rskd_ready) returned_lock_valid <= lock_valid; // }}} // w_cancel_lock // {{{",
            "always @(*) w_cancel_lock = (lock_valid && w_lock_request) || (lock_valid && o_we && o_waddr >= lock_start && o_waddr <= lock_end && o_wstrb != 0); // }}} // lock_valid // {{{",
            "initial lock_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !OPT_LOCK) lock_valid <= 0; else begin if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLOCK && S_AXI_ARID== lock_id) lock_valid <= 0; if (w_cancel_lock) lock_valid <= 0; if (w_valid_lock_request) lock_valid <= 1; end // }}} // lock_start, lock_end, lock_len, lock_size, lock_id // {{{",
            "always @(posedge S_AXI_ACLK) if (w_valid_lock_request) begin lock_start <= S_AXI_ARADDR[C_S_AXI_ADDR_WIDTH-1:LSB]; lock_end <= S_AXI_ARADDR[C_S_AXI_ADDR_WIDTH-1:LSB] + ((S_AXI_ARBURST == 2'b00) ? 0 : S_AXI_ARLEN[3:0]); lock_len <= S_AXI_ARLEN[3:0]; lock_burst <= S_AXI_ARBURST; lock_size <= S_AXI_ARSIZE; lock_id <= S_AXI_ARID; end // }}} // w_write_lock_valid // {{{",
            "always @(*) begin w_write_lock_valid = returned_lock_valid; if (!m_awvalid || !m_awready || !m_awlock || !lock_valid) w_write_lock_valid = 0; if (m_awaddr[C_S_AXI_ADDR_WIDTH-1:LSB] != lock_start) w_write_lock_valid = 0; if (m_awid != lock_id) w_write_lock_valid = 0; if (m_awlen[3:0] != lock_len) // MAX transfer size is 16 beats w_write_lock_valid = 0; if (m_awburst != 2'b01 && lock_len != 0) w_write_lock_valid = 0; if (m_awsize != lock_size) w_write_lock_valid = 0; end // }}}",
            "assign write_lock_valid = w_write_lock_valid; // }}} end else if (OPT_LOCK) // && OPT_LOCKID begin : EXCLUSIVE_ACCESS_PER_ID // {{{ genvar gk;",
            "wire [(1<<IW)-1:0] write_lock_valid_per_id; for(gk=0; gk<(1<<IW); gk=gk+1) begin : PER_ID_LOGIC // {{{ // Local declarations // {{{",
            "reg w_valid_lock_request, w_cancel_lock, lock_valid, returned_lock_valid; // reg [1:0] lock_burst;",
            "reg [2:0] lock_size;",
            "reg [3:0] lock_len;",
            "reg [AW-LSB-1:0] lock_start, lock_end;",
            "reg w_write_lock_valid; // }}} // valid_lock_request // {{{",
            "always @(*) begin w_valid_lock_request = 0; if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARID == gk[IW-1:0] && S_AXI_ARLOCK) w_valid_lock_request = 1; if (o_we && o_waddr == S_AXI_ARADDR[AW-1:LSB]) w_valid_lock_request = 0; end // }}} // returned_lock_valid // {{{",
            "initial returned_lock_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) returned_lock_valid <= 0; else if (S_AXI_ARVALID && S_AXI_ARREADY &&S_AXI_ARLOCK&&S_AXI_ARID== gk[IW-1:0]) returned_lock_valid <= 0; else if (w_cancel_lock) returned_lock_valid <= 0; else if (rskd_valid && rskd_lock && rskd_ready && rskd_id == gk[IW-1:0]) returned_lock_valid <= lock_valid; // }}} // w_cancel_lock // {{{",
            "always @(*) w_cancel_lock=(lock_valid&&w_valid_lock_request) || (lock_valid && o_we && o_waddr >= lock_start && o_waddr <= lock_end && o_wstrb != 0); // }}} // lock_valid // {{{",
            "initial lock_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !OPT_LOCK) lock_valid <= 0; else begin if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLOCK && S_AXI_ARID == gk[IW-1:0]) lock_valid <= 0; if (w_cancel_lock) lock_valid <= 0; if (w_valid_lock_request) lock_valid <= 1; end // }}} // lock_start, lock_end, lock_len, lock_size // {{{",
            "always @(posedge S_AXI_ACLK) if (w_valid_lock_request) begin lock_start <= S_AXI_ARADDR[C_S_AXI_ADDR_WIDTH-1:LSB]; // Verilator lint_off WIDTH lock_end <= S_AXI_ARADDR[C_S_AXI_ADDR_WIDTH-1:LSB] + ((S_AXI_ARBURST == 2'b00) ? 4'h0 : S_AXI_ARLEN[3:0]); // Verilator lint_on WIDTH lock_len <= S_AXI_ARLEN[3:0]; lock_size <= S_AXI_ARSIZE; // lock_burst <= S_AXI_ARBURST; end // }}} // w_write_lock_valid // {{{",
            "always @(*) begin w_write_lock_valid = returned_lock_valid; if (!m_awvalid || !m_awready || !m_awlock || !lock_valid) w_write_lock_valid = 0; if (m_awaddr[C_S_AXI_ADDR_WIDTH-1:LSB] != lock_start) w_write_lock_valid = 0; if (m_awid[IW-1:0] != gk[IW-1:0]) w_write_lock_valid = 0; if (m_awlen[3:0] != lock_len) // MAX transfer size is 16 beats w_write_lock_valid = 0; if (m_awburst != 2'b01 && lock_len != 0) w_write_lock_valid = 0; if (m_awsize != lock_size) w_write_lock_valid = 0; end // }}}",
            "assign write_lock_valid_per_id[gk]= w_write_lock_valid; // }}} end",
            "assign write_lock_valid = |write_lock_valid_per_id; // }}} end else begin : NO_LOCKING // {{{",
            "assign write_lock_valid = 1'b0; // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused_lock;",
            "assign unused_lock = &{ 1'b0, S_AXI_ARLOCK, S_AXI_AWLOCK }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} end endgenerate // }}} // Make Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0, S_AXI_AWCACHE, S_AXI_AWPROT, S_AXI_AWQOS, S_AXI_ARCACHE, S_AXI_ARPROT, S_AXI_ARQOS }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // // The following properties are only some of the properties used // to verify this core // reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge S_AXI_ACLK) f_past_valid <= 1;",
            "always @(*) if (!f_past_valid) assume(!S_AXI_ARESETN); faxi_slave #( // {{{ .C_AXI_ID_WIDTH(C_S_AXI_ID_WIDTH), .C_AXI_DATA_WIDTH(C_S_AXI_DATA_WIDTH), .C_AXI_ADDR_WIDTH(C_S_AXI_ADDR_WIDTH)) // ... // }}} f_slave( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // // Address write channel // {{{ .i_axi_awvalid(m_awvalid), .i_axi_awready(m_awready), .i_axi_awid( m_awid), .i_axi_awaddr( m_awaddr), .i_axi_awlen( m_awlen), .i_axi_awsize( m_awsize), .i_axi_awburst(m_awburst), .i_axi_awlock( m_awlock), .i_axi_awcache(4'h0), .i_axi_awprot( 3'h0), .i_axi_awqos( 4'h0), // }}} // Write Data Channel // {{{ // Write Data .i_axi_wdata(S_AXI_WDATA), .i_axi_wstrb(S_AXI_WSTRB), .i_axi_wlast(S_AXI_WLAST), .i_axi_wvalid(S_AXI_WVALID), .i_axi_wready(S_AXI_WREADY), // }}} // Write response // {{{ .i_axi_bvalid(S_AXI_BVALID), .i_axi_bready(S_AXI_BREADY), .i_axi_bid( S_AXI_BID), .i_axi_bresp( S_AXI_BRESP), // }}} // Read address channel // {{{ .i_axi_arvalid(S_AXI_ARVALID), .i_axi_arready(S_AXI_ARREADY), .i_axi_arid( S_AXI_ARID), .i_axi_araddr( S_AXI_ARADDR), .i_axi_arlen( S_AXI_ARLEN), .i_axi_arsize( S_AXI_ARSIZE), .i_axi_arburst(S_AXI_ARBURST), .i_axi_arlock( S_AXI_ARLOCK), .i_axi_arcache(S_AXI_ARCACHE), .i_axi_arprot( S_AXI_ARPROT), .i_axi_arqos( S_AXI_ARQOS), // }}} // Read data return channel // {{{ .i_axi_rvalid(S_AXI_RVALID), .i_axi_rready(S_AXI_RREADY), .i_axi_rid(S_AXI_RID), .i_axi_rdata(S_AXI_RDATA), .i_axi_rresp(S_AXI_RRESP), .i_axi_rlast(S_AXI_RLAST), // }}} // // ... // }}} ); // }}} //////////////////////////////////////////////////////////////////////// // // Write induction properties // {{{ //////////////////////////////////////////////////////////////////////// // // // // ... // always @(*) if (r_bvalid) assert(S_AXI_BVALID);",
            "always @(*) assert(axi_awready == (!S_AXI_WREADY&& !r_bvalid));",
            "always @(*) if (axi_awready) assert(!S_AXI_WREADY); // // ... // // }}} //////////////////////////////////////////////////////////////////////// // // Read induction properties // {{{ //////////////////////////////////////////////////////////////////////// // // // // ... // always @(posedge S_AXI_ACLK) if (f_past_valid && axi_rlen == 0) assert(S_AXI_ARREADY);",
            "always @(posedge S_AXI_ACLK) assert(axi_rlen <= 256); // }}} //////////////////////////////////////////////////////////////////////// // // Lowpower checking // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (OPT_LOWPOWER && S_AXI_ARESETN) begin if (!rskd_valid) assert(!rskd_lock); if (faxi_awr_nbursts == 0) begin assert(S_AXI_BRESP == 2'b00); // assert(S_AXI_BID == 0); end if (!S_AXI_RVALID) begin assert(S_AXI_RID == 0); assert(S_AXI_RDATA == 0); assert(S_AXI_RRESP == 2'b00); end if (!o_we) begin assert(o_waddr == 0); assert(o_wdata == 0); assert(o_wstrb == 0); end end // }}} //////////////////////////////////////////////////////////////////////// // // Contract checking // {{{ //////////////////////////////////////////////////////////////////////// // // ... // // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // reg f_wr_cvr_valid, f_rd_cvr_valid;",
            "reg [4:0] f_dbl_rd_count, f_dbl_wr_count;",
            "initial f_wr_cvr_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) f_wr_cvr_valid <= 0; else if (S_AXI_AWVALID && S_AXI_AWREADY && S_AXI_AWLEN > 4) f_wr_cvr_valid <= 1;",
            "always @(*) cover(!S_AXI_BVALID && axi_awready && !m_awvalid && f_wr_cvr_valid /* && ... */));",
            "initial f_rd_cvr_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) f_rd_cvr_valid <= 0; else if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN > 4) f_rd_cvr_valid <= 1;",
            "always @(*) cover(S_AXI_ARREADY && f_rd_cvr_valid /* && ... */); // // Generate cover statements associated with multiple successive bursts // // These will be useful for demonstrating the throughput of the core. // initial f_dbl_wr_count = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) f_dbl_wr_count = 0; else if (S_AXI_AWVALID && S_AXI_AWREADY && S_AXI_AWLEN == 3) begin if (!(&f_dbl_wr_count)) f_dbl_wr_count <= f_dbl_wr_count + 1; end",
            "always @(*) cover(S_AXI_ARESETN && (f_dbl_wr_count > 1)); //!",
            "always @(*) cover(S_AXI_ARESETN && (f_dbl_wr_count > 3)); //!",
            "always @(*) cover(S_AXI_ARESETN && (f_dbl_wr_count > 3) && !m_awvalid &&(!S_AXI_AWVALID && !S_AXI_WVALID && !S_AXI_BVALID) && (faxi_awr_nbursts == 0) && (faxi_wr_pending == 0));",
            "initial f_dbl_rd_count = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) f_dbl_rd_count = 0; else if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN == 3) begin if (!(&f_dbl_rd_count)) f_dbl_rd_count <= f_dbl_rd_count + 1; end",
            "always @(*) cover(!S_AXI_ARESETN && (f_dbl_rd_count > 3) /* && ... */ && !S_AXI_ARVALID && !S_AXI_RVALID); generate if (OPT_LOCK) begin",
            "always @(*) cover(S_AXI_ARESETN && S_AXI_BVALID && S_AXI_BREADY && S_AXI_BRESP == 2'b01); end endgenerate `ifdef VERIFIC cover property (@(posedge S_AXI_ACLK) disable iff (!S_AXI_ARESETN) // Accept a burst request for 4 beats (S_AXI_ARVALID && S_AXI_ARREADY && (S_AXI_ARLEN == 3) ##1 S_AXI_ARVALID [*3]) [*3] ##1 1 [*0:12] // The return to idle ##1 (!S_AXI_ARVALID && !o_rd && !rskd_valid && !S_AXI_RVALID) ); `endif // }}} //////////////////////////////////////////////////////////////////////// // // \"Careless\" assumptions // {{{ //////////////////////////////////////////////////////////////////////// // // // }}} `endif // }}}",
            "endmodule `ifndef YOSYS `default_nettype",
            "wire `endif"
        ]
    },
    {
        "file_name": "axilscope.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axilscope.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/axilscope.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: This is a generic/library routine for providing a bus accessed // 'scope' or (perhaps more appropriately) a bus accessed",
            "logic analyzer. // The general operation is such that this 'scope' can record and report // on any 32 bit value transiting through the FPGA. Once started and // reset, the scope records a copy of the",
            "input data every time the clock // ticks with the circuit enabled. That is, it records these values up // until the trigger. Once the trigger goes high, the scope will record // for br_holdoff more counts before stopping. Values may then be read // from the buffer, oldest to most recent. After reading, the scope may // then be reset for another run. // // In general, therefore, operation happens in this fashion: // 1. A reset is issued. // 2. Recording starts, in a circular buffer, and continues until // 3. The trigger line is asserted. // The scope",
            "reg isters the asserted trigger by setting // the 'o_triggered'",
            "output flag. // 4. A counter then ticks until the last value is written // The scope",
            "reg isters that it has stopped recording by // setting the 'o_stopped'",
            "output flag. // 5. The scope recording is then paused until the next reset. // 6. While stopped, the CPU can read the data from the scope // 7. -- oldest to most recent // 8. -- one value per i_rd&i_data_clk // 9. Writes to the data",
            "reg ister reset the address to the // beginning of the buffer // // Although the data width DW is",
            "parameter ized, it is not very changable, // since the width is tied to the width of the data bus, as is the // control word. Therefore changing the data width would require changing // the interface. It's doable, but it would be a change to the interface. // // The SYNCHRONOUS",
            "parameter turns on and off meta-stability // synchronization. Ideally a wishbone scope able to handle one or two // clocks would have a changing number of ports as this SYNCHRONOUS // parameter changed. Other than running another script to modify // this, I don't know how to do that so ... we'll just leave it running // off of two clocks or not. // // // Internal to this routine, reg isters and",
            "wire s are named with one of the // following prefixes: // // i_ An",
            "input port to the routine // o_ An",
            "output port of the routine // br_ A",
            "reg ister, controlled by the bus clock // dr_ A",
            "reg ister, controlled by the data clock // bw_ A",
            "wire /net, controlled by the bus clock // dw_ A",
            "wire /net, controlled by the data clock // // And, of course, since AXI wants to be particular about their port // naming conventions, anything beginning with // // S_AXI_ // // is a signal associated with this function as an AXI slave. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2015-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module axilscope #( // {{{",
            "parameter [4:0] LGMEM = 5'd10, parameter SYNCHRONOUS=1, parameter HOLDOFFBITS = 20, parameter [(HOLDOFFBITS-1):0] DEFAULT_HOLDOFF = ((1<<(LGMEM-1))-4), localparam BUSW = 32, // // Width of S_AXI data bus",
            "localparam integer C_S_AXI_DATA_WIDTH = 32, // Width of S_AXI address bus",
            "parameter integer C_S_AXI_ADDR_WIDTH = 3, localparam ADDR_LSBS = $clog2(C_S_AXI_DATA_WIDTH)-3 // }}} ) ( // {{{",
            "input wire i_data_clk, // The data clock, can be set to ACLK",
            "input wire i_ce, // = '1' when recordable data is present",
            "input wire i_trigger,// = '1' when interesting event hapns",
            "input wire [31:0] i_data, output wire o_interrupt, // ='1' when scope has stopped // // Global Clock Signal",
            "input wire S_AXI_ACLK, // Global Reset Signal. This Signal is Active LOW",
            "input wire S_AXI_ARESETN, // Write address (issued by master, acceped by Slave)",
            "input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR, // Write channel Protection type. This signal indicates the // privilege and security level of the transaction, and whether // the transaction is a data access or an instruction access.",
            "input wire [2 : 0] S_AXI_AWPROT, // Write address valid. This signal indicates that the master // signaling valid write address and control information.",
            "input wire S_AXI_AWVALID, // Write address ready. This signal indicates that the slave // is ready to accept an address and associated control signals.",
            "output wire S_AXI_AWREADY, // Write data (issued by master, acceped by Slave)",
            "input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA, // Write strobes. This signal indicates which byte lanes hold // valid data. There is one write strobe bit for each eight // bits of the write data bus.",
            "input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB, // Write valid. This signal indicates that valid write // data and strobes are available.",
            "input wire S_AXI_WVALID, // Write ready. This signal indicates that the slave // can accept the write data.",
            "output wire S_AXI_WREADY, // Write response. This signal indicates the status // of the write transaction.",
            "output wire [1 : 0] S_AXI_BRESP, // Write response valid. This signal indicates that the channel // is signaling a valid write response.",
            "output wire S_AXI_BVALID, // Response ready. This signal indicates that the master // can accept a write response.",
            "input wire S_AXI_BREADY, // Read address (issued by master, acceped by Slave)",
            "input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR, // Protection type. This signal indicates the privilege // and security level of the transaction, and whether the // transaction is a data access or an instruction access.",
            "input wire [2 : 0] S_AXI_ARPROT, // Read address valid. This signal indicates that the channel // is signaling valid read address and control information.",
            "input wire S_AXI_ARVALID, // Read address ready. This signal indicates that the slave is // ready to accept an address and associated control signals.",
            "output wire S_AXI_ARREADY, // Read data (issued by slave)",
            "output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA, // Read response. This signal indicates the status of the // read transfer.",
            "output wire [1 : 0] S_AXI_RRESP, // Read valid. This signal indicates that the channel is // signaling the required read data.",
            "output wire S_AXI_RVALID, // Read ready. This signal indicates that the master can // accept the read data and response information.",
            "input wire S_AXI_RREADY // }}} ); // Signal declarations // {{{ // AXI4LITE signals",
            "reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_awaddr;",
            "reg axi_awready;",
            "reg axi_wready;",
            "reg [C_S_AXI_DATA_WIDTH-1:0] axi_wdata; // reg [1 : 0] axi_bresp;",
            "reg axi_bvalid; // reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_araddr;",
            "reg axi_arready; // reg [1 : 0] axi_rresp; // Pseudo bus signals",
            "wire bus_clock;",
            "reg read_from_data;",
            "wire write_stb;",
            "wire write_to_control;",
            "reg [1:0] read_address; // reg read_address;",
            "wire [31:0] i_bus_data;",
            "reg [31:0] o_bus_data; // reg [(LGMEM-1):0] raddr, waddr;",
            "reg [(BUSW-1):0] mem[0:((1<<LGMEM)-1)];",
            "wire bw_reset_request, bw_manual_trigger, bw_disable_trigger, bw_reset_complete;",
            "reg [2:0] br_config;",
            "reg [(HOLDOFFBITS-1):0] br_holdoff;",
            "wire dw_reset, dw_manual_trigger, dw_disable_trigger;",
            "reg dr_triggered, dr_primed;",
            "wire dw_trigger;",
            "reg dr_stopped; (* ASYNC_REG=\"TRUE\" *)",
            "reg [(HOLDOFFBITS-1):0] counter;",
            "localparam STOPDELAY = 1; // Calibrated value--don't change this",
            "wire [(BUSW-1):0] wr_piped_data;",
            "wire bw_stopped, bw_triggered, bw_primed;",
            "reg [(LGMEM-1):0] this_addr;",
            "reg [31:0] nxt_mem;",
            "wire [19:0] full_holdoff;",
            "wire [4:0] bw_lgmem;",
            "reg br_level_interrupt; `ifdef FORMAL (* gclk *)",
            "reg gbl_clk;",
            "reg f_past_valid_bus, f_past_valid_gbl, f_past_valid_data; `endif // FORMAL",
            "wire i_reset;",
            "reg valid_write_data, valid_write_address, write_response_stall;",
            "reg [1:0] rvalid; // }}} //////////////////////////////////////////////////////////////////////// // // Decode and handle the bus signaling in a (somewhat) portable manner // {{{ //////////////////////////////////////////////////////////////////////// // // // assign i_reset = !S_AXI_ARESETN;",
            "always @(*) begin valid_write_address = (S_AXI_AWVALID || !S_AXI_AWREADY); valid_write_data = (S_AXI_WVALID || !S_AXI_WREADY); write_response_stall= (S_AXI_BVALID && !S_AXI_BREADY); end",
            "initial axi_awready = 1'b1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_awready <= 1'b1; else if (write_response_stall) axi_awready <= !valid_write_address; else if (valid_write_data) axi_awready <= 1'b1; else axi_awready <= !valid_write_address;",
            "initial axi_wready = 1'b1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_wready <= 1'b1; else if (write_response_stall) axi_wready <= !valid_write_data; else if (valid_write_address) axi_wready <= 1'b1; else axi_wready <= !valid_write_data;",
            "always @(posedge S_AXI_ACLK) if (S_AXI_WREADY) axi_wdata <= S_AXI_WDATA;",
            "assign S_AXI_AWREADY = axi_awready;",
            "assign S_AXI_WREADY = axi_wready;",
            "always @(posedge S_AXI_ACLK) if ((S_AXI_AWVALID)&&(S_AXI_AWREADY)) axi_awaddr <= S_AXI_AWADDR;",
            "initial axi_bvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (i_reset) axi_bvalid <= 0; else if (write_stb) axi_bvalid <= 1'b1; else if (S_AXI_BREADY) axi_bvalid <= 1'b0;",
            "assign S_AXI_BRESP = 2'b00; // An 'OKAY' response",
            "assign S_AXI_BVALID= axi_bvalid;",
            "assign write_stb = valid_write_data && valid_write_address && !write_response_stall;",
            "initial axi_arready = 1'b1;",
            "always @(posedge S_AXI_ACLK) if (i_reset) axi_arready <= 1'b1; else if ((&rvalid) && (S_AXI_RVALID && !S_AXI_RREADY)) axi_arready <= axi_arready && !S_AXI_ARVALID; else axi_arready <= 1'b1; // always @(posedge S_AXI_ACLK) // if (axi_arready && S_AXI_ARVALID) // axi_araddr <= S_AXI_ARADDR;",
            "assign S_AXI_ARREADY = axi_arready;",
            "initial rvalid = 2'b00;",
            "always @(posedge S_AXI_ACLK) if (i_reset) rvalid <= 2'b00; else begin if (!rvalid[0] || !rvalid[1] || S_AXI_RREADY) rvalid[0] <= S_AXI_ARVALID || !axi_arready; if (rvalid[0]) rvalid[1] <= 1'b1; else if (S_AXI_RREADY) rvalid[1] <= 1'b0; end",
            "assign S_AXI_RVALID = rvalid[1];",
            "assign S_AXI_RRESP = 2'b00; /////////////////////////////////////////////////// // // Final simplification of the AXI code // /////////////////////////////////////////////////// // // Now that we've provided all of the bus signaling // above, can we make any sense of it? // // The following",
            "wire s are here to provide some // simplification of the complex bus protocol. In // particular, are we reading or writing during this // clock? The two *should* be mutually exclusive // (i.e., you *shouldn't* be able to both read and // write on the same clock) ... but Xilinx's default // implementation does nothing to ensure that this // would be the case. // // From here on down, Gisselquist Technology, LLC, // claims a copyright on the code. // assign bus_clock = S_AXI_ACLK;",
            "assign write_to_control = (write_stb) &&(axi_awready ? !S_AXI_AWADDR[ADDR_LSBS] : !axi_awaddr[ADDR_LSBS]);",
            "always @(posedge bus_clock) begin if (S_AXI_ARVALID && S_AXI_ARREADY) read_address[0] <= S_AXI_ARADDR[ADDR_LSBS]; if (!rvalid[0] || !rvalid[1] || S_AXI_RREADY) begin if (S_AXI_ARREADY) read_address[1] <= S_AXI_ARADDR[ADDR_LSBS]; else read_address[1] <= read_address[0]; end end",
            "always @(*) begin if (S_AXI_ARREADY) read_from_data = S_AXI_ARVALID && S_AXI_ARADDR[ADDR_LSBS]; else read_from_data = read_address[0]; if (rvalid[0] && rvalid[1] && !S_AXI_RREADY) read_from_data = 0; end",
            "assign i_bus_data = (S_AXI_WREADY ? S_AXI_WDATA : axi_wdata); // }}} //////////////////////////////////////////////////////////////////////// // // Our status/config",
            "reg ister // {{{ //////////////////////////////////////////////////////////////////////// // // Now that we've finished reading/writing from the // bus, ... or at least acknowledging reads and // writes from and to the bus--even if they haven't // happened yet, now we implement our actual scope. // This includes implementing the actual reads/writes // from/to the bus. // // From here on down, is the heart of the scope itself. // initial br_config = 3'b0;",
            "initial br_holdoff = DEFAULT_HOLDOFF;",
            "always @(posedge bus_clock) begin if (write_to_control) begin br_config[1:0] <= { i_bus_data[27], i_bus_data[26] }; if (!i_bus_data[31] && br_config[2]) br_holdoff <= i_bus_data[(HOLDOFFBITS-1):0]; end // // Reset",
            "logic if (bw_reset_complete) // Clear the reset request, reg ardless of the write br_config[2] <= 1'b1; else if (!br_config[2]) // Reset request is already pending--don't change it br_config[2] <= 1'b0; else if (write_to_control && !i_bus_data[31]) // Initiate a new reset request // Note that we won't initiate a new reset request // while one is already pending. Once the pending // one completes we'll be in the reset state anyway br_config[2] <= 1'b0; if (i_reset) br_config[2] <= 1'b0; end",
            "assign bw_reset_request = (!br_config[2]);",
            "assign bw_manual_trigger = (br_config[1]);",
            "assign bw_disable_trigger = (br_config[0]); generate if (SYNCHRONOUS > 0) begin : GEN_SYNCHRONOUS",
            "assign dw_reset = bw_reset_request;",
            "assign dw_manual_trigger = bw_manual_trigger;",
            "assign dw_disable_trigger = bw_disable_trigger;",
            "assign bw_reset_complete = bw_reset_request; end else begin : GEN_ASYNC",
            "reg r_reset_complete; (* ASYNC_REG = \"TRUE\" *)",
            "reg [2:0] q_iflags, r_iflags; // Resets are synchronous to the bus clock, not the data clock // so do a clock transfer here",
            "initial { q_iflags, r_iflags } = 6'h0;",
            "initial r_reset_complete = 1'b0;",
            "always @(posedge i_data_clk or posedge i_reset) if (i_reset) begin { q_iflags, r_iflags } <= 6'h0; r_reset_complete <= 1'b0; end else begin q_iflags <= { bw_reset_request, bw_manual_trigger, bw_disable_trigger }; r_iflags <= q_iflags; r_reset_complete <= (dw_reset); end",
            "assign dw_reset = r_iflags[2];",
            "assign dw_manual_trigger = r_iflags[1];",
            "assign dw_disable_trigger = r_iflags[0]; (* ASYNC_REG = \"TRUE\" *)",
            "reg q_reset_complete, qq_reset_complete; // Pass an acknowledgement back from the data clock to the bus // clock that the reset has been accomplished",
            "initial q_reset_complete = 1'b0;",
            "initial qq_reset_complete = 1'b0;",
            "always @(posedge bus_clock or posedge i_reset) if (i_reset) begin q_reset_complete <= 1'b0; qq_reset_complete <= 1'b0; end else begin q_reset_complete <= r_reset_complete; qq_reset_complete <= q_reset_complete; end",
            "assign bw_reset_complete = qq_reset_complete; `ifdef FORMAL",
            "always @(posedge gbl_clk) if (f_past_valid_data) begin if ($rose(r_reset_complete)) assert(bw_reset_request); end",
            "always @(*) case({ bw_reset_request, q_iflags[2], dw_reset, q_reset_complete, qq_reset_complete }) 5'h00: begin end 5'h10: begin end 5'h18: begin end 5'h1c: begin end 5'h1e: begin end 5'h1f: begin end 5'h0f: begin end 5'h07: begin end 5'h03: begin end 5'h01: begin end default: assert(0); endcase `endif end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Set up the trigger // {{{ //////////////////////////////////////////////////////////////////////// // // // dw_trigger -- trigger",
            "wire , defined on the data clock // {{{ // Write with the i_clk, or",
            "input clock. All",
            "output s read with the // bus clock, or bus_clock as we've called it here.",
            "assign dw_trigger = (dr_primed)&&( ((i_trigger)&&(!dw_disable_trigger)) ||(dw_manual_trigger)); // }}} // dr_triggered // {{{",
            "initial dr_triggered = 1'b0;",
            "always @(posedge i_data_clk) if (dw_reset) dr_triggered <= 1'b0; else if ((i_ce)&&(dw_trigger)) dr_triggered <= 1'b1; // }}} // // Determine when memory is full and capture is complete // // Writes take place on the data clock // counter // {{{ // The counter is unsigned",
            "initial counter = 0;",
            "always @(posedge i_data_clk) if (dw_reset) counter <= 0; else if ((i_ce)&&(dr_triggered)&&(!dr_stopped)) counter <= counter + 1'b1; `ifdef FORMAL",
            "always @(*) if (!dw_reset && !bw_reset_request) assert(counter <= br_holdoff+1'b1);",
            "always @(posedge i_data_clk) assume(!(&br_holdoff));",
            "always @(posedge i_data_clk) if (!dr_triggered) assert(counter == 0); `endif // }}} // dr_stopped // {{{",
            "initial dr_stopped = 1'b0;",
            "always @(posedge i_data_clk) if ((!dr_triggered)||(dw_reset)) dr_stopped <= 1'b0; else if (!dr_stopped) begin if (HOLDOFFBITS > 1) // if (i_ce) dr_stopped <= (counter >= br_holdoff); else if (HOLDOFFBITS <= 1) dr_stopped <= ((i_ce)&&(dw_trigger)); end // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Write to memory // {{{ //////////////////////////////////////////////////////////////////////// // // // // Actually do our writes to memory. Record, via 'primed' when // the memory is full. // // The 'waddr' address that we are using really crosses two clock // domains. While writing and changing, it's in the data clock // domain. Once stopped, it becomes part of the bus clock domain. // The clock transfer on the stopped line handles the clock // transfer for these signals. // // waddr, dr_primed // {{{",
            "initial waddr = {(LGMEM){1'b0}};",
            "initial dr_primed = 1'b0;",
            "always @(posedge i_data_clk) if (dw_reset) // For simulation purposes, supply a valid value begin waddr <= 0; // upon reset. dr_primed <= 1'b0; end else if (i_ce && !dr_stopped) begin // mem[waddr] <= i_data; waddr <= waddr + {{(LGMEM-1){1'b0}},1'b1}; if (!dr_primed) dr_primed <= (&waddr); end // }}} // wr_piped_data -- delay data to match the trigger // {{{ // Delay the incoming data so that we can get our trigger // logic to line up with the data. The goal is to have a // hold off of zero place the trigger in the last memory // address. generate if (STOPDELAY == 0) begin : NO_STOPDLY // No delay ... just",
            "assign the",
            "wire s to our",
            "input lines",
            "assign wr_piped_data = i_data; end else if (STOPDELAY == 1) begin : GEN_ONE_STOPDLY // // Delay by one means just",
            "reg ister this once",
            "reg [(BUSW-1):0] data_pipe;",
            "always @(posedge i_data_clk) if (i_ce) data_pipe <= i_data;",
            "assign wr_piped_data = data_pipe; end else begin : GEN_STOPDELAY // Arbitrary delay ... use a longer pipe",
            "reg [(STOPDELAY*BUSW-1):0] data_pipe;",
            "always @(posedge i_data_clk) if (i_ce) data_pipe <= { data_pipe[((STOPDELAY-1)*BUSW-1):0], i_data };",
            "assign wr_piped_data = { data_pipe[(STOPDELAY*BUSW-1):((STOPDELAY-1)*BUSW)] }; end endgenerate // }}} // mem[] <= wr_piped_data // {{{",
            "always @(posedge i_data_clk) if ((i_ce)&&(!dr_stopped)) mem[waddr] <= wr_piped_data; // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Move the status signals back to the bus clock // {{{ //////////////////////////////////////////////////////////////////////// // generate if (SYNCHRONOUS > 0) begin : SYNCHRONOUS_RETURN",
            "assign bw_stopped = dr_stopped;",
            "assign bw_triggered = dr_triggered;",
            "assign bw_primed = dr_primed; end else begin : ASYNC_STATUS // {{{ // These aren't a problem, since none of these are strobe // signals. They goes from low to high, and then stays high // for many clocks. Swapping is thus easy--two flip flops to // protect against meta-stability and we're done. // (* ASYNC_REG = \"TRUE\" *)",
            "reg [2:0] q_oflags;",
            "reg [2:0] r_oflags;",
            "initial q_oflags = 3'h0;",
            "initial r_oflags = 3'h0;",
            "always @(posedge bus_clock) if (bw_reset_request) begin q_oflags <= 3'h0; r_oflags <= 3'h0; end else begin q_oflags <= { dr_stopped, dr_triggered, dr_primed }; r_oflags <= q_oflags; end",
            "assign bw_stopped = r_oflags[2];",
            "assign bw_triggered = r_oflags[1];",
            "assign bw_primed = r_oflags[0]; // }}} `ifdef FORMAL",
            "always @(*) if (!bw_reset_request) begin if (bw_primed) assert(q_oflags[0] && dr_primed); else if (q_oflags[0]) assert(dr_primed); if (bw_triggered) assert(q_oflags[1] && dr_triggered); else if (q_oflags[1]) assert(dr_triggered); if (bw_stopped) assert(q_oflags[2] && dr_stopped); else if (q_oflags[2]) assert(dr_stopped); end `endif end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Read from the memory, using the bus clock. Otherwise respond to bus // {{{ //////////////////////////////////////////////////////////////////////// // // // Reads use the bus clock",
            "initial raddr = 0;",
            "always @(posedge bus_clock) begin if ((bw_reset_request)||(write_to_control)) raddr <= 0; else if ((read_from_data)&&(bw_stopped)) raddr <= raddr + 1'b1; // Data read, when stopped end",
            "always @(posedge bus_clock) if (read_from_data) this_addr <= raddr + waddr + 1'b1; else this_addr <= raddr + waddr;",
            "always @(posedge bus_clock) if (read_from_data) nxt_mem <= mem[this_addr]; // holdoff sub-",
            "reg ister // {{{",
            "assign full_holdoff[(HOLDOFFBITS-1):0] = br_holdoff; generate if (HOLDOFFBITS < 20) begin : GEN_FULL_HOLDOFF",
            "assign full_holdoff[19:(HOLDOFFBITS)] = 0; end endgenerate // }}}",
            "assign bw_lgmem = LGMEM; // Bus read // {{{",
            "always @(posedge bus_clock) if (rvalid[0] && (!S_AXI_RVALID || S_AXI_RREADY)) begin if (!read_address[1]) // Control",
            "reg ister read o_bus_data <= { bw_reset_request, bw_stopped, bw_triggered, bw_primed, bw_manual_trigger, bw_disable_trigger, (raddr == {(LGMEM){1'b0}}), bw_lgmem, full_holdoff }; else if (!bw_stopped) // read, prior to stopping // // *WARNING*: THIS READ IS NOT PROTECTED FROM // ASYNCHRONOUS COHERENCE ISSUES! // o_bus_data <= i_data; else // if (i_wb_addr) // Read from FIFO memory o_bus_data <= nxt_mem; // mem[raddr+waddr]; end // }}}",
            "assign S_AXI_RDATA = o_bus_data; // }}} //////////////////////////////////////////////////////////////////////// // // Interrupt generation // {{{ //////////////////////////////////////////////////////////////////////// // // initial br_level_interrupt = 1'b0;",
            "always @(posedge bus_clock) if ((bw_reset_complete)||(bw_reset_request)) br_level_interrupt<= 1'b0; else br_level_interrupt<= (bw_stopped)&&(!bw_disable_trigger);",
            "assign o_interrupt = (bw_stopped)&&(!bw_disable_trigger) &&(!br_level_interrupt); // }}} // Make verilator happy // {{{ // verilator lint_off UNUSED // Make verilator happy",
            "wire unused;",
            "assign unused = &{ 1'b0, S_AXI_WSTRB, S_AXI_ARPROT, S_AXI_AWPROT, axi_awaddr[ADDR_LSBS-1:0], i_bus_data[30:28], i_bus_data[25:0] }; // verilator lint_on UNUSED // }}} `ifdef FORMAL generate if (SYNCHRONOUS) begin : ASSUME_CLK",
            "always @(*) assume(i_data_clk == S_AXI_ACLK); end else begin : ASSUME_ASYN",
            "localparam CKSTEP_BITS = 3;",
            "localparam [CKSTEP_BITS-1:0] MAX_STEP = { 1'b0, {(CKSTEP_BITS-1){1'b1}} }; // \"artificially\" generate two clocks (* anyconst *)",
            "wire [CKSTEP_BITS-1:0] f_data_step, f_bus_step;",
            "reg [CKSTEP_BITS-1:0] f_data_count, f_bus_count;",
            "always @(*) begin assume(f_data_step > 0); assume(f_bus_step > 0); assume(f_data_step <= MAX_STEP); assume(f_bus_step <= MAX_STEP); assume((f_data_step == MAX_STEP) ||(f_bus_step == MAX_STEP)); end",
            "always @(posedge gbl_clk) begin f_data_count <= f_data_count + f_data_step; f_bus_count <= f_bus_count + f_bus_step; assume(i_data_clk == f_data_count[CKSTEP_BITS-1]); assume(bus_clock == f_bus_count[CKSTEP_BITS-1]); end",
            "always @(posedge gbl_clk) if (!$rose(i_data_clk)) begin assume($stable(i_trigger)); assume($stable(i_data)); end",
            "always @(posedge gbl_clk) if (!$rose(S_AXI_ACLK)) begin assume($stable(S_AXI_ARESETN)); // assume($stable(S_AXI_AWADDR)); assume($stable(S_AXI_AWPROT)); assume($stable(S_AXI_AWVALID)); // assume($stable(S_AXI_WDATA)); assume($stable(S_AXI_WSTRB)); assume($stable(S_AXI_WVALID)); // assume($stable(S_AXI_BREADY)); // assume($stable(S_AXI_ARADDR)); assume($stable(S_AXI_ARPROT)); assume($stable(S_AXI_ARVALID)); // assume($stable(S_AXI_RREADY)); // end",
            "always @(posedge gbl_clk) if (!$rose(i_data_clk)) begin assume($stable(i_ce)); assume($stable(i_trigger)); assume($stable(i_data)); end",
            "always @(*) if (!dw_reset && !bw_reset_request) begin if (bw_triggered) assert(dr_triggered); if (bw_primed) assert(dr_primed); if (bw_stopped) assert(dr_stopped); end end endgenerate",
            "initial f_past_valid_bus = 1'b0;",
            "always @(posedge S_AXI_ACLK) f_past_valid_bus <= 1'b1; generate if (!SYNCHRONOUS) begin",
            "initial { f_past_valid_gbl, f_past_valid_data }= 2'b0;",
            "always @(posedge gbl_clk) f_past_valid_gbl <= 1'b1;",
            "always @(posedge i_data_clk) f_past_valid_data = 1'b1;",
            "always @(posedge gbl_clk) if (f_past_valid_gbl && !$rose(bus_clock)) assert($stable(o_interrupt));",
            "always @(posedge gbl_clk) if ((f_past_valid_gbl)&&(!$rose(S_AXI_ACLK))) begin assert($stable(S_AXI_AWREADY)); assert($stable(S_AXI_ARREADY)); assert($stable(S_AXI_RDATA)); assert($stable(S_AXI_RRESP)); assert($stable(S_AXI_RVALID)); assert($stable(S_AXI_WREADY)); assert($stable(S_AXI_BRESP)); assert($stable(S_AXI_BVALID)); end end else begin",
            "always @(*) f_past_valid_data = f_past_valid_bus;",
            "always @(*) f_past_valid_gbl = f_past_valid_bus; end endgenerate",
            "localparam F_LGDEPTH = 5;",
            "wire [F_LGDEPTH-1:0] f_axi_rd_outstanding, f_axi_wr_outstanding, f_axi_awr_outstanding; faxil_slave #( // .C_S_AXI_DATA_WIDTH(C_S_AXI_DATA_WIDTH), // Width of S_AXI address bus .C_AXI_ADDR_WIDTH(C_S_AXI_ADDR_WIDTH), .F_LGDEPTH(F_LGDEPTH), .F_OPT_HAS_CACHE(1'b0), // .F_OPT_CLK2FFLOGIC(!SYNCHRONOUS), .F_AXI_MAXWAIT(5'h6), .F_AXI_MAXDELAY(5'h6) ) faxil_slave( .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // .i_axi_awvalid(S_AXI_AWVALID), .i_axi_awready(S_AXI_AWREADY), .i_axi_awaddr(S_AXI_AWADDR), .i_axi_awprot(S_AXI_AWPROT), // .i_axi_wdata(S_AXI_WDATA), .i_axi_wstrb(S_AXI_WSTRB), .i_axi_wvalid(S_AXI_WVALID), .i_axi_wready(S_AXI_WREADY), // .i_axi_bvalid(S_AXI_BVALID), .i_axi_bready(S_AXI_BREADY), .i_axi_bresp(S_AXI_BRESP), // .i_axi_arvalid(S_AXI_ARVALID), .i_axi_arready(S_AXI_ARREADY), .i_axi_araddr(S_AXI_ARADDR), .i_axi_arprot(S_AXI_ARPROT), // .i_axi_rvalid(S_AXI_RVALID), .i_axi_rready(S_AXI_RREADY), .i_axi_rdata(S_AXI_RDATA), .i_axi_rresp(S_AXI_RRESP), // .f_axi_rd_outstanding(f_axi_rd_outstanding), .f_axi_wr_outstanding(f_axi_wr_outstanding), .f_axi_awr_outstanding(f_axi_awr_outstanding));",
            "always @(*) if (S_AXI_ARESETN) begin assert(f_axi_awr_outstanding == (S_AXI_AWREADY ? 0:1) + (S_AXI_BVALID ? 1:0)); assert(f_axi_wr_outstanding == (S_AXI_WREADY ? 0:1) + (S_AXI_BVALID ? 1:0)); assert(f_axi_rd_outstanding == (axi_arready ? 0:1) + (rvalid[0] ? 1:0) + (rvalid[1] ? 1:0)); end",
            "always @(*) if (dr_triggered) assert(dr_primed);",
            "always @(*) if (dr_stopped) assert((dr_primed)&&(dr_triggered)); //////////////////////////////////////////////////////////////////////// // // Contract // //////////////////////////////////////////////////////////////////////// // // (* anyconst *)",
            "reg [(LGMEM-1):0] f_addr;",
            "reg [BUSW-1:0] f_data;",
            "reg f_filled, f_nxtstopped, f_busstopped;",
            "reg [(LGMEM-1):0] f_busmemaddr, f_nxtaddr;",
            "reg [2:0] f_axi_addr;",
            "initial f_filled = 1'b0;",
            "always @(posedge i_data_clk) if (dw_reset) f_filled <= 1'b0; else if ((i_ce)&&(!dr_stopped)&&(waddr == f_addr)) f_filled <= 1'b1;",
            "always @(posedge i_data_clk) if (waddr > f_addr) assert(f_filled);",
            "always @(posedge i_data_clk) if (!f_filled) assert(!dr_primed);",
            "always @(posedge i_data_clk) if ((i_ce)&&(!dr_stopped)&&(waddr == f_addr)) f_data <= wr_piped_data;",
            "always @(posedge i_data_clk) if (f_filled) assert(mem[f_addr] == f_data);",
            "always @(posedge bus_clock) if (f_past_valid_bus && $past(!bw_stopped)) assert(raddr == 0);",
            "always @(posedge bus_clock) begin if (!rvalid[0] || !rvalid[1] || S_AXI_RREADY) f_axi_addr[0] <= (S_AXI_ARREADY ? S_AXI_ARADDR[ADDR_LSBS] : read_address[0]); if (!rvalid[1] || S_AXI_RREADY) f_axi_addr[1] <= f_axi_addr[0]; if (f_past_valid_bus && !$past(read_from_data)) assert(!$rose(rvalid[0] && f_axi_addr[0])); if (f_past_valid_bus && $past(!i_reset && read_from_data)) assert(f_axi_addr[0] && rvalid[0]); end",
            "always @(*) if (rvalid[0]) assert(f_axi_addr[0] == read_address[1]);",
            "always @(*) if (S_AXI_ARREADY && !S_AXI_ARVALID) assert(!read_from_data); else if (rvalid[0] && rvalid[1] && !S_AXI_RREADY) assert(!read_from_data); else if (!S_AXI_ARREADY) assert(read_from_data == read_address[0]); else if (S_AXI_ARVALID) assert(read_from_data == S_AXI_ARADDR[ADDR_LSBS]); else assert(!read_from_data);",
            "initial f_nxtaddr = 0;",
            "initial f_nxtstopped = 0;",
            "always @(posedge bus_clock) if (i_reset || bw_reset_request) f_nxtstopped <= 1'b0; else if (read_from_data) f_nxtstopped <= bw_stopped;",
            "initial f_busstopped = 0;",
            "always @(posedge bus_clock) if (i_reset || bw_reset_request) f_busstopped <= 1'b0; else if (rvalid[0] && (!S_AXI_RVALID || S_AXI_RREADY)) f_busstopped <= f_nxtstopped;",
            "always @(*) if (f_nxtstopped) assert(bw_stopped);",
            "always @(*) if (f_busstopped) assert(bw_stopped && f_nxtstopped);",
            "always @(posedge bus_clock) if (read_from_data) f_nxtaddr = this_addr;",
            "always @(posedge bus_clock) if (f_past_valid_bus && $past(f_past_valid_bus) && $past(bw_stopped) && dr_stopped && $past(bw_stopped && !write_to_control,2)) begin if ($past(read_from_data)) assert(this_addr == $past(this_addr + 1'b1)); else assert($stable(this_addr)); end",
            "always @(*) if (!bw_reset_request && !dw_reset && rvalid[0] && f_nxtstopped && f_nxtaddr == f_addr && f_axi_addr[0]) assert(nxt_mem == mem[f_nxtaddr]);",
            "always @(posedge bus_clock) if (rvalid[0] && (!S_AXI_RVALID || S_AXI_RREADY)) f_busmemaddr <= f_nxtaddr;",
            "always @(posedge bus_clock) if (f_past_valid_bus && $past(!i_reset && rvalid[0] && !bw_reset_request && (!S_AXI_RVALID || S_AXI_RREADY) && f_axi_addr[0] && f_busstopped)) begin if (f_filled && f_busmemaddr == f_addr) assert(S_AXI_RDATA == f_data); end",
            "always @(*) if (S_AXI_RVALID && !f_axi_addr[1]) assert(S_AXI_RDATA[24:20] == bw_lgmem);",
            "always @(*) if (dr_triggered) assert(dr_primed);",
            "always @(*) if (dr_stopped) assert(dr_triggered); `endif",
            "endmodule // `default_nettype",
            "wire"
        ]
    },
    {
        "file_name": "axiempty.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axiempty.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/axiempty.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: A basic AXI core to provide a response to an AXI master when // no other slaves are connected to the bus. All results are // bus errors. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2019-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module axiempty #( // {{{",
            "parameter integer C_AXI_ID_WIDTH = 2, parameter integer C_AXI_DATA_WIDTH = 32, // Verilator lint_off UNUSED",
            "parameter integer C_AXI_ADDR_WIDTH = 6 // Verilator lint_on UNUSED // Some useful short-hand definitions // localparam AW = C_AXI_ADDR_WIDTH, // localparam DW = C_AXI_DATA_WIDTH // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, // input wire S_AXI_AWVALID, output wire S_AXI_AWREADY, input wire [C_AXI_ID_WIDTH-1:0] S_AXI_AWID, // input wire S_AXI_WVALID, output wire S_AXI_WREADY, input wire S_AXI_WLAST, // output wire S_AXI_BVALID, input wire S_AXI_BREADY, output wire [C_AXI_ID_WIDTH-1:0] S_AXI_BID, output wire [1:0] S_AXI_BRESP, // input wire S_AXI_ARVALID, output wire S_AXI_ARREADY, input wire [C_AXI_ID_WIDTH-1:0] S_AXI_ARID, input wire [7:0] S_AXI_ARLEN, // output wire S_AXI_RVALID, input wire S_AXI_RREADY, output wire [C_AXI_ID_WIDTH-1:0] S_AXI_RID, output wire [C_AXI_DATA_WIDTH-1:0] S_AXI_RDATA, output wire S_AXI_RLAST, output wire [1:0] S_AXI_RRESP // }}} );",
            "localparam IW = C_AXI_ID_WIDTH; // Double buffer the write response channel only",
            "reg [IW-1 : 0] axi_bid;",
            "reg axi_bvalid; //////////////////////////////////////////////////////////////////////// // // Write",
            "logic // {{{ //////////////////////////////////////////////////////////////////////// // // // // Start with the two skid buffers // {{{",
            "wire m_awvalid, m_wvalid;",
            "wire m_awready, m_wready, m_wlast;",
            "wire [IW-1:0] m_awid; // skidbuffer #(.DW(IW), .OPT_OUTREG(1'b0)) awskd(S_AXI_ACLK, !S_AXI_ARESETN, S_AXI_AWVALID, S_AXI_AWREADY, S_AXI_AWID, m_awvalid, m_awready, m_awid ); skidbuffer #(.DW(1), .OPT_OUTREG(1'b0)) wskd(S_AXI_ACLK, !S_AXI_ARESETN, S_AXI_WVALID, S_AXI_WREADY, S_AXI_WLAST, m_wvalid, m_wready, m_wlast ); // }}} // m_awready, m_wready // {{{ // The",
            "logic here is pretty simple--accept a write address burst // into the skid buffer, then leave it there while the write data comes // on. Once we get to the last write data element, accept both it and // the address. This spares us the trouble of counting out the elements // in the write burst. // assign m_awready= (m_awvalid && m_wvalid && m_wlast) && (!S_AXI_BVALID || S_AXI_BREADY);",
            "assign m_wready = !m_wlast || m_awready; // }}} // bvalid // {{{ // As soon as m_awready above, a packet has come through successfully. // Acknowledge it with a bus error. // initial axi_bvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_bvalid <= 1'b0; else if (m_awready) axi_bvalid <= 1'b1; else if (S_AXI_BREADY) axi_bvalid <= 1'b0; // }}} // bid // {{{",
            "always @(posedge S_AXI_ACLK) if (m_awready) axi_bid <= m_awid; // }}}",
            "assign S_AXI_BVALID = axi_bvalid;",
            "assign S_AXI_BID = axi_bid;",
            "assign S_AXI_BRESP = 2'b11; // An interconnect bus error // }}} //////////////////////////////////////////////////////////////////////// // // Read half // {{{ //////////////////////////////////////////////////////////////////////// // // reg [IW-1:0] rid, axi_rid;",
            "reg axi_arready, axi_rlast, axi_rvalid;",
            "reg [8:0] axi_rlen; // axi_arready // {{{",
            "initial axi_arready = 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_arready <= 1; else if (S_AXI_ARVALID && S_AXI_ARREADY) axi_arready <= (S_AXI_ARLEN==0)&&(!S_AXI_RVALID|| S_AXI_RREADY); else if (!S_AXI_RVALID || S_AXI_RREADY) begin if ((!axi_arready)&&(S_AXI_RVALID)) axi_arready <= (axi_rlen <= 2); end // }}} // axi_rlen // {{{",
            "initial axi_rlen = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_rlen <= 0; else if (S_AXI_ARVALID && S_AXI_ARREADY) axi_rlen <= (S_AXI_ARLEN+1) + ((S_AXI_RVALID && !S_AXI_RREADY) ? 1:0); else if (S_AXI_RREADY && S_AXI_RVALID) axi_rlen <= axi_rlen - 1; // }}} // rid // {{{",
            "always @(posedge S_AXI_ACLK) if (S_AXI_ARREADY) rid <= S_AXI_ARID; // }}} // axi_rvalid // {{{",
            "initial axi_rvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) axi_rvalid <= 0; else if (S_AXI_ARVALID || (axi_rlen > 1)) axi_rvalid <= 1; else if (S_AXI_RREADY) axi_rvalid <= 0; // }}} // axi_rid // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_RVALID || S_AXI_RREADY) begin if (S_AXI_ARVALID && S_AXI_ARREADY) axi_rid <= S_AXI_ARID; else axi_rid <= rid; end // }}} // axi_rlast // {{{",
            "initial axi_rlast = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_RVALID || S_AXI_RREADY) begin if (S_AXI_ARVALID && S_AXI_ARREADY) axi_rlast <= (S_AXI_ARLEN == 0); else if (S_AXI_RVALID) axi_rlast <= (axi_rlen == 2); else axi_rlast <= (axi_rlen == 1); end // }}} // assign S_AXI_ARREADY = axi_arready;",
            "assign S_AXI_RVALID = axi_rvalid;",
            "assign S_AXI_RID = axi_rid;",
            "assign S_AXI_RDATA = 0;",
            "assign S_AXI_RRESP = 2'b11;",
            "assign S_AXI_RLAST = axi_rlast; // }}} // Make Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = &{ 1'b0 }; // Verilator lint_on UNUSED // Verilator coverage_on // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL // // The following properties are only some of the properties used // to verify this core // reg f_past_valid;",
            "initial f_past_valid = 0;",
            "always @(posedge S_AXI_ACLK) f_past_valid <= 1;",
            "always @(*) if (!f_past_valid) assume(!S_AXI_ARESETN); faxi_slave #( // {{{ .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH), .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH), .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH) // }}} f_slave( // {{{ .i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // // Address write channel // .i_axi_awvalid(S_AXI_AWVALID), .i_axi_awready(S_AXI_AWREADY), .i_axi_awid( S_AXI_AWID), .i_axi_awaddr( {(C_AXI_ADDR_WIDTH){1'b0}}), .i_axi_awlen( S_AXI_AWLEN), .i_axi_awsize( LSB[2:0]), .i_axi_awburst(2'b0), .i_axi_awlock( 1'b0), .i_axi_awcache(4'h0), .i_axi_awprot( 3'h0), .i_axi_awqos( 4'h0), // // // // Write Data Channel // // Write Data .i_axi_wdata({(C_AXI_DATA_WIDTH){1'b0}}), .i_axi_wstrb({(C_AXI_DATA_WIDTH/8){1'b0}}), .i_axi_wlast(S_AXI_WLAST), .i_axi_wvalid(S_AXI_WVALID), .i_axi_wready(S_AXI_WREADY), // // // Response ID tag. This signal is the ID tag of the // write response. .i_axi_bvalid(S_AXI_BVALID), .i_axi_bready(S_AXI_BREADY), .i_axi_bid( S_AXI_BID), .i_axi_bresp( S_AXI_BRESP), // // // // Read address channel // .i_axi_arvalid(S_AXI_ARVALID), .i_axi_arready(S_AXI_ARREADY), .i_axi_arid( S_AXI_ARID), .i_axi_araddr( {(C_AXI_ADDR_WIDTH){1'b0}}), .i_axi_arlen( S_AXI_ARLEN), .i_axi_arsize( LSB[2:0]), .i_axi_arburst(2'b00), .i_axi_arlock( 1'b0), .i_axi_arcache(4'h0), .i_axi_arprot( 3'h0), .i_axi_arqos( 4'h0), // // // // Read data return channel // .i_axi_rvalid(S_AXI_RVALID), .i_axi_rready(S_AXI_RREADY), .i_axi_rid(S_AXI_RID), .i_axi_rdata(S_AXI_RDATA), .i_axi_rresp(S_AXI_RRESP), .i_axi_rlast(S_AXI_RLAST), // // ... // }}} ); // //////////////////////////////////////////////////////////////////////// // // Write induction properties // //////////////////////////////////////////////////////////////////////// // // {{{ // // ... // // }}} //////////////////////////////////////////////////////////////////////// // // Read induction properties // //////////////////////////////////////////////////////////////////////// // // {{{ // // ... // always @(posedge S_AXI_ACLK) if (f_past_valid && $rose(S_AXI_RLAST)) assert(S_AXI_ARREADY); // }}} //////////////////////////////////////////////////////////////////////// // // Contract checking // //////////////////////////////////////////////////////////////////////// // // {{{ // // ... // // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // //////////////////////////////////////////////////////////////////////// // // {{{",
            "reg f_wr_cvr_valid, f_rd_cvr_valid;",
            "initial f_wr_cvr_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) f_wr_cvr_valid <= 0; else if (S_AXI_AWVALID && S_AXI_AWREADY && S_AXI_AWLEN > 4) f_wr_cvr_valid <= 1;",
            "always @(*) cover(!S_AXI_BVALID && axi_awready && !m_awvalid && f_wr_cvr_valid /* && ... */));",
            "initial f_rd_cvr_valid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) f_rd_cvr_valid <= 0; else if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN > 4) f_rd_cvr_valid <= 1;",
            "always @(*) cover(S_AXI_ARREADY && f_rd_cvr_valid /* && ... */); // // Generate cover statements associated with multiple successive bursts // // These will be useful for demonstrating the throughput of the core. // reg [4:0] f_dbl_rd_count, f_dbl_wr_count;",
            "initial f_dbl_wr_count = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) f_dbl_wr_count = 0; else if (S_AXI_AWVALID && S_AXI_AWREADY && S_AXI_AWLEN == 3) begin if (!(&f_dbl_wr_count)) f_dbl_wr_count <= f_dbl_wr_count + 1; end",
            "always @(*) cover(S_AXI_ARESETN && (f_dbl_wr_count > 1)); //!",
            "always @(*) cover(S_AXI_ARESETN && (f_dbl_wr_count > 3)); //!",
            "always @(*) cover(S_AXI_ARESETN && (f_dbl_wr_count > 3) && !m_awvalid &&(!S_AXI_AWVALID && !S_AXI_WVALID && !S_AXI_BVALID) && (f_axi_awr_nbursts == 0) && (f_axi_wr_pending == 0)); //!!",
            "initial f_dbl_rd_count = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) f_dbl_rd_count = 0; else if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN == 3) begin if (!(&f_dbl_rd_count)) f_dbl_rd_count <= f_dbl_rd_count + 1; end",
            "always @(*) cover(!S_AXI_ARESETN && (f_dbl_rd_count > 3) /* && ... */ && !S_AXI_ARVALID && !S_AXI_RVALID); // }}} //////////////////////////////////////////////////////////////////////// // // Assumptions necessary to pass a formal check // //////////////////////////////////////////////////////////////////////// // // // // No limiting assumptions at present, check is currently full and // complete // `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "axi_addr.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axi_addr.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/axi_addr.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: The AXI (full) standard has some rather complicated addressing // modes, where the address can either be FIXED, INCRementing, or // even where it can WRAP around some boundary. When in either INCR or // WRAP modes, the next address must",
            "always be aligned. In WRAP mode, // the next address calculation needs to wrap around a given value, and // that value is dependent upon the burst size (i.e. bytes per beat) and // length (total numbers of beats). Since this calculation can be // non-trivial, and since it needs to be done multiple times, the",
            "logic // below captures it for every time it might be needed. // // 20200918 - modified to accommodate (potential) AXI3 burst lengths // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2019-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module axi_addr #( // {{{",
            "parameter AW = 32, DW = 32, // parameter [0:0] OPT_AXI3 = 1'b0, localparam LENB = 8 // }}} ) ( // {{{",
            "input wire [AW-1:0] i_last_addr, input wire [2:0] i_size, // 1b, 2b, 4b, 8b, etc",
            "input wire [1:0] i_burst, // fixed, incr, wrap, reserved",
            "input wire [LENB-1:0] i_len, output reg [AW-1:0] o_next_addr // }}} ); // Parameter/",
            "reg ister declarations // {{{",
            "localparam DSZ = $clog2(DW)-3;",
            "localparam [1:0] FIXED = 2'b00; // localparam [1:0] INCREMENT = 2'b01; // localparam [1:0] WRAP = 2'b10;",
            "reg [AW-1:0] wrap_mask, increment; // }}} // Address increment // {{{",
            "always @(*) begin increment = 0; if (i_burst != 0) begin // Addresses increment from one beat to the next // {{{ if (DSZ == 0) increment = 1; else if (DSZ == 1) increment = (i_size[0]) ? 2 : 1; else if (DSZ == 2) increment = (i_size[1]) ? 4 : ((i_size[0]) ? 2 : 1); else if (DSZ == 3) case(i_size[1:0]) 2'b00: increment = 1; 2'b01: increment = 2; 2'b10: increment = 4; 2'b11: increment = 8; endcase else increment = (1<<i_size); // }}} end end // }}} // wrap_mask // {{{ // The wrap_mask is used to determine which bits remain stable across // the burst, and which are allowed to change. It is only used during // wrapped addressing.",
            "always @(*) begin // Start with the default, minimum mask wrap_mask = 1; /* // Here's the original code. It works, but it's // not economical (uses too many LUTs) // if (i_len[3:0] == 1) wrap_mask = (1<<(i_size+1)); else if (i_len[3:0] == 3) wrap_mask = (1<<(i_size+2)); else if (i_len[3:0] == 7) wrap_mask = (1<<(i_size+3)); else if (i_len[3:0] == 15) wrap_mask = (1<<(i_size+4)); wrap_mask = wrap_mask - 1; */ // Here's what we *want* // // wrap_mask[i_size:0] = -1; // // On the other hand, since we're already guaranteed that our // addresses are aligned, do we really care about // wrap_mask[i_size-1:0] ? // What we want: // // wrap_mask[i_size+3:i_size] |= i_len[3:0] // // We could simplify this to // // wrap_mask = wrap_mask | (i_len[3:0] << (i_size)); // // But verilator complains about the left-hand side of // the shift having only 3 bits. // if (DSZ < 2) wrap_mask = wrap_mask | ({{(AW-4){1'b0}},i_len[3:0]} << (i_size[0])); else if (DSZ < 4) wrap_mask = wrap_mask | ({{(AW-4){1'b0}},i_len[3:0]} << (i_size[1:0])); else wrap_mask = wrap_mask | ({{(AW-4){1'b0}},i_len[3:0]} << (i_size)); if (AW > 12) wrap_mask[(AW-1):((AW>12)? 12:(AW-1))] = 0; end // }}} // o_next_addr // {{{",
            "always @(*) begin o_next_addr = i_last_addr + increment; if (i_burst != FIXED) begin // Align subsequent beats in any burst // {{{ // // We use the bus size here to simplify the",
            "logic // required in case the bus is smaller than the // maximum. This depends upon AxSIZE being less than // $clog2(DATA_WIDTH/8). if (DSZ < 2) begin // {{{ // Align any subsequent address if (i_size[0]) o_next_addr[0] = 0; // }}} end else if (DSZ < 4) begin // {{{ // Align any subsequent address case(i_size[1:0]) 2'b00: o_next_addr = o_next_addr; 2'b01: o_next_addr[ 0] = 0; 2'b10: o_next_addr[(AW-1>1) ? 1 : (AW-1):0]= 0; 2'b11: o_next_addr[(AW-1>2) ? 2 : (AW-1):0]= 0; endcase // }}} end else begin // {{{ // Align any subsequent address case(i_size) 3'b001: o_next_addr[ 0] = 0; 3'b010: o_next_addr[(AW-1>1) ? 1 : (AW-1):0]=0; 3'b011: o_next_addr[(AW-1>2) ? 2 : (AW-1):0]=0; 3'b100: o_next_addr[(AW-1>3) ? 3 : (AW-1):0]=0; 3'b101: o_next_addr[(AW-1>4) ? 4 : (AW-1):0]=0; 3'b110: o_next_addr[(AW-1>5) ? 5 : (AW-1):0]=0; 3'b111: o_next_addr[(AW-1>6) ? 6 : (AW-1):0]=0; default: o_next_addr = o_next_addr; endcase // }}} end // }}} end // WRAP addressing // {{{ if (i_burst[1]) begin // WRAP! o_next_addr[AW-1:0] = (i_last_addr & ~wrap_mask) | (o_next_addr & wrap_mask); end // }}} // Guarantee only the bottom 12 bits change // {{{ // This is really a",
            "logic simplification. AXI bursts aren't // allowed to cross 4kB boundaries. Given that's the case, // we don't have to suffer from the propagation across all // AW bits, and can limit any address propagation to just the // lower 12 bits if (AW > 12) o_next_addr[AW-1:((AW>12)? 12:(AW-1))] = i_last_addr[AW-1:((AW>12) ? 12:(AW-1))]; // }}} end // }}} // Make Verilator happy // {{{ // Verilator coverage_off // Verilator lint_off UNUSED",
            "wire unused;",
            "assign unused = (LENB <= 4) ? &{1'b0, i_len[0] } : &{ 1'b0, i_len[LENB-1:4], i_len[0] }; // Verilator lint_on UNUSED // Verilator coverage_on // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "axixbar.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axixbar.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/axixbar.v // {{{ // Project: WB2AXIPSP: bus bridges and other odds and ends // // Purpose: Create a full crossbar between NM AXI sources (masters), and NS // AXI slaves. Every master can talk to any slave, provided it // isn't already busy. // {{{ // Performance: This core has been designed with the goal of being able to push // one transaction through the interconnect, from any master to // any slave, per clock cycle. This may perhaps be its most unique // feature. While throughput is good, latency is something else. // // The arbiter requires a clock to switch, then another clock to send data // downstream. This creates a minimum two clock latency up front. The // return path suffers another clock of latency as well, placing the // minimum latency at four clocks. The minimum write latency is at // least one clock longer, since the write data must wait for the write // address before proceeeding. // // Note that this arbiter only forwards AxID fields. It does not use // them in arbitration. As a result, only one master may ever make // requests of any given slave at a time. All responses from a slave // will be returned to that known master. This is a known limitation in // this implementation which will be fixed (in time) with funding and // interest. Until that time, in order for a second master to access // a given slave, the first master must receive all of its acknowledgments. // // Usage: To use, you must first set NM and NS to the number of masters // and the number of slaves you wish to connect to. You then need to // adjust the addresses of the slaves, found SLAVE_ADDR array. Those // bits that are relevant in SLAVE_ADDR to then also be set in SLAVE_MASK. // Adjusting the data and address widths go without saying. // // Lower numbered masters are given priority in any \"fight\". // // Channel grants are given on the condition that 1) they are requested, // 2) no other channel has a grant, 3) all of the responses have been // received from the current channel, and 4) the internal counters are // not overflowing. // // The core limits the number of outstanding transactions on any channel to // 1<<LGMAXBURST-1. // // Channel grants are lost 1) after OPT_LINGER clocks of being idle, or // 2) when another master requests an idle (but still lingering) channel // assign ment, or 3) once all the responses have been returned to the // current channel, and the current master is requesting another channel. // // A special slave is allocated for the case of no valid address. // // Since the write channel has no address information, the write data // channel",
            "always be delayed by at least one clock from the write address // channel. // // If OPT_LOWPOWER is set, then unused values will be set to zero. // This can also be used to help identify relevant values within any // trace. // // Known issues: This",
            "module can be a challenge to",
            "wire up. // // In order to keep the build lint clean, it's important that every // port be connected. In order to be flexible",
            "reg arding the number of // ports that can be connected, the various AXI signals, whether",
            "input // or",
            "output , have been concatenated together across either all masters // or all slaves. This can make the design a lesson in tediousness to // wire up. // // I commonly",
            "wire this crossbar up using AutoFPGA--just to make certain // that I do it right and don't make mistakes when wiring it up. This // also handles the tediousness involved. // // I have also done this by hand. // // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // }}} //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2019-2024, Gisselquist Technology, LLC // {{{ // This file is part of the WB2AXIP project. // // The WB2AXIP project contains free software and gateware, licensed under the // Apache License, Version 2.0 (the \"License\"). You may not use this project, // or this file, except in compliance with the License. You may obtain a copy // of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT // WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the // License for the specific language governing permissions and limitations // under the License. // //////////////////////////////////////////////////////////////////////////////// // `default_nettype none // }}}",
            "module axixbar #( // {{{",
            "parameter integer C_AXI_DATA_WIDTH = 32, parameter integer C_AXI_ADDR_WIDTH = 32, parameter integer C_AXI_ID_WIDTH = 2, // // NM is the number of masters driving the incoming slave chnls",
            "parameter NM = 4, // // NS is the number of slaves connected to the crossbar, driven // by the master channels",
            "output from this IP.",
            "parameter NS = 8, // // SLAVE_ADDR is an array of addresses, describing each of // {{{ // the slave channels. It works tightly with SLAVE_MASK, // so that when (ADDR & MASK == ADDR), the channel in question // has been requested. // // It is an internal in the setup of this core to doubly map // an address, such that (addr & SLAVE_MASK[k])==SLAVE_ADDR[k] // for two separate values of k. // // Any attempt to access an address that is a hole in this // address list will result in a returned xRESP value of // INTERCONNECT_ERROR (2'b11) // // NOTE: This is only a nominal address set. I expect that // any design using the crossbar will need to adjust both // SLAVE_ADDR and SLAVE_MASK, if not also NM and NS.",
            "parameter [NS*C_AXI_ADDR_WIDTH-1:0] SLAVE_ADDR = { 3'b111, {(C_AXI_ADDR_WIDTH-3){1'b0}}, 3'b110, {(C_AXI_ADDR_WIDTH-3){1'b0}}, 3'b101, {(C_AXI_ADDR_WIDTH-3){1'b0}}, 3'b100, {(C_AXI_ADDR_WIDTH-3){1'b0}}, 3'b011, {(C_AXI_ADDR_WIDTH-3){1'b0}}, 3'b010, {(C_AXI_ADDR_WIDTH-3){1'b0}}, 4'b0001, {(C_AXI_ADDR_WIDTH-4){1'b0}}, 4'b0000, {(C_AXI_ADDR_WIDTH-4){1'b0}} }, // }}} // // SLAVE_MASK: is an array, much like SLAVE_ADDR, describing // {{{ // which of the bits in SLAVE_ADDR are relevant. It is // important to maintain for every slave that // (~SLAVE_MASK[i] & SLAVE_ADDR[i]) == 0. // // NOTE: This value should be overridden by any implementation. // Verilator lint_off WIDTH",
            "parameter [NS*C_AXI_ADDR_WIDTH-1:0] SLAVE_MASK = { 3'b111, {(C_AXI_ADDR_WIDTH-3){1'b0}}, 3'b111, {(C_AXI_ADDR_WIDTH-3){1'b0}}, 3'b111, {(C_AXI_ADDR_WIDTH-3){1'b0}}, 3'b111, {(C_AXI_ADDR_WIDTH-3){1'b0}}, 3'b111, {(C_AXI_ADDR_WIDTH-3){1'b0}}, 3'b111, {(C_AXI_ADDR_WIDTH-3){1'b0}}, 4'b1111, {(C_AXI_ADDR_WIDTH-4){1'b0}}, 4'b1111, {(C_AXI_ADDR_WIDTH-4){1'b0}} }, // Verilator lint_on WIDTH // }}} // // OPT_LOWPOWER: If set, it forces all unused values to zero, // {{{ // preventing them from unnecessarily toggling. This will // raise the",
            "logic count of the core, but might also lower // the power used by the interconnect and the bus driven",
            "wire s // which (in my experience) tend to have a high fan out.",
            "parameter [0:0] OPT_LOWPOWER = 0, // }}} // // OPT_LINGER: Set this to the number of clocks an idle // {{{ // channel shall be left open before being closed. Once // closed, it will take a minimum of two clocks before the // channel can be opened and data transmitted through it again.",
            "parameter OPT_LINGER = 4, // }}} // // [EXPERIMENTAL] OPT_QOS: If set, the QOS transmission values // {{{ // will be honored when determining who wins arbitration for // accessing a given slave. (This feature has not yet been // verified)",
            "parameter [0:0] OPT_QOS = 0, // }}} // // LGMAXBURST: Specifies the log based two of the maximum // {{{ // number of bursts transactions that may be outstanding at any // given time. This is different from the maximum number of // outstanding beats.",
            "parameter LGMAXBURST = 3 // }}} // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, // Write slave channels from the controlling AXI masters // {{{",
            "input wire [NM*C_AXI_ID_WIDTH-1:0] S_AXI_AWID, input wire [NM*C_AXI_ADDR_WIDTH-1:0] S_AXI_AWADDR, input wire [NM*8-1:0] S_AXI_AWLEN, input wire [NM*3-1:0] S_AXI_AWSIZE, input wire [NM*2-1:0] S_AXI_AWBURST, input wire [NM-1:0] S_AXI_AWLOCK, input wire [NM*4-1:0] S_AXI_AWCACHE, input wire [NM*3-1:0] S_AXI_AWPROT, input wire [NM*4-1:0] S_AXI_AWQOS, input wire [NM-1:0] S_AXI_AWVALID, output wire [NM-1:0] S_AXI_AWREADY, // input wire [NM*C_AXI_DATA_WIDTH-1:0] S_AXI_WDATA, input wire [NM*C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB, input wire [NM-1:0] S_AXI_WLAST, input wire [NM-1:0] S_AXI_WVALID, output wire [NM-1:0] S_AXI_WREADY, // output wire [NM*C_AXI_ID_WIDTH-1:0] S_AXI_BID, output wire [NM*2-1:0] S_AXI_BRESP, output wire [NM-1:0] S_AXI_BVALID, input wire [NM-1:0] S_AXI_BREADY, // }}} // Read slave channels from the controlling AXI masters // {{{",
            "input wire [NM*C_AXI_ID_WIDTH-1:0] S_AXI_ARID, input wire [NM*C_AXI_ADDR_WIDTH-1:0] S_AXI_ARADDR, input wire [NM*8-1:0] S_AXI_ARLEN, input wire [NM*3-1:0] S_AXI_ARSIZE, input wire [NM*2-1:0] S_AXI_ARBURST, input wire [NM-1:0] S_AXI_ARLOCK, input wire [NM*4-1:0] S_AXI_ARCACHE, input wire [NM*3-1:0] S_AXI_ARPROT, input wire [NM*4-1:0] S_AXI_ARQOS, input wire [NM-1:0] S_AXI_ARVALID, output wire [NM-1:0] S_AXI_ARREADY, // output wire [NM*C_AXI_ID_WIDTH-1:0] S_AXI_RID, output wire [NM*C_AXI_DATA_WIDTH-1:0] S_AXI_RDATA, output wire [NM*2-1:0] S_AXI_RRESP, output wire [NM-1:0] S_AXI_RLAST, output wire [NM-1:0] S_AXI_RVALID, input wire [NM-1:0] S_AXI_RREADY, // }}} // Write channel master",
            "output s to the connected AXI slaves // {{{",
            "output wire [NS*C_AXI_ID_WIDTH-1:0] M_AXI_AWID, output wire [NS*C_AXI_ADDR_WIDTH-1:0] M_AXI_AWADDR, output wire [NS*8-1:0] M_AXI_AWLEN, output wire [NS*3-1:0] M_AXI_AWSIZE, output wire [NS*2-1:0] M_AXI_AWBURST, output wire [NS-1:0] M_AXI_AWLOCK, output wire [NS*4-1:0] M_AXI_AWCACHE, output wire [NS*3-1:0] M_AXI_AWPROT, output wire [NS*4-1:0] M_AXI_AWQOS, output wire [NS-1:0] M_AXI_AWVALID, input wire [NS-1:0] M_AXI_AWREADY, // // output wire [NS*C_AXI_DATA_WIDTH-1:0] M_AXI_WDATA, output wire [NS*C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB, output wire [NS-1:0] M_AXI_WLAST, output wire [NS-1:0] M_AXI_WVALID, input wire [NS-1:0] M_AXI_WREADY, // input wire [NS*C_AXI_ID_WIDTH-1:0] M_AXI_BID, input wire [NS*2-1:0] M_AXI_BRESP, input wire [NS-1:0] M_AXI_BVALID, output wire [NS-1:0] M_AXI_BREADY, // }}} // Read channel master",
            "output s to the connected AXI slaves // {{{",
            "output wire [NS*C_AXI_ID_WIDTH-1:0] M_AXI_ARID, output wire [NS*C_AXI_ADDR_WIDTH-1:0] M_AXI_ARADDR, output wire [NS*8-1:0] M_AXI_ARLEN, output wire [NS*3-1:0] M_AXI_ARSIZE, output wire [NS*2-1:0] M_AXI_ARBURST, output wire [NS-1:0] M_AXI_ARLOCK, output wire [NS*4-1:0] M_AXI_ARCACHE, output wire [NS*4-1:0] M_AXI_ARQOS, output wire [NS*3-1:0] M_AXI_ARPROT, output wire [NS-1:0] M_AXI_ARVALID, input wire [NS-1:0] M_AXI_ARREADY, // // input wire [NS*C_AXI_ID_WIDTH-1:0] M_AXI_RID, input wire [NS*C_AXI_DATA_WIDTH-1:0] M_AXI_RDATA, input wire [NS*2-1:0] M_AXI_RRESP, input wire [NS-1:0] M_AXI_RLAST, input wire [NS-1:0] M_AXI_RVALID, output wire [NS-1:0] M_AXI_RREADY // }}} // }}} ); // Local",
            "parameter s, derived from those above // {{{ // IW, AW, and DW, are short-hand abbreviations used locally.",
            "localparam IW = C_AXI_ID_WIDTH;",
            "localparam AW = C_AXI_ADDR_WIDTH;",
            "localparam DW = C_AXI_DATA_WIDTH; // LGLINGER tells us how many bits we need for counting how long // to keep an udle channel open.",
            "localparam LGLINGER = (OPT_LINGER>1) ? $clog2(OPT_LINGER+1) : 1; // localparam LGNM = (NM>1) ? $clog2(NM) : 1;",
            "localparam LGNS = (NS>1) ? $clog2(NS+1) : 1; // // In order to use indexes, and hence fully balanced mux trees, it helps // to make certain that we have a power of two based lookup. NMFULL // is the number of masters in this lookup, with potentially some // unused extra ones. NSFULL is defined similarly.",
            "localparam NMFULL = (NM>1) ? (1<<LGNM) : 1;",
            "localparam NSFULL = (NS>1) ? (1<<LGNS) : 2; // localparam [1:0] INTERCONNECT_ERROR = 2'b11; // // OPT_SKID_INPUT controls whether the",
            "input skid buffers",
            "reg ister // their",
            "output s or not. If set, all skid buffers will cost one more // clock of latency. It's not clear that there's a performance gain // to be had by setting this.",
            "localparam [0:0] OPT_SKID_INPUT = 0; // // OPT_BUFFER_DECODER determines whether or not the",
            "output s of the // address decoder will be buffered or not. If buffered, there will // be an extra (",
            "reg istered) clock delay on each of the A* channels from // VALID to issue.",
            "localparam [0:0] OPT_BUFFER_DECODER = 1; // // OPT_AWW controls whether or not a W* beat may be issued to a slave // at the same time as the first AW* beat gets sent to the slave. Set // to 1'b1 for lower latency, at the potential cost of a greater // combinatorial path length",
            "localparam OPT_AWW = 1'b1; // }}} //////////////////////////////////////////////////////////////////////// // // Internal signal declarations and definitions // {{{ //////////////////////////////////////////////////////////////////////// // // genvar N,M; integer iN, iM;",
            "reg [NSFULL-1:0] wrequest [0:NM-1];",
            "reg [NSFULL-1:0] rrequest [0:NM-1];",
            "reg [NSFULL-1:0] wrequested [0:NM];",
            "reg [NSFULL-1:0] rrequested [0:NM];",
            "reg [NS:0] wgrant [0:NM-1];",
            "reg [NS:0] rgrant [0:NM-1];",
            "reg [NM-1:0] mwgrant;",
            "reg [NM-1:0] mrgrant;",
            "reg [NS-1:0] swgrant;",
            "reg [NS-1:0] srgrant; // verilator lint_off UNUSED",
            "wire [LGMAXBURST-1:0] w_mawpending [0:NM-1];",
            "wire [LGMAXBURST-1:0] wlasts_pending [0:NM-1];",
            "wire [LGMAXBURST-1:0] w_mrpending [0:NM-1]; // verilator lint_on UNUSED",
            "reg [NM-1:0] mwfull;",
            "reg [NM-1:0] mrfull;",
            "reg [NM-1:0] mwempty;",
            "reg [NM-1:0] mrempty; // wire [LGNS-1:0] mwindex [0:NMFULL-1];",
            "wire [LGNS-1:0] mrindex [0:NMFULL-1];",
            "wire [LGNM-1:0] swindex [0:NSFULL-1];",
            "wire [LGNM-1:0] srindex [0:NSFULL-1];",
            "wire [NM-1:0] wdata_expected; // The shadow buffers",
            "wire [NMFULL-1:0] m_awvalid, m_arvalid;",
            "wire [NMFULL-1:0] m_wvalid;",
            "wire [NM-1:0] dcd_awvalid, dcd_arvalid;",
            "wire [C_AXI_ID_WIDTH-1:0] m_awid [0:NMFULL-1];",
            "wire [C_AXI_ADDR_WIDTH-1:0] m_awaddr [0:NMFULL-1];",
            "wire [7:0] m_awlen [0:NMFULL-1];",
            "wire [2:0] m_awsize [0:NMFULL-1];",
            "wire [1:0] m_awburst [0:NMFULL-1];",
            "wire [NMFULL-1:0] m_awlock;",
            "wire [3:0] m_awcache [0:NMFULL-1];",
            "wire [2:0] m_awprot [0:NMFULL-1];",
            "wire [3:0] m_awqos [0:NMFULL-1]; // wire [C_AXI_DATA_WIDTH-1:0] m_wdata [0:NMFULL-1];",
            "wire [C_AXI_DATA_WIDTH/8-1:0] m_wstrb [0:NMFULL-1];",
            "wire [NMFULL-1:0] m_wlast;",
            "wire [C_AXI_ID_WIDTH-1:0] m_arid [0:NMFULL-1];",
            "wire [C_AXI_ADDR_WIDTH-1:0] m_araddr [0:NMFULL-1];",
            "wire [8-1:0] m_arlen [0:NMFULL-1];",
            "wire [3-1:0] m_arsize [0:NMFULL-1];",
            "wire [2-1:0] m_arburst [0:NMFULL-1];",
            "wire [NMFULL-1:0] m_arlock;",
            "wire [4-1:0] m_arcache [0:NMFULL-1];",
            "wire [2:0] m_arprot [0:NMFULL-1];",
            "wire [3:0] m_arqos [0:NMFULL-1]; // // reg [NM-1:0] berr_valid;",
            "reg [IW-1:0] berr_id [0:NM-1]; // reg [NM-1:0] rerr_none;",
            "reg [NM-1:0] rerr_last;",
            "reg [8:0] rerr_outstanding [0:NM-1];",
            "reg [IW-1:0] rerr_id [0:NM-1];",
            "wire [NM-1:0] skd_awvalid, skd_awstall;",
            "wire [NM-1:0] skd_arvalid, skd_arstall;",
            "wire [IW-1:0] skd_awid [0:NM-1];",
            "wire [AW-1:0] skd_awaddr [0:NM-1];",
            "wire [8-1:0] skd_awlen [0:NM-1];",
            "wire [3-1:0] skd_awsize [0:NM-1];",
            "wire [2-1:0] skd_awburst [0:NM-1];",
            "wire [NM-1:0] skd_awlock;",
            "wire [4-1:0] skd_awcache [0:NM-1];",
            "wire [3-1:0] skd_awprot [0:NM-1];",
            "wire [4-1:0] skd_awqos [0:NM-1]; // wire [IW-1:0] skd_arid [0:NM-1];",
            "wire [AW-1:0] skd_araddr [0:NM-1];",
            "wire [8-1:0] skd_arlen [0:NM-1];",
            "wire [3-1:0] skd_arsize [0:NM-1];",
            "wire [2-1:0] skd_arburst [0:NM-1];",
            "wire [NM-1:0] skd_arlock;",
            "wire [4-1:0] skd_arcache [0:NM-1];",
            "wire [3-1:0] skd_arprot [0:NM-1];",
            "wire [4-1:0] skd_arqos [0:NM-1]; // Verilator lint_off UNUSED",
            "reg [NSFULL-1:0] m_axi_awvalid;",
            "reg [NSFULL-1:0] m_axi_awready;",
            "reg [IW-1:0] m_axi_awid [0:NSFULL-1];",
            "reg [7:0] m_axi_awlen [0:NSFULL-1];",
            "reg [NSFULL-1:0] m_axi_wvalid;",
            "reg [NSFULL-1:0] m_axi_wready;",
            "reg [NSFULL-1:0] m_axi_bvalid;",
            "reg [NSFULL-1:0] m_axi_bready; // Verilator lint_on UNUSED",
            "reg [1:0] m_axi_bresp [0:NSFULL-1];",
            "reg [IW-1:0] m_axi_bid [0:NSFULL-1]; // Verilator lint_off UNUSED",
            "reg [NSFULL-1:0] m_axi_arvalid;",
            "reg [7:0] m_axi_arlen [0:NSFULL-1];",
            "reg [IW-1:0] m_axi_arid [0:NSFULL-1];",
            "reg [NSFULL-1:0] m_axi_arready; // Verilator lint_on UNUSED",
            "reg [NSFULL-1:0] m_axi_rvalid; // Verilator lint_off UNUSED",
            "reg [NSFULL-1:0] m_axi_rready; // Verilator lint_on UNUSED // reg [IW-1:0] m_axi_rid [0:NSFULL-1];",
            "reg [DW-1:0] m_axi_rdata [0:NSFULL-1];",
            "reg [NSFULL-1:0] m_axi_rlast;",
            "reg [2-1:0] m_axi_rresp [0:NSFULL-1];",
            "reg [NM-1:0] slave_awaccepts;",
            "reg [NM-1:0] slave_waccepts;",
            "reg [NM-1:0] slave_raccepts;",
            "reg [NM-1:0] bskd_valid;",
            "reg [NM-1:0] rskd_valid, rskd_rlast;",
            "wire [NM-1:0] bskd_ready;",
            "wire [NM-1:0] rskd_ready; // Verilator lint_off UNUSED",
            "wire [NMFULL-1:0] write_qos_lockout, read_qos_lockout; // Verilator lint_on UNUSED",
            "reg [NSFULL-1:0] slave_awready, slave_wready, slave_arready; // }}} // m_axi_* convenience signals (write side) // {{{",
            "always @(*) begin m_axi_awvalid = -1; m_axi_awready = -1; m_axi_wvalid = -1; m_axi_wready = -1; m_axi_bvalid = 0; m_axi_bready = -1; m_axi_awvalid[NS-1:0] = M_AXI_AWVALID; m_axi_awready[NS-1:0] = M_AXI_AWREADY; m_axi_wvalid[NS-1:0] = M_AXI_WVALID; m_axi_wready[NS-1:0] = M_AXI_WREADY; m_axi_bvalid[NS-1:0] = M_AXI_BVALID; m_axi_bready[NS-1:0] = M_AXI_BREADY; for(iM=0; iM<NS; iM=iM+1) begin m_axi_awid[iM] = M_AXI_AWID[ iM*IW +: IW]; m_axi_awlen[iM] = M_AXI_AWLEN[ iM* 8 +: 8]; m_axi_bid[iM] = M_AXI_BID[iM* IW +: IW]; m_axi_bresp[iM] = M_AXI_BRESP[iM* 2 +: 2]; m_axi_rid[iM] = M_AXI_RID[ iM*IW +: IW]; m_axi_rdata[iM] = M_AXI_RDATA[iM*DW +: DW]; m_axi_rresp[iM] = M_AXI_RRESP[iM* 2 +: 2]; m_axi_rlast[iM] = M_AXI_RLAST[iM]; end for(iM=NS; iM<NSFULL; iM=iM+1) begin m_axi_awid[iM] = 0; m_axi_awlen[iM] = 0; m_axi_bresp[iM] = INTERCONNECT_ERROR; m_axi_bid[iM] = 0; m_axi_rid[iM] = 0; m_axi_rdata[iM] = 0; m_axi_rresp[iM] = INTERCONNECT_ERROR; m_axi_rlast[iM] = 1; end end // }}} // m_axi_* convenience signals (read side) // {{{",
            "always @(*) begin m_axi_arvalid = 0; m_axi_arready = 0; m_axi_rvalid = 0; m_axi_rready = 0; for(iM=0; iM<NS; iM=iM+1) begin m_axi_arlen[iM] = M_AXI_ARLEN[iM* 8 +: 8]; m_axi_arid[iM] = M_AXI_ARID[ iM*IW +: IW]; end for(iM=NS; iM<NSFULL; iM=iM+1) begin m_axi_arlen[iM] = 0; m_axi_arid[iM] = 0; end m_axi_arvalid[NS-1:0] = M_AXI_ARVALID; m_axi_arready[NS-1:0] = M_AXI_ARREADY; m_axi_rvalid[NS-1:0] = M_AXI_RVALID; m_axi_rready[NS-1:0] = M_AXI_RREADY; end // }}} // slave_*ready convenience signals // {{{",
            "always @(*) begin // These are designed to keep us from doing things like // m_axi_*[m?index[N]] && m_axi_*[m?index[N]] && .. etc // // First, we'll set bits for all slaves--to include those that // are undefined (but required by our static analysis tools). slave_awready = -1; slave_wready = -1; slave_arready = -1; // // Here we do all of the combinatoric calculations, so the // master only needs to reference one bit of this signal slave_awready[NS-1:0] = (~M_AXI_AWVALID | M_AXI_AWREADY); slave_wready[NS-1:0] = (~M_AXI_WVALID | M_AXI_WREADY); slave_arready[NS-1:0] = (~M_AXI_ARVALID | M_AXI_ARREADY); end // }}} //////////////////////////////////////////////////////////////////////// // // Process our incoming signals: AW*, W*, and AR* // {{{ //////////////////////////////////////////////////////////////////////// // // generate for(N=0; N<NM; N=N+1) begin : W1_DECODE_WRITE_REQUEST // {{{",
            "wire [NS:0] wdecode; // awskid, the skidbuffer for the incoming AW* channel // {{{ skidbuffer #( // {{{ .DW(IW+AW+8+3+2+1+4+3+4), .OPT_OUTREG(OPT_SKID_INPUT) // }}} ) awskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, S_AXI_AWVALID[N], S_AXI_AWREADY[N], { S_AXI_AWID[N*IW +: IW], S_AXI_AWADDR[N*AW +: AW], S_AXI_AWLEN[N*8 +: 8], S_AXI_AWSIZE[N*3 +: 3], S_AXI_AWBURST[N*2 +: 2], S_AXI_AWLOCK[N], S_AXI_AWCACHE[N*4 +: 4], S_AXI_AWPROT[N*3 +: 3], S_AXI_AWQOS[N*4 +: 4] }, skd_awvalid[N], !skd_awstall[N], { skd_awid[N], skd_awaddr[N], skd_awlen[N], skd_awsize[N], skd_awburst[N], skd_awlock[N], skd_awcache[N], skd_awprot[N], skd_awqos[N] } // }}} ); // }}} // wraddr, decode the write channel's address request to a // particular slave index // {{{ addrdecode #( // {{{ .AW(AW), .DW(IW+8+3+2+1+4+3+4), .NS(NS), .SLAVE_ADDR(SLAVE_ADDR), .SLAVE_MASK(SLAVE_MASK), .OPT_REGISTERED(OPT_BUFFER_DECODER) // }}} ) wraddr( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(skd_awvalid[N]), .o_stall(skd_awstall[N]), .i_addr(skd_awaddr[N]), .i_data({ skd_awid[N], skd_awlen[N], skd_awsize[N], skd_awburst[N], skd_awlock[N], skd_awcache[N], skd_awprot[N], skd_awqos[N] }), .o_valid(dcd_awvalid[N]), .i_stall(!dcd_awvalid[N]||!slave_awaccepts[N]), .o_decode(wdecode), .o_addr(m_awaddr[N]), .o_data({ m_awid[N], m_awlen[N], m_awsize[N], m_awburst[N], m_awlock[N], m_awcache[N], m_awprot[N], m_awqos[N]}) // }}} ); // }}} // wskid, the skid buffer for the incoming W* channel // {{{ skidbuffer #( // {{{ .DW(DW+DW/8+1), .OPT_OUTREG(OPT_SKID_INPUT || OPT_BUFFER_DECODER) // }}} ) wskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, S_AXI_WVALID[N], S_AXI_WREADY[N], { S_AXI_WDATA[N*DW +: DW], S_AXI_WSTRB[N*DW/8 +: DW/8], S_AXI_WLAST[N] }, m_wvalid[N], slave_waccepts[N], { m_wdata[N], m_wstrb[N], m_wlast[N] } // }}} ); // }}} // slave_awaccepts // {{{",
            "always @(*) begin slave_awaccepts[N] = 1'b1; // Cannot accept/forward a packet without a bus grant // This handles whether or not write data is still // pending. if (!mwgrant[N]) slave_awaccepts[N] = 1'b0; if (write_qos_lockout[N]) slave_awaccepts[N] = 1'b0; if (mwfull[N]) slave_awaccepts[N] = 1'b0; // Don't accept a packet unless its to the same slave // the grant is issued for if (!wrequest[N][mwindex[N]]) slave_awaccepts[N] = 1'b0; if (!wgrant[N][NS]) begin if (!slave_awready[mwindex[N]]) slave_awaccepts[N] = 1'b0; end else if (berr_valid[N] && !bskd_ready[N]) begin // Can't accept an write address channel request // for the no-address-mapped channel if the // B* channel is stalled, lest we lose the ID // of the transaction // // !berr_valid[N] => we have to accept more // write data before we can issue BVALID slave_awaccepts[N] = 1'b0; end end // }}} // slave_waccepts // {{{",
            "always @(*) begin slave_waccepts[N] = 1'b1; if (!mwgrant[N]) slave_waccepts[N] = 1'b0; if (!wdata_expected[N] && (!OPT_AWW || !slave_awaccepts[N])) slave_waccepts[N] = 1'b0; if (!wgrant[N][NS]) begin if (!slave_wready[mwindex[N]]) slave_waccepts[N] = 1'b0; end else if (berr_valid[N] && !bskd_ready[N]) slave_waccepts[N] = 1'b0; end // }}}",
            "reg r_awvalid;",
            "always @(*) begin r_awvalid = dcd_awvalid[N] && !mwfull[N]; wrequest[N]= 0; if (!mwfull[N]) wrequest[N][NS:0] = wdecode; end",
            "assign m_awvalid[N] = r_awvalid; // QOS handling via write_qos_lockout // {{{ if (!OPT_QOS || NM == 1) begin : WRITE_NO_QOS // If we aren't using QOS, then never lock any packets // out from arbitration",
            "assign write_qos_lockout[N] = 0; end else begin : WRITE_QOS // Lock out a master based upon a second master having // a higher QOS request level // {{{",
            "reg r_write_qos_lockout;",
            "initial r_write_qos_lockout = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_write_qos_lockout <= 0; else begin r_write_qos_lockout <= 0; for(iN=0; iN<NM; iN=iN+1) if (iN != N) begin if (m_awvalid[N] &&(|(wrequest[iN][NS-1:0] & wdecode[NS-1:0])) &&(m_awqos[N] < m_awqos[iN])) r_write_qos_lockout <= 1; end end",
            "assign write_qos_lockout[N] = r_write_qos_lockout; // }}} end // }}} end for (N=NM; N<NMFULL; N=N+1) begin : UNUSED_WSKID_BUFFERS // {{{ // The following values are unused. They need to be defined // so that our indexing scheme will work, but indexes should // never actually reference them",
            "assign m_awid[N] = 0;",
            "assign m_awaddr[N] = 0;",
            "assign m_awlen[N] = 0;",
            "assign m_awsize[N] = 0;",
            "assign m_awburst[N] = 0;",
            "assign m_awlock[N] = 0;",
            "assign m_awcache[N] = 0;",
            "assign m_awprot[N] = 0;",
            "assign m_awqos[N] = 0;",
            "assign m_awvalid[N] = 0;",
            "assign m_wvalid[N] = 0; // assign m_wdata[N] = 0;",
            "assign m_wstrb[N] = 0;",
            "assign m_wlast[N] = 0;",
            "assign write_qos_lockout[N] = 0; // }}} // }}} end endgenerate // Read skid buffers and address decoding, slave_araccepts",
            "logic generate for(N=0; N<NM; N=N+1) begin : R1_DECODE_READ_REQUEST // {{{",
            "reg r_arvalid;",
            "wire [NS:0] rdecode; // arskid // {{{ skidbuffer #( // {{{ .DW(IW+AW+8+3+2+1+4+3+4), .OPT_OUTREG(OPT_SKID_INPUT) // }}} ) arskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, S_AXI_ARVALID[N], S_AXI_ARREADY[N], { S_AXI_ARID[N*IW +: IW], S_AXI_ARADDR[N*AW +: AW], S_AXI_ARLEN[N*8 +: 8], S_AXI_ARSIZE[N*3 +: 3], S_AXI_ARBURST[N*2 +: 2], S_AXI_ARLOCK[N], S_AXI_ARCACHE[N*4 +: 4], S_AXI_ARPROT[N*3 +: 3], S_AXI_ARQOS[N*4 +: 4] }, skd_arvalid[N], !skd_arstall[N], { skd_arid[N], skd_araddr[N], skd_arlen[N], skd_arsize[N], skd_arburst[N], skd_arlock[N], skd_arcache[N], skd_arprot[N], skd_arqos[N] } // }}} ); // }}} // Read address decoder // {{{ addrdecode #( // {{{ .AW(AW), .DW(IW+8+3+2+1+4+3+4), .NS(NS), .SLAVE_ADDR(SLAVE_ADDR), .SLAVE_MASK(SLAVE_MASK), .OPT_REGISTERED(OPT_BUFFER_DECODER) // }}} ) rdaddr( // {{{ .i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN), .i_valid(skd_arvalid[N]), .o_stall(skd_arstall[N]), .i_addr(skd_araddr[N]), .i_data({ skd_arid[N], skd_arlen[N], skd_arsize[N], skd_arburst[N], skd_arlock[N], skd_arcache[N], skd_arprot[N], skd_arqos[N] }), .o_valid(dcd_arvalid[N]), .i_stall(!m_arvalid[N] || !slave_raccepts[N]), .o_decode(rdecode), .o_addr(m_araddr[N]), .o_data({ m_arid[N], m_arlen[N], m_arsize[N], m_arburst[N], m_arlock[N], m_arcache[N], m_arprot[N], m_arqos[N]}) // }}} ); // }}}",
            "always @(*) begin r_arvalid = dcd_arvalid[N] && !mrfull[N]; rrequest[N] = 0; if (!mrfull[N]) rrequest[N][NS:0] = rdecode; end",
            "assign m_arvalid[N] = r_arvalid; // slave_raccepts decoding // {{{",
            "always @(*) begin slave_raccepts[N] = 1'b1; if (!mrgrant[N]) slave_raccepts[N] = 1'b0; if (read_qos_lockout[N]) slave_raccepts[N] = 1'b0; if (mrfull[N]) slave_raccepts[N] = 1'b0; // If we aren't requesting access to the channel we've // been granted access to, then we can't accept this // verilator lint_off WIDTH if (!rrequest[N][mrindex[N]]) slave_raccepts[N] = 1'b0; // verilator lint_on WIDTH if (!rgrant[N][NS]) begin if (!slave_arready[mrindex[N]]) slave_raccepts[N] = 1'b0; end else if (!mrempty[N] || !rerr_none[N] || rskd_valid[N]) slave_raccepts[N] = 1'b0; end // }}} // Read QOS",
            "logic // {{{ // read_qos_lockout will get set if a master with a higher // QOS number is requesting a given slave. It will not // affect existing outstanding packets, but will be used to // prevent further packets from being sent to a given slave. if (!OPT_QOS || NM == 1) begin : READ_NO_QOS // If we aren't implementing QOS, then the lockout // signal is never set",
            "assign read_qos_lockout[N] = 0; end else begin : READ_QOS // {{{ // We set lockout if another master (with a higher // QOS) is requesting this slave *and* the slave // channel is currently stalled.",
            "reg r_read_qos_lockout;",
            "initial r_read_qos_lockout = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_read_qos_lockout <= 0; else begin r_read_qos_lockout <= 0; for(iN=0; iN<NM; iN=iN+1) if (iN != N) begin if (m_arvalid[iN] && !slave_raccepts[N] &&(|(rrequest[iN][NS-1:0] & rdecode[NS-1:0])) &&(m_arqos[N] < m_arqos[iN])) r_read_qos_lockout <= 1; end end",
            "assign read_qos_lockout[N] = 0; // }}} end // }}} end for (N=NM; N<NMFULL; N=N+1) begin : UNUSED_RSKID_BUFFERS // {{{",
            "assign m_arvalid[N] = 0;",
            "assign m_arid[N] = 0;",
            "assign m_araddr[N] = 0;",
            "assign m_arlen[N] = 0;",
            "assign m_arsize[N] = 0;",
            "assign m_arburst[N] = 0;",
            "assign m_arlock[N] = 0;",
            "assign m_arcache[N] = 0;",
            "assign m_arprot[N] = 0;",
            "assign m_arqos[N] = 0;",
            "assign read_qos_lockout[N] = 0; // }}} // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Channel arbitration // {{{ //////////////////////////////////////////////////////////////////////// // // // wrequested // {{{",
            "always @(*) begin : W2_DECONFLICT_WRITE_REQUESTS for(iN=0; iN<=NM; iN=iN+1) wrequested[iN] = 0; // Vivado may complain about too many bits for wrequested. // This is (currrently) expected. mwindex is used to index // into wrequested, and mwindex has LGNS bits, where LGNS // is $clog2(NS+1) rather than $clog2(NS). The extra bits // are defined to be zeros, but the point is they are defined. // Therefore, no matter what mwindex is, it will",
            "always // reference something valid. wrequested[NM] = 0; for(iM=0; iM<NS; iM=iM+1) begin wrequested[0][iM] = 1'b0; for(iN=1; iN<NM ; iN=iN+1) begin // Continue to request any channel with // a grant and pending operations if (wrequest[iN-1][iM] && wgrant[iN-1][iM]) wrequested[iN][iM] = 1; if (wrequest[iN-1][iM] && (!mwgrant[iN-1]||mwempty[iN-1])) wrequested[iN][iM] = 1; // Otherwise, if it's already claimed, then // it can't be claimed again if (wrequested[iN-1][iM]) wrequested[iN][iM] = 1; end wrequested[NM][iM] = wrequest[NM-1][iM] || wrequested[NM-1][iM]; end end // }}} // rrequested // {{{",
            "always @(*) begin : R2_DECONFLICT_READ_REQUESTS for(iN=0; iN<NM ; iN=iN+1) rrequested[iN] = 0; // See the note above for wrequested. This applies to // rrequested as well. rrequested[NM] = 0; for(iM=0; iM<NS; iM=iM+1) begin rrequested[0][iM] = 0; for(iN=1; iN<NM ; iN=iN+1) begin // Continue to request any channel with // a grant and pending operations if (rrequest[iN-1][iM] && rgrant[iN-1][iM]) rrequested[iN][iM] = 1; if (rrequest[iN-1][iM] && (!mrgrant[iN-1] || mrempty[iN-1])) rrequested[iN][iM] = 1; // Otherwise, if it's already claimed, then // it can't be claimed again if (rrequested[iN-1][iM]) rrequested[iN][iM] = 1; end rrequested[NM][iM] = rrequest[NM-1][iM] || rrequested[NM-1][iM]; end end // }}} generate for(N=0; N<NM; N=N+1) begin : W3_ARBITRATE_WRITE_REQUESTS // {{{",
            "reg stay_on_channel;",
            "reg requested_channel_is_available;",
            "reg leave_channel;",
            "reg [LGNS-1:0] requested_index;",
            "wire linger;",
            "reg [LGNS-1:0] r_mwindex; // The basic",
            "logic : // 1. If we must stay_on_channel, then nothing changes // 2. If the requested channel isn't available, then no grant // is issued // 3. Otherwise, if we need to leave this channel--such as if // another master is requesting it, then we lose our grant // stay_on_channel // {{{ // We must stay on the channel if we aren't done working with it // i.e. more writes requested, more acknowledgments expected, // etc.",
            "always @(*) begin stay_on_channel = |(wrequest[N][NS:0] & wgrant[N]); if (write_qos_lockout[N]) stay_on_channel = 0; // We must stay on this channel until we've received // our last acknowledgment signal. Only then can we // switch grants if (mwgrant[N] && !mwempty[N]) stay_on_channel = 1; // if berr_valid is true, we have a grant to the // internal slave-error channel. While this grant // exists, we cannot issue any others. if (berr_valid[N]) stay_on_channel = 1; end // }}} // requested_channel_is_available // {{{",
            "always @(*) begin // The channel is available to us if 1) we want it, // 2) no one else is using it, and 3) no one earlier // has requested it requested_channel_is_available = |(wrequest[N][NS-1:0] & ~swgrant & ~wrequested[N][NS-1:0]); // Of course, the error pseudo-channel is *",
            "always * // available to us. if (wrequest[N][NS]) requested_channel_is_available = 1; // Likewise, if we are the only master, then the // channel is",
            "always available on any request if (NM < 2) requested_channel_is_available = m_awvalid[N]; end // }}} // Linger option, and setting the \"linger\" flag // {{{ // If used, linger will hold on to a given channels grant // for some number of clock ticks after the channel has become // idle. This will spare future requests from the same master // to the same slave from neding to go through the arbitration // clock cycle again--potentially saving a clock period. If, // however, the master in question requests a different slave // or a different master requests this slave, then the linger // option is voided and the grant given up anyway. if (OPT_LINGER == 0) begin : NO_LINGER",
            "assign linger = 0; end else begin : WRITE_LINGER",
            "reg [LGLINGER-1:0] linger_counter;",
            "reg r_linger;",
            "initial r_linger = 0;",
            "initial linger_counter = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || wgrant[N][NS]) begin r_linger <= 0; linger_counter <= 0; end else if (!mwempty[N] || bskd_valid[N]) begin // While the channel is in use, we set the // linger counter linger_counter <= OPT_LINGER; r_linger <= 1; end else if (linger_counter > 0) begin // Otherwise, we decrement it until it reaches // zero r_linger <= (linger_counter > 1); linger_counter <= linger_counter - 1; end else r_linger <= 0;",
            "assign linger = r_linger; end // }}} // leave_channel // {{{ // True of another master is requesting access to this slave, // or if we are requesting access to another slave. If QOS // lockout is enabled, then we also leave the channel if a // request with a higher QOS has arrived",
            "always @(*) begin leave_channel = 0; if (!m_awvalid[N] && (!linger || wrequested[NM][mwindex[N]])) // Leave the channel after OPT_LINGER counts // of the channel being idle, or when someone // else asks for the channel leave_channel = 1; if (m_awvalid[N] && !wrequest[N][mwindex[N]]) // Need to leave this channel to connect // to any other channel leave_channel = 1; if (write_qos_lockout[N]) // Need to leave this channel for another higher // priority request leave_channel = 1; end // }}} // WRITE GRANT ALLOCATION // {{{ // Now that we've done our homework, we can switch grants // if necessary",
            "initial wgrant[N] = 0;",
            "initial mwgrant[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin wgrant[N] <= 0; mwgrant[N] <= 0; end else if (!stay_on_channel) begin if (requested_channel_is_available) begin // Switch to a new channel mwgrant[N] <= 1'b1; wgrant[N] <= wrequest[N][NS:0]; end else if (leave_channel) begin // Revoke the given grant mwgrant[N] <= 1'b0; wgrant[N] <= 0; end end // }}} // mwindex (",
            "reg istered) // {{{",
            "always @(wrequest[N]) begin requested_index = 0; for(iM=0; iM<=NS; iM=iM+1) if (wrequest[N][iM]) requested_index= requested_index | iM[LGNS-1:0]; end // Now for mwindex",
            "initial r_mwindex = 0;",
            "always @(posedge S_AXI_ACLK) if (!stay_on_channel && requested_channel_is_available) r_mwindex <= requested_index;",
            "assign mwindex[N] = r_mwindex; // }}} end for (N=NM; N<NMFULL; N=N+1) begin",
            "assign mwindex[N] = 0; // }}} end endgenerate generate for(N=0; N<NM; N=N+1) begin : R3_ARBITRATE_READ_REQUESTS // {{{",
            "reg stay_on_channel;",
            "reg requested_channel_is_available;",
            "reg leave_channel;",
            "reg [LGNS-1:0] requested_index;",
            "reg linger;",
            "reg [LGNS-1:0] r_mrindex; // The basic",
            "logic : // 1. If we must stay_on_channel, then nothing changes // 2. If the requested channel isn't available, then no grant // is issued // 3. Otherwise, if we need to leave this channel--such as if // another master is requesting it, then we lose our grant // stay_on_channel // {{{ // We must stay on the channel if we aren't done working with it // i.e. more reads requested, more acknowledgments expected, // etc.",
            "always @(*) begin stay_on_channel = |(rrequest[N][NS:0] & rgrant[N]); if (read_qos_lockout[N]) stay_on_channel = 0; // We must stay on this channel until we've received // our last acknowledgment signal. Only then can we // switch grants if (mrgrant[N] && !mrempty[N]) stay_on_channel = 1; // if we have a grant to the internal slave-error // channel, then we cannot issue a grant to any other // while this grant is active if (rgrant[N][NS] && (!rerr_none[N] || rskd_valid[N])) stay_on_channel = 1; end // }}} // requested_channel_is_available // {{{",
            "always @(*) begin // The channel is available to us if 1) we want it, // 2) no one else is using it, and 3) no one earlier // has requested it requested_channel_is_available = |(rrequest[N][NS-1:0] & ~srgrant & ~rrequested[N][NS-1:0]); // Of course, the error pseudo-channel is *",
            "always * // available to us. if (rrequest[N][NS]) requested_channel_is_available = 1; // Likewise, if we are the only master, then the // channel is",
            "always available on any request if (NM < 2) requested_channel_is_available = m_arvalid[N]; end // }}} // Linger option, and setting the \"linger\" flag // {{{ // If used, linger will hold on to a given channels grant // for some number of clock ticks after the channel has become // idle. This will spare future requests from the same master // to the same slave from neding to go through the arbitration // clock cycle again--potentially saving a clock period. If, // however, the master in question requests a different slave // or a different master requests this slave, then the linger // option is voided and the grant given up anyway. if (OPT_LINGER == 0) begin : NO_LONGER",
            "always @(*) linger = 0; end else begin : READ_LINGER",
            "reg [LGLINGER-1:0] linger_counter;",
            "initial linger = 0;",
            "initial linger_counter = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || rgrant[N][NS]) begin linger <= 0; linger_counter <= 0; end else if (!mrempty[N] || rskd_valid[N]) begin linger_counter <= OPT_LINGER; linger <= 1; end else if (linger_counter > 0) begin linger <= (linger_counter > 1); linger_counter <= linger_counter - 1; end else linger <= 0; end // }}} // leave_channel // {{{ // True of another master is requesting access to this slave, // or if we are requesting access to another slave. If QOS // lockout is enabled, then we also leave the channel if a // request with a higher QOS has arrived",
            "always @(*) begin leave_channel = 0; if (!m_arvalid[N] && (!linger || rrequested[NM][mrindex[N]])) // Leave the channel after OPT_LINGER counts // of the channel being idle, or when someone // else asks for the channel leave_channel = 1; if (m_arvalid[N] && !rrequest[N][mrindex[N]]) // Need to leave this channel to connect // to any other channel leave_channel = 1; if (read_qos_lockout[N]) leave_channel = 1; end // }}} // READ GRANT ALLOCATION // {{{",
            "initial rgrant[N] = 0;",
            "initial mrgrant[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin rgrant[N] <= 0; mrgrant[N] <= 0; end else if (!stay_on_channel) begin if (requested_channel_is_available) begin // Switching channels mrgrant[N] <= 1'b1; rgrant[N] <= rrequest[N][NS:0]; end else if (leave_channel) begin mrgrant[N] <= 1'b0; rgrant[N] <= 0; end end // }}} // mrindex (",
            "reg istered) // {{{",
            "always @(rrequest[N]) begin requested_index = 0; for(iM=0; iM<=NS; iM=iM+1) if (rrequest[N][iM]) requested_index = requested_index|iM[LGNS-1:0]; end",
            "initial r_mrindex = 0;",
            "always @(posedge S_AXI_ACLK) if (!stay_on_channel && requested_channel_is_available) r_mrindex <= requested_index;",
            "assign mrindex[N] = r_mrindex; // }}} end for (N=NM; N<NMFULL; N=N+1) begin",
            "assign mrindex[N] = 0; // }}} end endgenerate // Calculate swindex (",
            "reg istered) generate for (M=0; M<NS; M=M+1) begin : W4_SLAVE_WRITE_INDEX // {{{ // swindex is a per slave index, containing the index of the // master that has currently won write arbitration and so // has permission to access this slave if (NM <= 1) begin : SINGLE_MASTER // If there's only ever one master, that index is // always the index of the one master.",
            "assign swindex[M] = 0; end else begin : MULTIPLE_MASTERS",
            "reg [LGNM-1:0] reqwindex, r_swindex; // In the case of multiple masters, we follow the",
            "logic // of the arbiter to generate the appropriate index // here, and",
            "reg ister it on the next clock cycle. If // no slave has arbitration, the index will remain zero",
            "always @(*) begin reqwindex = 0; for(iN=0; iN<NM; iN=iN+1) if ((!mwgrant[iN] || mwempty[iN]) &&(wrequest[iN][M] && !wrequested[iN][M])) reqwindex = reqwindex | iN[LGNM-1:0]; end",
            "always @(posedge S_AXI_ACLK) if (!swgrant[M]) r_swindex <= reqwindex;",
            "assign swindex[M] = r_swindex; end end for (M=NS; M<NSFULL; M=M+1) begin : W4_UNUSED_MASTERS",
            "assign swindex[M] = 0; // }}} end endgenerate // Calculate srindex (",
            "reg istered) generate for (M=0; M<NS; M=M+1) begin : R4_SLAVE_READ_INDEX // {{{ // srindex is an index to the master that has currently won // read arbitration to the given slave. if (NM <= 1) begin : SINGLE_MASTER // If there's only one master, srindex can",
            "always // point to that master--no longic required",
            "assign srindex[M] = 0; end else begin : MULTIPLE_MASTERS",
            "reg [LGNM-1:0] reqrindex, r_srindex; // In the case of multiple masters, we'll follow the // read arbitration",
            "logic to generate the index--first // combinatorially, then we'll",
            "reg ister it.",
            "always @(*) begin reqrindex = 0; for(iN=0; iN<NM; iN=iN+1) if ((!mrgrant[iN] || mrempty[iN]) &&(rrequest[iN][M] && !rrequested[iN][M])) reqrindex = reqrindex | iN[LGNM-1:0]; end",
            "always @(posedge S_AXI_ACLK) if (!srgrant[M]) r_srindex <= reqrindex;",
            "assign srindex[M] = r_srindex; end end for (M=NS; M<NSFULL; M=M+1) begin : R4_UNUSED_MASTERS",
            "assign srindex[M] = 0; // }}} end endgenerate // swgrant and srgrant (combinatorial) generate for(M=0; M<NS; M=M+1) begin : SGRANT // {{{ // s?grant is a convenience to tell a slave that some master // has won arbitration and so has a grant to that slave. // swgrant: write arbitration",
            "initial swgrant = 0;",
            "always @(*) begin swgrant[M] = 0; for(iN=0; iN<NM; iN=iN+1) if (wgrant[iN][M]) swgrant[M] = 1; end",
            "initial srgrant = 0; // srgrant: read arbitration",
            "always @(*) begin srgrant[M] = 0; for(iN=0; iN<NM; iN=iN+1) if (rgrant[iN][M]) srgrant[M] = 1; end // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Generate the signals for the various slaves--the forward channel // {{{ //////////////////////////////////////////////////////////////////////// // // Assign",
            "output s to the various slaves generate for(M=0; M<NS; M=M+1) begin : W5_WRITE_SLAVE_OUTPUTS // {{{",
            "reg axi_awvalid;",
            "reg [IW-1:0] axi_awid;",
            "reg [AW-1:0] axi_awaddr;",
            "reg [7:0] axi_awlen;",
            "reg [2:0] axi_awsize;",
            "reg [1:0] axi_awburst;",
            "reg axi_awlock;",
            "reg [3:0] axi_awcache;",
            "reg [2:0] axi_awprot;",
            "reg [3:0] axi_awqos;",
            "reg axi_wvalid;",
            "reg [DW-1:0] axi_wdata;",
            "reg [DW/8-1:0] axi_wstrb;",
            "reg axi_wlast; // reg axi_bready;",
            "reg sawstall, swstall;",
            "reg awaccepts; // Control the slave's AW* channel // {{{ // Personalize the slave_awaccepts signal",
            "always @(*) awaccepts = slave_awaccepts[swindex[M]];",
            "always @(*) sawstall= (M_AXI_AWVALID[M]&& !M_AXI_AWREADY[M]);",
            "initial axi_awvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !swgrant[M]) axi_awvalid <= 0; else if (!sawstall) begin axi_awvalid <= m_awvalid[swindex[M]] &&(awaccepts); end",
            "initial axi_awid = 0;",
            "initial axi_awaddr = 0;",
            "initial axi_awlen = 0;",
            "initial axi_awsize = 0;",
            "initial axi_awburst = 0;",
            "initial axi_awlock = 0;",
            "initial axi_awcache = 0;",
            "initial axi_awprot = 0;",
            "initial axi_awqos = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && (!S_AXI_ARESETN || !swgrant[M])) begin // Under the OPT_LOWPOWER option, we clear all signals // we aren't using axi_awid <= 0; axi_awaddr <= 0; axi_awlen <= 0; axi_awsize <= 0; axi_awburst <= 0; axi_awlock <= 0; axi_awcache <= 0; axi_awprot <= 0; axi_awqos <= 0; end else if (!sawstall) begin if (!OPT_LOWPOWER||(m_awvalid[swindex[M]]&&awaccepts)) begin // swindex[M] is defined as 0 above in the // case where NM <= 1 axi_awid <= m_awid[ swindex[M]]; axi_awaddr <= m_awaddr[ swindex[M]]; axi_awlen <= m_awlen[ swindex[M]]; axi_awsize <= m_awsize[ swindex[M]]; axi_awburst <= m_awburst[swindex[M]]; axi_awlock <= m_awlock[ swindex[M]]; axi_awcache <= m_awcache[swindex[M]]; axi_awprot <= m_awprot[ swindex[M]]; axi_awqos <= m_awqos[ swindex[M]]; end else begin axi_awid <= 0; axi_awaddr <= 0; axi_awlen <= 0; axi_awsize <= 0; axi_awburst <= 0; axi_awlock <= 0; axi_awcache <= 0; axi_awprot <= 0; axi_awqos <= 0; end end // }}} // Control the slave's W* channel // {{{",
            "always @(*) swstall = (M_AXI_WVALID[M] && !M_AXI_WREADY[M]);",
            "initial axi_wvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !swgrant[M]) axi_wvalid <= 0; else if (!swstall) begin axi_wvalid <= (m_wvalid[swindex[M]]) &&(slave_waccepts[swindex[M]]); end",
            "initial axi_wdata = 0;",
            "initial axi_wstrb = 0;",
            "initial axi_wlast = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && !S_AXI_ARESETN) begin axi_wdata <= 0; axi_wstrb <= 0; axi_wlast <= 0; end else if (OPT_LOWPOWER && !swgrant[M]) begin axi_wdata <= 0; axi_wstrb <= 0; axi_wlast <= 0; end else if (!swstall) begin if (!OPT_LOWPOWER || (m_wvalid[swindex[M]]&&slave_waccepts[swindex[M]])) begin // If NM <= 1, swindex[M] is already defined // to be zero above axi_wdata <= m_wdata[swindex[M]]; axi_wstrb <= m_wstrb[swindex[M]]; axi_wlast <= m_wlast[swindex[M]]; end else begin axi_wdata <= 0; axi_wstrb <= 0; axi_wlast <= 0; end end // }}} // always @(*) if (!swgrant[M]) axi_bready = 1; else axi_bready = bskd_ready[swindex[M]]; // Combinatorial",
            "assign s // {{{",
            "assign M_AXI_AWVALID[M] = axi_awvalid;",
            "assign M_AXI_AWID[ M*IW +: IW] = axi_awid;",
            "assign M_AXI_AWADDR[ M*AW +: AW] = axi_awaddr;",
            "assign M_AXI_AWLEN[ M* 8 +: 8] = axi_awlen;",
            "assign M_AXI_AWSIZE[ M* 3 +: 3] = axi_awsize;",
            "assign M_AXI_AWBURST[M* 2 +: 2] = axi_awburst;",
            "assign M_AXI_AWLOCK[ M] = axi_awlock;",
            "assign M_AXI_AWCACHE[M* 4 +: 4] = axi_awcache;",
            "assign M_AXI_AWPROT[ M* 3 +: 3] = axi_awprot;",
            "assign M_AXI_AWQOS[ M* 4 +: 4] = axi_awqos; // // assign M_AXI_WVALID[M] = axi_wvalid;",
            "assign M_AXI_WDATA[M*DW +: DW] = axi_wdata;",
            "assign M_AXI_WSTRB[M*DW/8 +: DW/8] = axi_wstrb;",
            "assign M_AXI_WLAST[M] = axi_wlast; // // assign M_AXI_BREADY[M] = axi_bready; // }}} // // }}} end endgenerate generate for(M=0; M<NS; M=M+1) begin : R5_READ_SLAVE_OUTPUTS // {{{",
            "reg axi_arvalid;",
            "reg [IW-1:0] axi_arid;",
            "reg [AW-1:0] axi_araddr;",
            "reg [7:0] axi_arlen;",
            "reg [2:0] axi_arsize;",
            "reg [1:0] axi_arburst;",
            "reg axi_arlock;",
            "reg [3:0] axi_arcache;",
            "reg [2:0] axi_arprot;",
            "reg [3:0] axi_arqos; // reg axi_rready;",
            "reg arstall;",
            "always @(*) arstall= axi_arvalid && !M_AXI_ARREADY[M];",
            "initial axi_arvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN || !srgrant[M]) axi_arvalid <= 0; else if (!arstall) axi_arvalid <= m_arvalid[srindex[M]] && slave_raccepts[srindex[M]]; else if (M_AXI_ARREADY[M]) axi_arvalid <= 0;",
            "initial axi_arid = 0;",
            "initial axi_araddr = 0;",
            "initial axi_arlen = 0;",
            "initial axi_arsize = 0;",
            "initial axi_arburst = 0;",
            "initial axi_arlock = 0;",
            "initial axi_arcache = 0;",
            "initial axi_arprot = 0;",
            "initial axi_arqos = 0;",
            "always @(posedge S_AXI_ACLK) if (OPT_LOWPOWER && (!S_AXI_ARESETN || !srgrant[M])) begin axi_arid <= 0; axi_araddr <= 0; axi_arlen <= 0; axi_arsize <= 0; axi_arburst <= 0; axi_arlock <= 0; axi_arcache <= 0; axi_arprot <= 0; axi_arqos <= 0; end else if (!arstall) begin if (!OPT_LOWPOWER || (m_arvalid[srindex[M]] && slave_raccepts[srindex[M]])) begin // If NM <=1, srindex[M] is defined to be zero axi_arid <= m_arid[ srindex[M]]; axi_araddr <= m_araddr[ srindex[M]]; axi_arlen <= m_arlen[ srindex[M]]; axi_arsize <= m_arsize[ srindex[M]]; axi_arburst <= m_arburst[srindex[M]]; axi_arlock <= m_arlock[ srindex[M]]; axi_arcache <= m_arcache[srindex[M]]; axi_arprot <= m_arprot[ srindex[M]]; axi_arqos <= m_arqos[ srindex[M]]; end else begin axi_arid <= 0; axi_araddr <= 0; axi_arlen <= 0; axi_arsize <= 0; axi_arburst <= 0; axi_arlock <= 0; axi_arcache <= 0; axi_arprot <= 0; axi_arqos <= 0; end end",
            "always @(*) if (!srgrant[M]) axi_rready = 1; else axi_rready = rskd_ready[srindex[M]]; // assign M_AXI_ARVALID[M] = axi_arvalid;",
            "assign M_AXI_ARID[ M*IW +: IW] = axi_arid;",
            "assign M_AXI_ARADDR[ M*AW +: AW] = axi_araddr;",
            "assign M_AXI_ARLEN[ M* 8 +: 8] = axi_arlen;",
            "assign M_AXI_ARSIZE[ M* 3 +: 3] = axi_arsize;",
            "assign M_AXI_ARBURST[M* 2 +: 2] = axi_arburst;",
            "assign M_AXI_ARLOCK[ M] = axi_arlock;",
            "assign M_AXI_ARCACHE[M* 4 +: 4] = axi_arcache;",
            "assign M_AXI_ARPROT[ M* 3 +: 3] = axi_arprot;",
            "assign M_AXI_ARQOS[ M* 4 +: 4] = axi_arqos; // assign M_AXI_RREADY[M] = axi_rready; // // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Generate the signals for the various masters--the return channel // {{{ //////////////////////////////////////////////////////////////////////// // // Return values generate for (N=0; N<NM; N=N+1) begin : W6_WRITE_RETURN_CHANNEL // {{{",
            "reg [1:0] i_axi_bresp;",
            "reg [IW-1:0] i_axi_bid; // Write error (no slave selected) state machine // {{{",
            "initial berr_valid[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) berr_valid[N] <= 0; else if (wgrant[N][NS] && m_wvalid[N] && m_wlast[N] && slave_waccepts[N]) berr_valid[N] <= 1; else if (bskd_ready[N]) berr_valid[N] <= 0;",
            "always @(*) if (berr_valid[N]) bskd_valid[N] = 1; else bskd_valid[N] = mwgrant[N]&&m_axi_bvalid[mwindex[N]];",
            "always @(posedge S_AXI_ACLK) if (m_awvalid[N] && slave_awaccepts[N]) berr_id[N] <= m_awid[N];",
            "always @(*) if (wgrant[N][NS]) begin i_axi_bid = berr_id[N]; i_axi_bresp = INTERCONNECT_ERROR; end else begin i_axi_bid = m_axi_bid[mwindex[N]]; i_axi_bresp = m_axi_bresp[mwindex[N]]; end // }}} // bskid, the B* channel skidbuffer // {{{ skidbuffer #( // {{{ .DW(IW+2), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_OUTREG(1) // }}} ) bskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, bskd_valid[N], bskd_ready[N], { i_axi_bid, i_axi_bresp }, S_AXI_BVALID[N], S_AXI_BREADY[N], { S_AXI_BID[N*IW +: IW], S_AXI_BRESP[N*2 +: 2] } // }}} ); // }}} // }}} end endgenerate // Return values generate for (N=0; N<NM; N=N+1) begin : R6_READ_RETURN_CHANNEL // {{{",
            "reg [DW-1:0] i_axi_rdata;",
            "reg [IW-1:0] i_axi_rid;",
            "reg [2-1:0] i_axi_rresp; // generate the read response // {{{ // Here we have two choices. We can either generate our // response from the slave itself, or from our internally // generated (no-slave exists) FSM.",
            "always @(*) if (rgrant[N][NS]) rskd_valid[N] = !rerr_none[N]; else rskd_valid[N] = mrgrant[N] && m_axi_rvalid[mrindex[N]];",
            "always @(*) if (rgrant[N][NS]) begin i_axi_rid = rerr_id[N]; i_axi_rdata = 0; rskd_rlast[N] = rerr_last[N]; i_axi_rresp = INTERCONNECT_ERROR; end else begin i_axi_rid = m_axi_rid[mrindex[N]]; i_axi_rdata = m_axi_rdata[mrindex[N]]; rskd_rlast[N]= m_axi_rlast[mrindex[N]]; i_axi_rresp = m_axi_rresp[mrindex[N]]; end // }}} // rskid, the outgoing read skidbuffer // {{{ // Since our various read signals are all combinatorially // determined, we'll throw them into an outgoing skid buffer // to",
            "reg ister them (per spec) and to make it easier to meet // timing. skidbuffer #( // {{{ .DW(IW+DW+1+2), .OPT_LOWPOWER(OPT_LOWPOWER), .OPT_OUTREG(1) // }}} ) rskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, rskd_valid[N], rskd_ready[N], { i_axi_rid, i_axi_rdata, rskd_rlast[N], i_axi_rresp }, S_AXI_RVALID[N], S_AXI_RREADY[N], { S_AXI_RID[N*IW +: IW], S_AXI_RDATA[N*DW +: DW], S_AXI_RLAST[N], S_AXI_RRESP[N*2 +: 2] } // }}} ); // }}} // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Count pending transactions // {{{ //////////////////////////////////////////////////////////////////////// // // generate for (N=0; N<NM; N=N+1) begin : W7_COUNT_PENDING_WRITES // {{{",
            "reg [LGMAXBURST-1:0] awpending, wpending;",
            "reg r_wdata_expected; // awpending, and the associated flags mwempty and mwfull // {{{ // awpending is a count of all of the AW* packets that have // been forwarded to the slave, but for which the slave has // yet to return a B* response. This number can be as large // as (1<<LGMAXBURST)-1. The two associated flags, mwempty // and mwfull, are there to keep us from checking awempty==0 // and &awempty respectively.",
            "initial awpending = 0;",
            "initial mwempty[N] = 1;",
            "initial mwfull[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin awpending <= 0; mwempty[N] <= 1; mwfull[N] <= 0; end else case ({(m_awvalid[N] && slave_awaccepts[N]), (bskd_valid[N] && bskd_ready[N])}) 2'b01: begin awpending <= awpending - 1; mwempty[N] <= (awpending <= 1); mwfull[N] <= 0; end 2'b10: begin awpending <= awpending + 1; mwempty[N] <= 0; mwfull[N] <= &awpending[LGMAXBURST-1:1]; end default: begin end endcase // Just so we can access this counter elsewhere, let's make // it available outside of this generate block. (The formal // section uses this.)",
            "assign w_mawpending[N] = awpending; // }}} // r_wdata_expected and wdata_expected // {{{ // This section keeps track of whether or not we are expecting // more W* data from the given burst. It's designed to keep us // from accepting new W* information before the AW* portion // has been routed to the new slave. // // Addition: wpending. wpending counts the number of write // bursts that are pending, based upon the write channel. // Bursts are counted from AWVALID & AWREADY, and decremented // once we see the WVALID && WREADY signal. Packets should // not be accepted without a prior (or concurrent) // AWVALID && AWREADY.",
            "initial r_wdata_expected = 0;",
            "initial wpending = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin r_wdata_expected <= 0; wpending <= 0; end else case ({(m_awvalid[N] && slave_awaccepts[N]), (m_wvalid[N]&&slave_waccepts[N] && m_wlast[N])}) 2'b01: begin r_wdata_expected <= (wpending > 1); wpending <= wpending - 1; end 2'b10: begin wpending <= wpending + 1; r_wdata_expected <= 1; end default: begin end endcase",
            "assign wdata_expected[N] = r_wdata_expected;",
            "assign wlasts_pending[N] = wpending; // }}} // }}} end endgenerate generate for (N=0; N<NM; N=N+1) begin : R7_COUNT_PENDING_READS // {{{",
            "reg [LGMAXBURST-1:0] rpending; // rpending, and its associated mrempty and mrfull // {{{ // rpending counts the number of read transactions that have // been accepted, but for which rlast has yet to be returned. // This specifically counts grants to valid slaves. The error // slave is excluded from this count. mrempty and mrfull have // analogous definitions to mwempty and mwfull, being equal to // rpending == 0 and (&rpending) respectfully.",
            "initial rpending = 0;",
            "initial mrempty[N] = 1;",
            "initial mrfull[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin rpending <= 0; mrempty[N]<= 1; mrfull[N] <= 0; end else case ({(m_arvalid[N] && slave_raccepts[N] && !rgrant[N][NS]), (rskd_valid[N] && rskd_ready[N] && rskd_rlast[N] && !rgrant[N][NS])}) 2'b01: begin rpending <= rpending - 1; mrempty[N] <= (rpending == 1); mrfull[N] <= 0; end 2'b10: begin rpending <= rpending + 1; mrfull[N] <= &rpending[LGMAXBURST-1:1]; mrempty[N] <= 0; end default: begin end endcase",
            "assign w_mrpending[N] = rpending; // }}} // Read error state machine, rerr_outstanding and rerr_id // {{{ // rerr_outstanding is the count of read *beats* that remain // to be returned to a master from a non-existent slave. // rerr_last is true on the last of these read beats, // equivalent to rerr_outstanding == 1, and rerr_none is true // when the error state machine is idle",
            "initial rerr_outstanding[N] = 0;",
            "initial rerr_last[N] = 0;",
            "initial rerr_none[N] = 1;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) begin rerr_outstanding[N] <= 0; rerr_last[N] <= 0; rerr_none[N] <= 1; end else if (!rerr_none[N]) begin if (!rskd_valid[N] || rskd_ready[N]) begin rerr_none[N] <= (rerr_outstanding[N] == 1); rerr_last[N] <= (rerr_outstanding[N] == 2); rerr_outstanding[N] <= rerr_outstanding[N] - 1; end end else if (m_arvalid[N] && rrequest[N][NS] && slave_raccepts[N]) begin rerr_none[N] <= 0; rerr_last[N] <= (m_arlen[N] == 0); rerr_outstanding[N] <= m_arlen[N] + 1; end // rerr_id is the ARID field of the currently outstanding // error. It's used when generating a read response to a // non-existent slave.",
            "initial rerr_id[N] = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN && OPT_LOWPOWER) rerr_id[N] <= 0; else if (m_arvalid[N] && slave_raccepts[N]) begin if (rrequest[N][NS] || !OPT_LOWPOWER) // A low-",
            "logic definition rerr_id[N] <= m_arid[N]; else rerr_id[N] <= 0; end else if (OPT_LOWPOWER && rerr_last[N] && (!rskd_valid[N] || rskd_ready[N])) rerr_id[N] <= 0; // }}} `ifdef FORMAL",
            "always @(*) assert(rerr_none[N] == (rerr_outstanding[N] == 0));",
            "always @(*) assert(rerr_last[N] == (rerr_outstanding[N] == 1));",
            "always @(*) if (OPT_LOWPOWER && rerr_none[N]) assert(rerr_id[N] == 0); `endif // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // (Partial) Parameter validation // {{{ //////////////////////////////////////////////////////////////////////// // // initial begin if (NM == 0) begin $display(\"At least one master must be defined\"); $stop; end if (NS == 0) begin $display(\"At least one slave must be defined\"); $stop; end end // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal property verification section // {{{ //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "localparam F_LGDEPTH = LGMAXBURST+9; //////////////////////////////////////////////////////////////////////// // // Declare signals used for formal checking // {{{ //////////////////////////////////////////////////////////////////////// // // // // ... // // }}} //////////////////////////////////////////////////////////////////////// // // Initial/reset value checking // {{{",
            "initial assert(NS >= 1);",
            "initial assert(NM >= 1); // }}} //////////////////////////////////////////////////////////////////////// // // Check the arbiter signals for consistency // {{{ generate for(N=0; N<NM; N=N+1) begin : F1_CHECK_MASTER_GRANTS // {{{ // Write grants",
            "always @(*) for(iM=0; iM<=NS; iM=iM+1) begin if (wgrant[N][iM]) begin assert((wgrant[N] ^ (1<<iM))==0); assert(mwgrant[N]); assert(mwindex[N] == iM); if (iM < NS) begin assert(swgrant[iM]); assert(swindex[iM] == N); end end end",
            "always @(*) if (mwgrant[N]) assert(wgrant[N] != 0);",
            "always @(*) if (wrequest[N][NS]) assert(wrequest[N][NS-1:0] == 0);",
            "always @(posedge S_AXI_ACLK) if (S_AXI_ARESETN && f_past_valid && bskd_valid[N]) begin assert($stable(wgrant[N])); assert($stable(mwindex[N])); end //////////////////////////////////////////////////////////////// // // Read grant checking // always @(*) for(iM=0; iM<=NS; iM=iM+1) begin if (rgrant[N][iM]) begin assert((rgrant[N] ^ (1<<iM))==0); assert(mrgrant[N]); assert(mrindex[N] == iM); if (iM < NS) begin assert(srgrant[iM]); assert(srindex[iM] == N); end end end",
            "always @(*) if (mrgrant[N]) assert(rgrant[N] != 0);",
            "always @(posedge S_AXI_ACLK) if (S_AXI_ARESETN && f_past_valid && S_AXI_RVALID[N]) begin assert($stable(rgrant[N])); assert($stable(mrindex[N])); if (!rgrant[N][NS]) assert(!mrempty[N]); end // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // AXI signaling check, (incoming) master side // {{{ //////////////////////////////////////////////////////////////////////// // generate for(N=0; N<NM; N=N+1) begin : F2_CHECK_MASTERS // {{{ faxi_slave #( .C_AXI_ID_WIDTH(IW), .C_AXI_DATA_WIDTH(DW), .C_AXI_ADDR_WIDTH(AW), .F_OPT_ASSUME_RESET(1'b1), .F_AXI_MAXSTALL(0), .F_AXI_MAXRSTALL(2), .F_AXI_MAXDELAY(0), .F_OPT_READCHECK(0), .F_OPT_NO_RESET(1), .F_LGDEPTH(F_LGDEPTH)) mstri(.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // .i_axi_awid( S_AXI_AWID[ N*IW +:IW]), .i_axi_awaddr( S_AXI_AWADDR[ N*AW +:AW]), .i_axi_awlen( S_AXI_AWLEN[ N* 8 +: 8]), .i_axi_awsize( S_AXI_AWSIZE[ N* 3 +: 3]), .i_axi_awburst(S_AXI_AWBURST[N* 2 +: 2]), .i_axi_awlock( S_AXI_AWLOCK[ N]), .i_axi_awcache(S_AXI_AWCACHE[N* 4 +: 4]), .i_axi_awprot( S_AXI_AWPROT[ N* 3 +: 3]), .i_axi_awqos( S_AXI_AWQOS[ N* 4 +: 4]), .i_axi_awvalid(S_AXI_AWVALID[N]), .i_axi_awready(S_AXI_AWREADY[N]), // .i_axi_wdata( S_AXI_WDATA[ N*DW +: DW]), .i_axi_wstrb( S_AXI_WSTRB[ N*DW/8 +: DW/8]), .i_axi_wlast( S_AXI_WLAST[ N]), .i_axi_wvalid(S_AXI_WVALID[N]), .i_axi_wready(S_AXI_WREADY[N]), // .i_axi_bid( S_AXI_BID[ N*IW +:IW]), .i_axi_bresp( S_AXI_BRESP[ N*2 +: 2]), .i_axi_bvalid(S_AXI_BVALID[N]), .i_axi_bready(S_AXI_BREADY[N]), // .i_axi_arid( S_AXI_ARID[ N*IW +:IW]), .i_axi_arready(S_AXI_ARREADY[N]), .i_axi_araddr( S_AXI_ARADDR[ N*AW +:AW]), .i_axi_arlen( S_AXI_ARLEN[ N* 8 +: 8]), .i_axi_arsize( S_AXI_ARSIZE[ N* 3 +: 3]), .i_axi_arburst(S_AXI_ARBURST[N* 2 +: 2]), .i_axi_arlock( S_AXI_ARLOCK[ N]), .i_axi_arcache(S_AXI_ARCACHE[N* 4 +: 4]), .i_axi_arprot( S_AXI_ARPROT[ N* 3 +: 3]), .i_axi_arqos( S_AXI_ARQOS[ N* 4 +: 4]), .i_axi_arvalid(S_AXI_ARVALID[N]), // // .i_axi_rid( S_AXI_RID[ N*IW +: IW]), .i_axi_rdata( S_AXI_RDATA[ N*DW +: DW]), .i_axi_rresp( S_AXI_RRESP[ N* 2 +: 2]), .i_axi_rlast( S_AXI_RLAST[ N]), .i_axi_rvalid(S_AXI_RVALID[N]), .i_axi_rready(S_AXI_RREADY[N]), // // ... // ); // // ... // // // Check full/empty flags // always @(*) begin assert(mwfull[N] == &w_mawpending[N]); assert(mwempty[N] == (w_mawpending[N] == 0)); end",
            "always @(*) begin assert(mrfull[N] == &w_mrpending[N]); assert(mrempty[N] == (w_mrpending[N] == 0)); end // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // AXI signaling check, (outgoing) slave side // {{{ //////////////////////////////////////////////////////////////////////// // generate for(M=0; M<NS; M=M+1) begin : F3_CHECK_SLAVES // {{{ faxi_master #( .C_AXI_ID_WIDTH(IW), .C_AXI_DATA_WIDTH(DW), .C_AXI_ADDR_WIDTH(AW), .F_OPT_ASSUME_RESET(1'b1), .F_AXI_MAXSTALL(2), .F_AXI_MAXRSTALL(0), .F_AXI_MAXDELAY(2), .F_OPT_READCHECK(0), .F_OPT_NO_RESET(1), .F_LGDEPTH(F_LGDEPTH)) slvi(.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // .i_axi_awid( M_AXI_AWID[ M*IW+:IW]), .i_axi_awaddr( M_AXI_AWADDR[ M*AW +: AW]), .i_axi_awlen( M_AXI_AWLEN[ M*8 +: 8]), .i_axi_awsize( M_AXI_AWSIZE[ M*3 +: 3]), .i_axi_awburst(M_AXI_AWBURST[M*2 +: 2]), .i_axi_awlock( M_AXI_AWLOCK[ M]), .i_axi_awcache(M_AXI_AWCACHE[M*4 +: 4]), .i_axi_awprot( M_AXI_AWPROT[ M*3 +: 3]), .i_axi_awqos( M_AXI_AWQOS[ M*4 +: 4]), .i_axi_awvalid(M_AXI_AWVALID[M]), .i_axi_awready(M_AXI_AWREADY[M]), // .i_axi_wready(M_AXI_WREADY[M]), .i_axi_wdata( M_AXI_WDATA[ M*DW +: DW]), .i_axi_wstrb( M_AXI_WSTRB[ M*DW/8 +: DW/8]), .i_axi_wlast( M_AXI_WLAST[ M]), .i_axi_wvalid(M_AXI_WVALID[M]), // .i_axi_bid( M_AXI_BID[ M*IW +: IW]), .i_axi_bresp( M_AXI_BRESP[ M*2 +: 2]), .i_axi_bvalid(M_AXI_BVALID[M]), .i_axi_bready(M_AXI_BREADY[M]), // .i_axi_arid( M_AXI_ARID[ M*IW +:IW]), .i_axi_araddr( M_AXI_ARADDR[ M*AW +:AW]), .i_axi_arlen( M_AXI_ARLEN[ M*8 +: 8]), .i_axi_arsize( M_AXI_ARSIZE[ M*3 +: 3]), .i_axi_arburst(M_AXI_ARBURST[M*2 +: 2]), .i_axi_arlock( M_AXI_ARLOCK[ M]), .i_axi_arcache(M_AXI_ARCACHE[M* 4 +: 4]), .i_axi_arprot( M_AXI_ARPROT[ M* 3 +: 3]), .i_axi_arqos( M_AXI_ARQOS[ M* 4 +: 4]), .i_axi_arvalid(M_AXI_ARVALID[M]), .i_axi_arready(M_AXI_ARREADY[M]), // // .i_axi_rresp( M_AXI_RRESP[ M*2 +: 2]), .i_axi_rvalid(M_AXI_RVALID[M]), .i_axi_rdata( M_AXI_RDATA[ M*DW +: DW]), .i_axi_rready(M_AXI_RREADY[M]), .i_axi_rlast( M_AXI_RLAST[ M]), .i_axi_rid( M_AXI_RID[ M*IW +: IW]), // // ... // ); // // ... // always @(*) if (M_AXI_AWVALID[M]) assert(((M_AXI_AWADDR[M*AW +:AW]^SLAVE_ADDR[M*AW +:AW]) & SLAVE_MASK[M*AW +: AW]) == 0);",
            "always @(*) if (M_AXI_ARVALID[M]) assert(((M_AXI_ARADDR[M*AW +:AW]^SLAVE_ADDR[M*AW +:AW]) & SLAVE_MASK[M*AW +: AW]) == 0); // }}} end endgenerate // }}} // m_axi_* convenience signals // {{{ // ... // }}} //////////////////////////////////////////////////////////////////////// // // ... // {{{ //////////////////////////////////////////////////////////////////////// // generate for(N=0; N<NM; N=N+1) begin : // ... // {{{ // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Double buffer checks // {{{ //////////////////////////////////////////////////////////////////////// // // generate for(N=0; N<NM; N=N+1) begin : F4_DOUBLE_BUFFER_CHECKS // {{{ // ... // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Cover properties // {{{ //////////////////////////////////////////////////////////////////////// // // Can every master reach every slave? // Can things transition without dropping the request line(s)? generate for(N=0; N<NM; N=N+1) begin : F5_COVER_CONNECTIVITY_FROM_MASTER // {{{ // ... // }}} end endgenerate //////////////////////////////////////////////////////////////////////// // // Focused check: How fast can one master talk to each of the slaves? // {{{ //////////////////////////////////////////////////////////////////////// // // // ... // }}} //////////////////////////////////////////////////////////////////////// // // Focused check: How fast can one master talk to a particular slave? // We'll pick master 1 and slave 1. // {{{ //////////////////////////////////////////////////////////////////////// // // // ... // }}} //////////////////////////////////////////////////////////////////////// // // Poor man's cover check // {{{ // ... // }}} // }}} //////////////////////////////////////////////////////////////////////// // // Negation check // {{{ // Pick a particular value. Assume the value doesn't show up on the // input . Prove it doesn't show up on the",
            "output . This will check for // ... // 1. Stuck bits on the",
            "output channel // 2. Cross-talk between channels // //////////////////////////////////////////////////////////////////////// // // // ... // }}} //////////////////////////////////////////////////////////////////////// // // Artificially constraining assumptions // {{{ // Ideally, this section should be empty--there should be no // assumptions here. The existence of these assumptions should // give you an idea of where I'm at with this project. // //////////////////////////////////////////////////////////////////////// // // generate for(N=0; N<NM; N=N+1) begin : F6_LIMITING_ASSUMPTIONS if (!OPT_WRITES) begin",
            "always @(*) assume(S_AXI_AWVALID[N] == 0);",
            "always @(*) assert(wgrant[N] == 0);",
            "always @(*) assert(mwgrant[N] == 0);",
            "always @(*) assert(S_AXI_BVALID[N]== 0); end if (!OPT_READS) begin",
            "always @(*) assume(S_AXI_ARVALID [N]== 0);",
            "always @(*) assert(rgrant[N] == 0);",
            "always @(*) assert(S_AXI_RVALID[N] == 0); end end endgenerate",
            "always @(*) assert(OPT_READS | OPT_WRITES); // }}} `endif // }}}",
            "endmodule"
        ]
    },
    {
        "file_name": "axi2axilite.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axi2axilite.v",
        "chunks": [
            "//////////////////////////////////////////////////////////////////////////////// // // Filename: sim/rtl/axi2axilite.v // {{{ // Project: Zip CPU -- a small, lightweight, RISC CPU soft core // // Purpose: Convert from AXI to AXI-lite with no performance loss. // // Performance: The goal of this converter is to convert from AXI to AXI-lite // while still maintaining the one-clock per transaction speed // of AXI. It currently achieves this goal. The design needs very little // configuration to be useful, but you might wish to resize the FIFOs // within depending upon the length of your slave's data path. The current // FIFO length, LGFIFO=4, is sufficient to maintain full speed. If the // slave, however, can maintain full speed but requires a longer // processing cycle, then you may need longer FIFOs. // // The AXI specification does require an additional 2 clocks per // transaction when using this core, so your latency will go up. // // Related: There's a related axidouble.v core in the same repository as // well. That can be used to convert the AXI protocol to something // simpler (even simpler than AXI-lite), but it can also do so for multiple // downstream slaves at the same time. // // Creator: Dan Gisselquist, Ph.D. // Gisselquist Technology, LLC // //////////////////////////////////////////////////////////////////////////////// // }}} // Copyright (C) 2019-2024, Gisselquist Technology, LLC // {{{ // This program is free software (firmware): you can redistribute it and/or // modify it under the terms of the GNU General Public License as published // by the Free Software Foundation, either version 3 of the License, or (at // your option) any later version. // // This program is distributed in the hope that it will be useful, but WITHOUT // ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License // for more details. // // You should have received a copy of the GNU General Public License along // with this program. (It's in the $(ROOT)/doc directory. Run make with no // target there if the PDF file isn't present.) If not, see // <http://www.gnu.org/licenses/> for a copy. // }}} // License: GPL, v3, as defined and found on www.gnu.org, // {{{ // http://www.gnu.org/licenses/gpl.html // //////////////////////////////////////////////////////////////////////////////// // // `default_nettype none // }}}",
            "module axi2axilite #( // {{{",
            "parameter integer C_AXI_ID_WIDTH = 2, parameter integer C_AXI_DATA_WIDTH = 32, parameter integer C_AXI_ADDR_WIDTH = 6, parameter [0:0] OPT_WRITES = 1, parameter [0:0] OPT_READS = 1, parameter [0:0] OPT_LOWPOWER = 0, // Log (based two) of the maximum number of outstanding AXI // (not AXI-lite) transactions. If you multiply 2^LGFIFO * 256, // you'll get the maximum number of outstanding AXI-lite // transactions",
            "parameter LGFIFO = 4 // }}} ) ( // {{{",
            "input wire S_AXI_ACLK, input wire S_AXI_ARESETN, // AXI4 slave interface // {{{ // Write address channel // {{{",
            "input wire S_AXI_AWVALID, output wire S_AXI_AWREADY, input wire [C_AXI_ID_WIDTH-1:0] S_AXI_AWID, input wire [C_AXI_ADDR_WIDTH-1:0] S_AXI_AWADDR, input wire [7:0] S_AXI_AWLEN, input wire [2:0] S_AXI_AWSIZE, input wire [1:0] S_AXI_AWBURST, input wire S_AXI_AWLOCK, input wire [3:0] S_AXI_AWCACHE, input wire [2:0] S_AXI_AWPROT, input wire [3:0] S_AXI_AWQOS, // }}} // Write data channel // {{{",
            "input wire S_AXI_WVALID, output wire S_AXI_WREADY, input wire [C_AXI_DATA_WIDTH-1:0] S_AXI_WDATA, input wire [(C_AXI_DATA_WIDTH/8)-1:0] S_AXI_WSTRB, input wire S_AXI_WLAST, // }}} // Write return channel // {{{",
            "output wire S_AXI_BVALID, input wire S_AXI_BREADY, output wire [C_AXI_ID_WIDTH-1:0] S_AXI_BID, output wire [1:0] S_AXI_BRESP, // }}} // Read address channel // {{{",
            "input wire S_AXI_ARVALID, output wire S_AXI_ARREADY, input wire [C_AXI_ID_WIDTH-1:0] S_AXI_ARID, input wire [C_AXI_ADDR_WIDTH-1:0] S_AXI_ARADDR, input wire [7:0] S_AXI_ARLEN, input wire [2:0] S_AXI_ARSIZE, input wire [1:0] S_AXI_ARBURST, input wire S_AXI_ARLOCK, input wire [3:0] S_AXI_ARCACHE, input wire [2:0] S_AXI_ARPROT, input wire [3:0] S_AXI_ARQOS, // }}} // Read data channel // {{{",
            "output wire S_AXI_RVALID, input wire S_AXI_RREADY, output wire [C_AXI_ID_WIDTH-1:0] S_AXI_RID, output wire [C_AXI_DATA_WIDTH-1:0] S_AXI_RDATA, output wire [1:0] S_AXI_RRESP, output wire S_AXI_RLAST, // }}} // }}} // AXI-lite master interface // {{{ // AXI-lite Write interface // {{{",
            "output wire [C_AXI_ADDR_WIDTH-1:0] M_AXI_AWADDR, output wire [2 : 0] M_AXI_AWPROT, output wire M_AXI_AWVALID, input wire M_AXI_AWREADY, output wire [C_AXI_DATA_WIDTH-1:0] M_AXI_WDATA, output wire [(C_AXI_DATA_WIDTH/8)-1:0] M_AXI_WSTRB, output wire M_AXI_WVALID, input wire M_AXI_WREADY, input wire [1 : 0] M_AXI_BRESP, input wire M_AXI_BVALID, output wire M_AXI_BREADY, // }}} // AXI-lite read interface // {{{",
            "output wire [C_AXI_ADDR_WIDTH-1:0] M_AXI_ARADDR, output wire [2:0] M_AXI_ARPROT, output wire M_AXI_ARVALID, input wire M_AXI_ARREADY, // input wire M_AXI_RVALID, output wire M_AXI_RREADY, input wire [C_AXI_DATA_WIDTH-1 : 0] M_AXI_RDATA, input wire [1 : 0] M_AXI_RRESP // }}} // }}} // }}} ); // Local",
            "parameter s, reg ister, and net declarations // {{{",
            "localparam [1:0] SLVERR = 2'b10; // localparam [1:0] OKAY = 2'b00, // EXOKAY = 2'b01, // DECERR = 2'b10;",
            "localparam AW = C_AXI_ADDR_WIDTH;",
            "localparam DW = C_AXI_DATA_WIDTH;",
            "localparam IW = C_AXI_ID_WIDTH; // }}} // Register declarations // {{{ // // Write",
            "reg isters",
            "wire s_axi_wready;",
            "reg [C_AXI_ADDR_WIDTH-1:0] axi_awaddr;",
            "wire [7:0] axi_awlen;",
            "reg [1:0] axi_awburst;",
            "reg [2:0] axi_awsize;",
            "wire [4:0] wfifo_count;",
            "wire wfifo_full;",
            "wire wfifo_empty;",
            "wire [7:0] wfifo_bcount;",
            "wire [IW-1:0] wfifo_bid;",
            "wire [8:0] bcounts;",
            "wire read_from_wrfifo; // // Read",
            "reg ister",
            "wire [4:0] rfifo_count;",
            "wire rfifo_full;",
            "wire rfifo_empty;",
            "wire [7:0] axi_arlen;",
            "wire [IW-1:0] rid; // // S_AXI_AW* skid buffer",
            "wire skids_awvalid, skids_awready;",
            "wire [IW-1:0] skids_awid;",
            "wire [AW-1:0] skids_awaddr;",
            "wire [7:0] skids_awlen;",
            "wire [2:0] skids_awsize;",
            "wire [1:0] skids_awburst; // // S_AXI_W* skid buffer",
            "wire skids_wvalid, skids_wready, skids_wlast;",
            "wire [DW-1:0] skids_wdata;",
            "wire [DW/8-1:0] skids_wstrb; // // S_AXI_B* skid buffer isn't needed // // M_AXI_AW* skid buffer isn't needed // // M_AXI_W* skid buffer",
            "wire skidm_wvalid, skidm_wready;",
            "wire [DW-1:0] skidm_wdata;",
            "wire [DW/8-1:0] skidm_wstrb; // // M_AXI_B* skid buffer",
            "wire skidm_bvalid, skidm_bready;",
            "wire [1:0] skidm_bresp; // // // // S_AXI_AR* skid buffer",
            "wire skids_arvalid, skids_arready;",
            "wire [IW-1:0] skids_arid;",
            "wire [AW-1:0] skids_araddr;",
            "wire [7:0] skids_arlen;",
            "wire [2:0] skids_arsize;",
            "wire [1:0] skids_arburst; // // S_AXI_R* skid buffer isn't needed // // M_AXI_AR* skid buffer isn't needed // M_AXI_R* skid buffer",
            "wire skidm_rvalid, skidm_rready;",
            "wire [DW-1:0] skidm_rdata;",
            "wire [1:0] skidm_rresp; // }}} //////////////////////////////////////////////////////////////////////// // // Write",
            "logic // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_WRITES) begin : IMPLEMENT_WRITES // {{{",
            "reg s_axi_bvalid;",
            "reg [1:0] r_axi_bresp;",
            "wire [1:0] axi_bresp;",
            "reg [C_AXI_ID_WIDTH-1:0] r_axi_bid, r_bid;",
            "wire [C_AXI_ID_WIDTH-1:0] axi_bid, bid;",
            "reg [8:0] r_bcounts;",
            "wire [C_AXI_ADDR_WIDTH-1:0] next_write_addr;",
            "reg [7:0] r_axi_awlen, axi_blen;",
            "reg r_axi_wready;",
            "reg m_axi_awvalid; // The write address channel's skid buffer // {{{ skidbuffer #( // {{{ .DW(IW+AW+8+3+2), .OPT_LOWPOWER(0), .OPT_OUTREG(0) // }}} ) awskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, S_AXI_AWVALID, S_AXI_AWREADY, { S_AXI_AWID, S_AXI_AWADDR, S_AXI_AWLEN, S_AXI_AWSIZE, S_AXI_AWBURST }, skids_awvalid, skids_awready, { skids_awid, skids_awaddr, skids_awlen, skids_awsize, skids_awburst } // }}} ); // }}} // // The write data channel's skid buffer (S_AXI_W*) // {{{ skidbuffer #( // {{{ .DW(DW+DW/8+1), .OPT_LOWPOWER(0), .OPT_OUTREG(0) // }}} ) wskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, S_AXI_WVALID, S_AXI_WREADY, { S_AXI_WDATA, S_AXI_WSTRB, S_AXI_WLAST }, skids_wvalid, skids_wready, { skids_wdata, skids_wstrb, skids_wlast } // }}} ); // }}} // // The downstream AXI-lite write data (M_AXI_W*) skid buffer // {{{ skidbuffer #( // {{{ .DW(DW+DW/8), .OPT_LOWPOWER(0), .OPT_OUTREG(1) // }}} ) mwskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, skidm_wvalid, skidm_wready, { skidm_wdata, skidm_wstrb }, M_AXI_WVALID,M_AXI_WREADY,{ M_AXI_WDATA, M_AXI_WSTRB } // }}} ); // }}} // // The downstream AXI-lite response (M_AXI_B*) skid buffer // {{{ skidbuffer #( // {{{ .DW(2), .OPT_LOWPOWER(0), .OPT_OUTREG(0) // }}} ) bskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, M_AXI_BVALID, M_AXI_BREADY, { M_AXI_BRESP }, skidm_bvalid, skidm_bready, { skidm_bresp } // }}} ); // }}} // m_axi_awvalid // {{{",
            "initial m_axi_awvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) m_axi_awvalid <= 0; else if (skids_awvalid & skids_awready) m_axi_awvalid <= 1; else if (M_AXI_AWREADY && axi_awlen == 0) m_axi_awvalid <= 0;",
            "assign M_AXI_AWVALID = m_axi_awvalid; // }}} // skids_awready // {{{",
            "assign skids_awready = (!M_AXI_AWVALID || ((axi_awlen == 0)&&M_AXI_AWREADY)) && !wfifo_full &&(!s_axi_wready || (skids_wvalid && skids_wlast && skids_wready)); // }}} // Address processing // {{{",
            "always @(posedge S_AXI_ACLK) if (skids_awvalid && skids_awready) begin axi_awaddr <= skids_awaddr; axi_blen <= skids_awlen; axi_awburst<= skids_awburst; axi_awsize <= skids_awsize; end else if (M_AXI_AWVALID && M_AXI_AWREADY) axi_awaddr <= next_write_addr; // }}} // axi_awlen // {{{",
            "initial r_axi_awlen = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_axi_awlen <= 0; else if (skids_awvalid && skids_awready) r_axi_awlen <= skids_awlen; else if (M_AXI_AWVALID && M_AXI_AWREADY && axi_awlen > 0) r_axi_awlen <= r_axi_awlen - 1;",
            "assign axi_awlen = r_axi_awlen; // }}} // axi_addr // {{{ axi_addr #( // {{{ .AW(C_AXI_ADDR_WIDTH), .DW(C_AXI_DATA_WIDTH) // }}} ) calcwraddr( // {{{ axi_awaddr, axi_awsize, axi_awburst, axi_blen, next_write_addr // }}} ); // }}} // s_axi_wready // {{{ // We really don't need to do anything special to the write // channel.",
            "initial r_axi_wready = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_axi_wready <= 0; else if (skids_awvalid && skids_awready) r_axi_wready <= 1; else if (skids_wvalid && skids_wready && skids_wlast) r_axi_wready <= 0;",
            "assign s_axi_wready = r_axi_wready; // }}} // skidm*, and read_from_wrfifo // {{{",
            "assign skidm_wdata = skids_wdata;",
            "assign skidm_wstrb = skids_wstrb;",
            "assign skidm_wvalid = skids_wvalid && s_axi_wready;",
            "assign skids_wready = s_axi_wready && skidm_wready;",
            "assign read_from_wrfifo = (bcounts <= 1)&&(!wfifo_empty) &&(skidm_bvalid && skidm_bready); // }}} // BFIFO // {{{ sfifo #( .BW(C_AXI_ID_WIDTH+8), .LGFLEN(LGFIFO) ) bidlnfifo( S_AXI_ACLK, !S_AXI_ARESETN, skids_awvalid && skids_awready, { skids_awid, skids_awlen }, wfifo_full, wfifo_count, read_from_wrfifo, { wfifo_bid, wfifo_bcount }, wfifo_empty); // }}} // bcounts // {{{ // Return counts",
            "initial r_bcounts = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_bcounts <= 0; else if (read_from_wrfifo) begin r_bcounts <= wfifo_bcount + bcounts; end else if (skidm_bvalid && skidm_bready) r_bcounts <= bcounts - 1;",
            "assign bcounts = r_bcounts; // }}} // bid // {{{",
            "always @(posedge S_AXI_ACLK) if (read_from_wrfifo) r_bid <= wfifo_bid;",
            "assign bid = r_bid;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_BVALID || S_AXI_BREADY) r_axi_bid <= (read_from_wrfifo && bcounts==0) ? wfifo_bid : bid;",
            "assign axi_bid = r_axi_bid; // }}} // s_axi_bvalid // {{{",
            "initial s_axi_bvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) s_axi_bvalid <= 0; else if (skidm_bvalid && skidm_bready) s_axi_bvalid <= (bcounts == 1) ||((bcounts == 0) && (!wfifo_empty) && (wfifo_bcount == 0)); else if (S_AXI_BREADY) s_axi_bvalid <= 0; // }}} // axi_bresp // {{{",
            "initial r_axi_bresp = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_axi_bresp <= 0; else if (S_AXI_BVALID && S_AXI_BREADY) begin if (skidm_bvalid && skidm_bready) r_axi_bresp <= skidm_bresp; else r_axi_bresp <= 0; end else if (skidm_bvalid && skidm_bready) begin // Let SLVERR take priority over DECERR casez({ S_AXI_BRESP, skidm_bresp }) 4'b??0?: r_axi_bresp <= S_AXI_BRESP; 4'b0?1?: r_axi_bresp <= skidm_bresp; 4'b1?10: r_axi_bresp <= SLVERR; 4'b1011: r_axi_bresp <= SLVERR; 4'b1111: r_axi_bresp <= skidm_bresp; endcase end",
            "assign axi_bresp = r_axi_bresp; // /}}} // M_AXI_AW* // {{{",
            "assign M_AXI_AWVALID= m_axi_awvalid;",
            "assign M_AXI_AWADDR = axi_awaddr;",
            "assign M_AXI_AWPROT = 0; // }}} // skidm_bready, S_AXI_B* // {{{",
            "assign skidm_bready = ((bcounts > 0)||(!wfifo_empty))&&(!S_AXI_BVALID | S_AXI_BREADY);",
            "assign S_AXI_BID = axi_bid;",
            "assign S_AXI_BRESP = axi_bresp;",
            "assign S_AXI_BVALID = s_axi_bvalid; // }}} // }}} end else begin : NO_WRITE_SUPPORT // {{{",
            "assign S_AXI_AWREADY = 0;",
            "assign S_AXI_WREADY = 0;",
            "assign S_AXI_BID = 0;",
            "assign S_AXI_BRESP = 2'b11;",
            "assign S_AXI_BVALID = 0;",
            "assign S_AXI_BID = 0; // assign M_AXI_AWVALID = 0;",
            "assign M_AXI_AWADDR = 0;",
            "assign M_AXI_AWPROT = 0; // assign M_AXI_WVALID = 0;",
            "assign M_AXI_WDATA = 0;",
            "assign M_AXI_WSTRB = 0; // assign M_AXI_BREADY = 0;",
            "assign axi_awaddr = 0;",
            "assign axi_awlen = 0; // Verilator lint_off WIDTH",
            "assign axi_awsize = $clog2(C_AXI_DATA_WIDTH/8); // Verilator lint_on WIDTH",
            "assign axi_awburst= 2'b01; // // S_AXI_AW* skid buffer",
            "assign skids_awvalid = 0;",
            "assign skids_awready = 0;",
            "assign skids_awid = 0;",
            "assign skids_awaddr = 0;",
            "assign skids_awlen = 0;",
            "assign skids_awsize = 0;",
            "assign skids_awburst = 0; // // S_AXI_W* skid buffer",
            "assign skids_wvalid = S_AXI_WVALID;",
            "assign skids_wready = S_AXI_WREADY;",
            "assign skids_wdata = S_AXI_WDATA;",
            "assign skids_wstrb = S_AXI_WSTRB;",
            "assign skids_wlast = S_AXI_WLAST; // // S_AXI_B* skid buffer isn't needed // // M_AXI_AW* skid buffer isn't needed // // M_AXI_W* skid buffer",
            "assign skidm_wvalid = M_AXI_WVALID;",
            "assign skidm_wready = M_AXI_WREADY;",
            "assign skidm_wdata = M_AXI_WDATA;",
            "assign skidm_wstrb = M_AXI_WSTRB; // // M_AXI_B* skid buffer",
            "assign skidm_bvalid = M_AXI_BVALID;",
            "assign skidm_bready = M_AXI_BREADY;",
            "assign skidm_bresp = M_AXI_BRESP; // // assign s_axi_wready = 0;",
            "assign axi_awlen = 0;",
            "assign bcounts = 0;",
            "assign wfifo_full = 0;",
            "assign wfifo_empty = 1;",
            "assign wfifo_bid = 0;",
            "assign wfifo_count = 0;",
            "assign wfifo_bcount= 0;",
            "assign read_from_wrfifo = 0; // Make Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused_write_signals;",
            "assign unused_write_signals = &{ 1'b0, S_AXI_AWVALID, S_AXI_AWID, S_AXI_AWADDR, S_AXI_AWLEN, S_AXI_AWSIZE, S_AXI_AWBURST, M_AXI_AWREADY, M_AXI_WREADY, S_AXI_BREADY, M_AXI_BVALID, M_AXI_BREADY, read_from_wrfifo, wfifo_full, bcounts, wfifo_bcount, wfifo_bid, wfifo_empty, skidm_wvalid, skidm_wready, skidm_wdata, skidm_wstrb, s_axi_wready, axi_awaddr, axi_awlen, axi_awsize, axi_awburst, skids_awvalid, skids_awready, skids_awid, skids_awaddr, skids_awlen, skids_awburst, skids_awsize, skids_wvalid, skids_wready, skids_wdata, skids_wstrb, skidm_bvalid, skidm_bready, skidm_bresp }; // Verilator lint_on UNUSED // }}} // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Read",
            "logic // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_READS) begin : IMPLEMENT_READS // {{{",
            "reg m_axi_arvalid;",
            "reg [C_AXI_ID_WIDTH-1:0] s_axi_rid;",
            "wire [C_AXI_ID_WIDTH-1:0] rfifo_rid;",
            "reg [IW-1:0] r_rid;",
            "wire read_from_rdfifo;",
            "reg [C_AXI_DATA_WIDTH-1:0] s_axi_rdata;",
            "reg s_axi_rlast;",
            "reg [C_AXI_ADDR_WIDTH-1:0] axi_araddr;",
            "reg [7:0] r_axi_arlen, axi_rlen;",
            "reg [1:0] axi_arburst;",
            "reg [2:0] axi_arsize;",
            "wire [C_AXI_ADDR_WIDTH-1:0] next_read_addr;",
            "reg s_axi_rvalid;",
            "reg [1:0] s_axi_rresp;",
            "reg [8:0] r_rcounts;",
            "wire [8:0] rcounts;",
            "wire [7:0] rfifo_rcount; // S_AXI_AR* skid buffer // {{{ skidbuffer #( // {{{ .DW(IW+AW+8+3+2), .OPT_LOWPOWER(0), .OPT_OUTREG(0) // }}} ) arskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, S_AXI_ARVALID, S_AXI_ARREADY, { S_AXI_ARID, S_AXI_ARADDR, S_AXI_ARLEN, S_AXI_ARSIZE, S_AXI_ARBURST }, skids_arvalid, skids_arready, { skids_arid, skids_araddr, skids_arlen, skids_arsize, skids_arburst } // }}} ); // }}} // M_AXI_R* skid buffer // {{{ skidbuffer #( // {{{ .DW(DW+2), .OPT_LOWPOWER(0), .OPT_OUTREG(0) // }}} ) rskid( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, M_AXI_RVALID, M_AXI_RREADY,{ M_AXI_RDATA, M_AXI_RRESP }, skidm_rvalid,skidm_rready,{ skidm_rdata, skidm_rresp } // }}} ); // }}} // m_axi_arvalid // {{{",
            "initial m_axi_arvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) m_axi_arvalid <= 0; else if (skids_arvalid && skids_arready) m_axi_arvalid <= 1; else if (M_AXI_ARREADY && axi_arlen == 0) m_axi_arvalid <= 0; // }}} // Read address processing // {{{",
            "always @(posedge S_AXI_ACLK) if (skids_arvalid && skids_arready) begin axi_araddr <= skids_araddr; axi_arburst <= skids_arburst; axi_arsize <= skids_arsize; axi_rlen <= skids_arlen; end else if (M_AXI_ARREADY) begin axi_araddr <= next_read_addr; if (OPT_LOWPOWER && axi_arlen == 0) axi_araddr <= 0; end axi_addr #( // {{{ .AW(C_AXI_ADDR_WIDTH), .DW(C_AXI_DATA_WIDTH) // }}} ) calcrdaddr( // {{{ axi_araddr, axi_arsize, axi_arburst, axi_rlen, next_read_addr // }}} ); // }}} // axi_arlen, Read length processing // {{{",
            "initial r_axi_arlen = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_axi_arlen <= 0; else if (skids_arvalid && skids_arready) r_axi_arlen <= skids_arlen; else if (M_AXI_ARVALID && M_AXI_ARREADY && axi_arlen > 0) r_axi_arlen <= axi_arlen - 1;",
            "assign axi_arlen = r_axi_arlen; // }}}",
            "assign skids_arready = (!M_AXI_ARVALID || ((axi_arlen == 0) && M_AXI_ARREADY)) && !rfifo_full;",
            "assign read_from_rdfifo = skidm_rvalid && skidm_rready && (rcounts <= 1) && !rfifo_empty; // Read ID FIFO // {{{ sfifo #( // {{{ .BW(C_AXI_ID_WIDTH+8), .LGFLEN(LGFIFO) // }}} ) ridlnfifo( // {{{ S_AXI_ACLK, !S_AXI_ARESETN, skids_arvalid && skids_arready, { skids_arid, skids_arlen }, rfifo_full, rfifo_count, read_from_rdfifo, { rfifo_rid, rfifo_rcount }, rfifo_empty // }}} ); // }}}",
            "assign skidm_rready = (!S_AXI_RVALID || S_AXI_RREADY); // s_axi_rvalid // {{{",
            "initial s_axi_rvalid = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) s_axi_rvalid <= 0; else if (skidm_rvalid && skidm_rready) s_axi_rvalid <= 1; else if (S_AXI_RREADY) s_axi_rvalid <= 0; // }}} // s_axi_rresp, s_axi_rdata // {{{",
            "always @(posedge S_AXI_ACLK) if (skidm_rvalid && skidm_rready) begin s_axi_rresp <= skidm_rresp; s_axi_rdata <= skidm_rdata; end else if (S_AXI_RREADY) begin s_axi_rresp <= 0; s_axi_rdata <= 0; end // }}} // rcounts, Return counts // {{{",
            "initial r_rcounts = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) r_rcounts <= 0; else if (read_from_rdfifo) r_rcounts <= rfifo_rcount + rcounts; else if (skidm_rvalid && skidm_rready) r_rcounts <= rcounts - 1;",
            "assign rcounts = r_rcounts; // }}} // rid // {{{",
            "initial r_rid = 0;",
            "always @(posedge S_AXI_ACLK) if (read_from_rdfifo) r_rid <= rfifo_rid;",
            "assign rid = r_rid; // }}} // s_axi_rlast // {{{",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_RVALID || S_AXI_RREADY) begin // if (rcounts == 1) s_axi_rlast <= 1; else if (read_from_rdfifo) s_axi_rlast <= (rfifo_rcount == 0); else s_axi_rlast <= 0; if (rcounts == 1) s_axi_rlast <= 1; end // }}} // s_axi_rid // {{{",
            "initial s_axi_rid = 0;",
            "always @(posedge S_AXI_ACLK) if ((S_AXI_RVALID && S_AXI_RREADY && S_AXI_RLAST) ||(!S_AXI_RVALID && rcounts == 0)) s_axi_rid <= (read_from_rdfifo)&&(rcounts == 0)?rfifo_rid : rid; // }}} // M_AXI_AR* // {{{",
            "assign M_AXI_ARVALID= m_axi_arvalid;",
            "assign M_AXI_ARADDR = axi_araddr;",
            "assign M_AXI_ARPROT = 0; // }}} // S_AXI_R* // {{{",
            "assign S_AXI_RVALID = s_axi_rvalid;",
            "assign S_AXI_RDATA = s_axi_rdata;",
            "assign S_AXI_RRESP = s_axi_rresp;",
            "assign S_AXI_RLAST = s_axi_rlast;",
            "assign S_AXI_RID = s_axi_rid; // }}} // }}} end else begin : NO_READ_SUPPORT // if (!OPT_READS) // {{{",
            "assign M_AXI_ARVALID= 0;",
            "assign M_AXI_ARADDR = 0;",
            "assign M_AXI_ARPROT = 0;",
            "assign M_AXI_RREADY = 0; // assign S_AXI_ARREADY= 0;",
            "assign S_AXI_RVALID = 0;",
            "assign S_AXI_RDATA = 0;",
            "assign S_AXI_RRESP = 0;",
            "assign S_AXI_RLAST = 0;",
            "assign S_AXI_RID = 0; // assign skids_arvalid = S_AXI_ARVALID;",
            "assign skids_arready = S_AXI_ARREADY;",
            "assign skids_arid = S_AXI_ARID;",
            "assign skids_araddr = S_AXI_ARADDR;",
            "assign skids_arlen = S_AXI_ARLEN;",
            "assign skids_arsize = S_AXI_ARSIZE;",
            "assign skids_arburst = S_AXI_ARBURST; // assign skidm_rvalid = M_AXI_RVALID;",
            "assign skidm_rready = M_AXI_RREADY;",
            "assign skidm_rdata = M_AXI_RDATA;",
            "assign skidm_rresp = M_AXI_RRESP; // // assign axi_arlen = 0; // assign rcounts = 0;",
            "assign rid = 0;",
            "assign rfifo_empty = 1;",
            "assign rfifo_full = 0;",
            "assign rfifo_count = 0; // Make Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire unused_read_signals;",
            "assign unused_read_signals = &{ 1'b0, rid, rfifo_empty, rfifo_count, rfifo_full, axi_arlen, skids_arvalid, skids_arready, skids_arid, skids_araddr, skids_arlen, skids_arsize, skids_arburst, skidm_rvalid, skidm_rready, skidm_rdata, skidm_rresp, M_AXI_ARREADY, S_AXI_RREADY }; // Verilator lint_on UNUSED // }}} // }}} end endgenerate // }}} // Make Verilator happy // {{{ // Verilator lint_off UNUSED",
            "wire [35-1:0] unused;",
            "assign unused = { S_AXI_AWLOCK, S_AXI_AWCACHE, S_AXI_AWPROT, S_AXI_AWQOS, skids_wlast, wfifo_count, S_AXI_ARLOCK, S_AXI_ARCACHE, S_AXI_ARPROT, S_AXI_ARQOS, rfifo_count }; // Verilator lint_on UNUSED // }}} //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// // // Formal properties // {{{ // The following are a subset of the formal properties used to verify this core //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// `ifdef FORMAL",
            "localparam F_LGDEPTH = LGFIFO+1+8; // // ... // //////////////////////////////////////////////////////////////////////// // // AXI channel properties // {{{ //////////////////////////////////////////////////////////////////////// // // faxi_slave #(.C_AXI_ID_WIDTH(IW), .C_AXI_DATA_WIDTH(DW), .C_AXI_ADDR_WIDTH(AW), // ) faxi(.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // Write address .i_axi_awready(skids_awready), .i_axi_awid( skids_awid), .i_axi_awaddr( skids_awaddr), .i_axi_awlen( skids_awlen), .i_axi_awsize( skids_awsize), .i_axi_awburst(skids_awburst), .i_axi_awlock( 0), .i_axi_awcache(0), .i_axi_awprot( 0), .i_axi_awqos( 0), .i_axi_awvalid(skids_awvalid), // Write data .i_axi_wready( skids_wready), .i_axi_wdata( skids_wdata), .i_axi_wstrb( skids_wstrb), .i_axi_wlast( skids_wlast), .i_axi_wvalid( skids_wvalid), // Write return response .i_axi_bid( S_AXI_BID), .i_axi_bresp( S_AXI_BRESP), .i_axi_bvalid( S_AXI_BVALID), .i_axi_bready( S_AXI_BREADY), // Read address .i_axi_arready(skids_arready), .i_axi_arid( skids_arid), .i_axi_araddr( skids_araddr), .i_axi_arlen( skids_arlen), .i_axi_arsize( skids_arsize), .i_axi_arburst(skids_arburst), .i_axi_arlock( 0), .i_axi_arcache(0), .i_axi_arprot( 0), .i_axi_arqos( 0), .i_axi_arvalid(skids_arvalid), // Read response .i_axi_rid( S_AXI_RID), .i_axi_rresp( S_AXI_RRESP), .i_axi_rvalid( S_AXI_RVALID), .i_axi_rdata( S_AXI_RDATA), .i_axi_rlast( S_AXI_RLAST), .i_axi_rready( S_AXI_RREADY), // // Formal property data .f_axi_awr_nbursts( faxi_awr_nbursts), .f_axi_wr_pending( faxi_wr_pending), .f_axi_rd_nbursts( faxi_rd_nbursts), .f_axi_rd_outstanding(faxi_rd_outstanding), // // ... ); // }}} //////////////////////////////////////////////////////////////////////// // // AXI-lite properties // {{{ //////////////////////////////////////////////////////////////////////// // // faxil_master #(.C_AXI_DATA_WIDTH(DW), .C_AXI_ADDR_WIDTH(AW), .F_OPT_NO_RESET(1), .F_AXI_MAXWAIT(5), .F_AXI_MAXDELAY(4), .F_AXI_MAXRSTALL(0), .F_OPT_WRITE_ONLY(OPT_WRITES && !OPT_READS), .F_OPT_READ_ONLY(!OPT_WRITES && OPT_READS), .F_LGDEPTH(F_AXIL_LGDEPTH)) faxil(.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN), // Write address channel .i_axi_awvalid(M_AXI_AWVALID), .i_axi_awready(M_AXI_AWREADY), .i_axi_awaddr( M_AXI_AWADDR), .i_axi_awprot( M_AXI_AWPROT), // Write data .i_axi_wready( skidm_wready), .i_axi_wdata( skidm_wdata), .i_axi_wstrb( skidm_wstrb), .i_axi_wvalid( skidm_wvalid), // Write response .i_axi_bresp( skidm_bresp), .i_axi_bvalid( skidm_bvalid), .i_axi_bready( skidm_bready), // Read address .i_axi_arvalid(M_AXI_ARVALID), .i_axi_arready(M_AXI_ARREADY), .i_axi_araddr( M_AXI_ARADDR), .i_axi_arprot( M_AXI_ARPROT), // Read data return .i_axi_rvalid( skidm_rvalid), .i_axi_rready( skidm_rready), .i_axi_rdata( skidm_rdata), .i_axi_rresp( skidm_rresp), // // Formal check variables .f_axi_rd_outstanding(faxil_rd_outstanding), .f_axi_wr_outstanding(faxil_wr_outstanding), .f_axi_awr_outstanding(faxil_awr_outstanding)); // }}} //////////////////////////////////////////////////////////////////////// // // Assume that the two write channels stay within an appropriate // distance of each other. This is to make certain that the property // file features are not violated, although not necessary true for // actual operation // always @(*) assert(s_axi_wready == (OPT_WRITES && faxi_wr_pending > 0)); //////////////////////////////////////////////////////////////////////// // // Write induction properties // {{{ //////////////////////////////////////////////////////////////////////// // // These are extra properties necessary to pass write induction // always @(*) if ((bcounts == 0)&&(!read_from_wrfifo)) assert(!skidm_bvalid || !skidm_bready);",
            "always @(*) if (axi_awlen > 0) begin assert(m_axi_awvalid); if (axi_awlen > 1) begin assert(!skids_awready); end else if (wfifo_full) begin assert(!skids_awready); end else if (M_AXI_AWVALID && !M_AXI_AWREADY) assert(!skids_awready); end",
            "always @(*) assert(axi_bresp != EXOKAY);",
            "reg [F_LGDEPTH-1:0] f_wfifo_bursts, f_wfifo_bursts_minus_one, f_wfifo_within, f_wfiid_bursts, f_wfiid_bursts_minus_one;",
            "reg [IW-1:0] f_awid;",
            "always @(posedge S_AXI_ACLK) if (skids_awvalid && skids_awready) f_awid = skids_awid; // }}} //////////////////////////////////////////////////////////////////////// // // Read induction properties // {{{ //////////////////////////////////////////////////////////////////////// // // always @(*) if (!S_AXI_RVALID && rcounts > 0) assert(rid == S_AXI_RID);",
            "always @(*) if (S_AXI_RVALID && !S_AXI_RLAST) assert(rid == S_AXI_RID);",
            "always @(*) if ((rcounts == 0)&&(!read_from_rdfifo)) assert(!skidm_rvalid || !skidm_rready);",
            "always @(*) if (axi_arlen > 0) begin assert(m_axi_arvalid); assert(!skids_arready); end // // ... // // }}} //////////////////////////////////////////////////////////////////////// // // Select only write or only read operation // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (!OPT_WRITES) begin",
            "always @(*) begin assume(!skids_awvalid); assume(!skids_wvalid); assert(M_AXI_AWVALID == 0); assert(faxil_awr_outstanding == 0); assert(faxil_wr_outstanding == 0); assert(!skidm_bvalid); assert(!S_AXI_BVALID); end end endgenerate generate if (!OPT_READS) begin",
            "always @(*) begin assume(!S_AXI_ARVALID); assert(M_AXI_ARVALID == 0); assert(faxil_rd_outstanding == 0); end end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // Cover statements, to show performance // {{{ //////////////////////////////////////////////////////////////////////// // // generate if (OPT_WRITES) begin // {{{",
            "reg [3:0] cvr_write_count, cvr_write_count_simple;",
            "initial cvr_write_count = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) cvr_write_count_simple <= 0; else if (S_AXI_AWVALID && S_AXI_AWREADY && S_AXI_AWLEN == 0) cvr_write_count_simple <= cvr_write_count_simple + 1;",
            "initial cvr_write_count = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) cvr_write_count <= 0; else if (S_AXI_AWVALID && S_AXI_AWREADY && S_AXI_AWLEN > 2) cvr_write_count <= cvr_write_count + 1;",
            "always @(*) cover(cvr_write_count_simple > 6 && /* ... */ !S_AXI_BVALID);",
            "always @(*) cover(cvr_write_count > 2 && /* ... */ !S_AXI_BVALID); // }}} end endgenerate generate if (OPT_READS) begin // {{{",
            "reg [3:0] cvr_read_count, cvr_read_count_simple;",
            "initial cvr_read_count_simple = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) cvr_read_count_simple <= 0; else if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN == 0) cvr_read_count_simple <= cvr_read_count_simple + 1;",
            "initial cvr_read_count = 0;",
            "always @(posedge S_AXI_ACLK) if (!S_AXI_ARESETN) cvr_read_count <= 0; else if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN > 2) cvr_read_count <= cvr_read_count + 1;",
            "always @(*) cover(cvr_read_count_simple > 6 && /* ... */ !S_AXI_RVALID);",
            "always @(*) cover(cvr_read_count > 2 && /* ... */ !S_AXI_RVALID); // }}} end endgenerate // }}} //////////////////////////////////////////////////////////////////////// // // ... // {{{ //////////////////////////////////////////////////////////////////////// // // }}} `undef BMC_ASSERT `endif // }}}",
            "endmodule"
        ]
    }
]