[
    {
        "file_name": "ffetch.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/formal/ffetch.v",
        "chunks": [
            "reg ards the instruction fetch.\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n//\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype\tnone\n// }}}",
            "module ffetch #(\n\t\t// {{{\n\t\t// Address width -- from the CPU's perspective, not the bus'es",
            "parameter ADDRESS_WIDTH = 30,",
            "parameter [0:0]\tOPT_ALIGNED  = 1'b0,",
            "parameter [0:0]\tOPT_CONTRACT = 1'b1,",
            "parameter INSN_WIDTH = 32, // Number of bits in an instruction",
            "parameter [0:0]\tF_OPT_ASYNC_RESET = 1'b0,",
            "localparam AW=ADDRESS_WIDTH, // Shorthand for ADDRESS_WIDTH",
            "localparam BW=AW + $clog2(INSN_WIDTH/8)\t// Byte addr wid\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t//\n\t\t// The interface with the rest of the CPU",
            "input ",
            "wire cpu_new_pc,",
            "input ",
            "wire cpu_clear_cache,",
            "input ",
            "wire [BW-1:0]\tcpu_pc,",
            "input ",
            "wire pf_valid,",
            "input ",
            "wire cpu_ready,",
            "input ",
            "wire [BW-1:0]\tpf_pc,",
            "input ",
            "wire [(INSN_WIDTH-1):0]\tpf_insn,\n\t\t//\n\t\t// o_illegal will be true if this instruction was the result of\n\t\t// a bus error (This is also part of the CPU interface)",
            "input ",
            "wire pf_illegal,\n\t\t//",
            "output ",
            "wire [BW-1:0]\tfc_pc,",
            "output ",
            "wire fc_illegal,",
            "output ",
            "wire [INSN_WIDTH-1:0]\tfc_insn,",
            "output ",
            "reg [BW-1:0]\tf_address\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{\n`ifdef\tZIPCPU\n`define\tCPU_ASSUME\tassume\n`define\tCPU_ASSERT\tassert\n`else\n`define\tCPU_ASSUME\tassert\n`define\tCPU_ASSERT\tassume\n`endif",
            "localparam INSN_LSB = $clog2(INSN_WIDTH/8);",
            "reg [BW-1:0]\tf_next_address;",
            "reg f_past_valid;",
            "reg need_new_pc, past_stalled, past_illegal;",
            "reg [INSN_WIDTH-1:0]\tpast_insn;\n\n\t// Verilator lint_off UNDRIVEN\n\t(* anyconst *)",
            "reg [BW-1:0]\tr_fc_pc;\n\t(* anyconst *)",
            "reg r_fc_illegal;\n\t(* anyconst *)",
            "reg [INSN_WIDTH-1:0]\tr_fc_insn;\n\t// Verilator lint_on  UNDRIVEN\n\n\tassign\tfc_pc\t\t= r_fc_pc;\n\tassign\tfc_illegal\t= r_fc_illegal;\n\tassign\tfc_insn\t\t= r_fc_insn;\n\t// }}}\n\n\t// f_address, f_next_address -- address tracking\n\t// {{{\n\talways @(posedge i_clk)\n\tif (cpu_new_pc)\n\t\tf_address <= cpu_pc;\n\telse if (pf_valid && cpu_ready)\n\tbegin\n\t\tf_address[BW-1:INSN_LSB] <= f_address[BW-1:INSN_LSB] + 1'b1;\n\t\tif (INSN_LSB > 0)\n\t\t\tf_address[((INSN_LSB>0) ? INSN_LSB:1)-1:0] <= 0;\n\tend\n\n\talways @(*)\n\tbegin\n\t\tf_next_address = f_address + (1<<INSN_LSB);\n\t\tif (INSN_LSB > 0)\n\t\t\tf_next_address[((INSN_LSB>0) ? INSN_LSB : 1)-1:0] <= 0;\n\tend\n\t// }}}\n\n\t// f_past_valid\n\t// {{{\n\t// Keep track of a flag telling us whether or not $past()\n\t// will return valid results\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Reset\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\n\t//\n\t// Assume we start from a reset condition\n\tinitial\t`CPU_ASSERT(i_reset);\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`CPU_ASSERT(i_reset);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about our return responses to the CPU\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// pf_pc, and cpu_pc alignment\n\t// {{{\n\tgenerate if (OPT_ALIGNED && INSN_LSB > 0)\n\tbegin : F_CHECK_ALIGNMENT\n\n\t\talways @(*)\n\t\tif (cpu_new_pc)\n\t\t\t`CPU_ASSERT(cpu_pc[INSN_LSB-1:0] == 0);\n\n\t\talways @(*)\n\t\tif (pf_valid)\n\t\t\t`CPU_ASSUME(pf_pc[INSN_LSB-1:0] == 0);\n\n\tend endgenerate\n\t// }}}\n\n\t// Some things to know from the CPU ... there will always be a\n\t// i_new_pc request following any reset or clear cache request\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset))\n\tbegin\n\t\t`CPU_ASSUME(!pf_valid);\n\t\t`CPU_ASSUME(!pf_illegal);\n\tend\n\n\tinitial\tneed_new_pc = 1'b1;\n\talways @(posedge i_clk)\n\t\tneed_new_pc <= (i_reset || cpu_clear_cache);\n\n\tinitial\tpast_stalled = 1'b1;\n\talways @(posedge i_clk)\n\t\tpast_stalled <= pf_valid && !cpu_ready && !cpu_new_pc;\n\n\tinitial\tpast_illegal = 1'b0;\n\talways @(posedge i_clk)\n\t\tpast_illegal <= pf_illegal;\n\n\talways @(posedge i_clk)\n\t\tpast_insn <= pf_insn;\n\n\talways @(*)\n\tif (!F_OPT_ASYNC_RESET || !i_reset)\n\tbegin\n\t\tif (need_new_pc)\n\t\tbegin\n\t\t\t`CPU_ASSERT(i_reset || cpu_clear_cache || cpu_new_pc);\n\t\t\t`CPU_ASSUME(!pf_valid);\n\t\t\t`CPU_ASSUME(!pf_illegal);\n\t\tend else if (past_stalled)\n\t\tbegin\n\t\t\t`CPU_ASSUME(past_illegal == pf_illegal);\n\t\t\t`CPU_ASSUME(pf_illegal || (past_insn == pf_insn));\n\t\t\tif (!cpu_new_pc)\n\t\t\t\t`CPU_ASSERT(cpu_pc[BW-1:INSN_LSB]== f_next_address[BW-1:INSN_LSB]);\n\t\tend else if (!cpu_new_pc && !i_reset && !cpu_clear_cache)\n\t\tbegin\n\t\t\t`CPU_ASSERT(cpu_pc[BW-1:INSN_LSB]== f_next_address[BW-1:INSN_LSB]);\n\t\tend\n\tend\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset || cpu_clear_cache)\n\t\t\t|| (F_OPT_ASYNC_RESET && i_reset))\n\tbegin\n\t\tif (!F_OPT_ASYNC_RESET || !i_reset)\n\t\tbegin\n\t\t\tassert(need_new_pc);\n\t\t\t`CPU_ASSERT(cpu_new_pc || i_reset || cpu_clear_cache);\n\t\t\t`CPU_ASSUME(!pf_valid);\n\t\t\t`CPU_ASSUME(!pf_illegal);\n\t\tend\n\tend else if (!$past(cpu_new_pc) && $past(pf_valid && !cpu_ready))\n\tbegin\n\t\t//\n\t\t// Once an instruction has been presented, it must hold valid\n\t\t// until accepted\n\t\tassert(!need_new_pc);\n\t\t`CPU_ASSUME(pf_valid);\n\t\t`CPU_ASSUME($stable(pf_pc));\n\t\t`CPU_ASSUME(pf_illegal || $stable(pf_insn));\n\t\t`CPU_ASSUME($stable(pf_illegal));\n\tend else if ($past(pf_illegal && !cpu_new_pc))\n\t\t// Once illegal is raised, it stays raised until a new PC,\n\t\t// reset, or cache clear\n\t\t`CPU_ASSUME(pf_illegal);\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset || cpu_clear_cache))\n\tbegin\n\t\t`CPU_ASSUME(!pf_valid);\n\tend else if ((f_past_valid)&&(!$past(pf_illegal && !cpu_new_pc))&&(pf_illegal))\n\t\t// pf_illegal can only rise if pf_valid is true\n\t\t`CPU_ASSUME(pf_valid);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_reset || cpu_new_pc || cpu_clear_cache)))\n\tbegin\n\t\t`CPU_ASSUME(!pf_illegal || pf_valid);\n\tend else if (f_past_valid && $past(pf_illegal))\n\t\t`CPU_ASSUME(pf_illegal);\n\n\talways @(*)\n\tif (pf_valid && !pf_illegal)\n\t\t`CPU_ASSUME(f_address == pf_pc);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && !i_reset && !cpu_new_pc && !need_new_pc)\n\t\t`CPU_ASSERT(f_next_address == cpu_pc);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(*)\n\t\tassume(fc_pc[1:0] == 2'b00);\n\n\tgenerate if (OPT_CONTRACT)\n\tbegin : CHECK_CONTRACT\n\t\talways @(*)\n\t\tif (pf_valid && fc_pc[BW-1:INSN_LSB] == f_address[BW-1:INSN_LSB])\n\t\tbegin\n\t\t\tif (fc_illegal)\n\t\t\tbegin\n\t\t\t\t`CPU_ASSUME(pf_illegal);\n\t\t\tend else if (!pf_illegal)\n\t\t\t\t`CPU_ASSUME(fc_insn == pf_insn);\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && !$past(pf_illegal) && pf_valid\n\t\t\t\t&& fc_pc[BW-1:INSN_LSB] == f_address[BW-1:INSN_LSB])\n\t\t\t`CPU_ASSUME(fc_illegal == pf_illegal);\n\n\tend endgenerate\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "fdebug.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/formal/fdebug.v",
        "chunks": [
            "reg ister override bits.\n//\n// Ports:\n//\ti_clk\n//\ti_reset\tPositive, synchronous, reset everything\n//\ti_cpu_reset\tThe CPU is being reset and only the CPU--not the bus.\n//\ti_halt\t\tA request is being made to halt the CPU\n//\ti_halted\tSignal from the CPU that it has come to a complete halt\n//\ti_clear_cache\tRequest to clear the CPU's cache.  Can only be issued\n//\t\t\twith i_halt true, must hold true once set until\n//\t\t\ti_halted.\n//\ti_dbg_we\tA request to write to a CPU",
            "reg ister.  i_halt must\n//\t\t\talso be true.  The request must remain valid until\n//\t\t\t!i_dbg_stall is also true.\n//\ti_dbg_",
            "reg The",
            "reg ister to be written.  Registers 0-15 are in the\n//\t\t\tsupervisor set, 16-31 in the user set.  Registers\n//\t\t\t15 and 31 are program counters, 14 and 30 are flags,\n//\t\t\t13 and 29 are (by convention) stack pointers.\n//\ti_dbg_data\tThe data to be written to i_dbg_",
            "reg when i_dbg_we is\n//\t\t\tset.  Note that there's no byte enables, strobes, or\n//\t\t\tany other mechanism for less than 32-bit writes.  All\n//\t\t\twrites are 32-bits.\n//\ti_dbg_stall\tThe CPU is not able to handle a write request at this\n//\t\t\ttime.\n//\ti_dbg_break\tThe CPU has suffered from a break condition and cannot\n//\t\t\tcontinue operating.\n//\ti_dbg_cc\tCPU conditions:\n//\t\ti_bus_err:\tThe supervisor has suffered from a bus error\n//\t\tgie:\t\tCPU is in user mode\n//\t\tsleep:\t\tCPU is asleep (if in user mode), or halted\n//\t\t\t\tif in supervisor mode (gie is clear)\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2020-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype\tnone\n// }}}",
            "module fdebug #(\n\t\t// {{{\n\t\t// Some FPGA's have no distributed RAM, and so require an extra\n\t\t// clock cycle to access CPU",
            "reg ister data.  In such cases, CPU\n\t\t// reads require an extra clock cycle:\n\t\t//\t1. Address valid, 2. (wait state), 3. Data available\n\t\t// Set OPT_DISTRIBUTED_RAM to 1'b0 if such a wait state is\n\t\t// required.",
            "parameter [0:0]\tOPT_DISTRIBUTED_RAM = 1'b1,",
            "parameter [0:0]\tOPT_START_HALTED = 1'b1\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk,",
            "input ",
            "wire i_reset,",
            "input ",
            "wire i_cpu_reset,",
            "input ",
            "wire i_halt,",
            "input ",
            "wire i_halted,",
            "input ",
            "wire i_clear_cache,\n\t\t//",
            "input ",
            "wire i_dbg_we,",
            "input ",
            "wire [4:0]\ti_dbg_",
            "reg ,",
            "input ",
            "wire [31:0]\ti_dbg_data,\n\t\t//",
            "input ",
            "wire i_dbg_stall,",
            "input ",
            "wire i_dbg_break,",
            "input ",
            "wire [2:0]\ti_dbg_cc\n\t\t// }}}\n\t);\n\n`ifdef\tZIPCPU\n`define\tCPU_ASSUME\tassume\n`define\tCPU_ASSERT\tassert\n`else\n`define\tCPU_ASSUME\tassert\n`define\tCPU_ASSERT\tassume\n`endif",
            "reg f_past_valid;\n\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset && !i_cpu_reset))\n\t\t`CPU_ASSUME(i_cpu_reset);\n\n\t// Stall checking\n\t// {{{\n\talways @(posedge i_clk)\n\tif (f_past_valid && $past(!i_reset && !i_cpu_reset && i_dbg_we && i_dbg_stall))\n\tbegin\n\t\t`CPU_ASSUME(i_dbg_we);\n\t\t`CPU_ASSUME($stable(i_dbg_",
            "reg ));\n\t\t`CPU_ASSUME($stable(i_dbg_data));\n\tend\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && $past(!i_reset && !i_cpu_reset\n\t\t\t\t\t&& i_clear_cache && i_dbg_stall))\n\t\t`CPU_ASSUME(i_clear_cache);\n\t// }}}\n\n\t// Writes will only ever be attempted if/when the CPU is halted\n\t// {{{\n\talways @(*)\n\tif (i_dbg_we)\n\t\t`CPU_ASSUME(i_halt);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && (!i_reset && !i_cpu_reset)\n\t\t\t&& $past(!i_reset && !i_cpu_reset) && $past(i_dbg_we))\n\t\t`CPU_ASSUME(i_halt);\n\n\tgenerate if (!OPT_DISTRIBUTED_RAM)\n\tbegin\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && $past(f_past_valid) && $past(i_dbg_we,2))\n\t\t\t`CPU_ASSUME(i_halt);\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Clear cache checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// The clear cache signal will only ever be applied if/when the\n\t// CPU is halted\n\t// {{{\n\talways @(*)\n\tif (!i_halt && !i_reset && !i_cpu_reset)\n\t\t`CPU_ASSUME(!i_clear_cache);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && $past(!i_reset && !i_cpu_reset && i_clear_cache))\n\t\t`CPU_ASSUME(i_halt);\n\t// }}}\n\t// }}}\n\n\t// Writes to the program counter will always be aligned\n\t// always @(posedge i_clk)\n\t// if (i_dbg_we && i_dbg_",
            "reg [3:0] == 4'hf)\n\t//\t`CPU_ASSUME(i_dbg_data[1:0] == 2'b00);\n\n\t// The CPU will always come to a halt on a break\n\talways @(posedge i_clk)\n\tif (f_past_valid && $past(!i_reset && !i_cpu_reset && i_dbg_break))\n\t\t`CPU_ASSUME(i_halt || i_reset || i_cpu_reset);\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Complete halt assertions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\n\t// If the CPU isn't halted, stall will be asserted\n\t// {{{\n\talways @(*)\n\tif (!i_halted)\n\t\t`CPU_ASSERT(i_dbg_stall);\n\t// }}}\n\n\t// A halted CPU won't restart without being released\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset))\n\tbegin\n\t\t`CPU_ASSERT(i_halted == OPT_START_HALTED);\n\tend else if (f_past_valid && $past(i_halt && i_halted))\n\t\t`CPU_ASSERT(i_halted);\n\t// }}}\n\n\t// Once requested, the halt request will remain active until the CPU\n\t// comes to a complete halt\n\t// {{{\n\talways @(posedge i_clk)\n\tif (f_past_valid && $past(!i_reset && !i_cpu_reset && i_halt && !i_halted))\n\t\t`CPU_ASSUME(i_halt);\n\t// }}}\n\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "abs_mpy.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/formal/abs_mpy.v",
        "chunks": [
            "module abs_mpy #(\n\t\t// {{{",
            "parameter OPT_MPY = 1,",
            "parameter MAXDELAY = 3,\n\t\t// Verilator lint_off UNUSED",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0\n\t\t// Verilator lint_on  UNUSED\n\t\t// }}}\n\t) (\n\t\t// {{{\n\t\t// The following",
            "parameter selects which multiply algorithm we\n\t\t// use.  Timing performance is strictly dependent upon it.",
            "input ",
            "wire i_clk, i_reset, i_stb,",
            "input ",
            "wire [1:0]\ti_op, // 2'b00=MPY, 2'b10=MPYUHI, 2'b11=MPYSHI",
            "input ",
            "wire [31:0]\ti_a, i_b,",
            "output ",
            "reg o_valid,",
            "output ",
            "wire o_busy, // The multiply is busy if true",
            "output ",
            "wire [63:0]\to_result,",
            "output ",
            "reg o_hi // Rtrn high half of mpy results\n\t\t// }}}\n\t);\n\n`define\tASSERT\tassert\n// i_stb instead of this_is_a_multiply_op\n// o_result\n// o_busy\n// o_done\n\tgenerate if (OPT_MPY == 0)\n\tbegin // No multiply support.\n\t\t// {{{\n\n\t\tassign\to_result   = 64'h00;\n\t\tassign\to_busy     = 1'b0;\n\t\talways @(*)\n\t\t\to_valid    = i_stb;\n\t\talways @(*) o_hi = 1'b0; // Not needed\n\t\t// }}}\n\tend else begin : F_MPY // Our single clock option (no extra clocks)\n\t\t// {{{\n\n\t\t// Verilator lint_off UNDRIVEN\n\t\t(* anyseq *)",
            "reg [2:0]\tnext_delay_to_valid;\n\t\t(* anyseq *)",
            "reg [63:0]\tany_result;\n\t\t// Verilator lint_on  UNDRIVEN\n\n\t\tassign\to_result = any_result;",
            "reg [2w:0]\tdelay_to_valid;",
            "reg r_busy;\n\n\t\talways @(*)\n\t\tassume((MAXDELAY == 0)\n\t\t\t||(next_delay_to_valid < MAXDELAY));\n\n\t\t// always @(*)\n\t\t// if (OPT_MPY == 1)\n\t\t\t// assume(next_delay_to_valid == 0);\n\t\talways @(*)\n\t\tif (OPT_MPY>0)\n\t\t\tassume(next_delay_to_valid == OPT_MPY-1);\n\n\t\tinitial\tdelay_to_valid = 3'h0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tdelay_to_valid <= 0;\n\t\telse if ((i_stb)&&(next_delay_to_valid != 0))\n\t\t\tdelay_to_valid <= next_delay_to_valid;\n\t\telse if (delay_to_valid > 0)\n\t\t\tdelay_to_valid <= delay_to_valid - 1'b1;\n\n\t\tinitial\tr_busy = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_busy <= 1'b0;\n\t\telse if (i_stb)\n\t\t\tr_busy <= (next_delay_to_valid != 0);\n\t\telse if (r_busy)\n\t\t\tr_busy <= (delay_to_valid != 3'h1);\n\n\t\tinitial\to_valid = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\to_valid <= 1'b0;\n\t\telse if ((i_stb)&&(next_delay_to_valid == 0))\n\t\t\to_valid <= 1'b1;\n\t\telse\n\t\t\to_valid <= (o_busy)&&(delay_to_valid == 3'h1);\n\n\t\talways @(posedge i_clk)\n\t\tif (i_stb)\n\t\t\to_hi <= i_op[1];\n\n\t\tassign\to_busy = r_busy;\n\t\t// }}}\n\tend endgenerate // All possible multiply results have been determined\n\n\t// Keep Verilator happy\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, i_op, i_a, i_b };\n\t// Verilator lint_on  UNUSED\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "abs_div.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/formal/abs_div.v",
        "chunks": [
            "module provides an Integer divide\n//\t\tcapability to the Zip CPU.  This",
            "module is an abstract\n//\tdivide",
            "module .  It *might* produce a valid integer divide, either signed\n//\tor unsigned, result.  It might instead do somethin else.  It is designed\n//\tto be easier for the formal tools to work with.\n//\n// Steps:\n//\ti_reset\tThe DIVide unit starts in idle.  It can also be placed into an\n//\tidle by asserting the reset",
            "input .\n//\n//\ti_wr\tWhen i_reset is asserted, a divide begins.  On the next clock:\n//\n//\t  o_busy is set high so everyone else knows we are at work and they can\n//\t\twait for us to complete.\n//\n//\t  pre_sign is set to true if we need to do a signed divide.  In this\n//\t\tcase, we take a clock cycle to turn the divide into an unsigned\n//\t\tdivide.\n//\n//\t  o_quotient, a place to store our result, is initialized to all zeros.\n//\n//\t  r_dividend is set to the numerator\n//\n//\t  r_divisor is set to 2^31 * the denominator (shift left by 31, or add\n//\t\t31 zeros to the right of the number.\n//\n//\tpre_sign When true (clock cycle after i_wr), a clock cycle is used\n//\t\tto take the absolute value of the various arguments (r_dividend\n//\t\tand r_divisor), and to calculate what sign the",
            "output result\n//\t\tshould be.\n//\n//\n//\tAt this point, the divide is has started.  The divide works by walking\n//\tthrough every shift of the\n//\n//\t\t    DIVIDEND\tover the\n//\t\tDIVISOR\n//\n//\tIf the DIVISOR is bigger than the dividend, the divisor is shifted\n//\tright, and nothing is done to the",
            "output quotient.\n//\n//\t\t    DIVIDEND\n//\t\t DIVISOR\n//\n//\tThis repeats, until DIVISOR is less than or equal to the divident, as in\n//\n//\t\tDIVIDEND\n//\t\tDIVISOR\n//\n//\tAt this point, if the DIVISOR is less than the dividend, the\n//\tdivisor is subtracted from the dividend, and the DIVISOR is again\n//\tshifted to the right.  Further, a '1' bit gets set in the",
            "output //\tquotient.\n//\n//\tOnce we've done this for 32 clocks, we've accumulated our answer into\n//\tthe",
            "output quotient, and we can proceed to the next step.  If the\n//\tresult will be signed, the next step negates the quotient, otherwise\n//\tit returns the result.\n//\n//\tOn the clock when we are done, o_busy is set to false, and o_valid set\n//\tto true.  (It is a violation of the ZipCPU internal protocol for both\n//\tbusy and valid to ever be true on the same clock.  It is also a\n//\tviolation for busy to be false with valid true thereafter.)\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of  the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype\tnone\n// }}}",
            "module abs_div #(\n\t\t// {{{",
            "parameter BW=32, LGBW = 5,\n\t\t// Verilator lint_off UNUSED",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,\n\t\t// Verilator lint_on  UNUSED",
            "parameter [4:0]\tMAXDELAY = 3\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Input",
            "parameter s",
            "input ",
            "wire i_wr, i_signed,",
            "input ",
            "wire [(BW-1):0]\ti_numerator, i_denominator,\n\t\t// Output",
            "parameter s",
            "output ",
            "wire o_busy,",
            "output ",
            "reg o_valid, o_err,",
            "output ",
            "reg [(BW-1):0]\to_quotient,",
            "output ",
            "wire [3:0]\to_flags\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{\n\t// Verilator lint_off UNDRIVEN\n\t(* anyseq *)",
            "reg any_err;\n\t(* anyseq *)",
            "reg [(BW-1):0]\tany_quotient;\n\t(* anyseq *)",
            "reg [5:0]\t\twait_time;\n\t(* anyseq *)",
            "reg [3:0]\t\tany_flags;\n\t// Verilator lint_on  UNDRIVEN",
            "reg [5:0]\tr_busy_counter;\n\t// }}}\n\n\talways @(*)\n\t\to_err      = any_err;\n\talways @(*)\n\t\to_quotient = any_quotient;\n\n\talways @(*)\n\t\tassume(wait_time > 5'h1);\n\n\talways @(*)\n\t\tassume((MAXDELAY == 0)||(wait_time < MAXDELAY));\n\n\t// r_busy_counter\n\t// {{{\n\tinitial\tr_busy_counter = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_busy_counter <= 0;\n\telse if ((i_wr)&&(!o_busy))\n\t\tr_busy_counter <= wait_time;\n\telse if (r_busy_counter > 0)\n\t\tr_busy_counter <= r_busy_counter - 1'b1;\n\t// }}}\n\n\talways @(*)\n\t\tassert((MAXDELAY == 0)||(r_busy_counter < MAXDELAY));\n\n\tassign\to_busy = (r_busy_counter != 0);\n\n\t// o_valid\n\t// {{{\n\tinitial\to_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_valid <= 1'b0;\n\telse\n\t\to_valid <= (r_busy_counter == 1);\n\t// }}}\n\n\tassign o_flags    = (o_valid) ? \n\t\t\t{ 1'b0, o_quotient[31], any_flags[1],\n\t\t\t\t\t(o_quotient == 0) } : any_flags;\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\talways @(posedge i_clk)\n\tif (!f_past_valid)\n\t\tassert((!o_busy)&&(!o_valid));\n\n`define\tASSUME\tassert\n\n\tinitial\t`ASSUME(i_reset);\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(i_reset);\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\t\t`ASSUME(!i_wr);\n\n\talways @(*)\n\tif (o_busy)\n\t\t`ASSUME(!i_wr);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(o_busy))&&(!o_busy))\n\t\tassume(o_valid);\n\n\talways @(*)\n\tif (o_err)\n\t\tassume(o_valid);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wr)))\n\t\tassert(o_busy);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_valid)))\n\t\tassume(!o_valid);\n\n\talways @(*)\n\tif ((o_valid)&&(!o_err))\n\t\tassume(o_flags[3] == ((o_quotient == 0)? 1'b1:1'b0));\n\n\talways @(*)\n\tif ((o_valid)&&(!o_err))\n\t\tassume(o_flags[1] == o_quotient[BW-1]);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(o_busy))&&(!$past(i_wr)))\n\t\tassume(!o_busy);\n\n\talways @(posedge i_clk)\n\t\tassume((!o_busy)||(!o_valid));\n\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "f_idecode.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/formal/f_idecode.v",
        "chunks": [
            "module f_idecode #(\n\t\t// {{{",
            "parameter [0:0]\tOPT_MPY    = 1'b1,",
            "parameter [0:0]\tOPT_SHIFTS = 1'b1,",
            "parameter [0:0]\tOPT_DIVIDE = 1'b1,",
            "parameter [0:0]\tOPT_FPU    = 1'b0,",
            "parameter [0:0]\tOPT_CIS    = 1'b1,",
            "parameter [0:0]\tOPT_LOCK   = 1'b1,",
            "parameter [0:0]\tOPT_OPIPE  = 1'b1,",
            "parameter [0:0]\tOPT_SIM    = 1'b0,",
            "parameter [0:0]\tOPT_USERMODE = 1'b1,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire [31:0]\ti_instruction,",
            "input ",
            "wire i_phase, i_gie,",
            "output ",
            "reg o_illegal,",
            "output ",
            "wire [6:0]\to_dcdR, o_dcdA, o_dcdB,",
            "output ",
            "wire [31:0]\to_I,",
            "output ",
            "wire [3:0]\to_cond,",
            "output ",
            "wire o_wF,",
            "output ",
            "wire [3:0]\to_op,",
            "output ",
            "wire o_ALU, o_M, o_DV, o_FP, o_break,",
            "output ",
            "wire o_lock,",
            "output ",
            "wire o_wR, o_rA, o_rB,",
            "output ",
            "wire o_prepipe,",
            "output ",
            "wire o_sim,",
            "output ",
            "wire [22:0]\to_sim_immv\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam [3:0]\tCPU_SP_REG = 4'hd,\n\t\t\t\tCPU_CC_REG = 4'he,\n\t\t\t\tCPU_PC_REG = 4'hf;",
            "localparam CISBIT    = 31,\n\t\t\t\tCISIMMSEL = 23,\n\t\t\t\tIMMSEL    = 18;",
            "wire [4:0]\tw_op;",
            "wire w_ldi, w_mov, w_cmptst, w_ldilo, w_ALU, w_brev,\n\t\t\tw_noop, w_lock, w_sim, w_break, w_special, // w_add,\n\t\t\tw_mpy;",
            "wire [4:0]\tw_dcdR, w_dcdB, w_dcdA;",
            "wire w_dcdR_pc, w_dcdR_cc;",
            "wire w_dcdA_pc, w_dcdA_cc;",
            "wire w_dcdB_pc, w_dcdB_cc;",
            "wire [3:0]\tw_cond;",
            "wire w_wF, w_mem, w_sto, w_div, w_fpu;",
            "wire w_wR, w_rA, w_rB, w_wR_n;",
            "wire illegal_shift;",
            "wire [31:0]\tiword;\n\t// }}}\n\n\t// iword\n\t// {{{\n\tgenerate if (OPT_CIS)\n\tbegin : SET_IWORD\n\n\t\tassign\tiword = ((!i_instruction[CISBIT])||(i_phase))\n\t\t\t? i_instruction\n\t\t\t: { 1'b1, i_instruction[14:0], i_instruction[15:0] };\n\n\tend else begin : CLR_IWORD\n\n\t\tassign\tiword = { 1'b0, i_instruction[30:0] };\n\n\tend endgenerate\n\t// }}}",
            "reg [4:0]\tw_cis_op;\n\n\t// w_cis_op : Get the opcode\n\t// {{{\n\tgenerate if (OPT_CIS)\n\tbegin : GEN_CIS_OP\n\n\t\talways @(*)\n\t\tif (!iword[CISBIT])\n\t\t\tw_cis_op = iword[26:22];\n\t\telse case(iword[26:24])\n\t\t3'h0: w_cis_op = 5'h00;\t// ADD\n\t\t3'h1: w_cis_op = 5'h01;\t// AND\n\t\t3'h2: w_cis_op = 5'h02;\t// SUB\n\t\t3'h3: w_cis_op = 5'h10;\t// BREV\n\t\t3'h4: w_cis_op = 5'h12;\t// LW\n\t\t3'h5: w_cis_op = 5'h13;\t// SW\n\t\t3'h6: w_cis_op = 5'h18;\t// LDI\n\t\t3'h7: w_cis_op = 5'h0d;\t// MOV\n\t\tendcase\n\n\tend else begin : GEN_NOCIS_OP\n\n\t\talways @(*)\n\t\t\tw_cis_op = w_op;\n\n\tend endgenerate\n\t// }}}\n\n\t// Decode instructions\n\t// {{{\n\tassign\tw_op= iword[26:22];\n\tassign\tw_mov    = (w_cis_op      == 5'h0d);\n\tassign\tw_ldi    = (w_cis_op[4:1] == 4'hc);\n\tassign\tw_brev   = (w_cis_op      == 5'h08);\n\tassign\tw_mpy    = (w_cis_op[4:1] == 4'h5)||(w_cis_op[4:0]==5'h0c);\n\tassign\tw_cmptst = (w_cis_op[4:1] == 4'h8);\n\tassign\tw_ldilo  = (w_cis_op[4:0] == 5'h09);\n\tassign\tw_ALU    = (!w_cis_op[4]) // anything with [4]==0, but ...\n\t\t\t\t&&(w_cis_op[3:1] != 3'h7); // not the divide\n\t// assign\tw_add    = (w_cis_op[4:0] == 5'h02);\n\tassign\tw_mem    = (w_cis_op[4:3] == 2'b10)&&(w_cis_op[2:1] !=2'b00);\n\tassign\tw_sto    = (w_mem)&&( w_cis_op[0]);\n\tassign\tw_div    = (!iword[CISBIT])&&(w_op[4:1] == 4'h7);\n\tassign\tw_fpu    = (!iword[CISBIT])&&(w_op[4:3] == 2'b11)\n\t\t\t\t&&(w_dcdR[3:1] != 3'h7)\n\t\t\t\t&&(w_op[2:1] != 2'b00);\n\t// If the result",
            "reg ister is either CC or PC, and this would otherwise\n\t// be a floating point instruction with floating point opcode of 0,\n\t// then this is a NOOP.\n\tassign\tw_special= (!iword[CISBIT])&&(w_dcdR[3:1]==3'h7)\n\t\t\t&&(w_op[4:2] == 3'b111);\n\tassign\tw_break = (w_special)&&(w_op[4:0]==5'h1c);\n\tassign\tw_lock  = (w_special)&&(w_op[4:0]==5'h1d);\n\tassign\tw_sim   = (w_special)&&(w_op[4:0]==5'h1e);\n\tassign\tw_noop  = (w_special)&&(w_op[4:1]==4'hf); // Must include w_sim\n`ifdef\tFORMAL\n\talways @(*)\n\t\tassert(!w_special || !w_fpu);\n`endif\n\t// }}}\n\n\t// w_dcdR, w_dcdA\n\t// {{{\n\t// What",
            "reg ister will we be placing results into (if at all)?\n\t//\n\t// Two parts to the result",
            "reg ister: the",
            "reg ister set, given for\n\t// moves in iword[18] but only for the supervisor, and the other\n\t// four bits encoded in the instruction.\n\t//\n\tassign\tw_dcdR = { ((!iword[CISBIT])&&(OPT_USERMODE)&&(w_mov)&&(!i_gie))?iword[IMMSEL]:i_gie,\n\t\t\t\tiword[30:27] };\n\n\tassign\tw_dcdA = w_dcdR;\t// on ZipCPU, A is always result",
            "reg assign\tw_dcdA_pc = w_dcdR_pc;\n\tassign\tw_dcdA_cc = w_dcdR_cc;\n\n\tassign\tw_dcdR_pc = (w_dcdR == {i_gie, CPU_PC_REG});\n\tassign\tw_dcdR_cc = (w_dcdR == {i_gie, CPU_CC_REG});\n\t// }}}\n\n\t// dcdB - What",
            "reg ister is used in the opB?\n\t// {{{\n\tassign w_dcdB[4] = ((!iword[CISBIT])&&(w_mov)&&(OPT_USERMODE)&&(!i_gie))?iword[13]:i_gie;\n\tassign w_dcdB[3:0]= (iword[CISBIT])\n\t\t\t\t? (((!iword[CISIMMSEL])&&(iword[26:25]==2'b10))\n\t\t\t\t\t? CPU_SP_REG : iword[22:19])\n\t\t\t\t: iword[17:14];\n\n\tassign\tw_dcdB_pc = (w_rB)&&(w_dcdB[3:0] == CPU_PC_REG);\n\tassign\tw_dcdB_cc = (w_rB)&&(w_dcdB[3:0] == CPU_CC_REG);\n\t// }}}\n\n\t// w_cond\n\t// {{{\n\t// Under what condition will we execute this instruction?  Only the\n\t// load immediate instruction and the CIS instructions are completely\n\t// unconditional.  Well ... not quite.  The BREAK, LOCK, and SIM/NOOP\n\t// instructions are also unconditional.\n\t//\n\tassign\tw_cond = ((w_ldi)||(w_special)||(iword[CISBIT])) ? 4'h8 :\n\t\t\t{ (iword[21:19]==3'h0), iword[21:19] };\n\t// }}}\n\n\t// rA - do we need to read",
            "reg ister A?\n\t// {{{\n\tassign\tw_rA = // Floating point reads",
            "reg A\n\t\t\t(w_fpu)\n\t\t\t// Divide's read A\n\t\t\t||(w_div)\n\t\t\t// ALU ops read A,\n\t\t\t//\texcept for MOV's and BREV's which don't\n\t\t\t||((w_ALU)&&(!w_brev)&&(!w_mov))\n\t\t\t// STO's read A\n\t\t\t||(w_sto)\n\t\t\t// Test/compares\n\t\t\t||(w_cmptst);\n\t// }}}\n\n\t// rB -- do we read a",
            "reg ister for operand B?\n\t// {{{\n\t// Specifically, do we add the",
            "reg isters value to the immediate to\n\t// create opB?\n\tassign\tw_rB     = (w_mov)\n\t\t\t\t||((!iword[CISBIT])&&(iword[IMMSEL])&&(!w_ldi)&&(!w_special))\n\t\t\t\t||(( iword[CISBIT])&&(iword[CISIMMSEL])&&(!w_ldi))\n\t\t\t\t// If using compressed instruction sets,\n\t\t\t\t// we *always* read on memory operands.\n\t\t\t\t||(( iword[CISBIT])&&(w_mem));\n\t// }}}\n\n\t// wR -- will we be writing our result back?\n\t// {{{\n\t// wR_n = !wR\n\t// All but STO, NOOP/BREAK/LOCK, and CMP/TST write back to w_dcdR\n\tassign\tw_wR_n   = (w_sto)\n\t\t\t\t||(w_special)\n\t\t\t\t||(w_cmptst);\n\tassign\tw_wR     = !w_wR_n;\n\t// }}}\n\t//\n\t// wF -- do we write flags when we are done?\n\t// {{{\n\tassign\tw_wF     = (w_cmptst)\n\t\t\t||((w_cond[3])&&(w_fpu||w_div\n\t\t\t\t||((w_ALU)&&(!w_mov)&&(!w_ldilo)&&(!w_brev)\n\t\t\t\t\t&&(w_dcdR[3:1] != 3'h7))));\n\t// }}}\n\n\t// w_immsrc - where does the immediate value come from\n\t// {{{\n\t// Bottom 13 bits: no LUT's\n\t// w_dcd[12: 0] -- no LUTs\n\t// w_dcd[   13] -- 2 LUTs\n\t// w_dcd[17:14] -- (5+i0+i1) = 3 LUTs, 1 delay\n\t// w_dcd[22:18] : 5 LUTs, 1 delay (assuming high bit is o/w determined)",
            "wire [22:0]\tw_I, w_fullI;\n\n\t// w_fullI -- extracting the immediate value from the insn word\n\t// {{{\n\tassign\tw_fullI = (w_ldi) ? { iword[22:0] } // LDI\n\t\t\t// MOVE immediates have one less bit\n\t\t\t:((w_mov) ?{ {(23-13){iword[12]}}, iword[12:0] }\n\t\t\t// Normal Op-B immediate ... 18 or 14 bits\n\t\t\t:((!iword[IMMSEL]) ? { {(23-18){iword[17]}}, iword[17:0] }\n\t\t\t: { {(23-14){iword[13]}}, iword[13:0] }\n\t\t\t));\n\t// }}}\n\n\t// w_I and w_Iz: Immediate value decoding\n\t// {{{\n\tgenerate if (OPT_CIS)\n\tbegin : GEN_CIS_IMMEDIATE",
            "wire [7:0]\tw_halfbits;\n\t\tassign\tw_halfbits = iword[CISIMMSEL:16];",
            "wire [7:0]\tw_halfI;\n\t\tassign\tw_halfI = (iword[26:24]==3'h6) ? w_halfbits[7:0] // 8'b for LDI\n\t\t\t\t:(w_halfbits[7])?\n\t\t\t\t\t{ {(6){w_halfbits[2]}}, w_halfbits[1:0]}\n\t\t\t\t\t:{ w_halfbits[6], w_halfbits[6:0] };\n\t\tassign\tw_I  = (iword[CISBIT])\n\t\t\t\t? {{(23-8){w_halfI[7]}}, w_halfI }\n\t\t\t\t: w_fullI;\n\n\tend else begin : GEN_NOCIS_IMMEDIATE\n\n\t\tassign\tw_I  = w_fullI;\n\n\tend endgenerate\n\n\t// }}}\n\t// }}}\n\n\t// illegal_shift\n\t// {{{\n\tgenerate if (OPT_SHIFTS)\n\tbegin\n\t\tassign\tillegal_shift = 1'b0;\n\tend else begin",
            "reg r_illegal_shift;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tr_illegal_shift = 1'b1;\n\t\t\tif (i_instruction[CISBIT])\n\t\t\t\tr_illegal_shift = 1'b0;\n\t\t\telse if ((i_instruction[26:22] == 5'h5)\n\t\t\t\t||(i_instruction[26:22] == 5'h6)\n\t\t\t\t||(i_instruction[26:22] == 5'h7))\n\t\t\t\tr_illegal_shift = 1'b0;\n\t\t\telse if (!i_instruction[18]\n\t\t\t\t\t&& i_instruction[17:0] == 18'h1)\n\t\t\t\tr_illegal_shift = 1'b0;\n\t\tend\n\n\t\tassign\tillegal_shift = r_illegal_shift;\n\tend endgenerate\n\t// }}}\n\n\t// o_illegal\n\t// {{{\n\tinitial\to_illegal = 1'b0;\n\talways @(*)\n\tbegin\n\t\to_illegal = 1'b0;\n\n\t\tif (illegal_shift)\n\t\t\to_illegal = 1'b1;\n\n\t\tif ((!OPT_CIS)&&(i_instruction[CISBIT]))\n\t\t\to_illegal = 1'b1;\n\t\tif ((!OPT_MPY)&&(w_mpy))\n\t\t\to_illegal = 1'b1;\n\n\t\tif ((!OPT_DIVIDE)&&(w_div))\n\t\t\to_illegal = 1'b1;\n\t\telse if ((OPT_DIVIDE)&&(w_div)&&(w_dcdR[3:1]==3'h7))\n\t\t\to_illegal = 1'b1;\n\n\n\t\tif (!OPT_FPU && w_fpu)\n\t\t\to_illegal = 1'b1;\n\n\t\tif ((!OPT_SIM)&&(w_sim))\n\t\t// Simulation instructions on real hardware should\n\t\t// always cause an illegal instruction error\n\t\t\to_illegal = 1'b1;\n\n\t\t// There are two (missing) special instructions, after\n\t\t// BREAK, LOCK, SIM, and NOOP.  These are special if their\n\t\t// (unused-result)",
            "reg ister is either the PC or CC",
            "reg ister.\n\t\t//\n\t\t// These should cause an illegal instruction error\n\t\tif ((w_dcdR[3:1]==3'h7)&&(w_cis_op[4:1]==4'b1101))\n\t\t\to_illegal = 1'b1;\n\n\t\t// If the lock function isn't implemented, this should\n\t\t// also cause an illegal instruction error\n\t\tif ((!OPT_LOCK)&&(w_lock))\n\t\t\to_illegal = 1'b1;\n\tend\n\t// }}}\n\n\tgenerate if (OPT_OPIPE)\n\tbegin\n\t\t// o_prepipe is true if a pipelined memory instruction\n\t\t// might follow this one\n\t\tassign\to_prepipe =\n\t\t\t\t((OPT_CIS)||(!i_instruction[CISBIT]))\n\t\t\t\t&&(o_M)&&(o_rB)\n\t\t\t\t&&(o_dcdB[3:1] != 3'h7)\n\t\t\t\t&&(o_dcdR[3:1] != 3'h7)\n\t\t\t\t&&((!o_wR)||(o_dcdR != o_dcdB));\n\tend else begin\n\t\tassign\to_prepipe = 1'b0;\n\tend endgenerate\n\n\tassign\to_dcdR = { w_dcdR_cc, w_dcdR_pc, w_dcdR};\n\tassign\to_dcdA = { w_dcdA_cc, w_dcdA_pc, w_dcdA};\n\tassign\to_dcdB = { w_dcdB_cc, w_dcdB_pc, w_dcdB};\n\tassign\to_I = { {(32-22){w_I[22]}}, w_I[21:0] };\n\tassign\to_cond = w_cond;\n\tassign\to_wF   = w_wF;\n\tassign\to_op   = ((w_ldi)||(w_noop))? 4'hd : w_cis_op[3:0];\n\tassign\to_ALU  =  (w_ALU)||(w_ldi)||(w_cmptst)||(w_noop);\n\tassign\to_M    = w_mem;\n\tassign\to_DV   = (OPT_DIVIDE)&&(w_div);\n\tassign\to_FP   = (OPT_FPU)&&(w_fpu);\n\tassign\to_break= w_break;\n\tassign\to_lock = (OPT_LOCK)&&(w_lock);\n\tassign\to_wR   = w_wR;\n\tassign\to_rA   = w_rA;\n\tassign\to_rB   = w_rB;\n\tassign\to_sim      = (OPT_SIM) ? ((w_sim)||(w_noop)) : 1'b0;\n\tassign\to_sim_immv = (OPT_SIM && (!OPT_LOWPOWER || o_sim)) ? iword[22:0] : 0;",
            "endmodule "
        ]
    },
    {
        "file_name": "fmem.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/formal/fmem.v",
        "chunks": [
            "reg The",
            "reg ister to write the return data back to\n//\ti_busy\t\tWhether the memory unit is busy doing something or not.\n//\t\t\tIf the memory unit is busy, it may still accept\n//\t\t\tfurther reads (during a read cycle), or further writes\n//\t\t\t(during a write cycle) if i_pipe_stalled is clear.\n//\n//\t\t\tNote that just because the memory unit is busy doesn't\n//\t\t\tmean it's busy doing anything relevant for the CPU.\n//\t\t\tThe CPU may have issued a command, and then been reset.\n//\t\t\tIn that case, the memory unit may still need to complete\n//\t\t\tthe last command.\n//\ti_rdbusy\tNot only is the memory unit busy, but it's busy in a\n//\t\t\tway where it might write data back to the CPU when it\n//\t\t\tis done.\n//\ti_valid\t\tA read has completed, the data for that read is now\n//\t\t\tavailable in i_result, to be written to i_w",
            "reg //\ti_done\t\tAn operation has completed--either read or write\n//\ti_err\t\tA bus error has occurred.  It may or may not be clear\n//\t\t\twhich instruction caused it.  The CPU should begin any\n//\t\t\texception handling.\n//\ti_w",
            "reg If i_valid is true, this is the",
            "reg ister that the\n//\t\t\tresult needs to be written to.\n//\ti_result\tThe result of the last read\n//\n// Other ports are useful for synchronizing these formal properties to the\n// CPU.  These include:\n//\n//\tf_outstanding\tA counter of how many requests are outstanding.  This\n//\t\t\tis incremented on every i_stb, and decremented on every\n//\t\t\ti_done.\n//\tf_pc\t\tTrue if the last read will be written to either the\n//\t\t\tflags",
            "reg ister or the program counter.\n//\tf_gie\t\tTrue if the",
            "reg isters to be read are user mode\n//",
            "reg isters (i.e. the \"Global Interrupt Enable\" for the\n//\t\t\tZipCPU is set), requested by the CPU within user mode,\n//\t\t\tor clear if they are supervisor",
            "reg isters (the Global\n//\t\t\tInterrupt Enable, or gie bit, is clear).  The memory\n//\t\t\tunit will only do one or the other, never both.\n//\tf_read_cycle\tTrue if we are in a read cycle (i.e. a load), false\n//\t\t\tduring any store operations.  The memory must cease\n//\t\t\tto be busy before switching directions.\n//\tf_axi_write_cycle\n//\t\t\tTrue if we are in an AXI exclusive access write cycle.\n//\t\t\tIf this cycle fails, the write will return and require\n//\t\t\ta write to the program counter.\n//\tf_last_",
            "reg The last read",
            "reg ister.  Once data is returned to this\n//",
            "reg ister, the current string or reads will be complete.\n//\tf_addr_",
            "reg The base address",
            "reg ister.  On any string of reads,\n//\t\t\tthe CPU will guarantee that the loads are not stored\n//\t\t\tinto the base address",
            "reg ister unless it is the last\n//",
            "reg ister in any sequence.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2020-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n//\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype none\n// }}}",
            "module fmem #(\n\t\t// {{{\n\t\t// OPT_LOCK\n\t\t// {{{\n\t\t// If false, forces the i_lock",
            "parameter to be zero and\n\t\t// guarantees no bus locking.  Can be set to 1'b1 to test both\n\t\t// with and without bus locking.\n\t\t// }}}",
            "parameter [0:0]\tOPT_LOCK = 1'b0,\n\t\t// F_LGDEPTH\n\t\t// {{{\n\t\t// This is the number of bits required to hold our internal\n\t\t// counters.  It should have a sufficient number of bits to\n\t\t// hold the OPT_MAXDEPTH.\n\t\t// }}}",
            "parameter F_LGDEPTH = 4,\n\t\t// OPT_MAXDEPTH\n\t\t// {{{\n\t\t// OPT_MAXDEPTH is the maximum number of requests which may be\n\t\t// outstanding at any given time\n\t\t// }}}",
            "parameter [F_LGDEPTH-1:0]\tOPT_MAXDEPTH = 1,\n\t\t// OPT_AXI_LOCK\n\t\t// {{{\n\t\t// AXI locks have special semantics.  When a lock takes place\n\t\t// with AXI semantics, there must be a locked read followed by\n\t\t// a locked write.  The locked write is treated as a read that\n\t\t// might write back to the program counter of the CPU, and so\n\t\t// rdbusy will be true during the locked write.  If you want to\n\t\t// check both the AXI and non-AXI lock semantics, feel free to\n\t\t// set this to one.",
            "parameter OPT_AXI_LOCK = 0\n\t\t// }}}\n\t\t// }}}\n\t) (\n\t\t// {{{\n\t\t//\n\t\t// See above comments for a description of these signals\n\t\t//",
            "input ",
            "wire i_clk,",
            "input ",
            "wire i_sys_reset,",
            "input ",
            "wire i_cpu_reset,\n\t\t//\n\t\t// CPU interface",
            "input ",
            "wire i_stb,",
            "input ",
            "wire i_pipe_stalled,",
            "input ",
            "wire i_clear_cache,",
            "input ",
            "wire i_lock,",
            "input ",
            "wire [2:0]\t\ti_op,",
            "input ",
            "wire [31:0]\t\ti_addr,",
            "input ",
            "wire [31:0]\t\ti_data,",
            "input ",
            "wire [4:0]\t\ti_o",
            "reg ,",
            "input ",
            "wire [4:0]\t\ti_a",
            "reg , // Base address",
            "reg ister\n\t\t//",
            "input ",
            "wire i_busy,",
            "input ",
            "wire i_rdbusy,",
            "input ",
            "wire i_valid,",
            "input ",
            "wire i_done,",
            "input ",
            "wire i_err,",
            "input ",
            "wire [4:0]\t\ti_w",
            "reg ,",
            "input ",
            "wire [31:0]\t\ti_result,\n\t\t//",
            "output ",
            "reg [F_LGDEPTH-1:0]\tf_outstanding,",
            "output ",
            "reg f_pc,",
            "output ",
            "reg f_gie,",
            "output ",
            "reg f_read_cycle,",
            "output ",
            "reg f_axi_write_cycle,",
            "output ",
            "reg [4:0]\t\tf_last_",
            "reg ,",
            "output ",
            "reg [4:0]\t\tf_addr_",
            "reg // ,",
            "output ",
            "reg f_endpipe,\n\t\t// }}}\n\t);\n\n\t// Declarations and setup\n\t// {{{\n`ifdef\tZIPCPU\n`define\tCPU_ASSUME\tassume\n`define\tCPU_ASSERT\tassert\n`else\n`define\tCPU_ASSUME\tassert\n`define\tCPU_ASSERT\tassume\n`endif",
            "reg f_past_valid;",
            "reg past_stb, past_rd, past_busy;\n\t// Verilator lint_off UNDRIVEN\n\t(* anyconst *)",
            "reg f_check_axi_lock;\n\t// Verilator lint_on  UNDRIVEN\n\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Reset checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_sys_reset);\n\n\talways @(*)\n\tif (i_sys_reset)\n\t\tassume(i_cpu_reset);\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_cpu_reset))\n\tbegin\n\t\t`CPU_ASSUME(!i_valid);\n\t\t`CPU_ASSUME(!i_done);\n\t\t`CPU_ASSUME(!i_err);\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\talways @(*)\n\tif (!f_past_valid || !i_busy)\n\t\t`CPU_ASSUME(!i_rdbusy);\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_sys_reset || i_cpu_reset))\n\t\t`CPU_ASSUME(!i_rdbusy);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && !$past(i_busy || i_stb))\n\t\t`CPU_ASSUME(!i_busy);\n\n\talways @(*)\n\t\t`CPU_ASSUME(!i_valid || !i_err);\n\n\tinitial\tf_outstanding = 0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || i_err)\n\t\tf_outstanding <= 0;\n\telse casez({ i_stb, i_done })\n\t2'b10: f_outstanding <= f_outstanding + 1;\n\t2'b01: f_outstanding <= f_outstanding - 1;\n\tdefault: begin end\n\tendcase\n\n\talways @(*)\n\tif (f_outstanding == 0)\n\t\t`CPU_ASSUME(!i_done && !i_err);\n\n\talways @(*)\n\t\tassert(f_outstanding <= OPT_MAXDEPTH);\n\n\talways @(*)\n\tif (f_outstanding == OPT_MAXDEPTH + ((i_done || i_err) ? 1:0))\n\t\t`CPU_ASSUME(i_pipe_stalled);\n\n\talways @(*)\n\tif (!i_err && f_outstanding > ((i_done || i_err) ? 1:0))\n\t\t`CPU_ASSUME(i_busy);\n\n\t// The CPU is not allowed to write to the CC",
            "reg ister while a memory\n\t// read operation is ongoing, lest any resulting bus error get returned\n\t// to the wrong mode--i.e. user bus error halting the supervisor.  What\n\t// this means, though, is that the CPU will *never* attempt to clear\n\t// any cache while the cache is busy.\n\talways @(*)\n\tif (!i_cpu_reset && f_outstanding > 0 && i_rdbusy)\n\t\t`CPU_ASSERT(!i_clear_cache);\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_cpu_reset))\n\tbegin\n\t\t`CPU_ASSERT(!i_stb);\n\t\n\t\t// If we reset the CPU but not the bus, the bus might still\n\t\t// be busy for a while.  Same as if we are using AXI and we\n\t\t// get an error--we still have to flush the rest of what's\n\t\t// on the bus.  It's just that ... the CPU doesn't need to wait,\n\t\t// same as if it were writing something to the bus.\n\t\t//\n\t\t`CPU_ASSUME(!i_rdbusy);\n\n\t\t`CPU_ASSUME(!i_valid);\n\t\t`CPU_ASSUME(!i_err);\n\tend else if ($past(i_err))\n\tbegin\n\t\t`CPU_ASSERT(!i_stb);\n\tend\n\n\t// Stability while stalled\n\t// {{{\n\talways @(posedge i_clk)\n\tif (f_past_valid && $past(i_stb && i_pipe_stalled && !i_cpu_reset))\n\tbegin\n\t\t`CPU_ASSERT(i_stb);\n\t\t`CPU_ASSERT($stable(i_addr));\n\t\t`CPU_ASSERT($stable(i_data));\n\t\t`CPU_ASSERT($stable(i_o",
            "reg ));\n\t\t// `CPU_ASSERT($stable(i_lock));\n\tend\n\t// }}}\n\n\talways @(*)\n\tif (!OPT_LOCK)\n\t\t`CPU_ASSERT(!i_stb || !i_lock);\n\n\talways @(posedge i_clk)\n\tif (OPT_LOCK && f_past_valid && !$past(i_cpu_reset))\n\tbegin\n\t//\tif ($past(!i_lock && (!i_stb || i_busy)))\n\t//\t\t`CPU_ASSERT(!i_lock);\n\tend\n\n\talways @(*)\n\tif (!i_done)\n\tbegin\n\t\t`CPU_ASSUME(!i_valid);\n\tend else if (i_rdbusy)\n\t\t`CPU_ASSUME(i_valid);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && !$past(i_rdbusy))\n\tbegin\n\t\t`CPU_ASSUME(!i_valid);\n\tend else if (f_past_valid && $past(i_rdbusy) && f_axi_write_cycle)\n\tbegin\n\t\t`CPU_ASSUME(f_outstanding == 1);\n\t\tif (i_valid)\n\t\tbegin\n\t\t\t`CPU_ASSUME(i_w",
            "reg [3:0] == 4'hf && i_done);\n\t\tend else\n\t\t\t`CPU_ASSUME(i_rdbusy || i_done || i_err);\n\tend else if (f_past_valid && !i_err && $past(i_rdbusy)\n\t\t\t&& (f_outstanding > (i_valid ? 1:0)))\n\t\t`CPU_ASSUME(i_rdbusy);\n\n\tinitial\tpast_stb = 1'b0;\n\talways @(posedge i_clk)\n\t\tpast_stb <= i_stb && !i_cpu_reset && !i_err;\n\n\tinitial\tpast_rd = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || i_err)\n\t\tpast_rd <= 1'b0;\n\telse if (i_stb && !i_op[0])\n\t\tpast_rd <= 1'b1;\n\telse\n\t\tpast_rd <= i_rdbusy && (f_outstanding > (i_valid ? 1:0));\n\n\t// Can only become busy on a CPU reset or a bus request\n\tinitial\tpast_busy = 1'b1;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || i_stb)\n\t\tpast_busy <= 1'b1;\n\telse if (!i_busy)\n\t\tpast_busy <= 1'b0;\n\n\talways @(*)\n\tif (!past_busy)\n\t\t`CPU_ASSUME(!i_busy);\n\n\talways @(*)\n\t\t`CPU_ASSUME(!i_rdbusy || !i_err);\n\n\talways @(*)\n\tif (past_stb)\n\tbegin\n\t\t`CPU_ASSUME(i_busy || i_valid || i_err);\n\n\t\tif (i_busy)\n\t\t\t`CPU_ASSUME(i_err || i_rdbusy == past_rd || f_axi_write_cycle);\n\tend else if (!past_rd || !i_busy)\n\t\t`CPU_ASSUME(!i_rdbusy);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && !$past(i_cpu_reset))\n\tbegin\n\t\t//\n\t\t// Will never happen, 'cause i_stb can't be true when i_busy\n\t\t//\n\t\tif ($past(i_stb && i_pipe_stalled) && i_stb)\n\t\tbegin\n\t\t\t`CPU_ASSERT($stable(i_op));\n\t\t\t`CPU_ASSERT($stable(i_addr));\n\t\t\t`CPU_ASSERT($stable(i_data));\n\t\t\t`CPU_ASSERT($stable(i_o",
            "reg ));\n\t\t\t`CPU_ASSERT($stable(i_lock));\n\t\tend\n\tend\n\n\talways @(*)\n\tif (i_stb)\n\t\t`CPU_ASSERT(i_op[2:1] != 2'b00);\n\n\t//\n\t// This is guaranteed by the CPU: No new requests during busy.  It\n\t// isn't necessarily required by most handshaking interfaces, but the\n\t// CPU needs it in order to make certain that it doesn't accidentally\n\t// issue instructions.  It's part of the CPU pipeline",
            "logic .\n\talways @(*)\n\tif (!i_cpu_reset && i_busy && f_outstanding > 0)\n\t\t`CPU_ASSERT(!i_clear_cache);\n\n\talways @(*)\n\tif (i_clear_cache)\n\t\t`CPU_ASSERT(!i_stb);\n\n\talways @(*)\n\tif (i_pipe_stalled)\n\t\t`CPU_ASSERT(!i_stb);\n\n\talways @(*)\n\tif (!i_busy)\n\t\t`CPU_ASSUME(!i_pipe_stalled);\n\n\t// Reads must always complete before writes, and vice versa\n\talways @(*)\n\tif (i_stb && i_busy)\n\t\t`CPU_ASSERT(f_read_cycle == !i_op[0]);\n\n\t// always @(posedge i_clk)\n\t// if (f_past_valid && $past(i_busy && !i_pipe_stalled && !i_stb))\n\t//\t`CPU_ASSERT(!i_stb || i_lock);\n\n\t//\n\t// This is also required of the CPU pipeline",
            "logic .  Following any\n\t// error the pipeline needs to be cleared.  That means that, on an\n\t// error, you can't have any new requests\n\talways @(*)\n\tif (i_err)\n\t\t`CPU_ASSERT(!i_stb);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && $past(i_cpu_reset || i_err))\n\t\t`CPU_ASSERT(!i_stb);\n\n\talways @(*)\n\tif (i_rdbusy)\n\t\t`CPU_ASSERT(!i_stb || !i_op[0]);\n\n\talways @(*)\n\tif (i_rdbusy)\n\t\t`CPU_ASSUME(i_busy);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// f_addr_",
            "reg , f_last_",
            "reg , f_pc properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// The last",
            "reg ister\n\t// {{{\n\t// For pipeline hazard purposes, it's important to be able to know and\n\t// track the last",
            "reg ister that will be returned to the CPU.\n\talways @(posedge i_clk)\n\tif (i_stb && !i_pipe_stalled)\n\tbegin\n\t\tf_last_",
            "reg <= i_o",
            "reg ;\n\t\tif (OPT_LOCK && f_check_axi_lock && i_op[0] && i_lock)\n\t\t\tf_last_",
            "reg [3:0] <= 4'hf;\n\tend\n\n\talways @(*)\n\tif (f_outstanding == 1 && i_valid && !f_axi_write_cycle)\n\t\t`CPU_ASSUME(f_last_",
            "reg == i_w",
            "reg );\n\n\talways @(*)\n\tif (f_axi_write_cycle)\n\tbegin\n\t\t`CPU_ASSUME(f_last_",
            "reg [3:0] == 4'hf);\n\t\tassert(f_outstanding == 1);\n\tend\n\t// }}}\n\n\t//\n\t// The base address",
            "reg ister\n\t// {{{\n\t// In any string of reads, the ZipCPU will only ever use a single\n\t// base address.  The ZipCPU will *not* read into the base address\n\t//",
            "reg ister unless that read is the last in the string of reads.\n\talways @(posedge i_clk)\n\tif (i_stb)\n\t\tf_addr_",
            "reg <= i_a",
            "reg ;\n\n\talways @(*)\n\tif (i_stb && i_rdbusy)\n\t\t`CPU_ASSERT(i_a",
            "reg == f_addr_",
            "reg );\n\n\talways @(*)\n\tif (i_rdbusy)\n\t\t`CPU_ASSERT(!i_stb || f_last_",
            "reg != i_a",
            "reg );\n\n\talways @(*)\n\tif (i_rdbusy && i_valid)\n\tbegin\n\t\tif (f_outstanding > 1)\n\t\t\t`CPU_ASSUME(i_w",
            "reg != f_addr_",
            "reg );\n\tend\n\t// }}}\n\n\t// f_pc\n\t// {{{\n\t// True if any",
            "reg ister will return a write to either the program\n\t// counter or the CC",
            "reg ister.  If such a read exists, it must be the\n\t// last in a sequence.\n\tinitial\tf_pc = 0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || i_err)\n\t\tf_pc <= 0;\n\telse if (i_stb && !i_op[0] && i_o",
            "reg [3:1] == 3'h7)\n\t\tf_pc <= 1'b1;\n\telse if (f_check_axi_lock && i_stb && i_op[0] && i_lock)\n\t\tf_pc <= 1'b1;\n\telse if (i_valid && i_w",
            "reg [3:1] == 3'h7)\n\t\tf_pc <= 1'b0;\n\telse if (f_axi_write_cycle && i_done)\n\t\tf_pc <= 1'b0;\n\n\t//\n\t// Once the CPU issues a request to read into one of the special\n\t//",
            "reg isters (either CC, or PC), it will not issue another read request\n\t// until this request has completed.\n\talways @(*)\n\tif (f_pc && f_read_cycle)\n\t\t`CPU_ASSERT(!i_stb);\n\n\talways @(*)\n\tif (f_pc && !f_read_cycle && f_axi_write_cycle\n\t\t\t&& f_outstanding > ((i_done || i_err) ? 1:0))\n\t\t`CPU_ASSUME(i_pipe_stalled);\n\n\talways @(*)\n\tif (f_last_",
            "reg [3:1] != 3'h7)\n\tbegin\n\t\tassert(!f_pc || f_axi_write_cycle);\n\tend else if (i_rdbusy)\n\t\tassert(f_pc);\n\n\talways @(*)\n\tif (f_pc)\n\tbegin\n\t\t`CPU_ASSUME(f_read_cycle || f_axi_write_cycle);\n\t\tif (f_axi_write_cycle)\n\t\tbegin\n\t\t\tassert(f_check_axi_lock);\n\t\t\t`CPU_ASSUME(f_outstanding == 1);\n\t\tend else begin\n\t\t\tif (f_outstanding > 1 && !i_err)\n\t\t\tbegin\n\t\t\t\t`CPU_ASSUME(!i_valid || i_w",
            "reg [3:1] != 3'h7);\n\t\t\tend else if (f_outstanding == 1 && i_valid)\n\t\t\t\t`CPU_ASSUME(i_w",
            "reg [3:1] == 3'h7);\n\t\t\t`CPU_ASSUME(f_outstanding > 0);\n\t\tend\n\tend else if (i_valid)\n\t\t`CPU_ASSUME(!i_valid || i_w",
            "reg [3:1] != 3'h7);\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// f_gie properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(posedge i_clk)\n\tif (i_stb)\n\t\tf_gie <= i_o",
            "reg [4];\n\n\talways @(*)\n\tif (i_stb && f_outstanding > 0)\n\t\t`CPU_ASSERT(f_gie == i_o",
            "reg [4]);\n\n\talways @(*)\n\tif (i_valid)\n\t\t`CPU_ASSUME(f_gie == i_w",
            "reg [4]);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// f_axi_write_cycle properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (OPT_AXI_LOCK == 0 || !OPT_LOCK)\n\tbegin\n\t\tassume(f_check_axi_lock == 1'b0);\n\tend else if (OPT_AXI_LOCK == 1)\n\t\tassume(f_check_axi_lock == 1'b1);\n\n\tinitial\tf_axi_write_cycle = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || i_clear_cache || !f_check_axi_lock)\n\t\tf_axi_write_cycle <= 1'b0;\n\telse if (i_stb && i_lock && i_op[0])\n\t\tf_axi_write_cycle <= 1'b1;\n\telse if (i_err || i_valid || !i_rdbusy)\n\t\tf_axi_write_cycle <= 1'b0;\n\n\talways @(*)\n\tif (!f_check_axi_lock)\n\t\tassert(f_axi_write_cycle == 0);\n\n\talways @(*)\n\tif (f_axi_write_cycle)\n\t\t`CPU_ASSUME(i_rdbusy || i_valid || i_err || i_done);\n\n\talways @(*)\n\tif (f_axi_write_cycle)\n\t\tassert(f_pc);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// f_read_cycle properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tinitial\tf_read_cycle = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || i_clear_cache)\n\t\tf_read_cycle <= 1'b0;\n\telse if (i_stb)\n\t\tf_read_cycle <= !i_op[0];\n\telse if (!i_busy)\n\t\tf_read_cycle <= 1'b0;\n\n\talways @(*)\n\tif (!f_read_cycle)\n\tbegin\n\t\tif (!f_axi_write_cycle)\n\t\tbegin\n\t\t\t`CPU_ASSUME(!i_rdbusy);\n\t\t\t`CPU_ASSUME(!i_valid);\n\t\tend\n\tend else if (i_done)\n\tbegin\n\t\t`CPU_ASSUME(i_valid || i_err);\n\t\tif (!i_err)\n\t\t`CPU_ASSUME((f_outstanding <= (i_valid ? 1:0)) || i_rdbusy);\n\tend\n\n\talways @(*)\n\t\t`CPU_ASSUME(!f_read_cycle || !f_axi_write_cycle);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Address",
            "reg ister checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Here's the (to be written) rule: During a string of operations,\n\t// there is one address",
            "reg ister.\n/*\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_endpipe <= 1'b1;\n\telse if (i_stb)\n\t\tf_endpipe <= i_op[0] || (i_o",
            "reg == i_a",
            "reg );\n\n\talways @(posedge i_clk)\n\tif (i_stb)\n\t\tf_addr_",
            "reg <= i_a",
            "reg ;\n\n\t//\n\t// Mid cycle, the CPU can't add a new",
            "reg ister to the end\n\talways @(*)\n\tif (f_read_cycle && (i_valid || f_outstanding > 0) && i_stb && !i_op[0])\n\tbegin\n\t\t`CPU_ASSERT(!f_endpipe);\n\t\t`CPU_ASSERT(i_o",
            "reg != f_addr_",
            "reg );\n\tend\n\n\n\t//\n\t// Only the last item can write to the address",
            "reg ister, and that only\n\t// if f_endpipe is true.\n\talways @(*)\n\tif (f_read_cycle && !i_err && i_valid)\n\tbegin\n\t\t// If we aren't ever writing to the address",
            "reg ister\n\t\t// ... or if we are, the address",
            "reg ister must be the last\n\t\t//",
            "reg ister to be returned, then don't allow a write response\n\t\t// to the address",
            "reg ister\n\t\tif (!f_endpipe || f_outstanding > (i_valid ? 1:0))\n\t\t\t`CPU_ASSUME(!i_valid || i_w",
            "reg != f_addr_",
            "reg );\n\tend\n*/\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg [3:0]\tcvr_returns, cvr_errors;\n\n\tinitial\tcvr_returns = 0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset)\n\t\tcvr_returns <= 0;\n\telse if (i_valid && !cvr_returns[3])\n\t\tcvr_returns <= cvr_returns + 1;\n\n\talways @(*)\n\t\tcover(cvr_returns > 4);\n\n\tinitial\tcvr_errors = 0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset)\n\t\tcvr_errors <= 0;\n\telse if (i_err && !cvr_errors[3])\n\t\tcvr_errors <= cvr_errors + 1;\n\n\talways @(*)\n\t\tcover(cvr_returns > 2);\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, i_result };\n\t// Verilator lint_on  UNUSED\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipbones.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/mcy/zipcpu/zipbones.v",
        "chunks": [
            "module .\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// Copyright (C) 2015-2019, Gisselquist Technology, LLC\n//\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of  the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n//\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype\tnone\n//\n`include \"cpudefs.v\"\n//\n`define\tRESET_BIT\t6\n`define\tSTEP_BIT\t8\n`define\tHALT_BIT\t10\n`define\tCLEAR_CACHE_BIT\t11\n//",
            "module zipbones(i_clk, i_reset,\n\t\t// Wishbone master interface from the CPU\n\t\to_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, o_wb_sel,\n\t\t\ti_wb_stall, i_wb_ack, i_wb_data, i_wb_err,\n\t\t// Incoming interrupts\n\t\ti_ext_int,\n\t\t// Our one outgoing interrupt\n\t\to_ext_int,\n\t\t// Wishbone slave interface for debugging purposes\n\t\ti_dbg_cyc, i_dbg_stb, i_dbg_we, i_dbg_addr, i_dbg_data,\n\t\t\to_dbg_stall, o_dbg_ack, o_dbg_data,\n\t\tmutsel\n`ifdef\tDEBUG_SCOPE\n\t\t, o_cpu_debug\n`endif\n\t\t);",
            "parameter RESET_ADDRESS=32'h0100000, ADDRESS_WIDTH=30,\n\t\t\tLGICACHE=8;",
            "parameter [0:0]\tSTART_HALTED=0;",
            "parameter EXTERNAL_INTERRUPTS=1,\n`ifdef\tOPT_MULTIPLY\n\t\t\tIMPLEMENT_MPY = `OPT_MULTIPLY;\n`else\n\t\t\tIMPLEMENT_MPY = 0;\n`endif",
            "parameter [0:0]\n`ifdef\tOPT_DIVIDE\n\t\t\tIMPLEMENT_DIVIDE=1,\n`else\n\t\t\tIMPLEMENT_DIVIDE=0,\n`endif\n`ifdef\tOPT_IMPLEMENT_FPU\n\t\t\tIMPLEMENT_FPU=1,\n`else\n\t\t\tIMPLEMENT_FPU=0,\n`endif\n\t\t\tIMPLEMENT_LOCK=1;",
            "localparam // Derived",
            "parameter s\n\t\t\tPHYSICAL_ADDRESS_WIDTH=ADDRESS_WIDTH,\n\t\t\tPAW=ADDRESS_WIDTH,\n`ifdef\tOPT_MMU\n\t\t\tVIRTUAL_ADDRESS_WIDTH=30,\n`else\n\t\t\tVIRTUAL_ADDRESS_WIDTH=PAW,\n`endif\n\t\t\tLGTLBSZ = 6,\n\t\t\tVAW=VIRTUAL_ADDRESS_WIDTH;",
            "localparam AW=ADDRESS_WIDTH;",
            "input ",
            "wire i_clk, i_reset;\n\t// Wishbone master",
            "output ",
            "wire o_wb_cyc, o_wb_stb, o_wb_we;",
            "output ",
            "wire [(PAW-1):0]\to_wb_addr;",
            "output ",
            "wire [31:0]\to_wb_data;",
            "output ",
            "wire [3:0]\to_wb_sel;",
            "input ",
            "wire i_wb_stall, i_wb_ack;",
            "input ",
            "wire [31:0]\ti_wb_data;",
            "input ",
            "wire i_wb_err;\n\t// Incoming interrupts",
            "input ",
            "wire i_ext_int;\n\t// Outgoing interrupt",
            "output ",
            "wire o_ext_int;\n\t// Wishbone slave",
            "input ",
            "wire i_dbg_cyc, i_dbg_stb, i_dbg_we, i_dbg_addr;",
            "input ",
            "wire [31:0]\ti_dbg_data;",
            "output ",
            "wire o_dbg_ack;",
            "output ",
            "wire o_dbg_stall;",
            "output ",
            "wire [31:0]\to_dbg_data;\n\t//",
            "input ",
            "wire [7:0]\tmutsel;\n\t//\n`ifdef\tDEBUG_SCOPE",
            "output ",
            "wire [31:0]\to_cpu_debug;\n`endif",
            "wire dbg_cyc, dbg_stb, dbg_we, dbg_addr, dbg_stall;",
            "wire [31:0]\tdbg_idata, dbg_odata;",
            "reg dbg_ack;\n\n\tassign\tdbg_cyc     = i_dbg_cyc;\n\tassign\tdbg_stb     = i_dbg_stb;\n\tassign\tdbg_we      = i_dbg_we;\n\tassign\tdbg_addr    = i_dbg_addr;\n\tassign\tdbg_idata   = i_dbg_data;\n\tassign\to_dbg_ack   = dbg_ack;\n\tassign\to_dbg_stall = dbg_stall;\n\tassign\to_dbg_data  = dbg_odata;\n\t//\n\t// The external debug interface\n\t//\n\t// We offer only a limited interface here, requiring a pre-",
            "reg ister\n\t// write to set the local address.  This interface allows access to\n\t// the Zip System on a debug basis only, and not to the rest of the\n\t// wishbone bus.  Further, to access these",
            "reg isters, the control\n\t//",
            "reg ister must first be accessed to both stop the CPU and to \n\t// set the following address in question.  Hence all accesses require\n\t// two accesses: write the address to the control",
            "reg ister (and halt\n\t// the CPU if not halted), then read/write the data from the data\n\t//",
            "reg ister.\n\t//",
            "wire cpu_break, dbg_cmd_write;",
            "reg cmd_reset, cmd_halt, cmd_step, cmd_clear_pf_cache;",
            "reg [4:0]\tcmd_addr;",
            "wire [3:0]\tcpu_dbg_cc;\n\tassign\tdbg_cmd_write = (dbg_stb)&&(dbg_we)&&(!dbg_addr);\n\t//\n\t// Always start us off with an initial reset\n\t//\n\tinitial\tcmd_reset = 1'b1;\n\talways @(posedge i_clk)\n\t\tcmd_reset <= ((dbg_cmd_write)&&(dbg_idata[`RESET_BIT]));\n\t//\n\tinitial\tcmd_halt  = START_HALTED;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tcmd_halt <= START_HALTED;\n\telse if (cmd_reset)\n\t\tcmd_halt <= START_HALTED;\n\telse if (dbg_cmd_write)\n\t\tcmd_halt <= ((dbg_idata[`HALT_BIT])&&(!dbg_idata[`STEP_BIT]));\n\telse if ((cmd_step)||(cpu_break))\n\t\tcmd_halt  <= 1'b1;\n\n\tinitial\tcmd_clear_pf_cache = 1'b1;\n\talways @(posedge i_clk)\n\t\tcmd_clear_pf_cache <= (dbg_cmd_write)&&(dbg_idata[`CLEAR_CACHE_BIT]);\n\t//\n\tinitial\tcmd_step  = 1'b0;\n\talways @(posedge i_clk)\n\t\tcmd_step <= (dbg_cmd_write)&&(dbg_idata[`STEP_BIT]);\n\t//\n\tinitial\tcmd_addr = 5'h0;\n\talways @(posedge i_clk)\n\t\tif (dbg_cmd_write)\n\t\t\tcmd_addr <= dbg_idata[4:0];",
            "wire cpu_reset;\n\tassign\tcpu_reset = (cmd_reset);",
            "wire cpu_halt, cpu_dbg_stall;\n\tassign\tcpu_halt = (cmd_halt);",
            "wire [31:0]\tcmd_data;\n\t// Values:\n\t//\t0x0003f -> cmd_addr mask\n\t//\t0x00040 -> reset\n\t//\t0x00080 -> PIC interrrupt pending\n\t//\t0x00100 -> cmd_step\n\t//\t0x00200 -> cmd_stall\n\t//\t0x00400 -> cmd_halt\n\t//\t0x00800 -> cmd_clear_pf_cache\n\t//\t0x01000 -> cc.sleep\n\t//\t0x02000 -> cc.gie\n\t//\t0x10000 -> External interrupt line is high\n\tassign\tcmd_data = { 7'h00, 8'h00, i_ext_int,\n\t\t\tcpu_dbg_cc,\n\t\t\t1'b0, cmd_halt, (!cpu_dbg_stall), 1'b0,\n\t\t\ti_ext_int, cpu_reset, 1'b0, cmd_addr };\n\n\t//\n\t// The CPU itself\n\t//",
            "wire cpu_lcl_cyc, cpu_lcl_stb, \n\t\t\tcpu_dbg_we,\n\t\t\tcpu_op_stall, cpu_pf_stall, cpu_i_count;",
            "wire [31:0]\tcpu_dbg_data;\n\tassign cpu_dbg_we = ((dbg_stb)&&(dbg_we)&&(dbg_addr));\n\tzipcpu\n\t\t/*\n\t\t#(.RESET_ADDRESS(RESET_ADDRESS),\n\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t\t.LGICACHE(LGICACHE),\n\t\t\t.WITH_LOCAL_BUS(0))\n\t\t*/\n\t\tthecpu(.i_clk(i_clk),\n\t\t\t.i_reset(cpu_reset),\n\t\t\t.i_interrupt(i_ext_int),\n\t\t\t.i_halt(cpu_halt),\n\t\t\t.i_clear_pf_cache(cmd_clear_pf_cache),\n\t\t\t.i_dbg_",
            "reg (cmd_addr[4:0]),\n\t\t\t.i_dbg_we(cpu_dbg_we),\n\t\t\t\t.i_dbg_data(dbg_idata),\n\t\t\t\t.o_dbg_stall(cpu_dbg_stall),\n\t\t\t\t.o_dbg_",
            "reg (cpu_dbg_data),\n\t\t\t\t.o_dbg_cc(cpu_dbg_cc),\n\t\t\t\t.o_break(cpu_break),\n\t\t\t.o_wb_gbl_cyc(o_wb_cyc),\n\t\t\t\t.o_wb_gbl_stb(o_wb_stb),\n\t\t\t\t.o_wb_lcl_cyc(cpu_lcl_cyc),\n\t\t\t\t.o_wb_lcl_stb(cpu_lcl_stb),\n\t\t\t\t.o_wb_we(o_wb_we),\n\t\t\t\t.o_wb_addr(o_wb_addr),\n\t\t\t\t.o_wb_data(o_wb_data),\n\t\t\t\t.o_wb_sel(o_wb_sel),\n\t\t\t\t.i_wb_stall(i_wb_stall),\n\t\t\t\t.i_wb_ack(i_wb_ack),\n\t\t\t\t.i_wb_data(i_wb_data),\n\t\t\t\t.i_wb_err((i_wb_err)||(cpu_lcl_cyc)),\n\t\t\t.o_op_stall(cpu_op_stall),\n\t\t\t.o_pf_stall(cpu_pf_stall),\n\t\t\t.o_i_count(cpu_i_count),\n\t\t\t.mutsel(mutsel)\n`ifdef\tDEBUG_SCOPE\n\t\t\t, o_cpu_debug\n`endif\n\t\t\t);\n\n\t// Return debug response values\n\tassign\tdbg_odata = (!dbg_addr)?cmd_data :cpu_dbg_data;\n\tinitial dbg_ack = 1'b0;\n\talways @(posedge i_clk)\n\t\tdbg_ack <= (dbg_stb)&&(!o_dbg_stall);\n\tassign\tdbg_stall= (cpu_dbg_stall)&&(dbg_addr);\n\n\tassign\to_ext_int = (cmd_halt) && (!i_wb_stall);\n\n\t// Make Verilator happy\n\t// verilator lint_off UNUSED",
            "wire [4:0] unused;\n\tassign\tunused = { dbg_cyc, cpu_lcl_stb, cpu_op_stall, cpu_pf_stall, cpu_i_count };\n\t// verilator lint_on  UNUSED",
            "endmodule "
        ]
    },
    {
        "file_name": "zipmmu_tb.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/rtl/zipmmu_tb.v",
        "chunks": [
            "module zipmmu_tb #(\n\t\t// {{{",
            "parameter CPU_ADDRESS_WIDTH=30,\n\t\t\t\tMEMORY_ADDRESS_WIDTH=15,",
            "localparam AW= CPU_ADDRESS_WIDTH,\n\t\t\t\tMAW= MEMORY_ADDRESS_WIDTH,\n\t\t\t\tLGTBL = 6,\n\t\t\t\tLGPGSZB=12\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t//",
            "input ",
            "wire i_ctrl_cyc_stb,\n\t\t//",
            "input ",
            "wire i_wbm_cyc, i_wbm_stb,\n\t\t//",
            "input ",
            "wire i_wb_we,",
            "input ",
            "wire i_exe,",
            "input ",
            "wire [(32-3):0]\ti_wb_addr,",
            "input ",
            "wire [(32-1):0]\ti_wb_data,",
            "input ",
            "wire [(32/8-1):0]\ti_wb_sel,",
            "input ",
            "wire i_gie,\n\t\t//\n\t\t// Here's where we return information on either our\n\t\t// slave/control bus, or the memory bus we are controlled\n\t\t// from.  Note that we share these",
            "wire s ...",
            "output ",
            "wire o_rtn_stall, o_rtn_ack,\n\t\t\t\t\t\to_rtn_err, o_rtn_miss,",
            "output ",
            "wire [(32-1):0]\to_rtn_data\n`ifdef\tVZIPMMU_TB\n\t\t,",
            "output ",
            "wire r_valid, wr_vtable,\n\t\t\t\t\t\twr_ptable,\n\t\t\t\t\t\twr_control,\n\t\t\t\t\t\tz_context,",
            "output ",
            "wire [15:0]\t\tr_context_word,",
            "output ",
            "wire r_pending,\n\t\t\t\t\t\tr_we,",
            "output ",
            "wire [29:0]\t\tr_addr,",
            "output ",
            "wire [31:0]\t\tr_data,",
            "output ",
            "wire mem_cyc, mem_stb, mem_we,",
            "output ",
            "wire [31:0]\t\tmem_odata,",
            "output ",
            "wire [(CPU_ADDRESS_WIDTH-1):0]\tmem_addr,",
            "output ",
            "reg mem_err,",
            "output ",
            "wire kernel_context,",
            "output ",
            "wire [5:0]\t\ts_tlb_addr,",
            "output ",
            "wire s_pending,",
            "output ",
            "wire s_tlb_hit, s_tlb_miss,\n\t\t\t\t\t\tro_flag, simple_miss,\n\t\t\t\t\t\tro_miss, exe_miss, table_err,",
            "output ",
            "wire tlb_valid,",
            "output ",
            "wire [19:0]\t\ttlb_pdata,",
            "output ",
            "wire [19:0]\t\ttlb_vdata,",
            "output ",
            "wire [15:0]\t\ttlb_cdata\n`endif\n\t\t// }}}\n\t);\n\n`ifndef\tVZIPMMU_TB",
            "wire mem_cyc,\n\t\t\t\tmem_stb,\n\t\t\t\tmem_we;",
            "wire [(CPU_ADDRESS_WIDTH-1):0]\tmem_addr;",
            "reg mem_err;",
            "wire [31:0]\t\tmem_odata;\n`endif",
            "wire mem_ack, mem_stall;",
            "wire [31:0]\t\tmem_idata;",
            "wire [(32/8-1):0]\tmem_sel;",
            "wire mmus_ack, mmus_stall;",
            "wire [31:0]\tmmus_data;",
            "wire rtn_ack, rtn_stall;",
            "wire [31:0]\trtn_data;",
            "wire ign_stb, ign_we, ign_cache;",
            "wire [(32-LGPGSZB-1):0]\tign_p;",
            "wire [(32-LGPGSZB-1):0]\tign_v;\n\n\t//\n\t// mut = Module Under Test\n\t//\n\tzipmmu\t#(\n\t\t.ADDRESS_WIDTH(CPU_ADDRESS_WIDTH),\n\t\t.LGTBL(LGTBL),.PLGPGSZB(LGPGSZB)\n\t) mut (\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\t\t// Slave access\n\t\t\ti_ctrl_cyc_stb, i_wb_we, i_wb_addr[(LGTBL+1):0],\n\t\t\t\ti_wb_data,\n\t\t\t\tmmus_ack, mmus_stall, mmus_data,\n\t\t\ti_wbm_cyc, i_wbm_stb, i_wb_we, i_exe,\n\t\t\t\ti_wb_addr, i_wb_data, i_wb_sel, i_gie,\n\t\t\tmem_cyc, mem_stb, mem_we, mem_addr, mem_idata, mem_sel,\n\t\t\t\tmem_stall, (mem_ack)&&(!mem_err), mem_err, mem_odata,\n\t\t\trtn_stall, rtn_ack, o_rtn_err, o_rtn_miss,\n\t\t\t\trtn_data,\n\t\t\tign_stb, ign_we, ign_p, ign_v, ign_cache\n\t\t// }}}\n\t);\n\n\tmemdev #(MAW+2) ram(i_clk,\n\t\tmem_cyc, mem_stb, mem_we, mem_addr[(MAW-1):0], mem_idata,\n\t\t\t\tmem_sel,\n\t\t\tmem_ack, mem_stall, mem_odata);\n\n\talways@(posedge i_clk)\n\tif (i_reset)\n\t\tmem_err <= 1'b0;\n\telse if (!mem_cyc)\n\t\tmem_err <= 1'b0;\n\telse\n\t\tmem_err <= (mem_err)||((mem_stb)&&(mem_addr[(AW-1):MAW]\n\t\t\t\t\t!= {{(AW-MAW-1){1'b0}}, 1'b1}));\n\n\n\tassign\to_rtn_stall = (i_wbm_cyc)&&(rtn_stall);\n\tassign\to_rtn_ack   = (i_wbm_cyc)?(rtn_ack) :mmus_ack;\n\tassign\to_rtn_data  = (i_wbm_cyc)?(rtn_data):mmus_data;\n\n`ifdef\tVZIPMMU_TB",
            "reg [5:0]\tlast_index, r_last_index;",
            "wire [63:0]\tpre_valid, shifted_valid;\n\n\tassign\tr_we = mut.r_we;\n\tassign\tr_valid = mut.r_valid;\n\tassign\twr_vtable = mut.wr_vtable;\n\tassign\twr_ptable = mut.wr_ptable;\n\tassign\twr_control = mut.wr_control;\n\tassign\tz_context  = mut.z_context ;\n\tassign\tr_context_word  = mut.r_context_word;\n\tassign\tr_pending  = mut.r_pending;\n\tassign\tr_we       = mut.r_we;\n\tassign\tr_addr     = mut.r_addr;\n\tassign\tr_data     = mut.r_data;\n\tassign\tkernel_context = mut.kernel_context;\n\n\tassign\ts_tlb_addr = mut.s_tlb_addr;\n\tassign\ts_pending  = mut.s_pending;\n\tassign\ts_tlb_hit  = mut.s_tlb_hit;\n\tassign\ts_tlb_miss = mut.s_tlb_miss;\n\tassign\tro_flag = mut.ro_flag;\n\tassign\tsimple_miss = mut.simple_miss;\n\tassign\tro_miss = mut.ro_miss;\n\tassign\texe_miss = mut.exe_miss;\n\tassign\ttable_err = mut.table_err;\n\tassign\tpre_valid = mut.tlb_valid;\n\tassign\tshifted_valid = pre_valid >> last_index;\n\tassign\ttlb_valid = shifted_valid[0];\n\tassign\ttlb_pdata = mut.tlb_pdata[last_index];\n\tassign\ttlb_vdata = mut.tlb_vdata[last_index];\n\tassign\ttlb_cdata = mut.tlb_cdata[last_index];\n\n\talways @(*)\n\tif (i_ctrl_cyc_stb && i_wb_we && i_wb_addr[7])\n\t\tlast_index = i_wb_addr[6:1];\n\telse\n\t\tlast_index = r_last_index;\n\n\talways @(posedge i_clk)\n\tif (i_ctrl_cyc_stb && i_wb_we && i_wb_addr[7])\n\t\tr_last_index <= i_wb_addr[6:1];\n\n\t// Make Verilator happy\n\t// verilator lint_off UNUSED",
            "wire unused_vbench;\n\tassign\tunused_vbench = &{ 1'b0, shifted_valid[63:1] };\n\t// verilator lint_on UNUSED\n`endif\n\n\t// Make Verilator happy\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, ign_stb, ign_we, ign_p, ign_v,\n\t\t\t\tign_cache, mmus_stall };\n\t// verilator lint_on  UNUSED",
            "endmodule "
        ]
    },
    {
        "file_name": "memdev.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/bench/rtl/memdev.v",
        "chunks": [
            "module memdev #(\n\t\t// {{{",
            "parameter LGMEMSZ=15, DW=32, EXTRACLOCK= 1,",
            "parameter HEXFILE=\"\",",
            "parameter [0:0]\tOPT_ROM = 1'b0,",
            "localparam AW = LGMEMSZ - $clog2(DW/8)\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,",
            "input ",
            "wire i_wb_cyc, i_wb_stb, i_wb_we,",
            "input ",
            "wire [(AW-1):0]\ti_wb_addr,",
            "input ",
            "wire [(DW-1):0]\ti_wb_data,",
            "input ",
            "wire [(DW/8-1):0]\ti_wb_sel,",
            "output ",
            "wire o_wb_stall,",
            "output ",
            "reg o_wb_ack,",
            "output ",
            "reg [(DW-1):0]\to_wb_data\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "wire w_wstb, w_stb;",
            "wire [(DW-1):0]\tw_data;",
            "wire [(AW-1):0]\tw_addr;",
            "wire [(DW/8-1):0]\tw_sel;",
            "reg [(DW-1):0]\tmem\t[0:((1<<AW)-1)];\n\t// }}}\n\n\t// Pre-load the memory\n\t// {{{\n\tgenerate if (HEXFILE != 0)\n\tbegin : PRELOAD_MEMORY\n\n\t\tinitial $readmemh(HEXFILE, mem);\n\n\tend endgenerate\n\t// }}}\n\n\t// Delay request if necessary\n\t// {{{\n\tgenerate if (EXTRACLOCK == 0)\n\tbegin : NO_EXTRA_CLOCK\n\t\t// {{{\n\t\tassign\tw_wstb = (i_wb_stb)&&(i_wb_we);\n\t\tassign\tw_stb  = i_wb_stb;\n\t\tassign\tw_addr = i_wb_addr;\n\t\tassign\tw_data = i_wb_data;\n\t\tassign\tw_sel  = i_wb_sel;\n\t\t// }}}\n\tend else begin : EXTRA_MEM_CLOCK_CYCLE\n\t\t// {{{",
            "reg last_wstb, last_stb;",
            "reg [(AW-1):0]\tlast_addr;",
            "reg [(DW-1):0]\tlast_data;",
            "reg [(DW/8-1):0]\tlast_sel;\n\n\t\tinitial\tlast_wstb = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tlast_wstb <= 0;\n\t\telse\n\t\t\tlast_wstb <= (i_wb_stb)&&(i_wb_we);\n\n\t\tinitial\tlast_stb = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tlast_stb <= 1'b0;\n\t\telse\n\t\t\tlast_stb <= (i_wb_stb);\n\n\t\talways @(posedge i_clk)\n\t\t\tlast_data <= i_wb_data;\n\t\talways @(posedge i_clk)\n\t\t\tlast_addr <= i_wb_addr;\n\t\talways @(posedge i_clk)\n\t\t\tlast_sel <= i_wb_sel;\n\n\t\tassign\tw_wstb = last_wstb;\n\t\tassign\tw_stb  = last_stb;\n\t\tassign\tw_addr = last_addr;\n\t\tassign\tw_data = last_data;\n\t\tassign\tw_sel  = last_sel;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// Read from memory\n\t// {{{\n\talways @(posedge i_clk)\n\t\to_wb_data <= mem[w_addr];\n\t// }}}\n\n\t// Write to memory (if not a ROM)\n\t// {{{\n\tgenerate if (!OPT_ROM)\n\tbegin : WRITE_TO_MEMORY\n\t\t// {{{\n\t\tinteger\tik;\n\n\t\talways @(posedge i_clk)\n\t\tif (w_wstb)\n\t\tbegin\n\t\t\tfor(ik=0; ik<DW/8; ik=ik+1)\n\t\t\tif (w_sel[ik])\n\t\t\t\tmem[w_addr][ik*8 +: 8] <= w_data[ik*8 +: 8];\n\t\tend\n`ifdef\tVERILATOR\n\tend else begin : VERILATOR_ROM\n\n\t\t// Make Verilator happy\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire rom_unused;\n\t\tassign\trom_unused = &{ 1'b0, w_wstb, w_data, w_sel };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n`endif\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// o_wb_ack\n\t// {{{\n\tinitial\to_wb_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_wb_ack <= 1'b0;\n\telse\n\t\to_wb_ack <= (w_stb)&&(i_wb_cyc);\n\t// }}}\n\n\tassign\to_wb_stall = 1'b0;\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = { 1'b0 };\n\t// verilator lint_on UNUSED\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "localparam F_LGDEPTH = 2;",
            "reg f_past_valid;",
            "wire [F_LGDEPTH-1:0]\tf_nreqs, f_nacks, f_outstanding;",
            "wire [(AW-1):0]\tf_addr;",
            "reg [31:0]\t\tf_data;\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\n\tfwb_slave #(\n\t\t.AW(AW), .DW(DW), .F_MAX_STALL(1), .F_MAX_ACK_DELAY(2),\n\t\t.F_OPT_DISCONTINUOUS(1), .F_LGDEPTH(F_LGDEPTH)\n\t) fwb(i_clk, i_reset, i_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr,\n\t\ti_wb_data, i_wb_sel, o_wb_ack, o_wb_stall, o_wb_data,\n\t\t1'b0, f_nreqs, f_nacks, f_outstanding);\n\n\tgenerate if (EXTRACLOCK)\n\tbegin\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(!i_reset)&&(i_wb_cyc)&&($past(i_wb_cyc)))\n\t\t\tassert((f_outstanding == 0)\n\t\t\t\t== ((!$past(w_stb))&&(!$past(i_wb_stb))));\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(!i_reset)&&(i_wb_cyc))\n\t\t\tassert((f_outstanding == 1)\n\t\t\t\t== ( (($past(w_stb))&&($past(i_wb_cyc)))\n\t\t\t\t\t^($past(i_wb_stb))));\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(!i_reset)&&(i_wb_cyc))\n\t\t\tassert((f_outstanding == 2'h2)\n\t\t\t\t== (($past(w_stb))&&($past(i_wb_cyc))\n\t\t\t\t\t&&($past(i_wb_stb))));\n\n\t\talways @(posedge i_clk)\n\t\t\tassert(f_outstanding <= 2);\n\n\tend else begin\n\n\t\talways @(posedge i_clk)\n\t\tif (f_outstanding > 0)\n\t\t\tassert(o_wb_ack);\n\n\t\talways @(posedge i_clk)\n\t\t\tassert(f_outstanding <= 1);\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(!i_reset)&&(i_wb_cyc)&&($past(i_wb_stb)))\n\t\t\tassert(f_outstanding == 1);\n\n\tend endgenerate\n\n\talways @(*)\n\t\tassert(!o_wb_stall);",
            "wire [(AW-1):0]\tf_addr;",
            "reg [31:0]\t\tf_data;\n\n\tassign\tf_addr = $anyconst;\n\tinitial\tassume(mem[f_addr] == f_data);\n\n\tgenerate if (!OPT_ROM)\n\tbegin : F_MATCH_WRITES\n\t\tinteger\tik;\n\n\t\talways @(posedge i_clk)\n\t\tif (w_wstb && f_addr == w_addr)\n\t\tfor(ik=0; ik < DW/8; ik=ik+1)\n\t\tif (w_sel[ik])\n\t\t\tf_data[ik * 8 +: 8] <= w_data[ik*8 +: 8];\n\n\tend endgenerate\n\n\talways @(*)\n\t\tassert(mem[f_addr] == f_data);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(OPT_ROM))\n\t\tassert($stable(f_data));\n\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipaxil.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipaxil.v",
        "chunks": [
            "module holding the core of the Zip CPU\n//\t\ttogether--this one with AXI-lite instruction, data, and debug\n//\tinterfaces.  In general, the Zip CPU is designed to be as simple as\n//\tpossible.  (actual implementation aside ...)  The instruction set is\n//\tabout as RISC as you can get, with only 26 instruction types currently\n//\tsupported.  (There are still 8-instruction Op-Codes reserved for\n//\tfloating point, and 5 which can be used for transactions not requiring\n//",
            "reg isters.) Please see the accompanying spec.pdf file for a description\n//\tof these instructions.\n//\n//\tThis version is bus width agnostic for both instruction and data buses,\n//\talthough the debug bus must still be 32-bits.  Instruction and data\n//\tbuses must be at least 32-bits wide.\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module zipaxil #(\n\t\t// {{{",
            "parameter C_DBG_ADDR_WIDTH = 8,",
            "parameter ADDRESS_WIDTH = 32,",
            "parameter C_AXI_DATA_WIDTH = 32,",
            "parameter OPT_LGICACHE = 0,",
            "parameter OPT_LGDCACHE = 0,",
            "parameter [0:0]\tOPT_PIPELINED = 1'b1,",
            "parameter [ADDRESS_WIDTH-1:0] RESET_ADDRESS={(ADDRESS_WIDTH){1'b0}},",
            "parameter [0:0]\tSTART_HALTED = 1'b0,",
            "parameter [0:0]\tSWAP_WSTRB = 1'b1,",
            "parameter OPT_MPY    = 3,",
            "parameter [0:0]\tOPT_DIV    = 1'b1,",
            "parameter [0:0]\tOPT_SHIFTS = 1'b1,",
            "parameter [0:0]\tOPT_LOCK   = 1'b1,",
            "parameter [0:0]\tOPT_FPU = 0,",
            "parameter [0:0]\tOPT_EARLY_BRANCHING = 1,",
            "parameter [0:0]\tOPT_CIS = 1'b1,",
            "parameter [0:0]\tOPT_LOWPOWER   = 1'b0,",
            "parameter [0:0]\tOPT_DISTRIBUTED_REGS = 1'b1,",
            "parameter [0:0]\tOPT_DBGPORT    = START_HALTED,",
            "parameter [0:0]\tOPT_TRACE_PORT = 1'b0,",
            "parameter [0:0]\tOPT_PROFILER   = 1'b0,",
            "parameter [0:0]\tOPT_USERMODE   = 1'b1,",
            "parameter RESET_DURATION = 10,\n\t\t//",
            "localparam [0:0]\tWITH_LOCAL_BUS = 1'b0,\n`ifdef\tVERILATOR",
            "parameter [0:0]\tOPT_SIM = 1'b1,",
            "parameter [0:0]\tOPT_CLKGATE = OPT_LOWPOWER\n`else",
            "parameter [0:0]\tOPT_SIM = 1'b0,",
            "parameter [0:0]\tOPT_CLKGATE = 1'b0\n`endif\n`ifdef\tFORMAL\n\t\t,",
            "parameter F_LGDEPTH=8\n`endif\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK, S_AXI_ARESETN,\n\t\t\t\t\ti_interrupt, i_cpu_reset,\n\t\t// Debug interface\n\t\t// {{{\n\t\t// Debug interface --",
            "input s\n//",
            "input ",
            "wire i_halt, i_clear_cache,\n//",
            "input ",
            "wire [4:0]\ti_dbg_w",
            "reg ,\n//",
            "input ",
            "wire i_dbg_we,\n//",
            "input ",
            "wire [31:0]\ti_dbg_data,\n//",
            "input ",
            "wire [4:0]\ti_dbg_r",
            "reg ,\n\t\t// Debug interface --",
            "output s\n//",
            "output ",
            "wire cpu_dbg_stall,\n//",
            "output ",
            "reg [31:0]\to_dbg_",
            "reg ,\n//",
            "output ",
            "reg [2:0]\to_dbg_cc,\n//",
            "output ",
            "wire o_break,",
            "input ",
            "wire S_DBG_AWVALID,",
            "output ",
            "wire S_DBG_AWREADY,",
            "input ",
            "wire [C_DBG_ADDR_WIDTH-1:0]\tS_DBG_AWADDR,\n\t\t// Verilator coverage_off",
            "input ",
            "wire [2:0]\tS_DBG_AWPROT,\n\t\t// Verilator coverage_on\n\t\t//",
            "input ",
            "wire S_DBG_WVALID,",
            "output ",
            "wire S_DBG_WREADY,",
            "input ",
            "wire [31:0]\tS_DBG_WDATA,",
            "input ",
            "wire [3:0]\tS_DBG_WSTRB,\n\t\t//",
            "output ",
            "reg S_DBG_BVALID,",
            "input ",
            "wire S_DBG_BREADY,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [1:0]\tS_DBG_BRESP,\n\t\t// Verilator coverage_on\n\t\t//",
            "input ",
            "wire S_DBG_ARVALID,",
            "output ",
            "wire S_DBG_ARREADY,",
            "input ",
            "wire [7:0]\tS_DBG_ARADDR,\n\t\t// Verilator coverage_off",
            "input ",
            "wire [2:0]\tS_DBG_ARPROT,\n\t\t// Verilator coverage_on\n\t\t//",
            "output ",
            "reg S_DBG_RVALID,",
            "input ",
            "wire S_DBG_RREADY,",
            "output ",
            "reg [31:0]\tS_DBG_RDATA,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [1:0]\tS_DBG_RRESP,\n\t\t// Verilator coverage_on\n\t\t//\n\t\t// }}}\n\t\t// Instruction bus (master)\n\t\t// {{{\n\t\t// Verilator coverage_off",
            "output ",
            "wire M_INSN_AWVALID,",
            "input ",
            "wire M_INSN_AWREADY,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0]\tM_INSN_AWADDR,",
            "output ",
            "wire [2:0]\t\t\tM_INSN_AWPROT,\n\t\t//",
            "output ",
            "wire M_INSN_WVALID,",
            "input ",
            "wire M_INSN_WREADY,",
            "output ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_INSN_WDATA,",
            "output ",
            "wire [C_AXI_DATA_WIDTH/8-1:0]\tM_INSN_WSTRB,\n\t\t//",
            "input ",
            "wire M_INSN_BVALID,",
            "output ",
            "wire M_INSN_BREADY,",
            "input ",
            "wire [1:0]\t\t\tM_INSN_BRESP,\n\t\t// Verilator coverage_on\n\t\t//",
            "output ",
            "wire M_INSN_ARVALID,",
            "input ",
            "wire M_INSN_ARREADY,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0]\tM_INSN_ARADDR,",
            "output ",
            "wire [2:0]\t\t\tM_INSN_ARPROT,\n\t\t//",
            "input ",
            "wire M_INSN_RVALID,",
            "output ",
            "wire M_INSN_RREADY,",
            "input ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_INSN_RDATA,",
            "input ",
            "wire [1:0]\t\t\tM_INSN_RRESP,\n\t\t// }}}\n\t\t// Data bus (master)\n\t\t// {{{",
            "output ",
            "wire M_DATA_AWVALID,",
            "input ",
            "wire M_DATA_AWREADY,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0]\tM_DATA_AWADDR,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [2:0]\t\t\tM_DATA_AWPROT,\n\t\t// Verilator coverage_on\n\t\t//",
            "output ",
            "wire M_DATA_WVALID,",
            "input ",
            "wire M_DATA_WREADY,",
            "output ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_DATA_WDATA,",
            "output ",
            "wire [C_AXI_DATA_WIDTH/8-1:0]\tM_DATA_WSTRB,\n\t\t//",
            "input ",
            "wire M_DATA_BVALID,",
            "output ",
            "wire M_DATA_BREADY,",
            "input ",
            "wire [1:0]\t\t\tM_DATA_BRESP,\n\t\t//",
            "output ",
            "wire M_DATA_ARVALID,",
            "input ",
            "wire M_DATA_ARREADY,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0]\tM_DATA_ARADDR,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [2:0]\t\t\tM_DATA_ARPROT,\n\t\t// Verilator coverage_on\n\t\t//",
            "input ",
            "wire M_DATA_RVALID,",
            "output ",
            "wire M_DATA_RREADY,",
            "input ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_DATA_RDATA,",
            "input ",
            "wire [1:0]\t\t\tM_DATA_RRESP,\n\t\t// }}}\n\t\t// Accounting",
            "output s ... to help us count stalls and usage",
            "output ",
            "wire o_cmd_reset,",
            "output ",
            "wire o_halted,",
            "output ",
            "wire o_gie,",
            "output ",
            "wire o_op_stall,",
            "output ",
            "wire o_pf_stall,",
            "output ",
            "wire o_i_count,\n\t\t//",
            "output ",
            "wire [31:0]\to_cpu_debug,\n\t\t//\n`ifdef\tVBENCH_TB\n\t\t// {{{\n\t\t//",
            "output ",
            "wire cpu_halt,\n\t\t//\t\t\t\tcmd_reset,\n\t\t//\t\t\t\tcmd_step,",
            "output ",
            "wire early_branch,",
            "output ",
            "wire [31:0]\t\tearly_branch_pc,",
            "output ",
            "wire [6:0]\t\tdcdA, dcdB,",
            "output ",
            "wire new_pc,",
            "output ",
            "wire [31:0]\t\tcpu_ipc, cpu_upc, pf_pc,\n\t\t//",
            "output ",
            "wire pf_cyc, pf_stb, pf_we,\n\t\t//",
            "output ",
            "wire [31:0]\t\tpf_addr,\n\t\t//",
            "output ",
            "wire pf_ack,",
            "output ",
            "wire pf_valid, pf_illegal,\n\t\t// pf_vmask, pf_r_v, pf_tagsrc, pf_tagipc, pf_tagvallst,\n\t\t//",
            "output ",
            "wire [31:0]\t\tpf_lastpc,",
            "output ",
            "wire [31:0]\t\tpf_instruction,",
            "output ",
            "wire [31:0]\t\tpf_instruction_pc,\n\t\t//",
            "output ",
            "wire dcd_ce, dcd_stalled, dcd_gie,\n\t\t\t\t\t\tdcd_valid, dcd_illegal,\n\t\t\t\t\t\tdcd_phase, dcd_break, dcd_pipe,",
            "output ",
            "wire [3:0]\t\tdcd_opn,",
            "output ",
            "wire dcd_rA, dcd_rB, dcd_wR, dcd_wF,",
            "output ",
            "wire [4:0]\t\tdcdR,",
            "output ",
            "wire dcdRpc, dcdRcc,",
            "output ",
            "wire [31:0]\t\tdcd_pc,",
            "output ",
            "wire dcd_M,\n\t\t//",
            "output ",
            "wire op_ce, op_illegal, op_valid,\n\t\t\t\t\t\top_valid_mem, op_valid_alu,\n\t\t\t\t\t\top_stall, op_wR, op_wF,\n\t\t\t\t\t\top_phase, op_gie,",
            "output ",
            "wire [4:0]\t\top_R, op_Aid, op_Bid,",
            "output ",
            "wire [31:0]\t\top_Av, op_Bv, op_pc,",
            "output ",
            "wire master_stall,\n\t\t//",
            "output ",
            "wire alu_ce, adf_ce_unconditional,\n\t\t\t\t\t\talu_valid, alu_wR, alu_wF,\n\t\t\t\t\t\talu_pc_valid, alu_illegal,\n\t\t\t\t\t\talu_gie,\n\t\t\t\t\t\tset_cond, alu_phase,",
            "output ",
            "wire [3:0]\t\talu_flags,",
            "output ",
            "wire [31:0]\t\talu_pc,\n\t\t//",
            "output ",
            "wire mem_valid, mem_pc_valid, mem_ce,\n\t\t\t\t\t\tmem_busy, mem_rdbusy,",
            "output ",
            "wire [4:0]\t\tmem_w",
            "reg ,\n\t\t//",
            "output ",
            "wire div_valid, div_ce, div_busy,\n\t\t//",
            "output ",
            "wire [4:0]\t\twr_",
            "reg _id,",
            "output ",
            "wire wr_",
            "reg _ce, wr_flags_ce,",
            "output ",
            "wire [31:0]\t\twr_gp",
            "reg _vl, wr_sp",
            "reg _vl,",
            "output ",
            "wire [15:0]\t\tw_iflags, w_uflags,\n\t\t//",
            "output ",
            "wire cpu_sim,\n\t\t\t\t\t\tr_sleep, master_ce, op_break,\n\t\t\t\t\t\tr_gie,",
            "output ",
            "wire [22:0]\t\tcpu_sim_immv,",
            "output ",
            "wire [7:0]\t\top_F,\n\t\t//\n\t\t//\n\t\t// ZipSystem peripherals",
            "output ",
            "wire [31:0]\t\twatchbus, watchdog, pic_data,\n\t\t\t\t\t\twdbus_data,",
            "output ",
            "wire [15:0]\t\tint_state, alt_int_state,",
            "output ",
            "wire [31:0]\t\ttimer_a,\n\t\t\t\t\t\ttimer_b, timer_c, jiffies,\n\t\t\t\t\t\tutc_data, uoc_data, uic_data,\n\t\t\t\t\t\tupc_data, mtc_data, moc_data,\n\t\t\t\t\t\tmpc_data, mic_data,",
            "output ",
            "wire [31:0]\t\tmem_data, mem_addr, mem_result,",
            "output ",
            "wire op_pipe,\n\t\t\t\t\t\t// op_A_alu, op_B_alu,\n\t\t\t\t\t\t// op_A_mem, op_B_mem,",
            "output ",
            "wire [3:0]\t\top_opn,",
            "output ",
            "wire [31:0]\t\talu_result,",
            "output ",
            "wire alu_busy,",
            "output ",
            "wire [4:0]\t\talu_",
            "reg ,",
            "output ",
            "wire switch_to_interrupt,\n\t\t\t\t\t\trelease_from_interrupt,\n\t\t\t\t\t\tbreak_en,\n\t\t// }}}\n`endif",
            "output ",
            "wire o_prof_stb,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0] o_prof_addr,",
            "output ",
            "wire [31:0]\to_prof_ticks\n\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam [0:0]\tDBG_ADDR_CTRL = 1'b0,\n\t\t\t\tDBG_ADDR_CPU  = 1'b1;",
            "localparam C_DBG_DATA_WIDTH = 32;",
            "localparam DBGLSB = $clog2(C_DBG_DATA_WIDTH/8);",
            "localparam AW=ADDRESS_WIDTH-2;",
            "localparam [0:0]\tOPT_PIPELINED_BUS_ACCESS = (OPT_PIPELINED)&&(OPT_LGDCACHE > 1);",
            "localparam [0:0]\tOPT_MEMPIPE = OPT_PIPELINED_BUS_ACCESS;",
            "localparam [0:0]\tOPT_DCACHE = (OPT_LGDCACHE > 4);",
            "localparam FETCH_LIMIT = (OPT_LGICACHE < 4) ? (1 << OPT_LGICACHE) : 16;\n\n\t// Debug bit allocations\n\t// {{{\n\t//\tDBGCTRL\n\t//\t\t 5 DBG Catch -- Catch exceptions/fautls w/ debugger\n\t//\t\t 4 Clear cache\n\t//\t\t 3 RESET_FLAG\n\t//\t\t 2 STEP\t(W=1 steps, and returns to halted)\n\t//\t\t 1 HALT(ED)\n\t//\t\t 0 HALT\n\t//\tDBGDATA\n\t//\t\tread/writes internal",
            "reg isters\n\t//",
            "localparam HALT_BIT = 0,\n\t\t\tSTEP_BIT = 2,\n\t\t\tRESET_BIT = 3,\n\t\t\tCLEAR_CACHE_BIT = 4,\n\t\t\tCATCH_BIT = 5;\n\t// }}}",
            "localparam [0:0]\tOPT_ALIGNMENT_ERR = 1'b0;",
            "localparam [0:0]\tSWAP_ENDIANNESS = 1'b0;\n\n\t// AXI-lite signal handling\n\t// {{{",
            "wire awskd_valid, wskd_valid, arskd_valid;",
            "wire dbg_write_ready, dbg_read_ready;",
            "wire [C_DBG_ADDR_WIDTH-DBGLSB-1:0]\tawskd_addr, arskd_addr;",
            "wire [31:0]\twskd_data;",
            "wire [3:0]\twskd_strb;",
            "reg dbg_write_valid, dbg_read_valid;",
            "wire dbg_blkram_stall;",
            "reg [4:0]\tdbg_write_",
            "reg ;",
            "wire [4:0]\tdbg_read_",
            "reg ;",
            "reg [31:0]\tdbg_write_data;",
            "wire [31:0]\tdbg_read_data;",
            "wire cpu_dbg_stall, cpu_break, dbg_write_stall;",
            "wire [2:0]\tcpu_dbg_cc;\n\t// }}}",
            "wire reset_hold, halt_on_fault, dbg_catch;",
            "wire cpu_clken, cpu_clock, clk_gate;",
            "wire reset_request, release_request, halt_request, step_request,\n\t\tclear_cache_request;",
            "wire cpu_has_halted;\n\n\n\t// CPU control",
            "reg isters\n\t// {{{",
            "reg cmd_halt, cmd_reset, cmd_step, cmd_clear_cache;",
            "wire [31:0]\tcpu_status;",
            "wire dbg_cmd_write, dbg_cpu_write;",
            "wire [31:0]\tdbg_cmd_data;",
            "wire [3:0]\tdbg_cmd_strb;\n\t// }}}\n\n\t// Fetch\n\t// {{{",
            "wire pf_new_pc, clear_icache, pf_ready;",
            "wire [AW+1:0]\tpf_request_address;\n`ifndef\tVBENCH_TB",
            "wire [31:0]\tpf_instruction;",
            "wire [AW+1:0]\tpf_instruction_pc;",
            "wire pf_valid, pf_illegal;\n`endif\n\t// }}}\n\t// Memory\n\t// {{{",
            "wire clear_dcache, bus_lock;",
            "wire [2:0]\tmem_op;",
            "wire [31:0]\tmem_cpu_addr;",
            "wire [AW+1:0]\tmem_lock_pc;",
            "wire [31:0]\tmem_wdata;",
            "wire [4:0]\tmem_",
            "reg ;",
            "wire mem_pipe_stalled, mem_bus_err;\n`ifndef\tVBENCH_TB",
            "wire mem_ce, mem_valid, mem_busy, mem_rdbusy;",
            "wire [4:0]\tmem_w",
            "reg ;",
            "wire [31:0]\tmem_result;\n`endif\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Debug signal handling\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Write signaling\n\t// {{{\n\tskidbuffer #(\n\t\t// {{{\n\t\t.OPT_OUTREG(0),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.DW(C_DBG_ADDR_WIDTH-DBGLSB)\n\t\t// }}}\n\t) dbgawskd(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t.i_valid(S_DBG_AWVALID),\n\t\t.o_ready(S_DBG_AWREADY),\n\t\t.i_data(S_DBG_AWADDR[C_DBG_ADDR_WIDTH-1:DBGLSB]),\n\t\t.o_valid(awskd_valid), .i_ready(dbg_write_ready),\n\t\t\t.o_data(awskd_addr)\n\t\t// }}}\n\t);\n\n\tskidbuffer #(\n\t\t// {{{\n\t\t.OPT_OUTREG(0),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.DW(C_DBG_DATA_WIDTH+C_DBG_DATA_WIDTH/8)\n\t\t// }}}\n\t) dbgwskd(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t.i_valid(S_DBG_WVALID),\n\t\t.o_ready(S_DBG_WREADY),\n\t\t.i_data({ S_DBG_WSTRB, S_DBG_WDATA }),\n\t\t.o_valid(wskd_valid), .i_ready(dbg_write_ready),\n\t\t\t.o_data({ wskd_strb, wskd_data })\n\t\t// }}}\n\t);\n\n\tassign\tdbg_write_ready = awskd_valid && wskd_valid\n\t\t\t&& ((wskd_strb==0) || awskd_addr[5] != DBG_ADDR_CPU\n\t\t\t   || !dbg_write_stall)\n\t\t\t&& (!S_DBG_BVALID || S_DBG_BREADY);\n\n\t// dbg_write_valid\n\t// {{{\n\tinitial\tdbg_write_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || !OPT_DBGPORT)\n\t\tdbg_write_valid <= 1'b0;\n\telse if (!dbg_write_stall)\n\t\tdbg_write_valid <= dbg_cpu_write;\n\t// }}}\n\n\t// dbg_write_",
            "reg // {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!dbg_write_stall)\n\tbegin\n\t\tdbg_write_",
            "reg <= awskd_addr[4:0];\n\t\tif (OPT_LOWPOWER && !dbg_cpu_write)\n\t\t\tdbg_write_",
            "reg <= 0;\n\tend\n\t// }}}\n\n\t// dbg_write_data\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!dbg_write_stall)\n\tbegin\n\t\tdbg_write_data <= wskd_data;\n\t\tif (OPT_LOWPOWER && !dbg_cpu_write)\n\t\t\tdbg_write_data <= 0;\n\tend\n\t// }}}\n\n\t// S_DBG_BVALID\n\t//  {{{\n\tinitial\tS_DBG_BVALID = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tS_DBG_BVALID <= 1'b0;\n\telse if (dbg_write_ready)\n\t\tS_DBG_BVALID <= 1'b1;\n\telse if (S_DBG_BREADY)\n\t\tS_DBG_BVALID <= 1'b0;\n\t// }}}\n\n\t// S_DBG_BRESP\n\t// {{{\n\tassign\tS_DBG_BRESP = 2'b00;\n\t// }}}\n\n\t// }}}\n\n\t//\n\t// Read signaling\n\t// {{{\n\n\tskidbuffer #(\n\t\t// {{{\n\t\t.OPT_OUTREG(0),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.DW(C_DBG_ADDR_WIDTH-DBGLSB)\n\t\t// }}}\n\t) dbgarskd(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t.i_valid(S_DBG_ARVALID),\n\t\t.o_ready(S_DBG_ARREADY),\n\t\t.i_data(S_DBG_ARADDR[C_DBG_ADDR_WIDTH-1:DBGLSB]),\n\t\t.o_valid(arskd_valid), .i_ready(dbg_read_ready),\n\t\t\t.o_data(arskd_addr)\n\t\t// }}}\n\t);\n\n\tassign\tdbg_read_ready = arskd_valid && !dbg_blkram_stall\n\t\t\t\t&& (!S_DBG_RVALID || S_DBG_RREADY);\n\n\tassign\tdbg_read_",
            "reg = (OPT_LOWPOWER && !dbg_read_ready)\n\t\t\t\t\t? 5'h0 : arskd_addr[4:0];\n\n\t// dbg_read_valid\n\t// {{{",
            "reg [1:0]\tr_blkram_stall;\n\n\tinitial\tr_blkram_stall = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || !OPT_DBGPORT)\n\t\tr_blkram_stall <= 0;\n\telse if (dbg_read_ready && arskd_addr[5] == DBG_ADDR_CPU)\n\t\tr_blkram_stall <= 2 + (OPT_DISTRIBUTED_REGS ? 0:1);\n\telse if (r_blkram_stall > 0)\n\t\tr_blkram_stall <= r_blkram_stall - 1;\n\n\tinitial\tdbg_read_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || !OPT_DBGPORT)\n\t\tdbg_read_valid <= 0;\n\telse\n\t\tdbg_read_valid <= (r_blkram_stall == 1);\n\n\tassign\tdbg_blkram_stall = (r_blkram_stall != 0);\n`ifdef\tFORMAL\n\talways @(*)\n\tif (S_AXI_ARESETN && (dbg_read_valid || dbg_blkram_stall))\n\t\tassert(!S_DBG_RVALID);\n`endif\n\t// }}}\n\n\t// S_DBG_RVALID\n\t// {{{\n\tinitial\tS_DBG_RVALID = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tS_DBG_RVALID <= 0;\n\telse if (!S_DBG_RVALID || S_DBG_RREADY)\n\t\tS_DBG_RVALID <= (dbg_read_ready\n\t\t\t  && (!OPT_DBGPORT || arskd_addr[5] == DBG_ADDR_CTRL))\n\t\t\t|| dbg_read_valid;\n\t// }}}\n\n\t// S_DBG_RDATA\n\t// {{{\n\tinitial\tS_DBG_RDATA = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\tS_DBG_RDATA <= 0;\n\telse if (!S_DBG_RVALID || S_DBG_RREADY)\n\tbegin\n\t\t// {{{\n\t\tif (OPT_DBGPORT && dbg_read_valid)\n\t\t\tS_DBG_RDATA <= dbg_read_data;\n\t\telse\n\t\t\tS_DBG_RDATA <= cpu_status;\n\n\t\tif (OPT_LOWPOWER && (!OPT_DBGPORT || !dbg_read_valid)\n\t\t\t\t\t\t&& !dbg_read_ready)\n\t\t\tS_DBG_RDATA <= 0;\n\t\t// }}}\n\tend\n\t// }}}\n\n\tassign\tS_DBG_RRESP = 2'b00;\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Reset, halt, clear-cache, and step controls\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tassign\tdbg_cpu_write = OPT_DBGPORT && dbg_write_ready\n\t\t\t\t&& awskd_addr[5] == DBG_ADDR_CPU\n\t\t\t\t&& wskd_strb == 4'hf;\n\tassign\tdbg_cmd_write = dbg_write_ready && awskd_addr[5] == DBG_ADDR_CTRL;\n\tassign\tdbg_cmd_data = wskd_data;\n\tassign\tdbg_cmd_strb = wskd_strb;\n\n\tassign\treset_request = dbg_cmd_write && dbg_cmd_strb[RESET_BIT/8]\n\t\t\t\t\t\t&& dbg_cmd_data[RESET_BIT];\n\tassign\trelease_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8]\n\t\t\t\t\t\t&& !dbg_cmd_data[HALT_BIT];\n\tassign\thalt_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8]\n\t\t\t\t\t\t&& dbg_cmd_data[HALT_BIT];\n\tassign\tstep_request = dbg_cmd_write && dbg_cmd_strb[STEP_BIT/8]\n\t\t\t\t\t\t&& dbg_cmd_data[STEP_BIT];\n\tassign\tclear_cache_request = dbg_cmd_write\n\t\t\t\t\t&& dbg_cmd_strb[CLEAR_CACHE_BIT/8]\n\t\t\t\t\t&& dbg_cmd_data[CLEAR_CACHE_BIT];\n\n\t//\n\t// reset_hold: Always start us off with an initial reset\n\t// {{{\n\tgenerate if (RESET_DURATION > 0)\n\tbegin : INITIAL_RESET_HOLD\n\t\t// {{{",
            "reg [$clog2(RESET_DURATION)-1:0]\treset_counter;",
            "reg r_reset_hold;\n\n\t\tinitial\treset_counter = RESET_DURATION;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || i_cpu_reset)\n\t\t\treset_counter <= RESET_DURATION;\n\t\telse if (reset_counter > 0)\n\t\t\treset_counter <= reset_counter - 1;\n\n\t\tinitial\tr_reset_hold = 1;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || i_cpu_reset)\n\t\t\tr_reset_hold <= 1;\n\t\telse\n\t\t\tr_reset_hold <= (reset_counter > 1);\n\n\t\tassign\treset_hold = r_reset_hold;\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\t\tassert(reset_hold == (reset_counter != 0));\n`endif\n\t\t// }}}\n\tend else begin : NO_RESET_HOLD\n\n\t\tassign reset_hold = 0;\n\n\tend endgenerate\n\t// }}}\n\n\tassign\thalt_on_fault = dbg_catch;\n\n\t// cmd_reset\n\t// {{{\n\t// Always start us off with an initial reset\n\tinitial\tcmd_reset = 1'b1;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || i_cpu_reset)\n\t\tcmd_reset <= 1'b1;\n\telse if (reset_hold)\n\t\tcmd_reset <= 1'b1;\n\telse if (cpu_break && !halt_on_fault)\n\t\tcmd_reset <= 1'b1;\n\telse\n\t\tcmd_reset <= reset_request;\n\t// }}}\n\n\t// cmd_halt\n\t// {{{\n\tinitial\tcmd_halt  = START_HALTED;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tcmd_halt <= START_HALTED;\n\telse if (i_cpu_reset && !dbg_write_ready && !dbg_write_stall)\n\t\tcmd_halt <= START_HALTED;\n\telse if (cmd_reset && START_HALTED)\n\t\tcmd_halt <= START_HALTED;\n\telse begin\n\t\t// {{{\n\t\t// When shall we release from a halt?  Only if we have\n\t\t// come to a full and complete stop.  Even then, we only\n\t\t// release if we aren't being given a command to step the CPU.\n\t\t//\n\t\tif (!dbg_write_valid && cpu_has_halted && dbg_cmd_write\n\t\t\t\t&& (release_request || step_request))\n\t\t\tcmd_halt <= 1'b0;\n\n\t\t// Reasons to halt\n\n\t\t// 1. Halt on any unhandled CPU exception.  The cause of the\n\t\t//\texception must be cured before we can (re)start.\n\t\t//\tIf the CPU is configured to start immediately on power\n\t\t//\tup, we leave it to reset on any exception instead.\n\t\tif (cpu_break && halt_on_fault)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 2. Halt on any user request to halt.  (Only valid if the\n\t\t//\tSTEP bit isn't also set)\n\t\tif (dbg_cmd_write && halt_request && !step_request)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 3. Halt on any user request to write to a CPU",
            "reg ister\n\t\tif (dbg_cpu_write)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 4. Halt following any step command\n\t\tif (cmd_step && !step_request)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 5. Halt following any clear cache\n\t\tif (cmd_clear_cache)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 6. Halt on any clear cache bit--independent of any step bit\n\t\tif (clear_cache_request)\n\t\t\tcmd_halt <= 1'b1;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// cmd_clear_cache\n\t// {{{\n\tinitial\tcmd_clear_cache = 1'b0;\n\talways @(posedge  S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || cmd_reset)\n\t\tcmd_clear_cache <= 1'b0;\n\telse if (dbg_cmd_write && clear_cache_request && halt_request)\n\t\tcmd_clear_cache <= 1'b1;\n\telse if (cmd_halt && !cpu_dbg_stall)\n\t\tcmd_clear_cache <= 1'b0;\n\t// }}}\n\n\t// cmd_step\n\t// {{{\n\tinitial\tcmd_step = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || i_cpu_reset)\n\t\tcmd_step <= 1'b0;\n\telse if (cmd_reset || cpu_break\n\t\t\t|| reset_request\n\t\t\t|| clear_cache_request || cmd_clear_cache\n\t\t\t|| halt_request || dbg_cpu_write)\n\t\tcmd_step <= 1'b0;\n\telse if (!dbg_write_valid && cpu_has_halted && step_request)\n\t\tcmd_step <= 1'b1;\n\telse // if (cpu_dbg_stall)\n\t\tcmd_step <= 1'b0;\n`ifdef\tFORMAL\n\t// While STEP is true, we can't halt\n\talways @(*)\n\tif (S_AXI_ARESETN && cmd_step)\n\t\tassert(!cmd_halt);\n`endif\n\t// }}}\n\n\t// dbg_catch\n\t// {{{\n\tgenerate if (!OPT_DBGPORT)\n\tbegin : NO_DBG_CATCH\n\t\tassign\tdbg_catch = START_HALTED;\n\tend else begin : GEN_DBG_CATCH",
            "reg r_dbg_catch;\n\n\t\tinitial\tr_dbg_catch = START_HALTED;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_dbg_catch <= START_HALTED;\n\t\telse if (dbg_cmd_write && dbg_cmd_strb[CATCH_BIT/8])\n\t\t\tr_dbg_catch <= dbg_cmd_data[CATCH_BIT];\n\n\t\tassign\tdbg_catch = r_dbg_catch;\n\tend endgenerate\n\t// }}}\n\n\t// cpu_status\n\t// {{{\n\t//\t0xffff_f000 -> (Unused / reserved)\n\t//\n\t//\t0x0000_0800 -> cpu_break\n\t//\t0x0000_0400 -> Interrupt pending\n\t//\t0x0000_0200 -> User mode\n\t//\t0x0000_0100 -> Sleep (CPU is sleeping)\n\t//\n\t//\t0x0000_00c0 -> (Unused/reserved)\n\t//\t0x0000_0020 -> dbg_catch\n\t//\t0x0000_0010 -> cmd_clear_cache\n\t//\n\t//\t0x0000_0008 -> Reset\n\t//\t0x0000_0004 -> Step (auto clearing, write only)\n\t//\t0x0000_0002 -> Halt (status)\n\t//\t0x0000_0001 -> Halt (request)\n\tassign\tcpu_status = { 16'h0, 4'h0,\n\t\t\tcpu_break, i_interrupt, cpu_dbg_cc[1:0],\n\t\t\t2'h0, dbg_catch, 1'b0,\n\t\t\tcmd_reset, 1'b0, !cpu_dbg_stall, cmd_halt\n\t\t};\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The ZipCPU Core\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n`ifdef\tFORMAL\n\t// {{{\n\t(* anyseq *)",
            "reg f_cpu_halted, f_cpu_data, f_cpu_stall,\n\t\t\t\tf_cpu_break;\n\t(* anyseq *)",
            "reg [2:0]\tf_cpu_dbg_cc;\n\t(* anyseq *)",
            "reg [2:0]\tf_cpu_dbg_read_data;\n\n\tassign\tcpu_dbg_stall = f_cpu_stall && !f_cpu_halted;\n\tassign\tcpu_break\t= f_cpu_break;\n\tassign\tcpu_dbg_cc\t= f_cpu_dbg_cc;\n\tassign\tdbg_read_data\t= f_cpu_dbg_read_data;\n\n\tfdebug #(\n\t\t// {{{\n\t\t.OPT_START_HALTED(START_HALTED),\n\t\t.OPT_DISTRIBUTED_RAM(OPT_DISTRIBUTED_REGS)\n\t\t// }}}\n\t) fdbg (\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK),\n\t\t.i_reset(!S_AXI_ARESETN),\n\t\t.i_cpu_reset(cmd_reset || i_cpu_reset),\n\t\t.i_halt(cmd_halt),\n\t\t.i_halted(f_cpu_halted),\n\t\t.i_clear_cache(cmd_clear_cache),\n\t\t.i_dbg_we(dbg_write_valid),\n\t\t.i_dbg_",
            "reg (dbg_write_",
            "reg ),\n\t\t.i_dbg_data(dbg_write_data),\n\t\t.i_dbg_stall(cpu_dbg_stall),\n\t\t.i_dbg_break(cpu_break),\n\t\t.i_dbg_cc(cpu_dbg_cc)\n\t\t// }}}\n\t);\n\t// }}}\n`else\n\tzipcore #(\n\t\t// {{{\n\t\t.RESET_ADDRESS({ {(32-ADDRESS_WIDTH){1'b0}}, RESET_ADDRESS }),\n\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH-2),\n\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t.OPT_DCACHE(OPT_DCACHE),\n\t\t.OPT_MPY(OPT_MPY),\n\t\t.OPT_DIV(OPT_DIV),\n\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t.IMPLEMENT_FPU(OPT_FPU),\n\t\t.OPT_CIS(OPT_CIS),\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.OPT_START_HALTED(START_HALTED),\n\t\t.OPT_SIM(OPT_SIM),\n\t\t.OPT_PIPELINED_BUS_ACCESS(OPT_MEMPIPE),\n\t\t//",
            "localparam [0:0]\tOPT_MEMPIPE = OPT_PIPELINED_BUS_ACCESS;\n\t\t.OPT_DBGPORT(OPT_DBGPORT),\n\t\t.OPT_TRACE_PORT(OPT_TRACE_PORT),\n\t\t.OPT_PROFILER(OPT_PROFILER),\n\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t.OPT_USERMODE(OPT_USERMODE)\n`ifdef\tFORMAL\n\t\t, .F_LGDEPTH(F_LGDEPTH)\n`endif\n\t\t// }}}\n\t) core (\n\t\t// {{{\n\t\t.i_clk(cpu_clock), .i_reset(cmd_reset),\n\t\t\t.i_interrupt(i_interrupt),\n\t\t.o_clken(cpu_clken),\n\t\t// Debug interface\n\t\t// {{{\n\t\t.i_halt(cmd_halt), .i_clear_cache(cmd_clear_cache),\n\t\t\t.i_dbg_w",
            "reg (dbg_write_",
            "reg ), .i_dbg_we(dbg_write_valid),\n\t\t\t.i_dbg_data(dbg_write_data),.i_dbg_r",
            "reg (dbg_read_",
            "reg ),\n\t\t\t.o_dbg_stall(cpu_dbg_stall),.o_dbg_",
            "reg (dbg_read_data),\n\t\t\t.o_dbg_cc(cpu_dbg_cc), .o_break(cpu_break),\n\t\t// }}}\n\t\t// Instruction fetch interface\n\t\t// {{{\n\t\t.o_pf_new_pc(pf_new_pc), .o_clear_icache(clear_icache),\n\t\t\t.o_pf_ready(pf_ready),\n\t\t\t.o_pf_request_address(pf_request_address),\n\t\t.i_pf_valid(pf_valid),\n\t\t\t.i_pf_illegal(pf_illegal),\n\t\t\t.i_pf_instruction(pf_instruction),\n\t\t\t.i_pf_instruction_pc(pf_instruction_pc),\n\t\t// }}}\n\t\t// Memory unit interface\n\t\t// {{{\n\t\t.o_clear_dcache(clear_dcache), .o_mem_ce(mem_ce),\n\t\t\t.o_bus_lock(bus_lock),\n\t\t\t.o_mem_op(mem_op), .o_mem_addr(mem_cpu_addr),\n\t\t\t.o_mem_data(mem_wdata),\n\t\t\t.o_mem_lock_pc(mem_lock_pc),\n\t\t\t.o_mem_",
            "reg (mem_",
            "reg ),\n\t\t\t.i_mem_busy(mem_busy),\n\t\t\t.i_mem_rdbusy(mem_rdbusy),\n\t\t\t.i_mem_pipe_stalled(mem_pipe_stalled),\n\t\t.i_mem_valid(mem_valid),\n\t\t\t.i_bus_err(mem_bus_err),\n\t\t\t.i_mem_w",
            "reg (mem_w",
            "reg ),\n\t\t\t.i_mem_result(mem_result),\n\t\t// }}}\n\t\t// Accounting/CPU usage interface\n\t\t.o_op_stall(o_op_stall), .o_pf_stall(o_pf_stall),\n\t\t.o_i_count(o_i_count),\n\t\t//\n\t\t.o_debug(o_cpu_debug),\n\t\t//\n\t\t.o_prof_stb(  o_prof_stb),\n\t\t.o_prof_addr( o_prof_addr),\n\t\t.o_prof_ticks(o_prof_ticks)\n\t\t// }}}\n\t);\n`endif\n\tassign\to_cmd_reset\t= cmd_reset;\n\tassign\to_gie\t\t= cpu_dbg_cc[1];\n\tassign\tdbg_write_stall\t= dbg_write_valid && cpu_dbg_stall;\n\tassign\tcpu_has_halted  = !cpu_dbg_stall;\n\tassign\to_halted\t= cpu_has_halted;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Instruction Fetch\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\n`ifndef\tFORMAL\n\n\t\taxilfetch #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH),\n\t\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t\t.FETCH_LIMIT(FETCH_LIMIT),\n\t\t\t.SWAP_ENDIANNESS(SWAP_ENDIANNESS)\n\t\t\t// }}}\n\t\t) pf (\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN),\n\t\t\t// CPU signals\n\t\t\t// {{{\n\t\t\t.i_cpu_reset(cmd_reset),\n\t\t\t.i_new_pc(pf_new_pc),\n\t\t\t.i_clear_cache(clear_icache),\n\t\t\t.i_ready(pf_ready && clk_gate),\n\t\t\t.i_pc(pf_request_address),\n\t\t\t.o_insn(pf_instruction),\n\t\t\t.o_pc(pf_instruction_pc),\n\t\t\t.o_valid(pf_valid),\n\t\t\t.o_illegal(pf_illegal),\n\t\t\t// }}}\n\t\t\t// AXI-lite bus signals\n\t\t\t// {{{\n\t\t\t.M_AXI_ARVALID(M_INSN_ARVALID),\n\t\t\t.M_AXI_ARREADY(M_INSN_ARREADY),\n\t\t\t.M_AXI_ARADDR(M_INSN_ARADDR),\n\t\t\t.M_AXI_ARPROT(M_INSN_ARPROT),\n\t\t\t//\n\t\t\t.M_AXI_RVALID(M_INSN_RVALID),\n\t\t\t.M_AXI_RREADY(M_INSN_RREADY),\n\t\t\t.M_AXI_RDATA(M_INSN_RDATA),\n\t\t\t.M_AXI_RRESP(M_INSN_RRESP)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n`endif\n\n\t// Assign values to the (unused) M_INSN_* write ports\n\t// {{{\n\tassign\tM_INSN_AWVALID = 0;\n\tassign\tM_INSN_AWADDR  = 0;\n\tassign\tM_INSN_AWPROT  = 0;\n\t//\n\tassign\tM_INSN_WVALID = 0;\n\tassign\tM_INSN_WDATA  = 0;\n\tassign\tM_INSN_WSTRB  = 0;\n\t//\n\tassign\tM_INSN_BREADY = 1'b1;\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Memory Unit\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n`ifndef\tFORMAL",
            "wire [C_AXI_DATA_WIDTH-1:0]\ti_bus_data, o_bus_data;",
            "wire [C_AXI_DATA_WIDTH/8-1:0]\to_bus_strb;\n\n\tgenerate if (SWAP_WSTRB && C_AXI_DATA_WIDTH > 32 && !OPT_DCACHE)\n\tbegin : SWAP_BUS_WORD_ORDER\n\t\tgenvar\tgk;\n\n\t\tfor(gk=0; gk<C_AXI_DATA_WIDTH/32; gk=gk+1)\n\t\tbegin\n\t\t\tassign\ti_bus_data[(C_AXI_DATA_WIDTH-32-gk*32) +: 32]\n\t\t\t\t\t\t= M_DATA_RDATA[gk*32 +: 32];\n\t\t\tassign\tM_DATA_WDATA[gk*32 +: 32]\n\t\t\t\t= o_bus_data[(C_AXI_DATA_WIDTH-32-gk*32) +: 32];\n\t\t\tassign\tM_DATA_WSTRB[gk* 4 +:  4]\n\t\t\t\t= o_bus_strb[(C_AXI_DATA_WIDTH/8-4-gk*4) +: 4];\n\t\tend\n\n\tend else begin : KEEP_BUS_WORD_ORDER\n\t\t// {{{\n\t\tassign\ti_bus_data = M_DATA_RDATA;\n\t\tassign\tM_DATA_WDATA = o_bus_data;\n\t\tassign\tM_DATA_WSTRB = o_bus_strb;\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate if (OPT_PIPELINED_BUS_ACCESS)\n\tbegin : PIPELINED_MEM\n\n\t\taxilpipe #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH),\n\t\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t\t.OPT_ALIGNMENT_ERR(OPT_ALIGNMENT_ERR),\n\t\t\t.SWAP_WSTRB(SWAP_WSTRB),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER)\n\t\t\t// .OPT_SIGN_EXTEND(OPT_SIGN_EXTEND)\n\t\t\t// }}}\n\t\t) domem(\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN),\n\t\t\t.i_cpu_reset(cmd_reset),\n\t\t\t// CPU interface\n\t\t\t// {{{\n\t\t\t.i_stb(mem_ce),\n\t\t\t.i_lock(bus_lock),\n\t\t\t.i_op(mem_op),\n\t\t\t.i_addr(mem_cpu_addr),\n\t\t\t.i_data(mem_wdata),\n\t\t\t.i_o",
            "reg (mem_",
            "reg ),\n\t\t\t.o_busy(mem_busy),\n\t\t\t.o_pipe_stalled(mem_pipe_stalled),\n\t\t\t.o_rdbusy(mem_rdbusy),\n\t\t\t.o_valid(mem_valid),\n\t\t\t.o_err(mem_bus_err),\n\t\t\t.o_w",
            "reg (mem_w",
            "reg ),\n\t\t\t.o_result(mem_result),\n\t\t\t// }}}\n\t\t\t// AXI-lite\n\t\t\t// Write interface\n\t\t\t// {{{\n\t\t\t.M_AXI_AWVALID(M_DATA_AWVALID),\n\t\t\t.M_AXI_AWREADY(M_DATA_AWREADY),\n\t\t\t.M_AXI_AWADDR( M_DATA_AWADDR),\n\t\t\t.M_AXI_AWPROT( M_DATA_AWPROT),\n\t\t\t//\n\t\t\t.M_AXI_WVALID(M_DATA_WVALID),\n\t\t\t.M_AXI_WREADY(M_DATA_WREADY),\n\t\t\t.M_AXI_WDATA(o_bus_data),\n\t\t\t.M_AXI_WSTRB(o_bus_strb),\n\t\t\t//\n\t\t\t.M_AXI_BVALID(M_DATA_BVALID),\n\t\t\t.M_AXI_BREADY(M_DATA_BREADY),\n\t\t\t.M_AXI_BRESP( M_DATA_BRESP),\n\t\t\t// }}}\n\t\t\t// Read interface\n\t\t\t// {{{\n\t\t\t.M_AXI_ARVALID(M_DATA_ARVALID),\n\t\t\t.M_AXI_ARREADY(M_DATA_ARREADY),\n\t\t\t.M_AXI_ARADDR( M_DATA_ARADDR),\n\t\t\t.M_AXI_ARPROT( M_DATA_ARPROT),\n\t\t\t//\n\t\t\t.M_AXI_RVALID(M_DATA_RVALID),\n\t\t\t.M_AXI_RREADY(M_DATA_RREADY),\n\t\t\t.M_AXI_RDATA( i_bus_data),\n\t\t\t.M_AXI_RRESP( M_DATA_RRESP)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\tend else begin : BARE_MEM\n\n\t\taxilops\t#(\n\t\t\t// {{{\n\t\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH),\n\t\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t\t.SWAP_ENDIANNESS(SWAP_ENDIANNESS),\n\t\t\t.SWAP_WSTRB(SWAP_WSTRB),\n\t\t\t.OPT_ALIGNMENT_ERR(OPT_ALIGNMENT_ERR),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER)\n\t\t\t// }}}\n\t\t) domem(\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN),\n\t\t\t.i_cpu_reset(cmd_reset),\n\t\t\t// CPU interface\n\t\t\t// {{{\n\t\t\t.i_stb(mem_ce),\n\t\t\t.i_lock(bus_lock),\n\t\t\t.i_op(mem_op),\n\t\t\t.i_addr(mem_cpu_addr[ADDRESS_WIDTH-1:0]),\n\t\t\t.i_data(mem_wdata),\n\t\t\t.i_o",
            "reg (mem_",
            "reg ),\n\t\t\t.o_busy(mem_busy),\n\t\t\t.o_rdbusy(mem_rdbusy),\n\t\t\t.o_valid(mem_valid),\n\t\t\t.o_err(mem_bus_err),\n\t\t\t.o_w",
            "reg (mem_w",
            "reg ),\n\t\t\t.o_result(mem_result),\n\t\t\t// }}}\n\t\t\t// AXI-lite\n\t\t\t// Write interface\n\t\t\t// {{{\n\t\t\t.M_AXI_AWVALID(M_DATA_AWVALID),\n\t\t\t.M_AXI_AWREADY(M_DATA_AWREADY),\n\t\t\t.M_AXI_AWADDR( M_DATA_AWADDR),\n\t\t\t.M_AXI_AWPROT( M_DATA_AWPROT),\n\t\t\t//\n\t\t\t.M_AXI_WVALID(M_DATA_WVALID),\n\t\t\t.M_AXI_WREADY(M_DATA_WREADY),\n\t\t\t.M_AXI_WDATA(o_bus_data),\n\t\t\t.M_AXI_WSTRB(o_bus_strb),\n\t\t\t//\n\t\t\t.M_AXI_BVALID(M_DATA_BVALID),\n\t\t\t.M_AXI_BREADY(M_DATA_BREADY),\n\t\t\t.M_AXI_BRESP( M_DATA_BRESP),\n\t\t\t// }}}\n\t\t\t// Read interface\n\t\t\t// {{{\n\t\t\t.M_AXI_ARVALID(M_DATA_ARVALID),\n\t\t\t.M_AXI_ARREADY(M_DATA_ARREADY),\n\t\t\t.M_AXI_ARADDR( M_DATA_ARADDR),\n\t\t\t.M_AXI_ARPROT( M_DATA_ARPROT),\n\t\t\t//\n\t\t\t.M_AXI_RVALID(M_DATA_RVALID),\n\t\t\t.M_AXI_RREADY(M_DATA_RREADY),\n\t\t\t.M_AXI_RDATA( i_bus_data),\n\t\t\t.M_AXI_RRESP( M_DATA_RRESP)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\tmem_pipe_stalled = mem_busy;\n\tend endgenerate\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Optional) Clock gate\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_CLKGATE)\n\tbegin : GATE_CPU_CLOCK",
            "reg gatep;",
            "reg gaten /* verilator clock_enable */;\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tgatep <= 1'b1;\n\t\telse\n\t\t\tgatep <= cpu_clken || arskd_valid || dbg_write_valid\n\t\t\t\t\t\t|| dbg_blkram_stall;\n\n\t\talways @(negedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tgaten <= 1'b1;\n\t\telse\n\t\t\tgaten <= gatep;\n\n\t\tassign\tcpu_clock = S_AXI_ACLK && gaten;\n\t\tassign\tclk_gate = gatep;\n\n\tend else begin : NO_CLOCK_GATE\n\n\t\tassign\tcpu_clock = S_AXI_ACLK;\n\t\tassign\tclk_gate = 1'b1;\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Simulation only accesses, to make the simulation display work\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n`ifdef\tVBENCH_TB\n\tassign\tearly_branch = core.dcd_early_branch;\n\tassign\tearly_branch_pc = core.dcd_branch_pc;\n\n\tassign\tdcdA = core.dcd_full_A;\n\tassign\tdcdB = core.dcd_full_B;\n\n\tassign\tnew_pc = core.new_pc;\n\tassign\tcpu_ipc= core.ipc;\n\tassign\tcpu_upc= core.upc;\n\tassign\tpf_pc  = core.pf_pc;\n\n\t// assign\tpf_cyc = thecpu.pf_cyc;\n\t// assign\tpf_stb = thecpu.pf_stb;\n\t// assign\tpf_we  = thecpu.pf_we;\n\t// assign\tpf_addr= { thecpu.pf_addr, 2'b00 };\n\t// assign\tpf_ack = thecpu.pf_ack;\n\t// assign\tpf_valid = core.i_pf_valid;\n\t// assign\tpf_illegal = core.i_pf_illegal;\n\t// assign\tcpu_idata  = core.i_wb_data;\n\t// assign\tpf_instruction = core.i_pf_instruction;\n\t// assign\tpf_instruction_pc = core.i_pf_instruction_pc;\n\t//\n\t// Peeking into the decode stage\n\t// {{{\n\tassign\tdcd_ce      = core.dcd_ce;\n\tassign\tdcd_stalled = core.dcd_stalled;\n\tassign\tdcd_gie     = core.dcd_gie;\n\tassign\tdcd_valid   = core.dcd_valid;\n\tassign\tdcd_illegal = core.dcd_illegal;\n\tassign\tdcd_phase   = core.dcd_phase;\n\tassign\tdcd_break   = core.dcd_break;\n\tassign\tdcd_pipe    = core.dcd_pipe;\n\t\t//\n\tassign\tdcd_opn     = core.dcd_opn;\n\tassign\tdcd_rA      = core.dcd_rA;\n\tassign\tdcd_rB      = core.dcd_rB;\n\tassign\tdcd_wR      = core.dcd_wR;\n\tassign\tdcd_wF      = core.dcd_wF;\n\tassign\tdcdR        = core.instruction_decoder.w_dcdR;\n\tassign\tdcdRpc      = core.instruction_decoder.w_dcdR_pc;\n\tassign\tdcdRcc      = core.instruction_decoder.w_dcdR_cc;\n\tassign\tdcd_pc      = core.dcd_pc;\n\tassign\tdcd_M       = core.dcd_M;\n\t// }}}\n\t// Peeking into the op stage\n\t// {{{\n\tassign\top_ce        = core.op_ce;\n\tassign\top_illegal   = core.op_illegal;\n\tassign\top_valid     = core.op_valid;\n\tassign\top_valid_mem = core.op_valid_mem;\n\tassign\top_valid_alu = core.op_valid_alu;\n\tassign\top_stall     = core.op_stall;\n\tassign\top_wR        = core.op_wR;\n\tassign\top_wF        = core.op_wF;\n\tassign\top_phase     = core.op_phase;\n\tassign\top_gie       = core.op_gie;\n\tassign\top_pipe      = core.op_pipe;\n\tassign\top_R         = core.op_R;\n\tassign\top_Aid       = core.op_Aid;\n\tassign\top_Bid       = core.op_Bid;\n\tassign\top_Av        = core.op_Av;\n\tassign\top_Bv        = core.op_Bv;\n\tassign\top_pc        = core.op_pc;\n\tassign\tmaster_stall = core.master_stall;\n\n\tassign\top_F         = core.op_F;\n\tassign\top_pipe      = core.op_pipe;\n\tassign\top_opn       = core.op_opn;\n\t// }}}\n\t// Peeking into the ALU stage\n\t// {{{\n\tassign\talu_ce   = core.alu_ce;\n\tassign\tadf_ce_unconditional   = core.adf_ce_unconditional;\n\tassign\talu_valid      = core.alu_valid;\n\tassign\talu_wR         = core.alu_wR;\n\tassign\talu_wF         = core.alu_wF;\n\tassign\talu_pc_valid   = core.alu_pc_valid;\n\tassign\talu_illegal    = core.alu_illegal;\n\tassign\talu_gie        = core.alu_gie;\n\tassign\tset_cond       = core.set_cond;\n\tassign\talu_phase      = core.alu_phase;\n\tassign\talu_flags      = core.alu_flags;\n\tassign\talu_pc         = core.alu_pc;\n\n\tassign\talu_result     = core.alu_result;\n\tassign\talu_busy       = core.alu_busy;\n\tassign\talu_",
            "reg = core.alu_",
            "reg ;\n\t// }}}\n\t// Peeking into the MEM stage\n\t// {{{\n\t//\n\t// assign\tmem_valid    = core.i_mem_valid;\n\tassign\tmem_pc_valid = core.mem_pc_valid;\n\t// assign\tmem_ce       = core.o_mem_ce;\n\t// assign\tmem_busy     = core.i_mem_busy;\n\t// assign\tmem_rdbusy   = core.i_mem_rdbusy;\n\t// assign\tmem_w",
            "reg = core.i_mem_w",
            "reg ;\n\t// }}}\n\t// Peeking into the divide stage\n\t// {{{\n\tassign\tdiv_valid = core.div_valid;\n\tassign\tdiv_ce    = core.div_ce;\n\tassign\tdiv_busy  = core.div_busy;\n\t// }}}\n\t// Writeback stage\n\t// {{{\n\tassign\twr_",
            "reg _id = core.wr_",
            "reg _id;\n\tassign\twr_",
            "reg _ce = core.wr_",
            "reg _ce;\n\tassign\twr_flags_ce = core.wr_flags_ce;\n\tassign\twr_gp",
            "reg _vl = core.wr_gp",
            "reg _vl;\n\tassign\twr_sp",
            "reg _vl = core.wr_sp",
            "reg _vl;\n\tassign\tw_iflags    = core.w_iflags;\n\tassign\tw_uflags    = core.w_uflags;\n\t// }}}\n\t// Miscellaneous\n\t// {{{\n\tassign\tcpu_sim      = core.cpu_sim;\n\tassign\tcpu_sim_immv = core.op_sim_immv;\n\tassign\tr_sleep      = core.sleep;\n\tassign\tmaster_ce    = core.master_ce;\n\tassign\top_break     = core.op_break;\n\tassign\tr_gie        = core.gie;\n\t// }}}\n\t//\n\t// ZipSystem peripherals\n\t// {{{\n\tassign\twatchbus = 32'h0;\n\tassign\twatchdog = 32'h0;\n\tassign\ttimer_a = 32'h0;\n\tassign\ttimer_b = 32'h0;\n\tassign\ttimer_c = 32'h0;\n\tassign\tjiffies = 32'h0;\n\tassign\twdbus_data = 32'h0;\n\tassign\tpic_data = 32'h0;\n\tassign\tutc_data = 32'h0;\n\tassign\tuoc_data = 32'h0;\n\tassign\tupc_data = 32'h0;\n\tassign\tuic_data = 32'h0;\n\tassign\tmtc_data = 32'h0;\n\tassign\tmoc_data = 32'h0;\n\tassign\tmpc_data = 32'h0;\n\tassign\tmic_data = 32'h0;\n\t//\n\tassign\tint_state = 16'h0;\n\tassign\talt_int_state = 16'h0;\n\t// assign\twb_cyc_gbl = mem_cyc_gbl;\n\t// assign\twb_stb_gbl = mem_stb_gbl;\n\t// assign\twb_cyc_lcl = mem_cyc_lcl;\n\t// assign\twb_stb_lcl = mem_stb_lcl;\n\t// assign\tmem_stb_gbl = mem_stb_gbl;\n\t// assign\tmem_stb_lcl = mem_stb_lcl;\n\t// assign\tmem_we     = mem_we;\n\t// assign\tmem_ack    = mem_ack;\n\t// assign\tmem_stall  = mem_stall;\n\tassign\tmem_data   = mem_wdata;\n\tassign\tmem_addr   = { core.o_mem_addr };\n\t// assign\tmem_result = core.i_mem_result;\n\tassign\tswitch_to_interrupt = core.w_switch_to_interrupt;\n\tassign\trelease_from_interrupt = core.w_release_from_interrupt;\n\tassign\tbreak_en = core.break_en;\n\t// }}}\n`endif\n\t// }}}\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, cpu_clken, cpu_dbg_cc[2],\n\t\t\tS_DBG_AWADDR[DBGLSB-1:0],\n\t\t\tmem_lock_pc, clear_dcache,\n\t\t\tS_DBG_ARADDR[DBGLSB-1:0],\n\t\t\tS_DBG_ARPROT, S_DBG_AWPROT,\n\t\t\tM_INSN_AWREADY, M_INSN_WREADY,\n\t\t\tM_INSN_BVALID, M_INSN_BRESP\n\t\t};\n\tgenerate if (32 > ADDRESS_WIDTH)\n\tbegin : GEN_UNUSED_ADDR",
            "wire unused_addr;\n\t\tassign\tunused_addr = &{ 1'b0, mem_cpu_addr[31:ADDRESS_WIDTH] };\n\tend endgenerate\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "wire [F_LGDEPTH-1:0]\tfaxil_rd_outstanding,\n\t\t\t\tfaxil_wr_outstanding, faxil_awr_outstanding;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI-lite debug interface\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\n\tfaxil_slave #(\n\t\t// {{{\n\t\t.C_AXI_DATA_WIDTH(C_DBG_DATA_WIDTH),\n\t\t.C_AXI_ADDR_WIDTH(C_DBG_ADDR_WIDTH),\n\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t.F_AXI_MAXWAIT(0),\n\t\t.F_AXI_MAXDELAY(0)\n\t\t// }}}\n\t) faxil (\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN),\n\t\t// AXI-lite debug writes\n\t\t// {{{\n\t\t.i_axi_awvalid(S_DBG_AWVALID),\n\t\t.i_axi_awready(S_DBG_AWREADY),\n\t\t.i_axi_awaddr(S_DBG_AWADDR),\n\t\t.i_axi_awprot(S_DBG_AWPROT),\n\t\t//\n\t\t.i_axi_wvalid(S_DBG_WVALID),\n\t\t.i_axi_wready(S_DBG_WREADY),\n\t\t.i_axi_wdata(S_DBG_WDATA),\n\t\t.i_axi_wstrb(S_DBG_WSTRB),\n\t\t//\n\t\t.i_axi_bvalid(S_DBG_BVALID),\n\t\t.i_axi_bready(S_DBG_BREADY),\n\t\t.i_axi_bresp(S_DBG_BRESP),\n\t\t// }}}\n\t\t// AXI-lite debug reads\n\t\t// {{{\n\t\t.i_axi_arvalid(S_DBG_ARVALID),\n\t\t.i_axi_arready(S_DBG_ARREADY),\n\t\t.i_axi_araddr(S_DBG_ARADDR),\n\t\t.i_axi_arprot(S_DBG_ARPROT),\n\t\t//\n\t\t.i_axi_rvalid(S_DBG_RVALID),\n\t\t.i_axi_rready(S_DBG_RREADY),\n\t\t.i_axi_rdata(S_DBG_RDATA),\n\t\t.i_axi_rresp(S_DBG_RRESP),\n\t\t// }}}\n\t\t// Induction\n\t\t// {{{\n\t\t.f_axi_rd_outstanding(faxil_rd_outstanding),\n\t\t.f_axi_wr_outstanding(faxil_wr_outstanding),\n\t\t.f_axi_awr_outstanding(faxil_awr_outstanding)\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (S_AXI_ARESETN)\n\tbegin\n\t\tassert(faxil_rd_outstanding == (S_DBG_ARREADY ? 0:1)\n\t\t\t\t+(dbg_read_valid ? 1:0) + (S_DBG_RVALID ? 1:0));\n\n\t\tassert(!dbg_read_valid || !S_DBG_RVALID);\n\n\t\tassert(faxil_wr_outstanding == (S_DBG_WREADY ? 0:1)\n\t\t\t\t+(S_DBG_BVALID ? 1:0));\n\n\t\tassert(faxil_awr_outstanding == (S_DBG_AWREADY ? 0:1)\n\t\t\t\t+(S_DBG_BVALID ? 1:0));\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// CPU's debug interface\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Captured above\n\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipsystem.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipsystem.v",
        "chunks": [
            "wire d to the reset line instead of\n//\t\tthe interrupt line of the CPU.\n//\n//\tDirect Memory Access Controller: This controller allows you to command\n//\t\tautomatic memory moves.  Such memory moves will take place\n//\t\twithout the CPU's involvement until they are done.  See the\n//\t\tDMA specification for more information. (Currently contained\n//\t\tw/in the ZipCPU spec.)\n//\n//\t(Potentially an eventual floating point co-processor ...?)\n//\n// Busses:\tThe ZipSystem implements a series of busses to make this take\n//\t\tplace.  These busses are identified by their prefix:\n//\n//\tcpu\tThis is the bus as the CPU sees it.  Since the CPU controls\n//\t\ttwo busses (a local and a global one), it uses _gbl_ to indicate\n//\t\tthe external bus (going through the MMU if necessary) and\n//\t\t_lcl_ to indicate a peripheral bus seen here.\n//\n//\tmmu\tSits between the CPU's wishbone interface and the external\n//\t\tbus.  Has no access to peripherals.\n//\n//\tsys\tA local bus implemented here within this space.  This is how the\n//\t\tCPU talks to the ZipSystem peripherals.  However, this bus\n//\t\tcan also be accessed from the external debug bus.\n//\n//\tio_dbg\n//\tio_wb\n//\n//\tdbg\tThis is identical to the io_dbg bus, but separated by a clock\n//\tdc\tThe",
            "output of the DMA controller\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}\n//\n// Debug address space:\n// {{{\n//\t 0-15\t0x0?\tSupervisors",
            "reg isters\n//\t16-31\t0x1?\tUser",
            "reg isters\n//\t32-63\t0x2?\tCPU command",
            "reg ister (singular, one",
            "reg ister only)\n//\t64\t0x40\tInterrupt controller\n//\t65\t0x41\tWatchdog\n//\t66\t0x42\tBus watchdog\n//\t67\t0x43\tCTRINT\n//\t68\t0x44\tTimer A\n//\t69\t0x45\tTimer B\n//\t70\t0x46\tTimer C\n//\t71\t0x47\tJiffies\n//\t72\t0x48\tMaster task counter\n//\t73\t0x49\tMaster task counter\n//\t74\t0x4a\tMaster task counter\n//\t75\t0x4b\tMaster instruction counter\n//\t76\t0x4c\tUser task counter\n//\t77\t0x4d\tUser task counter\n//\t78\t0x4e\tUser task counter\n//\t79\t0x4f\tUser instruction counter\n//\t80\t0x50\tDMAC\tControl/Status",
            "reg ister\n//\t81\t0x51\tDMAC\tLength\n//\t82\t0x52\tDMAC\tRead (source) address\n//\t83\t0x53\tDMAC\tWrite (destination) address\n//\n/////// /////// /////// ///////\n//\n//\t(MMU ... is not available via debug bus)\n// }}}",
            "module zipsystem #(\n\t\t// {{{",
            "parameter RESET_ADDRESS=32'h1000_0000,\n\t\t\t\tADDRESS_WIDTH=32,",
            "parameter BUS_WIDTH=32,\t// Bus data width",
            "localparam DBG_WIDTH=32,\n\t\t// CPU options\n\t\t// {{{",
            "parameter [0:0]\tOPT_PIPELINED=1,",
            "parameter [0:0]\tOPT_EARLY_BRANCHING=OPT_PIPELINED,\n\t\t// OPT_LGICACHE\n\t\t// {{{",
            "parameter OPT_LGICACHE=10,\n\t\t// }}}\n\t\t// OPT_LGDCACHE\n\t\t// {{{\n\t\t// Set to zero for no data cache",
            "parameter OPT_LGDCACHE=10,\n\t\t// }}}",
            "parameter [0:0]\tSTART_HALTED=1,",
            "parameter [0:0]\tOPT_DISTRIBUTED_REGS=1,",
            "parameter EXTERNAL_INTERRUPTS=1,\n\t\t// OPT_MPY\n\t\t// {{{",
            "parameter OPT_MPY = 3,\n\t\t// }}}\n\t\t// OPT_DIV\n\t\t// {{{",
            "parameter [0:0]\tOPT_DIV=1,\n\t\t// }}}\n\t\t// OPT_SHIFTS\n\t\t// {{{",
            "parameter [0:0]\tOPT_SHIFTS = 1,\n\t\t// }}}\n\t\t// OPT_FPU\n\t\t// {{{",
            "parameter [0:0]\tOPT_FPU = 0,\n\t\t// }}}",
            "parameter [0:0]\tOPT_CIS=1,",
            "parameter [0:0]\tOPT_LOCK=1,",
            "parameter [0:0]\tOPT_USERMODE=1,",
            "parameter [0:0]\tOPT_DBGPORT=START_HALTED,",
            "parameter [0:0]\tOPT_TRACE_PORT=1,",
            "parameter [0:0]\tOPT_PROFILER=0,",
            "parameter [0:0]\tOPT_LOWPOWER=0,\n\t\t// }}}\n\t\t// Local bus options\n\t\t// {{{\n\t\t// OPT_DMA\n\t\t// {{{",
            "parameter [0:0]\tOPT_DMA=1,",
            "parameter DMA_LGMEM = 10,\n\t\t// }}}\n\t\t// OPT_ACCOUNTING\n\t\t// {{{",
            "parameter [0:0]\tOPT_ACCOUNTING = 1'b1,\n\t\t// }}}\n\t\t// Bus delay options\n\t\t// {{{\n\t\t// While I hate adding delays to any bus access, this next\n\t\t// delay is required to make timing close in my Basys-3 design.",
            "parameter [0:0]\t\tDELAY_DBG_BUS = 1'b1,\n\t\t//",
            "parameter [0:0]\t\tDELAY_EXT_BUS = 1'b0,\n\t\t// }}}\n`ifdef\tVERILATOR",
            "parameter [0:0]\tOPT_SIM=1'b1,",
            "parameter [0:0]\tOPT_CLKGATE = OPT_LOWPOWER,\n`else",
            "parameter [0:0]\tOPT_SIM=1'b0,",
            "parameter [0:0]\tOPT_CLKGATE = 1'b0,\n`endif\n\t\t// }}}",
            "parameter RESET_DURATION = 0,\n\t\t// Short-cut names\n\t\t// {{{",
            "localparam // Derived",
            "parameter s\n\t\t\t\t// PHYSICAL_ADDRESS_WIDTH=ADDRESS_WIDTH,\n\t\t\t\tPAW=ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)\n\t\t// }}}\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Wishbone master interface from the CPU\n\t\t// {{{",
            "output ",
            "wire o_wb_cyc, o_wb_stb, o_wb_we,",
            "output ",
            "wire [PAW-1:0]\t\to_wb_addr,",
            "output ",
            "wire [BUS_WIDTH-1:0]\to_wb_data,",
            "output ",
            "wire [BUS_WIDTH/8-1:0]\to_wb_sel,",
            "input ",
            "wire i_wb_stall, i_wb_ack,",
            "input ",
            "wire [BUS_WIDTH-1:0]\ti_wb_data,",
            "input ",
            "wire i_wb_err,\n\t\t// }}}\n\t\t// Incoming interrupts",
            "input ",
            "wire [(EXTERNAL_INTERRUPTS-1):0]\ti_ext_int,\n\t\t// Our one outgoing interrupt",
            "output ",
            "wire o_ext_int,\n\t\t// Wishbone slave interface for debugging purposes\n\t\t// {{{",
            "input ",
            "wire i_dbg_cyc, i_dbg_stb, i_dbg_we,",
            "input ",
            "wire [6:0]\t\ti_dbg_addr,",
            "input ",
            "wire [DBG_WIDTH-1:0]\ti_dbg_data,",
            "input ",
            "wire [DBG_WIDTH/8-1:0]\ti_dbg_sel,",
            "output ",
            "wire o_dbg_stall,",
            "output ",
            "wire o_dbg_ack,",
            "output ",
            "wire [DBG_WIDTH-1:0]\to_dbg_data,\n\t\t// }}}",
            "output ",
            "wire [31:0]\t\to_cpu_debug,\n\t\t//\n`ifdef\tVBENCH_TB\n\t\t// {{{\n\t\t//",
            "output ",
            "wire cpu_halt,\n\t\t//\t\t\t\tcmd_reset,\n\t\t//\t\t\t\tcmd_step,",
            "output ",
            "wire early_branch,",
            "output ",
            "wire [31:0]\t\tearly_branch_pc,",
            "output ",
            "wire [6:0]\t\tdcdA, dcdB,",
            "output ",
            "wire new_pc,",
            "output ",
            "wire [31:0]\t\tcpu_ipc, cpu_upc, pf_pc,",
            "output ",
            "wire pf_cyc, pf_stb, pf_we,",
            "output ",
            "wire [31:0]\t\tpf_addr,",
            "output ",
            "wire pf_ack,",
            "output ",
            "wire pf_valid, pf_illegal,\n\t\t// pf_vmask, pf_r_v, pf_tagsrc, pf_tagipc, pf_tagvallst,\n\t\t//",
            "output ",
            "wire [31:0]\t\tpf_lastpc,",
            "output ",
            "wire [31:0]\t\tpf_instruction,",
            "output ",
            "wire [31:0]\t\tpf_instruction_pc,\n\t\t//",
            "output ",
            "wire dcd_ce, dcd_stalled, dcd_gie,\n\t\t\t\t\t\tdcd_valid, dcd_illegal,\n\t\t\t\t\t\tdcd_phase, dcd_break, dcd_pipe,",
            "output ",
            "wire [3:0]\t\tdcd_opn,",
            "output ",
            "wire dcd_rA, dcd_rB, dcd_wR, dcd_wF,",
            "output ",
            "wire [4:0]\t\tdcdR,",
            "output ",
            "wire dcdRpc, dcdRcc,",
            "output ",
            "wire [31:0]\t\tdcd_pc,",
            "output ",
            "wire dcd_M,\n\t\t//",
            "output ",
            "wire op_ce, op_illegal, op_valid,\n\t\t\t\t\t\top_valid_mem, op_valid_alu,\n\t\t\t\t\t\top_stall, op_wR, op_wF,\n\t\t\t\t\t\top_phase, op_gie,",
            "output ",
            "wire [4:0]\t\top_R, op_Aid, op_Bid,",
            "output ",
            "wire [31:0]\t\top_Av, op_Bv, op_pc,",
            "output ",
            "wire master_stall,\n\t\t//",
            "output ",
            "wire alu_ce, adf_ce_unconditional,\n\t\t\t\t\t\talu_valid, alu_wR, alu_wF,\n\t\t\t\t\t\talu_pc_valid, alu_illegal,\n\t\t\t\t\t\talu_gie,\n\t\t\t\t\t\tset_cond, alu_phase,",
            "output ",
            "wire [3:0]\t\talu_flags,",
            "output ",
            "wire [31:0]\t\talu_pc,\n\t\t//",
            "output ",
            "wire mem_valid, mem_pc_valid, mem_ce,\n\t\t\t\t\t\tmem_busy, mem_rdbusy,",
            "output ",
            "wire [4:0]\t\tmem_w",
            "reg ,\n\t\t//",
            "output ",
            "wire div_valid, div_ce, div_busy,\n\t\t//",
            "output ",
            "wire [4:0]\t\twr_",
            "reg _id,",
            "output ",
            "wire wr_",
            "reg _ce, wr_flags_ce,",
            "output ",
            "wire [31:0]\t\twr_gp",
            "reg _vl, wr_sp",
            "reg _vl,",
            "output ",
            "wire [15:0]\t\tw_iflags, w_uflags,\n\t\t//",
            "output ",
            "wire cpu_sim,\n\t\t\t\t\t\tr_sleep, master_ce, op_break,\n\t\t\t\t\t\tr_gie,",
            "output ",
            "wire [22:0]\t\tcpu_sim_immv,",
            "output ",
            "wire [7:0]\t\top_F,\n\t\t//",
            "output ",
            "wire dbg_cyc, dbg_stb, dbg_we,",
            "output ",
            "wire [6:0]\t\tdbg_addr,",
            "output ",
            "reg dbg_ack,",
            "output ",
            "wire [DBG_WIDTH-1:0]\tdbg_idata,",
            "output ",
            "wire sys_cyc, sys_stb, sys_we,",
            "output ",
            "wire [7:0]\t\tsys_addr,",
            "output ",
            "wire [DBG_WIDTH-1:0]\tsys_data,\n\t\t//",
            "output ",
            "wire [BUS_WIDTH-1:0]\tcpu_idata,",
            "output ",
            "wire cpu_stall,",
            "output ",
            "wire cpu_interrupt,\n\t\t//\n\t\t// ZipSystem peripherals",
            "output ",
            "wire [31:0]\t\twatchbus, watchdog, pic_data,\n\t\t\t\t\t\twdbus_data,",
            "output ",
            "wire [15:0]\t\tint_state, alt_int_state,",
            "output ",
            "wire [31:0]\t\ttimer_a,\n\t\t\t\t\t\ttimer_b, timer_c, jiffies,\n\t\t\t\t\t\tutc_data, uoc_data, uic_data,\n\t\t\t\t\t\tupc_data, mtc_data, moc_data,\n\t\t\t\t\t\tmpc_data, mic_data,",
            "output ",
            "wire wb_cyc_gbl, wb_cyc_lcl,\n\t\t\t\t\t\twb_stb_gbl, wb_stb_lcl,\n\t\t\t\t\t\tmem_stb_gbl, mem_stb_lcl,\n\t\t\t\t\t\tmem_we, mem_ack, mem_stall,",
            "output ",
            "wire [31:0]\t\tmem_data, mem_addr, mem_result,",
            "output ",
            "wire op_pipe,\n\t\t\t\t\t\t// op_A_alu, op_B_alu,\n\t\t\t\t\t\t// op_A_mem, op_B_mem,",
            "output ",
            "wire [3:0]\t\top_opn,",
            "output ",
            "wire [31:0]\t\talu_result,",
            "output ",
            "wire alu_busy,",
            "output ",
            "wire [4:0]\t\talu_",
            "reg ,",
            "output ",
            "wire switch_to_interrupt,\n\t\t\t\t\t\trelease_from_interrupt,\n\t\t\t\t\t\tbreak_en,",
            "output ",
            "wire pformem_owner,\n\t\t// }}}\n`endif",
            "output ",
            "wire o_prof_stb,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0]\to_prof_addr,",
            "output ",
            "wire [31:0]\t\to_prof_ticks\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{\n\t// Local",
            "parameter declarations\n\t// {{{",
            "localparam DW=BUS_WIDTH;\n\t// Peripheral addresses\n\t// {{{\n\t// Verilator lint_off UNUSED\n\t// These values may (or may not) be used, depending on whether or not\n\t// the respective peripheral is included in the CPU.",
            "localparam [31:0] PERIPHBASE = 32'hc0000000;",
            "localparam [7:0] INTCTRL     = 8'h0,\n\t\t\tWATCHDOG    = 8'h1, // Interrupt generates reset signal\n\t\t\tBUSWATCHDOG = 8'h2,\t// Sets IVEC[0]\n\t\t\tCTRINT      = 8'h3,\t// Sets IVEC[5]\n\t\t\tTIMER_A     = 8'h4,\t// Sets IVEC[4]\n\t\t\tTIMER_B     = 8'h5,\t// Sets IVEC[3]\n\t\t\tTIMER_C     = 8'h6,\t// Sets IVEC[2]\n\t\t\tJIFFIES     = 8'h7,\t// Sets IVEC[1]\n\t\t\t// Accounting counter addresses\n\t\t\tMSTR_TASK_CTR = 8'h08,\n\t\t\tMSTR_MSTL_CTR = 8'h09,\n\t\t\tMSTR_PSTL_CTR = 8'h0a,\n\t\t\tMSTR_INST_CTR = 8'h0b,\n\t\t\tUSER_TASK_CTR = 8'h0c,\n\t\t\tUSER_MSTL_CTR = 8'h0d,\n\t\t\tUSER_PSTL_CTR = 8'h0e,\n\t\t\tUSER_INST_CTR = 8'h0f,\n\t\t\t// The MMU\n\t\t\tMMU_ADDR = 8'h80,\n\t\t\t// DMA controller (DMAC)\n\t\t\t// Although I have a hole at 5'h2, the DMA controller\n\t\t\t// requires four wishbone addresses, therefore we place\n\t\t\t// it by itself and expand our address bus width here\n\t\t\t// by another bit.\n\t\t\tDMAC_ADDR = 8'h10;\n\t// Verilator lint_on  UNUSED\n\t// }}}\n\n\t// Debug bit allocations\n\t// {{{\n\t//\tDBGCTRL\n\t//\t\t 5 DBG Catch -- Catch exceptions/fautls w/ debugger\n\t//\t\t 4 Clear cache\n\t//\t\t 3 RESET_FLAG\n\t//\t\t 2 STEP\t(W=1 steps, and returns to halted)\n\t//\t\t 1 HALT(ED)\n\t//\t\t 0 HALT\n\t//\tDBGDATA\n\t//\t\tread/writes internal",
            "reg isters\n\t//",
            "localparam HALT_BIT = 0,\n\t\t\tSTEP_BIT = 2,\n\t\t\tRESET_BIT = 3,\n\t\t\tCLEAR_CACHE_BIT = 4,\n\t\t\tCATCH_BIT = 5;\n\t// }}}\n\n\t// Virtual address width (unused)\n\t// {{{",
            "localparam `ifdef\tOPT_MMU\n\t\t\t\tVIRTUAL_ADDRESS_WIDTH=30;\n`else\n\t\t\t\tVIRTUAL_ADDRESS_WIDTH=PAW;\n`endif\n\t\t\t\t// LGTLBSZ = 6,\t// Log TLB size\n\t\t\t\t// VAW=VIRTUAL_ADDRESS_WIDTH,\n\t// }}}",
            "localparam [1:0]\tDBG_ADDR_CTRL= 2'b00,\n\t\t\t\tDBG_ADDR_CPU = 2'b01,\n\t\t\t\tDBG_ADDR_SYS = 2'b10;\n\t// }}}",
            "wire [14:0]\tmain_int_vector, alt_int_vector;",
            "wire ctri_int, tma_int, tmb_int, tmc_int, jif_int, dmac_int;",
            "wire mtc_int, moc_int, mpc_int, mic_int,\n\t\t\tutc_int, uoc_int, upc_int, uic_int;",
            "wire [DBG_WIDTH-1:0]\tactr_data;",
            "wire actr_ack, actr_stall;",
            "wire cpu_clken;\n\t//\n\t//\n`ifndef\tVBENCH_TB",
            "wire sys_cyc, sys_stb, sys_we;",
            "wire [7:0]\t\tsys_addr;",
            "wire [DBG_WIDTH-1:0]\tsys_data;\n`endif",
            "wire [PAW-1:0]\tcpu_addr;",
            "reg [DBG_WIDTH-1:0]\tsys_idata;",
            "reg sys_ack;",
            "wire sys_stall;",
            "wire sel_counter, sel_timer, sel_pic, sel_apic,\n\t\tsel_watchdog, sel_bus_watchdog, sel_dmac, sel_mmus;\n\n`ifndef\tVBENCH_TB",
            "wire dbg_cyc, dbg_stb, dbg_we;",
            "wire [6:0]\t\t\tdbg_addr;",
            "wire [DBG_WIDTH-1:0]\t\tdbg_idata;",
            "reg dbg_ack;\n`endif",
            "wire dbg_stall;",
            "reg [DBG_WIDTH-1:0]\t\tdbg_odata;",
            "wire [DBG_WIDTH/8-1:0]\tdbg_sel;",
            "wire no_dbg_err;",
            "wire cpu_break, dbg_cmd_write,\n\t\t\t\tdbg_cpu_write, dbg_cpu_read;",
            "wire [DBG_WIDTH-1:0]\tdbg_cmd_data;",
            "wire [DBG_WIDTH/8-1:0]\tdbg_cmd_strb;",
            "wire reset_hold, halt_on_fault, dbg_catch;",
            "wire reset_request, release_request, halt_request,\n\t\t\t\tstep_request, clear_cache_request;",
            "reg cmd_reset, cmd_halt, cmd_step, cmd_clear_cache,\n\t\t\t\tcmd_write, cmd_read;",
            "reg [4:0]\t\tcmd_waddr;",
            "reg [DBG_WIDTH-1:0]\tcmd_wdata;",
            "wire [2:0]\t\tcpu_dbg_cc;",
            "wire cpu_reset, cpu_halt,\n\t\t\t\tcpu_has_halted;",
            "wire cpu_dbg_stall;",
            "wire [DBG_WIDTH-1:0]\tcpu_status;",
            "wire cpu_gie;",
            "wire wdt_stall, wdt_ack, wdt_reset;",
            "wire [DBG_WIDTH-1:0]\twdt_data;",
            "reg wdbus_ack;",
            "reg [PAW-1:0] \tr_wdbus_data;\n`ifndef\tVBENCH_TB",
            "wire [DBG_WIDTH-1:0]\tpic_data;",
            "wire [DBG_WIDTH-1:0]\twdbus_data;\n`endif",
            "wire reset_wdbus_timer, wdbus_int;",
            "wire cpu_op_stall, cpu_pf_stall, cpu_i_count;",
            "wire dmac_stb, dc_err;",
            "wire [DBG_WIDTH-1:0]\tdmac_data;",
            "wire dmac_stall, dmac_ack;",
            "wire dc_cyc, dc_stb, dc_we, dc_stall, dc_ack;",
            "wire [PAW-1:0]\tdc_addr;",
            "wire [BUS_WIDTH-1:0]\tdc_data;",
            "wire [BUS_WIDTH/8-1:0]\tdc_sel;",
            "wire cpu_gbl_cyc;",
            "wire [31:0]\t\tdmac_int_vec;",
            "wire ctri_sel, ctri_stall, ctri_ack;",
            "wire [DBG_WIDTH-1:0]\tctri_data;",
            "wire tma_stall, tma_ack;",
            "wire tmb_stall, tmb_ack;",
            "wire tmc_stall, tmc_ack;",
            "wire jif_stall, jif_ack;",
            "wire [DBG_WIDTH-1:0]\ttma_data;",
            "wire [DBG_WIDTH-1:0]\ttmb_data;",
            "wire [DBG_WIDTH-1:0]\ttmc_data;",
            "wire [DBG_WIDTH-1:0]\tjif_data;",
            "wire pic_stall, pic_ack;",
            "wire cpu_gbl_stb, cpu_lcl_cyc, cpu_lcl_stb,\n\t\t\tcpu_we;",
            "wire [BUS_WIDTH-1:0]\t\tcpu_data;",
            "wire [BUS_WIDTH/8-1:0]\tcpu_sel, mmu_sel;\n`ifndef\tVBENCH_TB",
            "wire [BUS_WIDTH-1:0]\t\tcpu_idata;",
            "wire cpu_stall;\n`endif",
            "wire pic_interrupt;",
            "wire cpu_ack, cpu_err;",
            "wire [DBG_WIDTH-1:0]\tcpu_dbg_data;",
            "wire ext_stall, ext_ack;",
            "wire mmu_cyc, mmu_stb, mmu_we, mmu_stall, mmu_ack,\n\t\t\t\tmmu_err, mmus_stall, mmus_ack;",
            "wire [PAW-1:0]\tmmu_addr;",
            "wire [BUS_WIDTH-1:0]\tmmu_data, mmu_idata;",
            "wire [DBG_WIDTH-1:0]\tmmus_data;",
            "wire cpu_miss;",
            "wire mmu_cpu_stall, mmu_cpu_ack;",
            "wire [BUS_WIDTH-1:0]\tmmu_cpu_idata;\n\n\t// The",
            "wire s associated with cache snooping",
            "wire pf_return_stb, pf_return_we, pf_return_cachable;",
            "wire [19:0]\t\tpf_return_v, pf_return_p;",
            "wire ext_cyc, ext_stb, ext_we, ext_err;",
            "wire [PAW-1:0]\t\text_addr;",
            "wire [BUS_WIDTH-1:0]\t\text_odata;",
            "wire [BUS_WIDTH/8-1:0]\text_sel;",
            "wire [BUS_WIDTH-1:0]\t\text_idata;",
            "reg [DBG_WIDTH-1:0]\t\ttmr_data;",
            "reg [2:0]\t\t\tw_ack_idx, ack_idx;",
            "reg last_sys_stb;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Handle our interrupt vector generation/coordination\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Main interrupt vector\n\t// {{{\n\tassign\tmain_int_vector[5:0] = { ctri_int, tma_int, tmb_int, tmc_int,\n\t\t\t\t\tjif_int, dmac_int };\n\tgenerate if (EXTERNAL_INTERRUPTS < 9)\n\tbegin : TRIM_MAIN_INTS\n\t\tassign\tmain_int_vector[14:6] = { {(9-EXTERNAL_INTERRUPTS){1'b0}},\n\t\t\t\t\ti_ext_int };\n\tend else begin : NO_TRIM_MAIN_INTS\n\t\tassign\tmain_int_vector[14:6] = i_ext_int[8:0];\n\tend endgenerate\n\t// }}}\n\n\t// The alternate interrupt vector\n\t// {{{\n\tgenerate if (EXTERNAL_INTERRUPTS <= 9 && OPT_ACCOUNTING)\n\tbegin : ALT_ACCOUNTING_INTS\n\t\tassign\talt_int_vector = { 7'h00,\n\t\t\t\t\tmtc_int, moc_int, mpc_int, mic_int,\n\t\t\t\t\tutc_int, uoc_int, upc_int, uic_int };\n\tend else if (EXTERNAL_INTERRUPTS <= 9) // && !OPT_ACCOUNTING\n\tbegin : ALT_NO_INTS\n\t\tassign\talt_int_vector = { 15'h00 };\n\tend else if (OPT_ACCOUNTING && EXTERNAL_INTERRUPTS >= 15)\n\tbegin : ALT_ACCT_PLUS_INTS\n\t\tassign\talt_int_vector = { i_ext_int[14:8],\n\t\t\t\t\tmtc_int, moc_int, mpc_int, mic_int,\n\t\t\t\t\tutc_int, uoc_int, upc_int, uic_int };\n\tend else if (OPT_ACCOUNTING)\n\tbegin : ALT_ACCT_SOME_INTS\n\n\t\tassign\talt_int_vector = { {(7-(EXTERNAL_INTERRUPTS-9)){1'b0}},\n\t\t\t\t\ti_ext_int[(EXTERNAL_INTERRUPTS-1):9],\n\t\t\t\t\tmtc_int, moc_int, mpc_int, mic_int,\n\t\t\t\t\tutc_int, uoc_int, upc_int, uic_int };\n\tend else if (!OPT_ACCOUNTING && EXTERNAL_INTERRUPTS >= 24)\n\tbegin : ALT_NO_ACCOUNTING_INTS\n\n\t\tassign\talt_int_vector = { i_ext_int[(EXTERNAL_INTERRUPTS-1):9] };\n\tend else begin : ALT_TRIM_INTS\n\t\tassign\talt_int_vector = { {(15-(EXTERNAL_INTERRUPTS-9)){1'b0}},\n\t\t\t\t\ti_ext_int[(EXTERNAL_INTERRUPTS-1):9] };\n\n\tend endgenerate\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\tgenerate if (!OPT_ACCOUNTING)\n\tbegin : UNUSED_ACCOUNTING\n\t\t// Verilator lint_off UNUSED",
            "wire unused_ctrs;\n\t\tassign\tunused_ctrs = &{ 1'b0,\n\t\t\tmoc_int, mpc_int, mic_int, mtc_int,\n\t\t\tuoc_int, upc_int, uic_int, utc_int,\n\t\t\tcpu_gie, cpu_op_stall, cpu_pf_stall, cpu_i_count };\n\t\t// Verilator lint_on  UNUSED\n\tend endgenerate\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Delay the debug port by one clock, to meet timing requirements\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\tgenerate if (DELAY_DBG_BUS)\n\tbegin : DELAY_THE_DEBUG_BUS\n\t\t// {{{",
            "wire dbg_err;\n\t\tassign\t\tdbg_err = 1'b0;\n\t\tbusdelay #(\n\t\t\t// {{{\n\t\t\t.AW(7),.DW(32)\n\t\t\t// }}}\n\t\t) wbdelay(\n\t\t\t// {{{\n\t\t\ti_clk, i_reset,\n\t\t\ti_dbg_cyc, i_dbg_stb, i_dbg_we, i_dbg_addr, i_dbg_data,\n\t\t\t\t4'hf,\n\t\t\t\to_dbg_stall, o_dbg_ack, o_dbg_data, no_dbg_err,\n\t\t\tdbg_cyc, dbg_stb, dbg_we, dbg_addr, dbg_idata, dbg_sel,\n\t\t\t\tdbg_stall, dbg_ack, dbg_odata, dbg_err\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\tend else begin : NO_DEBUG_BUS_DELAY\n\t\t// {{{\n\t\tassign\tdbg_cyc     = i_dbg_cyc;\n\t\tassign\tdbg_stb     = i_dbg_stb;\n\t\tassign\tdbg_we      = i_dbg_we;\n\t\tassign\tdbg_addr    = i_dbg_addr;\n\t\tassign\tdbg_idata   = i_dbg_data;\n\t\tassign\to_dbg_ack   = dbg_ack;\n\t\tassign\to_dbg_stall = dbg_stall;\n\t\tassign\to_dbg_data  = dbg_odata;\n\t\tassign\tdbg_sel     = 4'b1111;\n\t\tassign\tno_dbg_err  = 1'b0;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus decoding, sel_*\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tassign\tsel_pic         = (sys_stb)&&(sys_addr == INTCTRL);\n\tassign\tsel_watchdog    = (sys_stb)&&(sys_addr == WATCHDOG);\n\tassign\tsel_bus_watchdog= (sys_stb)&&(sys_addr == BUSWATCHDOG);\n\tassign\tsel_apic        = (sys_stb)&&(sys_addr == CTRINT);\n\tassign\tsel_timer       = (sys_stb)&&(sys_addr[7:2]==TIMER_A[7:2]);\n\tassign\tsel_counter     = (sys_stb)&&(sys_addr[7:3]==MSTR_TASK_CTR[7:3]);\n\tassign\tsel_dmac        = (sys_stb)&&(sys_addr[7:4] ==DMAC_ADDR[7:4]);\n\tassign\tsel_mmus        = (sys_stb)&&(sys_addr[7]);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The external debug interface\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tassign\tdbg_cpu_write = OPT_DBGPORT && (dbg_stb && !dbg_stall && dbg_we)\n\t\t\t\t&& (dbg_addr[6:5] == DBG_ADDR_CPU)\n\t\t\t\t&& dbg_sel == 4'hf;\n\tassign\tdbg_cpu_read = (dbg_stb && !dbg_stall && !dbg_we\n\t\t\t\t&& dbg_addr[6:5] == DBG_ADDR_CPU);\n\tassign\tdbg_cmd_write = (dbg_stb)&&(dbg_we)\n\t\t\t\t\t&&(dbg_addr[6:5] == DBG_ADDR_CTRL);\n\tassign\tdbg_cmd_data = dbg_idata;\n\tassign\tdbg_cmd_strb = dbg_sel;\n\n\n\tassign\treset_request = dbg_cmd_write && dbg_cmd_strb[RESET_BIT/8]\n\t\t\t\t\t\t&& dbg_cmd_data[RESET_BIT];\n\tassign\trelease_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8]\n\t\t\t\t\t\t&& !dbg_cmd_data[HALT_BIT];\n\tassign\thalt_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8]\n\t\t\t\t\t\t&& dbg_cmd_data[HALT_BIT];\n\tassign\tstep_request = dbg_cmd_write && dbg_cmd_strb[STEP_BIT/8]\n\t\t\t\t\t\t&& dbg_cmd_data[STEP_BIT];\n\tassign\tclear_cache_request = dbg_cmd_write\n\t\t\t\t\t&& dbg_cmd_strb[CLEAR_CACHE_BIT/8]\n\t\t\t\t\t&& dbg_cmd_data[CLEAR_CACHE_BIT];\n\n\t//\n\t// reset_hold: Always start us off with an initial reset\n\t// {{{\n\tgenerate if (RESET_DURATION > 0)\n\tbegin : INITIAL_RESET_HOLD\n\t\t// {{{",
            "reg [$clog2(RESET_DURATION)-1:0]\treset_counter;",
            "reg r_reset_hold;\n\n\t\tinitial\treset_counter = RESET_DURATION;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\treset_counter <= RESET_DURATION;\n\t\telse if (reset_counter > 0)\n\t\t\treset_counter <= reset_counter - 1;\n\n\t\tinitial\tr_reset_hold = 1;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_reset_hold <= 1;\n\t\telse\n\t\t\tr_reset_hold <= (reset_counter > 1);\n\n\t\tassign\treset_hold = r_reset_hold;\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\t\tassert(reset_hold == (reset_counter != 0));\n`endif\n\t\t// }}}\n\tend else begin : NO_RESET_HOLD\n\n\t\tassign reset_hold = 0;\n\n\tend endgenerate\n\t// }}}\n\n\tassign\thalt_on_fault = dbg_catch;\n\n\t// cmd_reset\n\t// {{{\n\t// Always start us off with an initial reset\n\tinitial\tcmd_reset = 1'b1;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tcmd_reset <= 1'b1;\n\telse if (reset_hold || wdt_reset)\n\t\tcmd_reset <= 1'b1;\n\telse if (cpu_break && !halt_on_fault)\n\t\tcmd_reset <= 1'b1;\n\telse\n\t\tcmd_reset <= reset_request;\n\t// }}}\n\n\t// cmd_halt\n\t// {{{\n\tinitial\tcmd_halt  = START_HALTED;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tcmd_halt <= START_HALTED;\n\telse if (cmd_reset && START_HALTED)\n\t\tcmd_halt <= START_HALTED;\n\telse begin\n\t\t// {{{\n\t\t// When shall we release from a halt?  Only if we have\n\t\t// come to a full and complete stop.  Even then, we only\n\t\t// release if we aren't being given a command to step the CPU.\n\t\t//\n\t\tif (!cmd_write && cpu_has_halted && dbg_cmd_write\n\t\t\t\t&& (release_request || step_request))\n\t\t\tcmd_halt <= 1'b0;\n\n\t\t// Reasons to halt\n\n\t\t// 1. Halt on any unhandled CPU exception.  The cause of the\n\t\t//\texception must be cured before we can (re)start.\n\t\t//\tIf the CPU is configured to start immediately on power\n\t\t//\tup, we leave it to reset on any exception instead.\n\t\tif (cpu_break && halt_on_fault)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 2. Halt on any user request to halt.  (Only valid if the\n\t\t//\tSTEP bit isn't also set)\n\t\tif (dbg_cmd_write && halt_request && !step_request)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 3. Halt on any user request to write to a CPU",
            "reg ister\n\t\tif (dbg_cpu_write)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 4. Halt following any step command\n\t\tif (cmd_step && !step_request)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 5. Halt following any clear cache\n\t\tif (cmd_clear_cache)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 6. Halt on any clear cache bit--independent of any step bit\n\t\tif (clear_cache_request)\n\t\t\tcmd_halt <= 1'b1;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// cmd_clear_cache\n\t// {{{\n\tinitial\tcmd_clear_cache = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || cpu_reset)\n\t\tcmd_clear_cache <= 1'b0;\n\telse if (dbg_cmd_write && clear_cache_request && halt_request)\n\t\tcmd_clear_cache <= 1'b1;\n\telse if (cmd_halt && !cpu_dbg_stall)\n\t\tcmd_clear_cache <= 1'b0;\n\t// }}}\n\n\t// cmd_step\n\t// {{{\n\tinitial\tcmd_step = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tcmd_step <= 1'b0;\n\telse if (cmd_reset || cpu_break\n\t\t\t|| reset_request\n\t\t\t|| clear_cache_request || cmd_clear_cache\n\t\t\t|| halt_request || dbg_cpu_write)\n\t\tcmd_step <= 1'b0;\n\telse if (!cmd_write && cpu_has_halted && step_request)\n\t\tcmd_step <= 1'b1;\n\telse // if (cpu_dbg_stall)\n\t\tcmd_step <= 1'b0;\n`ifdef\tFORMAL\n\t// While STEP is true, we can't halt\n\talways @(*)\n\tif (!i_reset && cmd_step)\n\t\tassert(!cmd_halt);\n`endif\n\t// }}}\n\n\t// dbg_catch\n\t// {{{\n\tgenerate if (!OPT_DBGPORT)\n\tbegin : NO_DBG_CATCH\n\t\tassign\tdbg_catch = START_HALTED;\n\tend else begin : GEN_DBG_CATCH",
            "reg r_dbg_catch;\n\n\t\tinitial\tr_dbg_catch = START_HALTED;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_dbg_catch <= START_HALTED;\n\t\telse if (dbg_cmd_write && dbg_cmd_strb[CATCH_BIT/8])\n\t\t\tr_dbg_catch <= dbg_cmd_data[CATCH_BIT];\n\n\t\tassign\tdbg_catch = r_dbg_catch;\n\tend endgenerate\n\t// }}}\n\n\tassign\tcpu_reset = (cmd_reset);\n\tassign\tcpu_halt = (cmd_halt);\n\n\t// cpu_status\n\t// {{{\n\t// Values:\n\t//\t0xxxxx_0000 -> External interrupt lines\n\t//\n\t//\t0xffff_f000 -> (Unused / reserved)\n\t//\n\t//\t0x0000_0800 -> cpu_break\n\t//\t0x0000_0400 -> Interrupt pending\n\t//\t0x0000_0200 -> User mode\n\t//\t0x0000_0100 -> Sleep (CPU is sleeping)\n\t//\n\t//\t0x0000_00c0 -> (Unused/reserved)\n\t//\t0x0000_0020 -> dbg_catch\n\t//\t0x0000_0010 -> cmd_clear_cache\n\t//\n\t//\t0x0000_0008 -> Reset\n\t//\t0x0000_0004 -> Step (auto clearing, write only)\n\t//\t0x0000_0002 -> Halt (status)\n\t//\t0x0000_0001 -> Halt (request)\n\tgenerate\n\tif (EXTERNAL_INTERRUPTS < 20)\n\tbegin : CPU_STATUS_NO_EXTRA_INTERRUPTS\n\t\tassign\tcpu_status = { {(20-EXTERNAL_INTERRUPTS){1'b0}},\n\t\t\ti_ext_int,\n\t\t\tcpu_break, pic_interrupt, cpu_dbg_cc[1:0],\n\t\t\t2'h0, dbg_catch, 1'b0,\n\t\t\tcmd_reset, 1'b0, !cpu_dbg_stall, cmd_halt\n\t\t};\n\tend else begin : CPU_STATUS_MAX_INTERRUPTS\n\t\tassign\tcpu_status = { i_ext_int[19:0],\n\t\t\tcpu_break, pic_interrupt, cpu_dbg_cc[1:0],\n\t\t\t2'h0, dbg_catch, 1'b0,\n\t\t\tcmd_reset, 1'b0, !cpu_dbg_stall, cmd_halt\n\t\t};\n\tend endgenerate\n\n\t// }}}\n\n\tassign\tcpu_gie = cpu_dbg_cc[1];\n\n\t// cmd_write\n\t// {{{\n\tinitial\tcmd_write = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || cpu_reset)\n\t\tcmd_write <= 1'b0;\n\telse if (!cmd_write || cpu_has_halted)\n\t\tcmd_write <= dbg_cpu_write;\n\t// }}}\n\n\t// cmd_read\n\t// {{{",
            "reg cmd_read_ack;\n\n\tinitial\tcmd_read = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || !dbg_cyc || !OPT_DBGPORT)\n\t\tcmd_read <= 1'b0;\n\telse if (dbg_cpu_read)\n\t\tcmd_read <= 1'b1;\n\telse if (cmd_read) // cmd_read_ack == 1)\n\t\tcmd_read <= 1'b0;\n\n\tgenerate if (OPT_DISTRIBUTED_REGS)\n\tbegin : GEN_CMD_READ_ACK\n\n\t\tinitial\tcmd_read_ack = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !dbg_cyc || !OPT_DBGPORT)\n\t\t\tcmd_read_ack <= 0;\n\t\telse if (dbg_cpu_read)\n\t\t\tcmd_read_ack <= 1;\n\t\telse if (cmd_read_ack != 0)\n\t\t\tcmd_read_ack <= 0;\n\n\tend else begin : GEN_FWD_CMDREAD_ACK\n\t\talways @(*)\n\t\t\tcmd_read_ack = cmd_read;\n\n\tend endgenerate\n\t// }}}\n\n\t// cmd_waddr, cmd_wdata\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((!cmd_write || cpu_has_halted) && dbg_cpu_write)\n\tbegin\n\t\tcmd_waddr <= dbg_addr[4:0];\n\t\tcmd_wdata <= dbg_idata;\n\tend\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The WATCHDOG Timer\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tziptimer #(\n\t\t.BW(32),.VW(31),.RELOADABLE(0)\n\t) u_watchdog (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(cpu_reset),\n\t\t.i_ce(!cmd_halt),\n\t\t\t.i_wb_cyc(sys_cyc),\n\t\t\t.i_wb_stb((sys_stb)&&(sel_watchdog)),\n\t\t\t.i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf),\n\t\t\t.o_wb_stall(wdt_stall),\n\t\t\t.o_wb_ack(wdt_ack),\n\t\t\t.o_wb_data(wdt_data),\n\t\t\t.o_int(wdt_reset)\n\t\t// }}}\n\t);\n\n\t//\n\t// Position two, a second watchdog timer--this time for the wishbone\n\t// bus, in order to tell/find wishbone bus lockups.  In its current\n\t// configuration, it cannot be configured and all bus accesses must\n\t// take less than the number written to this",
            "reg ister.\n\t//\n\tassign\treset_wdbus_timer = (!o_wb_cyc)||(o_wb_stb)||(i_wb_ack);\n\n\twbwatchdog #(14)\n\tu_watchbus(\n\t\t// {{{\n\t\ti_clk,(cpu_reset)||(reset_wdbus_timer),\n\t\t\t14'h2000, wdbus_int\n\t\t// }}}\n\t);\n\n\tinitial\tr_wdbus_data = 0;\n\talways @(posedge i_clk)\n\tif ((wdbus_int)||(cpu_err))\n\t\tr_wdbus_data <= o_wb_addr;\n\n\tassign\twdbus_data = { {(32-PAW){1'b0}}, r_wdbus_data };\n\tinitial\twdbus_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || !sys_cyc)\n\t\twdbus_ack <= 1'b0;\n\telse\n\t\twdbus_ack <= (sys_stb)&&(sel_bus_watchdog);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Performance counters\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Here's the stuff we'll be counting ....\n\t//\n\tgenerate if (OPT_ACCOUNTING)\n\tbegin : ACCOUNTING_COUNTERS\n\t\t// {{{\n\t\t// Local definitions\n\t\t// {{{\n\t\t// Verilator lint_off UNUSED",
            "wire mtc_stall, mtc_ack;",
            "wire moc_stall, moc_ack;",
            "wire mpc_stall, mpc_ack;",
            "wire mic_stall, mic_ack;",
            "wire utc_stall, utc_ack;",
            "wire uoc_stall, uoc_ack;",
            "wire upc_stall, upc_ack;",
            "wire uic_stall, uic_ack;\n\t\t// Verilator lint_on  UNUSED\n`ifndef\tVBENCH_TB",
            "wire [DBG_WIDTH-1:0]\tmtc_data;",
            "wire [DBG_WIDTH-1:0]\tmoc_data;",
            "wire [DBG_WIDTH-1:0]\tmpc_data;",
            "wire [DBG_WIDTH-1:0]\tmic_data;",
            "wire [DBG_WIDTH-1:0]\tutc_data;",
            "wire [DBG_WIDTH-1:0]\tuoc_data;",
            "wire [DBG_WIDTH-1:0]\tupc_data;",
            "wire [DBG_WIDTH-1:0]\tuic_data;\n`endif",
            "reg [DBG_WIDTH-1:0]\tr_actr_data;\n\t\t// }}}\n\n\t\t// Master counters\n\t\t// {{{\n\t\t// The master counters will, in general, not be reset.  They'll\n\t\t// be used for an overall counter.\n\t\t//\n\t\t// Master task counter\n\t\tzipcounter\n\t\tmtask_ctr(\n\t\t\t// {{{\n\t\t\ti_clk, 1'b0, (!cmd_halt), sys_cyc,\n\t\t\t(sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b000),\n\t\t\t\tsys_we, sys_data,\n\t\t\tmtc_stall, mtc_ack, mtc_data, mtc_int\n\t\t\t// }}}\n\t\t);\n\n\t\t// Master Operand Stall counter\n\t\tzipcounter\n\t\tmmstall_ctr(\n\t\t\t// {{{\n\t\t\ti_clk,1'b0, (cpu_op_stall), sys_cyc,\n\t\t\t(sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b001),\n\t\t\t\tsys_we, sys_data,\n\t\t\tmoc_stall, moc_ack, moc_data, moc_int\n\t\t\t// }}}\n\t\t);\n\n\t\t// Master PreFetch-Stall counter\n\t\tzipcounter\n\t\tmpstall_ctr(\n\t\t\t// {{{\n\t\t\ti_clk,1'b0, (cpu_pf_stall), sys_cyc,\n\t\t\t(sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b010),\n\t\t\t\t\tsys_we, sys_data,\n\t\t\tmpc_stall, mpc_ack, mpc_data, mpc_int\n\t\t\t// }}}\n\t\t);\n\n\t\t// Master Instruction counter\n\t\tzipcounter\n\t\tmins_ctr(\n\t\t\t// {{{\n\t\t\ti_clk,1'b0, (cpu_i_count), sys_cyc,\n\t\t\t(sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b011),\n\t\t\t\tsys_we, sys_data,\n\t\t\tmic_stall, mic_ack, mic_data, mic_int\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\t\t// User counters\n\t\t// {{{\n\t\t// The user counters are different from those of the master.\n\t\t// They will be reset any time a task is given control of the\n\t\t// CPU.\n\t\t//\n\t\t// User task counter\n\t\tzipcounter\n\t\tutask_ctr(\n\t\t\t// {{{\n\t\t\ti_clk,1'b0, (!cmd_halt)&&(cpu_gie), sys_cyc,\n\t\t\t(sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b100),\n\t\t\t\tsys_we, sys_data,\n\t\t\tutc_stall, utc_ack, utc_data, utc_int\n\t\t\t// }}}\n\t\t);\n\n\t\t// User Op-Stall counter\n\t\tzipcounter\n\t\tumstall_ctr(\n\t\t\t// {{{\n\t\t\ti_clk,1'b0, (cpu_op_stall)&&(cpu_gie), sys_cyc,\n\t\t\t\t(sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b101),\n\t\t\t\t\tsys_we, sys_data,\n\t\t\t\tuoc_stall, uoc_ack, uoc_data, uoc_int\n\t\t\t// }}}\n\t\t);\n\n\t\t// User PreFetch-Stall counter\n\t\tzipcounter\n\t\tupstall_ctr(\n\t\t\t// {{{\n\t\t\ti_clk,1'b0, (cpu_pf_stall)&&(cpu_gie), sys_cyc,\n\t\t\t\t(sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b110),\n\t\t\t\t\tsys_we, sys_data,\n\t\t\t\tupc_stall, upc_ack, upc_data, upc_int\n\t\t\t// }}}\n\t\t);\n\n\t\t// User instruction counter\n\t\tzipcounter\n\t\tuins_ctr(\n\t\t\t// {{{\n\t\t\ti_clk,1'b0, (cpu_i_count)&&(cpu_gie), sys_cyc,\n\t\t\t\t(sys_stb)&&(sel_counter)&&(sys_addr[2:0] == 3'b111),\n\t\t\t\t\tsys_we, sys_data,\n\t\t\t\tuic_stall, uic_ack, uic_data, uic_int\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// A little bit of pre-cleanup (actr = accounting counters)\n\t\tassign\tactr_ack = sel_counter;\n\t\tassign\tactr_stall = 1'b0;\n\n\t\t// actr_data\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tcase(sys_addr[2:0])\n\t\t\t3'h0: r_actr_data = mtc_data;\n\t\t\t3'h1: r_actr_data = moc_data;\n\t\t\t3'h2: r_actr_data = mpc_data;\n\t\t\t3'h3: r_actr_data = mic_data;\n\t\t\t3'h4: r_actr_data = utc_data;\n\t\t\t3'h5: r_actr_data = uoc_data;\n\t\t\t3'h6: r_actr_data = upc_data;\n\t\t\t3'h7: r_actr_data = uic_data;\n\t\t\tendcase\n\t\tend\n\n\t\tassign\tactr_data = r_actr_data;\n\t\t// }}}\n\t\t// }}}\n\tend else begin : NO_ACCOUNTING_COUNTERS\n\t\t// {{{\n\n\t\tassign\tactr_stall = 1'b0;\n\t\tassign\tactr_data = 32'h0000;\n\n\t\tassign\tmtc_int = 1'b0;\n\t\tassign\tmoc_int = 1'b0;\n\t\tassign\tmpc_int = 1'b0;\n\t\tassign\tmic_int = 1'b0;\n\t\tassign\tutc_int = 1'b0;\n\t\tassign\tuoc_int = 1'b0;\n\t\tassign\tupc_int = 1'b0;\n\t\tassign\tuic_int = 1'b0;\n\n\t\tassign\tactr_ack = sel_counter;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The DMA Controller\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tassign\tdmac_int_vec = { 1'b0, alt_int_vector, 1'b0,\n\t\t\t\t\tmain_int_vector[14:1], 1'b0 };\n\tassign\tdmac_stb = (sys_stb)&&(sel_dmac);\n\n\tgenerate if (OPT_DMA)\n\tbegin : DMA\n\t\t// {{{\n\t\tzipdma\t#(\n\t\t\t// {{{\n\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH), .LGMEMLEN(DMA_LGMEM),\n\t\t\t.OPT_REGISTER_RAM(!OPT_DISTRIBUTED_REGS),\n\t\t\t.BUS_WIDTH(DW), .OPT_LITTLE_ENDIAN(1'b0)\n\t\t\t// }}}\n\t\t) dma_controller(\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(cpu_reset),\n\t\t\t.i_swb_cyc(sys_cyc), .i_swb_stb(dmac_stb),\n\t\t\t\t.i_swb_we(sys_we), .i_swb_addr(sys_addr[1:0]),\n\t\t\t\t.i_swb_data(sys_data), .i_swb_sel(4'hf),\n\t\t\t.o_swb_stall(dmac_stall), .o_swb_ack(dmac_ack),\n\t\t\t\t.o_swb_data(dmac_data),\n\t\t\t// Need the outgoing DMAC wishbone bus\n\t\t\t.o_mwb_cyc(dc_cyc), .o_mwb_stb(dc_stb),\n\t\t\t\t.o_mwb_we(dc_we), .o_mwb_addr(dc_addr),\n\t\t\t\t.o_mwb_data(dc_data), .o_mwb_sel(dc_sel),\n\t\t\t.i_mwb_stall(dc_stall),\n\t\t\t\t.i_mwb_ack(dc_ack), .i_mwb_data(ext_idata),\n\t\t\t\t.i_mwb_err(dc_err),\n\t\t\t// External device interrupts\n\t\t\t.i_dev_ints(dmac_int_vec),\n\t\t\t// DMAC interrupt, for upon completion\n\t\t\t.o_interrupt(dmac_int)\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\tend else begin : NO_DMA\n\t\t// {{{",
            "reg r_dmac_ack;\n\n\t\tinitial\tr_dmac_ack = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_dmac_ack <= 1'b0;\n\t\telse\n\t\t\tr_dmac_ack <= (sys_cyc)&&(dmac_stb);\n\t\tassign\tdmac_ack = r_dmac_ack;\n\t\tassign\tdmac_data = 32'h000;\n\t\tassign\tdmac_stall = 1'b0;\n\n\t\tassign\tdc_cyc  = 1'b0;\n\t\tassign\tdc_stb  = 1'b0;\n\t\tassign\tdc_we   = 1'b0;\n\t\tassign\tdc_addr = { (PAW) {1'b0} };\n\t\tassign\tdc_data = 32'h00;\n\t\tassign\tdc_sel  = 4'h0;\n\n\t\tassign\tdmac_int = 1'b0;\n\n\t\t// Make Verilator happy\n\t\t// {{{\n\t\t// Verilator lint_off UNUSED",
            "wire unused_dmac;\n\t\tassign\tunused_dmac = &{ 1'b0, dc_err, dc_ack,\n\t\t\t\t\tdc_stall, dmac_int_vec };\n\t\t// Verilator lint_on UNUSED\n\t\t// }}}\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The alternate interrupt controller\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tassign\tctri_sel = (sys_stb)&&(sel_apic);\n\tgenerate if (OPT_ACCOUNTING)\n\tbegin : PIC_WITH_ACCOUNTING\n\t\t//\n\t\t// Interrupt controller\n\t\t//\n\t\tif (EXTERNAL_INTERRUPTS <= 9)\n\t\tbegin : ALT_PIC\n\t\t\ticontrol #(8)\n\t\t\tctri(\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(cpu_reset),\n\t\t\t.i_wb_cyc(sys_cyc), .i_wb_stb(ctri_sel),\n\t\t\t.i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf),\n\t\t\t.o_wb_stall(ctri_stall), .o_wb_ack(ctri_ack),\n\t\t\t.o_wb_data(ctri_data),\n\t\t\t.i_brd_ints(alt_int_vector[7:0]), .o_interrupt(ctri_int)\n\t\t\t// }}}\n\t\t\t);\n`ifdef\tVBENCH_TB\n\t\t\tassign\talt_int_state = { 8'h0, ctri.r_int_state };\n`endif\n\t\tend else begin : ALT_PIC\n\t\t\ticontrol #(8+(EXTERNAL_INTERRUPTS-9))\n\t\t\tctri(\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(cpu_reset),\n\t\t\t.i_wb_cyc(sys_cyc), .i_wb_stb(ctri_sel),\n\t\t\t\t.i_wb_we(sys_we), .i_wb_data(sys_data),\n\t\t\t\t.i_wb_sel(4'hf),\n\t\t\t\t.o_wb_stall(ctri_stall),\n\t\t\t\t.o_wb_ack(ctri_ack),\n\t\t\t\t.o_wb_data(ctri_data),\n\t\t\t\t.i_brd_ints(alt_int_vector[(EXTERNAL_INTERRUPTS-2):0]),\n\t\t\t\t.o_interrupt(ctri_int)\n\t\t\t// }}}\n\t\t\t);\n`ifdef\tVBENCH_TB\n\t\t\tassign\talt_int_state = {\n\t\t\t\t\t{(17-EXTERNAL_INTERRUPTS){1'b0}},\n\t\t\t\t\t\tctri.r_int_state };\n`endif\n\t\tend\n\tend else begin : PIC_WITHOUT_ACCOUNTING\n\n\t\tif (EXTERNAL_INTERRUPTS <= 9)\n\t\tbegin : ALT_PIC\n\t\t\tassign\tctri_stall = 1'b0;\n\t\t\tassign\tctri_data  = 32'h0000;\n\t\t\tassign\tctri_int   = 1'b0;\n`ifdef\tVBENCH_TB\n\t\t\tassign\talt_int_state = 16'h0;\n`endif\n\t\tend else begin : ALT_PIC\n\t\t\ticontrol #(EXTERNAL_INTERRUPTS-9)\n\t\t\tctri(\n\t\t\t\t// {{{\n\t\t\t\t.i_clk(i_clk), .i_reset(cpu_reset),\n\t\t\t\t.i_wb_cyc(sys_cyc), .i_wb_stb(ctri_sel),\n\t\t\t\t\t.i_wb_we(sys_we), .i_wb_data(sys_data),\n\t\t\t\t.i_wb_sel(4'hf),\n\t\t\t\t.o_wb_stall(ctri_stall),\n\t\t\t\t.o_wb_ack(ctri_ack),\n\t\t\t\t.o_wb_data(ctri_data),\n\t\t\t\t.i_brd_ints(alt_int_vector[(EXTERNAL_INTERRUPTS-10):0]),\n\t\t\t\t.o_interrupt(ctri_int)\n\t\t\t\t// }}}\n\t\t\t);\n`ifdef\tVBENCH_TB\n\t\t\tassign\talt_int_state = {\n\t\t\t\t\t{(25-EXTERNAL_INTERRUPTS){1'b0}},\n\t\t\t\t\tctri.r_int_state };\n`endif\n\t\tend\n\n\tend endgenerate\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Timers\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// Timer A\n\t//\n\tziptimer u_timer_a(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(cpu_reset), .i_ce(!cmd_halt),\n\t\t.i_wb_cyc(sys_cyc),\n\t\t.i_wb_stb((sys_stb)&&(sel_timer)&&(sys_addr[1:0] == 2'b00)),\n\t\t.i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf),\n\t\t.o_wb_stall(tma_stall), .o_wb_ack(tma_ack),\n\t\t.o_wb_data(tma_data),\n\t\t.o_int(tma_int)\n\t\t// }}}\n\t);\n\n\t//\n\t// Timer B\n\t//\n\tziptimer u_timer_b(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(cpu_reset), .i_ce(!cmd_halt),\n\t\t.i_wb_cyc(sys_cyc),\n\t\t.i_wb_stb((sys_stb)&&(sel_timer)&&(sys_addr[1:0] == 2'b01)),\n\t\t.i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf),\n\t\t.o_wb_stall(tmb_stall), .o_wb_ack(tmb_ack),\n\t\t.o_wb_data(tmb_data),\n\t\t.o_int(tmb_int)\n\t\t// }}}\n\t);\n\n\t//\n\t// Timer C\n\t//\n\tziptimer u_timer_c(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(cpu_reset), .i_ce(!cmd_halt),\n\t\t.i_wb_cyc(sys_cyc),\n\t\t.i_wb_stb((sys_stb)&&(sel_timer)&&(sys_addr[1:0] == 2'b10)),\n\t\t.i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf),\n\t\t.o_wb_stall(tmc_stall), .o_wb_ack(tmc_ack),\n\t\t.o_wb_data(tmc_data),\n\t\t.o_int(tmc_int)\n\t\t// }}}\n\t);\n\n\t//\n\t// JIFFIES\n\t//\n\tzipjiffies u_jiffies(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(cpu_reset), .i_ce(!cmd_halt),\n\t\t.i_wb_cyc(sys_cyc),\n\t\t.i_wb_stb((sys_stb)&&(sel_timer)&&(sys_addr[1:0] == 2'b11)),\n\t\t.i_wb_we(sys_we), .i_wb_data(sys_data), .i_wb_sel(4'hf),\n\t\t.o_wb_stall(jif_stall), .o_wb_ack(jif_ack),\n\t\t.o_wb_data(jif_data),\n\t\t.o_int(jif_int)\n\t\t// }}}\n\t);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The main (programmable) interrupt controller peripheral\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (EXTERNAL_INTERRUPTS < 9)\n\tbegin : MAIN_PIC\n\t\ticontrol #(6+EXTERNAL_INTERRUPTS)\n\t\tpic(\n\t\t\t// {{{\n\t\t\ti_clk, cpu_reset,\n\t\tsys_cyc, (sys_cyc)&&(sys_stb)&&(sel_pic),sys_we,\n\t\t\tsys_data, 4'hf, pic_stall, pic_ack, pic_data,\n\t\t\tmain_int_vector[(6+EXTERNAL_INTERRUPTS-1):0],\n\t\t\tpic_interrupt\n\t\t\t// }}}\n\t\t);\n\n`ifdef\tVBENCH_TB\n\t\tassign\tint_state = { {(10-EXTERNAL_INTERRUPTS){1'b0}},\n\t\t\t\t\t\tpic.r_int_state };\n`endif\n\tend else begin : MAIN_PIC\n\t\ticontrol #(15)\n\t\tpic(\n\t\t\t// {{{\n\t\t\ti_clk, cpu_reset,\n\t\t\tsys_cyc, (sys_cyc)&&(sys_stb)&&(sel_pic),sys_we,\n\t\t\tsys_data, 4'hf, pic_stall, pic_ack, pic_data,\n\t\t\tmain_int_vector[14:0], pic_interrupt\n\t\t\t// }}}\n\t\t);\n\n`ifdef\tVBENCH_TB\n\t\tassign\tint_state = { 1'b0, pic.r_int_state };\n`endif\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The CPU itself\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tassign\tcpu_clken = cmd_write || cmd_read || (dbg_stb && dbg_addr[6] == DBG_ADDR_CPU[1]);\n`ifdef\tFORMAL\n\t// {{{\n\t(* anyseq *)",
            "reg f_cpu_halted, f_cpu_data, f_cpu_stall,\n\t\t\t\tf_cpu_break;\n\t(* anyseq *)",
            "reg [1:0]\tf_cpu_dbg_cc;\n\t(* anyseq *)",
            "reg [31:0]\tf_cpu_dbg_data;",
            "wire cpu_dbg_we;\n\n\tassign cpu_dbg_we = ((dbg_stb)&&(dbg_we)\n\t\t\t\t\t&&(dbg_addr[6:5] == DBG_ADDR_CPU));\n\n\tassign\tcpu_dbg_stall = f_cpu_stall && !f_cpu_halted;\n\tassign\tcpu_break     = f_cpu_break;\n\tassign\tcpu_dbg_cc    = f_cpu_dbg_cc;\n\tassign\tcpu_dbg_data  = f_cpu_dbg_data;\n\tassign\tcpu_has_halted= f_cpu_halted;\n\n\tfdebug #(\n\t\t// {{{\n\t\t.OPT_START_HALTED(START_HALTED),\n\t\t.OPT_DISTRIBUTED_RAM(OPT_DISTRIBUTED_REGS)\n\t\t// }}}\n\t) fdbg (\n\t\t// {{{\n\t\t.i_clk(i_clk),\n\t\t.i_reset(i_reset),\n\t\t.i_cpu_reset(cpu_reset),\n\t\t.i_halt(cpu_halt),\n\t\t.i_halted(f_cpu_halted),\n\t\t.i_clear_cache(cmd_clear_cache),\n\t\t.i_dbg_we(cmd_write),\n\t\t.i_dbg_",
            "reg (cmd_waddr),\n\t\t.i_dbg_data(cmd_wdata),\n\t\t.i_dbg_stall(cpu_dbg_stall),\n\t\t.i_dbg_break(cpu_break),\n\t\t.i_dbg_cc(cpu_dbg_cc)\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (f_cpu_halted)\n\t\tassume(!cpu_gbl_cyc && !cpu_gbl_stb);\n\t// }}}\n`else\n\tzipwb\t#(\n\t\t// {{{\n\t\t.RESET_ADDRESS(RESET_ADDRESS),\n\t\t.ADDRESS_WIDTH(VIRTUAL_ADDRESS_WIDTH),\n\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t.OPT_LGICACHE(OPT_LGICACHE),\n\t\t.OPT_LGDCACHE(OPT_LGDCACHE),\n\t\t.OPT_MPY(OPT_MPY),\n\t\t.OPT_DIV(OPT_DIV),\n\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t.IMPLEMENT_FPU(OPT_FPU),\n\t\t.OPT_CIS(OPT_CIS),\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.OPT_START_HALTED(START_HALTED),\n\t\t.OPT_SIM(OPT_SIM),\n\t\t.OPT_DBGPORT(OPT_DBGPORT),\n\t\t.OPT_TRACE_PORT(OPT_TRACE_PORT),\n\t\t.OPT_PROFILER(OPT_PROFILER),\n\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t.WITH_LOCAL_BUS(1'b1)\n\t\t// }}}\n\t) thecpu(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(cpu_reset),\n\t\t\t.i_interrupt(pic_interrupt),\n\t\t\t.i_cpu_clken(cpu_clken),\n\t\t// Debug interface\n\t\t// {{{\n\t\t.i_halt(cpu_halt), .i_clear_cache(cmd_clear_cache),\n\t\t\t\t.i_dbg_w",
            "reg (cmd_waddr), .i_dbg_we(cmd_write),\n\t\t\t\t.i_dbg_data(cmd_wdata),\n\t\t\t\t.i_dbg_r",
            "reg (dbg_addr[4:0]),\n\t\t\t.o_dbg_stall(cpu_dbg_stall),\n\t\t\t.o_halted(cpu_has_halted),\n\t\t\t.o_dbg_",
            "reg (cpu_dbg_data),\n\t\t\t.o_dbg_cc(cpu_dbg_cc),\n\t\t\t.o_break(cpu_break),\n\t\t// }}}\n\t\t// Wishbone bus interface\n\t\t// {{{\n\t\t.o_wb_gbl_cyc(cpu_gbl_cyc), .o_wb_gbl_stb(cpu_gbl_stb),\n\t\t\t\t.o_wb_lcl_cyc(cpu_lcl_cyc),\n\t\t\t\t.o_wb_lcl_stb(cpu_lcl_stb),\n\t\t\t\t.o_wb_we(cpu_we), .o_wb_addr(cpu_addr),\n\t\t\t\t.o_wb_data(cpu_data), .o_wb_sel(cpu_sel),\n\t\t\t\t// Return values from the Wishbone bus\n\t\t\t\t.i_wb_stall(cpu_stall), .i_wb_ack(cpu_ack),\n\t\t\t\t.i_wb_data(cpu_idata), .i_wb_err(cpu_err),\n\t\t// }}}\n\t\t\t.o_op_stall(cpu_op_stall), .o_pf_stall(cpu_pf_stall),\n\t\t\t\t.o_i_count(cpu_i_count),\n\t\t.o_debug(o_cpu_debug),\n\t\t//\n\t\t.o_prof_stb(o_prof_stb),\n\t\t.o_prof_addr(o_prof_addr),\n\t\t.o_prof_ticks(o_prof_ticks)\n\t\t// }}}\n\t);\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The (unused) MMU\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// The mmu_cpu_ lines are the return bus lines from the MMU.  They\n\t// are separate from the cpu_'s lines simply because either the sys_\n\t// (local) bus or the mmu_cpu_ (global) bus might return a response to\n\t// the CPU, and the responses haven't been merged back together again\n\t// yet.\n\n`ifdef\tOPT_MMU\n\t// Ok ... here's the MMU\n\tzipmmu\t#(\n\t\t// {{{\n\t\t.LGTBL(LGTLBSZ),\n\t\t.ADDRESS_WIDTH(PHYSICAL_ADDRESS_WIDTH)\n\t\t// }}}\n\t) themmu(\n\t\t// {{{\n\t\ti_clk, cpu_reset,\n\t\t// Slave interface\n\t\t(sys_stb)&&(sel_mmus),\n\t\t\tsys_we, sys_addr[7:0], sys_data,\n\t\t\tmmus_stall, mmus_ack, mmus_data,\n\t\t// CPU global bus master lines\n\t\tcpu_gbl_cyc, cpu_gbl_stb, cpu_we, cpu_addr,\n\t\t\tcpu_data, cpu_sel,\n\t\t// MMU bus master outgoing lines\n\t\tmmu_cyc, mmu_stb, mmu_we, mmu_addr, mmu_data, mmu_sel,\n\t\t\t// .... and the return from the slave(s)\n\t\t\tmmu_stall, mmu_ack, mmu_err, mmu_idata,\n\t\t// CPU gobal bus master return lines\n\t\t\tmmu_cpu_stall, mmu_cpu_ack, cpu_err, cpu_miss, mmu_cpu_idata,\n\t\t\tpf_return_stb, pf_return_we, pf_return_p, pf_return_v,\n\t\t\t\tpf_return_cachable\n\t\t// }}}\n\t);\n\n`else",
            "reg r_mmus_ack;\n\n\tassign\tmmu_cyc   = cpu_gbl_cyc;\n\tassign\tmmu_stb   = cpu_gbl_stb;\n\tassign\tmmu_we    = cpu_we;\n\tassign\tmmu_addr  = cpu_addr;\n\tassign\tmmu_data  = cpu_data;\n\tassign\tmmu_sel   = cpu_sel;\n\tassign\tcpu_miss  = 1'b0;\n\tassign\tcpu_err   = (mmu_err)&&(cpu_gbl_cyc);\n\tassign\tmmu_cpu_idata = mmu_idata;\n\tassign\tmmu_cpu_stall = mmu_stall;\n\tassign\tmmu_cpu_ack   = mmu_ack;\n\n\tinitial\tr_mmus_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_mmus_ack <= 1'b0;\n\telse\n\t\tr_mmus_ack <= (sys_stb)&&(sys_addr[7]);\n\n\tassign\tmmus_ack   = r_mmus_ack;\n\tassign\tmmus_stall = 1'b0;\n\tassign\tmmus_data  = 32'h0;\n\n\tassign\tpf_return_stb = 0;\n\tassign\tpf_return_v   = 0;\n\tassign\tpf_return_p   = 0;\n\tassign\tpf_return_we  = 0;\n\tassign\tpf_return_cachable = 0;\n`endif\n\t//\n\t// Responses from the MMU still need to be merged/muxed back together\n\t// with the responses from the local bus\n\tassign\tcpu_ack   = ((cpu_lcl_cyc)&&(sys_ack))\n\t\t\t\t||((cpu_gbl_cyc)&&(mmu_cpu_ack));\n\tassign\tcpu_stall = ((cpu_lcl_cyc)&&(sys_stall))\n\t\t\t\t||((cpu_gbl_cyc)&&(mmu_cpu_stall));\n\tassign\tcpu_idata     = (cpu_gbl_cyc)?mmu_cpu_idata\n\t\t\t\t: { {(BUS_WIDTH-DBG_WIDTH){1'b0}}, sys_idata };\n\n\t// The following lines (will be/) are used to allow the prefetch to\n\t// snoop on any external interaction.  Until this capability is\n\t// integrated into the CPU, they are unused.  Here we tell Verilator\n\t// not to be surprised that these lines are unused:\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The internal sys bus\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Now, arbitrate the bus ... first for the local peripherals\n\t// For the debugger to have access to the local system bus, the\n\t// following must be true:\n\t//\t(dbg_cyc)\tThe debugger must request the bus\n\t//\t(!cpu_lcl_cyc)\tThe CPU cannot be using it (CPU gets priority)\n\t//\t(dbg_addr)\tThe debugger must be requesting its data\n\t//",
            "reg ister, not just the control",
            "reg ister\n\t// and one of two other things.  Either\n\t//\t((cpu_halt)&&(!cpu_dbg_stall))\tthe CPU is completely halted,\n\t// or\n\t//\t(dbg_addr[6:5]==2'b01)\twe are trying to read a CPU",
            "reg ister\n\t//\t\t\twhile in motion.  Let the user beware that,\n\t//\t\t\tby not waiting for the CPU to fully halt,\n\t//\t\t\this results may not be what he expects.\n\t//\n\tassign\tsys_cyc = (cpu_lcl_cyc)||(dbg_cyc);\n\tassign\tsys_stb = (cpu_lcl_cyc)\n\t\t\t\t? (cpu_lcl_stb)\n\t\t\t\t: ((dbg_stb)&&(dbg_addr[6:5]==DBG_ADDR_SYS));\n\n\tassign\tsys_we  = (cpu_lcl_cyc) ? cpu_we : dbg_we;\n\tassign\tsys_addr= (cpu_lcl_cyc) ? cpu_addr[7:0] : { 3'h0, dbg_addr[4:0]};\n\tassign\tsys_data= (cpu_lcl_cyc) ? cpu_data[DBG_WIDTH-1:0] : dbg_idata;\n\n\t// tmr_data\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tcase(sys_addr[1:0])\n\t\t2'b00: tmr_data = tma_data;\n\t\t2'b01: tmr_data = tmb_data;\n\t\t2'b10: tmr_data = tmc_data;\n\t\t2'b11: tmr_data = jif_data;\n\t\tendcase\n\n\t\t// tmr_ack == sys_stb && sel_timer\n\tend\n\t// }}}\n\n\t// last_sys_stb\n\t// {{{\n\tinitial\tlast_sys_stb = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tlast_sys_stb <= 0;\n\telse\n\t\tlast_sys_stb <= sys_stb;\n\t// }}}\n\n\t// sys_ack, sys_idata\n\t// {{{\n\talways @(posedge i_clk)\n\tbegin\n\t\tcase(ack_idx)\n\t\t3'h0: { sys_ack, sys_idata } <= { mmus_ack, mmus_data };\n\t\t3'h1: { sys_ack, sys_idata } <= { last_sys_stb,  wdt_data  };\n\t\t3'h2: { sys_ack, sys_idata } <= { last_sys_stb,  wdbus_data };\n\t\t3'h3: { sys_ack, sys_idata } <= { last_sys_stb,  ctri_data };// A-PIC\n\t\t3'h4: { sys_ack, sys_idata } <= { last_sys_stb,  tmr_data };\n\t\t3'h5: { sys_ack, sys_idata } <= { last_sys_stb,  actr_data };//countr\n\t\t3'h6: { sys_ack, sys_idata } <= { dmac_ack, dmac_data };\n\t\t3'h7: { sys_ack, sys_idata } <= { last_sys_stb,  pic_data };\n\t\tendcase\n\n\t\tif (i_reset || !sys_cyc)\n\t\t\tsys_ack <= 1'b0;\n\tend\n\t// }}}\n\n\t// w_ack_idx\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tw_ack_idx = 0;\n\t\tif (sel_mmus)         w_ack_idx = w_ack_idx | 3'h0;\n\t\tif (sel_watchdog)     w_ack_idx = w_ack_idx | 3'h1;\n\t\tif (sel_bus_watchdog) w_ack_idx = w_ack_idx | 3'h2;\n\t\tif (sel_apic)         w_ack_idx = w_ack_idx | 3'h3;\n\t\tif (sel_timer)        w_ack_idx = w_ack_idx | 3'h4;\n\t\tif (sel_counter)      w_ack_idx = w_ack_idx | 3'h5;\n\t\tif (sel_dmac)         w_ack_idx = w_ack_idx | 3'h6;\n\t\tif (sel_pic)          w_ack_idx = w_ack_idx | 3'h7;\n\tend\n\t// }}}\n\n\t// ack_idx\n\t// {{{\n\talways @(posedge i_clk)\n\tif (sys_stb)\n\t\tack_idx <= w_ack_idx;\n\t// }}}\n\tassign\tsys_stall = 1'b0;\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Return debug response values\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg dbg_pre_ack;",
            "reg [1:0]\t\tdbg_pre_addr;",
            "reg [DBG_WIDTH-1:0]\tdbg_cpu_status;\n\n\talways @(posedge i_clk)\n\t\tdbg_pre_addr <= dbg_addr[6:5];\n\n\talways @(posedge i_clk)\n\t\tdbg_cpu_status <= cpu_status;\n\n\tinitial\tdbg_pre_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || !i_dbg_cyc)\n\t\tdbg_pre_ack <= 1'b0;\n\telse\n\t\tdbg_pre_ack <= dbg_stb && !dbg_stall && !dbg_cpu_read;\n\n\t// A return from one of three busses:\n\t//\tCMD\tgiving command instructions to the CPU (step, halt, etc)\n\t//\tCPU-DBG-DATA\tinternal",
            "reg ister responses from within the CPU\n\t//\tsys\tResponses from the front-side bus here in the ZipSystem\n\t// assign\tdbg_odata = (!dbg_addr) ? cpu_status\n\t//\t\t\t:((!cmd_addr[5])?cpu_dbg_data : sys_idata);\n\tinitial dbg_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || !dbg_cyc)\n\t\tdbg_ack <= 1'b0;\n\telse\n\t\tdbg_ack <= dbg_pre_ack || cmd_read_ack;\n\n\talways @(posedge i_clk)\n\tif (!OPT_LOWPOWER || (dbg_cyc && (dbg_pre_ack || cmd_read)))\n\tcasez(dbg_pre_addr)\n\tDBG_ADDR_CPU:\tdbg_odata <= cpu_dbg_data;\n\tDBG_ADDR_CTRL:\tdbg_odata <= dbg_cpu_status;\n\t// DBG_ADDR_SYS:\n\tdefault:\tdbg_odata <= sys_idata;\n\tendcase\n\n\tassign\tdbg_stall = cmd_read || (cmd_write && cpu_dbg_stall\n\t\t\t&& dbg_addr[6:5] == DBG_ADDR_CPU)\n\t\t\t||(dbg_addr[6]==DBG_ADDR_SYS[1] && cpu_lcl_cyc);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Arbitrate between CPU and DMA\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Now for the external wishbone bus\n\t//\tNeed to arbitrate between the flash cache and the CPU\n\t// The way this works, though, the CPU will stall once the flash\n\t// cache gets access to the bus--the CPU will be stuck until the\n\t// flash cache is finished with the bus.\n\twbpriarbiter #(\n\t\t// {{{\n\t\t.DW(BUS_WIDTH),\n\t\t.AW(PAW)\n\t\t// }}}\n\t) dmacvcpu(\n\t\t// {{{\n\t\ti_clk,\n\t\tmmu_cyc, mmu_stb, mmu_we, mmu_addr, mmu_data, mmu_sel,\n\t\t\tmmu_stall, mmu_ack, mmu_err,\n\t\tdc_cyc, dc_stb, dc_we, dc_addr, dc_data, dc_sel,\n\t\t\tdc_stall, dc_ack, dc_err,\n\t\text_cyc, ext_stb, ext_we, ext_addr, ext_odata, ext_sel,\n\t\t\text_stall, ext_ack, ext_err\n\t\t// }}}\n\t);\n\tassign\tmmu_idata = ext_idata;\n/*\n\tassign\text_cyc  = mmu_cyc;\n\tassign\text_stb  = mmu_stb;\n\tassign\text_we   = mmu_we;\n\tassign\text_odata= mmu_data;\n\tassign\text_addr = mmu_addr;\n\tassign\text_sel  = mmu_sel;\n\tassign\tmmu_ack  = ext_ack;\n\tassign\tmmu_stall= ext_stall;\n\tassign\tmmu_err  = ext_err;\n*/\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Delay access to the external bus by one clock (if necessary)\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (DELAY_EXT_BUS)\n\tbegin : DELAY_EXTERNAL_BUS\n\t\t// {{{\n\t\tbusdelay #(\n\t\t\t// {{{\n\t\t\t.AW(PAW),\n\t\t\t.DW(BUS_WIDTH),\n\t\t\t.DELAY_STALL(0)\n\t\t\t// }}}\n\t\t) extbus(\n\t\t\t// {{{\n\t\t\ti_clk, i_reset,\n\t\t\text_cyc, ext_stb, ext_we, ext_addr, ext_odata, ext_sel,\n\t\t\t\text_stall, ext_ack, ext_idata, ext_err,\n\t\t\to_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data,\n\t\t\t\to_wb_sel,\n\t\t\ti_wb_stall, i_wb_ack, i_wb_data, (i_wb_err)||(wdbus_int)\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\tend else begin : NO_EXTERNAL_BUS_DELAY\n\t\t// {{{\n\t\tassign\to_wb_cyc  = ext_cyc;\n\t\tassign\to_wb_stb  = ext_stb;\n\t\tassign\to_wb_we   = ext_we;\n\t\tassign\to_wb_addr = ext_addr;\n\t\tassign\to_wb_data = ext_odata;\n\t\tassign\to_wb_sel  = ext_sel;\n\t\tassign\text_stall = i_wb_stall;\n\t\tassign\text_ack   = i_wb_ack;\n\t\tassign\text_idata = i_wb_data;\n\t\tassign\text_err   = (i_wb_err)||(wdbus_int);\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\tassign\to_ext_int = (cmd_halt) && (!cpu_stall);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Simulation only accesses, to make the simulation display work\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n`ifdef\tVBENCH_TB\n\t// {{{\n\tassign\tearly_branch = thecpu.core.dcd_early_branch;\n\tassign\tearly_branch_pc = thecpu.core.dcd_branch_pc;\n\n\tassign\tdcdA = thecpu.core.dcd_full_A;\n\tassign\tdcdB = thecpu.core.dcd_full_B;\n\n\tassign\tnew_pc = thecpu.core.new_pc;\n\tassign\tcpu_ipc= thecpu.core.ipc;\n\tassign\tcpu_upc= thecpu.core.upc;\n\tassign\tpf_pc  = thecpu.core.pf_pc;\n\tassign\tcpu_interrupt = pic_interrupt;\n\n\tassign\tpf_cyc = thecpu.pf_cyc;\n\tassign\tpf_stb = thecpu.pf_stb;\n\tassign\tpf_we  = thecpu.pf_we;\n\tassign\tpf_addr= { thecpu.pf_addr, 2'b00 };\n\tassign\tpf_ack = thecpu.pf_ack;\n\tassign\tpf_valid = thecpu.pf_valid;\n\tassign\tpf_illegal = thecpu.pf_illegal;\n\t// assign\tcpu_idata  = thecpu.i_wb_data;\n\tassign\tpf_instruction = thecpu.pf_instruction;\n\tassign\tpf_instruction_pc = thecpu.pf_instruction_pc;\n\tgenerate if (OPT_PIPELINED)\n\tbegin : GEN_PFORMEM_OWNER_PIPE\n\t\tassign\tpformem_owner = thecpu.PRIORITY_DATA.pformem.r_a_owner;\n\tend else begin : GEN_PFORMEM_OWNER\n\t\tassign\tpformem_owner = thecpu.PRIORITY_PREFETCH.pformem.r_a_owner;\n\tend endgenerate\n\t//\n\t//\n\t// Peeking into the decode stage\n\t// {{{\n\tassign\tdcd_ce      = thecpu.core.dcd_ce;\n\tassign\tdcd_stalled = thecpu.core.dcd_stalled;\n\tassign\tdcd_gie     = thecpu.core.dcd_gie;\n\tassign\tdcd_valid   = thecpu.core.dcd_valid;\n\tassign\tdcd_illegal = thecpu.core.dcd_illegal;\n\tassign\tdcd_phase   = thecpu.core.dcd_phase;\n\tassign\tdcd_break   = thecpu.core.dcd_break;\n\tassign\tdcd_pipe    = thecpu.core.dcd_pipe;\n\t\t//\n\tassign\tdcd_opn     = thecpu.core.dcd_opn;\n\tassign\tdcd_rA      = thecpu.core.dcd_rA;\n\tassign\tdcd_rB      = thecpu.core.dcd_rB;\n\tassign\tdcd_wR      = thecpu.core.dcd_wR;\n\tassign\tdcd_wF      = thecpu.core.dcd_wF;\n\tassign\tdcdR        = thecpu.core.instruction_decoder.w_dcdR;\n\tassign\tdcdRpc      = thecpu.core.instruction_decoder.w_dcdR_pc;\n\tassign\tdcdRcc      = thecpu.core.instruction_decoder.w_dcdR_cc;\n\tassign\tdcd_pc      = thecpu.core.dcd_pc;\n\tassign\tdcd_M       = thecpu.core.dcd_M;\n\t// }}}\n\t// Peeking into the op stage\n\t// {{{\n\tassign\top_ce        = thecpu.core.op_ce;\n\tassign\top_illegal   = thecpu.core.op_illegal;\n\tassign\top_valid     = thecpu.core.op_valid;\n\tassign\top_valid_mem = thecpu.core.op_valid_mem;\n\tassign\top_valid_alu = thecpu.core.op_valid_alu;\n\tassign\top_stall     = thecpu.core.op_stall;\n\tassign\top_wR        = thecpu.core.op_wR;\n\tassign\top_wF        = thecpu.core.op_wF;\n\tassign\top_phase     = thecpu.core.op_phase;\n\tassign\top_gie       = thecpu.core.op_gie;\n\tassign\top_pipe      = thecpu.core.op_pipe;\n\tassign\top_R         = thecpu.core.op_R;\n\tassign\top_Aid       = thecpu.core.op_Aid;\n\tassign\top_Bid       = thecpu.core.op_Bid;\n\tassign\top_Av        = thecpu.core.op_Av;\n\tassign\top_Bv        = thecpu.core.op_Bv;\n\tassign\top_pc        = thecpu.core.op_pc;\n\tassign\tmaster_stall = thecpu.core.master_stall;\n\n\tassign\top_F         = thecpu.core.op_F;\n\tassign\top_pipe      = thecpu.core.op_pipe;\n\tassign\top_opn       = thecpu.core.op_opn;\n\t// }}}\n\t// Peeking into the ALU stage\n\t// {{{\n\tassign\talu_ce   = thecpu.core.alu_ce;\n\tassign\tadf_ce_unconditional   = thecpu.core.adf_ce_unconditional;\n\tassign\talu_valid   = thecpu.core.alu_valid;\n\tassign\talu_wR   = thecpu.core.alu_wR;\n\tassign\talu_wF   = thecpu.core.alu_wF;\n\tassign\talu_pc_valid   = thecpu.core.alu_pc_valid;\n\tassign\talu_illegal    = thecpu.core.alu_illegal;\n\tassign\talu_gie        = thecpu.core.alu_gie;\n\tassign\tset_cond       = thecpu.core.set_cond;\n\tassign\talu_phase      = thecpu.core.alu_phase;\n\tassign\talu_flags      = thecpu.core.alu_flags;\n\tassign\talu_pc         = thecpu.core.alu_pc;\n\n\tassign\talu_result     = thecpu.core.alu_result;\n\tassign\talu_busy       = thecpu.core.alu_busy;\n\tassign\talu_",
            "reg = thecpu.core.alu_",
            "reg ;\n\t// }}}\n\t// Peeking into the MEM stage\n\t// {{{\n\t//\n\tassign\tmem_valid    = thecpu.mem_valid;\n\tassign\tmem_pc_valid = thecpu.core.mem_pc_valid;\n\tassign\tmem_ce       = thecpu.core.o_mem_ce;\n\tassign\tmem_busy     = thecpu.core.i_mem_busy;\n\tassign\tmem_rdbusy   = thecpu.core.i_mem_rdbusy;\n\tassign\tmem_w",
            "reg = thecpu.core.i_mem_w",
            "reg ;\n\t// }}}\n\t// Peeking into the divide stage\n\t// {{{\n\tassign\tdiv_valid = thecpu.core.div_valid;\n\tassign\tdiv_ce    = thecpu.core.div_ce;\n\tassign\tdiv_busy  = thecpu.core.div_busy;\n\t// }}}\n\t// Writeback stage\n\t// {{{\n\tassign\twr_",
            "reg _id = thecpu.core.wr_",
            "reg _id;\n\tassign\twr_",
            "reg _ce = thecpu.core.wr_",
            "reg _ce;\n\tassign\twr_flags_ce = thecpu.core.wr_flags_ce;\n\tassign\twr_gp",
            "reg _vl = thecpu.core.wr_gp",
            "reg _vl;\n\tassign\twr_sp",
            "reg _vl = thecpu.core.wr_sp",
            "reg _vl;\n\tassign\tw_iflags    = thecpu.core.w_iflags;\n\tassign\tw_uflags    = thecpu.core.w_uflags;\n\t// }}}\n\t// Miscellaneous\n\t// {{{\n\tassign\tcpu_sim      = thecpu.core.cpu_sim;\n\tassign\tcpu_sim_immv = thecpu.core.op_sim_immv;\n\tassign\tr_sleep      = thecpu.core.sleep;\n\tassign\tmaster_ce    = thecpu.core.master_ce;\n\tassign\top_break     = thecpu.core.op_break;\n\tassign\tr_gie        = thecpu.core.gie;\n\t// }}}\n\t//\n\t// ZipSystem peripherals\n\t// {{{\n\tassign\twatchbus = { 18'h0, u_watchbus.r_value };\n\tassign\twatchdog = {  1'b0, u_watchdog.r_value };\n\tassign\ttimer_a = tma_data;\n\tassign\ttimer_b = tmb_data;\n\tassign\ttimer_c = tmc_data;\n\tassign\tjiffies = jif_data;\n\t//\n\tassign\twb_cyc_gbl = thecpu.mem_cyc_gbl;\n\tassign\twb_stb_gbl = thecpu.mem_stb_gbl;\n\tassign\twb_cyc_lcl = thecpu.mem_cyc_lcl;\n\tassign\twb_stb_lcl = thecpu.mem_stb_lcl;\n\tassign\tmem_stb_gbl = thecpu.mem_stb_gbl;\n\tassign\tmem_stb_lcl = thecpu.mem_stb_lcl;\n\tassign\tmem_we     = thecpu.mem_we;\n\tassign\tmem_ack    = thecpu.mem_ack;\n\tassign\tmem_stall  = thecpu.mem_stall;\n\tassign\tmem_data   = thecpu.mem_data;\n\tassign\tmem_addr   = { thecpu.core.o_mem_addr };\n\tassign\tmem_result = thecpu.mem_result;\n\tassign\tswitch_to_interrupt = thecpu.core.w_switch_to_interrupt;\n\tassign\trelease_from_interrupt = thecpu.core.w_release_from_interrupt;\n\tassign\tbreak_en = thecpu.core.break_en;\n\t// }}}\n`endif\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign unused = &{ 1'b0,\n\t\tcpu_dbg_cc[2],\n\t\tpic_ack, pic_stall, cpu_clken,\n\t\ttma_ack, tma_stall, tmb_ack, tmb_stall, tmc_ack, tmc_stall,\n\t\tjif_ack, jif_stall, no_dbg_err, dbg_sel,\n\t\tsel_mmus, ctri_ack, ctri_stall, mmus_stall, dmac_stall,\n\t\twdt_ack, wdt_stall, actr_ack, actr_stall,\n\t\twdbus_ack, i_dbg_sel,\n\t\t// moc_ack, mtc_ack, mic_ack, mpc_ack,\n\t\t// uoc_ack, utc_ack, uic_ack, upc_ack,\n\t\t// moc_stall, mtc_stall, mic_stall, mpc_stall,\n\t\t// uoc_stall, utc_stall, uic_stall, upc_stall,\n\t\t// Unused MMU pins\n\t\tpf_return_stb, pf_return_we, pf_return_p, pf_return_v,\n\t\tpf_return_cachable, cpu_miss };\n\t// verilator lint_on UNUSED\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "wire [2:0]\tfdbg_nreqs, fdbg_nacks, fdbg_outstanding;\n\n\tfwb_slave #(\n\t\t// {{{\n\t\t.AW(7), .DW(32), .F_LGDEPTH(3)\n\t\t// }}}\n\t) dbg (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_wb_cyc(i_dbg_cyc), .i_wb_stb(i_dbg_stb),\n\t\t\t.i_wb_we(i_dbg_we),\t.i_wb_addr(i_dbg_addr),\n\t\t\t.i_wb_data(i_dbg_data),\t.i_wb_sel(i_dbg_sel),\n\t\t.i_wb_ack(o_dbg_ack), .i_wb_stall(o_dbg_stall),\n\t\t.i_wb_idata(o_dbg_data), .i_wb_err(1'b0),\n\t\t.f_nreqs(fdbg_nreqs), .f_nacks(fdbg_nacks),\n\t\t\t.f_outstanding(fdbg_outstanding)\n\t\t// }}}\n\t);\n\n\tfwb_slave #(\n\t\t// {{{\n\t\t.AW(32), .DW(32), .F_LGDEPTH(3)\n\t\t// }}}\n\t) fwb_cpu (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(cpu_reset),\n\t\t//\n\t\t.i_wb_cyc(i_dbg_cyc), .i_wb_stb(i_dbg_stb),\n\t\t\t.i_wb_we(i_dbg_we),\t.i_wb_addr(i_dbg_addr),\n\t\t\t.i_wb_data(i_dbg_data),\t.i_wb_sel(i_dbg_sel),\n\t\t.i_wb_ack(o_dbg_ack), .i_wb_stall(o_dbg_stall),\n\t\t.i_wb_idata(o_dbg_data), .i_wb_err(1'b0),\n\t\t.f_nreqs(fdbg_nreqs), .f_nacks(fdbg_nacks),\n\t\t\t.f_outstanding(fdbg_outstanding)\n\t\t// }}}\n\t);\n\n\tfwb_master #(\n\t) fsys (\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t);\n\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipbones.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipbones.v",
        "chunks": [
            "module .\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module zipbones #(\n\t\t// {{{",
            "parameter RESET_ADDRESS=32'h1000_0000,\n\t\t\t\tADDRESS_WIDTH=32,",
            "parameter BUS_WIDTH=32,\t// Bus data width\n\t\t// CPU options\n\t\t// {{{",
            "parameter [0:0]\tOPT_PIPELINED=1,",
            "parameter [0:0]\tOPT_EARLY_BRANCHING=OPT_PIPELINED,\n\t\t// OPT_LGICACHE\n\t\t// {{{",
            "parameter OPT_LGICACHE = 2,\n\t\t// }}}\n\t\t// OPT_LGDCACHE\n\t\t// {{{\n\t\t// Set to zero for no data cache",
            "parameter OPT_LGDCACHE = 0,\n\t\t// }}}",
            "parameter [0:0]\tSTART_HALTED=1,",
            "parameter [0:0]\tOPT_DISTRIBUTED_REGS=1,\n\t\t// OPT_MPY\n\t\t// {{{",
            "parameter OPT_MPY = 3,\n\t\t// }}}\n\t\t// OPT_DIV\n\t\t// {{{",
            "parameter [0:0]\tOPT_DIV=1,\n\t\t// }}}\n\t\t// OPT_SHIFTS\n\t\t// {{{",
            "parameter [0:0]\tOPT_SHIFTS = 1,\n\t\t// }}}\n\t\t// OPT_FPU\n\t\t// {{{",
            "parameter [0:0]\tOPT_FPU = 0,\n\t\t// }}}",
            "parameter [0:0]\tOPT_CIS=1,",
            "parameter [0:0]\tOPT_LOCK=1,",
            "parameter [0:0]\tOPT_USERMODE=1,",
            "parameter [0:0]\tOPT_DBGPORT=START_HALTED,",
            "parameter [0:0]\tOPT_TRACE_PORT=1,",
            "parameter [0:0]\tOPT_PROFILER=0,",
            "parameter [0:0]\tOPT_LOWPOWER=0,\n`ifdef\tVERILATOR",
            "parameter [0:0]\tOPT_SIM=1'b1,",
            "parameter [0:0]\tOPT_CLKGATE = OPT_LOWPOWER,\n`else",
            "parameter [0:0]\tOPT_SIM=1'b0,",
            "parameter [0:0]\tOPT_CLKGATE = 1'b0,\n`endif\n\t\t// }}}",
            "parameter RESET_DURATION = 10,\n\t\t// Short-cut names\n\t\t// {{{\n\t\t//",
            "localparam AW=ADDRESS_WIDTH,",
            "localparam DBG_WIDTH=32,\t// Debug bus data width",
            "localparam // Derived",
            "parameter s\n\t\t\t\t// PHYSICAL_ADDRESS_WIDTH=ADDRESS_WIDTH,\n\t\t\t\tPAW=ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)\n`ifdef\tOPT_MMU\n\t\t\t\t// VIRTUAL_ADDRESS_WIDTH=30,\n`else\n\t\t\t\t// VIRTUAL_ADDRESS_WIDTH=PAW,\n`endif\n\t\t\t\t// LGTLBSZ = 6,\n\t\t\t\t// VAW=VIRTUAL_ADDRESS_WIDTH,\n\n\t\t// }}}\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Wishbone master interface from the CPU\n\t\t// {{{",
            "output ",
            "wire o_wb_cyc, o_wb_stb, o_wb_we,",
            "output ",
            "wire [PAW-1:0]\t\to_wb_addr,",
            "output ",
            "wire [BUS_WIDTH-1:0]\to_wb_data,",
            "output ",
            "wire [BUS_WIDTH/8-1:0]\to_wb_sel,",
            "input ",
            "wire i_wb_stall, i_wb_ack,",
            "input ",
            "wire [BUS_WIDTH-1:0]\ti_wb_data,",
            "input ",
            "wire i_wb_err,\n\t\t// }}}\n\t\t// Incoming interrupts",
            "input ",
            "wire i_ext_int,\n\t\t// Our one outgoing interrupt",
            "output ",
            "wire o_ext_int,\n\t\t// Wishbone slave interface for debugging purposes\n\t\t// {{{",
            "input ",
            "wire i_dbg_cyc, i_dbg_stb, i_dbg_we,",
            "input ",
            "wire [5:0]\t\ti_dbg_addr,",
            "input ",
            "wire [DBG_WIDTH-1:0]\ti_dbg_data,",
            "input ",
            "wire [DBG_WIDTH/8-1:0]\ti_dbg_sel,",
            "output ",
            "wire o_dbg_stall,",
            "output ",
            "wire o_dbg_ack,",
            "output ",
            "wire [DBG_WIDTH-1:0]\to_dbg_data,\n\t\t// }}}",
            "output ",
            "wire [31:0]\t\to_cpu_debug,\n\t\t//\n`ifdef\tVBENCH_TB\n\t\t// {{{\n\t\t//",
            "output ",
            "wire cpu_halt,\n\t\t//\t\t\t\tcmd_reset,\n\t\t//\t\t\t\tcmd_step,",
            "output ",
            "wire early_branch,",
            "output ",
            "wire [31:0]\t\tearly_branch_pc,",
            "output ",
            "wire [6:0]\t\tdcdA, dcdB,",
            "output ",
            "wire new_pc,",
            "output ",
            "wire [31:0]\t\tcpu_ipc, cpu_upc, pf_pc,",
            "output ",
            "wire pf_cyc, pf_stb, pf_we,",
            "output ",
            "wire [31:0]\t\tpf_addr,",
            "output ",
            "wire pf_ack,",
            "output ",
            "wire pf_valid, pf_illegal,\n\t\t// pf_vmask, pf_r_v, pf_tagsrc, pf_tagipc, pf_tagvallst,\n\t\t//",
            "output ",
            "wire [31:0]\t\tpf_lastpc,",
            "output ",
            "wire [31:0]\t\tpf_instruction,",
            "output ",
            "wire [31:0]\t\tpf_instruction_pc,\n\t\t//",
            "output ",
            "wire dcd_ce, dcd_stalled, dcd_gie,\n\t\t\t\t\t\tdcd_valid, dcd_illegal,\n\t\t\t\t\t\tdcd_phase, dcd_break, dcd_pipe,",
            "output ",
            "wire [3:0]\t\tdcd_opn,",
            "output ",
            "wire dcd_rA, dcd_rB, dcd_wR, dcd_wF,",
            "output ",
            "wire [4:0]\t\tdcdR,",
            "output ",
            "wire dcdRpc, dcdRcc,",
            "output ",
            "wire [31:0]\t\tdcd_pc,",
            "output ",
            "wire dcd_M,\n\t\t//",
            "output ",
            "wire op_ce, op_illegal, op_valid,\n\t\t\t\t\t\top_valid_mem, op_valid_alu,\n\t\t\t\t\t\top_stall, op_wR, op_wF,\n\t\t\t\t\t\top_phase, op_gie,",
            "output ",
            "wire [4:0]\t\top_R, op_Aid, op_Bid,",
            "output ",
            "wire [31:0]\t\top_Av, op_Bv, op_pc,",
            "output ",
            "wire master_stall,\n\t\t//",
            "output ",
            "wire alu_ce, adf_ce_unconditional,\n\t\t\t\t\t\talu_valid, alu_wR, alu_wF,\n\t\t\t\t\t\talu_pc_valid, alu_illegal,\n\t\t\t\t\t\talu_gie,\n\t\t\t\t\t\tset_cond, alu_phase,",
            "output ",
            "wire [3:0]\t\talu_flags,",
            "output ",
            "wire [31:0]\t\talu_pc,\n\t\t//",
            "output ",
            "wire mem_valid, mem_pc_valid, mem_ce,\n\t\t\t\t\t\tmem_busy, mem_rdbusy,",
            "output ",
            "wire [4:0]\t\tmem_w",
            "reg ,\n\t\t//",
            "output ",
            "wire div_valid, div_ce, div_busy,\n\t\t//",
            "output ",
            "wire [4:0]\t\twr_",
            "reg _id,",
            "output ",
            "wire wr_",
            "reg _ce, wr_flags_ce,",
            "output ",
            "wire [31:0]\t\twr_gp",
            "reg _vl, wr_sp",
            "reg _vl,",
            "output ",
            "wire [15:0]\t\tw_iflags, w_uflags,\n\t\t//",
            "output ",
            "wire cpu_sim,\n\t\t\t\t\t\tr_sleep, master_ce, op_break,\n\t\t\t\t\t\tr_gie,",
            "output ",
            "wire [22:0]\t\tcpu_sim_immv,",
            "output ",
            "wire [7:0]\t\top_F,\n\t\t//\n\t\t//\n\t\t// ZipSystem peripherals",
            "output ",
            "wire [31:0]\t\twatchbus, watchdog, pic_data,\n\t\t\t\t\t\twdbus_data,",
            "output ",
            "wire [15:0]\t\tint_state, alt_int_state,",
            "output ",
            "wire [31:0]\t\ttimer_a,\n\t\t\t\t\t\ttimer_b, timer_c, jiffies,\n\t\t\t\t\t\tutc_data, uoc_data, uic_data,\n\t\t\t\t\t\tupc_data, mtc_data, moc_data,\n\t\t\t\t\t\tmpc_data, mic_data,",
            "output ",
            "wire wb_cyc_gbl, wb_cyc_lcl,\n\t\t\t\t\t\twb_stb_gbl, wb_stb_lcl,\n\t\t\t\t\t\tmem_stb_gbl, mem_stb_lcl,\n\t\t\t\t\t\tmem_we, mem_ack, mem_stall,",
            "output ",
            "wire [31:0]\t\tmem_data, mem_addr, mem_result,",
            "output ",
            "wire op_pipe,\n\t\t\t\t\t\t// op_A_alu, op_B_alu,\n\t\t\t\t\t\t// op_A_mem, op_B_mem,",
            "output ",
            "wire [3:0]\t\top_opn,",
            "output ",
            "wire [31:0]\t\talu_result,",
            "output ",
            "wire alu_busy,",
            "output ",
            "wire [4:0]\t\talu_",
            "reg ,",
            "output ",
            "wire switch_to_interrupt,\n\t\t\t\t\t\trelease_from_interrupt,\n\t\t\t\t\t\tbreak_en,",
            "output ",
            "wire pformem_owner,\n\t\t// }}}\n`endif",
            "output ",
            "wire o_prof_stb,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0]\to_prof_addr,",
            "output ",
            "wire [31:0]\t\to_prof_ticks\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam [0:0]\tDBG_ADDR_CTRL = 1'b0,\n\t\t\t\tDBG_ADDR_CPU  = 1'b1;\n\n\t// Debug bit allocations\n\t// {{{\n\t//\tDBGCTRL\n\t//\t\t 5 DBG Catch -- Catch exceptions/fautls w/ debugger\n\t//\t\t 4 Clear cache\n\t//\t\t 3 RESET_FLAG\n\t//\t\t 2 STEP\t(W=1 steps, and returns to halted)\n\t//\t\t 1 HALT(ED)\n\t//\t\t 0 HALT\n\t//\tDBGDATA\n\t//\t\tread/writes internal",
            "reg isters\n\t//",
            "localparam HALT_BIT = 0,\n\t\t\tSTEP_BIT = 2,\n\t\t\tRESET_BIT = 3,\n\t\t\tCLEAR_CACHE_BIT = 4,\n\t\t\tCATCH_BIT = 5;\n\t// }}}",
            "wire cpu_clken;",
            "wire dbg_cyc, dbg_stb, dbg_we, dbg_stall;",
            "wire [5:0]\t\tdbg_addr;",
            "wire [DBG_WIDTH-1:0]\tdbg_idata;",
            "wire [DBG_WIDTH/8-1:0]\tdbg_sel;",
            "reg [DBG_WIDTH-1:0]\tdbg_odata;",
            "reg dbg_ack;",
            "wire cpu_break, dbg_cmd_write,\n\t\t\t\tdbg_cpu_write, dbg_cpu_read;",
            "wire reset_hold, halt_on_fault, dbg_catch;",
            "wire reset_request, release_request, halt_request,\n\t\t\t\tstep_request, clear_cache_request;",
            "reg cmd_reset, cmd_halt, cmd_step, cmd_clear_cache,\n\t\t\t\tcmd_write, cmd_read;",
            "reg [2:0]\t\tcmd_read_ack;",
            "reg [4:0]\t\tcmd_waddr;",
            "reg [DBG_WIDTH-1:0]\tcmd_wdata;",
            "wire [2:0]\t\tcpu_dbg_cc;",
            "wire cpu_reset, cpu_halt, cpu_dbg_stall,\n\t\t\t\tcpu_has_halted;",
            "wire cpu_lcl_cyc, cpu_lcl_stb,\n\t\t\t\tcpu_op_stall, cpu_pf_stall, cpu_i_count;",
            "wire [DBG_WIDTH-1:0]\tcpu_dbg_data;",
            "wire [DBG_WIDTH-1:0]\tcpu_status;",
            "wire [DBG_WIDTH-1:0]\tdbg_cmd_data;",
            "wire [DBG_WIDTH/8-1:0]\tdbg_cmd_strb;",
            "reg dbg_pre_ack;",
            "reg [DBG_WIDTH-1:0]\tdbg_cpu_status;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Debug bus signal renaming\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tassign\tdbg_cyc     = i_dbg_cyc;\n\tassign\tdbg_stb     = i_dbg_stb;\n\tassign\tdbg_we      = i_dbg_we;\n\tassign\tdbg_addr    = i_dbg_addr;\n\tassign\tdbg_idata   = i_dbg_data;\n\tassign\tdbg_sel     = i_dbg_sel;\n\tassign\to_dbg_ack   = dbg_ack;\n\tassign\to_dbg_stall = dbg_stall;\n\tassign\to_dbg_data  = dbg_odata;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The external debug interface\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tassign\tdbg_cpu_write = OPT_DBGPORT && (dbg_stb && !dbg_stall && dbg_we)\n\t\t\t\t&& (dbg_addr[5] == DBG_ADDR_CPU)\n\t\t\t\t&& dbg_sel == 4'hf;\n\tassign\tdbg_cpu_read = (dbg_stb && !dbg_stall && !dbg_we\n\t\t\t\t&& dbg_addr[5] == DBG_ADDR_CPU);\n\tassign\tdbg_cmd_write = (dbg_stb && !dbg_stall && dbg_we)\n\t\t\t\t\t&&(dbg_addr[5] == DBG_ADDR_CTRL);\n\tassign\tdbg_cmd_data = dbg_idata;\n\tassign\tdbg_cmd_strb = dbg_sel;\n\n\n\tassign\treset_request = dbg_cmd_write && dbg_cmd_strb[RESET_BIT/8]\n\t\t\t\t\t\t&& dbg_cmd_data[RESET_BIT];\n\tassign\trelease_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8]\n\t\t\t\t\t\t&& !dbg_cmd_data[HALT_BIT];\n\tassign\thalt_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8]\n\t\t\t\t\t\t&& dbg_cmd_data[HALT_BIT];\n\tassign\tstep_request = dbg_cmd_write && dbg_cmd_strb[STEP_BIT/8]\n\t\t\t\t\t\t&& dbg_cmd_data[STEP_BIT];\n\tassign\tclear_cache_request = dbg_cmd_write\n\t\t\t\t\t&& dbg_cmd_strb[CLEAR_CACHE_BIT/8]\n\t\t\t\t\t&& dbg_cmd_data[CLEAR_CACHE_BIT];\n\n\t//\n\t// reset_hold: Always start us off with an initial reset\n\t// {{{\n\tgenerate if (RESET_DURATION > 0)\n\tbegin : INITIAL_RESET_HOLD\n\t\t// {{{",
            "reg [$clog2(RESET_DURATION)-1:0]\treset_counter;",
            "reg r_reset_hold;\n\n\t\tinitial\treset_counter = RESET_DURATION;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\treset_counter <= RESET_DURATION;\n\t\telse if (reset_counter > 0)\n\t\t\treset_counter <= reset_counter - 1;\n\n\t\tinitial\tr_reset_hold = 1;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_reset_hold <= 1;\n\t\telse\n\t\t\tr_reset_hold <= (reset_counter > 1);\n\n\t\tassign\treset_hold = r_reset_hold;\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\t\tassert(reset_hold == (reset_counter != 0));\n`endif\n\t\t// }}}\n\tend else begin : NO_RESET_HOLD\n\n\t\tassign reset_hold = 0;\n\n\tend endgenerate\n\t// }}}\n\n\tassign\thalt_on_fault = dbg_catch;\n\n\t// cmd_reset\n\t// {{{\n\t// Always start us off with an initial reset\n\tinitial\tcmd_reset = 1'b1;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tcmd_reset <= 1'b1;\n\telse if (reset_hold)\n\t\tcmd_reset <= 1'b1;\n\telse if (cpu_break && !halt_on_fault)\n\t\tcmd_reset <= 1'b1;\n\telse\n\t\tcmd_reset <= reset_request;\n\t// }}}\n\n\t// cmd_halt\n\t// {{{\n\tinitial\tcmd_halt  = START_HALTED;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tcmd_halt <= START_HALTED;\n\telse if (cmd_reset && START_HALTED)\n\t\tcmd_halt <= START_HALTED;\n\telse begin\n\t\t// {{{\n\t\t// When shall we release from a halt?  Only if we have\n\t\t// come to a full and complete stop.  Even then, we only\n\t\t// release if we aren't being given a command to step the CPU.\n\t\t//\n\t\tif (!cmd_write && cpu_has_halted && dbg_cmd_write\n\t\t\t\t&& (release_request || step_request))\n\t\t\tcmd_halt <= 1'b0;\n\n\t\t// Reasons to halt\n\n\t\t// 1. Halt on any unhandled CPU exception.  The cause of the\n\t\t//\texception must be cured before we can (re)start.\n\t\t//\tIf the CPU is configured to start immediately on power\n\t\t//\tup, we leave it to reset on any exception instead.\n\t\tif (cpu_break && halt_on_fault)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 2. Halt on any user request to halt.  (Only valid if the\n\t\t//\tSTEP bit isn't also set)\n\t\tif (dbg_cmd_write && halt_request && !step_request)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 3. Halt on any user request to write to a CPU",
            "reg ister\n\t\tif (dbg_cpu_write)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 4. Halt following any step command\n\t\tif (cmd_step && !step_request)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 5. Halt following any clear cache\n\t\tif (cmd_clear_cache)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 6. Halt on any clear cache bit--independent of any step bit\n\t\tif (clear_cache_request)\n\t\t\tcmd_halt <= 1'b1;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// cmd_clear_cache\n\t// {{{\n\tinitial\tcmd_clear_cache = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || cpu_reset)\n\t\tcmd_clear_cache <= 1'b0;\n\telse if (dbg_cmd_write && clear_cache_request && halt_request)\n\t\tcmd_clear_cache <= 1'b1;\n\telse if (cmd_halt && !cpu_dbg_stall)\n\t\tcmd_clear_cache <= 1'b0;\n\t// }}}\n\n\t// cmd_step\n\t// {{{\n\tinitial\tcmd_step = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tcmd_step <= 1'b0;\n\telse if (cmd_reset || cpu_break\n\t\t\t|| reset_request\n\t\t\t|| clear_cache_request || cmd_clear_cache\n\t\t\t|| halt_request || dbg_cpu_write)\n\t\tcmd_step <= 1'b0;\n\telse if (!cmd_write && cpu_has_halted && step_request)\n\t\tcmd_step <= 1'b1;\n\telse // if (cpu_dbg_stall)\n\t\tcmd_step <= 1'b0;\n`ifdef\tFORMAL\n\t// While STEP is true, we can't halt\n\talways @(*)\n\tif (!i_reset && cmd_step)\n\t\tassert(!cmd_halt);\n`endif\n\t// }}}\n\n\t// dbg_catch\n\t// {{{\n\tgenerate if (!OPT_DBGPORT)\n\tbegin : NO_DBG_CATCH\n\t\tassign\tdbg_catch = START_HALTED;\n\tend else begin : GEN_DBG_CATCH",
            "reg r_dbg_catch;\n\n\t\tinitial\tr_dbg_catch = START_HALTED;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_dbg_catch <= START_HALTED;\n\t\telse if (dbg_cmd_write && dbg_cmd_strb[CATCH_BIT/8])\n\t\t\tr_dbg_catch <= dbg_cmd_data[CATCH_BIT];\n\n\t\tassign\tdbg_catch = r_dbg_catch;\n\tend endgenerate\n\t// }}}\n\n\tassign\tcpu_reset = (cmd_reset);\n\tassign\tcpu_halt = (cmd_halt);\n\n\t// cpu_status\n\t// {{{\n\t//\t0xffff_f000 -> (Unused / reserved)\n\t//\n\t//\t0x0000_0800 -> cpu_break\n\t//\t0x0000_0400 -> Interrupt pending\n\t//\t0x0000_0200 -> User mode\n\t//\t0x0000_0100 -> Sleep (CPU is sleeping)\n\t//\n\t//\t0x0000_00c0 -> (Unused/reserved)\n\t//\t0x0000_0020 -> dbg_catch\n\t//\t0x0000_0010 -> cmd_clear_cache\n\t//\n\t//\t0x0000_0008 -> Reset\n\t//\t0x0000_0004 -> Step (auto clearing, write only)\n\t//\t0x0000_0002 -> Halt (status)\n\t//\t0x0000_0001 -> Halt (request)\n\tassign\tcpu_status = { 16'h0, 4'h0,\n\t\t\tcpu_break, i_ext_int, cpu_dbg_cc[1:0],\n\t\t\t2'h0, dbg_catch, 1'b0,\n\t\t\tcmd_reset, 1'b0, !cpu_dbg_stall, cmd_halt\n\t\t};\n\n\t// }}}\n\n\t// cmd_write\n\t// {{{\n\tinitial\tcmd_write = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || cpu_reset)\n\t\tcmd_write <= 1'b0;\n\telse if (!cmd_write || cpu_has_halted)\n\t\tcmd_write <= dbg_cpu_write;\n\t// }}}\n\n\t// cmd_read\n\t// {{{\n\tinitial\tcmd_read = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || !dbg_cyc || !OPT_DBGPORT)\n\t\tcmd_read <= 1'b0;\n\telse if (dbg_cpu_read)\n\t\tcmd_read <= 1'b1;\n\telse if (cmd_read_ack == 1)\n\t\tcmd_read <= 1'b0;\n\n\tinitial\tcmd_read_ack = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || !dbg_cyc || !OPT_DBGPORT)\n\t\tcmd_read_ack <= 0;\n\telse if (dbg_cpu_read)\n\t\tcmd_read_ack <= 2 + (OPT_DISTRIBUTED_REGS ? 0:1);\n\telse if (cmd_read_ack > 0)\n\t\tcmd_read_ack <= cmd_read_ack - 1;\n\t// }}}\n\n\t// cmd_waddr, cmd_wdata\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((!cmd_write || cpu_has_halted) && dbg_cpu_write)\n\tbegin\n\t\tcmd_waddr <= dbg_addr[4:0];\n\t\tcmd_wdata <= dbg_idata;\n\tend\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The CPU itself\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tassign\tcpu_clken = cmd_write || cmd_read || dbg_cyc;\n`ifdef\tFORMAL\n\t// {{{\n\t(* anyseq *)",
            "reg f_cpu_halted, f_cpu_data, f_cpu_stall,\n\t\t\t\tf_cpu_break;\n\t(* anyseq *)",
            "reg [2:0]\tf_cpu_dbg_cc;\n\t(* anyseq *)",
            "reg [31:0]\tf_cpu_dbg_data;\n\n\tassign\tcpu_dbg_stall = f_cpu_stall && !f_cpu_halted;\n\tassign\tcpu_break     = f_cpu_break;\n\tassign\tcpu_dbg_cc    = f_cpu_dbg_cc;\n\tassign\tcpu_dbg_data  = f_cpu_dbg_data;\n\tassign\tcpu_has_halted= f_cpu_halted;\n\n\tfdebug #(\n\t\t// {{{\n\t\t.OPT_START_HALTED(START_HALTED),\n\t\t.OPT_DISTRIBUTED_RAM(OPT_DISTRIBUTED_REGS)\n\t\t// }}}\n\t) fdbg (\n\t\t// {{{\n\t\t.i_clk(i_clk),\n\t\t.i_reset(i_reset),\n\t\t.i_cpu_reset(cpu_reset),\n\t\t.i_halt(cpu_halt),\n\t\t.i_halted(f_cpu_halted),\n\t\t.i_clear_cache(cmd_clear_cache),\n\t\t.i_dbg_we(cmd_write),\n\t\t.i_dbg_",
            "reg (cmd_waddr),\n\t\t.i_dbg_data(cmd_wdata),\n\t\t.i_dbg_stall(cpu_dbg_stall),\n\t\t.i_dbg_break(cpu_break),\n\t\t.i_dbg_cc(cpu_dbg_cc)\n\t\t// }}}\n\t);\n\t// }}}\n`else\n\tzipwb\t#(\n\t\t// {{{\n\t\t.RESET_ADDRESS(RESET_ADDRESS),\n\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)),\n\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t.OPT_LGICACHE(OPT_LGICACHE),\n\t\t.OPT_LGDCACHE(OPT_LGDCACHE),\n\t\t.OPT_MPY(OPT_MPY),\n\t\t.OPT_DIV(OPT_DIV),\n\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t.IMPLEMENT_FPU(OPT_FPU),\n\t\t.OPT_CIS(OPT_CIS),\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.OPT_START_HALTED(START_HALTED),\n\t\t.OPT_SIM(OPT_SIM),\n\t\t.OPT_DBGPORT(OPT_DBGPORT),\n\t\t.OPT_TRACE_PORT(OPT_TRACE_PORT),\n\t\t.OPT_PROFILER(OPT_PROFILER),\n\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t.WITH_LOCAL_BUS(0)\n\t\t// }}}\n\t) thecpu(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(cpu_reset), .i_interrupt(i_ext_int),\n\t\t\t.i_cpu_clken(cpu_clken),\n\t\t// Debug interface\n\t\t// {{{\n\t\t.i_halt(cpu_halt), .i_clear_cache(cmd_clear_cache),\n\t\t\t\t.i_dbg_w",
            "reg (cmd_waddr), .i_dbg_we(cmd_write),\n\t\t\t\t.i_dbg_data(cmd_wdata),\n\t\t\t\t.i_dbg_r",
            "reg (dbg_addr[4:0]),\n\t\t\t.o_dbg_stall(cpu_dbg_stall),\n\t\t\t.o_halted(cpu_has_halted),\n\t\t\t.o_dbg_",
            "reg (cpu_dbg_data),\n\t\t\t.o_dbg_cc(cpu_dbg_cc),\n\t\t\t.o_break(cpu_break),\n\t\t// }}}\n\t\t// Wishbone bus interface\n\t\t// {{{\n\t\t.o_wb_gbl_cyc(o_wb_cyc), .o_wb_gbl_stb(o_wb_stb),\n\t\t\t.o_wb_lcl_cyc(cpu_lcl_cyc),\n\t\t\t.o_wb_lcl_stb(cpu_lcl_stb),\n\t\t\t.o_wb_we(o_wb_we), .o_wb_addr(o_wb_addr),\n\t\t\t.o_wb_data(o_wb_data), .o_wb_sel(o_wb_sel),\n\t\t// Return values from the Wishbone bus\n\t\t.i_wb_stall(i_wb_stall), .i_wb_ack(i_wb_ack),\n\t\t\t\t.i_wb_data(i_wb_data),\n\t\t\t\t.i_wb_err((i_wb_err)||(cpu_lcl_cyc)),\n\t\t// }}}\n\t\t\t.o_op_stall(cpu_op_stall), .o_pf_stall(cpu_pf_stall),\n\t\t\t\t.o_i_count(cpu_i_count),\n\t\t.o_debug(o_cpu_debug),\n\t\t//\n\t\t.o_prof_stb(o_prof_stb),\n\t\t.o_prof_addr(o_prof_addr),\n\t\t.o_prof_ticks(o_prof_ticks)\n\t\t// }}}\n\t);\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Return debug response values\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// always @(posedge i_clk)\n\t//\tdbg_pre_addr <= dbg_addr[5];\n\n\talways @(posedge i_clk)\n\t\tdbg_cpu_status <= cpu_status;\n\n\tinitial\tdbg_pre_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || !i_dbg_cyc)\n\t\tdbg_pre_ack <= 1'b0;\n\telse\n\t\tdbg_pre_ack <= dbg_stb && !dbg_stall && !dbg_cpu_read;\n\n\tinitial dbg_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || !i_dbg_cyc)\n\t\tdbg_ack <= 1'b0;\n\telse\n\t\tdbg_ack <= dbg_pre_ack || (cmd_read_ack == 1);\n\n\talways @(posedge i_clk)\n\tif (!OPT_LOWPOWER || dbg_pre_ack || cmd_read)\n\tbegin\n\t\tif (cmd_read)\n\t\t\tdbg_odata <= cpu_dbg_data;\n\t\telse\n\t\t\tdbg_odata <= dbg_cpu_status;\n\tend\n\n\tassign\tdbg_stall = cmd_read || (cmd_write && cpu_dbg_stall\n\t\t\t&& dbg_addr[5] == DBG_ADDR_CPU);\n\t// }}}\n\n\tassign\to_ext_int = (cmd_halt) && (!i_wb_stall);\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Simulation only accesses, to make the simulation display work\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n`ifdef\tVBENCH_TB\n\tassign\tearly_branch = thecpu.core.dcd_early_branch;\n\tassign\tearly_branch_pc = thecpu.core.dcd_branch_pc;\n\n\tassign\tdcdA = thecpu.core.dcd_full_A;\n\tassign\tdcdB = thecpu.core.dcd_full_B;\n\n\tassign\tnew_pc = thecpu.core.new_pc;\n\tassign\tcpu_ipc= thecpu.core.ipc;\n\tassign\tcpu_upc= thecpu.core.upc;\n\tassign\tpf_pc  = thecpu.core.pf_pc;\n\n\tassign\tpf_cyc = thecpu.pf_cyc;\n\tassign\tpf_stb = thecpu.pf_stb;\n\tassign\tpf_we  = thecpu.pf_we;\n\tassign\tpf_addr= { thecpu.pf_addr, 2'b00 };\n\tassign\tpf_ack = thecpu.pf_ack;\n\tassign\tpf_valid = thecpu.pf_valid;\n\tassign\tpf_illegal = thecpu.pf_illegal;\n\t// assign\tcpu_idata  = thecpu.i_wb_data;\n\tassign\tpf_instruction = thecpu.pf_instruction;\n\tassign\tpf_instruction_pc = thecpu.pf_instruction_pc;\n\tgenerate if (OPT_PIPELINED)\n\tbegin : GEN_PFORMEM_OWNER_DATA\n\t\tassign\tpformem_owner = thecpu.PRIORITY_DATA.pformem.r_a_owner;\n\tend else begin : GEN_PFORMEM_OWNER_FETCH\n\t\tassign\tpformem_owner = thecpu.PRIORITY_PREFETCH.pformem.r_a_owner;\n\tend endgenerate\n\t//\n\t// Peeking into the decode stage\n\t// {{{\n\tassign\tdcd_ce      = thecpu.core.dcd_ce;\n\tassign\tdcd_stalled = thecpu.core.dcd_stalled;\n\tassign\tdcd_gie     = thecpu.core.dcd_gie;\n\tassign\tdcd_valid   = thecpu.core.dcd_valid;\n\tassign\tdcd_illegal = thecpu.core.dcd_illegal;\n\tassign\tdcd_phase   = thecpu.core.dcd_phase;\n\tassign\tdcd_break   = thecpu.core.dcd_break;\n\tassign\tdcd_pipe    = thecpu.core.dcd_pipe;\n\t\t//\n\tassign\tdcd_opn     = thecpu.core.dcd_opn;\n\tassign\tdcd_rA      = thecpu.core.dcd_rA;\n\tassign\tdcd_rB      = thecpu.core.dcd_rB;\n\tassign\tdcd_wR      = thecpu.core.dcd_wR;\n\tassign\tdcd_wF      = thecpu.core.dcd_wF;\n\tassign\tdcdR        = thecpu.core.instruction_decoder.w_dcdR;\n\tassign\tdcdRpc      = thecpu.core.instruction_decoder.w_dcdR_pc;\n\tassign\tdcdRcc      = thecpu.core.instruction_decoder.w_dcdR_cc;\n\tassign\tdcd_pc      = thecpu.core.dcd_pc;\n\tassign\tdcd_M       = thecpu.core.dcd_M;\n\t// }}}\n\t// Peeking into the op stage\n\t// {{{\n\tassign\top_ce        = thecpu.core.op_ce;\n\tassign\top_illegal   = thecpu.core.op_illegal;\n\tassign\top_valid     = thecpu.core.op_valid;\n\tassign\top_valid_mem = thecpu.core.op_valid_mem;\n\tassign\top_valid_alu = thecpu.core.op_valid_alu;\n\tassign\top_stall     = thecpu.core.op_stall;\n\tassign\top_wR        = thecpu.core.op_wR;\n\tassign\top_wF        = thecpu.core.op_wF;\n\tassign\top_phase     = thecpu.core.op_phase;\n\tassign\top_gie       = thecpu.core.op_gie;\n\tassign\top_pipe      = thecpu.core.op_pipe;\n\tassign\top_R         = thecpu.core.op_R;\n\tassign\top_Aid       = thecpu.core.op_Aid;\n\tassign\top_Bid       = thecpu.core.op_Bid;\n\tassign\top_Av        = thecpu.core.op_Av;\n\tassign\top_Bv        = thecpu.core.op_Bv;\n\tassign\top_pc        = thecpu.core.op_pc;\n\tassign\tmaster_stall = thecpu.core.master_stall;\n\n\tassign\top_F         = thecpu.core.op_F;\n\tassign\top_pipe      = thecpu.core.op_pipe;\n\tassign\top_opn       = thecpu.core.op_opn;\n\t// }}}\n\t// Peeking into the ALU stage\n\t// {{{\n\tassign\talu_ce   = thecpu.core.alu_ce;\n\tassign\tadf_ce_unconditional   = thecpu.core.adf_ce_unconditional;\n\tassign\talu_valid   = thecpu.core.alu_valid;\n\tassign\talu_wR   = thecpu.core.alu_wR;\n\tassign\talu_wF   = thecpu.core.alu_wF;\n\tassign\talu_pc_valid   = thecpu.core.alu_pc_valid;\n\tassign\talu_illegal    = thecpu.core.alu_illegal;\n\tassign\talu_gie        = thecpu.core.alu_gie;\n\tassign\tset_cond       = thecpu.core.set_cond;\n\tassign\talu_phase      = thecpu.core.alu_phase;\n\tassign\talu_flags      = thecpu.core.alu_flags;\n\tassign\talu_pc         = thecpu.core.alu_pc;\n\n\tassign\talu_result     = thecpu.core.alu_result;\n\tassign\talu_busy       = thecpu.core.alu_busy;\n\tassign\talu_",
            "reg = thecpu.core.alu_",
            "reg ;\n\t// }}}\n\t// Peeking into the MEM stage\n\t// {{{\n\t//\n\tassign\tmem_valid    = thecpu.mem_valid;\n\tassign\tmem_pc_valid = thecpu.core.mem_pc_valid;\n\tassign\tmem_ce       = thecpu.core.o_mem_ce;\n\tassign\tmem_busy     = thecpu.core.i_mem_busy;\n\tassign\tmem_rdbusy   = thecpu.core.i_mem_rdbusy;\n\tassign\tmem_w",
            "reg = thecpu.core.i_mem_w",
            "reg ;\n\t// }}}\n\t// Peeking into the divide stage\n\t// {{{\n\tassign\tdiv_valid = thecpu.core.div_valid;\n\tassign\tdiv_ce    = thecpu.core.div_ce;\n\tassign\tdiv_busy  = thecpu.core.div_busy;\n\t// }}}\n\t// Writeback stage\n\t// {{{\n\tassign\twr_",
            "reg _id = thecpu.core.wr_",
            "reg _id;\n\tassign\twr_",
            "reg _ce = thecpu.core.wr_",
            "reg _ce;\n\tassign\twr_flags_ce = thecpu.core.wr_flags_ce;\n\tassign\twr_gp",
            "reg _vl = thecpu.core.wr_gp",
            "reg _vl;\n\tassign\twr_sp",
            "reg _vl = thecpu.core.wr_sp",
            "reg _vl;\n\tassign\tw_iflags    = thecpu.core.w_iflags;\n\tassign\tw_uflags    = thecpu.core.w_uflags;\n\t// }}}\n\t// Miscellaneous\n\t// {{{\n\tassign\tcpu_sim      = thecpu.core.cpu_sim;\n\tassign\tcpu_sim_immv = thecpu.core.op_sim_immv;\n\tassign\tr_sleep      = thecpu.core.sleep;\n\tassign\tmaster_ce    = thecpu.core.master_ce;\n\tassign\top_break     = thecpu.core.op_break;\n\tassign\tr_gie        = thecpu.core.gie;\n\t// }}}\n\t//\n\t// ZipSystem peripherals\n\t// {{{\n\tassign\twatchbus = 32'h0;\n\tassign\twatchdog = 32'h0;\n\tassign\ttimer_a = 32'h0;\n\tassign\ttimer_b = 32'h0;\n\tassign\ttimer_c = 32'h0;\n\tassign\tjiffies = 32'h0;\n\tassign\twdbus_data = 32'h0;\n\tassign\tpic_data = 32'h0;\n\tassign\tutc_data = 32'h0;\n\tassign\tuoc_data = 32'h0;\n\tassign\tupc_data = 32'h0;\n\tassign\tuic_data = 32'h0;\n\tassign\tmtc_data = 32'h0;\n\tassign\tmoc_data = 32'h0;\n\tassign\tmpc_data = 32'h0;\n\tassign\tmic_data = 32'h0;\n\t//\n\tassign\tint_state = 16'h0;\n\tassign\talt_int_state = 16'h0;\n\tassign\twb_cyc_gbl = thecpu.mem_cyc_gbl;\n\tassign\twb_stb_gbl = thecpu.mem_stb_gbl;\n\tassign\twb_cyc_lcl = thecpu.mem_cyc_lcl;\n\tassign\twb_stb_lcl = thecpu.mem_stb_lcl;\n\tassign\tmem_stb_gbl = thecpu.mem_stb_gbl;\n\tassign\tmem_stb_lcl = thecpu.mem_stb_lcl;\n\tassign\tmem_we     = thecpu.mem_we;\n\tassign\tmem_ack    = thecpu.mem_ack;\n\tassign\tmem_stall  = thecpu.mem_stall;\n\tassign\tmem_data   = thecpu.mem_data;\n\tassign\tmem_addr   = { thecpu.core.o_mem_addr };\n\tassign\tmem_result = thecpu.mem_result;\n\tassign\tswitch_to_interrupt = thecpu.core.w_switch_to_interrupt;\n\tassign\trelease_from_interrupt = thecpu.core.w_release_from_interrupt;\n\tassign\tbreak_en = thecpu.core.break_en;\n\t// }}}\n`endif\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, dbg_cyc, cpu_lcl_stb, cpu_op_stall,\n\t\t\tcpu_dbg_cc[2], cpu_pf_stall, cpu_i_count };\n\t// verilator lint_on  UNUSED\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "localparam F_LGDEPTH = 3;",
            "reg [F_LGDEPTH-1:0]\tfwb_nreqs, fwb_nacks, fwb_outstanding;",
            "wire cpu_dbg_we;\n\n\tassign cpu_dbg_we = (dbg_stb && !dbg_stall && dbg_we\n\t\t\t\t\t&&(dbg_addr[5] == DBG_ADDR_CPU));\n\n\tfwb_slave #(\n\t\t.AW(6), .DW(DBG_WIDTH), .F_LGDEPTH(F_LGDEPTH)\n\t) fwb(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_wb_cyc(i_dbg_cyc), .i_wb_stb(i_dbg_stb && !o_dbg_stall),\n\t\t.i_wb_we(i_dbg_we), .i_wb_addr(i_dbg_addr),\n\t\t.i_wb_data(i_dbg_data),\n\t\t.i_wb_ack(o_dbg_ack), .i_wb_stall(o_dbg_stall),\n\t\t.i_wb_idata(o_dbg_data), .i_wb_err(1'b0),\n\t\t.f_nreqs(fwb_nreqs), .f_nacks(fwb_nacks),\n\t\t.f_outstanding(fwb_outstanding)\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (i_dbg_cyc)\n\tbegin\n\t\tif (cmd_read_ack > 0)\n\t\tbegin\n\t\t\tassert(!dbg_pre_ack);\n\t\t\tassert(fwb_outstanding == 1 + (o_dbg_ack ? 1:0));\n\t\tend else\n\t\t\tassert(fwb_outstanding == dbg_pre_ack + o_dbg_ack);\n\tend\n\n\talways @(posedge i_clk)\n\tif ($past(i_dbg_cyc && cpu_dbg_we))\n\t\tassume(i_dbg_cyc);\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipaxi.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipaxi.v",
        "chunks": [
            "module holding the core of the Zip CPU\n//\t\ttogether--this one with AXI4 instruction and data interfaces,\n//\tand an AXI-lite debug interfaces.  In general, the Zip CPU is designed\n//\tto be as simple as possible.  (actual implementation aside ...)  The\n//\tinstruction set is about as RISC as you can get, with only 26\n//\tinstruction types currently supported.  (There are still 8-instruction\n//\tOp-Codes reserved for floating point, and 5 which can be used for\n//\ttransactions not requiring",
            "reg isters.) Please see the accompanying\n//\tspec.pdf file for a description of these instructions.\n//\n//\tThis version is bus width agnostic for both instruction and data buses,\n//\talthough the debug bus must still be 32-bits.  Instruction and data\n//\tbuses must be at least 32-bits wide.\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module zipaxi #(\n\t\t// {{{",
            "parameter C_DBG_ADDR_WIDTH = 8,",
            "localparam C_DBG_DATA_WIDTH = 32,",
            "localparam DBGLSB = $clog2(C_DBG_DATA_WIDTH/8),",
            "parameter ADDRESS_WIDTH = 32,",
            "parameter C_AXI_DATA_WIDTH = 32,",
            "parameter C_AXI_ID_WIDTH = 1,",
            "parameter INSN_ID = 0,",
            "parameter DATA_ID = 0,",
            "localparam AXILSB = $clog2(C_AXI_DATA_WIDTH/8),",
            "parameter OPT_LGICACHE = 0,",
            "parameter OPT_LGDCACHE = 0,",
            "parameter [0:0]\tOPT_PIPELINED = (OPT_LGICACHE>0),",
            "parameter [ADDRESS_WIDTH-1:0] RESET_ADDRESS={(ADDRESS_WIDTH){1'b0}},",
            "parameter [0:0]\tSTART_HALTED = 1'b0,",
            "parameter [0:0]\tOPT_WRAP   = 1'b1,",
            "parameter [0:0]\tSWAP_WSTRB = 1'b1,",
            "parameter OPT_MPY    = 3,",
            "parameter [0:0]\tOPT_DIV    = 1'b1,",
            "parameter [0:0]\tOPT_SHIFTS = 1'b1,",
            "parameter [0:0]\tOPT_LOCK   = 1'b1,",
            "parameter [0:0]\tOPT_FPU = 0,",
            "parameter [0:0]\tOPT_EARLY_BRANCHING = 1,",
            "parameter [0:0]\tOPT_CIS = 1'b1,",
            "parameter [0:0]\tOPT_LOWPOWER   = 1'b0,",
            "parameter [0:0]\tOPT_DISTRIBUTED_REGS = 1'b1,",
            "parameter [0:0]\tOPT_DBGPORT    = START_HALTED,",
            "parameter [0:0]\tOPT_TRACE_PORT = 1'b0,",
            "parameter [0:0]\tOPT_PROFILER   = 1'b0,",
            "parameter [0:0]\tOPT_USERMODE   = 1'b1,",
            "parameter LGILINESZ= 3,",
            "parameter OPT_LGDLINESZ = 3,",
            "parameter RESET_DURATION = 10,\n\t\t//",
            "localparam [0:0]\tWITH_LOCAL_BUS = 1'b0,",
            "localparam AW=ADDRESS_WIDTH-2,\n`ifdef\tVERILATOR",
            "parameter [0:0]\tOPT_SIM = 1'b1,",
            "parameter [0:0]\tOPT_CLKGATE = OPT_LOWPOWER\n`else",
            "parameter [0:0]\tOPT_SIM = 1'b0,",
            "parameter [0:0]\tOPT_CLKGATE = 1'b0\n`endif\n`ifdef\tFORMAL\n\t\t,",
            "parameter F_LGDEPTH=8\n`endif\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK, S_AXI_ARESETN,\n\t\t\t\t\ti_interrupt, i_cpu_reset,\n\t\t// Debug interface\n\t\t// {{{\n\t\t// Debug interface --",
            "input s\n//",
            "input ",
            "wire i_halt, i_clear_cache,\n//",
            "input ",
            "wire [4:0]\ti_dbg_w",
            "reg ,\n//",
            "input ",
            "wire i_dbg_we,\n//",
            "input ",
            "wire [31:0]\ti_dbg_data,\n//",
            "input ",
            "wire [4:0]\ti_dbg_r",
            "reg ,\n\t\t// Debug interface --",
            "output s\n//",
            "output ",
            "wire cpu_dbg_stall,\n//",
            "output ",
            "reg [31:0]\to_dbg_",
            "reg ,\n//",
            "output ",
            "reg [2:0]\to_dbg_cc,\n//",
            "output ",
            "wire o_break,",
            "input ",
            "wire S_DBG_AWVALID,",
            "output ",
            "wire S_DBG_AWREADY,",
            "input ",
            "wire [C_DBG_ADDR_WIDTH-1:0]\tS_DBG_AWADDR,\n\t\t// Verilator coverage_off",
            "input ",
            "wire [2:0]\tS_DBG_AWPROT,\n\t\t// Verilator coverage_on\n\t\t//",
            "input ",
            "wire S_DBG_WVALID,",
            "output ",
            "wire S_DBG_WREADY,",
            "input ",
            "wire [31:0]\tS_DBG_WDATA,",
            "input ",
            "wire [3:0]\tS_DBG_WSTRB,\n\t\t//",
            "output ",
            "reg S_DBG_BVALID,",
            "input ",
            "wire S_DBG_BREADY,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [1:0]\tS_DBG_BRESP,\n\t\t// Verilator coverage_on\n\t\t//",
            "input ",
            "wire S_DBG_ARVALID,",
            "output ",
            "wire S_DBG_ARREADY,",
            "input ",
            "wire [7:0]\tS_DBG_ARADDR,\n\t\t// Verilator coverage_off",
            "input ",
            "wire [2:0]\tS_DBG_ARPROT,\n\t\t// Verilator coverage_on\n\t\t//",
            "output ",
            "reg S_DBG_RVALID,",
            "input ",
            "wire S_DBG_RREADY,",
            "output ",
            "reg [31:0]\tS_DBG_RDATA,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [1:0]\tS_DBG_RRESP,\n\t\t// Verilator coverage_on\n\t\t//\n\t\t// }}}\n\t\t// Instruction bus (master)\n\t\t// {{{\n\t\t// Verilator coverage_off",
            "output ",
            "wire M_INSN_AWVALID,",
            "input ",
            "wire M_INSN_AWREADY,",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_INSN_AWID,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0]\tM_INSN_AWADDR,",
            "output ",
            "wire [7:0]\t\t\tM_INSN_AWLEN,",
            "output ",
            "wire [2:0]\t\t\tM_INSN_AWSIZE,",
            "output ",
            "wire [1:0]\t\t\tM_INSN_AWBURST,",
            "output ",
            "wire M_INSN_AWLOCK,",
            "output ",
            "wire [3:0]\t\t\tM_INSN_AWCACHE,",
            "output ",
            "wire [2:0]\t\t\tM_INSN_AWPROT,",
            "output ",
            "wire [3:0]\t\t\tM_INSN_AWQOS,\n\t\t//",
            "output ",
            "wire M_INSN_WVALID,",
            "input ",
            "wire M_INSN_WREADY,",
            "output ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_INSN_WDATA,",
            "output ",
            "wire [C_AXI_DATA_WIDTH/8-1:0]\tM_INSN_WSTRB,",
            "output ",
            "wire M_INSN_WLAST,\n\t\t//",
            "input ",
            "wire M_INSN_BVALID,",
            "output ",
            "wire M_INSN_BREADY,",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_INSN_BID,",
            "input ",
            "wire [1:0]\t\t\tM_INSN_BRESP,\n\t\t// Verilator coverage_on\n\t\t//",
            "output ",
            "wire M_INSN_ARVALID,",
            "input ",
            "wire M_INSN_ARREADY,",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_INSN_ARID,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0]\tM_INSN_ARADDR,",
            "output ",
            "wire [7:0]\t\t\tM_INSN_ARLEN,",
            "output ",
            "wire [2:0]\t\t\tM_INSN_ARSIZE,",
            "output ",
            "wire [1:0]\t\t\tM_INSN_ARBURST,",
            "output ",
            "wire M_INSN_ARLOCK,",
            "output ",
            "wire [3:0]\t\t\tM_INSN_ARCACHE,",
            "output ",
            "wire [2:0]\t\t\tM_INSN_ARPROT,",
            "output ",
            "wire [3:0]\t\t\tM_INSN_ARQOS,\n\t\t//",
            "input ",
            "wire M_INSN_RVALID,",
            "output ",
            "wire M_INSN_RREADY,",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_INSN_RID,",
            "input ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_INSN_RDATA,",
            "input ",
            "wire M_INSN_RLAST,",
            "input ",
            "wire [1:0]\t\t\tM_INSN_RRESP,\n\t\t// }}}\n\t\t// Data bus (master)\n\t\t// {{{",
            "output ",
            "wire M_DATA_AWVALID,",
            "input ",
            "wire M_DATA_AWREADY,",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_DATA_AWID,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0]\tM_DATA_AWADDR,",
            "output ",
            "wire [7:0]\t\t\tM_DATA_AWLEN,",
            "output ",
            "wire [2:0]\t\t\tM_DATA_AWSIZE,",
            "output ",
            "wire [1:0]\t\t\tM_DATA_AWBURST,",
            "output ",
            "wire M_DATA_AWLOCK,",
            "output ",
            "wire [3:0]\t\t\tM_DATA_AWCACHE,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [2:0]\t\t\tM_DATA_AWPROT,\n\t\t// Verilator coverage_on",
            "output ",
            "wire [3:0]\t\t\tM_DATA_AWQOS,\n\t\t//",
            "output ",
            "wire M_DATA_WVALID,",
            "input ",
            "wire M_DATA_WREADY,",
            "output ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_DATA_WDATA,",
            "output ",
            "wire [C_AXI_DATA_WIDTH/8-1:0]\tM_DATA_WSTRB,",
            "output ",
            "wire M_DATA_WLAST,\n\t\t//",
            "input ",
            "wire M_DATA_BVALID,",
            "output ",
            "wire M_DATA_BREADY,",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_DATA_BID,",
            "input ",
            "wire [1:0]\t\t\tM_DATA_BRESP,\n\t\t//",
            "output ",
            "wire M_DATA_ARVALID,",
            "input ",
            "wire M_DATA_ARREADY,",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_DATA_ARID,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0]\tM_DATA_ARADDR,",
            "output ",
            "wire [7:0]\t\t\tM_DATA_ARLEN,",
            "output ",
            "wire [2:0]\t\t\tM_DATA_ARSIZE,",
            "output ",
            "wire [1:0]\t\t\tM_DATA_ARBURST,",
            "output ",
            "wire M_DATA_ARLOCK,",
            "output ",
            "wire [3:0]\t\t\tM_DATA_ARCACHE,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [2:0]\t\t\tM_DATA_ARPROT,\n\t\t// Verilator coverage_on",
            "output ",
            "wire [3:0]\t\t\tM_DATA_ARQOS,\n\t\t//",
            "input ",
            "wire M_DATA_RVALID,",
            "output ",
            "wire M_DATA_RREADY,",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_DATA_RID,",
            "input ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_DATA_RDATA,",
            "input ",
            "wire M_DATA_RLAST,",
            "input ",
            "wire [1:0]\t\t\tM_DATA_RRESP,\n\t\t// }}}\n\t\t// Accounting",
            "output s ... to help us count stalls and usage",
            "output ",
            "wire o_cmd_reset,",
            "output ",
            "wire o_halted,",
            "output ",
            "wire o_gie,",
            "output ",
            "wire o_op_stall,",
            "output ",
            "wire o_pf_stall,",
            "output ",
            "wire o_i_count,\n\t\t//",
            "output ",
            "wire [31:0]\to_cpu_debug,\n\t\t//",
            "output ",
            "wire o_prof_stb,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0] o_prof_addr,",
            "output ",
            "wire [31:0]\to_prof_ticks\n\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam [0:0]\tDBG_ADDR_CTRL = 1'b0,\n\t\t\t\tDBG_ADDR_CPU  = 1'b1;",
            "localparam [0:0]\tOPT_PIPELINED_BUS_ACCESS = (OPT_PIPELINED)&&(OPT_LGDCACHE > 1);",
            "localparam [0:0]\tOPT_MEMPIPE = OPT_PIPELINED_BUS_ACCESS;",
            "localparam [0:0]\tOPT_DCACHE = (OPT_LGDCACHE > 4);",
            "localparam FETCH_LIMIT = (OPT_LGICACHE < 4) ? (1 << OPT_LGICACHE) : 16;\n\n\t// Debug bit allocations\n\t// {{{\n\t//\tDBGCTRL\n\t//\t\t 5 DBG Catch -- Catch exceptions/faults w/ debugger\n\t//\t\t 4 Clear cache\n\t//\t\t 3 RESET_FLAG\n\t//\t\t 2 STEP\t(W=1 steps, and returns to halted)\n\t//\t\t 1 HALT(ED)\n\t//\t\t 0 HALT\n\t//\tDBGDATA\n\t//\t\tread/writes internal",
            "reg isters\n\t//",
            "localparam HALT_BIT = 0,\n\t\t\tSTEP_BIT = 2,\n\t\t\tRESET_BIT = 3,\n\t\t\tCLEAR_CACHE_BIT = 4,\n\t\t\tCATCH_BIT = 5;\n\t// }}}",
            "localparam [0:0]\tOPT_ALIGNMENT_ERR = 1'b0;",
            "localparam [0:0]\tSWAP_ENDIANNESS = 1'b0;\n\n\t// AXI-lite signal handling\n\t// {{{",
            "wire awskd_valid, wskd_valid, arskd_valid;",
            "wire dbg_write_ready, dbg_read_ready;",
            "wire [C_DBG_ADDR_WIDTH-DBGLSB-1:0]\tawskd_addr, arskd_addr;",
            "wire [31:0]\twskd_data;",
            "wire [3:0]\twskd_strb;",
            "reg dbg_write_valid, dbg_read_valid;",
            "wire dbg_blkram_stall;",
            "reg [4:0]\tdbg_write_",
            "reg ;",
            "wire [4:0]\tdbg_read_",
            "reg ;",
            "reg [31:0]\tdbg_write_data;",
            "wire [31:0]\tdbg_read_data;",
            "wire cpu_dbg_stall, cpu_break, dbg_write_stall;",
            "wire [2:0]\tcpu_dbg_cc;\n\t// }}}",
            "wire reset_hold, halt_on_fault, dbg_catch;",
            "wire cpu_clken, cpu_clock, clk_gate;",
            "wire reset_request, release_request, halt_request, step_request,\n\t\tclear_cache_request;",
            "wire cpu_has_halted;\n\n\n\t// CPU control",
            "reg isters\n\t// {{{",
            "reg cmd_halt, cmd_reset, cmd_step, cmd_clear_cache;",
            "wire [31:0]\tcpu_status;",
            "wire dbg_cmd_write, dbg_cpu_write;",
            "wire [31:0]\tdbg_cmd_data;",
            "wire [3:0]\tdbg_cmd_strb;\n\t// }}}\n\n\t// Fetch\n\t// {{{",
            "wire pf_new_pc, clear_icache, pf_ready;",
            "wire [AW+1:0]\tpf_request_address;",
            "wire [31:0]\tpf_instruction;",
            "wire [AW+1:0]\tpf_instruction_pc;",
            "wire pf_valid, pf_illegal;\n\t// }}}\n\t// Memory\n\t// {{{",
            "wire clear_dcache, mem_ce, bus_lock;",
            "wire [2:0]\tmem_op;",
            "wire [31:0]\tmem_cpu_addr;",
            "wire [AW+1:0]\tmem_lock_pc;",
            "wire [31:0]\tmem_wdata;",
            "wire [4:0]\tmem_",
            "reg ;",
            "wire mem_busy, mem_rdbusy, mem_pipe_stalled, mem_valid,\n\t\t\tmem_bus_err;",
            "wire [4:0]\tmem_w",
            "reg ;",
            "wire [31:0]\tmem_result;\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Debug signal handling\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Write signaling\n\t// {{{\n\tskidbuffer #(\n\t\t// {{{\n\t\t.OPT_OUTREG(0),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.DW(C_DBG_ADDR_WIDTH-DBGLSB)\n\t\t// }}}\n\t) dbgawskd(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t.i_valid(S_DBG_AWVALID),\n\t\t.o_ready(S_DBG_AWREADY),\n\t\t.i_data(S_DBG_AWADDR[C_DBG_ADDR_WIDTH-1:DBGLSB]),\n\t\t.o_valid(awskd_valid), .i_ready(dbg_write_ready),\n\t\t\t.o_data(awskd_addr)\n\t\t// }}}\n\t);\n\n\tskidbuffer #(\n\t\t// {{{\n\t\t.OPT_OUTREG(0),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.DW(C_DBG_DATA_WIDTH+C_DBG_DATA_WIDTH/8)\n\t\t// }}}\n\t) dbgwskd(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t.i_valid(S_DBG_WVALID),\n\t\t.o_ready(S_DBG_WREADY),\n\t\t.i_data({ S_DBG_WSTRB, S_DBG_WDATA }),\n\t\t.o_valid(wskd_valid), .i_ready(dbg_write_ready),\n\t\t\t.o_data({ wskd_strb, wskd_data })\n\t\t// }}}\n\t);\n\n\tassign\tdbg_write_ready = awskd_valid && wskd_valid\n\t\t\t&& ((wskd_strb==0) || awskd_addr[5] != DBG_ADDR_CPU\n\t\t\t   || !dbg_write_stall)\n\t\t\t&& (!S_DBG_BVALID || S_DBG_BREADY);\n\n\t// dbg_write_valid\n\t// {{{\n\tinitial\tdbg_write_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || !OPT_DBGPORT)\n\t\tdbg_write_valid <= 1'b0;\n\telse if (!dbg_write_stall)\n\t\tdbg_write_valid <= dbg_cpu_write;\n\t// }}}\n\n\t// dbg_write_",
            "reg // {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!dbg_write_stall)\n\tbegin\n\t\tdbg_write_",
            "reg <= awskd_addr[4:0];\n\t\tif (OPT_LOWPOWER && !dbg_cpu_write)\n\t\t\tdbg_write_",
            "reg <= 0;\n\tend\n\t// }}}\n\n\t// dbg_write_data\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!dbg_write_stall)\n\tbegin\n\t\tdbg_write_data <= wskd_data;\n\t\tif (OPT_LOWPOWER && !dbg_cpu_write)\n\t\t\tdbg_write_data <= 0;\n\tend\n\t// }}}\n\n\t// S_DBG_BVALID\n\t//  {{{\n\tinitial\tS_DBG_BVALID = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tS_DBG_BVALID <= 1'b0;\n\telse if (dbg_write_ready)\n\t\tS_DBG_BVALID <= 1'b1;\n\telse if (S_DBG_BREADY)\n\t\tS_DBG_BVALID <= 1'b0;\n\t// }}}\n\n\t// S_DBG_BRESP\n\t// {{{\n\tassign\tS_DBG_BRESP = 2'b00;\n\t// }}}\n\n\t// }}}\n\n\t//\n\t// Read signaling\n\t// {{{\n\n\tskidbuffer #(\n\t\t// {{{\n\t\t.OPT_OUTREG(0),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.DW(C_DBG_ADDR_WIDTH-DBGLSB)\n\t\t// }}}\n\t) dbgarskd(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t.i_valid(S_DBG_ARVALID),\n\t\t.o_ready(S_DBG_ARREADY),\n\t\t.i_data(S_DBG_ARADDR[C_DBG_ADDR_WIDTH-1:DBGLSB]),\n\t\t.o_valid(arskd_valid), .i_ready(dbg_read_ready),\n\t\t\t.o_data(arskd_addr)\n\t\t// }}}\n\t);\n\n\tassign\tdbg_read_ready = arskd_valid && !dbg_blkram_stall\n\t\t\t\t&& (!S_DBG_RVALID || S_DBG_RREADY);\n\n\tassign\tdbg_read_",
            "reg = (OPT_LOWPOWER && !dbg_read_ready)\n\t\t\t\t\t? 5'h0 : arskd_addr[4:0];\n\n\t// dbg_read_valid",
            "reg [1:0]\tr_blkram_stall;\n\n\tinitial\tr_blkram_stall = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || !OPT_DBGPORT)\n\t\tr_blkram_stall <= 0;\n\telse if (dbg_read_ready && arskd_addr[5] == DBG_ADDR_CPU)\n\t\tr_blkram_stall <= 2 + (OPT_DISTRIBUTED_REGS ? 0:1);\n\telse if (r_blkram_stall > 0)\n\t\tr_blkram_stall <= r_blkram_stall - 1;\n\t// {{{\n\tinitial\tdbg_read_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || !OPT_DBGPORT)\n\t\tdbg_read_valid <= 0;\n\telse\n\t\tdbg_read_valid <= (r_blkram_stall == 1);\n\n\tassign\tdbg_blkram_stall = (r_blkram_stall != 0);\n`ifdef\tFORMAL\n\talways @(*)\n\tif (S_AXI_ARESETN && (dbg_read_valid || dbg_blkram_stall))\n\t\tassert(!S_DBG_RVALID);\n`endif\n\t// }}}\n\n\t// S_DBG_RVALID\n\t// {{{\n\tinitial\tS_DBG_RVALID = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tS_DBG_RVALID <= 0;\n\telse if (!S_DBG_RVALID || S_DBG_RREADY)\n\t\tS_DBG_RVALID <= (dbg_read_ready\n\t\t\t  && (!OPT_DBGPORT || arskd_addr[5] == DBG_ADDR_CTRL))\n\t\t\t|| dbg_read_valid;\n\t// }}}\n\n\t// S_DBG_RDATA\n\t// {{{\n\tinitial\tS_DBG_RDATA = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\tS_DBG_RDATA <= 0;\n\telse if (!S_DBG_RVALID || S_DBG_RREADY)\n\tbegin\n\t\t// {{{\n\t\tif (OPT_DBGPORT && dbg_read_valid)\n\t\t\tS_DBG_RDATA <= dbg_read_data;\n\t\telse\n\t\t\tS_DBG_RDATA <= cpu_status;\n\n\t\tif (OPT_LOWPOWER && (!OPT_DBGPORT || !dbg_read_valid)\n\t\t\t\t\t\t&& !dbg_read_ready)\n\t\t\tS_DBG_RDATA <= 0;\n\t\t// }}}\n\tend\n\t// }}}\n\n\tassign\tS_DBG_RRESP = 2'b00;\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Reset, halt, clear-cache, and step controls\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tassign\tdbg_cpu_write = OPT_DBGPORT && dbg_write_ready\n\t\t\t\t&& awskd_addr[5] == DBG_ADDR_CPU\n\t\t\t\t&& wskd_strb == 4'hf;\n\tassign\tdbg_cmd_write = dbg_write_ready && awskd_addr[5] == DBG_ADDR_CTRL;\n\tassign\tdbg_cmd_data = wskd_data;\n\tassign\tdbg_cmd_strb = wskd_strb;\n\n\tassign\treset_request = dbg_cmd_write && dbg_cmd_strb[RESET_BIT/8]\n\t\t\t\t\t\t&& dbg_cmd_data[RESET_BIT];\n\tassign\trelease_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8]\n\t\t\t\t\t\t&& !dbg_cmd_data[HALT_BIT];\n\tassign\thalt_request = dbg_cmd_write && dbg_cmd_strb[HALT_BIT/8]\n\t\t\t\t\t\t&& dbg_cmd_data[HALT_BIT];\n\tassign\tstep_request = dbg_cmd_write && dbg_cmd_strb[STEP_BIT/8]\n\t\t\t\t\t\t&& dbg_cmd_data[STEP_BIT];\n\tassign\tclear_cache_request = dbg_cmd_write\n\t\t\t\t\t&& dbg_cmd_strb[CLEAR_CACHE_BIT/8]\n\t\t\t\t\t&& dbg_cmd_data[CLEAR_CACHE_BIT];\n\n\t//\n\t// reset_hold: Always start us off with an initial reset\n\t// {{{\n\tgenerate if (RESET_DURATION > 0)\n\tbegin : INITIAL_RESET_HOLD\n\t\t// {{{",
            "reg [$clog2(RESET_DURATION)-1:0]\treset_counter;",
            "reg r_reset_hold;\n\n\t\tinitial\treset_counter = RESET_DURATION;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || i_cpu_reset)\n\t\t\treset_counter <= RESET_DURATION;\n\t\telse if (reset_counter > 0)\n\t\t\treset_counter <= reset_counter - 1;\n\n\t\tinitial\tr_reset_hold = 1;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || i_cpu_reset)\n\t\t\tr_reset_hold <= 1;\n\t\telse\n\t\t\tr_reset_hold <= (reset_counter > 1);\n\n\t\tassign\treset_hold = r_reset_hold;\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\t\tassert(reset_hold == (reset_counter != 0));\n`endif\n\t\t// }}}\n\tend else begin : NO_RESET_HOLD\n\n\t\tassign reset_hold = 0;\n\n\tend endgenerate\n\t// }}}\n\n\tassign\thalt_on_fault = dbg_catch;\n\n\t// cmd_reset\n\t// {{{\n\t// Always start us off with an initial reset\n\tinitial\tcmd_reset = 1'b1;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || i_cpu_reset)\n\t\tcmd_reset <= 1'b1;\n\telse if (reset_hold)\n\t\tcmd_reset <= 1'b1;\n\telse if (cpu_break && !halt_on_fault)\n\t\tcmd_reset <= 1'b1;\n\telse\n\t\tcmd_reset <= reset_request;\n\t// }}}\n\n\t// cmd_halt\n\t// {{{\n\tinitial\tcmd_halt  = START_HALTED;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tcmd_halt <= START_HALTED;\n\telse if (i_cpu_reset && !dbg_write_ready && !dbg_write_stall)\n\t\tcmd_halt <= START_HALTED;\n\telse if (cmd_reset && START_HALTED)\n\t\tcmd_halt <= START_HALTED;\n\telse begin\n\t\t// {{{\n\t\t// When shall we release from a halt?  Only if we have\n\t\t// come to a full and complete stop.  Even then, we only\n\t\t// release if we aren't being given a command to step the CPU.\n\t\t//\n\t\tif (!dbg_write_valid && cpu_has_halted && dbg_cmd_write\n\t\t\t\t&& (release_request || step_request))\n\t\t\tcmd_halt <= 1'b0;\n\n\t\t// Reasons to halt\n\n\t\t// 1. Halt on any unhandled CPU exception.  The cause of the\n\t\t//\texception must be cured before we can (re)start.\n\t\t//\tIf the CPU is configured to start immediately on power\n\t\t//\tup, we leave it to reset on any exception instead.\n\t\tif (cpu_break && halt_on_fault)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 2. Halt on any user request to halt.  (Only valid if the\n\t\t//\tSTEP bit isn't also set)\n\t\tif (dbg_cmd_write && halt_request && !step_request)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 3. Halt on any user request to write to a CPU",
            "reg ister\n\t\tif (dbg_cpu_write)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 4. Halt following any step command\n\t\tif (cmd_step && !step_request)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 5. Halt following any clear cache\n\t\tif (cmd_clear_cache)\n\t\t\tcmd_halt <= 1'b1;\n\n\t\t// 6. Halt on any clear cache bit--independent of any step bit\n\t\tif (clear_cache_request)\n\t\t\tcmd_halt <= 1'b1;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// cmd_clear_cache\n\t// {{{\n\tinitial\tcmd_clear_cache = 1'b0;\n\talways @(posedge  S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || cmd_reset)\n\t\tcmd_clear_cache <= 1'b0;\n\telse if (dbg_cmd_write && clear_cache_request && halt_request)\n\t\tcmd_clear_cache <= 1'b1;\n\telse if (cmd_halt && !cpu_dbg_stall)\n\t\tcmd_clear_cache <= 1'b0;\n\t// }}}\n\n\t// cmd_step\n\t// {{{\n\tinitial\tcmd_step = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || i_cpu_reset)\n\t\tcmd_step <= 1'b0;\n\telse if (cmd_reset || cpu_break\n\t\t\t|| reset_request\n\t\t\t|| clear_cache_request || cmd_clear_cache\n\t\t\t|| halt_request || dbg_cpu_write)\n\t\tcmd_step <= 1'b0;\n\telse if (!dbg_write_valid && cpu_has_halted && step_request)\n\t\tcmd_step <= 1'b1;\n\telse // if (cpu_dbg_stall)\n\t\tcmd_step <= 1'b0;\n`ifdef\tFORMAL\n\t// While STEP is true, we can't halt\n\talways @(*)\n\tif (S_AXI_ARESETN && cmd_step)\n\t\tassert(!cmd_halt);\n`endif\n\t// }}}\n\n\t// dbg_catch\n\t// {{{\n\tgenerate if (!OPT_DBGPORT)\n\tbegin : NO_DBG_CATCH\n\t\tassign\tdbg_catch = START_HALTED;\n\tend else begin : GEN_DBG_CATCH",
            "reg r_dbg_catch;\n\n\t\tinitial\tr_dbg_catch = START_HALTED;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_dbg_catch <= START_HALTED;\n\t\telse if (dbg_cmd_write && dbg_cmd_strb[CATCH_BIT/8])\n\t\t\tr_dbg_catch <= dbg_cmd_data[CATCH_BIT];\n\n\t\tassign\tdbg_catch = r_dbg_catch;\n\tend endgenerate\n\t// }}}\n\n\t// cpu_status\n\t// {{{\n\t//\t0xffff_f000 -> (Unused / reserved)\n\t//\n\t//\t0x0000_0800 -> cpu_break\n\t//\t0x0000_0400 -> Interrupt pending\n\t//\t0x0000_0200 -> User mode\n\t//\t0x0000_0100 -> Sleep (CPU is sleeping)\n\t//\n\t//\t0x0000_00c0 -> (Unused/reserved)\n\t//\t0x0000_0020 -> dbg_catch\n\t//\t0x0000_0010 -> cmd_clear_cache\n\t//\n\t//\t0x0000_0008 -> Reset\n\t//\t0x0000_0004 -> Step (auto clearing, write only)\n\t//\t0x0000_0002 -> Halt (status)\n\t//\t0x0000_0001 -> Halt (request)\n\tassign\tcpu_status = { 16'h0, 4'h0,\n\t\t\tcpu_break, i_interrupt, cpu_dbg_cc[1:0],\n\t\t\t2'h0, dbg_catch, 1'b0,\n\t\t\tcmd_reset, 1'b0, !cpu_dbg_stall, cmd_halt\n\t\t};\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The ZipCPU Core\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n`ifdef\tFORMAL\n\t// {{{\n\t(* anyseq *)",
            "reg f_cpu_halted, f_cpu_data, f_cpu_stall,\n\t\t\t\tf_cpu_break;\n\t(* anyseq *)",
            "reg [2:0]\tf_cpu_dbg_cc;\n\t(* anyseq *)",
            "reg [2:0]\tf_cpu_dbg_read_data;\n\n\tassign\tcpu_dbg_stall = f_cpu_stall && !f_cpu_halted;\n\tassign\tcpu_break\t= f_cpu_break;\n\tassign\tcpu_dbg_cc\t= f_cpu_dbg_cc;\n\tassign\tdbg_read_data\t= f_cpu_dbg_read_data;\n\n\tfdebug #(\n\t\t// {{{\n\t\t.OPT_START_HALTED(START_HALTED),\n\t\t.OPT_DISTRIBUTED_RAM(OPT_DISTRIBUTED_REGS)\n\t\t// }}}\n\t) fdbg (\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK),\n\t\t.i_reset(!S_AXI_ARESETN),\n\t\t.i_cpu_reset(cmd_reset || i_cpu_reset),\n\t\t.i_halt(cmd_halt),\n\t\t.i_halted(f_cpu_halted),\n\t\t.i_clear_cache(cmd_clear_cache),\n\t\t.i_dbg_we(dbg_write_valid),\n\t\t.i_dbg_",
            "reg (dbg_write_",
            "reg ),\n\t\t.i_dbg_data(dbg_write_data),\n\t\t.i_dbg_stall(cpu_dbg_stall),\n\t\t.i_dbg_break(cpu_break),\n\t\t.i_dbg_cc(cpu_dbg_cc)\n\t\t// }}}\n\t);\n\t// }}}\n`else\n\tzipcore #(\n\t\t// {{{\n\t\t.RESET_ADDRESS({ {(32-ADDRESS_WIDTH){1'b0}}, RESET_ADDRESS }),\n\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH-2),\n\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t.OPT_DCACHE(OPT_DCACHE),\n\t\t.OPT_MPY(OPT_MPY),\n\t\t.OPT_DIV(OPT_DIV),\n\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t.IMPLEMENT_FPU(OPT_FPU),\n\t\t.OPT_CIS(OPT_CIS),\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.OPT_START_HALTED(START_HALTED),\n\t\t.OPT_SIM(OPT_SIM),\n\t\t.OPT_PIPELINED_BUS_ACCESS(OPT_MEMPIPE),\n\t\t//",
            "localparam [0:0]\tOPT_MEMPIPE = OPT_PIPELINED_BUS_ACCESS;\n\t\t.OPT_DBGPORT(OPT_DBGPORT),\n\t\t.OPT_TRACE_PORT(OPT_TRACE_PORT),\n\t\t.OPT_PROFILER(OPT_PROFILER),\n\t\t//",
            "localparam [0:0]\tOPT_LOCK=(IMPLEMENT_LOCK)&&(OPT_PIPELINED);\n\t\t//",
            "parameter [0:0]\tWITH_LOCAL_BUS = 1'b1;\n\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t.OPT_USERMODE(OPT_USERMODE)\n`ifdef\tFORMAL\n\t\t, .F_LGDEPTH(F_LGDEPTH)\n`endif\n\t\t// }}}\n\t) core (\n\t\t// {{{\n\t\t.i_clk(cpu_clock), .i_reset(cmd_reset),\n\t\t\t.i_interrupt(i_interrupt),\n\t\t.o_clken(cpu_clken),\n\t\t// Debug interface\n\t\t// {{{\n\t\t.i_halt(cmd_halt), .i_clear_cache(cmd_clear_cache),\n\t\t\t.i_dbg_w",
            "reg (dbg_write_",
            "reg ), .i_dbg_we(dbg_write_valid),\n\t\t\t.i_dbg_data(dbg_write_data),.i_dbg_r",
            "reg (dbg_read_",
            "reg ),\n\t\t\t.o_dbg_stall(cpu_dbg_stall),.o_dbg_",
            "reg (dbg_read_data),\n\t\t\t.o_dbg_cc(cpu_dbg_cc), .o_break(cpu_break),\n\t\t// }}}\n\t\t// Instruction fetch interface\n\t\t// {{{\n\t\t.o_pf_new_pc(pf_new_pc), .o_clear_icache(clear_icache),\n\t\t\t.o_pf_ready(pf_ready),\n\t\t\t.o_pf_request_address(pf_request_address),\n\t\t.i_pf_valid(pf_valid),\n\t\t\t.i_pf_illegal(pf_illegal),\n\t\t\t.i_pf_instruction(pf_instruction),\n\t\t\t.i_pf_instruction_pc(pf_instruction_pc),\n\t\t// }}}\n\t\t// Memory unit interface\n\t\t// {{{\n\t\t.o_clear_dcache(clear_dcache), .o_mem_ce(mem_ce),\n\t\t\t.o_bus_lock(bus_lock),\n\t\t\t.o_mem_op(mem_op), .o_mem_addr(mem_cpu_addr),\n\t\t\t.o_mem_data(mem_wdata),\n\t\t\t.o_mem_lock_pc(mem_lock_pc),\n\t\t\t.o_mem_",
            "reg (mem_",
            "reg ),\n\t\t\t.i_mem_busy(mem_busy),\n\t\t\t.i_mem_rdbusy(mem_rdbusy),\n\t\t\t.i_mem_pipe_stalled(mem_pipe_stalled),\n\t\t.i_mem_valid(mem_valid),\n\t\t\t.i_bus_err(mem_bus_err),\n\t\t\t.i_mem_w",
            "reg (mem_w",
            "reg ),\n\t\t\t.i_mem_result(mem_result),\n\t\t// }}}\n\t\t// Accounting/CPU usage interface\n\t\t.o_op_stall(o_op_stall), .o_pf_stall(o_pf_stall),\n\t\t.o_i_count(o_i_count),\n\t\t//\n\t\t.o_debug(o_cpu_debug),\n\t\t//\n\t\t.o_prof_stb(  o_prof_stb),\n\t\t.o_prof_addr( o_prof_addr),\n\t\t.o_prof_ticks(o_prof_ticks)\n\t\t// }}}\n\t);\n`endif\n\tassign\to_cmd_reset\t= cmd_reset;\n\tassign\to_gie\t\t= cpu_dbg_cc[1];\n\tassign\tdbg_write_stall\t= dbg_write_valid && cpu_dbg_stall;\n\tassign\tcpu_has_halted  = !cpu_dbg_stall;\n\tassign\to_halted\t= cpu_has_halted;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Instruction Fetch\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\n`ifndef\tFORMAL\n\tgenerate if (OPT_LGICACHE > 4)\n\tbegin : INSN_CACHE\n\n\t\taxiicache #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),\n\t\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH),\n\t\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t\t.AXI_ID(INSN_ID),\n\t\t\t.LGCACHESZ(OPT_LGICACHE),\n\t\t\t.LGLINESZ(LGILINESZ),\n\t\t\t.OPT_WRAP(OPT_WRAP),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t// Instruction fetches don't need subword access,\n\t\t\t// so SWAPWSTRB doesn't make any sense here.\n\t\t\t// .SWAP_WSTRB(SWAP_WSTRB),\n\t\t\t.SWAP_ENDIANNESS(SWAP_ENDIANNESS)\n\t\t\t// }}}\n\t\t) pf (\n\t\t// {{{\n\t\t\t.S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN),\n\t\t\t// CPU signals\n\t\t\t// {{{\n\t\t\t.i_cpu_reset(cmd_reset),\n\t\t\t.i_new_pc(pf_new_pc),\n\t\t\t.i_clear_cache(clear_icache),\n\t\t\t.i_ready(pf_ready && clk_gate),\n\t\t\t.i_pc(pf_request_address),\n\t\t\t.o_insn(pf_instruction),\n\t\t\t.o_pc(pf_instruction_pc),\n\t\t\t.o_valid(pf_valid),\n\t\t\t.o_illegal(pf_illegal),\n\t\t\t// }}}\n\t\t\t// AXI4 (full) bus signals\n\t\t\t// {{{\n\t\t\t.M_AXI_ARVALID(M_INSN_ARVALID),\n\t\t\t.M_AXI_ARREADY(M_INSN_ARREADY),\n\t\t\t.M_AXI_ARID(   M_INSN_ARID),\n\t\t\t.M_AXI_ARADDR( M_INSN_ARADDR),\n\t\t\t.M_AXI_ARLEN(  M_INSN_ARLEN),\n\t\t\t.M_AXI_ARSIZE( M_INSN_ARSIZE),\n\t\t\t.M_AXI_ARBURST(M_INSN_ARBURST),\n\t\t\t.M_AXI_ARLOCK( M_INSN_ARLOCK),\n\t\t\t.M_AXI_ARCACHE(M_INSN_ARCACHE),\n\t\t\t.M_AXI_ARPROT( M_INSN_ARPROT),\n\t\t\t.M_AXI_ARQOS(  M_INSN_ARQOS),\n\t\t\t//\n\t\t\t.M_AXI_RVALID(M_INSN_RVALID),\n\t\t\t.M_AXI_RREADY(M_INSN_RREADY),\n\t\t\t.M_AXI_RID(   M_INSN_RID),\n\t\t\t.M_AXI_RDATA( M_INSN_RDATA),\n\t\t\t.M_AXI_RLAST( M_INSN_RLAST),\n\t\t\t.M_AXI_RRESP( M_INSN_RRESP)\n\t\t\t// }}}\n\t\t// }}}\n\t\t);\n\n\tend else begin : AXILFETCH\n\n\t\taxilfetch #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH),\n\t\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t\t.FETCH_LIMIT(FETCH_LIMIT),\n\t\t\t// .SWAP_WSTRB(SWAP_WSTRB),\n\t\t\t.SWAP_ENDIANNESS(SWAP_ENDIANNESS)\n\t\t\t// }}}\n\t\t) pf (\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN),\n\t\t\t// CPU signals\n\t\t\t// {{{\n\t\t\t.i_cpu_reset(cmd_reset),\n\t\t\t.i_new_pc(pf_new_pc),\n\t\t\t.i_clear_cache(clear_icache),\n\t\t\t.i_ready(pf_ready && clk_gate),\n\t\t\t.i_pc(pf_request_address),\n\t\t\t.o_insn(pf_instruction),\n\t\t\t.o_pc(pf_instruction_pc),\n\t\t\t.o_valid(pf_valid),\n\t\t\t.o_illegal(pf_illegal),\n\t\t\t// }}}\n\t\t\t// AXI-lite bus signals\n\t\t\t// {{{\n\t\t\t.M_AXI_ARVALID(M_INSN_ARVALID),\n\t\t\t.M_AXI_ARREADY(M_INSN_ARREADY),\n\t\t\t.M_AXI_ARADDR(M_INSN_ARADDR),\n\t\t\t.M_AXI_ARPROT(M_INSN_ARPROT),\n\t\t\t//\n\t\t\t.M_AXI_RVALID(M_INSN_RVALID),\n\t\t\t.M_AXI_RREADY(M_INSN_RREADY),\n\t\t\t.M_AXI_RDATA(M_INSN_RDATA),\n\t\t\t.M_AXI_RRESP(M_INSN_RRESP)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\tM_INSN_ARID = INSN_ID;\n\t\t// ARADDR\n\t\tassign\tM_INSN_ARLEN = 0;\n\t\tassign\tM_INSN_ARSIZE = AXILSB[2:0];\n\t\tassign\tM_INSN_ARBURST = 2'b01;\n\t\tassign\tM_INSN_ARLOCK  = 1'b0;\n\t\tassign\tM_INSN_ARCACHE = 4'h3;\n\t\t// PROT\n\t\tassign\tM_INSN_ARQOS   = 4'h0;\n\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_insn_axi;\n\t\tassign\tunused_insn_axi = &{ 1'b0, M_INSN_RID, M_INSN_RLAST };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\tend endgenerate\n`endif\n\n\t// Assign values to the (unused) M_INSN_* write ports\n\t// {{{\n\tassign\tM_INSN_AWVALID = 0;\n\tassign\tM_INSN_AWVALID = 0;\n\tassign\tM_INSN_AWID = INSN_ID;\n\tassign\tM_INSN_AWADDR  = 0;\n\tassign\tM_INSN_AWLEN   = 0;\n\tassign\tM_INSN_AWSIZE  = 0;\n\tassign\tM_INSN_AWBURST = 0;\n\tassign\tM_INSN_AWLOCK  = 0;\n\tassign\tM_INSN_AWCACHE = 0;\n\tassign\tM_INSN_AWPROT  = 0;\n\tassign\tM_INSN_AWQOS   = 0;\n\t//\n\tassign\tM_INSN_WVALID = 0;\n\tassign\tM_INSN_WDATA  = 0;\n\tassign\tM_INSN_WSTRB  = 0;\n\tassign\tM_INSN_WLAST  = 0;\n\t//\n\tassign\tM_INSN_BREADY = 1'b1;\n\t//\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Memory Unit\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n`ifndef\tFORMAL",
            "wire [C_AXI_DATA_WIDTH-1:0]\ti_bus_data, o_bus_data;",
            "wire [C_AXI_DATA_WIDTH/8-1:0]\to_bus_strb;\n\n\tgenerate if (SWAP_WSTRB && C_AXI_DATA_WIDTH > 32 && !OPT_DCACHE)\n\tbegin : SWAP_BUS_WORD_ORDER\n\t\tgenvar\tgk;\n\n\t\tfor(gk=0; gk<C_AXI_DATA_WIDTH/32; gk=gk+1)\n\t\tbegin\n\t\t\tassign\ti_bus_data[(C_AXI_DATA_WIDTH-32-gk*32) +: 32]\n\t\t\t\t\t\t= M_DATA_RDATA[gk*32 +: 32];\n\t\t\tassign\tM_DATA_WDATA[gk*32 +: 32]\n\t\t\t\t= o_bus_data[(C_AXI_DATA_WIDTH-32-gk*32) +: 32];\n\t\t\tassign\tM_DATA_WSTRB[gk* 4 +:  4]\n\t\t\t\t= o_bus_strb[(C_AXI_DATA_WIDTH/8-4-gk*4) +: 4];\n\t\tend\n\n\tend else begin : KEEP_BUS_WORD_ORDER\n\t\t// {{{\n\t\tassign\ti_bus_data = M_DATA_RDATA;\n\t\tassign\tM_DATA_WDATA = o_bus_data;\n\t\tassign\tM_DATA_WSTRB = o_bus_strb;\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate if (OPT_DCACHE)\n\tbegin : DATA_CACHE\n\n\t\taxidcache #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH),\n\t\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t\t.C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),\n\t\t\t.AXI_ID(DATA_ID),\n\t\t\t.LGCACHELEN(OPT_LGDCACHE),\n\t\t\t.LGNLINES(OPT_LGDCACHE-$clog2(C_AXI_DATA_WIDTH/8)-OPT_LGDLINESZ),\n\t\t\t// .SWAP_ENDIANNESS(SWAP_ENDIANNESS),\n\t\t\t.SWAP_WSTRB(SWAP_WSTRB),\n\t\t\t// .OPT_SIGN_EXTEND(OPT_SIGN_EXTEND),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t// .OPT_LOCAL_BUS(WITH_LOCAL_BUS),\n\t\t\t.OPT_WRAP(OPT_WRAP),\n\t\t\t.OPT_PIPE(OPT_MEMPIPE),\n\t\t\t.OPT_LOCK(OPT_LOCK)\n// `ifdef\tFORMAL\n\t\t\t// Used with OPT_PIPE, not yet enabled\n\t\t\t// , .OPT_FIFO_DEPTH(2)\n\t\t\t// , .F_LGDEPTH(F_LGDEPTH)\n// `endif\n\t\t\t// }}}\n\t\t) mem(\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN),\n\t\t\t.i_cpu_reset(cmd_reset), .i_clear(clear_dcache),\n\t\t\t// CPU interface\n\t\t\t// {{{\n\t\t\t.i_pipe_stb(mem_ce),\n\t\t\t.i_lock(bus_lock),\n\t\t\t.i_op(mem_op),\n\t\t\t.i_addr(mem_cpu_addr[AW+1:0]),\n\t\t\t.i_restart_pc(mem_lock_pc),\n\t\t\t.i_data(mem_wdata),\n\t\t\t.i_o",
            "reg (mem_",
            "reg ),\n\t\t\t.o_busy(mem_busy),\n\t\t\t.o_pipe_stalled(mem_pipe_stalled),\n\t\t\t.o_rdbusy(mem_rdbusy),\n\t\t\t.o_valid(mem_valid),\n\t\t\t.o_err(mem_bus_err),\n\t\t\t.o_w",
            "reg (mem_w",
            "reg ),\n\t\t\t.o_data(mem_result),\n\t\t\t// }}}\n\t\t\t// Write interface\n\t\t\t// {{{\n\t\t\t.M_AXI_AWVALID(M_DATA_AWVALID),\n\t\t\t.M_AXI_AWREADY(M_DATA_AWREADY),\n\t\t\t.M_AXI_AWID(   M_DATA_AWID),\n\t\t\t.M_AXI_AWADDR( M_DATA_AWADDR),\n\t\t\t.M_AXI_AWLEN(  M_DATA_AWLEN),\n\t\t\t.M_AXI_AWSIZE( M_DATA_AWSIZE),\n\t\t\t.M_AXI_AWBURST(M_DATA_AWBURST),\n\t\t\t.M_AXI_AWLOCK( M_DATA_AWLOCK),\n\t\t\t.M_AXI_AWCACHE(M_DATA_AWCACHE),\n\t\t\t.M_AXI_AWPROT( M_DATA_AWPROT),\n\t\t\t.M_AXI_AWQOS(  M_DATA_AWQOS),\n\t\t\t//\n\t\t\t.M_AXI_WVALID(M_DATA_WVALID),\n\t\t\t.M_AXI_WREADY(M_DATA_WREADY),\n\t\t\t.M_AXI_WDATA(o_bus_data),\n\t\t\t.M_AXI_WSTRB(o_bus_strb),\n\t\t\t.M_AXI_WLAST(M_DATA_WLAST),\n\t\t\t//\n\t\t\t.M_AXI_BVALID(M_DATA_BVALID),\n\t\t\t.M_AXI_BREADY(M_DATA_BREADY),\n\t\t\t.M_AXI_BID(   M_DATA_BID),\n\t\t\t.M_AXI_BRESP( M_DATA_BRESP),\n\t\t\t// }}}\n\t\t\t// Read interface\n\t\t\t// {{{\n\t\t\t.M_AXI_ARVALID(M_DATA_ARVALID),\n\t\t\t.M_AXI_ARREADY(M_DATA_ARREADY),\n\t\t\t.M_AXI_ARID(   M_DATA_ARID),\n\t\t\t.M_AXI_ARADDR( M_DATA_ARADDR),\n\t\t\t.M_AXI_ARLEN(  M_DATA_ARLEN),\n\t\t\t.M_AXI_ARSIZE( M_DATA_ARSIZE),\n\t\t\t.M_AXI_ARBURST(M_DATA_ARBURST),\n\t\t\t.M_AXI_ARLOCK( M_DATA_ARLOCK),\n\t\t\t.M_AXI_ARCACHE(M_DATA_ARCACHE),\n\t\t\t.M_AXI_ARPROT( M_DATA_ARPROT),\n\t\t\t.M_AXI_ARQOS(  M_DATA_ARQOS),\n\t\t\t//\n\t\t\t.M_AXI_RVALID(M_DATA_RVALID),\n\t\t\t.M_AXI_RREADY(M_DATA_RREADY),\n\t\t\t.M_AXI_RID(   M_DATA_RID),\n\t\t\t.M_AXI_RDATA( i_bus_data),\n\t\t\t.M_AXI_RLAST( M_DATA_RLAST),\n\t\t\t.M_AXI_RRESP( M_DATA_RRESP)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\tend else if (OPT_PIPELINED_BUS_ACCESS && OPT_LGDCACHE > 0)\n\tbegin : PIPELINED_MEM\n\n\t\taxipipe #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH),\n\t\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t\t.C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),\n\t\t\t.AXI_ID(DATA_ID),\n\t\t\t.OPT_LOCK(OPT_LOCK),\n\t\t\t.OPT_ALIGNMENT_ERR(OPT_ALIGNMENT_ERR),\n\t\t\t.SWAP_WSTRB(SWAP_WSTRB),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER)\n\t\t\t// .OPT_SIGN_EXTEND(OPT_SIGN_EXTEND)\n\t\t\t// }}}\n\t\t) domem(\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN),\n\t\t\t.i_cpu_reset(cmd_reset),\n\t\t\t// CPU interface\n\t\t\t// {{{\n\t\t\t.i_stb(mem_ce),\n\t\t\t.i_lock(bus_lock),\n\t\t\t.i_op(mem_op),\n\t\t\t.i_addr(mem_cpu_addr[AW+1:0]),\n\t\t\t.i_restart_pc(mem_lock_pc),\n\t\t\t.i_data(mem_wdata),\n\t\t\t.i_o",
            "reg (mem_",
            "reg ),\n\t\t\t.o_busy(mem_busy),\n\t\t\t.o_pipe_stalled(mem_pipe_stalled),\n\t\t\t.o_rdbusy(mem_rdbusy),\n\t\t\t.o_valid(mem_valid),\n\t\t\t.o_err(mem_bus_err),\n\t\t\t.o_w",
            "reg (mem_w",
            "reg ),\n\t\t\t.o_result(mem_result),\n\t\t\t// }}}\n\t\t\t// AXI\n\t\t\t// Write interface\n\t\t\t// {{{\n\t\t\t.M_AXI_AWVALID(M_DATA_AWVALID),\n\t\t\t.M_AXI_AWREADY(M_DATA_AWREADY),\n\t\t\t.M_AXI_AWID(   M_DATA_AWID),\n\t\t\t.M_AXI_AWADDR( M_DATA_AWADDR),\n\t\t\t.M_AXI_AWLEN(  M_DATA_AWLEN),\n\t\t\t.M_AXI_AWSIZE( M_DATA_AWSIZE),\n\t\t\t.M_AXI_AWBURST(M_DATA_AWBURST),\n\t\t\t.M_AXI_AWLOCK( M_DATA_AWLOCK),\n\t\t\t.M_AXI_AWCACHE(M_DATA_AWCACHE),\n\t\t\t.M_AXI_AWPROT( M_DATA_AWPROT),\n\t\t\t.M_AXI_AWQOS(  M_DATA_AWQOS),\n\t\t\t//\n\t\t\t.M_AXI_WVALID(M_DATA_WVALID),\n\t\t\t.M_AXI_WREADY(M_DATA_WREADY),\n\t\t\t.M_AXI_WDATA(o_bus_data),\n\t\t\t.M_AXI_WSTRB(o_bus_strb),\n\t\t\t.M_AXI_WLAST(M_DATA_WLAST),\n\t\t\t//\n\t\t\t.M_AXI_BVALID(M_DATA_BVALID),\n\t\t\t.M_AXI_BREADY(M_DATA_BREADY),\n\t\t\t.M_AXI_BID(   M_DATA_BID),\n\t\t\t.M_AXI_BRESP( M_DATA_BRESP),\n\t\t\t// }}}\n\t\t\t// Read interface\n\t\t\t// {{{\n\t\t\t.M_AXI_ARVALID(M_DATA_ARVALID),\n\t\t\t.M_AXI_ARREADY(M_DATA_ARREADY),\n\t\t\t.M_AXI_ARID(   M_DATA_ARID),\n\t\t\t.M_AXI_ARADDR( M_DATA_ARADDR),\n\t\t\t.M_AXI_ARLEN(  M_DATA_ARLEN),\n\t\t\t.M_AXI_ARSIZE( M_DATA_ARSIZE),\n\t\t\t.M_AXI_ARBURST(M_DATA_ARBURST),\n\t\t\t.M_AXI_ARLOCK( M_DATA_ARLOCK),\n\t\t\t.M_AXI_ARCACHE(M_DATA_ARCACHE),\n\t\t\t.M_AXI_ARPROT( M_DATA_ARPROT),\n\t\t\t.M_AXI_ARQOS(  M_DATA_ARQOS),\n\t\t\t//\n\t\t\t.M_AXI_RVALID(M_DATA_RVALID),\n\t\t\t.M_AXI_RREADY(M_DATA_RREADY),\n\t\t\t.M_AXI_RID(   M_DATA_RID),\n\t\t\t.M_AXI_RDATA( i_bus_data),\n\t\t\t.M_AXI_RLAST( M_DATA_RLAST),\n\t\t\t.M_AXI_RRESP( M_DATA_RRESP)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\t// Make Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_pipe;\n\t\tassign\tunused_pipe = &{ 1'b0, clear_dcache };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\tend else begin : BARE_MEM\n\n\t\taxiops\t#(\n\t\t\t// {{{\n\t\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH),\n\t\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t\t.C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),\n\t\t\t.AXI_ID(DATA_ID),\n\t\t\t.SWAP_ENDIANNESS(SWAP_ENDIANNESS),\n\t\t\t.SWAP_WSTRB(SWAP_WSTRB),\n\t\t\t// .OPT_SIGN_EXTEND(OPT_SIGN_EXTEND),\n\t\t\t.OPT_LOCK(OPT_LOCK),\n\t\t\t.OPT_ALIGNMENT_ERR(OPT_ALIGNMENT_ERR),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER)\n\t\t\t// }}}\n\t\t) domem(\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(S_AXI_ACLK), .S_AXI_ARESETN(S_AXI_ARESETN),\n\t\t\t.i_cpu_reset(cmd_reset),\n\t\t\t// CPU interface\n\t\t\t// {{{\n\t\t\t.i_stb(mem_ce),\n\t\t\t.i_lock(bus_lock),\n\t\t\t.i_op(mem_op),\n\t\t\t.i_addr(mem_cpu_addr[ADDRESS_WIDTH-1:0]),\n\t\t\t.i_restart_pc(mem_lock_pc),\n\t\t\t.i_data(mem_wdata),\n\t\t\t.i_o",
            "reg (mem_",
            "reg ),\n\t\t\t.o_busy(mem_busy),\n\t\t\t.o_rdbusy(mem_rdbusy),\n\t\t\t.o_valid(mem_valid),\n\t\t\t.o_err(mem_bus_err),\n\t\t\t.o_w",
            "reg (mem_w",
            "reg ),\n\t\t\t.o_result(mem_result),\n\t\t\t// }}}\n\t\t\t// AXI4 (full)\n\t\t\t// Write interface\n\t\t\t// {{{\n\t\t\t.M_AXI_AWVALID(M_DATA_AWVALID),\n\t\t\t.M_AXI_AWREADY(M_DATA_AWREADY),\n\t\t\t.M_AXI_AWID(   M_DATA_AWID),\n\t\t\t.M_AXI_AWADDR( M_DATA_AWADDR),\n\t\t\t.M_AXI_AWLEN(  M_DATA_AWLEN),\n\t\t\t.M_AXI_AWSIZE( M_DATA_AWSIZE),\n\t\t\t.M_AXI_AWBURST(M_DATA_AWBURST),\n\t\t\t.M_AXI_AWLOCK( M_DATA_AWLOCK),\n\t\t\t.M_AXI_AWCACHE(M_DATA_AWCACHE),\n\t\t\t.M_AXI_AWPROT( M_DATA_AWPROT),\n\t\t\t.M_AXI_AWQOS(  M_DATA_AWQOS),\n\t\t\t//\n\t\t\t.M_AXI_WVALID(M_DATA_WVALID),\n\t\t\t.M_AXI_WREADY(M_DATA_WREADY),\n\t\t\t.M_AXI_WDATA(o_bus_data),\n\t\t\t.M_AXI_WSTRB(o_bus_strb),\n\t\t\t.M_AXI_WLAST(M_DATA_WLAST),\n\t\t\t//\n\t\t\t.M_AXI_BVALID(M_DATA_BVALID),\n\t\t\t.M_AXI_BREADY(M_DATA_BREADY),\n\t\t\t.M_AXI_BID(   M_DATA_BID),\n\t\t\t.M_AXI_BRESP( M_DATA_BRESP),\n\t\t\t// }}}\n\t\t\t// Read interface\n\t\t\t// {{{\n\t\t\t.M_AXI_ARVALID(M_DATA_ARVALID),\n\t\t\t.M_AXI_ARREADY(M_DATA_ARREADY),\n\t\t\t.M_AXI_ARID(   M_DATA_ARID),\n\t\t\t.M_AXI_ARADDR( M_DATA_ARADDR),\n\t\t\t.M_AXI_ARLEN(  M_DATA_ARLEN),\n\t\t\t.M_AXI_ARSIZE( M_DATA_ARSIZE),\n\t\t\t.M_AXI_ARBURST(M_DATA_ARBURST),\n\t\t\t.M_AXI_ARLOCK( M_DATA_ARLOCK),\n\t\t\t.M_AXI_ARCACHE(M_DATA_ARCACHE),\n\t\t\t.M_AXI_ARPROT( M_DATA_ARPROT),\n\t\t\t.M_AXI_ARQOS(  M_DATA_ARQOS),\n\t\t\t//\n\t\t\t.M_AXI_RVALID(M_DATA_RVALID),\n\t\t\t.M_AXI_RREADY(M_DATA_RREADY),\n\t\t\t.M_AXI_RID(   M_DATA_RID),\n\t\t\t.M_AXI_RDATA( i_bus_data),\n\t\t\t.M_AXI_RLAST( M_DATA_RLAST),\n\t\t\t.M_AXI_RRESP( M_DATA_RRESP)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\tmem_pipe_stalled = mem_busy;\n\n\t\t// Make Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_bare;\n\t\tassign\tunused_bare = &{ 1'b0, clear_dcache };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Optional) Clock gate\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_CLKGATE)\n\tbegin : GATE_CPU_CLOCK",
            "reg gatep;",
            "reg gaten /* verilator clock_enable */;\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tgatep <= 1'b1;\n\t\telse\n\t\t\tgatep <= cpu_clken || arskd_valid || dbg_write_valid\n\t\t\t\t\t\t|| dbg_blkram_stall;\n\n\t\talways @(negedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tgaten <= 1'b1;\n\t\telse\n\t\t\tgaten <= gatep;\n\n\t\tassign\tcpu_clock = S_AXI_ACLK && gaten;\n\t\tassign\tclk_gate = gatep;\n\n\tend else begin : NO_CLOCK_GATE\n\n\t\tassign\tcpu_clock = S_AXI_ACLK;\n\t\tassign\tclk_gate = 1'b1;\n\n\tend endgenerate\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, cpu_clken, cpu_dbg_cc[2],\n\t\t\tS_DBG_AWADDR[DBGLSB-1:0],\n\t\t\tS_DBG_ARADDR[DBGLSB-1:0],\n\t\t\tS_DBG_ARPROT, S_DBG_AWPROT,\n\t\t\tM_INSN_AWREADY, M_INSN_WREADY,\n\t\t\tM_INSN_BVALID, M_INSN_BID, M_INSN_BRESP\n\t\t};\n\tgenerate if (32 > ADDRESS_WIDTH)\n\tbegin : UNUSED_ADDR",
            "wire unused_addr;\n\t\tassign\tunused_addr = &{ 1'b0, mem_cpu_addr[31:ADDRESS_WIDTH] };\n\tend endgenerate\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "wire [F_LGDEPTH-1:0]\tfaxil_rd_outstanding,\n\t\t\t\tfaxil_wr_outstanding, faxil_awr_outstanding;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI-lite debug interface\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\n\tfaxil_slave #(\n\t\t// {{{\n\t\t.C_AXI_DATA_WIDTH(C_DBG_DATA_WIDTH),\n\t\t.C_AXI_ADDR_WIDTH(C_DBG_ADDR_WIDTH),\n\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t.F_AXI_MAXWAIT(0),\n\t\t.F_AXI_MAXDELAY(0)\n\t\t// }}}\n\t) faxil (\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN),\n\t\t// AXI-lite debug writes\n\t\t// {{{\n\t\t.i_axi_awvalid(S_DBG_AWVALID),\n\t\t.i_axi_awready(S_DBG_AWREADY),\n\t\t.i_axi_awaddr(S_DBG_AWADDR),\n\t\t.i_axi_awprot(S_DBG_AWPROT),\n\t\t//\n\t\t.i_axi_wvalid(S_DBG_WVALID),\n\t\t.i_axi_wready(S_DBG_WREADY),\n\t\t.i_axi_wdata(S_DBG_WDATA),\n\t\t.i_axi_wstrb(S_DBG_WSTRB),\n\t\t//\n\t\t.i_axi_bvalid(S_DBG_BVALID),\n\t\t.i_axi_bready(S_DBG_BREADY),\n\t\t.i_axi_bresp(S_DBG_BRESP),\n\t\t// }}}\n\t\t// AXI-lite debug reads\n\t\t// {{{\n\t\t.i_axi_arvalid(S_DBG_ARVALID),\n\t\t.i_axi_arready(S_DBG_ARREADY),\n\t\t.i_axi_araddr(S_DBG_ARADDR),\n\t\t.i_axi_arprot(S_DBG_ARPROT),\n\t\t//\n\t\t.i_axi_rvalid(S_DBG_RVALID),\n\t\t.i_axi_rready(S_DBG_RREADY),\n\t\t.i_axi_rdata(S_DBG_RDATA),\n\t\t.i_axi_rresp(S_DBG_RRESP),\n\t\t// }}}\n\t\t// Induction\n\t\t// {{{\n\t\t.f_axi_rd_outstanding(faxil_rd_outstanding),\n\t\t.f_axi_wr_outstanding(faxil_wr_outstanding),\n\t\t.f_axi_awr_outstanding(faxil_awr_outstanding)\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (S_AXI_ARESETN)\n\tbegin\n\t\tassert(faxil_rd_outstanding == (S_DBG_ARREADY ? 0:1)\n\t\t\t\t+(dbg_read_valid ? 1:0) + (S_DBG_RVALID ? 1:0));\n\n\t\tassert(!dbg_read_valid || !S_DBG_RVALID);\n\n\t\tassert(faxil_wr_outstanding == (S_DBG_WREADY ? 0:1)\n\t\t\t\t+(S_DBG_BVALID ? 1:0));\n\n\t\tassert(faxil_awr_outstanding == (S_DBG_AWREADY ? 0:1)\n\t\t\t\t+(S_DBG_BVALID ? 1:0));\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// CPU's debug interface\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Captured above\n\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipdma_s2mm.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma_s2mm.v",
        "chunks": [
            "module zipdma_s2mm #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=30,",
            "parameter BUS_WIDTH = 64,",
            "parameter [0:0]\tOPT_LITTLE_ENDIAN = 1'b0,",
            "parameter LGPIPE = 10,\n\t\t// Abbreviations",
            "localparam DW = BUS_WIDTH,",
            "localparam AW = ADDRESS_WIDTH-$clog2(DW/8)\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Configuration\n\t\t// {{{",
            "input ",
            "wire i_request,",
            "output ",
            "reg o_busy, o_err,",
            "input ",
            "wire i_inc,",
            "input ",
            "wire [1:0]\t\ti_size,\n\t\t//",
            "input ",
            "wire [LGLENGTH:0]\ti_transferlen,",
            "input ",
            "wire [ADDRESS_WIDTH-1:0]\ti_addr,\t// Byte address\n\t\t// }}}\n\t\t// Incoming Stream interface\n\t\t// {{{",
            "input ",
            "wire S_VALID,",
            "output ",
            "wire S_READY,",
            "input ",
            "wire [DW-1:0]\tS_DATA,\n\t\t// How many bytes are valid?",
            "input ",
            "wire [$clog2(DW/8):0]\tS_BYTES,",
            "input ",
            "wire S_LAST,\n\t\t// }}}\n\t\t// Outgoing Wishbone interface\n\t\t// {{{",
            "output ",
            "reg o_wr_cyc, o_wr_stb,",
            "output ",
            "wire o_wr_we,",
            "output ",
            "reg [AW-1:0]\to_wr_addr,",
            "output ",
            "reg [DW-1:0]\to_wr_data,",
            "output ",
            "reg [DW/8-1:0]\to_wr_sel,",
            "input ",
            "wire i_wr_stall,",
            "input ",
            "wire i_wr_ack,\n\t\t// Verilator coverage_off",
            "input ",
            "wire [DW-1:0]\ti_wr_data,\t// UNUSED",
            "input ",
            "wire i_wr_err\n\t\t// Verilator coverage_on\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Local decalarations\n\t// {{{",
            "localparam [1:0]\t\tSZ_BYTE = 2'b11,\n\t\t\t\t\tSZ_16B  = 2'b10,\n\t\t\t\t\tSZ_32B  = 2'b01,\n\t\t\t\t\tSZ_BUS  = 2'b00;",
            "localparam WBLSB = $clog2(DW/8);\n\tinteger\t\t\t\tik;\n\t//",
            "reg r_inc;",
            "reg [1:0]\t\t\tr_size;\n\t//",
            "reg [ADDRESS_WIDTH:0]\tnext_addr;",
            "reg [WBLSB-1:0]\t\tsubaddr;",
            "reg [2*DW-1:0]\t\tnext_data;",
            "reg [DW-1:0]\t\tr_data;",
            "reg [2*DW/8-1:0]\t\tnext_sel, pre_sel;",
            "reg [DW/8-1:0]\t\tr_sel;",
            "reg r_last;",
            "reg [LGPIPE-1:0]\t\twb_outstanding;",
            "reg wb_pipeline_full;",
            "reg addr_overflow;\n\t// }}}\n\n\tassign\to_wr_we = 1'b1;\n\n\t// Copy config: r_inc, r_size(, r_addr)\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_request && !o_busy)\n\tbegin\n\t\tr_inc  <= i_inc;\n\t\tr_size <= i_size;\n\t\t// r_addr <= i_addr;\n\tend\n\t// }}}\n\n\t// next_addr\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tnext_addr = { 1'b0, o_wr_addr, subaddr };\n\n\t\tif (o_wr_stb && !i_wr_stall)\n\t\tcase(r_size)\n\t\tSZ_BYTE: if (r_inc)\n\t\t\tnext_addr = next_addr + 1;\n\t\tSZ_16B: begin\t// 16-bit addressing\n\t\t\tif (r_inc)\n\t\t\t\tnext_addr = next_addr + 2;\n\t\t\telse\n\t\t\t\tnext_addr[  0] = 0;\n\t\t\tend\n\t\tSZ_32B: begin\t// 32-bit addressing\n\t\t\tif (r_inc)\n\t\t\t\tnext_addr = next_addr + 4;\n\t\t\telse\n\t\t\t\tnext_addr[1:0] = 0;\n\t\t\tend\n\t\tSZ_BUS: begin\t// Full word addressing\n\t\t\tif (r_inc)\n\t\t\t\tnext_addr = next_addr + { {(AW-1){1'b0}}, 1'b1,\n\t\t\t\t\t\t{(WBLSB){1'b0}} };\n\t\t\telse\n\t\t\t\tnext_addr[WBLSB-1:0] = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\n\talways @(*)\n\t\taddr_overflow = next_addr[ADDRESS_WIDTH];\n`ifdef\tFORMAL\n\talways @(posedge i_clk)\n\tif (!i_reset && o_busy && !r_inc)\n\tcase(r_size)\n\tSZ_BYTE: begin end\n\tSZ_16B: assert(next_addr[0] == 0);\n\tSZ_32B: assert(next_addr[1:0] == 0);\n\tSZ_BUS: assert(next_addr[WBLSB-1:0] == 0);\n\tendcase\n`endif\n\t// }}}\n\n\t// next_data\n\t// {{{\n\talways @(*)\n\tif (OPT_LITTLE_ENDIAN)\n\tbegin\n\t\tnext_data = { {(DW){1'b0}}, r_data };\n\n\t\t// Zero out unused data\n\t\tfor(ik=0; ik<DW/8; ik=ik+1)\n\t\tif (!r_sel[ik])\n\t\t\tnext_data[ik * 8 +: 8] = 8'h0;\n\n\t\tif (S_VALID && !r_last)\n\t\t\tnext_data = next_data | ({{(DW){1'b0}}, S_DATA }\n\t\t\t\t\t<< (next_addr[WBLSB-1:0]*8));\n\tend else begin\n\t\tnext_data = { r_data, {(DW){1'b0}} };\n\n\t\t// Zero out unused data\n\t\tfor(ik=0; ik<DW/8; ik=ik+1)\n\t\tif (!r_sel[ik])\n\t\t\tnext_data[DW + ik * 8 +: 8] = 8'h0;\n\n\t\tif (S_VALID && !r_last)\n\t\t\tnext_data = next_data | ({ S_DATA, {(DW){1'b0}} }\n\t\t\t\t\t>> (next_addr[WBLSB-1:0]*8));\n\tend\n\t// }}}\n\n\t// next_sel\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tpre_sel = 0;\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tfor(ik=0; ik<DW/8; ik=ik+1)\n\t\t\tif (ik < S_BYTES)\n\t\t\t\tpre_sel[ik] = 1'b1;\n\n\t\t\tnext_sel = { {(DW/8){1'b0}}, r_sel };\n\t\t\tif (S_VALID && !r_last)\n\t\t\t\tnext_sel = next_sel | (pre_sel\n\t\t\t\t\t\t<< (next_addr[WBLSB-1:0]));\n\t\tend else begin\n\t\t\tfor(ik=0; ik<DW/8; ik=ik+1)\n\t\t\tif (ik < S_BYTES)\n\t\t\t\tpre_sel[2*DW/8-1-ik] = 1'b1;\n\n\t\t\tnext_sel = { r_sel, {(DW/8){1'b0}} };\n\t\t\tif (S_VALID && !r_last)\n\t\t\t\tnext_sel = next_sel | (pre_sel\n\t\t\t\t\t\t>> (next_addr[WBLSB-1:0]));\n\t\tend\n\tend\n\t// }}}\n\n\t// wb_pipeline_full, wb_outstanding\n\t// {{{\n\tinitial\twb_pipeline_full = 1'b0;\n\tinitial\twb_outstanding   = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || !o_wr_cyc || i_wr_err)\n\tbegin\n\t\twb_pipeline_full <= 1'b0;\n\t\twb_outstanding   <= 0;\n\tend else case({ (o_wr_stb && !i_wr_stall), i_wr_ack })\n\t2'b10:\tbegin\n\t\twb_pipeline_full <= (&wb_outstanding[LGPIPE-1:2])\n\t\t\t\t\t\t&& (|wb_outstanding[1:0]);\n\t\twb_outstanding   <= wb_outstanding + 1;\n\t\tend\n\t2'b01: begin\n\t\twb_pipeline_full <= (&wb_outstanding[LGPIPE-1:0]);\n\t\twb_outstanding   <= wb_outstanding - 1;\n\t\tend\n\tdefault: begin end\n\tendcase\n\n`ifdef\tFORMAL\n\talways @(*)\n\tif (!i_reset || !o_wr_cyc)\n\t\tassert(wb_pipeline_full == (&wb_outstanding[LGPIPE-1:1]));\n\n\talways @(*)\n\tif (!i_reset && o_wr_cyc && (&wb_outstanding))\n\t\tassert(!o_wr_stb);\n`endif\n\t// }}}\n\n\t// crc, stb, o_wr_addr, o_wr_sel, o_busy, o_err, subaddr\n\t// {{{\n\tinitial\to_wr_cyc = 1'b0;\n\tinitial\to_wr_stb = 1'b0;\n\tinitial\to_busy   = 1'b0;\n\tinitial\to_err    = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\t// {{{\n\t\to_wr_cyc  <= 0;\n\t\to_wr_stb  <= 0;\n\t\to_wr_addr <= 0;\n\n\t\to_busy <= 1'b0;\n\t\to_err  <= 1'b0;\n\t\t{ o_wr_addr, subaddr } <= {(ADDRESS_WIDTH){1'b0}};\n\t\tr_last <= 1'b0;\n\t\t// }}}\n\tend else if (!o_busy || o_err || (o_wr_cyc && i_wr_err))\n\tbegin\n\t\t// {{{\n\t\to_wr_cyc  <= 0;\n\t\to_wr_stb  <= 0;\n\t\to_wr_addr <= 0;\n\n\t\to_busy <= i_request && !o_busy;\n\n\t\to_err <= o_wr_cyc && i_wr_err;\n\t\tif (o_wr_cyc && i_wr_err)\n\t\t\to_busy <= 1'b0;\n\n\t\to_wr_addr <= i_addr[ADDRESS_WIDTH-1:WBLSB];\n\t\tsubaddr   <= i_addr[WBLSB-1:0];\n\t\tr_last <= 1'b0;\n\t\t// }}}\n\tend else if (!o_wr_stb || !i_wr_stall)\n\tbegin\n\t\t// {{{\n\t\to_wr_stb <= 1'b0;\n\n\t\tif (o_wr_stb)\n\t\t\t{ o_wr_addr, subaddr } <= next_addr[ADDRESS_WIDTH-1:0];\n\n\t\tif (addr_overflow)\n\t\t\t{ o_err, o_wr_cyc, o_wr_stb } <= 3'b100;\n\t\telse if (!wb_pipeline_full)\n\t\tbegin\n\t\t\tif ((r_last && (|r_sel)) || (S_VALID && !r_last))\n\t\t\tbegin\n\t\t\t\t// Need to flush our last result out\n\t\t\t\t{ o_wr_cyc, o_wr_stb } <= 2'b11;\n\n\t\t\tend else if (wb_outstanding + (o_wr_stb ? 1:0)\n\t\t\t\t\t\t\t== (i_wr_ack ? 1:0))\n\t\t\tbegin\n\t\t\t\t// We are all done writing\n\t\t\t\to_wr_cyc <= 1'b0;\n\t\t\t\to_busy <= !r_last;\n\t\t\tend\n\t\tend\n\n\t\tif (S_VALID && !r_last)\n\t\t\tr_last <= S_LAST;\n\t\t// }}}\n\tend\n\n`ifdef\tFORMAL\n\talways @(posedge i_clk)\n\tif (i_reset || !o_busy || o_err || (o_wr_cyc && i_wr_err))\n\tbegin\n\tend else if (!o_wr_stb || !i_wr_stall)\n\tbegin\n\t\t// {{{\n\t\tif (addr_overflow)\n\t\tbegin\n\t\tend else if (!wb_pipeline_full)\n\t\tbegin\n\t\t\tif (r_last && (|r_sel))\n\t\t\tbegin\n\t\t\t\t// Need to flush our last result out\n\t\t\t\tassert(!S_READY);\n\t\t\tend else if (S_VALID && !r_last)\n\t\t\tbegin\n\t\t\t\tassert(S_VALID && S_READY);\n\t\t\tend else begin\n\t\t\t\tassert(!S_VALID || !S_READY);\n\t\t\tend\n\t\tend else begin\n\t\t\tassert(!S_READY);\n\t\tend\n\t\t// }}}\n\tend else begin\n\t\tassert(!S_READY);\n\tend\n\n\talways @(*)\n\tif (!i_reset && !o_busy)\n\t\tassert(!o_wr_cyc);\n`endif\n\t// }}}\n\n\t// o_wr_data, o_wr_sel\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!o_busy) // i_reset || !o_busy || o_err || (o_wr_cyc && i_wr_err))\n\tbegin\n\t\t// {{{\n\t\t{ r_data, o_wr_data  } <= {(2*DW  ){1'b0}};\n\t\t{ r_sel,  o_wr_sel   } <= {(2*DW/8){1'b0}};\n\t\t// }}}\n\tend else if ((!o_wr_stb || !i_wr_stall) && !wb_pipeline_full\n\t\t\t\t\t&& (r_last || S_VALID))\n\tbegin\n\t\t// {{{\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\t{ r_data, o_wr_data } <= next_data;\n\t\t\t{ r_sel,  o_wr_sel  } <= next_sel;\n\t\tend else begin\n\t\t\t{ o_wr_data, r_data } <= next_data;\n\t\t\t{ o_wr_sel,  r_sel  } <= next_sel;\n\t\tend\n\t\t// }}}\n\tend\n\t// }}}\n\n\tassign\tS_READY = !r_last && o_busy && (!o_wr_stb || !i_wr_stall)\n\t\t\t\t&& !wb_pipeline_full;\n\n\t// Keep Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, i_wr_data };\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "localparam F_LGDEPTH = LGPIPE+1;",
            "reg f_past_valid;\n\t(* anyconst *)",
            "reg [ADDRESS_WIDTH-1:0]\tf_cfg_addr;\n\t(* anyconst *)",
            "reg [1:0]\tf_cfg_size;\n\t(* anyconst *)",
            "reg f_cfg_inc;",
            "wire [F_LGDEPTH-1:0]\t\tfwb_nreqs, fwb_nacks, fwb_outstanding;",
            "reg [ADDRESS_WIDTH:0]\tf_posn, fwb_addr, fwb_posn;",
            "reg [WBLSB-1:0]\tfr_sel_count, fr_sel_count_past;",
            "reg [ADDRESS_WIDTH-1:0]\tr_addr;\n\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Control interface properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset))\n\t\tassume(!i_request);\n\telse if ($past(i_request && o_busy))\n\tbegin\n\t\tassume(i_request);\n\t\tassume($stable(i_inc));\n\t\tassume($stable(i_size));\n\t\tassume($stable(i_addr));\n\tend\n\n\talways @(posedge i_clk)\n\tif (i_request && !o_busy)\n\tbegin\n\t\t// r_inc  <= i_inc;\n\t\t// r_size <= i_size;\n\t\tr_addr <= i_addr;\n\tend\n\n\talways @(*)\n\tif (!f_cfg_inc) case(f_cfg_size)\n\tSZ_BYTE: begin end\n\tSZ_16B:  assume(f_cfg_addr[0] == 1'b0);\n\tSZ_32B:  assume(f_cfg_addr[1:0] == 2'b0);\n\tSZ_BUS:  assume(f_cfg_addr[WBLSB-1:0] == 0);\n\tendcase\n\n\talways @(*)\n\tif (i_request && !o_busy)\n\tbegin\n\t\tassume(i_inc  == f_cfg_inc);\n\t\tassume(i_size == f_cfg_size);\n\t\tassume(i_addr == f_cfg_addr);\n\tend\n\n\talways @(*)\n\tif (!i_reset && o_busy)\n\tbegin\n\t\tassert(r_addr == f_cfg_addr);\n\t\tassert(r_size == f_cfg_size);\n\t\tassert(r_inc  == f_cfg_inc);\n\n\t\tif (!r_inc)\n\t\tcase(r_size)\n\t\tSZ_BYTE: begin end\n\t\tSZ_16B: assert(r_addr[0] == 1'b0);\n\t\tSZ_32B: assert(r_addr[1:0] == 2'b0);\n\t\tSZ_BUS: assert(r_addr[WBLSB-1:0] == 0);\n\t\tendcase\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Stream properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset))\n\tbegin\n\t\tassume(!S_VALID);\n\tend else if ($past(S_VALID && !S_READY))\n\tbegin\n\t\tassume(S_VALID);\n\t\tassume($stable(S_DATA));\n\t\tassume($stable(S_BYTES));\n\t\tassume($stable(S_LAST));\n\tend\n\n\talways @(*)\n\tif (S_VALID)\n\tbegin\n\t\tassume(S_BYTES <= DW/8);\n\t\tassume(S_BYTES > 0);\n\n\t\tif (!S_LAST)\n\t\tcase(f_cfg_size)\n\t\t2'b11: assume(S_BYTES == 1);\n\t\t2'b10: assume(S_BYTES == 2);\n\t\t2'b01: assume(S_BYTES == 4);\n\t\t2'b00: assume(S_BYTES == (DW/8));\n\t\tendcase\n\t\telse case(f_cfg_size)\n\t\t2'b11: assume(S_BYTES == 1);\n\t\t2'b10: assume(S_BYTES <= 2);\n\t\t2'b01: assume(S_BYTES <= 4);\n\t\t2'b00: assume(S_BYTES <= (DW/8));\n\t\tendcase\n\tend\n\n\talways @(posedge i_clk)\n\tif (i_reset || !o_busy)\n\t\tf_posn <= 0;\n\telse if (S_VALID && S_READY)\n\t\tf_posn <= f_posn + S_BYTES;\n\n\talways @(*)\n\tif (o_busy)\n\t\tassume(!f_posn[ADDRESS_WIDTH] || (f_posn[ADDRESS_WIDTH-1:0]==0\n\t\t\t&& r_last));\n\n\talways @(*)\n\tif (!i_reset && o_busy)\n\tbegin\n\t\tif (r_last)\n\t\tbegin\n\t\tend else case(f_cfg_size)\n\t\t2'b11: begin end\n\t\t2'b10: assert(f_posn[0] == 1'b0);\n\t\t2'b01: assert(f_posn[1:0] == 2'b0);\n\t\t2'b00: assert(f_posn[WBLSB-1:0] == 0);\n\t\tendcase\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Wishbone properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tfwb_master #(\n\t\t.AW(AW), .DW(DW), .F_LGDEPTH(F_LGDEPTH),\n\t\t.F_OPT_DISCONTINUOUS(1'b1),\n\t\t.F_MAX_STALL(2),\n\t\t.F_MAX_ACK_DELAY(2)\n\t) fwb (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_wb_cyc( o_wr_cyc),\n\t\t.i_wb_stb( o_wr_stb),\n\t\t.i_wb_we(  o_wr_we),\n\t\t.i_wb_addr(o_wr_addr),\n\t\t.i_wb_data(o_wr_data),\n\t\t.i_wb_sel( o_wr_sel),\n\t\t//\n\t\t.i_wb_stall(i_wr_stall),\n\t\t.i_wb_ack(  i_wr_ack),\n\t\t.i_wb_idata(i_wr_data),\n\t\t.i_wb_err(  i_wr_err),\n\t\t//\n\t\t.f_nreqs(fwb_nreqs),\n\t\t.f_nacks(fwb_nacks),\n\t\t.f_outstanding(fwb_outstanding)\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (!i_reset && o_wr_stb)\n\t\tassert(|o_wr_sel);\n\n\talways @(*)\n\tif (o_wr_cyc)\n\t\tassert(fwb_outstanding == wb_outstanding);\n\n\tinitial\tfwb_posn = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || !o_busy)\n\t\tfwb_posn <= 0;\n\telse if (o_wr_stb && !i_wr_stall)\n\t\tfwb_posn <= fwb_posn + $countones(o_wr_sel);\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_err)\n\t\tassert(f_posn == fwb_posn + $countones(r_sel)\n\t\t\t\t+ (o_wr_stb ? $countones(o_wr_sel) : 0));\n\n\talways @(*)\n\tif (r_inc)\n\tbegin\n\t\tfwb_addr = r_addr + fwb_posn;\n\n\t\tif (fwb_posn > 0)\n\t\tcase(r_size)\n\t\tSZ_16B: fwb_addr[  0] = 0;\n\t\tSZ_32B: fwb_addr[1:0] = 0;\n\t\tSZ_BUS: fwb_addr[WBLSB-1:0] = 0;\n\t\tdefault: begin end\n\t\tendcase\n\tend else begin\n\t\t// fwb_addr = r_addr + fwb_posn;\n\t\tfwb_addr = r_addr;\n\n\t\tcase(r_size)\n\t\tSZ_BYTE: begin end\n\t\tSZ_16B: fwb_addr[0] = 0;\n\t\tSZ_32B: fwb_addr[1:0] = 0;\n\t\tSZ_BUS: fwb_addr[WBLSB-1:0] = 0;\n\t\tendcase\n\tend\n\n\talways @(*)\n\tif (!i_reset && o_busy && !r_last && !o_err)\n\t\t\t// && (o_wr_stb || !fwb_addr[ADDRESS_WIDTH]) && !r_last)\n\tbegin\n\t\tassert({ 1'b0, o_wr_addr } == fwb_addr[ADDRESS_WIDTH:WBLSB]);\n\t\tcase(r_size)\n\t\tSZ_BUS: assert(subaddr == r_addr[WBLSB-1:0]);\n\t\tSZ_16B: assert(subaddr == { fwb_addr[WBLSB-1:1], r_addr[0] });\n\t\tSZ_32B: assert(subaddr == { fwb_addr[WBLSB-1:2], r_addr[1:0] });\n\t\tdefault:\n\t\t\tassert(subaddr == fwb_addr[WBLSB-1:0]);\n\t\tendcase\n\tend\n\n\talways @(*)\n\tif (o_busy && fwb_addr[ADDRESS_WIDTH] && !r_last)\n\tbegin\n\t\tassert(o_err);\n\t\t// assert(fwb_addr[ADDRESS_WIDTH-1:0] <= DW/8);\n\tend\n\n\talways @(*)\n\tif (!o_busy || o_err)\n\t\tassert(!o_wr_cyc);\n\n\talways @(*)\n\tif (!i_reset && o_busy)\n\tbegin\n\t\tif (!r_inc)\n\t\tcase(r_size)\n\t\tSZ_BYTE: begin end\n\t\tSZ_16B: assert(subaddr[0] == 1'b0);\n\t\tSZ_32B: assert(subaddr[1:0] == 2'b00);\n\t\tSZ_BUS: assert(subaddr == 0);\n\t\tendcase else case(r_size)\n\t\tSZ_BYTE: begin end\n\t\tSZ_16B: assert(subaddr[0]   == r_addr[0]);\n\t\tSZ_32B: assert(subaddr[1:0] == r_addr[1:0]);\n\t\tSZ_BUS: assert(subaddr      == r_addr[WBLSB-1:0]);\n\t\tendcase\n\tend\n\n\talways @(*)\n\t\tfr_sel_count = $countones(r_sel);\n\n\talways @(posedge i_clk)\n\tif (!o_wr_sel || !i_wr_stall)\n\t\tfr_sel_count_past <= fr_sel_count;\n\n\talways @(posedge i_clk)\n\tif(!i_reset && o_busy && !o_err && !r_last && $past(S_VALID && S_READY))\n\tbegin\n\t\tassert(o_wr_stb);\n\t\tassert($countones({ r_sel, o_wr_sel })\n\t\t\t\t\t== $past(S_BYTES + fr_sel_count));\n\tend\n\n\talways @(*)\n\tif (!i_reset && o_busy)\n\tbegin\n\t\tif (o_err)\n\t\t\tassert(!o_wr_cyc);\n\t\tif (f_posn == 0)\n\t\tbegin\n\t\t\tassert(r_sel == 0);\n\t\t\tassert(!o_wr_cyc);\n\t\t\tassert(wb_outstanding == 0);\n\t\tend else\n\t\tcase(r_size)\n\t\tSZ_BYTE: assert(r_sel == 0);\n\t\tSZ_16B: begin\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\tassert(r_sel[DW/8-1:1] == 0);\n\t\t\tend else begin\n\t\t\t\tassert(r_sel[DW/8-2:0] == 0);\n\t\t\tend\n\n\t\t\tif (!o_wr_stb) begin end\n\t\t\telse if (subaddr + 2 <= DW/8)\n\t\t\tbegin\n\t\t\t\tassert(r_sel == 0);\n\t\t\tend else if (!r_last)\n\t\t\tbegin\n\t\t\t\tassert(r_sel[(OPT_LITTLE_ENDIAN) ? 0 : (DW/8-1)] == (subaddr+2 > DW/8));\n\t\t\tend else begin\n\t\t\t\tassert(r_sel[(OPT_LITTLE_ENDIAN) ? 0 : (DW/8-1)] <= (subaddr+2 > DW/8));\n\t\t\tend end\n\t\tSZ_32B: begin\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\tassert(r_sel[DW/8-1:3] == 0);\n\t\t\tend else begin\n\t\t\t\tassert(r_sel[DW/8-4:0] == 0);\n\t\t\tend\n\n\t\t\tif (!o_wr_stb) begin end\n\t\t\telse if (subaddr + 4 <= DW/8)\n\t\t\tbegin\n\t\t\t\tassert(r_sel == 0);\n\t\t\t/*\n\t\t\tend else if (!r_last)\n\t\t\tbegin\n\t\t\t\tassert($countones(r_sel) == subaddr+4-DW/8);\n\t\t\tend else begin\n\t\t\t\tassert($countones(r_sel) <= subaddr+4-DW/8);\n\t\t\t*/\n\t\t\tend end\n\t\tSZ_BUS: begin\n\t\t\tassert(!(&r_sel));\n\t\t\tif (subaddr == 0)\n\t\t\t\tassert(r_sel == 0);\n\t\t\tend\n\t\tdefault: begin end\n\t\tendcase\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tif (!o_wr_sel[DW/8-1])\n\t\t\t\tassert(!r_sel[0]);\n\t\tend else begin\n\t\t\tif (!o_wr_sel[0])\n\t\t\t\tassert(!r_sel[DW/8-1]);\n\t\tend\n\n\t\tfor(ik=0; ik<DW/8; ik=ik+1)\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tcase(r_size)\n\t\t\tSZ_32B: if (ik > 2)\n\t\t\t\tassert(!r_sel[ik]);\n\t\t\tSZ_BUS: if (ik >= r_addr[DW/8-1:0])\n\t\t\t\tassert(!r_sel[ik]);\n\t\t\tdefault: begin end\n\t\t\tendcase\n\t\tend else begin\n\t\t\tif (ik > 0 && !r_sel[DW/8-ik])\n\t\t\tbegin\n\t\t\t\tassert(!r_sel[DW/8-1-ik]);\n\t\t\tend\n\n\t\t\tcase(r_size)\n\t\t\tSZ_32B: begin\n\t\t\t\t/*if (ik >= 4 || subaddr + ik < DW/8\n\t\t\t\t\t|| subaddr + ik - DW/8 >= 4)\n\t\t\t\t// assert(!r_sel[subaddr+ik-DW/8]);\n\t\t\t\tassert(!r_sel[DW/5-1-ik-subaddr]);\n\t\t\t\t*/\n\t\t\t\tend\n\t\t\tSZ_BUS: begin\n\t\t\t\t/*\n\t\t\t\tif (ik > DW/8-1-i_addr[DW/8-1:0])\n\t\t\t\tassert(!r_sel[ik]);\n\t\t\t\t*/\n\t\t\t\tend\n\t\t\tdefault: begin end\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(*)\n\tif (!i_reset && o_busy && !r_inc)\n\t\tassert(r_sel == 0);",
            "reg [WBLSB-1:0]\tf_sum;\n\n\talways @(*)\n\tif (r_inc)\n\t\tf_sum = fwb_posn[WBLSB-1:0] + r_addr[WBLSB-1:0];\n\telse\n\t\tf_sum = fwb_posn[WBLSB-1:0];\n\n\talways @(*)\n\tif (!i_reset && o_busy && fwb_posn > 0)\n\tbegin\n\t\tif (!r_last) case(r_size)\n\t\tSZ_16B: assert(f_sum[  0] == 0);\n\t\tSZ_32B: assert(f_sum[1:0] == 0);\n\t\tSZ_BUS: assert(f_sum[WBLSB-1:0] == 0);\n\t\tdefault: begin end\n\t\tendcase\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t(* anyconst *)",
            "reg fc_check;\n\t(* anyconst *)",
            "reg [ADDRESS_WIDTH:0]\tfc_posn;\n\t(* anyconst *)",
            "reg [7:0]\t\t\tfc_byte;",
            "reg [ADDRESS_WIDTH:0]\tf_shift, fwb_shift;",
            "reg [DW-1:0]\tfc_partial;",
            "reg [2*DW-1:0]\tfc_partial_wb;",
            "reg [2*DW/8-1:0]\tfc_partial_sel;",
            "wire [DW-1:0]\tfz_data;",
            "wire [DW/8-1:0]\tfz_sel;\n\n\tassign\tfz_data = 0;\n\tassign\tfz_sel  = 0;\n\n\talways @(*)\n\tbegin\n\t\tf_shift = (fc_posn - f_posn);\n\t\tf_shift[ADDRESS_WIDTH:WBLSB] = 0;\n\tend\n\n\talways @(*)\n\tif (OPT_LITTLE_ENDIAN)\n\t\tfc_partial = S_DATA >> (8*f_shift);\n\telse\n\t\tfc_partial = S_DATA << (8*f_shift);",
            "wire fin_check, fwb_check;\n\tassign\tfin_check = fc_check && S_VALID && (f_posn <= fc_posn)\n\t\t\t\t&& (fc_posn < f_posn + S_BYTES);\n\tassign\tfwb_check = fc_check && o_busy && !o_err\n\t\t&& (fwb_posn <= fc_posn)\n\t\t&&((o_wr_stb && fc_posn < fwb_posn + $countones(o_wr_sel))\n\t\t||(!o_wr_stb && fc_posn < fwb_posn + $countones(r_sel)));\n\n\talways @(*)\n\tif (fin_check)\n\tbegin\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tassume(fc_partial[7:0] == fc_byte);\n\t\telse\n\t\t\tassume(fc_partial[DW-1:DW-8] == fc_byte);\n\tend\n\n\talways @(*)\n\tbegin\n\t\tfwb_shift = 0;\n\t\tif (r_inc)\n\t\tbegin\n\t\t\tfwb_shift[WBLSB-1:0] = fc_posn[WBLSB-1:0]\n\t\t\t\t- fwb_posn[WBLSB-1:0];\n\t\t\tif (o_wr_stb)\n\t\t\t\tfwb_shift[WBLSB-1:0] = fwb_shift[WBLSB-1:0] + fwb_addr[WBLSB-1:0];\n\t\tend else\n\t\t\tfwb_shift[WBLSB-1:0] = fc_posn[WBLSB-1:0] - fwb_posn[WBLSB-1:0]\n\t\t\t\t\t\t\t+ r_addr[WBLSB-1:0];\n\tend\n\n\talways @(*)\n\tif (OPT_LITTLE_ENDIAN)\n\tbegin\n\t\tif (o_wr_stb)\n\t\tbegin\n\t\tfc_partial_wb ={ r_data, o_wr_data} >> (8*fwb_shift);\n\t\tfc_partial_sel={ r_sel,  o_wr_sel } >>    fwb_shift;\n\t\tend else begin\n\t\tfc_partial_wb ={ fz_data, r_data} >> (8*fwb_shift);\n\t\tfc_partial_sel={ fz_sel,  r_sel } >>    fwb_shift;\n\t\tend\n\tend else begin\n\t\tif (o_wr_stb)\n\t\tbegin\n\t\t\tfc_partial_wb ={ o_wr_data, r_data }<< (8*fwb_shift);\n\t\t\tfc_partial_sel={ o_wr_sel,  r_sel } <<    fwb_shift;\n\t\tend else begin\n\t\t\tfc_partial_wb ={ r_data,fz_data } << (8*fwb_shift);\n\t\t\tfc_partial_sel={ r_sel, fz_sel  } <<    fwb_shift;\n\t\tend\n\tend\n\n\talways @(*)\n\tif (o_busy)\n\t\tassert(fwb_posn <= f_posn);\n\n\talways @(*)\n\tif (fwb_check)\n\tbegin\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tassert(fc_partial_wb[7:0] == fc_byte);\n\t\t\tassert(fc_partial_sel[0]);\n\t\tend else begin\n\t\t\tassert(fc_partial_wb[2*DW-1:2*DW-8] == fc_byte);\n\t\t\tassert(fc_partial_sel[2*DW/8-1]);\n\t\tend\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif (!i_reset && !$past(i_reset))\n\t\tcover(i_request);\n\n\talways @(posedge i_clk)\n\tif (!i_reset && !$past(i_reset))\n\t\tcover(o_busy);\n\n\talways @(posedge i_clk)\n\tif (!i_reset && !$past(i_reset) && $past(o_busy))\n\tbegin\n\t\tcover(!o_busy);\n\n\t\tif (!o_busy)\n\t\tbegin\n\t\t\tcase({ r_inc, r_size })\n\t\t\t3'b000: cover(f_posn > DW/8);\n\t\t\t3'b001: cover(f_posn > DW/8);\n\t\t\t3'b010: cover(f_posn > DW/8);\n\t\t\t3'b011: cover(f_posn > DW/8);\n\t\t\t3'b100: cover(f_posn > DW/8);\n\t\t\t3'b101: cover(f_posn > DW/8);\n\t\t\t3'b110: cover(f_posn > DW/8);\n\t\t\t3'b111: cover(f_posn > DW/8);\n\t\t\tendcase\n\t\tend\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// \"Careless\" assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tcase(f_cfg_size)\n\tSZ_BYTE: begin end\n\tSZ_BUS: begin end\n\tSZ_16B: assume(f_cfg_addr[0] == 1'b0);\n\tSZ_32B: assume(f_cfg_addr[1:0] == 2'b0);\n\tendcase\n\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipdma_rxgears.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma_rxgears.v",
        "chunks": [
            "module zipdma_rxgears #(\n\t\t// {{{",
            "parameter BUS_WIDTH = 64,",
            "parameter [0:0]\tOPT_LITTLE_ENDIAN = 1'b0,\n\t\t// Abbreviations",
            "localparam DW = BUS_WIDTH\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Configuration\n\t\t// {{{",
            "input ",
            "wire i_soft_reset,\n\t\t// }}}\n\t\t// Incoming Stream interface\n\t\t// {{{",
            "input ",
            "wire S_VALID,",
            "output ",
            "wire S_READY,",
            "input ",
            "wire [DW-1:0]\tS_DATA,\n\t\t// How many bytes are valid?",
            "input ",
            "wire [$clog2(DW/8):0]\tS_BYTES,",
            "input ",
            "wire S_LAST,\n\t\t// }}}\n\t\t// Outgoing Stream interface\n\t\t// {{{",
            "output ",
            "wire M_VALID,",
            "input ",
            "wire M_READY,",
            "output ",
            "wire [DW-1:0]\tM_DATA,\n\t\t// How many bytes are valid?",
            "output ",
            "wire [$clog2(DW/8):0]\tM_BYTES,",
            "output ",
            "wire M_LAST\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "localparam WBLSB = $clog2(DW/8);",
            "reg [2*DW-1:0]\t\ts",
            "reg ;",
            "reg [WBLSB+1:0]\t\tnext_fill, fill;",
            "reg m_valid, m_last, next_last,\n\t\t\t\t\tr_last, r_full;",
            "reg [WBLSB:0]\t\tm_bytes;",
            "reg [WBLSB-1:0]\t\tshift;",
            "reg [DW-1:0]\ts_data;\n\tinteger\t\t\tik;\n\n\t// }}}\n\n\t// next_fill, next_last\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tnext_fill = fill;\n\t\tif (M_VALID && M_READY)\n\t\tbegin\n\t\t\tif (M_LAST)\n\t\t\t\tnext_fill = 0;\n\t\t\telse\n\t\t\t\tnext_fill[WBLSB+1:WBLSB]\n\t\t\t\t\t\t= next_fill[WBLSB+1:WBLSB] - 1;\n\t\tend\n\n\t\tif (S_VALID && S_READY)\n\t\t\tnext_fill = next_fill + S_BYTES;\n\n\t\tnext_last = 0;\n\t\tif (S_VALID && S_READY && S_LAST)\n\t\t\tnext_last = (next_fill[WBLSB+1:WBLSB] == 2'b00)\n\t\t\t\t\t||((next_fill[WBLSB+1:WBLSB] == 2'b01)\n\t\t\t\t\t\t&&(next_fill[WBLSB-1:0] == 0));\n\t\t\t\t\t// Was next_fill <= DW/8);\n\tend\n\t// }}}\n\n\t// fill\n\t// {{{\n\tinitial\tfill = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\t\tfill <= 0;\n\telse\n\t\tfill <= next_fill;\n`ifdef\tFORMAL\n\talways @(*)\n\t\tassert(fill < 2*DW/8);\n`endif\n\t// }}}\n\n\t// r_full\n\t// {{{\n/*\n\t// This isn't necessary, since r_full == fill[WBLSB];\n\tinitial\tr_full = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\t\tr_full <= 0;\n\telse if (M_VALID && M_READY)\n\t\tr_full <= 1'b0;\n\telse if (S_VALID && S_READY)\n\t\tr_full <= (next_fill >= (DW/8));\n*/\n\talways @(*)\n\t\t// Verilator lint_off WIDTH\n\t\tr_full = (fill >= (DW/8));\n\t\t// Verilator lint_on  WIDTH\n\t// }}}\n\n\t// m_valid\n\t// {{{\n\tinitial\tm_valid = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\t\tm_valid <= 0;\n\telse if (!M_VALID || M_READY)\n\t\tm_valid <= r_last || (S_VALID && S_READY && S_LAST)\n\t\t\t|| (|next_fill[WBLSB+1:WBLSB]);\n`ifdef\tFORMAL\n\talways @(*)\n\tif (fill >= (DW/8) || r_last || m_last)\n\t\tassert(m_valid);\n\n\talways @(*)\n\tif (m_last)\n\t\tassert(m_bytes == fill);\n`endif\n\t// }}}\n\n\t// m_bytes\n\t// {{{\n\tinitial\tm_bytes = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\t\tm_bytes <= 0;\n\telse if (!M_VALID || M_READY)\n\t\tm_bytes <= (|next_fill[WBLSB+1:WBLSB])\n\t\t\t\t? { 1'b1, {(WBLSB){1'b0}} } // DW/8\n\t\t\t\t: { 1'b0, next_fill[WBLSB-1:0] };\n\t\t// m_bytes <= (next_fill > (DW/8)) ? DW/8 : next_fill;\n\t// }}}\n\n\t// r_last, m_last\n\t// {{{\n\tinitial\t{ r_last, m_last } = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\t\t{ r_last, m_last } <= 0;\n\telse if (S_VALID && S_READY && S_LAST)\n\t\t{ r_last, m_last } <= { !next_last, next_last };\n\telse if (M_VALID && M_READY)\n\t\t{ r_last, m_last } <= { 1'b0, r_last };\n\t// }}}\n\n\t// s",
            "reg // {{{\n\talways @(*)\n\tbegin\n\t\ts_data = 0;\n\t\tfor(ik=0; ik<DW/8; ik=ik+1)\n\t\tif (ik < S_BYTES)\n\t\tbegin\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\t\ts_data[ik*8 +: 8] = S_DATA[ik*8 +: 8];\n\t\t\telse\n\t\t\t\ts_data[(DW/8-1-ik)*8 +: 8]\n\t\t\t\t\t\t= S_DATA[(DW/8-1-ik)*8 +: 8];\n\t\tend\n\tend\n\n\talways @(*)\n\tbegin\n\t\tshift = fill[WBLSB-1:0];\n\t\tif (M_VALID && M_READY)\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tshift = fill - DW/8;\n\t\t\t// Verilator lint_on  WIDTH\n\tend\n\n\tinitial\ts",
            "reg = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\t\ts",
            "reg <= 0;\n\telse if (M_VALID && M_READY && M_LAST)\n\t\ts",
            "reg <= 0;\n\telse if (OPT_LITTLE_ENDIAN)\n\tbegin\n\t\t// {{{\n\t\tif (M_VALID && M_READY)\n\t\tbegin\n\t\t\tif (S_VALID && S_READY)\n\t\t\t\t// Verilator lint_off WIDTH\n\t\t\t\ts",
            "reg <= { {(DW){1'b0}}, s",
            "reg [2*DW-1:DW] }\n\t\t\t\t\t| ({{(DW){1'b0}}, s_data } << (shift*8));\n\t\t\t\t// Verilator lint_on  WIDTH\n\t\t\telse\n\t\t\t\ts",
            "reg <= { {(DW){1'b0}}, s",
            "reg [2*DW-1:DW] };\n\t\tend else if (S_VALID && S_READY)\n\t\t\ts",
            "reg <= s",
            "reg | ({ {(DW){1'b0}}, s_data } << shift*8);\n\t\t// }}}\n\tend else begin\n\t\tif (M_VALID && M_READY)\n\t\tbegin\n\t\t\tif (S_VALID && S_READY)\n\t\t\t\t// Verilator lint_off WIDTH\n\t\t\t\ts",
            "reg <= { s",
            "reg [DW-1:0], {(DW){1'b0}} }\n\t\t\t\t\t| ({s_data, {(DW){1'b0}} } >>(shift*8));\n\t\t\t\t// Verilator lint_on  WIDTH\n\t\t\telse\n\t\t\t\ts",
            "reg <= { s",
            "reg [DW-1:0], {(DW){1'b0}} };\n\t\tend else if (S_VALID && S_READY)\n\t\t\t// Verilator lint_off WIDTH\n\t\t\ts",
            "reg <= s",
            "reg | ({ s_data, {(DW){1'b0}} } >> (shift*8));\n\t\t\t// Verilator lint_on  WIDTH\n\tend\n\t// Verilator lint_on  WIDTH\n\t// }}}\n\n\tassign\tM_VALID = m_valid;\n\tassign\tM_DATA  = (OPT_LITTLE_ENDIAN) ? s",
            "reg [DW-1:0] : s",
            "reg [2*DW-1:DW];\n\tassign\tM_BYTES = m_bytes;\n\tassign\tM_LAST  = m_last;\n\n\tassign\tS_READY = (!M_LAST && !r_last)\n\t\t\t\t&& (!M_VALID || (M_READY || !r_full));\n\t\t\t\t//\t|| (S_BYTES + fill < 2*DW/8))));\n\n\t// Keep Verilator happy\n\t// {{{\n\t//",
            "wire unused;\n\t// assign\tunused = &{ 1'b0, ... };\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "localparam F_LGCOUNT = 16;",
            "reg f_past_valid;",
            "reg [F_LGCOUNT-1:0]\tf_rcvd, f_sent;\n\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Incoming stream properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset || i_soft_reset))\n\t\tassume(!S_VALID);\n\telse if ($past(S_VALID && !S_READY))\n\tbegin\n\t\tassume(S_VALID);\n\t\tassume($stable(S_DATA));\n\t\tassume($stable(S_BYTES));\n\t\tassume($stable(S_LAST));\n\tend\n\n\talways @(*)\n\tif (!i_reset && S_VALID)\n\tbegin\n\t\tassume(S_BYTES <= (DW/8));\n\t\tassume(S_BYTES > 0);\n\tend\n\n\tinitial\tf_rcvd = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\t\tf_rcvd <= 0;\n\telse if (S_VALID && S_READY)\n\tbegin\n\t\tif (S_LAST)\n\t\t\tf_rcvd <= 0;\n\t\telse\n\t\t\tf_rcvd <= f_rcvd + S_BYTES;\n\tend\n\n\talways @(*)\n\tbegin\n\t\tassume(!f_rcvd[F_LGCOUNT-1]);\n\t\tassume({ 1'b0, f_rcvd } + (S_VALID ? S_BYTES : 0)\n\t\t\t\t\t\t< (1<<(F_LGCOUNT-1)));\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Outgoing stream properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset || i_soft_reset))\n\tbegin\n\t\tassert(!M_VALID);\n\t\tassert(!r_last);\n\t\tassert(!M_LAST);\n\tend else if ($past(M_VALID && !M_READY))\n\tbegin\n\t\tassert(M_VALID);\n\t\tassert($stable(M_DATA));\n\t\tassert($stable(M_BYTES));\n\t\tassert($stable(M_LAST));\n\tend\n\n\talways @(*)\n\tif (!i_reset && M_VALID)\n\tbegin\n\t\tassert(M_BYTES <= (DW/8));\n\t\tassert(M_BYTES > 0);\n\n\t\tif (!M_LAST)\n\t\t\tassert(M_BYTES == (DW/8));\n\tend\n\n\tinitial\tf_sent = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\t\tf_sent <= 0;\n\telse if (M_VALID && M_READY)\n\tbegin\n\t\tif (M_LAST)\n\t\t\tf_sent <= 0;\n\t\telse\n\t\t\tf_sent <= f_sent + M_BYTES;\n\tend",
            "reg [F_LGCOUNT-1:0]\tf_buffered;\n\n\talways @(*)\n\tbegin\n\t\tf_buffered = f_sent + fill;\n\n\t\tassert(!f_sent[F_LGCOUNT-1]);\n\t\tassert(!f_buffered[F_LGCOUNT-1]);\n\n\t\tassert(f_buffered >= f_sent);\n\n\t\tassert(f_sent[WBLSB-1:0] == 0);\n\tend\n\n\talways @(*)\n\tif (!i_reset)\n\tbegin\n\t\tif (!m_last && !r_last)\n\t\tbegin\n\t\t\tassert(f_sent + fill == f_rcvd);\n\t\t\tassert(f_sent <= f_rcvd);\n\t\tend\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Induction properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (!i_reset)\n\tbegin\n\t\tassert(!r_last || !M_LAST);\n\n\t\tif (r_last)\n\t\t\tassert(M_VALID && fill > (DW/8));\n\tend\n\n\talways @(*)\n\tif (!i_reset)\n\tbegin\n\t\tif (fill > (DW/8))\n\t\t\tassert(M_BYTES == (DW/8));\n\t\telse\n\t\t\tassert(M_BYTES == fill);\n\tend\n\n\talways @(*)\n\tif (!i_reset && (r_last || M_LAST))\n\t\tassert(f_rcvd == 0);\n\telse if (!i_reset)\n\t\tassert(fill[WBLSB-1:0] == f_rcvd[WBLSB-1:0]);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t(* anyconst *)",
            "reg fc_check;\n\t(* anyconst *)",
            "reg [F_LGCOUNT-1:0]\tfc_posn;\n\t(* anyconst *)",
            "reg [7:0]\t\tfc_byte;",
            "wire frx_check, ftx_check;",
            "reg [WBLSB-1:0]\tfrx_shift;",
            "reg [WBLSB+1:0]\tftx_shift;",
            "reg [DW-1:0]\tfrx_shifted;",
            "reg [2*DW-1:0]\tftx_shifted;\n\n\talways @(*)\n\t\tfrx_shift = fc_posn [WBLSB-1:0]- f_rcvd[WBLSB-1:0];\n\n\talways @(*)\n\tif (OPT_LITTLE_ENDIAN)\n\t\tfrx_shifted = S_DATA >> (8*frx_shift);\n\telse\n\t\tfrx_shifted = S_DATA << (8*frx_shift);\n\n\tassign\tfrx_check = fc_check && S_VALID && f_rcvd <= fc_posn\n\t\t\t\t\t&& (fc_posn < f_rcvd + S_BYTES);\n\n\talways @(*)\n\tif (!i_reset && frx_check)\n\tbegin\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tassume(frx_shifted[7:0] == fc_byte);\n\t\tend else begin\n\t\t\tassume(frx_shifted[DW-1:DW-8] == fc_byte);\n\t\tend\n\tend\n\n\talways @(*)\n\tbegin\n\t\tftx_shift = fc_posn[WBLSB:0]- f_sent[WBLSB:0];\n\t\tftx_shift[WBLSB+1] = 0;\n\tend\n\n\talways @(*)\n\tif (OPT_LITTLE_ENDIAN)\n\t\tftx_shifted = s",
            "reg >> (8*ftx_shift);\n\telse\n\t\tftx_shifted = s",
            "reg << (8*ftx_shift);\n\n\tassign\tftx_check = fc_check && f_sent <= fc_posn\n\t\t\t\t\t&& (fc_posn < f_sent + fill);\n\n\talways @(*)\n\tif (!i_reset && ftx_check)\n\tbegin\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tassert(ftx_shifted[7:0] == fc_byte);\n\t\tend else begin\n\t\t\tassert(ftx_shifted[2*DW-1:2*DW-8] == fc_byte);\n\t\tend\n\tend\n\n\talways @(*)\n\tif (!i_reset)\n\tbegin\n\t\tfor(ik=0; ik<2*DW/8; ik=ik+1)\n\t\tif (fill <= ik)\n\t\tbegin\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\t\tassert(s",
            "reg [8*ik +: 8] == 8'h00);\n\t\t\telse\n\t\t\t\tassert(s",
            "reg [2*DW-8-8*ik +: 8] == 8'h00);\n\t\tend\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// \"Careless\" assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipdma_mm2s.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma_mm2s.v",
        "chunks": [
            "module zipdma_mm2s #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH = 30,",
            "parameter BUS_WIDTH = 64,",
            "parameter LGLENGTH = 10,",
            "parameter [0:0]\tOPT_LITTLE_ENDIAN = 1'b0,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,",
            "parameter [0:0] OPT_FIRSTBEAT_TRIM = 1'b0,\n\t\t// Abbreviations",
            "localparam DW = BUS_WIDTH,",
            "localparam AW = ADDRESS_WIDTH-$clog2(DW/8)\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Configuration\n\t\t// {{{",
            "input ",
            "wire i_request,",
            "output ",
            "reg o_busy, o_err,",
            "input ",
            "wire i_inc,\n\t\t// # of transferred byte per beat",
            "input ",
            "wire [1:0]\t\ti_size,",
            "input ",
            "wire [LGLENGTH:0]\ti_transferlen,",
            "input ",
            "wire [ADDRESS_WIDTH-1:0]\ti_addr,\t// Byte address\n\t\t// }}}\n\t\t// Wishbone master interface\n\t\t// {{{",
            "output ",
            "reg o_rd_cyc, o_rd_stb,\n\t\t// Verilator coverage_off",
            "output ",
            "wire o_rd_we,\n\t\t// Verilator coverage_on",
            "output ",
            "reg [AW-1:0]\to_rd_addr,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [DW-1:0]\to_rd_data,\n\t\t// Verilator coverage_on",
            "output ",
            "reg [DW/8-1:0]\to_rd_sel,",
            "input ",
            "wire i_rd_stall,",
            "input ",
            "wire i_rd_ack,",
            "input ",
            "wire [DW-1:0]\ti_rd_data,",
            "input ",
            "wire i_rd_err,\n\t\t// }}}\n\t\t// Outgoing Stream interface\n\t\t// {{{",
            "output ",
            "wire M_VALID,",
            "input ",
            "wire M_READY,\t// *MUST* be 1",
            "output ",
            "wire [DW-1:0]\tM_DATA,\n\t\t// How many bytes are valid?",
            "output ",
            "wire [$clog2(DW/8):0]\tM_BYTES,",
            "output ",
            "wire M_LAST\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{\n\t// size prefix is # of valid bytes in the beat (one clk cycle)\n\t// difference between _size and _len is that \"size\" references the\n\t// current beat, whereas _len references the whole transfer.  _sel\n\t// references which data byte lanes are valid (like WSTRB from AXI\n\t// interface)\n\t//",
            "localparam [1:0]\tSZ_BYTE = 2'b11,\n\t\t\t\tSZ_16B  = 2'b10,\n\t\t\t\tSZ_32B  = 2'b01,\n\t\t\t\tSZ_BUS  = 2'b00;",
            "localparam WBLSB = $clog2(DW/8);",
            "reg [WBLSB:0]\tnxtstb_size, rdstb_size, rdack_size,\n\t\t\t\tfirst_size, last_size;",
            "reg r_wrap;",
            "reg [ADDRESS_WIDTH:0]\tnext_addr;",
            "reg [ADDRESS_WIDTH-1:0]\tlast_request_addr;",
            "reg [WBLSB-1:0]\tsubaddr, rdack_subaddr;",
            "reg [DW/8-1:0]\tnxtstb_sel, first_sel, first_sel_no_shift,\n\t\t\t\tbase_sel, ibase_sel;",
            "reg [LGLENGTH:0]\twb_outstanding;",
            "reg [WBLSB+1:0]\tfill, next_fill;",
            "reg m_valid, m_last;",
            "reg [DW-1:0]\ts",
            "reg ;",
            "reg [WBLSB:0]\tm_bytes;",
            "reg [LGLENGTH:0]\trdstb_len, rdack_len;",
            "reg [WBLSB-1:0]\tpre_shift;",
            "reg [DW-1:0]\tpre_shifted_data;",
            "reg r_inc;",
            "reg [1:0]\t\tr_size;",
            "reg [LGLENGTH:0]\tr_transferlen;",
            "reg [ADDRESS_WIDTH-1:0]\tr_addr;\n\t// }}}\n\n\tassign\to_rd_we = 1'b0;\n\tassign\to_rd_data = {(DW){1'b0}};\n\n\t// Copy the configuration whenever i_request && !o_busy\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!o_busy && (!OPT_LOWPOWER || i_request))\n\tbegin\n\t\tr_inc  <= i_inc;\n\t\tr_size <= i_size;\n\t\tr_transferlen <= i_transferlen;\n\t\tr_addr <= i_addr;\n\tend\n\t// }}}\n\n\t// nxtstb_size\n\t// {{{\n\tgenerate if (BUS_WIDTH > 32)\n\tbegin : GEN_NXTSTB_SIZE\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tfirst_size = 0;\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE: first_size = 1;\n\t\t\tSZ_16B:  first_size = (i_addr[0]) ? 1 : 2;\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tSZ_32B:  first_size = 4 - i_addr[1:0];\n\t\t\tSZ_BUS:  first_size = (DW/8)-i_addr[WBLSB-1:0];\n\t\t\t// Verilator lint_on  WIDTH\n\t\t\tendcase\n\n\t\t\tif ({{ (LGLENGTH-WBLSB){1'b0}}, first_size } > i_transferlen)\n\t\t\t\tfirst_size = i_transferlen[WBLSB:0];\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tnxtstb_size = rdstb_size;\n\t\t\tlast_size = r_addr[WBLSB-1:0]+ r_transferlen[WBLSB-1:0];\n\n\t\t\tcase(r_size)\n\t\t\tSZ_BYTE: nxtstb_size = 1;\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tSZ_16B: if (r_transferlen == 2)\n\t\t\t\t\tnxtstb_size = 2 - r_addr[0];\n\t\t\t\telse if (r_transferlen == 3)\n\t\t\t\t\tnxtstb_size = r_addr[0] + 1;\n\t\t\t\telse\n\t\t\t\t\tnxtstb_size = (rdstb_len == 3) ? 1 : 2;\n\t\t\tSZ_32B: begin\n\t\t\t\tlast_size[WBLSB:2] = 0;\n\t\t\t\tif (r_transferlen < 8)\n\t\t\t\tbegin\n\t\t\t\t\tif (r_transferlen[1:0] + r_addr[1:0] == 0)\n\t\t\t\t\t\tnxtstb_size = 4;\n\t\t\t\t\telse\n\t\t\t\t\t\tnxtstb_size = (4 > rdstb_len - rdstb_size) ? last_size : 4;\n\t\t\t\tend else\n\t\t\t\t\tnxtstb_size = (rdstb_len >= 4 && rdstb_len < 8)\n\t\t\t\t\t\t? (rdstb_len - 4) : 4;\n\t\t\t\tend\n\t\t\tSZ_BUS: begin\n\t\t\t\tnxtstb_size = (DW/8);\n\t\t\t\tif (DW/8 > rdstb_len - rdstb_size)\n\t\t\t\t\tnxtstb_size= { 1'b0,rdstb_len[WBLSB:0] }\n\t\t\t\t\t\t- { 1'b0, rdstb_size[WBLSB:0]};\n\t\t\t\tend\n\t\t\t// Verilator lint_on  WIDTH\n\t\t\tendcase\n\t\tend\n\t\t// }}}\n\tend else begin : STD_NXTSTB_SIZE\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tfirst_size = 0;\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE: first_size = 1;\n\t\t\tSZ_16B:  first_size = (i_addr[0]) ? 1:2;\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tdefault:\n\t\t\t\tfirst_size = (DW/8)-i_addr[WBLSB-1:0];\n\t\t\tendcase\n\n\t\t\tif (first_size > i_transferlen)\n\t\t\t\tfirst_size = i_transferlen;\n\t\t\t// Verilator lint_on  WIDTH\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tnxtstb_size = rdstb_size;\n\t\t\tlast_size = r_addr[WBLSB-1:0]+r_transferlen[WBLSB-1:0];\n\n\t\t\tcasez(r_size)\n\t\t\tSZ_BYTE: nxtstb_size = 1;\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tSZ_16B: if (r_transferlen == 2)\n\t\t\t\t\tnxtstb_size = 2 - r_addr[0];\n\t\t\t\telse if (r_transferlen == 3)\n\t\t\t\t\tnxtstb_size = r_addr[0] + 1;\n\t\t\t\telse\n\t\t\t\t\tnxtstb_size = (rdstb_len == 3) ? 1 : 2;\n\t\t\tdefault: begin\n\t\t\t\tlast_size[WBLSB:2] = 0;\n\t\t\t\tif (r_transferlen < 8)\n\t\t\t\tbegin\n\t\t\t\t\tif (r_transferlen[1:0] + r_addr[1:0] == 0)\n\t\t\t\t\t\tnxtstb_size = 4;\n\t\t\t\t\telse\n\t\t\t\t\t\tnxtstb_size = (4 > rdstb_len - rdstb_size) ? last_size : 4;\n\t\t\t\tend else\n\t\t\t\t\tnxtstb_size = (rdstb_len >= 4\n\t\t\t\t\t\t\t&& rdstb_len < 8)\n\t\t\t\t\t\t? (rdstb_len - 4) : 4;\n\t\t\t\tend\n\t\t\t\t// Verilator lint_on  WIDTH\n\t\t\tendcase\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// next_addr\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tnext_addr = { 1'b0, o_rd_addr, subaddr };\n\n\t\tif (o_rd_stb && !i_rd_stall && r_inc)\n\t\t\tnext_addr = next_addr\n\t\t\t+ { {(ADDRESS_WIDTH-WBLSB-1){1'b0}}, rdstb_size };\n\tend\n\t// }}}\n\n\t// o_rd_cyc, o_rd_stb, o_busy, o_err, rdstb_len, rdstb_size\n\t// {{{\n\tinitial\t{ o_rd_cyc, o_rd_stb } = 2'b00;\n\tinitial\t{ o_busy, o_err } = 2'b00;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\t// {{{\n\t\to_rd_cyc <= 1'b0;\n\t\to_rd_stb <= 1'b0;\n\t\t{ o_rd_addr, subaddr } <= 0;\n\n\t\trdstb_size <= 0;\n\t\trdstb_len  <= 0;\n\t\to_busy     <= 0;\n\t\to_err      <= 0;\n\t\t// }}}\n\tend else if ((o_rd_cyc && i_rd_err) || o_err)\n\tbegin\n\t\t// {{{\n\t\to_rd_cyc <= 1'b0;\n\t\to_rd_stb <= 1'b0;\n\t\t{ o_rd_addr, subaddr } <= 0;\n\n\t\trdstb_size <= 0;\n\t\trdstb_len  <= 0;\n\n\t\to_busy <= o_rd_cyc && i_rd_err;\n\t\to_err  <= o_rd_cyc && i_rd_err;\n\t\t// }}}\n\tend else if (!o_busy)\n\tbegin\n\t\t// {{{\n\t\to_rd_cyc <= i_request;\n\t\to_rd_stb <= i_request;\n\t\to_busy   <= i_request;\n\t\to_err    <= 0;\n\n\t\trdstb_size <= 0;\n\t\trdstb_len  <= 0;\n\t\tif (!OPT_LOWPOWER || i_request)\n\t\tbegin\n\t\t\t{ o_rd_addr, subaddr } <= i_addr;\n\n\t\t\t// rdstb_size\n\t\t\trdstb_size <= first_size;\n\n\t\t\t// rdstb_len\n\t\t\trdstb_len <= i_transferlen;\n\t\tend\n\t\t// }}}\n\tend else begin\n\t\tif (!i_rd_stall)\n\t\t\to_rd_stb <= 1'b0;\n\n\t\tif (rdstb_len > { {(LGLENGTH-WBLSB){1'b0}}, rdstb_size })\n\t\tbegin\n\t\t\tif (r_wrap || next_addr[ADDRESS_WIDTH])\n\t\t\t\t{ o_err, o_rd_cyc, o_rd_stb } <= 3'b100;\n\t\t\telse\n\t\t\t\to_rd_stb <= 1'b1;\n\t\tend\n\n\t\tif (o_rd_stb && !i_rd_stall)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tif (rdstb_len <= { {(LGLENGTH-WBLSB){1'b0}}, rdstb_size })\n\t\t\tbegin\n\t\t\t\trdstb_len <= 0;\n\t\t\tend else begin\n\t\t\t\trdstb_len <= rdstb_len\n\t\t\t\t\t- { {(LGLENGTH-WBLSB){1'b0}}, rdstb_size };\n\t\t\tend\n\n\t\t\t// rdstb_size\n\t\t\trdstb_size <= nxtstb_size;\n\n\t\t\t{ o_rd_addr, subaddr } <= next_addr[ADDRESS_WIDTH-1:0];\n\t\t\t// }}}\n\t\tend\n\n\t\tif (wb_outstanding == (i_rd_ack ? 1:0) && !o_rd_stb)\n\t\t\to_rd_cyc <= 1'b0;\n\n\t\tif (m_valid && m_last)\n\t\t\to_busy <= 0;\n\tend\n\n\tinitial\tr_wrap = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || (o_rd_cyc && i_rd_err) || o_err || !o_busy)\n\t\tr_wrap <= 1'b0;\n\telse if (o_rd_stb && !i_rd_stall)\n\t\tr_wrap <= next_addr[ADDRESS_WIDTH];\n`ifdef\tFORMAL\n\talways @(*)\n\tif (o_busy && m_valid && m_last)\n\tbegin\n\t\tassert(rdack_len == 0);\n\t\tassert(fill == m_bytes);\n\tend\n`endif\n\t// }}}\n\n\t// o_rd_sel\n\t// {{{\n\n\t// ibase_sel\n\tgenerate if (BUS_WIDTH > 32)\n\tbegin : GEN_STRB\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tibase_sel = 0;\n\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\t// Verilator coverage_off\n\t\t\t\tcase(i_size)\n\t\t\t\tSZ_BYTE: ibase_sel = {{(DW/8-1){1'b0}}, 1'b1} << i_addr[WBLSB-1:0];\n\t\t\t\tSZ_16B: ibase_sel = {{(DW/8-2){1'b0}}, 2'h3} << {i_addr[WBLSB-1:1], 1'b0 };\n\t\t\t\tSZ_32B: ibase_sel = {{(DW/8-4){1'b0}}, 4'b1111} << {i_addr[WBLSB-1:2], 2'b0 };\n\t\t\t\tSZ_BUS: ibase_sel = {(DW/8){1'b1}};\n\t\t\t\tendcase\n\t\t\t\t// Verilator coverage_on\n\t\t\t\t// }}}\n\t\t\tend else begin\n\t\t\t\t// {{{\n\t\t\t\tcase(i_size)\n\t\t\t\tSZ_BYTE: ibase_sel = {1'h1, {(DW/8-1){1'b0}} } >> i_addr[WBLSB-1:0];\n\t\t\t\tSZ_16B: ibase_sel = {2'h3, {(DW/8-2){1'b0}} } >> {i_addr[WBLSB-1:1], 1'b0 };\n\t\t\t\tSZ_32B: ibase_sel = {4'hf, {(DW/8-4){1'b0}} } >> {i_addr[WBLSB-1:2], 2'b0 };\n\t\t\t\tSZ_BUS: ibase_sel = {(DW/8){1'b1}};\n\t\t\t\tendcase\n\t\t\t\t// }}}\n\t\t\tend\n\t\tend\n\t\t// }}}\n\tend else begin : MIN_STRB\n\t\t// {{{\n\t\talways @(*)\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\t// {{{\n\t\t\t// Verilator coverage_off\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE: ibase_sel = {{(DW/8-1){1'b0}}, 1'b1} << i_addr[WBLSB-1:0];\n\t\t\tSZ_16B: ibase_sel = {{(DW/8-2){1'b0}}, 2'h3} << {i_addr[WBLSB-1:1], 1'b0 };\n\t\t\tdefault: ibase_sel = {(DW/8){1'b1}};\n\t\t\tendcase\n\t\t\t// Verilator coverage_on\n\t\t\t// }}}\n\t\tend else begin\n\t\t\t// {{{\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE: ibase_sel= {1'h1, {(DW/8-1){1'b0}} } << i_addr[WBLSB-1:0];\n\t\t\tSZ_16B: ibase_sel = {2'h3, {(DW/8-2){1'b0}} } << {i_addr[WBLSB-1:1], 1'b0 };\n\t\t\tdefault: ibase_sel = {(DW/8){1'b1}};\n\t\t\tendcase\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\talways @(posedge i_clk)\n\tif (i_reset || (o_rd_cyc && i_rd_err))\n\tbegin\n\t\tbase_sel <= 0;\n\tend else if (!o_busy)\n\tbegin\n\t\tbase_sel <= 0;\n\t\tif (i_request || !OPT_LOWPOWER)\n\t\t\tbase_sel <= ibase_sel;\n\tend else if (o_rd_stb && !i_rd_stall)\n\t\tbase_sel <= nxtstb_sel;\n\n\t// nxtstb_sel\n\t// {{{\n\tgenerate if (DW == 32)\n\tbegin : GEN_NXTSTB_SEL\n\t\t// {{{\n\t\talways @(*)\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\t// Verilator coverage_off\n\t\t\tcase(r_size)\n\t\t\tSZ_BYTE: nxtstb_sel = { base_sel[DW/8-2:0], base_sel[DW/8-1] };\n\t\t\tSZ_16B:  nxtstb_sel = { base_sel[DW/8-3:0], base_sel[DW/8-1:DW/8-2] };\n\t\t\tdefault: nxtstb_sel = {(DW/8){1'b1}};\n\t\t\tendcase\n\n\t\t\tif (!r_inc)\n\t\t\t\tnxtstb_sel = base_sel;\n\t\t\t// Verilator coverage_on\n\t\tend else begin\n\t\t\tcase(r_size)\n\t\t\tSZ_BYTE: nxtstb_sel = { base_sel[0:0], base_sel[DW/8-1:1] };\n\t\t\tSZ_16B:  nxtstb_sel = { base_sel[1:0], base_sel[DW/8-1:2] };\n\t\t\tdefault:\n\t\t\t\tnxtstb_sel = {(DW/8){1'b1}};\n\t\t\tendcase\n\n\t\t\tif (!r_inc)\n\t\t\t\tnxtstb_sel = base_sel;\n\t\tend\n\t\t// }}}\n\tend else begin : GEN_WIDE_NXTSTB_SEL\n\t\talways @(*)\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\t// Verilator coverage_off\n\t\t\tcase(r_size)\n\t\t\tSZ_BYTE: nxtstb_sel = { base_sel[DW/8-2:0], base_sel[DW/8-1] };\n\t\t\tSZ_16B:  nxtstb_sel = { base_sel[DW/8-3:0], base_sel[DW/8-1:DW/8-2] };\n\t\t\tSZ_32B:  nxtstb_sel = { base_sel[DW/8-5:0], base_sel[DW/8-1:DW/8-4] };\n\t\t\tSZ_BUS:  nxtstb_sel = {(DW/8){1'b1}};\n\t\t\tendcase\n\n\t\t\tif (!r_inc)\n\t\t\t\tnxtstb_sel = base_sel;\n\t\t\t// Verilator coverage_on\n\t\tend else begin\n\t\t\tcase(r_size)\n\t\t\tSZ_BYTE: nxtstb_sel = { base_sel[0:0], base_sel[DW/8-1:1] };\n\t\t\tSZ_16B:  nxtstb_sel = { base_sel[1:0], base_sel[DW/8-1:2] };\n\t\t\tSZ_32B:  nxtstb_sel = { base_sel[3:0], base_sel[DW/8-1:4] };\n\t\t\tSZ_BUS:  nxtstb_sel = {(DW/8){1'b1}};\n\t\t\tendcase\n\n\t\t\tif (!r_inc)\n\t\t\t\tnxtstb_sel = base_sel;\n\t\tend\n\tend endgenerate\n\t// }}}\n\n\t// first_sel\n\tgenerate if (BUS_WIDTH > 32)\n\tbegin : GEN_FIRST_SEL\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tfirst_sel_no_shift = 0;\n\t\t\tfirst_sel = 0;\n\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tif (!OPT_FIRSTBEAT_TRIM || i_transferlen >= DW/8)\n\t\t\t\tfirst_sel_no_shift = -1;\n\t\t\telse if (OPT_LITTLE_ENDIAN)\n\t\t\t\tfirst_sel_no_shift = (1 << i_transferlen) - 1;\n\t\t\telse\n\t\t\t\tfirst_sel_no_shift = ({(DW/8){1'b1}} << (DW/8 - i_transferlen));\n\t\t\t// Verilator lint_on  WIDTH\n\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\t// Verilator coverage_off\n\t\t\t\tcase(i_size)\n\t\t\t\tSZ_BYTE: first_sel = {{(DW/8-1){1'b0}}, 1'b1} << i_addr[WBLSB-1:0];\n\t\t\t\tSZ_16B: begin\n\t\t\t\t\tfirst_sel_no_shift = first_sel_no_shift << i_addr[0];\n\t\t\t\t\tfirst_sel_no_shift[DW/8-1:2] = 0;\n\t\t\t\t\tfirst_sel = first_sel_no_shift << {i_addr[WBLSB-1:1], 1'b0 };\n\t\t\t\t\tend\n\t\t\t\tSZ_32B: begin\n\t\t\t\t\tfirst_sel_no_shift = first_sel_no_shift << i_addr[1:0];\n\t\t\t\t\tfirst_sel_no_shift[DW/8-1:4] = 0;\n\t\t\t\t\tfirst_sel = first_sel_no_shift << {i_addr[WBLSB-1:2], 2'b00 };\n\t\t\t\t\tend\n\t\t\t\tSZ_BUS: first_sel = first_sel_no_shift << i_addr[WBLSB-1:0];\n\t\t\t\tendcase\n\t\t\t\t// Verilator coverage_on\n\t\t\t\t// }}}\n\t\t\tend else begin\n\t\t\t\t// {{{\n\t\t\t\tcase(i_size)\n\t\t\t\tSZ_BYTE: first_sel = {1'b1, {(DW/8-1){1'b0}} } >> i_addr[WBLSB-1:0];\n\t\t\t\tSZ_16B: begin\n\t\t\t\t\tfirst_sel_no_shift = first_sel_no_shift >> i_addr[0];\n\t\t\t\t\tfirst_sel_no_shift[DW/8-3:0] = 0;\n\t\t\t\t\tfirst_sel = first_sel_no_shift >> {i_addr[WBLSB-1:1], 1'b0 };\n\t\t\t\t\tend\n\t\t\t\tSZ_32B: begin\n\t\t\t\t\tfirst_sel_no_shift = first_sel_no_shift >> i_addr[1:0];\n\t\t\t\t\tfirst_sel_no_shift[DW/8-5:0] = 0;\n\t\t\t\t\tfirst_sel = first_sel_no_shift >> {i_addr[WBLSB-1:2], 2'b00 };\n\t\t\t\t\tend\n\t\t\t\tSZ_BUS: first_sel = first_sel_no_shift >> i_addr[WBLSB-1:0];\n\t\t\t\tendcase\n\t\t\t\t// }}}\n\t\t\tend\n\t\tend\n\t\t// }}}\n\tend else begin : MIN_FIRST_SEL\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tfirst_sel_no_shift = 0;\n\t\t\tfirst_sel = 0;\n\n\t\t\tif (!OPT_FIRSTBEAT_TRIM || i_transferlen >= DW/8)\n\t\t\t\tfirst_sel_no_shift = -1;\n\t\t\telse if (OPT_LITTLE_ENDIAN)\n\t\t\t\tfirst_sel_no_shift = (1 << i_transferlen) - 1;\n\t\t\telse\n\t\t\t\tfirst_sel_no_shift = ({(DW/8){1'b1}} << (DW/8 - i_transferlen));\n\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\t// Verilator coverage_off\n\t\t\t\tcase(i_size)\n\t\t\t\tSZ_BYTE: first_sel = {{(DW/8-1){1'b0}}, 1'b1} << i_addr[WBLSB-1:0];\n\t\t\t\tSZ_16B: begin\n\t\t\t\t\tfirst_sel_no_shift = first_sel_no_shift << i_addr[0];\n\t\t\t\t\tfirst_sel_no_shift[DW/8-1:2] = 0;\n\t\t\t\t\tfirst_sel = first_sel_no_shift << {i_addr[WBLSB-1:1], 1'b0 };\n\t\t\t\t\tend\n\t\t\t\tdefault: first_sel = first_sel_no_shift << i_addr[WBLSB-1:0];\n\t\t\t\tendcase\n\t\t\t\t// Verilator coverage_on\n\t\t\t\t// }}}\n\t\t\tend else begin\n\t\t\t\t// {{{\n\t\t\t\tcase(i_size)\n\t\t\t\tSZ_BYTE: first_sel = {1'b1, {(DW/8-1){1'b0}} } >> i_addr[WBLSB-1:0];\n\t\t\t\tSZ_16B: begin\n\t\t\t\t\tfirst_sel_no_shift = first_sel_no_shift >> i_addr[0];\n\t\t\t\t\tfirst_sel_no_shift[DW/8-3:0] = 0;\n\t\t\t\t\tfirst_sel = first_sel_no_shift >> {i_addr[WBLSB-1:1], 1'b0 };\n\t\t\t\t\tend\n\t\t\t\tdefault: first_sel = first_sel_no_shift >> i_addr[WBLSB-1:0];\n\t\t\t\tendcase\n\t\t\t\t// }}}\n\t\t\tend\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\t// o_rd_sel\n\talways @(posedge i_clk)\n\tif (i_reset || (o_rd_cyc && i_rd_err))\n\tbegin\n\t\to_rd_sel   <= 0;\n\tend else if (!o_busy)\n\tbegin\n\t\t// {{{\n\t\to_rd_sel <= {(DW/8){1'b0}};\n\n\t\tif (!OPT_LOWPOWER || i_request)\n\t\t\to_rd_sel <= first_sel;\n\t\t// }}}\n\tend else if (o_rd_stb && !i_rd_stall)\n\t\to_rd_sel <= nxtstb_sel;\n\t// }}}\n\n\t// wb_outstanding\n\t// {{{\n\tinitial\twb_outstanding = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || !o_rd_cyc || i_rd_err)\n\t\twb_outstanding <= 0;\n\t\t// wb_pipeline_full <= 1'b0;\n\telse case({ (o_rd_stb && !i_rd_stall), i_rd_ack })\n\t2'b10: wb_outstanding <= wb_outstanding + 1;\n\t2'b01: wb_outstanding <= wb_outstanding - 1;\n\tdefault: begin end\n\tendcase\n\t// }}}\n\n\t// rdack_subaddr\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!o_busy)\n\tbegin\n\t\tif (!OPT_LOWPOWER || i_request)\n\t\t\trdack_subaddr <= i_addr[WBLSB-1:0];\n\tend else if (i_rd_ack)\n\tbegin\n\t\t// Verilator lint_off WIDTH\n\t\tif (r_inc)\n\t\t\trdack_subaddr <= rdack_subaddr + rdack_size;\n\t\telse case(r_size)\n\t\tSZ_BYTE: begin end\n\t\tSZ_16B: rdack_subaddr[  0] <= 1'b0;\n\t\tSZ_32B: rdack_subaddr[1:0] <= 2'b0;\n\t\tSZ_BUS: rdack_subaddr[WBLSB-1:0] <= {(WBLSB){1'b0}};\n\t\tendcase\n\t\t// Verilator lint_on  WIDTH\n\tend\n\t// }}}\n\n\t// rdack_len\n\t// {{{\n\t// Total length remaining, from the perspective of the bus return.\n\t// Hence, on any bus return, we drop by the number of bytes valid\n\t// in that return, or minus rdack_size.\n\talways @(posedge i_clk)\n\tif (!o_busy)\n\tbegin\n\t\tif (!OPT_LOWPOWER || i_request)\n\t\t\trdack_len <= i_transferlen;\n\tend else if (i_rd_ack)\n\tbegin\n\t\trdack_len <= rdack_len-{ {(LGLENGTH-WBLSB){1'b0}}, rdack_size };\n\t\tif (rdack_len <= { {(LGLENGTH-WBLSB){1'b0}}, rdack_size })\n\t\t\trdack_len <= 0;\n\tend\n\t// }}}\n\n\t// rdack_size\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!o_busy)\n\tbegin\n\t\tif (!OPT_LOWPOWER || i_request)\n\t\t\trdack_size <= first_size;\n\tend else if (i_rd_ack)\n\tbegin\n\t\tcase(r_size)\n\t\tSZ_BYTE:rdack_size <= 1;\n\t\t// Verilator lint_off WIDTH\n\t\tSZ_16B: if (rdack_len > 2 + rdack_size)\n\t\t\t\trdack_size <= 2;\n\t\t\telse\n\t\t\t\trdack_size <= rdack_len - rdack_size;\n\t\tSZ_32B: if (rdack_len > 4 + rdack_size)\n\t\t\t\trdack_size <= 4;\n\t\t\telse\n\t\t\t\trdack_size <= rdack_len - rdack_size;\n\t\tSZ_BUS: if (rdack_len > DW/8 + rdack_size)\n\t\t\t\trdack_size <= DW/8;\n\t\t\telse\n\t\t\t\trdack_size <= rdack_len - rdack_size;\n\t\t\t// Verilator lint_on  WIDTH\n\t\tendcase\n\tend\n\t// }}}\n\n\t// fill, next_fill (depends on rdack_size)\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tnext_fill = (M_VALID) ? 0 : fill;\n\t\tif (i_rd_ack)\n\t\t\tnext_fill = next_fill + { 1'b0, rdack_size };\n\tend\n\n\talways @(posedge i_clk)\n\tif (!o_busy)\n\t\tfill <= 0;\n\telse\n\t\tfill <= next_fill;\n\t// }}}\n\n\t// m_valid\n\t// {{{\n\tinitial\tm_valid = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || !o_busy)\n\t\tm_valid <= 1'b0;\n\telse begin\n\t\tm_valid <= 0;\n\t\tif ((!m_valid || !m_last) && rdack_len == 0 && fill > 0)\n\t\t\tm_valid <= 1;\n\t\telse if (o_rd_cyc && i_rd_ack)\n\t\t\tm_valid <= 1'b1;\n\tend\n\t// }}}\n\n\t// s",
            "reg // {{{\n\tinitial\tpre_shift = 0;\n\talways @(posedge i_clk)\n\tif (!o_busy)\n\tbegin\n\t\tpre_shift <= 0;\n\t\tif (!OPT_LOWPOWER || i_request)\n\t\t\tpre_shift <= i_addr[WBLSB-1:0];\n\tend else if (o_rd_cyc && i_rd_ack)\n\tbegin\n\t\tcase(r_size)\n\t\tSZ_BYTE: pre_shift <= pre_shift + (r_inc ? 1 : 0);\n\t\tSZ_16B:  begin\n\t\t\t// {{{\n\t\t\tpre_shift <= pre_shift + (r_inc ? 2 : 0);\n\t\t\tpre_shift[0] <= 1'b0;\n\t\t\tend\n\t\t\t// }}}\n\t\tSZ_32B:  begin\n\t\t\t// {{{\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tpre_shift <= pre_shift + (r_inc ? 4 : 0);\n\t\t\t// Verilator lint_on  WIDTH\n\t\t\tpre_shift[1:0] <= 2'b0;\n\t\t\tend\n\t\t\t// }}}\n\t\tSZ_BUS:  pre_shift <= 0;\n\t\tendcase\n\tend\n\n\talways @(*)\n\tif (OPT_LITTLE_ENDIAN)\n\t\tpre_shifted_data = i_rd_data >> (8*pre_shift);\n\telse\n\t\tpre_shifted_data = i_rd_data << (8*pre_shift);\n\n\tinitial\ts",
            "reg = 0;\n\talways @(posedge i_clk)\n\tif (!o_busy)\n\t\ts",
            "reg <= 0;\n\telse if (o_rd_cyc && i_rd_ack)\n\tbegin\n\t\t// {{{\n\t\t// Verilator lint_off WIDTH\n\t\ts",
            "reg <= pre_shifted_data;\n\t\t// Verilator lint_on  WIDTH\n\t\t// }}}\n\tend else if (m_valid)\n\tbegin\n\t\t// {{{\n\t\ts",
            "reg <= {(DW){1'b0}};\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// m_bytes\n\t// {{{\n\tinitial\tm_bytes = 0;\n\talways @(posedge i_clk)\n\tif (!o_busy)\n\tbegin\n\t\tm_bytes <= 0;\n\tend else if (i_rd_ack)\n\tbegin\n\t\tif (|next_fill[WBLSB+1:WBLSB]) // if next_fill >= DW/8)\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tm_bytes <= DW/8;\n\t\t\t// Verilator lint_on  WIDTH\n\t\telse\n\t\t\tm_bytes <= { 1'b0, next_fill[WBLSB-1:0] };\n\tend else if (rdack_len == 0)\n\t\tm_bytes <= next_fill[WBLSB:0];\n\t// }}}\n\n\t// m_last\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tlast_request_addr = i_addr;\n\t\tif (r_inc)\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tlast_request_addr = i_addr + i_transferlen - 1;\n\t\t\t// Verilator lint_on  WIDTH\n\tend\n\n\tinitial\tm_last = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tm_last <= 1'b0;\n\telse if (!o_busy)\n\tbegin\n\t\tm_last <= 1'b0;\n\t\tif (!OPT_LOWPOWER || i_request)\n\t\tcase(i_size)\n\t\tSZ_BYTE: m_last <= (i_transferlen <= 1);\n\t\tSZ_16B: m_last <= (last_request_addr[ADDRESS_WIDTH-1:1] != i_addr[ADDRESS_WIDTH-1:1]);\n\t\tSZ_32B: m_last <= (last_request_addr[ADDRESS_WIDTH-1:2] != i_addr[ADDRESS_WIDTH-1:2]);\n\t\tSZ_BUS: m_last <= (last_request_addr[ADDRESS_WIDTH-1:WBLSB] != i_addr[ADDRESS_WIDTH-1:WBLSB]);\n\t\tendcase\n\tend else if (i_rd_ack)\n\tbegin\n\t\t// Verilator lint_off WIDTH\n\t\tm_last <= (rdack_len <= rdack_size) && (next_fill <= DW/8);\n\t\t// Verilator lint_on  WIDTH\n\tend else if (rdack_len == 0)\n\t\tm_last <= 1;\n\t// }}}\n\n\tassign\tM_VALID = m_valid;\n\tassign\tM_DATA = s",
            "reg ;\n\tassign\tM_BYTES= m_bytes;\n\tassign\tM_LAST = m_last;\n\n\t// Keep Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, M_READY, last_request_addr[0],\n\t\t\t\tr_addr[ADDRESS_WIDTH-1:WBLSB] };\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t//",
            "localparam [0:0] CONTRACT = 1'b1;",
            "localparam F_LGDEPTH = LGLENGTH+1-WBLSB;",
            "localparam F_LGCOUNT = LGLENGTH+1;",
            "reg f_past_valid;",
            "wire [F_LGDEPTH-1:0]\tfwb_nreqs, fwb_nacks, fwb_outstanding;\n\t(* anyconst *)",
            "reg f_cfg_inc;\n\t(* anyconst *)",
            "reg [1:0]\t\t\tf_cfg_size;\n\t(* anyconst *)",
            "reg [ADDRESS_WIDTH-1:0]\tf_cfg_addr;\n\t(* anyconst *)",
            "reg [LGLENGTH:0]\t\tf_cfg_len;",
            "reg [DW/8-1:0] \t\tf_base_sel;",
            "reg [F_LGCOUNT-1:0]\tf_rcvd, f_sent;",
            "reg [WBLSB:0]\tf_ack_size, f_stb_size;",
            "reg [F_LGCOUNT-1:0]\tf_outstanding_bytes;",
            "reg f_stb_first, f_stb_last,\n\t\t\t\tf_ack_first, f_ack_last;\n\t(* keep *)",
            "reg [WBLSB-1:0] f_excess_last_return, lower_len_bits;\n\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Configuration properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Handshake property\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset) || $past(o_err))\n\tbegin\n\t\tassume(!i_request);\n\tend else if ($past(o_busy || i_request))\n\tbegin\n\t\tassume(i_request);\n\t\tassume($stable(i_inc));\n\t\tassume($stable(i_size));\n\t\tassume($stable(i_addr));\n\t\tassume($stable(i_transferlen));\n\tend\n\n\t// Assume the DMA request is for an arbitrary value we can track\n\talways @(*)\n\tbegin\n\t\tassume(f_cfg_len > 0);\n\t\tif (i_request && !o_busy)\n\t\tbegin\n\t\t\tassume(i_inc  == f_cfg_inc);\n\t\t\tassume(i_size == f_cfg_size);\n\t\t\tassume(i_addr == f_cfg_addr);\n\t\t\tassume(i_transferlen == f_cfg_len);\n\t\tend else if (o_busy)\n\t\tbegin\n\t\t\tassert(r_inc  == f_cfg_inc);\n\t\t\tassert(r_size == f_cfg_size);\n\t\t\tassert(r_addr == f_cfg_addr);\n\t\t\tassert(r_transferlen == f_cfg_len);\n\t\tend\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// f_stb_first, f_stb_last, f_ack_first, f_ack_last\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\t\tf_stb_first = (rdstb_len == f_cfg_len);\n\n\talways @(*)\n\tif (rdstb_len == 0)\n\t\tf_stb_last <= 1'b0;\n\telse case(r_size)\n\tSZ_BYTE: f_stb_last <= (rdstb_len == 1);\n\tSZ_16B:  f_stb_last <= (rdstb_len + f_excess_last_return[0] == 2);\n\tSZ_32B:  f_stb_last <= (rdstb_len + f_excess_last_return[1:0] == 4);\n\tSZ_BUS:  f_stb_last <= (rdstb_len + f_excess_last_return[WBLSB-1:0] == DW/8);\n\tendcase\n\n\talways @(*)\n\t\tf_ack_first = (f_rcvd == 0);\n\n\talways @(*)\n\tif (rdack_len == 0)\n\t\tf_ack_last <= 1'b0;\n\telse case(r_size)\n\tSZ_BYTE: f_ack_last <= (rdack_len == 1);\n\tSZ_16B:  f_ack_last <= (rdack_len + f_excess_last_return[0] == 2);\n\tSZ_32B:  f_ack_last <= (rdack_len + f_excess_last_return[1:0] == 4);\n\tSZ_BUS:  f_ack_last <= (rdack_len + f_excess_last_return[WBLSB-1:0] == DW/8);\n\tendcase\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// f_excess_last_return\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tbegin\n\t\tf_excess_last_return = f_cfg_addr + f_cfg_len;\n\t\tcase(r_size)\n\t\tSZ_BYTE: f_excess_last_return = 0;\n\t\tSZ_16B:  begin\n\t\t\tf_excess_last_return = 2 - f_excess_last_return[0];\n\t\t\tf_excess_last_return[WBLSB-1:1] = 0;\n\t\t\tend\n\t\tSZ_32B:  begin\n\t\t\tf_excess_last_return = 4 - f_excess_last_return[1:0];\n\t\t\tf_excess_last_return[WBLSB-1:2] = 0;\n\t\t\tend\n\t\tSZ_BUS:  f_excess_last_return = (DW/8) - f_excess_last_return[WBLSB-1:0];\n\t\tendcase\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// first_size\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_err)\n\tbegin\n\t\tcase(r_size)\n\t\tSZ_BYTE: assert(first_size == 1);\n\t\tSZ_16B:  assert(first_size == (f_cfg_addr[0]) ? 1 : 2);\n\t\tSZ_32B:  assert(first_size == 4 - f_cfg_addr[1:0]);\n\t\tSZ_BUS:  assert(first_size == (DW/8) - f_cfg_addr[WBLSB-1:0]);\n\t\tendcase\n\n\t\tif (first_size > f_cfg_len)\n\t\t\tassert(first_size == f_cfg_len);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// o_rd_addr, subaddr\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif(!i_reset && o_busy && !o_err)\n\tbegin\n\t\tif (!r_inc)\n\t\tbegin\n\t\t\tassert({ o_rd_addr, subaddr } == f_cfg_addr);\n\t\tend else if (rdstb_len != 0)\n\t\t\tassert({ o_rd_addr, subaddr } == f_cfg_addr + f_rcvd + f_outstanding_bytes);\n\tend\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_err && r_inc && r_size == SZ_BUS\n\t\t\t&& (wb_outstanding > 0 || f_rcvd > 0) && rdstb_len != 0)\n\t\tassert(subaddr == 0);\n\n\talways @(*)\n\tif (!i_reset && o_busy && r_inc)\n\t\tassert( {1'b0, f_cfg_addr} + f_rcvd <= { 1'b1, { (ADDRESS_WIDTH){1'b0} }});\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Wishbone properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.AW(AW), .DW(DW), .F_LGDEPTH(F_LGDEPTH),\n\t\t.F_OPT_RMW_BUS_OPTION(1'b0),\n\t\t.F_OPT_DISCONTINUOUS(1'b0),\n\t\t.F_OPT_SOURCE(1'b1),\n\t\t.F_OPT_MINCLOCK_DELAY(1'b1)\n\t\t// }}}\n\t) fwb (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t//\n\t\t.i_wb_cyc(o_rd_cyc),\n\t\t.i_wb_stb(o_rd_stb),\n\t\t.i_wb_we(o_rd_we),\n\t\t.i_wb_addr(o_rd_addr),\n\t\t.i_wb_data(o_rd_data),\n\t\t.i_wb_sel(o_rd_sel),\n\t\t//\n\t\t.i_wb_stall(i_rd_stall),\n\t\t.i_wb_ack(i_rd_ack),\n\t\t.i_wb_idata(i_rd_data),\n\t\t.i_wb_err(i_rd_err),\n\t\t//\n\t\t.f_nreqs(fwb_nreqs), .f_nacks(fwb_nacks),\n\t\t.f_outstanding(fwb_outstanding)\n\t\t// }}}\n\t);\n\n\talways @(*)\n\t\tassert(!o_rd_we);\n\n\talways @(*)\n\tif (!i_reset && !o_busy)\n\t\tassert(!o_rd_cyc);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// wb_outstanding\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (!i_reset && f_past_valid && o_rd_cyc)\n\t\tassert(fwb_outstanding == wb_outstanding);\n\n\talways @(*)\n\tif (wb_outstanding == 0)\n\t\tf_outstanding_bytes = 0;\n\telse case(r_size)\n\tSZ_BYTE: f_outstanding_bytes = wb_outstanding;\n\tSZ_16B: if (!f_ack_first)\n\t\t\tf_outstanding_bytes = wb_outstanding * 2;\n\t\telse\n\t\t\tf_outstanding_bytes = wb_outstanding * 2 - f_cfg_addr[0];\n\tSZ_32B: if (!f_ack_first)\n\t\t\tf_outstanding_bytes = wb_outstanding * 4;\n\t\telse\n\t\t\tf_outstanding_bytes = wb_outstanding * 4 - f_cfg_addr[1:0];\n\tSZ_BUS: if (!f_ack_first)\n\t\t\tf_outstanding_bytes = wb_outstanding * (DW/8);\n\t\telse\n\t\t\tf_outstanding_bytes = wb_outstanding * (DW/8) - f_cfg_addr[WBLSB-1:0];\n\tendcase\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_err)\n\t\tassert(f_outstanding_bytes <= f_cfg_len + ((rdstb_len == 0) ? f_excess_last_return : 0));\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// base_sel\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif (!i_reset && $past(o_busy) && o_busy && !o_err)\n\t\tassert(base_sel != 0);\n\n\talways @(*)\n\tif (OPT_LITTLE_ENDIAN)\n\tbegin\n\t\tcase(r_size)\n\t\tSZ_BYTE: f_base_sel = { {(DW/8-1){1'b0}}, 1'h1 } << subaddr;\n\t\tSZ_16B:  f_base_sel = { {(DW/8-2){1'b0}}, 2'h3 } << { subaddr[WBLSB-1:1], 1'b0 };\n\t\tSZ_32B:  f_base_sel = { {(DW/8-4){1'b0}}, 4'hf } << { subaddr[WBLSB-1:1], 2'b00 };\n\t\tSZ_BUS: if (r_inc || (!r_inc && f_stb_first))\n\t\t\t\tf_base_sel = { (DW/8){1'b1} } << subaddr;\n\t\t\telse\n\t\t\t\tf_base_sel = { (DW/8){1'b1} };\n\t\tendcase\n\tend else begin\n\t\tcase(r_size)\n\t\tSZ_BYTE: f_base_sel = { 1'h1, {(DW/8-1){1'b0}} } >> subaddr;\n\t\tSZ_16B:  f_base_sel = { 2'h3, {(DW/8-2){1'b0}} } >> { subaddr[WBLSB-1:1], 1'b0 };\n\t\tSZ_32B:  f_base_sel = { 4'hf, {(DW/8-4){1'b0}} } >> { subaddr[WBLSB-1:2], 2'b00 };\n\t\tSZ_BUS: if (r_inc || (!r_inc && f_stb_first))\n\t\t\t\tf_base_sel = { (DW/8){1'b1} } >> subaddr;\n\t\t\telse\n\t\t\t\tf_base_sel = { (DW/8){1'b1} };\n\t\tendcase\n\tend\n\n\talways @(posedge i_clk)\n\tif (!i_reset && $past(o_busy) && o_busy && !o_err && rdstb_len > 0)\n\tbegin\n\t\tif (r_size == SZ_BUS)\n\t\tbegin\n\t\t\tassert(base_sel == { (DW/8){1'b1} });\n\t\tend else begin\n\t\t\tassert(base_sel == f_base_sel);\n\t\tend\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// o_rd_sel\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_err)\n\tbegin\n\t\tassert(fill < (DW/8) + (M_VALID ? DW/8 : 0));\n\t\tif (rdstb_len != 0 || rdstb_len != rdstb_size)\n\t\t\tassert(rdstb_size <= $countones(o_rd_sel));\n\n\t\tif (!r_inc)\n\t\tcase(r_size)\n\t\tSZ_BYTE: assert(o_rd_sel == base_sel);\n\t\tSZ_16B:  assert(o_rd_sel == (f_cfg_len < 2) ? first_sel : base_sel);\n\t\tSZ_32B:  assert(o_rd_sel == (f_cfg_len < 4) ? first_sel : base_sel);\n\t\tSZ_BUS:  assert(o_rd_sel == (f_cfg_len < DW/8) ? first_sel : base_sel);\n\t\tendcase\n\tend\n\n\talways @(*)\n\tif (!i_reset && f_past_valid && o_rd_stb && r_inc && !f_stb_last)\n\tbegin\n\t\tassert(o_rd_sel != 0);\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tcase(r_size)\n\t\t\tSZ_BYTE:assert(o_rd_sel == { {(DW/8-1){1'b0}}, 1'b1 } << subaddr);\n\t\t\tSZ_16B: if (f_cfg_len < 2)\n\t\t\t\tbegin\n\t\t\t\t\tif (i_addr[0])\n\t\t\t\t\tbegin\n\t\t\t\t\t\tassert(o_rd_sel == { {(DW/8-2){1'b0}}, 2'b01 } << { subaddr[WBLSB-1:1], 1'b0 });\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tassert(o_rd_sel == { {(DW/8-2){1'b0}}, 2'b10 } << { subaddr[WBLSB-1:1], 1'b0 });\n\t\t\t\t\tend\n\t\t\t\tend else if (i_addr[0])\n\t\t\t\tbegin\n\t\t\t\t\tassert(o_rd_sel == { {(DW/8-2){1'b0}}, 2'b01 } << { subaddr[WBLSB-1:1], 1'b0 });\n\t\t\t\tend else begin\n\t\t\t\t\tassert(o_rd_sel == { {(DW/8-2){1'b0}}, 2'b11 } << { subaddr[WBLSB-1:1], 1'b0 });\n\t\t\t\tend\n\t\t\tSZ_32B: if (f_cfg_len < 4)\n\t\t\t\tbegin\n\t\t\t\t\tassert(o_rd_sel == { {(DW/8-4){1'b0}}, (4'b1111 << (4 - f_cfg_len)) } << { subaddr[WBLSB-1:2], 2'b00 });\n\t\t\t\tend else begin\n\t\t\t\t\tassert(o_rd_sel == { {(DW/8-4){1'b0}}, 4'b1111 } << { subaddr[WBLSB-1:2], 2'b00 });\n\t\t\t\tend\n\t\t\tSZ_BUS: if (f_cfg_len < DW/8)\n\t\t\t\tbegin\n\t\t\t\t\tassert(o_rd_sel == { (DW/8){1'b1} } << (DW/8 - f_cfg_len));\n\t\t\t\tend else if (rdstb_len == f_cfg_len)\n\t\t\t\tbegin\n\t\t\t\t\tassert(o_rd_sel == { (DW/8){1'b1} } << subaddr);\n\t\t\t\tend else begin\n\t\t\t\t\t\tassert(o_rd_sel == { (DW/8){1'b1} });\n\t\t\t\tend\n\t\t\tendcase\n\t\tend else case(r_size)\n\t\tSZ_BYTE:assert(o_rd_sel == { 1'b1, {(DW/8-1){1'b0}} } >> subaddr);\n\t\tSZ_16B: if (f_cfg_len < 2)\n\t\t\tbegin\n\t\t\t\tif (i_addr[0])\n\t\t\t\tbegin\n\t\t\t\t\tassert(o_rd_sel == { 2'b01, {(DW/8-2){1'b0}} } >> { subaddr[WBLSB-1:1], 1'b0 });\n\t\t\t\tend else begin\n\t\t\t\t\tassert(o_rd_sel == { 2'b10, {(DW/8-2){1'b0}} } >> { subaddr[WBLSB-1:1], 1'b0 });\n\t\t\t\tend\n\t\t\tend else if (subaddr[0])\n\t\t\tbegin\n\t\t\t\tassert(o_rd_sel == { 2'b01, {(DW/8-2){1'b0}} } >> { subaddr[WBLSB-1:1], 1'b0 });\n\t\t\tend else begin\n\t\t\t\tassert(o_rd_sel == { 2'b11, {(DW/8-2){1'b0}} } >> { subaddr[WBLSB-1:1], 1'b0 });\n\t\t\tend\n\t\tSZ_32B: if (f_cfg_len < 4)\n\t\t\tbegin\n\t\t\t\tif (i_addr[1:0] == 2'b00)\n\t\t\t\tbegin\n\t\t\t\t\tassert(o_rd_sel == {(4'b1111 >> (4 - f_cfg_len)), {(DW/8-4){1'b0}} }\n\t\t\t\t\t\t>> { subaddr[WBLSB-1:2], 2'b00 });\n\t\t\t\tend else if (f_cfg_len[1:0] < (4 - subaddr[1:0]))\n\t\t\t\tbegin\n\t\t\t\t\tassert(o_rd_sel == {(4'b1111 >> (4 - f_cfg_len)), {(DW/8-4){1'b0}} }\n\t\t\t\t\t\t>> { subaddr[WBLSB-1:2], 2'b00 });\n\t\t\t\tend else begin\n\t\t\t\t\tassert(o_rd_sel == {(4'b1111 >> (subaddr[1:0])), {(DW/8-4){1'b0}} }\n\t\t\t\t\t\t>> { subaddr[WBLSB-1:2], 2'b00 });\n\t\t\t\tend\n\t\t\tend else if (subaddr[1:0] == 2'b00)\n\t\t\tbegin\n\t\t\t\tassert(o_rd_sel == { 4'b1111, {(DW/8-4){1'b0}} } >> { subaddr[WBLSB-1:2], 2'b00 });\n\t\t\tend else begin\n\t\t\t\tassert(o_rd_sel == { (4'b1111 >> subaddr[1:0]), {(DW/8-4){1'b0}} } >> { subaddr[WBLSB-1:2], 2'b00 });\n\t\t\tend\n\t\tSZ_BUS: if (f_cfg_len < DW/8)\n\t\t\tbegin\n\t\t\t\tif (i_addr[WBLSB-1:0] == 0)\n\t\t\t\tbegin\n\t\t\t\t\tassert(o_rd_sel == { (DW/8){1'b1} } >> (DW/8 - f_cfg_len - subaddr));\n\t\t\t\tend else if (f_cfg_len[WBLSB-1:0] < (DW/8 - subaddr))\n\t\t\t\tbegin\n\t\t\t\t\tassert(o_rd_sel == { (DW/8){1'b1} } >> (DW/8 - f_cfg_len));\n\t\t\t\tend else begin\n\t\t\t\t\tassert(o_rd_sel == { (DW/8){1'b1} } >> (subaddr));\n\t\t\t\tend\n\t\t\tend else if (f_stb_first)\n\t\t\tbegin\n\t\t\t\tassert(o_rd_sel == { (DW/8){1'b1} } >> subaddr);\n\t\t\tend else begin\n\t\t\t\tassert(o_rd_sel == { (DW/8){1'b1} });\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// rdstb_size\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tbegin\n\t\tcase(r_size)\n\t\tSZ_BYTE: f_stb_size = 1;\n\t\tSZ_16B:  f_stb_size = 2;\n\t\tSZ_32B:  f_stb_size = 4;\n\t\tSZ_BUS:  f_stb_size = DW/8;\n\t\tendcase\n\n\t\tif (rdstb_len == f_cfg_len)\n\t\tcase(r_size)\n\t\tSZ_BYTE: f_stb_size =  1;\n\t\tSZ_16B:  f_stb_size = (2 - r_addr[  0]);\n\t\tSZ_32B:  f_stb_size = (4 - r_addr[1:0]);\n\t\tSZ_BUS:  f_stb_size = (DW/8 - r_addr[WBLSB-1:0]);\n\t\tendcase\n\tend\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_err && o_rd_cyc && o_rd_stb)\n\tbegin\n\t\tif (f_stb_first && f_stb_last)\n\t\tbegin\t// means that packet is one word only\n\t\t\tassert(rdstb_size == f_cfg_len);\n\t\tend else if (f_stb_last)\n\t\tbegin\n\t\t\tassert(rdstb_size == rdstb_len);\n\t\tend else begin\n\t\t\tassert(rdstb_size == f_stb_size);\n\t\tend\n\tend\n\n\talways @(*)\n\tif(!i_reset && o_busy && !o_err && rdstb_len > 0)\n\t\tassert(rdstb_size <= rdstb_len);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// rdack_size\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tbegin\n\t\tcase(r_size)\n\t\tSZ_BYTE: f_ack_size = 1;\n\t\tSZ_16B:  f_ack_size = 2;\n\t\tSZ_32B:  f_ack_size = 4;\n\t\tSZ_BUS:  f_ack_size = DW/8;\n\t\tendcase\n\n\t\tif (f_rcvd == 0)\n\t\tcase(r_size)\n\t\tSZ_BYTE: f_ack_size =  1;\n\t\tSZ_16B:  f_ack_size = (2 - r_addr[  0]);\n\t\tSZ_32B:  f_ack_size = (4 - r_addr[1:0]);\n\t\tSZ_BUS:  f_ack_size = (DW/8 - r_addr[WBLSB-1:0]);\n\t\tendcase\n\n\t\tif (f_rcvd + f_ack_size > r_transferlen)\n\t\t\tf_ack_size = r_transferlen - f_rcvd;\n\tend\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_err && o_rd_cyc)\n\tbegin\n\t\tif (f_ack_first && f_ack_last)\n\t\tbegin\t// means that packet is one word only\n\t\t\tassert(rdack_size == f_cfg_len);\n\t\tend else if (f_ack_last)\n\t\tbegin\n\t\t\tassert(rdack_size == rdack_len);\n\t\tend else begin\n\t\t\tassert(rdack_size == f_ack_size);\n\t\tend\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// rdstb_len, rdack_len\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_err && o_rd_cyc)\n\tbegin\n\t\tif (!f_stb_first)\n\t\tbegin\n\t\t\tcase(r_size)\t// Check the rdstb_len whether is odd or even\n\t\t\tSZ_16B: if (f_cfg_len > 2 && rdstb_len != 0)\n\t\t\t\tbegin\n\t\t\t\t\tassert(rdstb_len[0] == (f_cfg_addr[0] ^ f_cfg_len[0]));\n\t\t\t\tend\n\t\t\tSZ_32B: if (f_cfg_len > 4 && rdstb_len != 0)\n\t\t\t\tbegin\n\t\t\t\t\tlower_len_bits = f_cfg_len - (4 - f_cfg_addr[1:0]);\n\t\t\t\t\tassert(rdstb_len[1:0] == ((f_cfg_addr[1:0] == 2'b00) ? f_cfg_len[1:0] : lower_len_bits[1:0]));\n\t\t\t\tend\n\t\t\tSZ_BUS: if (f_cfg_len > DW/8 && rdstb_len != 0)\n\t\t\t\tbegin\n\t\t\t\t\tlower_len_bits = f_cfg_len - (DW/8 - f_cfg_addr[WBLSB-1:0]);\n\t\t\t\t\tassert(rdstb_len[WBLSB-1:0] == ((f_cfg_addr[WBLSB-1:0] == 0) ? f_cfg_len[WBLSB-1:0] : lower_len_bits[WBLSB-1:0]));\n\t\t\t\tend\n\t\t\tendcase\n\n\t\t\tif (f_stb_last)\n\t\t\tbegin\n\t\t\t\tcase(r_size)\n\t\t\t\tSZ_BYTE: assert(rdstb_len == 1);\n\t\t\t\tSZ_16B:  assert(rdstb_len == 2 - f_excess_last_return[0]);\n\t\t\t\tSZ_32B:  assert(rdstb_len == 4 - f_excess_last_return[1:0]);\n\t\t\t\tSZ_BUS:  assert(rdstb_len == (DW/8) - f_excess_last_return[WBLSB-1:0]);\n\t\t\t\tendcase\n\t\t\tend\n\n\t\t\tif (!f_ack_first)\n\t\t\tbegin\n\t\t\t\tif (r_size != 2'b11)\n\t\t\t\tbegin\n\t\t\t\t\tassert(rdack_len[0] == (f_cfg_addr[0] ^ f_cfg_len[0]));\n\t\t\t\tend\n\n\t\t\t\tif (f_ack_last)\n\t\t\t\tbegin\n\t\t\t\t\tcase(r_size)\n\t\t\t\t\tSZ_BYTE: assert(rdack_len == 1);\n\t\t\t\t\tSZ_16B:  assert(rdack_len == 2 - f_excess_last_return[0]);\n\t\t\t\t\tSZ_32B:  assert(rdack_len == 4 - f_excess_last_return[1:0]);\n\t\t\t\t\tSZ_BUS:  assert(rdack_len == (DW/8) - f_excess_last_return[WBLSB-1:0]);\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(*)\n\tif(!i_reset && o_busy && !o_err && !f_ack_first)\n\tbegin\n\t\tassert(f_rcvd <= f_cfg_len + DW/8 - 1);\n\t\tif(rdstb_len != 0)\n\t\t\tassert(f_cfg_len == f_rcvd + f_outstanding_bytes + rdstb_len);\n\tend\n\n\talways @(*)\n\tif(!i_reset && o_busy && !o_err)\n\tbegin\n\t\tassert(rdack_len <= f_cfg_len);\n\t\tassert(rdstb_len <= rdack_len);\n\t\tif(rdstb_len != 0)\n\t\tbegin\n\t\t\tassert(rdack_len == rdstb_len + f_outstanding_bytes);\n\t\tend else begin\n\t\t\tassert(f_outstanding_bytes == rdack_len\n\t\t\t\t+ ((rdstb_len == 0 && rdack_len != 0)\n\t\t\t\t\t? f_excess_last_return : 0));\n\t\tend\n\tend\n\n\talways @(*)\n\tif(!i_reset && o_busy && !o_err)\n\t\tassert(rdstb_len != 0 || !o_rd_stb);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// f_rcvd\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tinitial\tf_rcvd = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || !o_busy || (o_rd_cyc && i_rd_err))\n\t\tf_rcvd <= 0;\n\telse if (o_rd_cyc && i_rd_ack)\n\tbegin\n\t\tif (f_rcvd == 0)\n\t\tbegin\n\t\t\tcase(r_size)\n\t\t\tSZ_BYTE: f_rcvd <= f_rcvd + 1;\n\t\t\tSZ_16B:  f_rcvd <= f_rcvd + (f_cfg_len < 2) ? 1 : (2 - f_cfg_addr[0]);\n\t\t\tSZ_32B:  f_rcvd <= f_rcvd + (f_cfg_len < (4 - f_cfg_addr[1:0])) ? f_cfg_len : (4 - f_cfg_addr[1:0]);\n\t\t\tSZ_BUS:  f_rcvd <= f_rcvd + (f_cfg_len < (DW/8 - f_cfg_addr[WBLSB-1:0])) ? f_cfg_len : (DW/8 - f_cfg_addr[WBLSB-1:0]);\n\t\t\tendcase\n\t\tend else if (f_ack_last)\n\t\tbegin\n\t\t\tcase(r_size)\n\t\t\tSZ_BYTE: f_rcvd <= f_rcvd + 1;\n\t\t\tSZ_16B:  f_rcvd <= f_rcvd + (2 - f_excess_last_return[0]);\n\t\t\tSZ_32B:  f_rcvd <= f_rcvd + (4 - f_excess_last_return[1:0]);\n\t\t\tSZ_BUS:  f_rcvd <= f_rcvd + (DW/8 - f_excess_last_return[WBLSB-1:0]);\n\t\t\tendcase\n\t\tend else\n\t\tbegin\n\t\t\tcase(r_size)\n\t\t\tSZ_BYTE: f_rcvd <= f_rcvd + 1;\n\t\t\tSZ_16B:  f_rcvd <= f_rcvd + 2;\n\t\t\tSZ_32B:  f_rcvd <= f_rcvd + 4;\n\t\t\tSZ_BUS:  f_rcvd <= f_rcvd + DW/8;\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_err && rdack_len != 0)\n\t\tassert(f_rcvd == f_cfg_len - rdack_len);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Outgoing stream properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset))\n\t\tassert(!M_VALID);\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_err && !M_VALID)\n\t\tassert(fill == 0);\n\n\talways @(*)\n\tif (!i_reset && o_busy && M_VALID)\n\tbegin\n\t\tassert(M_BYTES > 0);\n\t\tassert(M_BYTES <= (DW/8));\n\n\t\tif (M_LAST)\n\t\t\tassert(!o_rd_stb);\n\tend\n\n\talways @(*)\n\tif (!i_reset && o_busy)\n\t\tassert(f_sent <= r_transferlen);\n\n\talways @(*)\n\tif (!i_reset && o_busy)\n\tbegin\n\t\tif (!M_VALID)\n\t\tbegin\n\t\t\tassert(f_rcvd == f_sent);\n\t\tend else\n\t\t\tassert(f_rcvd == f_sent + M_BYTES);\n\tend\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_rd_stb && !o_err)\n\t\tassert(rdstb_len == 0);\n\n\tinitial\tf_sent = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || !o_busy || (o_rd_cyc && i_rd_err))\n\t\tf_sent <= 0;\n\telse if (M_VALID && M_READY)\n\tbegin\n\t\tif (M_LAST)\n\t\t\tf_sent <= 0;\n\t\telse\n\t\t\tf_sent <= f_sent + M_BYTES;\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// \"Contract\" properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n// `define\tCONTRACT\n`ifdef CONTRACT\n\t(* anyconst *)",
            "reg fc_check;\n\t(* anyconst *)",
            "reg [F_LGCOUNT-1:0]\tfc_posn;\n\t(* anyconst *)",
            "reg [7:0]\t\tfc_byte;",
            "wire fwb_check,   fm_check;\n\t(* keep *)",
            "reg [WBLSB-1:0]\tfwb_shift,   fm_shift;\n\t(* keep *)",
            "reg [DW-1:0]\t\tfwb_shifted, fm_shifted;\n\n\t// Assume a known response from the bus\n\t// {{{\n\tassign\tfwb_check = fc_check && (o_rd_cyc && i_rd_ack)\n\t\t\t\t&& (f_rcvd <= fc_posn)\n\t\t\t\t&& (fc_posn < f_rcvd + f_ack_size);\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_err && rdstb_len != f_cfg_len\n\t\t\t&& rdstb_len > rdstb_size && !r_inc)\n\t\tassert(pre_shift == r_addr[WBLSB-1:0]);\n\n\talways @(*)\n\tbegin\n\t\tfwb_shift = fc_posn - f_rcvd;\n\t\tfwb_shift = fwb_shift + pre_shift;\n\tend\n\n\talways @(*)\n\tif (OPT_LITTLE_ENDIAN)\n\t\tfwb_shifted = i_rd_data >> (8*fwb_shift);\n\telse\n\t\tfwb_shifted = i_rd_data << (8*fwb_shift);\n\n\talways @(*)\n\tif (!i_reset && fwb_check)\n\tbegin\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tassume(fwb_shifted[7:0] == fc_byte);\n\t\tend else begin\n\t\t\tassume(fwb_shifted[DW-1:DW-8] == fc_byte);\n\t\tend\n\tend\n\t// }}}\n\n\t// Assert a specific",
            "output // {{{\n\tassign\tfm_check = fc_check && M_VALID\n\t\t\t\t&& (f_sent <= fc_posn)\n\t\t\t\t&& (fc_posn < f_sent + fill);\n\n\talways @(*)\n\t\tfm_shift = fc_posn - f_sent;\n\n\talways @(*)\n\tif (OPT_LITTLE_ENDIAN)\n\t\tfm_shifted = s",
            "reg >> (8*fm_shift);\n\telse\n\t\tfm_shifted = s",
            "reg << (8*fm_shift);\n\n\talways @(*)\n\tif (!i_reset && fm_check)\n\tbegin\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tassert(fm_shifted[7:0] == fc_byte);\n\t\tend else begin\n\t\t\tassert(fm_shifted[DW-1:DW-8] == fc_byte);\n\t\tend\n\tend\n\t// }}}\n`endif\t// CONTRACT\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tbegin\n\t\tcover(!i_reset && i_request);\n\t\tcover(o_busy);\n\t\tcover(o_rd_cyc);\n\t\tcover(o_rd_cyc && i_rd_ack);\n\tend\n\n`ifdef CONTRACT\n\talways @(*)\n\t\tcover(!i_reset && fm_check);\n`endif\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// \"Careless\" assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// The outgoing stream isn't quite an AXI stream master interface,\n\t// since WB doesn't have backpressure.  Therefore, we assume M_READY\n\t// is always high when we need it to be.\n\n\talways @(*)\n\tif (!OPT_FIRSTBEAT_TRIM)\n\tcase(f_cfg_size)\n\tSZ_16B: assume(f_cfg_len + f_cfg_addr[0] >= 2);\n\tSZ_32B: assume(f_cfg_len + f_cfg_addr[1:0] >= 4);\n\tSZ_BUS: assume(f_cfg_len + f_cfg_addr[WBLSB-1:0] >= BUS_WIDTH/8);\n\tendcase\n\n\talways @(*)\n\tif (!i_reset && M_VALID)\n\t\tassume(M_READY);\n\n\talways @(*)\n\tif (!i_reset && o_busy && !o_err)\n\t\tassume(r_transferlen + f_cfg_addr < (1 << ADDRESS_WIDTH));\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipdma_txgears.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma_txgears.v",
        "chunks": [
            "module zipdma_txgears #(\n\t\t// {{{",
            "parameter BUS_WIDTH = 512,",
            "parameter [0:0]\tOPT_LITTLE_ENDIAN = 1'b0,\n\t\t// Abbreviations",
            "localparam DW = BUS_WIDTH\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Configuration\n\t\t// {{{",
            "input ",
            "wire i_soft_reset,",
            "input ",
            "wire [1:0]\t\ti_size,\n\t\t// }}}\n\t\t// Incoming Stream interface\n\t\t// {{{",
            "input ",
            "wire S_VALID,",
            "output ",
            "wire S_READY,",
            "input ",
            "wire [DW-1:0]\tS_DATA,\n\t\t// How many bytes are valid?",
            "input ",
            "wire [$clog2(DW/8):0]\tS_BYTES,",
            "input ",
            "wire S_LAST,\n\t\t// }}}\n\t\t// Outgoing Stream interface\n\t\t// {{{",
            "output ",
            "wire M_VALID,",
            "input ",
            "wire M_READY,",
            "output ",
            "wire [DW-1:0]\tM_DATA,\n\t\t// How many bytes are valid?",
            "output ",
            "wire [$clog2(DW/8):0]\tM_BYTES,",
            "output ",
            "wire M_LAST\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "localparam WBLSB = $clog2(DW/8);",
            "localparam [1:0]\tSZ_BYTE = 2'b11,\n\t\t\t\tSZ_16B  = 2'b10,\n\t\t\t\tSZ_32B  = 2'b01,\n\t\t\t\tSZ_BUS  = 2'b00;",
            "reg m_valid, m_last, r_last, r_next;",
            "reg [DW-1:0]\ts",
            "reg ;",
            "reg [WBLSB:0]\tm_bytes, fill;\n\t// }}}\n\n\t// s",
            "reg , fill\n\t// {{{\n\tinitial {s",
            "reg , fill } = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\tbegin\n\t\ts",
            "reg <= 0;\n\t\tfill <= 0;\n\tend else if (S_VALID && S_READY)\n\tbegin\n\t\ts",
            "reg <= S_DATA;\n\t\tfill <= S_BYTES;\n\tend else if (M_VALID && M_READY)\n\tbegin\n\t\tif (M_LAST)\n\t\t\t{ s",
            "reg , fill } <= 0;\n\t\telse if (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\t// Verilator coverage_off\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE: begin s",
            "reg <= s",
            "reg >>  8; fill <= fill - 1; end\n\t\t\tSZ_16B:  begin s",
            "reg <= s",
            "reg >> 16; fill <= fill - 2; end\n\t\t\tSZ_32B:  begin s",
            "reg <= s",
            "reg >> 32; fill <= fill - 4; end\n\t\t\tSZ_BUS:  begin s",
            "reg <= 0; fill <= 0; end\n\t\t\tendcase\n\t\t\t// Verilator coverage_on\n\t\tend else begin\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE: begin s",
            "reg <= s",
            "reg <<  8; fill <= fill - 1; end\n\t\t\tSZ_16B:  begin s",
            "reg <= s",
            "reg << 16; fill <= fill - 2; end\n\t\t\tSZ_32B:  begin s",
            "reg <= s",
            "reg << 32; fill <= fill - 4; end\n\t\t\tSZ_BUS:  begin s",
            "reg <= 0; fill <= 0; end\n\t\t\tendcase\n\t\tend\n\tend\n`ifdef\tFORMAL\n\talways @(*)\n\tif (!i_reset)\n\t\tassert(fill <= (DW/8));\n`endif\n\t// }}}\n\n\t// m_valid\n\t// {{{\n\tinitial\tm_valid = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\t\tm_valid <= 0;\n\telse if (!M_VALID || M_READY)\n\tbegin\n\t\tif (S_VALID && S_READY)\n\t\t\tm_valid <= 1'b1;\n\t\telse case(i_size)\n\t\tSZ_BYTE: m_valid <= (fill > 1);\n\t\tSZ_16B:  m_valid <= (fill > 2);\n\t\tSZ_32B:  m_valid <= (fill > 4);\n\t\tSZ_BUS:  m_valid <= 0;\n\t\tendcase\n\tend\n`ifdef\tFORMAL\n\talways @(*)\n\tif (m_valid)\n\t\tassert(m_bytes <= fill);\n`endif\n\t// }}}\n\n\t// m_bytes\n\t// {{{\n\tgenerate if (BUS_WIDTH > 32)\n\tbegin : GEN_MBYTES\n\t\t// {{{\n\t\tinitial\tm_bytes = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || i_soft_reset)\n\t\t\tm_bytes <= 0;\n\t\telse if (S_VALID && S_READY)\n\t\tbegin\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE: m_bytes <= 1;\n\t\t\tSZ_16B: m_bytes <= (S_BYTES > 2) ? 2 : S_BYTES;\n\t\t\tSZ_32B: m_bytes <= (S_BYTES > 4) ? 4 : S_BYTES;\n\t\t\tSZ_BUS: m_bytes <= S_BYTES;\n\t\t\tendcase\n\t\tend else if (!M_VALID || M_READY)\n\t\tbegin\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE: m_bytes <= 1;\n\t\t\tSZ_16B:  m_bytes <= (fill >= 4) ? 2\n\t\t\t\t\t\t: (&fill[1:0]) ? 1 : 0;\n\t\t\tSZ_32B:  m_bytes <= (fill >= 8) ? 4\n\t\t\t\t: (fill[2]) ? ({ {(WBLSB-1){1'b0}}, fill[1:0] })\n\t\t\t\t: 0;\n\t\t\tSZ_BUS:  m_bytes <= 0;\n\t\t\tendcase\n\t\tend\n\t\t// }}}\n\tend else begin : MIN_MBYTES\n\t\t// {{{\n\t\tinitial\tm_bytes = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || i_soft_reset)\n\t\t\tm_bytes <= 0;\n\t\telse if (S_VALID && S_READY)\n\t\tbegin\n\t\t\tcasez(i_size)\n\t\t\tSZ_BYTE: m_bytes <= 1;\n\t\t\tSZ_16B:  m_bytes <= (S_BYTES > 2) ? 2 : S_BYTES;\n\t\t\tdefault: m_bytes <= S_BYTES;\n\t\t\tendcase\n\t\tend else if (!M_VALID || M_READY)\n\t\tbegin\n\t\t\tcasez(i_size)\n\t\t\tSZ_BYTE: m_bytes <= 1;\n\t\t\tSZ_16B:  m_bytes <= (fill >= 4) ? 2\n\t\t\t\t\t\t: (&fill[1:0]) ? 1 : 0;\n\t\t\tdefault: m_bytes <= 0;\n\t\t\tendcase\n\t\tend\n\t\t// }}}\n\tend endgenerate\n`ifdef\tFORMAL\n\t// {{{\n\talways @(*)\n\tif (!i_reset && M_VALID)\n\tbegin\n\t\tassert(m_bytes > 0);\n\t\tassert(m_bytes <= fill);\n\t\tif (M_LAST)\n\t\t\tassert(m_bytes == fill);\n\n\t\tcase(i_size)\n\t\tSZ_BYTE: assert(m_bytes == 1);\n\t\tSZ_16B:  begin\n\t\t\tassert(m_bytes <= 2);\n\t\t\tif (m_bytes < 2)\n\t\t\t\tassert(M_LAST && m_bytes == fill);\n\t\t\tend\n\t\tSZ_32B:  begin\n\t\t\tassert(m_bytes <= 4);\n\t\t\tif (m_bytes < 4)\n\t\t\t\tassert(M_LAST && m_bytes == fill);\n\t\t\tend\n\t\tSZ_BUS:  begin\n\t\t\tassert(m_bytes <= DW/8);\n\t\t\tif (m_bytes < (DW/8))\n\t\t\t\tassert(M_LAST && m_bytes == fill);\n\t\t\tend\n\t\tendcase\n\tend\n\t// }}}\n`endif\n\t// }}}\n\n\t// r_next -- Are we on our last word?\n\t// {{{\n\t// Only allow S_READY if r_next is true, so r_next must be true when\n\t// we",
            "output the last word of the shift",
            "reg ister.\n\tgenerate if (BUS_WIDTH > 32)\n\tbegin : GEN_NEXT\n\t\t// {{{\n\t\tinitial\tr_next = 1;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || i_soft_reset)\n\t\t\tr_next <= 1;\n\t\telse if (M_VALID && M_READY && M_LAST)\n\t\t\tr_next <= 1;\n\t\telse if (S_VALID && S_READY)\n\t\tbegin\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE:r_next <= (S_BYTES == 1);\n\t\t\tSZ_16B: r_next <= (S_BYTES <= 2);\n\t\t\tSZ_32B: r_next <= (S_BYTES <= 4);\n\t\t\tSZ_BUS: r_next <= 1;\n\t\t\tendcase\n\n\t\t\tif (S_LAST)\n\t\t\t\tr_next <= 0;\n\t\tend else if (M_VALID && M_READY)\n\t\tbegin\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE:r_next <= (fill <= 2);\n\t\t\tSZ_16B: r_next <= (fill <= 4);\n\t\t\tSZ_32B: r_next <= (fill <= 8);\n\t\t\tSZ_BUS: r_next <= 1;\n\t\t\tendcase\n\n\t\t\tif (r_last)\n\t\t\t\tr_next <= 0;\n\t\tend\n\t\t// }}}\n\tend else begin : MIN_NEXT\n\t\t// {{{\n\t\tinitial\tr_next = 1;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || i_soft_reset)\n\t\t\tr_next <= 1;\n\t\telse if (M_VALID && M_READY && M_LAST)\n\t\t\tr_next <= 1;\n\t\telse if (S_VALID && S_READY)\n\t\tbegin\n\t\t\tcasez(i_size)\n\t\t\tSZ_BYTE: r_next <= (S_BYTES == 1);\n\t\t\tSZ_16B:  r_next <= (S_BYTES <= 2);\n\t\t\tdefault: r_next <= 1;\n\t\t\tendcase\n\n\t\t\tif (S_LAST)\n\t\t\t\tr_next <= 0;\n\t\tend else if (M_VALID && M_READY)\n\t\tbegin\n\t\t\tcasez(i_size)\n\t\t\tSZ_BYTE: r_next <= (fill <= 2);\n\t\t\tSZ_16B:  r_next <= (fill <= 4);\n\t\t\tdefault: r_next <= 1;\n\t\t\tendcase\n\n\t\t\tif (r_last)\n\t\t\t\tr_next <= 0;\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n`ifdef\tFORMAL\n\t// {{{",
            "reg [1:0]\tf_mid_packet;\n\n\t// f_mid_packet\n\t// {{{\n\tinitial\tf_mid_packet = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\t\tf_mid_packet <= 0;\n\telse if (S_VALID && S_READY)\n\t\tf_mid_packet <= (S_LAST) ? 2'b10 : 2'b01;\n\telse if (M_VALID && M_READY && M_LAST)\n\t\tf_mid_packet <= 2'b00;\n\n\talways @(*)\n\t\tassert(f_mid_packet != 2'b11);\n\t// }}}\n\n\talways @(*)\n\tif (!i_reset) begin\n\n\t\tassert(f_mid_packet[1] == (r_last || m_last));\n\n\t\tif (f_mid_packet[1])\n\t\tbegin\n\t\t\tassert(!r_next);\n\t\tend else case(i_size)\n\t\tSZ_BYTE:assert(r_next == (fill <= 1));\n\t\tSZ_16B: assert(r_next == (fill <= 2));\n\t\tSZ_32B: assert(r_next == (fill <= 4));\n\t\tSZ_BUS: assert(r_next);\n\t\tendcase\n\tend\n\t// }}}\n`endif\n\t// }}}\n\n\t// r_last, m_last\n\t// {{{\n\tgenerate if (BUS_WIDTH > 32)\n\tbegin : GEN_LAST\n\t\t// {{{\n\t\tinitial { r_last, m_last } = 2'b00;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || i_soft_reset)\n\t\t\t{ r_last, m_last } <= 0;\n\t\telse if (S_VALID && S_READY)\n\t\tbegin\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE: { r_last, m_last } <= { (S_BYTES > 1), (S_BYTES == 1) };\n\t\t\tSZ_16B:  { r_last, m_last } <= { (S_BYTES > 2), (S_BYTES <= 2) };\n\t\t\tSZ_32B:  { r_last, m_last } <= { (S_BYTES > 4), (S_BYTES <= 4) };\n\t\t\tSZ_BUS:  { r_last, m_last } <= { 1'b0, S_LAST };\n\t\t\tendcase\n\n\t\t\tif (!S_LAST)\n\t\t\t\t{ r_last, m_last } <= 2'b00;\n\t\tend else if (M_VALID && M_READY)\n\t\tbegin\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE:m_last <= r_last && (fill <= 2);\n\t\t\tSZ_16B: m_last <= r_last && (fill <= 4);\n\t\t\tSZ_32B: m_last <= r_last && (fill <= 8);\n\t\t\tSZ_BUS: m_last <= 0;\n\t\t\tendcase\n\n\t\t\tcase(i_size)\n\t\t\tSZ_BYTE:r_last <= r_last && (fill > 2);\n\t\t\tSZ_16B: r_last <= r_last && (fill > 4);\n\t\t\tSZ_32B: r_last <= r_last && (fill > 8);\n\t\t\tSZ_BUS: r_last <= 0;\n\t\t\tendcase\n\n\t\t\t// if (M_LAST)\n\t\t\t//\t{ r_last, m_last } <= 2'b00;\n\t\tend\n\t\t// }}}\n\tend else begin : MIN_LAST\n\t\t// {{{\n\t\tinitial { r_last, m_last } = 2'b00;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || i_soft_reset)\n\t\t\t{ r_last, m_last } <= 0;\n\t\telse if (S_VALID && S_READY)\n\t\tbegin\n\t\t\tcasez(i_size)\n\t\t\tSZ_BYTE: { r_last, m_last } <= { (S_BYTES > 1), (S_BYTES == 1) };\n\t\t\tSZ_16B:  { r_last, m_last } <= { (S_BYTES > 2), (S_BYTES <= 2) };\n\t\t\tdefault: { r_last, m_last } <= { (S_BYTES > 4), (S_BYTES <= 4) };\n\t\t\tendcase\n\n\t\t\tif (!S_LAST)\n\t\t\t\t{ r_last, m_last } <= 2'b00;\n\t\tend else if (!M_VALID || M_READY)\n\t\tbegin\n\t\t\tcasez(i_size)\n\t\t\tSZ_BYTE: m_last <= r_last && (fill <= 2);\n\t\t\tSZ_16B:  m_last <= r_last && (fill <= 4);\n\t\t\tdefault: m_last <= 0;\n\t\t\tendcase\n\n\t\t\tcasez(i_size)\n\t\t\tSZ_BYTE: r_last <= r_last && (fill > 2);\n\t\t\tSZ_16B:  r_last <= r_last && (fill > 4);\n\t\t\tdefault: r_last <= 0;\n\t\t\tendcase\n\n\t\t\t// if (M_LAST)\n\t\t\t//\t{ r_last, m_last } <= 2'b00;\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n`ifdef FORMAL\n\talways @(posedge i_clk)\n\tif (f_past_valid && $past(!i_reset && M_VALID && M_READY && M_LAST))\n\t\tassert({ r_last, m_last } == 2'b00);\n`endif\n\t// }}}\n\n\tassign\tM_VALID = m_valid;\n\tassign\tM_DATA  = s",
            "reg ;\n\tassign\tM_BYTES = m_bytes;\n\tassign\tM_LAST  = m_last;\n\n\tassign\tS_READY = !M_VALID || (M_READY && r_next);\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "localparam F_LGCOUNT = 16;",
            "reg f_past_valid;\n\t(* anyconst *)",
            "reg [1:0]\tf_cfg_size;",
            "reg [F_LGCOUNT-1:0]\t\tf_rcvd, f_sent;\n\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\n\talways @(*)\n\tif (!i_reset)\n\t\tassume(i_size == f_cfg_size);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Incoming stream properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Basic stream properties\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset || i_soft_reset))\n\t\tassume(!S_VALID);\n\telse if ($past(S_VALID && !S_READY))\n\tbegin\n\t\tassume(S_VALID);\n\t\tassume($stable(S_DATA));\n\t\tassume($stable(S_BYTES));\n\t\tassume($stable(S_LAST));\n\tend\n\t// }}}\n\n\t// Properties of S_BYTES: incoming words are packed\n\t// {{{\n\talways @(*)\n\tif (!i_reset && S_VALID)\n\tbegin\n\t\tassume(S_BYTES > 0);\n\t\tassume(S_BYTES <= (DW/8));\n\t\tif (!S_LAST)\n\t\t\tassume(S_BYTES == (DW/8));\n\tend\n\t// }}}\n\n\t// f_rcvd\n\t// {{{\n\tinitial\tf_rcvd = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\t\tf_rcvd = 0;\n\telse if (S_VALID && S_READY)\n\tbegin\n\t\tif (S_LAST)\n\t\t\tf_rcvd <= 0;\n\t\telse\n\t\t\tf_rcvd <= f_rcvd + S_BYTES;\n\tend\n\n\talways @(*)\n\t\tassume(!f_rcvd[F_LGCOUNT-1]);\n\n\talways @(*)\n\tif (f_mid_packet == 2'b00 || f_mid_packet == 2'b10)\n\tbegin\n\t\tassert(f_rcvd == 0);\n\tend else\n\t\tassert(f_rcvd > 0);\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Outgoing stream properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Basic stream property\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset || i_soft_reset))\n\t\tassert(!M_VALID);\n\telse if ($past(M_VALID && !M_READY))\n\tbegin\n\t\tassert(M_VALID);\n\t\tassert($stable(M_DATA));\n\t\tassert($stable(M_BYTES));\n\t\tassert($stable(M_LAST));\n\tend\n\t// }}}\n\n\t// Bounding/checking M_LAST\n\t// {{{\n\talways @(*)\n\tif (!i_reset && M_VALID)\n\tbegin\n\t\tassert(M_BYTES > 0);\n\t\tassert(M_BYTES <= (DW/8));\n\n\t\tif (!M_LAST)\n\t\tcase(f_cfg_size)\n\t\tSZ_BYTE: assert(M_BYTES == 1);\n\t\tSZ_16B: assert(M_BYTES == 2);\n\t\tSZ_32B: assert(M_BYTES == 4);\n\t\tSZ_BUS: assert(M_BYTES == (DW/8));\n\t\tendcase\n\t\telse\n\t\tcase(f_cfg_size)\n\t\tSZ_BYTE: assert(M_BYTES == 1);\n\t\tSZ_16B: assert(M_BYTES <= 2);\n\t\tSZ_32B: assert(M_BYTES <= 4);\n\t\tSZ_BUS: assert(M_BYTES <= (DW/8));\n\t\tendcase\n\tend\n\t// }}}\n\n\t// Bounding/checking fill\n\t// {{{\n\talways @(*)\n\tif (!i_reset)\n\tbegin\n\t\tassert(!r_last || !M_LAST);\n\t\tif (r_last || M_LAST)\n\t\t\tassert(M_VALID);\n\n\t\tif (r_last)\n\t\tcase(f_cfg_size)\n\t\tSZ_BYTE: assert(fill > 1);\n\t\tSZ_16B: assert(fill > 2);\n\t\tSZ_32B: assert(fill > 4);\n\t\tSZ_BUS: assert(0);\n\t\tendcase\n\n\t\tif (M_LAST)\n\t\tbegin\n\t\t\tassert(fill > 0);\n\n\t\t\tcase(f_cfg_size)\n\t\t\t2'b11: assert(fill == 1);\n\t\t\tSZ_16B: assert(fill <= 2);\n\t\t\tSZ_32B: assert(fill <= 4);\n\t\t\tSZ_BUS: begin end\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(*)\n\tif (!i_reset)\n\tbegin\n\t\tassert(fill <= (DW/8));\n\t\tassert(M_VALID == (fill > 0));\n\n\t\tif (M_LAST)\n\t\t\tassert(fill == M_BYTES);\n\n\t\tif (!M_LAST && !r_last)\n\t\tcase(f_cfg_size)\n\t\tSZ_BYTE: begin end // assert(fill > 0);\n\t\tSZ_16B: assert(fill[0] == 1'b0);\n\t\tSZ_32B: assert(fill[1:0] == 2'b00);\n\t\tSZ_BUS: assert(fill[WBLSB-1:0] == 0);\n\t\tendcase\n\tend\n\t// }}}\n\n\t// f_sent\n\t// {{{\n\tinitial\tf_sent = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset)\n\t\tf_sent <= 0;\n\telse if (M_VALID && M_READY)\n\tbegin\n\t\tif (M_LAST)\n\t\t\tf_sent <= 0;\n\t\telse\n\t\t\tf_sent <= f_sent + M_BYTES;\n\tend\n\n\talways @(*)\n\tbegin\n\t\tassume(!f_sent[F_LGCOUNT-1]);\n\n\t\tif (!r_last && !m_last)\n\t\tbegin\n\t\t\tassert(f_sent + fill == f_rcvd);\n\t\t\tassert(f_sent <= f_rcvd);\n\t\tend\n\tend\n\n\talways @(*)\n\tif (f_mid_packet == 2'b00)\n\tbegin\n\t\tassert(f_sent == 0);\n\tend else if (f_mid_packet == 2'b10)\n\t\tassert(M_VALID || f_sent > 0);\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// \"Contract\" properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t(* anyconst *)",
            "reg fc_check;\n\t(* anyconst *)",
            "reg [F_LGCOUNT-1:0]\tfc_posn;\n\t(* anyconst *)",
            "reg [7:0]\t\tfc_byte;",
            "wire fs_check,   fm_check;",
            "reg [WBLSB-1:0]\tfs_shift,   fm_shift;",
            "reg [DW-1:0]\tfs_shifted, fm_shifted;\n\n\t// Slave assumption\n\t// {{{\n\tassign fs_check = fc_check && S_VALID && f_rcvd <= fc_posn\n\t\t\t\t&& (fc_posn < f_rcvd + S_BYTES);\n\n\talways @(*)\n\t\tfs_shift = fc_posn - f_rcvd;\n\n\talways @(*)\n\tif (OPT_LITTLE_ENDIAN)\n\t\tfs_shifted = S_DATA >> (8*fs_shift);\n\telse\n\t\tfs_shifted = S_DATA << (8*fs_shift);\n\n\talways @(*)\n\tif (!i_reset && fs_check)\n\tbegin\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tassume(fs_shifted[7:0] == fc_byte);\n\t\telse\n\t\t\tassume(fs_shifted[DW-1:DW-8] == fc_byte);\n\tend\n\t// }}}\n\n\t// Master assertion\n\t// {{{\n\tassign fm_check = fc_check && f_sent <= fc_posn\n\t\t\t\t&& (fc_posn < f_sent + fill);\n\n\talways @(*)\n\t\tfm_shift = fc_posn - f_sent;\n\n\talways @(*)\n\tif (OPT_LITTLE_ENDIAN)\n\t\tfm_shifted = s",
            "reg >> (8*fm_shift);\n\telse\n\t\tfm_shifted = s",
            "reg << (8*fm_shift);\n\n\talways @(*)\n\tif (!i_reset && fm_check)\n\tbegin\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tassert(fm_shifted[7:0] == fc_byte);\n\t\tend else begin\n\t\t\tassert(fm_shifted[DW-1:DW-8] == fc_byte);\n\t\tend\n\tend\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif (!i_reset && M_VALID && M_READY && M_LAST)\n\tbegin\n\t\tcover(i_size == SZ_BYTE && f_sent > DW/8);\n\t\tcover(i_size == SZ_16B  && f_sent > DW/8);\n\t\tcover(i_size == SZ_32B  && f_sent > DW/8);\n\t\tcover(i_size == SZ_BUS  && f_sent > DW/8);\n\n\t\tcover(i_size == SZ_BYTE && f_sent > 2*DW/8+1);\n\t\tcover(i_size == SZ_16B  && f_sent > 2*DW/8+1);\n\t\tcover(i_size == SZ_32B  && f_sent > 2*DW/8+1);\n\t\tcover(i_size == SZ_BUS  && f_sent > 2*DW/8+1);\n\n\t\tcover(i_size == SZ_BUS  && f_sent > 2*DW/8+2);\n\t\tcover(i_size == SZ_BUS  && f_sent > 2*DW/8+3);\n\t\tcover(i_size == SZ_BUS  && f_sent > 2*DW/8+4);\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// \"Careless\" assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipdma_ctrl.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma_ctrl.v",
        "chunks": [
            "module zipdma_ctrl #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=30, LGMEMLEN = 10,",
            "parameter SLV_WIDTH=32,\n\t\t\t\t// BUS_WIDTH=512,",
            "parameter LGDMALENGTH = ADDRESS_WIDTH,",
            "parameter ABORT_KEY = 32'h41425254,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,\n\t\t\t\t// == { 8'd65, 8'd66, 8'd82, 8'd84 }, \"ABRT\",",
            "localparam AW = ADDRESS_WIDTH\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Slave / control port\n\t\t// {{{",
            "input ",
            "wire i_cyc, i_stb, i_we,",
            "input ",
            "wire [1:0]\t\t\ti_addr,",
            "input ",
            "wire [SLV_WIDTH-1:0]\t\ti_data,",
            "input ",
            "wire [SLV_WIDTH/8-1:0]\t\ti_sel,\n\t\t//\n\t\t// Verilator coverage_off",
            "output ",
            "wire o_stall,\n\t\t// Verilator coverage_on",
            "output ",
            "reg o_ack,",
            "output ",
            "reg [SLV_WIDTH-1:0]\t\to_data,\n\t\t// }}}\n\t\t// DMA control",
            "wire s and feedback\n\t\t// {{{",
            "output ",
            "reg o_dma_request,",
            "output ",
            "reg o_dma_abort,",
            "input ",
            "wire i_dma_busy, i_dma_err,",
            "output ",
            "reg [AW-1:0]\t\to_src_addr,",
            "output ",
            "reg [AW-1:0]\t\to_dst_addr,",
            "output ",
            "reg [LGDMALENGTH-1:0]\to_length,",
            "output ",
            "reg [LGMEMLEN:0]\t\to_transferlen,",
            "output ",
            "reg o_mm2s_inc, o_s2mm_inc,",
            "output ",
            "reg [1:0]\t\t\to_mm2s_size,o_s2mm_size,\n\t\t//",
            "output ",
            "reg o_trigger,\n\t\t//",
            "input ",
            "wire [AW-1:0]\t\ti_current_src,",
            "input ",
            "wire [AW-1:0]\t\ti_current_dst,",
            "input ",
            "wire [LGDMALENGTH-1:0]\ti_remaining_len,\n\t\t// }}}",
            "input ",
            "wire [31:0]\ti_dma_int,",
            "output ",
            "reg o_interrupt\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "reg int_trigger, r_err, r_zero_len, r_busy;",
            "reg [4:0]\tint_sel;",
            "reg [SLV_WIDTH-1:0]\tnext_src, next_dst, next_len, next_tlen,\n\t\t\tw_control_",
            "reg ;\n\t// }}}\n\n\t// o_ack\n\t// {{{\n\tinitial\to_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_ack <= 1'b0;\n\telse\n\t\to_ack <= i_stb;\n\t// }}}\n\n\tassign\to_stall = 1'b0;\n\n\t// w_control_",
            "reg // {{{\n\talways @(*)\n\tbegin\n\t\tw_control_",
            "reg = 0;\n\t\tw_control_",
            "reg [31]    = i_dma_busy;\n\t\tw_control_",
            "reg [30]    = r_err || i_dma_err;\n\t\tw_control_",
            "reg [29]    = int_trigger;\n\t\tw_control_",
            "reg [28:24] = int_sel;\n\t\t//\n\t\tw_control_",
            "reg [LGMEMLEN:0] = o_transferlen;\n\t\t//\n\t\tw_control_",
            "reg [22]    = !o_s2mm_inc;\n\t\tw_control_",
            "reg [21:20] =  o_s2mm_size;\n\t\t//\n\t\tw_control_",
            "reg [18]    = !o_mm2s_inc;\n\t\tw_control_",
            "reg [17:16] =  o_mm2s_size;\n\tend\n\t// }}}\n\n\t// o_data\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!OPT_LOWPOWER || (i_stb && !o_stall && !i_we))\n\tbegin\n\t\to_data <= 0;\n\t\tcase(i_addr)\n\t\t2'b00: o_data <= w_control_",
            "reg ;\n\t\t2'b01: o_data[AW-1:0] <= (i_dma_busy) ? i_current_src : o_src_addr;\n\t\t2'b10: o_data[AW-1:0] <= (i_dma_busy) ? i_current_dst : o_dst_addr;\n\t\t2'b11: o_data[LGDMALENGTH-1:0] <= (i_dma_busy) ? i_remaining_len : o_length;\n\t\tendcase\n\tend\n\t// }}}\n\n\t// o_trigger\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_reset || o_dma_abort || i_dma_err || !i_dma_busy)\n\t\to_trigger <= 1'b0;\n\telse if (!int_trigger)\n\t\to_trigger <= 1'b1;\n\telse\n\t\to_trigger <= i_dma_int[int_sel];\n\t// }}}\n\n\t// next_src\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tnext_src = 32'h00;\n\t\tnext_src[AW-1:0] = o_src_addr;\n\n\t\tif (i_sel[0]) next_src[ 7: 0] = i_data[ 7: 0];\n\t\tif (i_sel[1]) next_src[15: 8] = i_data[15: 8];\n\t\tif (i_sel[2]) next_src[23:16] = i_data[23:16];\n\t\tif (i_sel[3]) next_src[31:24] = i_data[31:24];\n\tend\n\t// }}}\n\n\t// next_dst\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tnext_dst = 32'h00;\n\t\tnext_dst[AW-1:0] = o_dst_addr;\n\n\t\tif (i_sel[0]) next_dst[ 7: 0] = i_data[ 7: 0];\n\t\tif (i_sel[1]) next_dst[15: 8] = i_data[15: 8];\n\t\tif (i_sel[2]) next_dst[23:16] = i_data[23:16];\n\t\tif (i_sel[3]) next_dst[31:24] = i_data[31:24];\n\tend\n\t// }}}\n\n\t// next_len\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tnext_len = 32'h00;\n\t\tnext_len[LGDMALENGTH-1:0] = o_length;\n\n\t\tif (i_sel[0]) next_len[ 7: 0] = i_data[ 7: 0];\n\t\tif (i_sel[1]) next_len[15: 8] = i_data[15: 8];\n\t\tif (i_sel[2]) next_len[23:16] = i_data[23:16];\n\t\tif (i_sel[3]) next_len[31:24] = i_data[31:24];\n\tend\n\t// }}}\n\n\t// next_tlen\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tnext_tlen = 32'h00;\n\t\tnext_tlen[LGMEMLEN-1:0] = o_transferlen[LGMEMLEN-1:0];\n\n\t\tif (i_sel[0]) next_tlen[ 7: 0] = i_data[ 7: 0];\n\t\tif (i_sel[1]) next_tlen[15: 8] = i_data[15: 8];\n\t\tif (i_sel[2]) next_tlen[23:16] = i_data[23:16];\n\t\tif (i_sel[3]) next_tlen[31:24] = i_data[31:24];\n\n\t\tnext_tlen[SLV_WIDTH-1:LGMEMLEN] = 0;\n\t\tnext_tlen[LGMEMLEN] = (next_tlen[LGMEMLEN-1:0] == 0);\n\tend\n\t// }}}\n\n\t// Process i_data writes\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\t// {{{\n\t\to_src_addr    <= {(AW){1'b0}};\n\t\to_dst_addr    <= {(AW){1'b0}};\n\t\to_length      <= {(LGDMALENGTH){1'b0}};\n\t\tr_zero_len    <= 1'b1;\n\t\to_transferlen <= { 1'b1, {(LGMEMLEN){1'b0}} };\n\n\t\to_s2mm_inc    <= 1'b0;\n\t\to_s2mm_size   <= 2'b0;\n\n\t\to_mm2s_inc  <= 1'b0;\n\t\to_mm2s_size <= 2'b0;\n\n\t\tint_trigger <= 1'b0;\n\t\tint_sel     <= 5'h0;\n\t\t// }}}\n\tend else if (i_stb && !o_stall && i_we && !o_dma_request && !i_dma_busy)\n\tbegin // Register write, DMA is idle\n\t\t// {{{\n\t\tcase(i_addr)\n\t\t2'b00: begin // Control",
            "reg isters\n\t\t\t// {{{\n\t\t\to_transferlen[LGMEMLEN:0] <= next_tlen[LGMEMLEN:0];\n\t\t\tif (i_sel[2])\n\t\t\tbegin\n\t\t\t\to_s2mm_inc  <= !i_data[22];\n\t\t\t\to_s2mm_size <=  i_data[21:20];\n\t\t\t\t//\n\t\t\t\to_mm2s_inc  <= !i_data[18];\n\t\t\t\to_mm2s_size <=  i_data[17:16];\n\t\t\tend\n\n\t\t\tif (i_sel[3])\n\t\t\tbegin\n\t\t\t\tint_trigger <= i_data[29];\n\t\t\t\tint_sel     <= i_data[28:24];\n\t\t\tend end\n\t\t\t// }}}\n\t\t2'b01: o_src_addr <= next_src[AW-1:0];\n\t\t2'b10: o_dst_addr <= next_dst[AW-1:0];\n\t\t2'b11: begin // o_length\n\t\t\t// {{{\n\t\t\to_length <= next_len[LGDMALENGTH-1:0];\n\t\t\tr_zero_len <= (next_len[LGDMALENGTH-1:0] == 0);\n\t\t\tend\n\t\t\t// }}}\n\t\tendcase\n\t\t// }}}\n\tend else if (i_dma_busy)\n\tbegin\n\t\to_src_addr <= i_current_src;\n\t\to_dst_addr <= i_current_dst;\n\tend\n\t// }}}\n\n\t// o_dma_request, o_dma_abort, o_interrupt, r_err\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\t// {{{\n\t\to_dma_request <= 1'b0;\n\t\to_dma_abort   <= 1'b0;\n\n\t\tr_err <= 1'b0;\n\n\t\to_interrupt <= 1'b0;\n\t\t// }}}\n\tend else begin\n\t\tr_busy <= i_dma_busy;\n\n\t\tif (!i_dma_busy)\n\t\tbegin\n\t\t\to_dma_request <= 1'b0;\n\t\t\to_dma_abort   <= 1'b0;\n\t\tend\n\n\t\tif (i_dma_err)\n\t\t\tr_err <= 1'b1;\n\t\tif (r_busy && (!i_dma_busy || i_dma_err))\n\t\t\to_interrupt <= 1'b1;\n\n\t\tif (i_stb && !o_stall && i_we && i_addr == 2'b00)\n\t\tbegin\n\t\t// {{{\n\t\t\tif (o_dma_request || i_dma_busy)\n\t\t\tbegin\n\t\t\t\t// Deal with abort requests\n\t\t\t\tif ((&i_sel) && i_data == ABORT_KEY)\n\t\t\t\t\t{ o_dma_request, o_dma_abort } <= 2'b01;\n\n\t\t\tend else if (i_sel[3])\n\t\t\tbegin\n\t\t\t\t// Clear interrupts, errors, and potentially\n\t\t\t\t// restart the DMA\n\t\t\t\tif (i_data[29] || !i_data[30])\n\t\t\t\t\to_interrupt <= 1'b0;\n\t\t\t\tif (i_data[30])\n\t\t\t\t\tr_err <= 1'b0;\n\t\t\t\tif (!i_data[31] && (!r_err || i_data[30]))\n\t\t\t\t\to_dma_request <= !r_zero_len;\n\t\t\tend\n\t\t// }}}\n\t\tend\n\tend\n\t// }}}\n\n\t// Keep Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, i_cyc, next_tlen[SLV_WIDTH-1:LGMEMLEN] };\n\tgenerate if (SLV_WIDTH > AW)\n\tbegin : UNUSED_WIDE_ADDR",
            "wire unused_addr;\n\t\tassign\tunused_addr = &{ 1'b0,\n\t\t\t\tnext_src[SLV_WIDTH-1:AW],\n\t\t\t\tnext_dst[SLV_WIDTH-1:AW]\n\t\t\t\t};\n\tend if (SLV_WIDTH > LGDMALENGTH)\n\tbegin : UNUSED_LEN",
            "wire unused_len;\n\t\tassign\tunused_len = &{ 1'b0,\n\t\t\t\tnext_len[SLV_WIDTH-1:LGDMALENGTH]\n\t\t\t\t};\n\tend endgenerate\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipdma_fsm.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma_fsm.v",
        "chunks": [
            "module zipdma_fsm #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH = 32,\t// Byte ADDR width",
            "parameter LGDMALENGTH = ADDRESS_WIDTH,",
            "parameter LGSUBLENGTH = 10\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,",
            "input ",
            "wire i_soft_reset,\n\t\t// DMA control\n\t\t// {{{",
            "input ",
            "wire i_dma_request,",
            "output ",
            "reg o_dma_busy,",
            "output ",
            "reg o_dma_err,",
            "input ",
            "wire [ADDRESS_WIDTH-1:0]\ti_src_addr,",
            "input ",
            "wire [ADDRESS_WIDTH-1:0]\ti_dst_addr,",
            "input ",
            "wire [LGDMALENGTH-1:0]\ti_length,",
            "input ",
            "wire [LGSUBLENGTH:0]\t\ti_transferlen,",
            "output ",
            "wire [LGDMALENGTH-1:0]\to_remaining_len,\n\t\t// }}}",
            "input ",
            "wire i_trigger,\n\t\t// MM2S control\n\t\t// {{{",
            "output ",
            "reg o_mm2s_request,",
            "input ",
            "wire i_mm2s_busy,",
            "input ",
            "wire i_mm2s_err,",
            "input ",
            "wire i_mm2s_inc,\n\t\t//",
            "input ",
            "wire [1:0]\t\t\ti_mm2s_size,",
            "output ",
            "reg [ADDRESS_WIDTH-1:0]\to_mm2s_addr,",
            "output ",
            "wire [LGSUBLENGTH:0]\t\to_mm2s_transferlen,\n\t\t// }}}\n\t\t// S2MM control\n\t\t// {{{",
            "output ",
            "reg o_s2mm_request,",
            "input ",
            "wire i_s2mm_busy,",
            "input ",
            "wire i_s2mm_err,",
            "input ",
            "wire i_s2mm_inc,\n\t\t//",
            "input ",
            "wire [1:0]\t\t\ti_s2mm_size,",
            "output ",
            "reg [ADDRESS_WIDTH-1:0]\to_s2mm_addr,",
            "output ",
            "wire [LGSUBLENGTH:0]\t\to_s2mm_transferlen\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "localparam [1:0]\tS_IDLE = 2'b00,\n\t\t\t\tS_WAIT = 2'b01,\n\t\t\t\tS_READ = 2'b10,\n\t\t\t\tS_WRITE = 2'b11;",
            "reg [LGDMALENGTH-1:0]\tr_length;",
            "reg [LGSUBLENGTH:0]\t\tr_transferlen;",
            "reg [1:0]\t\t\tfsm_state;\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset || i_mm2s_err || i_s2mm_err)\n\tbegin\n\t\t// {{{\n\t\to_dma_busy     <= 0;\n\t\tr_length       <= 0;\n\t\tr_transferlen  <= 0;\n\t\to_mm2s_request <= 0;\n\t\to_s2mm_request <= 0;\n\n\t\to_mm2s_addr <= 0;\n\t\to_s2mm_addr <= 0;\n\n\t\tfsm_state   <= S_IDLE;\n\t\t// }}}\n\tend else if (!o_dma_busy)\n\tbegin\n\t\t// {{{\n\t\to_dma_busy <= 1'b0;\n\n\t\tr_length <= 0;\n\t\t// Verilator lint_off WIDTH\n\t\tr_transferlen <= (i_length < i_transferlen) ? i_length\n\t\t\t\t\t: i_transferlen;\n\t\t// Verilator lint_on  WIDTH\n\n\t\tfsm_state <= S_IDLE;\n\n\t\to_mm2s_request <= 0;\n\t\to_s2mm_request <= 0;\n\n\t\tif (i_dma_request)\n\t\tbegin\n\t\t\to_dma_busy <= 1'b1;\n\n\t\t\tfsm_state      <= (i_trigger) ? S_READ : S_WAIT;\n\t\t\to_mm2s_request <= i_trigger;\n\n\t\t\to_mm2s_addr <= i_src_addr;\n\t\t\to_s2mm_addr <= i_dst_addr;\n\t\t\tr_length <= i_length;\n\t\tend\n`ifdef\tFORMAL\n\t\tassert(fsm_state == S_IDLE);\n`endif\n\t\t// }}}\n\tend else case(fsm_state)\n\tS_WAIT: begin\n\t\t// {{{\n\t\tif (r_length == 0)\n\t\t\to_dma_busy <= 0;\n\t\telse if (i_trigger)\n\t\tbegin\n\t\t\tfsm_state <= S_READ;\n\t\t\to_mm2s_request <= 1'b1;\n\t\tend end\n\t\t// }}}\n\tS_READ: begin\n\t\t// {{{\n\t\tif (o_mm2s_request && !i_mm2s_busy)\t// VALID && READY\n\t\t\to_mm2s_request <= 1'b0;\n\t\tif (!i_mm2s_busy && !o_mm2s_request)\n\t\tbegin\n\t\t\tfsm_state <= S_WRITE;\n\t\t\to_s2mm_request <= 1'b1;\n\n\t\t\tif (i_mm2s_inc)\n\t\t\t\t// Verilator lint_off WIDTH\n\t\t\t\to_mm2s_addr <= o_mm2s_addr + r_transferlen;\n\t\t\t\t// Verilator lint_on  WIDTH\n\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tr_length <= (r_length > r_transferlen)\n\t\t\t\t? r_length - r_transferlen : 0;\n\t\t\t// Verilator lint_on  WIDTH\n\t\tend end\n\t\t// }}}\n\tS_WRITE: begin\n\t\t// {{{\n\t\tif (o_s2mm_request && !i_s2mm_busy)\t// VALID && READY\n\t\t\to_s2mm_request <= 1'b0;\n\t\tif (!i_s2mm_busy && !o_s2mm_request)\n\t\tbegin\n\t\t\tfsm_state <= (i_trigger) ? S_READ : S_WAIT;\n\t\t\to_mm2s_request <= (i_trigger);\n\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tif (r_transferlen > r_length)\n\t\t\t\t// Verilator lint_on  WIDTH\n\t\t\t\tr_transferlen <= r_length[LGSUBLENGTH:0];\n\n\t\t\tif (i_s2mm_inc)\n\t\t\t\t// Verilator lint_off WIDTH\n\t\t\t\to_s2mm_addr <= o_s2mm_addr + r_transferlen;\n\t\t\t\t// Verilator lint_on  WIDTH\n\n\t\t\tif (r_length == 0)\n\t\t\tbegin\n\t\t\t\tfsm_state      <= S_IDLE;\n\t\t\t\to_mm2s_request <= 1'b0;\n\t\t\t\to_dma_busy     <= 1'b0;\n\t\t\tend\n\t\tend end\n\t\t// }}}\n\t// Verilator coverage_off\n\tdefault: begin end\n\t// Verilator coverage_on\n\tendcase\n\n\tassign\to_s2mm_transferlen = r_transferlen;\n\tassign\to_mm2s_transferlen = r_transferlen;\n\tassign\to_remaining_len    = r_length;\n\n\t// o_dma_err\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_reset || i_soft_reset || !o_dma_busy)\n\t\to_dma_err <= 1'b0;\n\telse\n\t\to_dma_err <= (i_mm2s_busy && i_mm2s_err)\n\t\t\t\t|| (i_s2mm_busy && i_s2mm_err);\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipdma.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/zipdma/zipdma.v",
        "chunks": [
            "module zipdma #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=30, LGMEMLEN = 10,",
            "parameter LGDMALENGTH=ADDRESS_WIDTH,",
            "parameter SLV_WIDTH=32,",
            "parameter BUS_WIDTH=512,",
            "parameter [0:0]\tOPT_LITTLE_ENDIAN = 1'b0,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,",
            "parameter [0:0]\tOPT_REGISTER_RAM = 1'b0,",
            "localparam AW=ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Slave port\n\t\t// {{{\n\t\t// Slave/control wishbone",
            "input s",
            "input ",
            "wire i_swb_cyc, i_swb_stb, i_swb_we,",
            "input ",
            "wire [1:0]\t\ti_swb_addr,",
            "input ",
            "wire [SLV_WIDTH-1:0]\ti_swb_data,",
            "input ",
            "wire [SLV_WIDTH/8-1:0]\ti_swb_sel,\n\t\t// Slave/control wishbone",
            "output s\n\t\t// Verilator coverage_off",
            "output ",
            "wire o_swb_stall,\n\t\t// Verilator coverage_on",
            "output ",
            "wire o_swb_ack,",
            "output ",
            "wire [SLV_WIDTH-1:0]\to_swb_data,\n\t\t// }}}\n\t\t// Master/DMA port\n\t\t// {{{",
            "output ",
            "wire o_mwb_cyc, o_mwb_stb, o_mwb_we,",
            "output ",
            "wire [AW-1:0]\to_mwb_addr,",
            "output ",
            "wire [BUS_WIDTH-1:0]\to_mwb_data,",
            "output ",
            "wire [BUS_WIDTH/8-1:0]\to_mwb_sel,\n\t\t// Master/DMA wishbone responses from the bus",
            "input ",
            "wire i_mwb_stall, i_mwb_ack,",
            "input ",
            "wire [BUS_WIDTH-1:0]\ti_mwb_data,",
            "input ",
            "wire i_mwb_err,\n\t\t// }}}\n\t\t// The interrupt device interrupt lines",
            "input ",
            "wire [31:0]\t\ti_dev_ints,\n\t\t// An interrupt to be set upon completion",
            "output ",
            "wire o_interrupt\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "localparam FIFO_WIDTH = BUS_WIDTH+$clog2(BUS_WIDTH/8)+2;",
            "localparam LGFIFO = LGMEMLEN-$clog2(BUS_WIDTH/8);",
            "wire dma_request, dma_abort,\n\t\t\t\t\tdma_busy, dma_err;",
            "wire [ADDRESS_WIDTH-1:0]\tdma_src, dma_dst,\n\t\t\t\t\tread_addr, write_addr;",
            "wire [LGDMALENGTH-1:0]\tdma_length, remaining_len;",
            "wire [LGMEMLEN:0]\t\tdma_transferlen;",
            "wire dma_trigger;",
            "wire mm2s_request, s2mm_request;",
            "wire mm2s_busy, s2mm_busy;",
            "wire mm2s_err, s2mm_err;",
            "wire mm2s_inc, s2mm_inc;",
            "wire [1:0]\t\t\tmm2s_size, s2mm_size;",
            "wire [ADDRESS_WIDTH-1:0]\tmm2s_addr, s2mm_addr;",
            "wire [LGMEMLEN:0]\t\tmm2s_transferlen, s2mm_transferlen;",
            "wire mm2s_rd_cyc, mm2s_rd_stb, mm2s_rd_we,\n\t\t\t\t\tmm2s_rd_stall, mm2s_rd_ack, mm2s_rd_err;",
            "wire [AW-1:0]\t\tmm2s_rd_addr;",
            "wire [BUS_WIDTH-1:0]\t\tmm2s_rd_data;",
            "wire [BUS_WIDTH/8-1:0]\tmm2s_rd_sel;",
            "wire mm2s_valid, mm2s_ready, mm2s_last;",
            "wire [BUS_WIDTH-1:0]\t\tmm2s_data;",
            "wire [$clog2(BUS_WIDTH/8):0]\tmm2s_bytes;",
            "wire rx_valid, rx_ready, rx_last;",
            "wire [BUS_WIDTH-1:0]\t\trx_data;",
            "wire [$clog2(BUS_WIDTH/8):0]\trx_bytes;",
            "wire tx_valid, tx_ready, tx_last;",
            "wire [BUS_WIDTH-1:0]\t\ttx_data;",
            "wire [$clog2(BUS_WIDTH/8):0]\ttx_bytes;",
            "wire sfifo_full, sfifo_empty;",
            "wire [LGFIFO:0]\tign_sfifo_fill;",
            "wire s2mm_valid, s2mm_ready, s2mm_last;",
            "wire [BUS_WIDTH-1:0]\ts2mm_data;",
            "wire [$clog2(BUS_WIDTH/8):0]\ts2mm_bytes;",
            "wire s2mm_wr_cyc, s2mm_wr_stb, s2mm_wr_we,\n\t\t\t\t\ts2mm_wr_stall, s2mm_wr_ack, s2mm_wr_err;",
            "wire [AW-1:0]\t\ts2mm_wr_addr;",
            "wire [BUS_WIDTH-1:0]\t\ts2mm_wr_data;",
            "wire [BUS_WIDTH/8-1:0]\ts2mm_wr_sel;",
            "wire wb_cyc, wb_stb, wb_we,\n\t\t\t\t\twb_stall, wb_ack, wb_err;",
            "wire [AW-1:0]\t\twb_addr;",
            "wire [BUS_WIDTH-1:0]\t\twb_data, wb_idata;",
            "wire [BUS_WIDTH/8-1:0]\twb_sel;\n\t// }}}\n\n\n\tzipdma_ctrl #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t.LGMEMLEN(LGMEMLEN),\n\t\t.LGDMALENGTH(ADDRESS_WIDTH),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER)\n\t\t// }}}\n\t) u_controller (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t// Slave WB control port\n\t\t// {{{\n\t\t// Slave/control wishbone",
            "input s\n\t\t.i_cyc(i_swb_cyc), .i_stb(i_swb_stb), .i_we(i_swb_we),\n\t\t.i_addr(i_swb_addr),\n\t\t.i_data(i_swb_data), .i_sel(i_swb_sel),\n\t\t// Slave/control wishbone",
            "output s\n\t\t.o_stall(o_swb_stall),\n\t\t.o_ack(o_swb_ack), .o_data(o_swb_data),\n\t\t// }}}\n\t\t// Internal DMA controls\n\t\t// {{{\n\t\t.o_dma_request(dma_request), .o_dma_abort(dma_abort),\n\t\t.i_dma_busy(dma_busy),\t.i_dma_err(dma_err),\n\t\t.o_src_addr(dma_src),\t.o_dst_addr(dma_dst),\n\t\t.o_length(dma_length),\t.o_transferlen(dma_transferlen),\n\t\t.o_mm2s_inc(mm2s_inc),\t.o_mm2s_size(mm2s_size),\n\t\t.o_s2mm_inc(s2mm_inc),\t.o_s2mm_size(s2mm_size),\n\t\t//\n\t\t.o_trigger(dma_trigger),\n\t\t//\n\t\t.i_current_src(read_addr),\n\t\t.i_current_dst(write_addr),\n\t\t.i_remaining_len(remaining_len),\n\t\t// }}}\n\t\t.i_dma_int(i_dev_ints), .o_interrupt(o_interrupt)\n\t\t// }}}\n\t);\n\n\tzipdma_fsm #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t.LGDMALENGTH(ADDRESS_WIDTH),\n\t\t.LGSUBLENGTH(LGMEMLEN)\n\t\t// }}}\n\t) u_dma_fsm (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_soft_reset(dma_abort),\n\t\t// DMA control\n\t\t// {{{\n\t\t.i_dma_request(dma_request),\n\t\t.o_dma_busy(dma_busy),\t.o_dma_err(dma_err),\n\t\t.i_src_addr(dma_src),\t.i_dst_addr(dma_dst),\n\t\t.i_length(dma_length),\t.i_transferlen(dma_transferlen),\n\t\t.i_trigger(dma_trigger),\n\t\t.o_remaining_len(remaining_len),\n\t\t// }}}\n\t\t// Downstream MM2S configuration\n\t\t// {{{\n\t\t.o_mm2s_request(mm2s_request),\n\t\t.i_mm2s_busy(mm2s_busy),\n\t\t.i_mm2s_err(mm2s_err),\n\t\t.i_mm2s_inc(mm2s_inc),\n\t\t.o_mm2s_addr(mm2s_addr),\n\t\t.o_mm2s_transferlen(mm2s_transferlen),\n\t\t// }}}\n\t\t// Downstream S2MM configuration\n\t\t// {{{\n\t\t.o_s2mm_request(s2mm_request),\n\t\t.i_s2mm_busy(s2mm_busy),\n\t\t.i_s2mm_err(s2mm_err),\n\t\t.i_s2mm_inc(s2mm_inc),\n\t\t.o_s2mm_addr(s2mm_addr),\n\t\t.o_s2mm_transferlen(s2mm_transferlen)\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\tzipdma_mm2s #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t.LGLENGTH(LGMEMLEN),\n\t\t.OPT_LITTLE_ENDIAN(OPT_LITTLE_ENDIAN),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER)\n\t\t// }}}\n\t) u_mm2s (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset || dma_abort),\n\t\t// DMA control\n\t\t// {{{\n\t\t.i_request(mm2s_request),\n\t\t.o_busy(mm2s_busy),\t.o_err(mm2s_err),\n\t\t.i_inc(mm2s_inc),\t.i_size(mm2s_size),\n\t\t.i_transferlen(mm2s_transferlen),\n\t\t.i_addr(mm2s_addr),\n\t\t// }}}\n\t\t// Wishbone master interface\n\t\t// {{{\n\t\t.o_rd_cyc(mm2s_rd_cyc),\n\t\t.o_rd_stb(mm2s_rd_stb),\n\t\t.o_rd_we(mm2s_rd_we),\n\t\t.o_rd_addr(mm2s_rd_addr),\n\t\t.o_rd_data(mm2s_rd_data),\n\t\t.o_rd_sel(mm2s_rd_sel),\n\t\t//\n\t\t.i_rd_stall(mm2s_rd_stall),\n\t\t.i_rd_ack(mm2s_rd_ack),\n\t\t.i_rd_data(wb_idata),\n\t\t.i_rd_err(mm2s_rd_err),\n\t\t// }}}\n\t\t// MM2S Stream interface\n\t\t// {{{\n\t\t.M_VALID(mm2s_valid),\n\t\t.M_READY(mm2s_ready),\n\t\t.M_DATA(mm2s_data),\n\t\t.M_BYTES(mm2s_bytes),\n\t\t.M_LAST(mm2s_last)\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\tzipdma_rxgears #(\n\t\t// {{{\n\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t.OPT_LITTLE_ENDIAN(OPT_LITTLE_ENDIAN)\n\t\t// }}}\n\t) u_rxgears (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset), .i_soft_reset(dma_abort),\n\t\t//\n\t\t.S_VALID(mm2s_valid), .S_READY(mm2s_ready),\n\t\t.S_DATA(mm2s_data), .S_BYTES(mm2s_bytes),\n\t\t.S_LAST(mm2s_last),\n\t\t//\n\t\t.M_VALID(rx_valid), .M_READY(rx_ready),\n\t\t.M_DATA(rx_data), .M_BYTES(rx_bytes),\n\t\t.M_LAST(rx_last)\n\t\t// }}}\n\t);\n\n\tsfifo #(\n\t\t// {{{\n\t\t.BW(FIFO_WIDTH),\n\t\t.LGFLEN(LGFIFO),\n\t\t.OPT_ASYNC_READ(!OPT_REGISTER_RAM),\n\t\t.OPT_WRITE_ON_FULL(1'b0),\n\t\t.OPT_READ_ON_EMPTY(1'b0)\n\t\t// }}}\n\t) u_sfifo (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset || dma_abort),\n\t\t//\n\t\t.i_wr(rx_valid), .i_data({ rx_last, rx_bytes, rx_data }),\n\t\t.o_full(sfifo_full), .o_fill(ign_sfifo_fill),\n\t\t//\n\t\t.i_rd(tx_ready), .o_data({ tx_last, tx_bytes, tx_data }),\n\t\t.o_empty(sfifo_empty)\n\t\t// }}}\n\t);\n\n\tassign\trx_ready = !sfifo_full;\n\tassign\ttx_valid = !sfifo_empty;\n\n\tzipdma_txgears #(\n\t\t// {{{\n\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t.OPT_LITTLE_ENDIAN(OPT_LITTLE_ENDIAN)\n\t\t// }}}\n\t) u_txgears (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_soft_reset(dma_abort), .i_size(s2mm_size),\n\t\t// Incoming stream\n\t\t// {{{\n\t\t.S_VALID(tx_valid),\t.S_READY(tx_ready),\n\t\t.S_DATA(tx_data),\t.S_BYTES(tx_bytes),\n\t\t.S_LAST(tx_last),\n\t\t// }}}\n\t\t// Outgoing stream to S2MM\n\t\t// {{{\n\t\t.M_VALID(s2mm_valid),\t.M_READY(s2mm_ready),\n\t\t.M_DATA(s2mm_data),\t.M_BYTES(s2mm_bytes),\n\t\t.M_LAST(s2mm_last)\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\tzipdma_s2mm #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t.OPT_LITTLE_ENDIAN(OPT_LITTLE_ENDIAN),\n\t\t.LGPIPE(LGMEMLEN)\n\t\t// }}}\n\t) u_s2mm (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset || dma_abort),\n\t\t// S2MM configuration\n\t\t// {{{\n\t\t.i_request(s2mm_request),\n\t\t.o_busy(s2mm_busy),\t.o_err(s2mm_err),\n\t\t.i_inc(s2mm_inc),\t.i_size(s2mm_size),\n\t\t.i_addr(s2mm_addr),\n\t\t// }}}\n\t\t// Stream data source\n\t\t// {{{\n\t\t.S_VALID(s2mm_valid),\t.S_READY(s2mm_ready),\n\t\t.S_DATA(s2mm_data),\t.S_BYTES(s2mm_bytes),\n\t\t.S_LAST(s2mm_last),\n\t\t// }}}\n\t\t// Outgoing Wishbone interface\n\t\t// {{{\n\t\t.o_wr_cyc(s2mm_wr_cyc),\n\t\t.o_wr_stb(s2mm_wr_stb),\n\t\t.o_wr_we(s2mm_wr_we),\n\t\t.o_wr_addr(s2mm_wr_addr),\n\t\t.o_wr_data(s2mm_wr_data),\n\t\t.o_wr_sel(s2mm_wr_sel),\n\t\t//\n\t\t.i_wr_stall(s2mm_wr_stall),\n\t\t.i_wr_ack(s2mm_wr_ack),\n\t\t.i_wr_data({(BUS_WIDTH){1'b0}}),\n\t\t.i_wr_err(s2mm_wr_err)\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\twbarbiter #(\n\t\t// {{{\n\t\t.DW(BUS_WIDTH), .AW(AW), .OPT_ZERO_ON_IDLE(OPT_LOWPOWER)\n\t\t// }}}\n\t) u_arbiter (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t//\n\t\t.i_a_cyc(mm2s_rd_cyc),\t\t.i_a_stb(mm2s_rd_stb),\n\t\t.i_a_we(mm2s_rd_we),\t\t.i_a_adr(mm2s_rd_addr),\n\t\t.i_a_dat((OPT_LOWPOWER) ? mm2s_rd_data : s2mm_wr_data),\n\t\t\t\t\t\t.i_a_sel(mm2s_rd_sel),\n\t\t.o_a_stall(mm2s_rd_stall),\t.o_a_ack(mm2s_rd_ack),\n\t\t.o_a_err(mm2s_rd_err),\n\t\t//\n\t\t.i_b_cyc(s2mm_wr_cyc),\t\t.i_b_stb(s2mm_wr_stb),\n\t\t.i_b_we(s2mm_wr_we),\t\t.i_b_adr(s2mm_wr_addr),\n\t\t.i_b_dat(s2mm_wr_data),\t\t.i_b_sel(s2mm_wr_sel),\n\t\t.o_b_stall(s2mm_wr_stall),\t.o_b_ack(s2mm_wr_ack),\n\t\t.o_b_err(s2mm_wr_err),\n\t\t//\n\t\t.o_cyc(wb_cyc),\t\t\t.o_stb(wb_stb),\n\t\t.o_we(wb_we),\t\t\t.o_adr(wb_addr),\n\t\t.o_dat(wb_data),\t\t.o_sel(wb_sel),\n\t\t.i_stall(wb_stall),\t\t.i_ack(wb_ack),\n\t\t.i_err(wb_err)\n\t\t// }}}\n\t);\n\n\tassign\to_mwb_cyc  = wb_cyc;\n\tassign\to_mwb_stb  = wb_stb;\n\tassign\to_mwb_we   = wb_we;\n\tassign\to_mwb_addr = wb_addr;\n\tassign\to_mwb_data = wb_data;\n\tassign\to_mwb_sel  = wb_sel;\n\tassign\twb_stall   = i_mwb_stall;\n\tassign\twb_ack     = i_mwb_ack;\n\tassign\twb_idata   = i_mwb_data;\n\tassign\twb_err     = i_mwb_err;\n\n\tassign\tread_addr  = { mm2s_rd_addr, {($clog2(BUS_WIDTH/8)){1'b0}} };\n\tassign\twrite_addr = { s2mm_wr_addr, {($clog2(BUS_WIDTH/8)){1'b0}} };\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, ign_sfifo_fill, mm2s_rd_data, rx_ready,\n\t\t\t\ts2mm_transferlen };\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "reg f_past_valid;\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "cpuops.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/cpuops.v",
        "chunks": [
            "module cpuops #(\n\t\t// {{{",
            "parameter OPT_MPY = 3,\t// == 0 (no mpy),1-4,36",
            "parameter [0:0]\tOPT_SHIFTS = 1'b1,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b1\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset, i_stb,",
            "input ",
            "wire [3:0]\ti_op,",
            "input ",
            "wire [31:0]\ti_a, i_b,",
            "output ",
            "reg [31:0]\to_c,",
            "output ",
            "wire [3:0]\to_f,",
            "output ",
            "reg o_valid,\n`ifdef\tVMPY_TB\n\t\t// {{{\n\t\t// Define some",
            "wire s used to peek at internal values during\n\t\t// simulation.  These are *ONLY* used by the ZipCPU mpy_tb\n\t\t// simulation testbench.  They are *NOT* used during synthesis,\n\t\t// and not intended to be used outside of the ZipCPU setup.\n\t\t//",
            "output ",
            "wire [5:0]\tOPT_MULTIPLY,",
            "output ",
            "wire [31:0]\tmpy_a_",
            "input , mpy_b_",
            "input ,",
            "output ",
            "wire [63:0]\tmpy_",
            "output ,",
            "output ",
            "wire [2:0]\tmpy_pipe,\n\t\t// }}}\n`endif",
            "output ",
            "wire o_busy\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "wire [31:0]\tw_brev_result;",
            "wire z, n, v, vx;",
            "reg c, pre_sign, set_ovfl, keep_sgn_on_ovfl;",
            "wire [32:0]\t\tw_lsr_result, w_asr_result, w_lsl_result;",
            "wire [63:0]\tmpy_result; // Where we dump the multiply result",
            "wire mpyhi;\t\t// Return the high half of the multiply",
            "wire mpybusy;\t// The multiply is busy if true",
            "wire mpydone;\t// True if we'll be valid on the next clock;",
            "wire this_is_a_multiply_op;",
            "reg r_busy;\n\n\tgenvar\tk;\n\t// }}}\n\n\t// Shift",
            "reg ister pre-",
            "logic // {{{\n\tgenerate if (OPT_SHIFTS)\n\tbegin : IMPLEMENT_SHIFTS",
            "wire signed\t[32:0]\tw_pre_asr_",
            "input , w_pre_asr_shifted;\n\t\tassign\tw_pre_asr_",
            "input = { i_a, 1'b0 };\n\t\tassign\tw_pre_asr_shifted = w_pre_asr_",
            "input >>> i_b[4:0];\n\t\tassign\tw_asr_result = (|i_b[31:5])? {(33){i_a[31]}}\n\t\t\t\t\t: w_pre_asr_shifted;// ASR\n\t\tassign\tw_lsr_result = ((|i_b[31:6])||(i_b[5]&&(i_b[4:0]!=0)))? 33'h00\n\t\t\t\t\t:((i_b[5])?{32'h0,i_a[31]}\n\n\t\t\t\t\t: ( { i_a, 1'b0 } >> (i_b[4:0]) ));// LSR\n\t\tassign\tw_lsl_result = ((|i_b[31:6])||(i_b[5]&&(i_b[4:0]!=0)))? 33'h00\n\t\t\t\t\t:((i_b[5])?{i_a[0], 32'h0}\n\t\t\t\t\t: ({1'b0, i_a } << i_b[4:0]));\t// LSL\n\tend else begin : NO_SHIFTS\n\n\t\tassign\tw_asr_result = {   i_a[31], i_a[31:0] };\n\t\tassign\tw_lsr_result = {      1'b0, i_a[31:0] };\n\t\tassign\tw_lsl_result = { i_a[31:0],      1'b0 };\n\n\tend endgenerate\n\t// }}}\n\n\t//\n\t// Bit reversal pre-",
            "logic // {{{\n\tgenerate\n\tfor(k=0; k<32; k=k+1)\n\tbegin : bit_reversal_cpuop\n\t\tassign w_brev_result[k] = i_b[31-k];\n\tend endgenerate\n\t// }}}\n\n\t// Pre",
            "logic for our flags",
            "reg isters : set_ovfl and keep_sgn_on_ovfl\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_stb) // 1 LUT\n\t\tset_ovfl<=(((i_op==4'h0)&&(i_a[31] != i_b[31]))//SUB&CMP\n\t\t\t||((i_op==4'h2)&&(i_a[31] == i_b[31])) // ADD\n\t\t\t||(i_op == 4'h6) // LSL\n\t\t\t||(i_op == 4'h5)); // LSR\n\n\talways @(posedge i_clk)\n\tif (i_stb) // 1 LUT\n\t\tkeep_sgn_on_ovfl<=\n\t\t\t(((i_op==4'h0)&&(i_a[31] != i_b[31]))//SUB&CMP\n\t\t\t||((i_op==4'h2)&&(i_a[31] == i_b[31]))); // ADD\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Multiply handling\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// A 4-way multiplexer can be done in one 6-LUT.\n\t// A 16-way multiplexer can therefore be done in 4x 6-LUT's with\n\t//\tthe Xilinx multiplexer fabric that follows.\n\t// Given that we wish to apply this multiplexer approach to 33-bits,\n\t// this will cost a minimum of 132 6-LUTs.\n\n\tassign\tthis_is_a_multiply_op = (i_stb)&&((i_op[3:1]==3'h5)||(i_op[3:0]==4'hc));\n\n`ifdef\tFORMAL\n`define\tMPYOP\tabs_mpy\n`else\n`define\tMPYOP\tmpyop\n`endif\n\t`MPYOP #(\n\t\t// {{{\n\t\t.OPT_MPY(OPT_MPY),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER)\n\t\t// }}}\n\t) thempy(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_stb(this_is_a_multiply_op), .i_op(i_op[1:0]),\n\t\t.i_a(i_a), .i_b(i_b), .o_valid(mpydone),\n\t\t.o_busy(mpybusy), .o_result(mpy_result), .o_hi(mpyhi)\n\t\t// }}}\n\t);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The master ALU case statement\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_stb)\n\tbegin\n\t\tpre_sign <= (i_a[31]);\n\t\tc <= 1'b0;\n\t\tcasez(i_op)\n\t\t4'b0000:{c,o_c } <= {1'b0,i_a}-{1'b0,i_b};// CMP/SUB\n\t\t4'b0001:   o_c   <= i_a & i_b;\t\t// BTST/And\n\t\t4'b0010:{c,o_c } <= i_a + i_b;\t\t// Add\n\t\t4'b0011:   o_c   <= i_a | i_b;\t\t// Or\n\t\t4'b0100:   o_c   <= i_a ^ i_b;\t\t// Xor\n\t\t4'b0101:{o_c,c } <= w_lsr_result[32:0];\t// LSR\n\t\t4'b0110:{c,o_c } <= w_lsl_result[32:0]; // LSL\n\t\t4'b0111:{o_c,c } <= w_asr_result[32:0];\t// ASR\n\t\t4'b1000:   o_c   <= w_brev_result;\t// BREV\n\t\t4'b1001:   o_c   <= { i_a[31:16], i_b[15:0] }; // LODILO\n\t\t4'b1010:   o_c   <= mpy_result[63:32];\t// MPYHU\n\t\t4'b1011:   o_c   <= mpy_result[63:32];\t// MPYHS\n\t\t4'b1100:   o_c   <= mpy_result[31:0];\t// MPY\n\t\tdefault:   o_c   <= i_b;\t\t// MOV, LDI\n\t\tendcase\n\tend else if (!OPT_LOWPOWER || mpydone)\n\t\t// set the",
            "output based upon the multiply result\n\t\to_c <= (mpyhi)?mpy_result[63:32]:mpy_result[31:0];\n\t// }}}\n\n\t// o_busy, r_busy\n\t// {{{\n\tinitial\tr_busy = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_busy <= 1'b0;\n\telse if (OPT_MPY > 1)\n\t\tr_busy <= ((i_stb)&&(this_is_a_multiply_op))||mpybusy;\n\telse\n\t\tr_busy <= 1'b0;\n\n\tassign\to_busy = (r_busy); // ||((OPT_MPY>1)&&(this_is_a_multiply_op));\n\t// }}}\n\n\t// Flags assignment and determination\n\t// {{{\n\tassign\tz = (o_c == 32'h0000);\n\tassign\tn = (o_c[31]);\n\tassign\tv = (set_ovfl)&&(pre_sign != o_c[31]);\n\tassign\tvx = (keep_sgn_on_ovfl)&&(pre_sign != o_c[31]);\n\n\tassign\to_f = { v, n^vx, c, z };\n\t// }}}\n\n\t// o_valid\n\t// {{{\n\tinitial\to_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_valid <= 1'b0;\n\telse if (OPT_MPY <= 1)\n\t\to_valid <= (i_stb);\n\telse\n\t\to_valid <=((i_stb)&&(!this_is_a_multiply_op))||(mpydone);\n\t// }}}\n\n`ifdef\tVMPY_TB\n// {{{\n\tassign\tOPT_MULTIPLY = OPT_MPY;\n\tgenerate if (OPT_MPY == 0)\n\tbegin : VGEN0\n\t\tassign\tmpy_a_",
            "input = 0;\n\t\tassign\tmpy_b_",
            "input = 0;\n\t\tassign\tmpy_pipe = 1'b0;\n\tend else if (OPT_MPY == 1)\n\tbegin : VGEN1\n\t\tassign\tmpy_a_",
            "input = thempy.IMPY.MPY1CK.w_mpy_a_",
            "input [31:0];\n\t\tassign\tmpy_b_",
            "input = thempy.IMPY.MPY1CK.w_mpy_b_",
            "input [31:0];\n\t\tassign\tmpy_pipe = 3'b0;\n\tend else if (OPT_MPY == 2)\n\tbegin : VGEN2\n\t\tassign\tmpy_a_",
            "input = thempy.IMPY.MPN1.MPY2CK.r_mpy_a_",
            "input [31:0];\n\t\tassign\tmpy_b_",
            "input = thempy.IMPY.MPN1.MPY2CK.r_mpy_b_",
            "input [31:0];\n\t\tassign\tmpy_pipe = { 2'b0, thempy.IMPY.MPN1.MPY2CK.mpypipe };\n\tend else if (OPT_MPY == 3)\n\tbegin : VGEN_NORMAL\n\t\tassign\tmpy_a_",
            "input = thempy.IMPY.MPN1.MPN2.MPY3CK.r_mpy_a_",
            "input ;\n\t\tassign\tmpy_b_",
            "input = thempy.IMPY.MPN1.MPN2.MPY3CK.r_mpy_b_",
            "input ;\n\t\tassign\tmpy_pipe = { 1'b0, thempy.IMPY.MPN1.MPN2.MPY3CK.mpypipe };\n\tend else if (OPT_MPY == 4)\n\tbegin : VGEN_PARTIAL\n\t\tassign\tmpy_a_",
            "input = thempy.IMPY.MPN1.MPN2.MPN3.MPY4CK.r_mpy_a_",
            "input ;\n\t\tassign\tmpy_b_",
            "input = thempy.IMPY.MPN1.MPN2.MPN3.MPY4CK.r_mpy_b_",
            "input ;\n\t\tassign\tmpy_pipe = thempy.IMPY.MPN1.MPN2.MPN3.MPY4CK.mpypipe;\n\tend else begin : VGEN_SLOW\n\t\tassign\tmpy_a_",
            "input = thempy.IMPY.MPN1.MPN2.MPN3.MPYSLOW.slowmpyi.i_a[31:0];\n\t\tassign\tmpy_b_",
            "input = thempy.IMPY.MPN1.MPN2.MPN3.MPYSLOW.slowmpyi.i_b[31:0];\n\t\tassign\tmpy_pipe = {(3){mpybusy}};\n\tend endgenerate\n\n\tassign\tmpy_",
            "output = mpy_result;\n// }}}\n`endif\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Declarations\n\t// {{{\n\tinitial\tassume(i_reset);",
            "reg f_past_valid;\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\t// }}}\n\n`define\tASSERT\tassert\n`ifdef\tCPUOPS\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif\n\n\t// No request should be given us if/while we are busy\n\t// {{{\n\talways @(posedge i_clk)\n\tif (o_busy)\n\t\t`ASSUME(!i_stb);\n\t// }}}\n\n\t// Following any request other than a multiply request, we should\n\t// respond in the next cycle\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(o_busy))&&(!$past(this_is_a_multiply_op)))\n\t\t`ASSERT(!o_busy);\n\t// }}}\n\n\t// Valid and busy can never both be asserted\n\t// {{{\n\talways @(posedge i_clk)\n\t\t`ASSERT((!o_valid)||(!r_busy));\n\t// }}}\n\n\t// Following any busy, we should always become valid\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_busy))&&(!o_busy))\n\t\t`ASSERT($past(i_reset) || o_valid);\n\t// }}}\n\n\t// Check the shift values\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_stb)))\n\tbegin\n\t\tif (($past(|i_b[31:6]))||($past(i_b[5:0])>6'd32))\n\t\tbegin\n\t\t\tassert(($past(i_op)!=4'h5)\n\t\t\t\t\t||({o_c,c}=={(33){1'b0}}));\n\t\t\tassert(($past(i_op)!=4'h6)\n\t\t\t\t\t||({c,o_c}=={(33){1'b0}}));\n\t\t\tassert(($past(i_op)!=4'h7)\n\t\t\t\t\t||({o_c,c}=={(33){$past(i_a[31])}}));\n\t\tend else if ($past(i_b[5:0]==6'd32))\n\t\tbegin\n\t\t\tassert(($past(i_op)!=4'h5)\n\t\t\t\t||(o_c=={(32){1'b0}}));\n\t\t\tassert(($past(i_op)!=4'h6)\n\t\t\t\t||(o_c=={(32){1'b0}}));\n\t\t\tassert(($past(i_op)!=4'h7)\n\t\t\t\t||(o_c=={(32){$past(i_a[31])}}));\n\t\tend if ($past(i_b)==0)\n\t\tbegin\n\t\t\tassert(($past(i_op)!=4'h5)\n\t\t\t\t||({o_c,c}=={$past(i_a), 1'b0}));\n\t\t\tassert(($past(i_op)!=4'h6)\n\t\t\t\t||({c,o_c}=={1'b0, $past(i_a)}));\n\t\t\tassert(($past(i_op)!=4'h7)\n\t\t\t\t||({o_c,c}=={$past(i_a), 1'b0}));\n\t\tend if ($past(i_b)==1)\n\t\tbegin\n\t\t\tassert(($past(i_op)!=4'h5)\n\t\t\t\t||({o_c,c}=={1'b0, $past(i_a)}));\n\t\t\tassert(($past(i_op)!=4'h6)\n\t\t\t\t||({c,o_c}=={$past(i_a),1'b0}));\n\t\t\tassert(($past(i_op)!=4'h7)\n\t\t\t\t||({o_c,c}=={$past(i_a[31]),$past(i_a)}));\n\t\tend if ($past(i_b)==2)\n\t\tbegin\n\t\t\tassert(($past(i_op)!=4'h5)\n\t\t\t\t||({o_c,c}=={2'b0, $past(i_a[31:1])}));\n\t\t\tassert(($past(i_op)!=4'h6)\n\t\t\t\t||({c,o_c}=={$past(i_a[30:0]),2'b0}));\n\t\t\tassert(($past(i_op)!=4'h7)\n\t\t\t\t||({o_c,c}=={{(2){$past(i_a[31])}},$past(i_a[31:1])}));\n\t\tend if ($past(i_b)==31)\n\t\tbegin\n\t\t\tassert(($past(i_op)!=4'h5)\n\t\t\t\t||({o_c,c}=={31'b0, $past(i_a[31:30])}));\n\t\t\tassert(($past(i_op)!=4'h6)\n\t\t\t\t||({c,o_c}=={$past(i_a[1:0]),31'b0}));\n\t\t\tassert(($past(i_op)!=4'h7)\n\t\t\t\t||({o_c,c}=={{(31){$past(i_a[31])}},$past(i_a[31:30])}));\n\t\tend\n\tend\n\t// }}}\n`endif\n// }}}",
            "endmodule //\n// iCE40\tNoMPY,w/Shift\tNoMPY,w/o Shift\n//  SB_CARRY\t\t 64\t\t 64\n//  SB_DFFE\t\t  3\t\t  3\n//  SB_DFFESR\t\t  1\t\t  1\n//  SB_DFFSR\t\t 33\t\t 33\n//  SB_LUT4\t\t748\t\t323"
        ]
    },
    {
        "file_name": "axilpipe.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axilpipe.v",
        "chunks": [
            "module axilpipe #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=30,",
            "parameter C_AXI_ADDR_WIDTH = ADDRESS_WIDTH,",
            "parameter C_AXI_DATA_WIDTH = 32,",
            "localparam AW = C_AXI_ADDR_WIDTH,",
            "localparam DW = C_AXI_DATA_WIDTH,\n\t\t//\n\t\t// AXI locks are a challenge, and require support from the\n\t\t// CPU.  Specifically, we have to be able to unroll and re-do\n\t\t// the load instruction on any atomic access failure.  For that\n\t\t// reason, we'll ignore the lock request initially.",
            "parameter [0:0]\tOPT_ALIGNMENT_ERR = 1'b1,\n\t\t// Verilator lint_off UNUSED\n\t\t// This *should* be used -- need to rewrite so that it is",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,\n\t\t// Verilator lint_on  UNUSED",
            "parameter [0:0]\tSWAP_WSTRB = 0,",
            "parameter [0:0]\tOPT_SIGN_EXTEND = 0\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,",
            "input ",
            "wire i_cpu_reset,\n\t\t//\n\t\t// CPU interface\n\t\t// {{{",
            "input ",
            "wire i_stb,",
            "input ",
            "wire i_lock,",
            "input ",
            "wire [2:0]\t\t\ti_op,",
            "input ",
            "wire [31:0]\t\t\ti_addr,",
            "input ",
            "wire [31:0]\t\t\ti_data,",
            "input ",
            "wire [4:0]\t\t\ti_o",
            "reg ,",
            "output ",
            "reg o_busy,",
            "output ",
            "reg o_pipe_stalled,",
            "output ",
            "reg o_rdbusy,",
            "output ",
            "reg o_valid,",
            "output ",
            "reg o_err,",
            "output ",
            "reg [4:0]\t\t\to_w",
            "reg ,",
            "output ",
            "reg [31:0]\t\t\to_result,\n\t\t// }}}\n\t\t//\n\t\t// AXI-Lite bus interface\n\t\t// {{{\n\t\t// Writes\n\t\t// {{{",
            "output ",
            "reg M_AXI_AWVALID,",
            "input ",
            "wire M_AXI_AWREADY,",
            "output ",
            "reg [AW-1:0]\tM_AXI_AWADDR,\n\t\t// verilator coverage_off",
            "output ",
            "wire [2:0]\t\tM_AXI_AWPROT,\n\t\t// verilator coverage_on\n\t\t//",
            "output ",
            "reg M_AXI_WVALID,",
            "input ",
            "wire M_AXI_WREADY,",
            "output ",
            "reg [DW-1:0]\tM_AXI_WDATA,",
            "output ",
            "reg [DW/8-1:0]\tM_AXI_WSTRB,\n\t\t//",
            "input ",
            "wire M_AXI_BVALID,",
            "output ",
            "wire M_AXI_BREADY,",
            "input ",
            "wire [1:0]\t\tM_AXI_BRESP,\n\t\t// }}}\n\t\t// Reads\n\t\t// {{{",
            "output ",
            "reg M_AXI_ARVALID,",
            "input ",
            "wire M_AXI_ARREADY,",
            "output ",
            "reg [AW-1:0]\tM_AXI_ARADDR,\n\t\t// verilator coverage_off",
            "output ",
            "wire [2:0]\t\tM_AXI_ARPROT,\n\t\t// verilator coverage_on\n\t\t//",
            "input ",
            "wire M_AXI_RVALID,",
            "output ",
            "wire M_AXI_RREADY,",
            "input ",
            "wire [DW-1:0]\tM_AXI_RDATA,",
            "input ",
            "wire [1:0]\t\tM_AXI_RRESP\n\t\t// }}}\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam AXILLSB = $clog2(C_AXI_DATA_WIDTH/8);",
            "localparam AXILSB = $clog2(C_AXI_DATA_WIDTH/8);",
            "localparam LGPIPE = 4;",
            "localparam FIFO_WIDTH = AXILLSB+1+2+5 + 1;",
            "wire i_clk = S_AXI_ACLK;",
            "reg w_misaligned;",
            "wire misaligned_request, misaligned_aw_request, pending_err,\n\t\t\tw_misalignment_err;",
            "reg [C_AXI_DATA_WIDTH-1:0]\tnext_wdata;",
            "reg [C_AXI_DATA_WIDTH/8-1:0]\tnext_wstrb;",
            "reg none_outstanding, bus_abort,\n\t\t\t\t\tread_abort, write_abort;",
            "reg [LGPIPE:0]\t\tbeats_outstanding;",
            "reg r_flushing, flush_request,\n\t\t\t\t\tr_pipe_stalled;",
            "reg [LGPIPE:0]\t\tflushcount, new_flushcount;",
            "reg [LGPIPE:0]\t\twraddr, rdaddr;",
            "reg [4:0]\t\t\tar_o",
            "reg ;",
            "reg [1:0]\t\t\tar_op;",
            "reg [AXILSB-1:0]\t\tadr_lsb;",
            "reg [FIFO_WIDTH-1:0]\tfifo_data\t[0:((1<<LGPIPE)-1)];",
            "reg [FIFO_WIDTH-1:0]\tfifo_read_data;",
            "wire fifo_read_op, fifo_misaligned;",
            "wire [1:0]\t\t\tfifo_op;",
            "wire [4:0]\t\t\tfifo_return_",
            "reg ;",
            "wire [AXILSB-1:0]\t\tfifo_lsb;",
            "reg [2*C_AXI_DATA_WIDTH-1:0]\twide_return, wide_wdata;",
            "reg [31:0]\t\t\tpre_result;",
            "reg [2*C_AXI_DATA_WIDTH/8-1:0]\twide_wstrb;",
            "reg [C_AXI_DATA_WIDTH-1:0]\tmisdata;\n\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Transaction issue\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// AWVALID\n\t// {{{\n\tinitial\tM_AXI_AWVALID = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tM_AXI_AWVALID <= 0;\n\telse if (!M_AXI_AWVALID || M_AXI_AWREADY)\n\tbegin\n\t\tif (i_stb && i_op[0])\n\t\t\tM_AXI_AWVALID <= 1;\n\t\telse\n\t\t\tM_AXI_AWVALID <= M_AXI_AWVALID && misaligned_aw_request;\n\n\t\tif ((write_abort && !misaligned_aw_request)||w_misalignment_err)\n\t\t\tM_AXI_AWVALID <= 0;\n\tend\n\t// }}}\n\n\t// WVALID\n\t// {{{\n\tinitial\tM_AXI_WVALID = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tM_AXI_WVALID <= 0;\n\telse if (!M_AXI_WVALID || M_AXI_WREADY)\n\tbegin\n\t\tif (i_stb && i_op[0])\n\t\t\tM_AXI_WVALID <= 1;\n\t\telse\n\t\t\tM_AXI_WVALID <= M_AXI_WVALID && misaligned_request;\n\n\t\tif ((write_abort && !misaligned_request)||w_misalignment_err)\n\t\t\tM_AXI_WVALID <= 0;\n\tend\n\t// }}}\n\n\t// ARVALID\n\t// {{{\n\tinitial\tM_AXI_ARVALID = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tM_AXI_ARVALID <= 0;\n\telse if (!M_AXI_ARVALID || M_AXI_ARREADY)\n\tbegin\n\t\tif (i_stb && !i_op[0])\n\t\t\tM_AXI_ARVALID <= 1;\n\t\telse\n\t\t\tM_AXI_ARVALID <= M_AXI_ARVALID && misaligned_request;\n\n\t\tif ((read_abort && !misaligned_request)||w_misalignment_err)\n\t\t\tM_AXI_ARVALID <= 0;\n\tend\n\t// }}}\n\n\t// o_busy,\n\t// {{{\n\t// True if the bus is busy doing ... something, whatever it might be.\n\t// If the bus is busy, the CPU will avoid issuing further interactions\n\t// to the bus other than pipelined interactions.\n\tinitial\to_busy = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\to_busy <= 0;\n\telse if (i_stb && !w_misalignment_err && !bus_abort)\n\t\to_busy <= 1;\n\telse if (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID)\n\t\to_busy <= 1;\n\telse if (beats_outstanding > ((M_AXI_RVALID || M_AXI_BVALID) ? 1:0))\n\t\to_busy <= 1;\n\telse\n\t\to_busy <= 0;\n`ifdef\tFORMAL\n\talways @(*)\n\t\tassert(o_busy == (!none_outstanding || M_AXI_ARVALID\n\t\t\t\t|| M_AXI_AWVALID || M_AXI_WVALID));\n`endif\n\t// }}}\n\n\t// Read busy\n\t// {{{\n\t// True if the CPU should expect some kind of pending response from a\n\t// read, and so should stall for that purpose.  False otherwise.\n\tinitial\to_rdbusy = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_cpu_reset || r_flushing)\n\t\to_rdbusy <= 0;\n\telse if ((i_stb && w_misalignment_err) || bus_abort)\n\t\to_rdbusy <= 0;\n\telse if (i_stb && !i_op[0])\n\t\to_rdbusy <= 1;\n\telse if (o_rdbusy && !M_AXI_ARVALID)\n\t\to_rdbusy <= (beats_outstanding > (M_AXI_RVALID ? 1:0));\n\n`ifdef\tFORMAL",
            "reg writing;\n\n\talways @(posedge S_AXI_ACLK)\n\tif (i_stb && !o_busy)\n\t\twriting <= i_op[0];\n\n\talways @(*)\n\tbegin\n\t\tif (writing)\n\t\t\tassert(!o_rdbusy);\n\t\tif (r_flushing)\n\t\t\tassert(!o_rdbusy);\n\t\tif (!o_busy)\n\t\t\tassert(!o_rdbusy);\n\tend\n`endif\n\t// }}}\n\n\t// o_pipe_stalled, r_pipe_stalled\n\t// {{{\n\t// True if the CPU should expect some kind of pending response from a\n\t// read, and so should stall for that purpose.  False otherwise.\n\tgenerate if (OPT_ALIGNMENT_ERR)\n\tbegin : FULL_PIPE_STALL\n\t\t// {{{\n\t\t// Here, we stall if the FIFO is ever full.  In this case,\n\t\t// any new beat will count as only one item to the FIFO, and\n\t\t// so we can run all the way to full.",
            "reg [LGPIPE:0]\t\tbeats_committed;\n\n\t\talways @(*)\n\t\t\tbeats_committed = beats_outstanding\n\t\t\t\t+ ((i_stb && !w_misalignment_err) ? 1:0)\n\t\t\t\t+ ((M_AXI_AWVALID || M_AXI_WVALID\n\t\t\t\t\t\t|| M_AXI_ARVALID) ? 1:0);\n\n\t\tinitial\tr_pipe_stalled = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (i_cpu_reset)\n\t\t\tr_pipe_stalled <= 0;\n\t\telse if (M_AXI_RVALID || M_AXI_BVALID)\n\t\t\tr_pipe_stalled <= 0;\n\t\telse // if (!r_pipe_stalled)\n\t\t\tr_pipe_stalled <= (beats_committed >= (1<<LGPIPE));\n\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (beats_outstanding + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0) >= (1<<LGPIPE))\n\t\tbegin\n\t\t\tassert(r_pipe_stalled || r_flushing);\n\t\tend else if (beats_outstanding + (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) < (1<<LGPIPE)-1)\n\t\t\tassert(!r_pipe_stalled);\n`endif\n\t\t// }}}\n\tend else begin : PENULTIMATE_FULL_STALL\n\t\t// {{{\n\t\t// If we allow for misaligned reads and writes, than we have\n\t\t// to stall the CPU just before the FIFO is full, lest the\n\t\t// CPU send us a value that needs two items to be placed into\n\t\t// the FIO.",
            "reg [LGPIPE:0]\t\tbeats_committed;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tbeats_committed = beats_outstanding + (i_stb ? 1:0)\n\t\t\t\t+ ((M_AXI_AWVALID || M_AXI_WVALID\n\t\t\t\t\t\t|| M_AXI_ARVALID) ? 1:0)\n\t\t\t\t- ((M_AXI_BVALID || M_AXI_RVALID) ? 1:0);\n\t\tend\n\n\t\tinitial\tr_pipe_stalled = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (i_cpu_reset || bus_abort)\n\t\t\tr_pipe_stalled <= 0;\n\t\telse begin\n\t\t\tr_pipe_stalled <= 0;\n\t\t\tif (i_stb && w_misaligned && !o_pipe_stalled)\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\tif (misaligned_request && (M_AXI_WVALID && !M_AXI_WREADY))\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\tif (misaligned_request && (M_AXI_ARVALID && !M_AXI_ARREADY))\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\tif (misaligned_aw_request && (M_AXI_AWVALID && !M_AXI_AWREADY))\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\tif (beats_committed >= (1<<LGPIPE)-2)\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\tend\n\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (!r_flushing && (beats_outstanding\n\t\t\t\t+ (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID)\n\t\t\t\t+ (misaligned_aw_request || misaligned_request)\n\t\t\t\t>= (1<<LGPIPE)))\n\t\tbegin\n\t\t\tassert(r_pipe_stalled);\n\t\tend else if (!r_flushing && !o_err\n\t\t\t\t&& !M_AXI_AWVALID && !M_AXI_WVALID\n\t\t\t\t&& !M_AXI_ARVALID\n\t\t\t\t&& beats_outstanding <= ((1<<LGPIPE)-4))\n\t\t\tassert(!r_pipe_stalled);\n\n\t\talways @(*)\n\t\t\tassert(beats_committed\n\t\t\t\t+ ((i_stb && w_misaligned && !r_pipe_stalled) ? 1:0)\n\t\t\t\t<= (1<<LGPIPE));\n`endif\n\t\t// }}}\n\tend endgenerate\n\n\talways @(*)\n\tbegin\n\t\to_pipe_stalled = r_pipe_stalled || r_flushing;\n\t\tif (M_AXI_AWVALID && (!M_AXI_AWREADY || misaligned_aw_request))\n\t\t\to_pipe_stalled = 1;\n\t\tif (M_AXI_WVALID && (!M_AXI_WREADY || misaligned_request))\n\t\t\to_pipe_stalled = 1;\n\t\tif (M_AXI_ARVALID && (!M_AXI_ARREADY || misaligned_request))\n\t\t\to_pipe_stalled = 1;\n\tend\n`ifdef\tFORMAL\n\talways @(*)\n\tif (misaligned_request)\n\t\tassert(M_AXI_WVALID || M_AXI_ARVALID);\n\n\talways @(*)\n\tif (misaligned_aw_request)\n\t\tassert(M_AXI_AWVALID);\n`endif\n\t// }}}\n\n\t// Count the number of outstanding beats\n\t// {{{\n\t// This is the true count.  It is not affected by the number of\n\t// items the CPU believes is on the bus or not.\n\tinitial\tbeats_outstanding = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tbeats_outstanding <= 0;\n\telse casez({M_AXI_AWVALID && M_AXI_AWREADY,\n\t\tM_AXI_WVALID && M_AXI_WREADY,\n\t\tM_AXI_ARVALID && M_AXI_ARREADY,\n\t\tM_AXI_RVALID || M_AXI_BVALID})\n\t4'b0001: beats_outstanding <= beats_outstanding - 1;\n\t4'b??10: beats_outstanding <= beats_outstanding + 1;\n\t4'b1100: beats_outstanding <= beats_outstanding + 1;\n\t4'b1000: if (!M_AXI_WVALID || (misaligned_aw_request && !misaligned_request))\n\t\t\tbeats_outstanding <= beats_outstanding + 1;\n\t4'b0100: if (!M_AXI_AWVALID || (misaligned_request && !misaligned_aw_request))\n\t\t\tbeats_outstanding <= beats_outstanding + 1;\n\t4'b10?1: if ((M_AXI_WVALID && (OPT_ALIGNMENT_ERR\n\t\t\t\t|| (misaligned_request == misaligned_aw_request)))\n\t\t\t|| (!misaligned_aw_request && misaligned_request))\n\t\t\tbeats_outstanding <= beats_outstanding - 1;\n\t4'b0101: if ((M_AXI_AWVALID && (OPT_ALIGNMENT_ERR\n\t\t\t\t|| (misaligned_request == misaligned_aw_request)))\n\t\t\t|| (!misaligned_request && misaligned_aw_request))\n\t\t\tbeats_outstanding <= beats_outstanding - 1;\n\tdefault: begin end\n\tendcase\n\n\tinitial\tnone_outstanding = 1;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tnone_outstanding <= 1;\n\telse casez({M_AXI_AWVALID && M_AXI_AWREADY,\n\t\tM_AXI_WVALID && M_AXI_WREADY,\n\t\tM_AXI_ARVALID && M_AXI_ARREADY,\n\t\tM_AXI_RVALID || M_AXI_BVALID})\n\t4'b0001: none_outstanding <= (beats_outstanding <= 1);\n\t4'b??10: none_outstanding <= 0;\n\t4'b1100: none_outstanding <= 0;\n\t4'b1000: if (!M_AXI_WVALID || (misaligned_aw_request && !misaligned_request))\n\t\t\tnone_outstanding <= 0;\n\t4'b0100: if (!M_AXI_AWVALID || (misaligned_request && !misaligned_aw_request))\n\t\t\tnone_outstanding <= 0;\n\t4'b10?1: if ((M_AXI_WVALID && (OPT_ALIGNMENT_ERR\n\t\t\t\t|| (misaligned_request == misaligned_aw_request)))\n\t\t\t|| (!misaligned_aw_request && misaligned_request))\n\t\t\tnone_outstanding <= (beats_outstanding <= 1);\n\t4'b0101: if ((M_AXI_AWVALID && (OPT_ALIGNMENT_ERR\n\t\t\t\t|| (misaligned_request == misaligned_aw_request)))\n\t\t\t|| (!misaligned_request && misaligned_aw_request))\n\t\t\tnone_outstanding <= (beats_outstanding <= 1);\n\tdefault: begin end\n\tendcase\n`ifdef\tFORMAL\n\talways @(*)\n\t\tassert(none_outstanding == (beats_outstanding == 0));\n`endif\n\t// }}}\n\n\t// bus_abort\n\t// {{{\n\t// When do we abandon everything and start aborting bus transactions?\n\talways @(*)\n\tbegin\n\t\tbus_abort = 0;\n\t\tif (i_cpu_reset || o_err)\n\t\t\tbus_abort = 1;\n\t\tif (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\tbus_abort = 1;\n\t\tif (M_AXI_RVALID && M_AXI_RRESP[1])\n\t\t\tbus_abort = 1;\n\n\t\twrite_abort = 0;\n\t\tif (i_cpu_reset || o_err)\n\t\t\twrite_abort = 1;\n\t\tif (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\twrite_abort = 1;\n\n\t\tread_abort = 0;\n\t\tif (i_cpu_reset || o_err)\n\t\t\tread_abort = 1;\n\t\tif (M_AXI_RVALID && M_AXI_RRESP[1])\n\t\t\tread_abort = 1;\n\tend\n\t// }}}\n\n\t// Flushing\n\t// {{{\n\n\t// new_flushcount\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tcase({((M_AXI_AWVALID || M_AXI_WVALID) || M_AXI_ARVALID),\n\t\t\t(M_AXI_BVALID || M_AXI_RVALID) })\n\t\t2'b01: new_flushcount = beats_outstanding - 1;\n\t\t2'b10: new_flushcount = beats_outstanding + 1;\n\t\tdefault: new_flushcount = beats_outstanding;\n\t\tendcase\n\n\t\tif (!OPT_ALIGNMENT_ERR && (misaligned_request || misaligned_aw_request))\n\t\t\tnew_flushcount = new_flushcount + 1;\n\tend\n\t// }}}\n\n\tinitial\tr_flushing    = 1'b0;\n\tinitial\tflushcount    = 0;\n\tinitial\tflush_request = 0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN)\n\tbegin\n\t\t// {{{\n\t\tr_flushing <= 1'b0;\n\t\tflush_request <= 0;\n\t\tflushcount    <= 0;\n\t\t// }}}\n\tend else if (i_cpu_reset || bus_abort || (i_stb && w_misalignment_err))\n\tbegin\n\t\t// {{{\n\t\tr_flushing <= (new_flushcount != 0);\n\t\tflushcount <= new_flushcount;\n\t\tflush_request <= (M_AXI_ARVALID && (!M_AXI_ARREADY || misaligned_request))\n\t\t\t|| (M_AXI_AWVALID && (!M_AXI_AWREADY || misaligned_aw_request))\n\t\t\t|| (M_AXI_WVALID && (!M_AXI_WREADY || misaligned_request));\n\t\t// }}}\n\tend else if (r_flushing)\n\tbegin\n\t\t// {{{\n\t\tif (M_AXI_BVALID || M_AXI_RVALID)\n\t\tbegin\n\t\t\tflushcount <= flushcount - 1;\n\t\t\tr_flushing <= (flushcount > 1);\n\t\tend\n\n\t\tcasez({M_AXI_AWVALID && (M_AXI_AWREADY && !misaligned_aw_request),\n\t\t\t\t(M_AXI_WVALID && M_AXI_WREADY && !misaligned_request),\n\t\t\t\t(M_AXI_ARVALID && M_AXI_ARREADY && !misaligned_request) })\n\t\t3'b001: flush_request <= 0;\n\t\t3'b10?: flush_request <= M_AXI_WVALID;\n\t\t3'b01?: flush_request <= M_AXI_AWVALID;\n\t\t3'b11?: flush_request <= 0;\n\t\tdefault: begin end\n\t\tendcase\n\t\t// }}}\n\tend\n`ifdef\tFORMAL\n\talways @(*)\n\tbegin\n\t\tassert(r_flushing == (flushcount > 0));\n\t\tif (!r_flushing)\n\t\tbegin\n\t\t\tassert(!flush_request);\n\t\tend else\n\t\t\tassert(flush_request == (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID));\n\t\tif (r_flushing && !flush_request)\n\t\tbegin\n\t\t\tassert(!misaligned_request);\n\t\t\tassert(!misaligned_aw_request);\n\t\tend\n\n\t\tif (flush_request)\n\t\tbegin\n\t\t\tassert(flushcount == beats_outstanding + 1\n\t\t\t\t+ ((misaligned_request\n\t\t\t\t|| misaligned_aw_request) ? 1:0));\n\t\t// else if (faxil_rd_outstanding > 0 || M_AXI_ARVALID)\n\t\tend else if (r_flushing)\n\t\tbegin\n\t\t\tassert(beats_outstanding == flushcount);\n\t\tend else\n\t\t\tassert(beats_outstanding >= flushcount);\n\tend\n`endif\n\t// }}}\n\n\t// Bus addressing\n\t// {{{\n\tinitial\tM_AXI_AWADDR = 0;\n\talways @(posedge i_clk)\n\tif (i_stb)\n\tbegin\n\t\tM_AXI_AWADDR <= i_addr[AW-1:0];\n\t\tif (SWAP_WSTRB)\n\t\t\tM_AXI_AWADDR[AXILSB-1:0] <= 0;\n\tend else if (!OPT_ALIGNMENT_ERR\n\t\t&& ((M_AXI_AWVALID && M_AXI_AWREADY) // && misaligned_aw_request\n\t\t|| (M_AXI_ARVALID && M_AXI_ARREADY))) // && misaligned_request))\n\tbegin\n\t\tM_AXI_AWADDR[AW-1:AXILSB] <= M_AXI_AWADDR[AW-1:AXILSB] + 1;\n\t\tM_AXI_AWADDR[AXILSB-1:0] <= 0;\n\tend\n\n\talways @(*)\n\t\tM_AXI_ARADDR = M_AXI_AWADDR;\n\t// }}}\n\n\t// Is this request misaligned?\n\t// {{{\n\talways @(*)\n\tcasez(i_op[2:1])\n\t// Full word\n\t2'b0?: w_misaligned = (i_addr[AXILSB-1:0]+3) >= (1<<AXILSB);\n\t// Half word\n\t2'b10: w_misaligned = (i_addr[AXILSB-1:0]+1) >= (1<<AXILSB);\n\t// Bytes are always aligned\n\t2'b11: w_misaligned = 1'b0;\n\tendcase\n\n\tassign\tw_misalignment_err = w_misaligned && OPT_ALIGNMENT_ERR;\n\t// }}}\n\n\t// wide_wdata, wide_wstrb\n\t// {{{\n\talways @(*)\n\tif (SWAP_WSTRB)\n\tbegin : BACKWARDS_ORDER\n\t\t// {{{\n\t\tcasez(i_op[2:1])\n\t\t2'b10: wide_wdata\n\t\t\t= { i_data[15:0], {(2*C_AXI_DATA_WIDTH-16){1'b0}} }\n\t\t\t\t>> (i_addr[AXILSB-1:0] * 8);\n\t\t2'b11: wide_wdata\n\t\t\t= { i_data[7:0], {(2*C_AXI_DATA_WIDTH-8){1'b0}} }\n\t\t\t\t>> (i_addr[AXILSB-1:0] * 8);\n\t\tdefault: wide_wdata\n\t\t\t= ({ i_data, {(2*C_AXI_DATA_WIDTH-32){ 1'b0 }} }\n\t\t\t\t>> (i_addr[AXILSB-1:0] * 8));\n\t\tendcase\n\n\t\tcasez(i_op[2:1])\n\t\t2'b0?: wide_wstrb\n\t\t\t= { 4'b1111, {(2*C_AXI_DATA_WIDTH/8-4){1'b0}} } >> i_addr[AXILSB-1:0];\n\t\t2'b10: wide_wstrb\n\t\t\t= { 2'b11, {(2*C_AXI_DATA_WIDTH/8-2){1'b0}} } >> i_addr[AXILSB-1:0];\n\t\t2'b11: wide_wstrb\n\t\t\t= { 1'b1, {(2*C_AXI_DATA_WIDTH/8-1){1'b0}} } >> i_addr[AXILSB-1:0];\n\t\tendcase\n\t\t// }}}\n\tend else begin : LITTLE_ENDIAN_DATA\n\t\t// {{{\n\t\tcasez(i_op[2:1])\n\t\t2'b10: wide_wdata\n\t\t\t= { {(2*C_AXI_DATA_WIDTH-16){1'b0}}, i_data[15:0] } << (8*i_addr[AXILSB-1:0]);\n\t\t2'b11: wide_wdata\n\t\t\t= { {(2*C_AXI_DATA_WIDTH-8){1'b0}}, i_data[7:0] } << (8*i_addr[AXILSB-1:0]);\n\t\tdefault: wide_wdata\n\t\t\t= { {(2*C_AXI_DATA_WIDTH-32){1'b0}}, i_data }\n\t\t\t\t\t<< (8*i_addr[AXILSB-1:0]);\n\t\tendcase\n\n\t\tcasez(i_op[2:1])\n\t\t2'b0?: wide_wstrb\n\t\t\t= { {(2*C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b1111} << i_addr[AXILSB-1:0];\n\t\t2'b10: wide_wstrb\n\t\t\t= { {(2*C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b0011} << i_addr[AXILSB-1:0];\n\t\t2'b11: wide_wstrb\n\t\t\t= { {(2*C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b0001} << i_addr[AXILSB-1:0];\n\t\tendcase\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// WDATA and WSTRB\n\t// {{{\n\tinitial\tM_AXI_WDATA = 0;\n\tinitial\tM_AXI_WSTRB = 0;\n\tinitial\tnext_wdata  = 0;\n\tinitial\tnext_wstrb  = 0;\n\talways @(posedge i_clk)\n\tif (i_stb)\n\tbegin\n\t\tif (SWAP_WSTRB)\n\t\tbegin : BACKWARDS_ORDER_REG\n\t\t\t// {{{\n\t\t\t{ M_AXI_WDATA, next_wdata } <= wide_wdata;\n\t\t\t{ M_AXI_WSTRB, next_wstrb } <= wide_wstrb;\n\t\t\t// }}}\n\t\tend else begin\n\t\t\t// {{{\n\t\t\t{ next_wdata, M_AXI_WDATA } <= wide_wdata;\n\t\t\t{ next_wstrb, M_AXI_WSTRB } <= wide_wstrb;\n\t\t\t// }}}\n\t\tend\n\n\t\tif (OPT_ALIGNMENT_ERR)\n\t\t\t{ next_wstrb, next_wdata } <= 0;\n\n\tend else if ((OPT_LOWPOWER || !OPT_ALIGNMENT_ERR) && M_AXI_WREADY)\n\tbegin\n\t\tM_AXI_WDATA <= next_wdata;\n\t\tM_AXI_WSTRB <= next_wstrb;\n\t\tif (OPT_LOWPOWER)\n\t\t\t{ next_wdata, next_wstrb } <= 0;\n\tend\n\t// }}}\n\n\tgenerate if (OPT_ALIGNMENT_ERR)\n\tbegin : GEN_ALIGNMENT_ERR\n\t\t// {{{\n\t\t// Generate an error on any misaligned request\n\t\tassign\tmisaligned_request = 1'b0;\n\n\t\tassign\tmisaligned_aw_request = 1'b0;\n\t\tassign\tpending_err = 1'b0;\n\t\t// }}}\n\tend else begin : GEN_REALIGNMENT\n\t\t// {{{",
            "reg r_misaligned_request, r_misaligned_aw_request,\n\t\t\tr_pending_err;\n\n\t\t// misaligned_request\n\t\t// {{{\n\t\tinitial\tr_misaligned_request = 0;\n\t\talways @(posedge i_clk)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_misaligned_request <= 0;\n\t\telse if (i_stb && !o_err && !i_cpu_reset && !bus_abort)\n\t\t\tr_misaligned_request <= w_misaligned;\n\t\telse if ((M_AXI_WVALID && M_AXI_WREADY)\n\t\t\t\t\t|| (M_AXI_ARVALID && M_AXI_ARREADY))\n\t\t\tr_misaligned_request <= 1'b0;\n\n\t\tassign\tmisaligned_request = r_misaligned_request;\n\t\t// }}}\n\n\t\t// misaligned_aw_request\n\t\t// {{{\n\t\tinitial\tr_misaligned_aw_request = 0;\n\t\talways @(posedge i_clk)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_misaligned_aw_request <= 0;\n\t\telse if (i_stb && !o_err && !i_cpu_reset && !write_abort)\n\t\t\tr_misaligned_aw_request <= w_misaligned && i_op[0];\n\t\telse if (M_AXI_AWREADY)\n\t\t\tr_misaligned_aw_request <= 1'b0;\n\n\t\tassign\tmisaligned_aw_request = r_misaligned_aw_request;\n\t\t// }}}\n\n\t\t// pending_err\n\t\t// {{{\n\t\tinitial\tr_pending_err = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_cpu_reset || i_stb || o_err || r_flushing)\n\t\t\tr_pending_err <= 1'b0;\n\t\telse if ((M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t\t|| (M_AXI_RVALID && M_AXI_RRESP[1]))\n\t\t\tr_pending_err <= 1'b1;\n\n\t\tassign\tpending_err = r_pending_err;\n\t\t// }}}\n\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (pending_err)\n\t\t\tassert(r_flushing || o_err);\n`endif\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read transaction FIFO\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// wraddr\n\t// {{{\n\tinitial\twraddr = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (bus_abort || flush_request)\t// bus_abort includes i_cpu_reset\n\t\twraddr <= 0;\n\telse if ((M_AXI_ARVALID && M_AXI_ARREADY) || (M_AXI_WVALID && M_AXI_WREADY))\n\t\twraddr <= wraddr + 1;\n\t// }}}\n\n\t// rdaddr\n\t// {{{\n\tinitial\trdaddr = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (bus_abort || r_flushing)\n\t\trdaddr <= 0;\n\telse if (M_AXI_RVALID||M_AXI_BVALID)\n\t\trdaddr <= rdaddr + 1;\n\t// }}}\n\n\t// ar_o",
            "reg , ar_op, adr_lsb\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (i_stb)\n\t\t{ ar_o",
            "reg , ar_op, adr_lsb } <= { i_o",
            "reg , i_op[2:1], i_addr[AXILSB-1:0] };\n\telse if ((M_AXI_ARVALID && M_AXI_ARREADY)||(M_AXI_WVALID && M_AXI_WREADY))\n\t\tadr_lsb <= 0;\n\t// }}}\n\n\t// fifo_data\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif ((M_AXI_ARVALID && M_AXI_ARREADY) || (M_AXI_WVALID && M_AXI_WREADY))\n\t\tfifo_data[wraddr[LGPIPE-1:0]] <= { M_AXI_ARVALID, ar_o",
            "reg ,ar_op,\n\t\t\t\tmisaligned_request, adr_lsb };\n\n\talways @(*)\n\t\tfifo_read_data = fifo_data[rdaddr[LGPIPE-1:0]];\n\n\tassign\t{ fifo_read_op, fifo_return_",
            "reg , fifo_op,\n\t\t\tfifo_misaligned, fifo_lsb } = fifo_read_data;\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read return generation\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// o_valid\n\t// {{{\n\tinitial\to_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || r_flushing)\n\t\to_valid <= 1'b0;\n\telse if (OPT_ALIGNMENT_ERR && i_stb && w_misaligned)\n\t\to_valid <= 1'b0;\n\telse\n\t\to_valid <= M_AXI_RVALID && !M_AXI_RRESP[1] // && !pending_err\n\t\t\t\t&& !fifo_misaligned;\n\t// }}}\n\n\t// o_w",
            "reg // {{{\n\talways @(posedge i_clk)\n\t\to_w",
            "reg <= fifo_return_",
            "reg ;\n\t// }}}\n\n\t// o_result, misdata\n\t// {{{\n\t// Need to realign any returning data\n\t// wide_return\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tif (fifo_misaligned && !OPT_ALIGNMENT_ERR)\n\t\t\t\twide_return = { misdata, M_AXI_RDATA }\n\t\t\t\t\t\t\t<< (8*fifo_lsb);\n\t\t\telse\n\t\t\t\twide_return = { M_AXI_RDATA, {(DW){1'b0}} }\n\t\t\t\t\t\t\t<< (8*fifo_lsb);\n\n\t\tend else begin\n\t\t\tif (fifo_misaligned && !OPT_ALIGNMENT_ERR)\n\t\t\t\twide_return = { M_AXI_RDATA, misdata } >> (8*fifo_lsb);\n\t\t\telse\n\t\t\t\twide_return = { {(C_AXI_DATA_WIDTH){1'b0}}, M_AXI_RDATA }\n\t\t\t\t\t>> (8*fifo_lsb);\n\t\tend\n\n\t\tif (OPT_LOWPOWER && (!M_AXI_RVALID || M_AXI_RRESP[1]))\n\t\t\twide_return = 0;\n\tend\n\n\talways @(*)\n\tbegin\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tpre_result = 0;\n\n\t\t\tcasez(fifo_op)\n\t\t\t2'b10: pre_result[15:0] = {\n\t\t\t\t\twide_return[(2*DW)-1:(2*DW)-16] };\n\t\t\t2'b11: pre_result[7:0] = {\n\t\t\t\t\twide_return[(2*DW)-1:(2*DW)-8] };\n\t\t\tdefault: pre_result[31:0] = wide_return[(2*DW-1):(2*DW-32)];\n\t\t\tendcase\n\n\t\tend else\n\t\t\tpre_result = wide_return[31:0];\n\tend\n\t// }}}\n\n\t// misdata\n\t// {{{\n\talways @(posedge i_clk)\n\tif (OPT_ALIGNMENT_ERR)\n\t\tmisdata <= 0;\n\telse if (M_AXI_RVALID)\n\tbegin\n\t\tif (fifo_misaligned)\n\t\t\tmisdata <= M_AXI_RDATA;\n\t\telse\n\t\t\tmisdata <= 0;\n\tend\n\t// }}}\n\n\t// o_result\n\t// {{{\n\talways @(posedge i_clk)\n\tif (OPT_LOWPOWER && (!S_AXI_ARESETN || r_flushing || i_cpu_reset))\n\tbegin\n\t\to_result <= 0;\n\tend else if (!OPT_LOWPOWER || M_AXI_RVALID)\n\tbegin\n\n\t\to_result <= pre_result[31:0];\n\n\t\tif (OPT_SIGN_EXTEND)\n\t\tbegin\n\t\t\t// {{{\n\t\t\t// Optionally sign extend the return result.\n\t\t\tcase(fifo_op)\n\t\t\t2'b10: o_result[31:16] <= {(16){pre_result[15]}};\n\t\t\t2'b11: o_result[31: 8] <= {(24){pre_result[7]}};\n\t\t\tdefault: begin end\n\t\t\tendcase\n\t\t\t// }}}\n\t\tend else if (fifo_op[1])\n\t\tbegin\n\t\t\t// {{{\n\t\t\tif (fifo_op[0])\n\t\t\t\to_result[31: 8] <= 0;\n\t\t\telse\n\t\t\t\to_result[31:16] <= 0;\n\t\t\t// }}}\n\t\tend\n\n\tend\n\t// }}}\n\t// }}}\n\n\t// o_err - report bus errors back to the CPU\n\t// {{{\n\tinitial\to_err = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || r_flushing || o_err)\n\t\to_err <= 1'b0;\n\telse if (OPT_ALIGNMENT_ERR && i_stb && w_misaligned)\n\t\to_err <= 1'b1;\n\telse if (M_AXI_BVALID || M_AXI_RVALID)\n\t\to_err <= (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t|| (M_AXI_RVALID && M_AXI_RRESP[1]);\n\telse\n\t\to_err <= 1'b0;\n\t// }}}\n\n\t// Return xREADY -- always ready\n\t// {{{\n\tassign\tM_AXI_RREADY = 1;\n\tassign\tM_AXI_BREADY = 1;\n\t// }}}\n\n\t// AxPROT -- CPU data\n\t// {{{\n\tassign\tM_AXI_AWPROT = 3'b000;\n\tassign\tM_AXI_ARPROT = 3'b000;\n\n\t// }}}\n\t// }}}\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, M_AXI_RRESP[0], M_AXI_BRESP[0], i_lock,\n\t\t\t// i_addr[31:C_AXI_ADDR_WIDTH],\n\t\t\t(&i_addr),\n\t\t\tpending_err, adr_lsb, fifo_read_op,\n\t\t\tnone_outstanding };\n\n\tgenerate if (SWAP_WSTRB)\n\tbegin : GEN_UNUSED",
            "wire wide_unused;\n\n\t\tif (SWAP_WSTRB)\n\t\tbegin : UNUSED_SWAP\n\t\t\tassign\twide_unused = &{ 1'b0,\n\t\t\t\t\twide_return[2*DW-32-1:0] };\n\t\tend else begin : UNUSED\n\t\t\tassign\twide_unused = &{ 1'b0, wide_return[2*DW-1:32] };\n\t\tend\n\tend endgenerate\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal property section\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Declarations\n\t// {{{\n`define\tASSERT\t\tassert\n`ifndef\tBMC_ASSERT\n`define\tBMC_ASSERT\tassume\n`endif\n`ifdef\tAXILPIPE\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "localparam F_LGDEPTH = LGPIPE+1;",
            "wire [F_LGDEPTH-1:0]\tfaxil_rd_outstanding, faxil_wr_outstanding,\n\t\t\t\tfaxil_awr_outstanding;",
            "reg [LGPIPE:0]\tf_fifo_fill;",
            "reg f_clrfifo, f_wrfifo, f_rdfifo;",
            "wire misaligned_response_pending;",
            "reg [1:0]\tf_fsmfifo;\n\t(* anyconst *)",
            "reg [LGPIPE:0]\t\tf_first_addr;",
            "reg [LGPIPE:0]\t\tf_next_addr,\n\t\t\t\tf_penu_addr, f_last_written,\n\t\t\t\tf_distance_to_first, f_distance_to_next;",
            "reg [FIFO_WIDTH-1:0]\tf_first_data, f_next_data, f_penu_data;",
            "reg [4:0]\tf_first_return_",
            "reg , f_next_return_",
            "reg , f_return_",
            "reg ,\n\t\t\tf_penu_return_",
            "reg ;",
            "reg f_first_in_fifo,\tf_next_in_fifo,\n\t\t\tf_first_misaligned,\tf_next_misaligned,\n\t\t\tf_this_misaligned,\tf_penu_misaligned,\n\t\t\tf_first_read_cycle,\tf_next_read_cycle,\n\t\t\tf_this_read_cycle,\tf_penu_read_cycle;",
            "wire [LGPIPE:0]\tcpu_outstanding;",
            "wire cpu_gie, cpu_pc, cpu_read_cycle;",
            "wire [4:0]\t\tcpu_last_",
            "reg , cpu_addr_",
            "reg ;",
            "reg [4:0]\t\tf_ar_a",
            "reg ;\n\n\t(* anyseq *)",
            "reg [4:0]\tf_a",
            "reg ;",
            "reg f_done;",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid = 1'b1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(!S_AXI_ARESETN);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus property checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tfaxil_master #(\n\t\t// {{{\n\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),\n\t\t.F_OPT_ASSUME_RESET(1'b1),\n\t\t.F_LGDEPTH(F_LGDEPTH)\n\t\t// }}}\n\t) faxil(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN),\n\t\t//\n\t\t.i_axi_awvalid(M_AXI_AWVALID),\n\t\t.i_axi_awready(M_AXI_AWREADY),\n\t\t.i_axi_awaddr( M_AXI_AWADDR),\n\t\t.i_axi_awprot( M_AXI_AWPROT),\n\t\t//\n\t\t.i_axi_wvalid(M_AXI_WVALID),\n\t\t.i_axi_wready(M_AXI_WREADY),\n\t\t.i_axi_wdata( M_AXI_WDATA),\n\t\t.i_axi_wstrb( M_AXI_WSTRB),\n\t\t//\n\t\t.i_axi_bvalid(M_AXI_BVALID),\n\t\t.i_axi_bready(M_AXI_BREADY),\n\t\t.i_axi_bresp( M_AXI_BRESP),\n\t\t//\n\t\t.i_axi_arvalid(M_AXI_ARVALID),\n\t\t.i_axi_arready(M_AXI_ARREADY),\n\t\t.i_axi_araddr( M_AXI_ARADDR),\n\t\t.i_axi_arprot( M_AXI_ARPROT),\n\t\t//\n\t\t.i_axi_rvalid(M_AXI_RVALID),\n\t\t.i_axi_rready(M_AXI_RREADY),\n\t\t.i_axi_rdata( M_AXI_RDATA),\n\t\t.i_axi_rresp( M_AXI_RRESP),\n\t\t//\n\t\t.f_axi_rd_outstanding(faxil_rd_outstanding),\n\t\t.f_axi_wr_outstanding(faxil_wr_outstanding),\n\t\t.f_axi_awr_outstanding(faxil_awr_outstanding)\n\t\t// }}}\n\t);\n\n\n\talways @(*)\n\t\tf_fifo_fill = wraddr - rdaddr;\n\n\talways @(*)\n\tbegin\n\t\tif (misaligned_request)\n\t\t\t`ASSERT(M_AXI_WVALID || M_AXI_ARVALID);\n\t\tif (misaligned_aw_request)\n\t\t\t`ASSERT(M_AXI_AWVALID);\n\n\t\tif (M_AXI_ARVALID || faxil_rd_outstanding > 0)\n\t\tbegin\n\t\t\tassert(faxil_wr_outstanding == 0\n\t\t\t\t&& faxil_awr_outstanding == 0);\n\t\t\tassert(!M_AXI_AWVALID);\n\t\t\tassert(!M_AXI_WVALID);\n\t\tend\n\n\t\tif (faxil_wr_outstanding > 0 || faxil_awr_outstanding > 0\n\t\t\t|| M_AXI_AWVALID || M_AXI_WVALID)\n\t\tbegin\n\t\t\tassert(faxil_rd_outstanding == 0);\n\t\t\tassert(!M_AXI_ARVALID);\n\t\tend\n\n\t\t// Rule: Only one of the two VALID's may be valid, never both\n\t\t`ASSERT(!M_AXI_RVALID || (!M_AXI_AWVALID && !M_AXI_WVALID));\n\n\t\tassert(beats_outstanding\n\t\t\t+ ((misaligned_request && !misaligned_aw_request && M_AXI_WVALID) ? 1:0)\n\t\t\t+ ((M_AXI_WVALID && !M_AXI_AWVALID) ? 1:0)\n\t\t\t== faxil_rd_outstanding + faxil_awr_outstanding);\n\n\t\tassert(beats_outstanding\n\t\t\t+ ((misaligned_aw_request && !misaligned_request) ? 1:0)\n\t\t\t+ ((M_AXI_AWVALID && !M_AXI_WVALID) ? 1:0)\n\t\t\t== faxil_rd_outstanding + faxil_wr_outstanding);\n\n\t\tif (OPT_ALIGNMENT_ERR && !r_flushing\n\t\t\t\t&& (faxil_rd_outstanding > 0 || M_AXI_ARVALID))\n\t\tbegin\n\t\t\tassert(f_fifo_fill == faxil_rd_outstanding);\n\t\tend else if (OPT_ALIGNMENT_ERR && !r_flushing\n\t\t\t\t&& (faxil_wr_outstanding > 0 || M_AXI_WVALID))\n\t\t\tassert(f_fifo_fill == faxil_wr_outstanding);\n\n\t\tif (faxil_rd_outstanding == 0 && faxil_wr_outstanding == 0)\n\t\t\tassert(f_fifo_fill == 0);\n\tend\n\n\talways @(*)\n\tif (!o_busy)\n\t\t`ASSERT(!r_flushing);\n\n\t// Following any i_stb request, assuming we are idle, immediately\n\t// begin a bus transaction\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_stb && !o_err))\n\t\t&&(!$past(o_busy))&&($past(!i_cpu_reset)))\n\tbegin\n\t\t`ASSERT(o_busy || (OPT_ALIGNMENT_ERR && o_err));\n\tend\n\n\talways @(*)\n\tif (o_busy && !misaligned_request && OPT_LOWPOWER)\n\tbegin\n\t\tassert(next_wdata == 0);\n\t\tassert(next_wstrb == 0);\n\tend\n\n\t// o_err checking\n\t// {{{\n\t// If a transaction ends in an error, send o_err on the",
            "output port.\n\talways @(posedge i_clk)\n\tif (f_past_valid)\n\tbegin\n\t\tif ($past(i_cpu_reset || r_flushing || o_err))\n\t\tbegin\n\t\t\t`ASSERT(!o_err);\n\t\tend else if ($past(M_AXI_BVALID && M_AXI_BRESP[1]))\n\t\tbegin\n\t\t\t`ASSERT(o_err);\n\t\tend else if ($past(M_AXI_RVALID && M_AXI_RRESP[1]))\n\t\tbegin\n\t\t\t`ASSERT(o_err);\n\t\tend else if (OPT_ALIGNMENT_ERR && $past(i_stb && w_misaligned))\n\t\tbegin\n\t\t\t`ASSERT(o_err);\n\t\tend else if (!$past(pending_err))\n\t\t\t`ASSERT(!o_err);\n\tend\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(!i_cpu_reset))&&($past(i_stb)))\n\tbegin\n\t\t// On a write, assert o_wb_we should be true\n\t\tassert($past(i_op[0] && !o_err\n\t\t\t&& (!M_AXI_BVALID || !M_AXI_BRESP[1])\n\t\t\t&& (!OPT_ALIGNMENT_ERR || !w_misaligned))\n\t\t\t\t== (M_AXI_AWVALID && M_AXI_WVALID));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_cpu_reset)))\n\t\t`ASSUME(!i_stb);\n\n\talways @(*)\n\tif (!S_AXI_ARESETN)\n\t\t`ASSUME(i_cpu_reset);\n\n\t// misaligned_response_pending\n\t// {{{\n\tgenerate if (OPT_ALIGNMENT_ERR)\n\tbegin : NO_MISALIGNED_RESPONSES\n\n\t\tassign\tmisaligned_response_pending = 0;\n\n\tend else begin : MISALIGNED_RESPONSE_PENDING",
            "reg r_misaligned_response_pending;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tr_misaligned_response_pending = fifo_misaligned;\n\t\t\tif (wraddr == rdaddr)\n\t\t\t\tr_misaligned_response_pending = 0;\n\t\tend\n\n\t\tassign\tmisaligned_response_pending\n\t\t\t\t= r_misaligned_response_pending;\n\tend endgenerate\n\t// }}}\n\n\n\talways @(*)\n\tif (o_busy)\n\tbegin\n\t\tcover(i_stb);\n\t\tcover(o_valid);\n\t\tcover(o_err);\n\tend else begin\n\t\tcover(o_valid);\n\t\tcover(o_err);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Zero on idle checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (OPT_LOWPOWER)\n\tbegin\n\t\talways @(*)\n\t\tif (!M_AXI_AWVALID && !M_AXI_ARVALID)\n\t\t\t`ASSERT(M_AXI_AWADDR == 0);\n\n\t\talways @(*)\n\t\tif (!M_AXI_WVALID)\n\t\tbegin\n\t\t\t`ASSERT(M_AXI_WDATA == 0);\n\t\t\t`ASSERT(M_AXI_WSTRB == 0);\n\n\t\t\t`ASSERT(next_wdata == 0);\n\t\t\t`ASSERT(next_wstrb == 0);\n\t\tend\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// FIFO property checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tbegin\n\t\t// {{{\n\t\tf_next_addr = f_first_addr + 1;\n\t\tf_last_written = wraddr - 1;\n\n\t\tf_penu_addr = rdaddr + 1;\n\t\tf_penu_data = fifo_data[f_penu_addr[LGPIPE-1:0]];\n\n\t\tf_clrfifo = (!S_AXI_ARESETN || bus_abort || flush_request);\n\t\tf_wrfifo = (!f_clrfifo) && ((M_AXI_ARVALID && M_AXI_ARREADY)\n\t\t\t\t|| (M_AXI_WVALID && M_AXI_WREADY));\n\t\tf_rdfifo = (!f_clrfifo) && ((M_AXI_RVALID && M_AXI_RREADY)\n\t\t\t\t|| (M_AXI_BVALID && M_AXI_BREADY));\n\n\t\tf_distance_to_first = f_first_addr - rdaddr;\n\t\tf_distance_to_next  = f_next_addr  - rdaddr;\n\n\t\tf_first_in_fifo = (f_distance_to_first < f_fifo_fill) && (f_fifo_fill > 0);\n\t\tf_next_in_fifo  = (f_distance_to_next < f_fifo_fill) && (f_fifo_fill > 0);\n\n\t\tf_return_",
            "reg = fifo_return_",
            "reg ;\n\n\t\tf_first_return_",
            "reg = f_first_data[AXILLSB+3 +: 5];\n\t\tf_next_return_",
            "reg = f_next_data[AXILLSB+3 +: 5];\n\t\tf_penu_return_",
            "reg = f_penu_data[AXILLSB+3 +: 5];\n\n\t\tf_first_misaligned = f_first_data[AXILLSB];\n\t\tf_next_misaligned = f_next_data[AXILLSB];\n\t\tf_this_misaligned = fifo_read_data[AXILLSB];\n\t\tf_penu_misaligned = f_penu_data[AXILLSB];\n\n\t\tf_first_read_cycle = f_first_data[FIFO_WIDTH-1];\n\t\tf_next_read_cycle = f_next_data[FIFO_WIDTH-1];\n\t\tf_this_read_cycle = fifo_read_data[FIFO_WIDTH-1];\n\t\tf_penu_read_cycle = f_penu_data[FIFO_WIDTH-1];\n\t\t// }}}\n\tend\n\n\talways @(*)\n\tif (r_flushing && !f_clrfifo)\n\t\tassert(rdaddr == wraddr);\n\n\talways @(*)\n\tif (!f_clrfifo)\n\tbegin\n\t\tif (f_first_in_fifo)\n\t\t\t`ASSERT(f_first_data == fifo_data[f_first_addr]);\n\t\tif (f_next_in_fifo)\n\t\t\t`ASSERT(f_next_data == fifo_data[f_next_addr]);\n\tend\n\n\talways @(posedge S_AXI_ACLK)\n\tif (f_wrfifo && wraddr == f_first_addr)\n\t\tf_first_data <= { M_AXI_ARVALID, ar_o",
            "reg , ar_op, misaligned_request, adr_lsb };\n\n\talways @(posedge S_AXI_ACLK)\n\tif (f_wrfifo && wraddr == f_next_addr)\n\t\tf_next_data <= { M_AXI_ARVALID, ar_o",
            "reg , ar_op, misaligned_request, adr_lsb };\n\n\t// f_fsmfifo\n\t// {{{\n\tinitial\tf_fsmfifo = 2'b00;\n\talways @(posedge S_AXI_ACLK)\n\tif (f_clrfifo)\n\t\tf_fsmfifo <= 2'b00;\n\telse case(f_fsmfifo)\n\t2'b00: if (f_wrfifo && wraddr == f_first_addr)\n\t\tf_fsmfifo <= 2'b01;\n\t2'b01: if (f_rdfifo && rdaddr == f_first_addr)\n\t\tf_fsmfifo <= 2'b00;\n\t\telse if (f_wrfifo && wraddr == f_next_addr)\n\t\tf_fsmfifo <= 2'b10;\n\t2'b10: if (f_rdfifo && rdaddr == f_first_addr)\n\t\tf_fsmfifo <= 2'b11;\n\t2'b11: if (f_rdfifo)\n\t\tf_fsmfifo <= 2'b00;\n\tendcase\n\n\talways @(*)\n\tif (!f_clrfifo)\n\tcase(f_fsmfifo)\n\t2'b00: begin\n\t\t// {{{\n\t\t`ASSERT(!f_first_in_fifo);\n\t\tend\n\t\t// }}}\n\t2'b01: begin\n\t\t// {{{\n\t\t`ASSERT(f_fifo_fill >= 1);\n\t\t`ASSERT(f_first_in_fifo);\n\t\tend\n\t\t// }}}\n\t2'b10: begin\n\t\t// {{{\n\t\t`ASSERT(f_fifo_fill >= 2);\n\t\t`ASSERT(f_first_in_fifo);\n\t\t`ASSERT(f_next_in_fifo);\n\t\tend\n\t\t// }}}\n\t2'b11: begin\n\t\t// {{{\n\t\t`ASSERT(f_fifo_fill >= 1);\n\t\t`ASSERT(f_next_in_fifo);\n\t\tend\n\t\t// }}}\n\tendcase\n\t// }}}\n\n\t// { ar_o",
            "reg , ar_op, misaligned_request, M_AXI_ARADDR[AXILLSB-1:0] };\n\n\t// cpu_gie checks\n\t// {{{\n\talways @(*)\n\tif (M_AXI_ARVALID)\n\t\t`ASSERT(cpu_gie == ar_o",
            "reg [4]);\n\n\talways @(*)\n\tif (!f_clrfifo && f_fifo_fill != 0)\n\tbegin\n\t\tif (M_AXI_ARVALID || M_AXI_WVALID || M_AXI_AWVALID)\n\t\t\t`ASSERT(cpu_gie == ar_o",
            "reg [4]);\n\n\t\tif ((!f_first_in_fifo || rdaddr != f_first_addr)\n\t\t\t\t&& (!f_next_in_fifo || rdaddr != f_next_addr)\n\t\t\t\t&& (f_fifo_fill > 0))\n\t\t\t`ASSUME(cpu_gie == f_return_",
            "reg [4]);\n\n\t\tif (f_first_in_fifo)\n\t\t\t`ASSERT(cpu_gie == f_first_return_",
            "reg [4]);\n\t\tif (f_next_in_fifo)\n\t\t\t`ASSERT(cpu_gie == f_next_return_",
            "reg [4]);\n\tend\n\t// }}}\n\n\t// cpu_pc checks\n\t// {{{\n\talways @(*)\n\tif (M_AXI_ARVALID)\n\t\t`ASSERT(cpu_pc == ((&ar_o",
            "reg [3:1]) && (o_err || !flush_request)));\n\n\talways @(*)\n\tif (!f_clrfifo && f_fifo_fill != 0)\n\tbegin\n\t\tif ((M_AXI_ARVALID || (rdaddr != f_last_written)))\n\t\tbegin\n\t\t\t`ASSERT(f_this_misaligned || !cpu_read_cycle || !(&f_return_",
            "reg [3:1]));\n\t\tend else if (f_fifo_fill > 0 && !M_AXI_ARVALID)\n\t\t\t`ASSERT(f_this_misaligned || !cpu_read_cycle || cpu_pc == (&f_return_",
            "reg [3:1]));\n\n\t\tif ((!f_first_in_fifo || rdaddr != f_first_addr)\n\t\t\t&& (!f_next_in_fifo || rdaddr != f_next_addr)\n\t\t\t&& cpu_read_cycle)\n\t\tbegin\n\t\t\tif (M_AXI_ARVALID) // && (&ar_o",
            "reg [3:1]))\n\t\t\tbegin\n\t\t\t\t`ASSUME(!(&f_return_",
            "reg [3:1]));\n\t\t\tend else if (rdaddr != f_last_written)\n\t\t\tbegin\n\t\t\t\t`ASSUME(!(&f_return_",
            "reg [3:1]));\n\t\t\tend else if (!M_AXI_ARVALID && !o_err)\n\t\t\t\t`ASSUME(cpu_pc == (&f_return_",
            "reg [3:1])); // Not last written\n\t\tend\n\n\t\tif (f_first_in_fifo && cpu_read_cycle)\n\t\tbegin\n\t\t\tif (!cpu_pc || M_AXI_ARVALID\n\t\t\t\t\t|| (f_last_written != f_first_addr))\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_first_misaligned || !cpu_read_cycle || !(&f_first_return_",
            "reg [3:1]));\n\t\t\tend else if (!M_AXI_ARVALID && !o_err)\n\t\t\t\t`ASSERT(&f_first_return_",
            "reg [3:1]);\n\t\tend\n\n\t\tif (f_next_in_fifo && cpu_read_cycle)\n\t\tbegin\n\t\t\tif (!cpu_pc || M_AXI_ARVALID\n\t\t\t\t\t|| (f_last_written != f_next_addr))\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_next_misaligned || !(&f_next_return_",
            "reg [3:1]));\n\t\t\tend else if (!M_AXI_ARVALID && !o_err)\n\t\t\t\t`ASSERT(&f_next_return_",
            "reg [3:1]);\n\t\tend\n\n\t\tif (M_AXI_ARVALID)\n\t\t\t`ASSERT(cpu_pc == (&ar_o",
            "reg [3:1]));\n\tend\n\t// }}}\n\n\talways @(*)\n\tif (cpu_read_cycle && !r_flushing)\n\t\tassert(o_rdbusy==((rdaddr != wraddr)||(M_AXI_ARVALID)));\n\n\talways @(*)\n\tif (cpu_read_cycle)\n\t\tassert(!M_AXI_AWVALID && !M_AXI_WVALID && faxil_awr_outstanding == 0);\n\n\t// Verifying the alignment flags\n\t// {{{\n\talways @(*)\n\tif (M_AXI_ARVALID && OPT_ALIGNMENT_ERR)\n\t\tassert(!misaligned_request);\n\n\talways @(*)\n\tif (!f_clrfifo && f_fifo_fill != 0)\n\tbegin\n\t\tif (OPT_ALIGNMENT_ERR)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tif (f_first_in_fifo)\n\t\t\t\t`ASSERT(!f_first_misaligned);\n\t\t\tif (f_next_in_fifo)\n\t\t\t\t`ASSERT(!f_next_misaligned);\n\t\t\tif ((!f_first_in_fifo || rdaddr != f_first_addr)\n\t\t\t\t&& (!f_next_in_fifo || rdaddr != f_next_addr))\n\t\t\t\t`ASSUME(!f_this_misaligned);\n\t\t\t// }}}\n\t\tend else begin\n\t\t\t// {{{\n\t\t\tif (f_first_in_fifo && f_first_misaligned)\n\t\t\tbegin\n\t\t\t\tif (f_next_in_fifo)\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!f_next_misaligned);\n\t\t\t\tend else begin\n\t\t\t\t\t`ASSERT(!misaligned_request);\n\t\t\t\t\t`ASSERT(M_AXI_ARVALID || M_AXI_WVALID);\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif (misaligned_response_pending\n\t\t\t\t&& (!f_first_in_fifo || rdaddr != f_first_addr))\n\t\t\tbegin\n\t\t\t\tif (f_fifo_fill > 1)\n\t\t\t\tbegin\n\t\t\t\t\t`BMC_ASSERT(!f_penu_misaligned);\n\t\t\t\tend else if (f_fifo_fill == 1)\n\t\t\t\t\t`BMC_ASSERT(!misaligned_request);\n\t\t\tend\n\t\t\t// }}}\n\t\tend\n\tend\n\t// }}}\n\n\t// Verifying unaligned",
            "reg isters remain the same\n\t// {{{\n\talways @(*)\n\tif (!f_clrfifo && f_fifo_fill != 0 && !OPT_ALIGNMENT_ERR)\n\tbegin\n\t\tif (f_first_in_fifo && f_first_misaligned)\n\t\tbegin\n\t\t\tif (f_next_in_fifo)\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_first_return_",
            "reg == f_next_return_",
            "reg );\n\t\t\tend else begin\n\t\t\t\t`ASSERT(M_AXI_ARVALID || M_AXI_WVALID);\n\t\t\t\t`ASSERT(!misaligned_request);\n\t\t\t\t`ASSERT(f_first_return_",
            "reg == ar_o",
            "reg );\n\t\t\tend\n\t\tend\n\n\t\tif (misaligned_response_pending\n\t\t\t&& (!f_first_in_fifo || rdaddr != f_first_addr))\n\t\tbegin\n\t\t\tif (f_fifo_fill == 1)\n\t\t\tbegin\n\t\t\t\t`BMC_ASSERT(M_AXI_ARVALID || M_AXI_WVALID);\n\t\t\t\t`BMC_ASSERT(!misaligned_request);\n\t\t\t\t`BMC_ASSERT(f_first_return_",
            "reg == ar_o",
            "reg );\n\t\t\tend else\n\t\t\t\t`BMC_ASSERT(fifo_return_",
            "reg == f_penu_return_",
            "reg );\n\t\tend\n\tend\n\t// }}}\n\n\talways @(*)\n\t\tassert(f_fifo_fill <= (1<<LGPIPE));\n\n\talways @(*)\n\t\tassert(beats_outstanding <= (1<<LGPIPE));\n\n\t// Verifying the cpu_read_cycle flags\n\t// {{{\n\talways @(*)\n\tif (!r_flushing && f_fifo_fill > 0)\n\tbegin\n\t\tif (f_first_in_fifo)\n\t\t\t`ASSERT(cpu_read_cycle == f_first_read_cycle);\n\t\tif (f_next_in_fifo)\n\t\t\t`ASSERT(cpu_read_cycle == f_next_read_cycle);\n\n\t\tif (// f_fifo_fill > 0 && // Redundant\n\t\t\t   (!f_first_in_fifo || rdaddr != f_first_addr)\n\t\t\t&& (!f_next_in_fifo  || rdaddr != f_next_addr))\n\t\tbegin\n\t\t\t`BMC_ASSERT(cpu_read_cycle == f_this_read_cycle);\n\t\tend\n\n\t\tif (f_fifo_fill > 1\n\t\t\t&& (!f_first_in_fifo || f_penu_addr != f_first_addr)\n\t\t\t&& (!f_next_in_fifo  || f_penu_addr != f_next_addr))\n\t\tbegin\n\t\t\t`BMC_ASSERT(cpu_read_cycle == f_penu_read_cycle);\n\t\tend\n\n\t\tif (cpu_read_cycle)\n\t\tbegin\n\t\t\t`ASSERT(!M_AXI_AWVALID && !M_AXI_WVALID);\n\t\t\t`ASSERT(faxil_awr_outstanding == 0);\n\t\t\t`ASSERT(faxil_wr_outstanding == 0);\n\t\tend\n\tend\n\t// }}}\n\n\t// Verifying the cpu_last_",
            "reg // {{{\n\talways @(*)\n\tif (M_AXI_WVALID || M_AXI_ARVALID)\n\tbegin\n\t\tassert(cpu_last_",
            "reg == ar_o",
            "reg );\n\tend else if (!f_clrfifo && f_fifo_fill > 0)\n\tbegin\n\t\tif (f_first_in_fifo && f_first_addr == f_last_written)\n\t\t\tassert(f_first_return_",
            "reg == cpu_last_",
            "reg );\n\t\tif (f_next_in_fifo && f_next_addr == f_last_written)\n\t\t\tassert(f_next_return_",
            "reg == cpu_last_",
            "reg );\n\t\tif (rdaddr == f_last_written\n\t\t\t\t&& (rdaddr != f_first_addr)\n\t\t\t\t&& (rdaddr != f_next_addr))\n\t\t\t`BMC_ASSERT(fifo_return_",
            "reg == cpu_last_",
            "reg );\n\tend\n\t// }}}\n\n\t// Verifying the cpu_addr_",
            "reg // {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (i_stb)\n\t\tf_ar_a",
            "reg <= f_a",
            "reg ;\n\n\talways @(*)\n\tif (o_rdbusy)\n\t\t`ASSERT(f_ar_a",
            "reg == cpu_addr_",
            "reg );\n\n\talways @(*)\n\tif (!f_clrfifo && o_rdbusy && f_fifo_fill > 0)\n\tbegin\n\t\tif (f_first_in_fifo && f_first_addr != f_last_written)\n\t\t\tassert(f_first_return_",
            "reg != cpu_addr_",
            "reg || f_first_misaligned);\n\t\tif (f_next_in_fifo && f_next_addr != f_last_written)\n\t\t\tassert(f_next_return_",
            "reg != cpu_addr_",
            "reg || f_next_misaligned);\n\n\t\t// If the base address",
            "reg ister exists in the FIFO, then it\n\t\t// can't be part of any current requests.\n\t\tif ((f_first_in_fifo && (f_first_return_",
            "reg == cpu_addr_",
            "reg ) && !f_first_misaligned)\n\t\t\t||(f_next_in_fifo && (f_next_return_",
            "reg == cpu_addr_",
            "reg ) && !f_next_misaligned))\n\t\t\tassert(!M_AXI_WVALID && !M_AXI_ARVALID);\n\n\t\tif ((rdaddr != f_last_written || M_AXI_WVALID || M_AXI_ARVALID)\n\t\t\t\t&& !misaligned_response_pending\n\t\t\t\t&& (cpu_outstanding > (o_valid ? 1:0))\n\t\t\t\t&& (rdaddr != f_first_addr)\n\t\t\t\t&& (rdaddr != f_next_addr))\n\t\t\t`BMC_ASSERT(fifo_return_",
            "reg != cpu_addr_",
            "reg );\n\tend\n\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tinitial\tf_done = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || r_flushing)\n\t\tf_done <= 1'b0;\n\telse\n\t\tf_done <= (M_AXI_RVALID && !M_AXI_RRESP[1]\n\t\t\t|| M_AXI_BVALID && !M_AXI_BRESP[1]) && !pending_err\n\t\t\t\t&& !misaligned_response_pending;\n\n\n\tfmem #(\n\t\t// {{{\n\t\t.F_LGDEPTH(LGPIPE+1), .OPT_MAXDEPTH(1<<LGPIPE)\n\t\t// }}}\n\t) fcheck(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK),\n\t\t.i_sys_reset(!S_AXI_ARESETN),\n\t\t.i_cpu_reset(i_cpu_reset),\n\t\t.i_stb(i_stb),\n\t\t.i_pipe_stalled(o_pipe_stalled),\n\t\t.i_clear_cache(1'b0),\n\t\t.i_lock(i_lock), .i_op(i_op), .i_addr(i_addr),\n\t\t.i_data(i_data), .i_o",
            "reg (i_o",
            "reg ), .i_busy(o_busy),\n\t\t\t.i_a",
            "reg (f_a",
            "reg ),\n\t\t.i_rdbusy(o_rdbusy), .i_valid(o_valid), .i_done(f_done),\n\t\t.i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_result),\n\t\t.f_outstanding(cpu_outstanding),\n\t\t.f_pc(cpu_pc), .f_gie(cpu_gie), .f_read_cycle(cpu_read_cycle),\n\t\t.f_last_",
            "reg (cpu_last_",
            "reg ), .f_addr_",
            "reg (cpu_addr_",
            "reg )\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (flush_request)\n\tbegin\n\t\t`ASSERT(cpu_outstanding == 0 || o_err);\n\tend else if (r_flushing)\n\tbegin\n\t\t`ASSERT(o_err || cpu_outstanding == 0);\n\tend else if (OPT_ALIGNMENT_ERR)\n\tbegin\n\t\tif (!o_err)\n\t\t`ASSERT(cpu_outstanding == (beats_outstanding - flushcount)\n\t\t\t+ ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0)\n\t\t\t+ ((o_valid || f_done) ? 1:0));\n\t\t// else `ASSERT(cpu_outstanding == flushcount);\n\tend\n\n\talways @(*)\n\tif (o_err && beats_outstanding > 0)\n\t\t`ASSERT(r_flushing);\n\n\talways @(*)\n\tif (!o_err && cpu_outstanding > 0)\n\tbegin\n\t\tif (faxil_rd_outstanding > 0 || M_AXI_ARVALID || o_rdbusy)\n\t\tbegin\n\t\t\tassert(cpu_read_cycle);\n\t\tend else if (faxil_awr_outstanding > 0 || faxil_wr_outstanding > 0\n\t\t\t\t|| M_AXI_AWVALID || M_AXI_WVALID)\n\t\t\tassert(!cpu_read_cycle);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg [LGPIPE:0]\tcvr_writes, cvr_reads, cvr_valids;",
            "reg cvr_idle;\n\n\talways @(*)\n\tbegin\n\t\tcvr_idle = 1;\n\t\tif (i_cpu_reset || o_err || f_done)\n\t\t\tcvr_idle = 1'b0;\n\t\tif (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID)\n\t\t\tcvr_idle = 1'b0;\n\t\tif (faxil_awr_outstanding > 0)\n\t\t\tcvr_idle = 1'b0;\n\t\tif (faxil_wr_outstanding > 0)\n\t\t\tcvr_idle = 1'b0;\n\t\tif (faxil_rd_outstanding > 0)\n\t\t\tcvr_idle = 1'b0;\n\tend\n\n\tinitial\tcvr_writes = 0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || o_err)\n\t\tcvr_writes <= 0;\n\telse if (M_AXI_BVALID&& !misaligned_response_pending  && !(&cvr_writes))\n\t\tcvr_writes <= cvr_writes + 1;\n\n\tinitial\tcvr_reads = 0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || o_err)\n\t\tcvr_reads <= 0;\n\telse if (M_AXI_RVALID && !misaligned_response_pending && !(&cvr_reads))\n\t\tcvr_reads <= cvr_reads + 1;\n\n\tinitial\tcvr_valids = 0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || o_err)\n\t\tcvr_valids <= 0;\n\telse if (o_valid)\n\t\tcvr_valids <= cvr_valids + 1;\n\n\t// Cover a write response\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_BVALID && !M_AXI_BRESP[1]);\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_BVALID &&  M_AXI_BRESP[1]);\n\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_RVALID && !M_AXI_RRESP[1]);\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_RVALID &&  M_AXI_RRESP[1]);\n\n\n\talways @(posedge i_clk)\n\tif (cvr_idle)\n\tbegin\n\t\tcover(cvr_writes >  3);\n\t\tcover(cvr_reads  >  3);\n\t\tcover(cvr_valids >  3);\n\n\t\tcover(cvr_writes > (1<<LGPIPE));\n\t\tcover(cvr_reads  > (1<<LGPIPE));\n\t\tcover(cvr_valids > (1<<LGPIPE));\n\n\t\tcover(cvr_writes > (1<<LGPIPE)+2);\n\t\tcover(cvr_reads  > (1<<LGPIPE)+2);\n\t\tcover(cvr_valids > (1<<LGPIPE)+2);\n\tend\n\n\tgenerate if (!OPT_ALIGNMENT_ERR)\n\tbegin",
            "reg [LGPIPE:0]\tcvr_unaligned_writes,\n\t\t\t\t\tcvr_unaligned_reads;\n\n\t\tinitial\tcvr_writes = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_cpu_reset || o_err)\n\t\t\tcvr_unaligned_writes <= 0;\n\t\telse if (i_stb && i_op[0] && w_misaligned)\n\t\t\tcvr_unaligned_writes <= cvr_unaligned_writes + 1;\n\n\t\tinitial\tcvr_reads = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_cpu_reset || o_err)\n\t\t\tcvr_unaligned_reads <= 0;\n\t\telse if (i_stb && !i_op[0] && w_misaligned)\n\t\t\tcvr_unaligned_reads <= cvr_unaligned_reads + 1;\n\n\t\talways @(posedge i_clk)\n\t\tif (cvr_idle)\n\t\tbegin\n\t\t\tcover(cvr_unaligned_writes >  3);\n\t\t\tcover(cvr_unaligned_reads  >  3);\n\n\t\t\tcover(cvr_unaligned_writes > (1<<LGPIPE));\n\t\t\tcover(cvr_unaligned_reads  > (1<<LGPIPE));\n\t\tend\n\tend endgenerate\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Careless assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (!OPT_ALIGNMENT_ERR)\n\tbegin\n\t\tif (!r_flushing && !o_err)\n\t\t`BMC_ASSERT(cpu_outstanding <= beats_outstanding\n\t\t\t+ ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0)\n\t\t\t+ ((o_valid || f_done) ? 1:0));\n\n\t\tif (!r_flushing && cpu_read_cycle)\n\t\t`BMC_ASSERT(cpu_outstanding >= (f_done ? 1:0)\n\t\t\t\t\t+ faxil_rd_outstanding[F_LGDEPTH-1:1]);\n\t\telse if (!r_flushing)\n\t\t`BMC_ASSERT(cpu_outstanding >= (f_done ? 1:0)\n\t\t\t\t\t+ faxil_wr_outstanding[F_LGDEPTH-1:1]);\n\n\t\tif (!r_flushing && !o_err)\n\t\tassert(f_fifo_fill == beats_outstanding\n\t\t\t+ ((misaligned_aw_request && !misaligned_request) ? 1:0)\n\t\t\t\t+ (M_AXI_AWVALID && !M_AXI_WVALID));\n\n\t\tif (!r_flushing && !o_err)\n\t\t\t`BMC_ASSERT((cpu_outstanding == 0) == (!M_AXI_AWVALID\n\t\t\t\t&& !M_AXI_WVALID && !M_AXI_ARVALID\n\t\t\t\t&& (beats_outstanding + (f_done ? 1:0) == 0)));\n\t\telse if (o_err)\n\t\t\t`BMC_ASSERT(cpu_outstanding > 0);\n\n\n\t\tif (!r_flushing && !o_err && cpu_outstanding == (f_done ? 1:0))\n\t\t\t`BMC_ASSERT(beats_outstanding == 0\n\t\t\t\t&& !M_AXI_AWVALID && !M_AXI_WVALID\n\t\t\t\t&& !M_AXI_ARVALID);\n\tend\n\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "axidcache.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axidcache.v",
        "chunks": [
            "module axidcache #(\n\t\t// {{{\n\t\t// AXI Setup: address width, data width, ID width, and ID\n\t\t// {{{",
            "parameter C_AXI_ADDR_WIDTH = 32,",
            "parameter C_AXI_DATA_WIDTH = 64,",
            "parameter C_AXI_ID_WIDTH = 1,",
            "parameter [C_AXI_ID_WIDTH-1:0]\tAXI_ID = 0,\n\t\t// }}}\n\t\t// LGCACHELEN\n\t\t// {{{\n\t\t// The log (base 2) of the cache size in bytes.",
            "parameter LGCACHELEN = 8 + $clog2(C_AXI_DATA_WIDTH/8),",
            "localparam LGCACHEWORDS= LGCACHELEN-$clog2(C_AXI_DATA_WIDTH/8),\n\t\t// }}}\n\t\t// LGNLINES\n\t\t// {{{\n\t\t// The log (base 2) of the number of cache lines.  A cache line\n\t\t// is the minimum amount of data read on a miss.  Each cache\n\t\t// line has a valid signal and a tag associated with it.",
            "parameter LGNLINES = (LGCACHEWORDS-3),\n\t\t// }}}",
            "parameter [0:0]\tSWAP_WSTRB = 1'b0,\n\t\t// OPT_SIGN_EXTEND: When returning values to the CPU that are\n\t\t// {{{\n\t\t// less than word sized in length, if OPT_SIGN_EXTEND is true\n\t\t// these values will be sign extended.",
            "parameter [0:0]\tOPT_SIGN_EXTEND = 1'b0,\n\t\t// }}}",
            "parameter NAUX = 5,\n\t\t// OPT_PIPE: Set to 1 to allow multiple outstanding transactions\n\t\t// {{{\n\t\t// This is primarily used by write requests.  Read requests\n\t\t// will only ever read one cache line at a time.  Non-cache\n\t\t// reads are only ever done (at present) as singletons.",
            "parameter [0:0]\tOPT_PIPE = 1'b0,\n\t\t// }}}\n\t\t// OPT_WRAP: True if using AXI WRAP mode.  With AXI WRAP mode,\n\t\t// {{{\n\t\t// a cache read result will return its value before the entire\n\t\t// cache line read has been completed",
            "parameter [0:0]\tOPT_WRAP     = 1'b0,\n\t\t// }}}\n\t\t// OPT_LOWPOWER: If true, sets unused AXI values to all zeros,\n\t\t// {{{\n\t\t// or, in the case of AxSIZE, to 3'd2.  This is to keep things\n\t\t// from toggling if they don't need to.",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,\n\t\t// }}}\n\t\t// OPT_LOCK: Set to 1 in order to support exclusive access.\n\t\t// {{{",
            "parameter [0:0]\tOPT_LOCK = 1'b0,\n\t\t// }}}\n\t\t// Local",
            "parameter s, mostly abbreviations\n\t\t// {{{\n\t\t// Verilator lint_off UNUSED",
            "localparam LGPIPE = (OPT_PIPE) ? 4:2,\n\t\t// Verilator lint_on  UNUSED",
            "localparam [0:0]\tOPT_DUAL_READ_PORT = 1'b1,",
            "localparam [1:0]\tDC_IDLE  = 2'b00,\n\t\t\t\t\tDC_WRITE = 2'b01,\n\t\t\t\t\tDC_READS = 2'b10,\n\t\t\t\t\tDC_READC = 2'b11,",
            "localparam AW = C_AXI_ADDR_WIDTH,",
            "localparam DW = C_AXI_DATA_WIDTH,",
            "localparam IW = C_AXI_ID_WIDTH,",
            "localparam AXILSB = $clog2(C_AXI_DATA_WIDTH/8),",
            "localparam CS = LGCACHELEN - AXILSB, // Cache size, in wrds",
            "localparam LS = CS-LGNLINES,\t// Cache lines, lg_2",
            "localparam TW = AW-(CS+AXILSB)\t// Tag width\n\t\t// }}}\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK, S_AXI_ARESETN,",
            "input ",
            "wire i_cpu_reset, i_clear,\n\t\t// Interface from the CPU\n\t\t// {{{",
            "input ",
            "wire i_pipe_stb, i_lock,",
            "input ",
            "wire [2:0]\ti_op,",
            "input ",
            "wire [AW-1:0]\ti_addr,",
            "input ",
            "wire [AW-1:0]\ti_restart_pc,",
            "input ",
            "wire [31:0]\ti_data,",
            "input ",
            "wire [NAUX-1:0]\ti_o",
            "reg ,\n\t\t// Outputs, going back to the CPU",
            "output ",
            "reg o_busy, o_rdbusy,",
            "output ",
            "wire o_pipe_stalled,",
            "output ",
            "reg o_valid, o_err,",
            "output ",
            "reg [NAUX-1:0]\to_w",
            "reg ,",
            "output ",
            "reg [31:0]\to_data,\n\t\t// }}}\n\t\t// AXI bus interface\n\t\t// {{{\n\t\t// Write address\n\t\t// {{{",
            "output ",
            "wire M_AXI_AWVALID,",
            "input ",
            "wire M_AXI_AWREADY,\n\t\t// verilator coverage_off",
            "output ",
            "wire [IW-1:0]\tM_AXI_AWID,\t// = constant\n\t\t// verilator coverage_on",
            "output ",
            "wire [AW-1:0]\tM_AXI_AWADDR,\n\t\t// verilator coverage_off",
            "output ",
            "wire [7:0]\tM_AXI_AWLEN,\t// = const 0\n\t\t// verilator coverage_on",
            "output ",
            "wire [2:0]\tM_AXI_AWSIZE,",
            "output ",
            "wire [1:0]\tM_AXI_AWBURST,",
            "output ",
            "wire M_AXI_AWLOCK,",
            "output ",
            "wire [3:0]\tM_AXI_AWCACHE,\n\t\t// verilator coverage_off",
            "output ",
            "wire [2:0]\tM_AXI_AWPROT,",
            "output ",
            "wire [3:0]\tM_AXI_AWQOS,\n\t\t// verilator coverage_on\n\t\t// }}}\n\t\t// Write data\n\t\t// {{{",
            "output ",
            "wire M_AXI_WVALID,",
            "input ",
            "wire M_AXI_WREADY,",
            "output ",
            "wire [DW-1:0]\tM_AXI_WDATA,",
            "output ",
            "wire [DW/8-1:0]\tM_AXI_WSTRB,",
            "output ",
            "wire M_AXI_WLAST,\n\t\t// }}}\n\t\t// Write return\n\t\t// {{{",
            "input ",
            "wire M_AXI_BVALID,",
            "output ",
            "wire M_AXI_BREADY,\n\t\t// verilator coverage_off",
            "input ",
            "wire [IW-1:0]\tM_AXI_BID,\n\t\t// verilator coverage_on",
            "input ",
            "wire [1:0]\tM_AXI_BRESP,\n\t\t// }}}\n\t\t// Read address\n\t\t// {{{",
            "output ",
            "wire M_AXI_ARVALID,",
            "input ",
            "wire M_AXI_ARREADY,\n\t\t// verilator coverage_off",
            "output ",
            "wire [IW-1:0]\tM_AXI_ARID,\n\t\t// verilator coverage_on",
            "output ",
            "wire [AW-1:0]\tM_AXI_ARADDR,",
            "output ",
            "wire [7:0]\tM_AXI_ARLEN,",
            "output ",
            "wire [2:0]\tM_AXI_ARSIZE,",
            "output ",
            "wire [1:0]\tM_AXI_ARBURST,",
            "output ",
            "wire M_AXI_ARLOCK,",
            "output ",
            "wire [3:0]\tM_AXI_ARCACHE,\n\t\t// verilator coverage_off",
            "output ",
            "wire [2:0]\tM_AXI_ARPROT,",
            "output ",
            "wire [3:0]\tM_AXI_ARQOS,\n\t\t// verilator coverage_on\n\t\t// }}}\n\t\t// Read data returned\n\t\t// {{{",
            "input ",
            "wire M_AXI_RVALID,",
            "output ",
            "wire M_AXI_RREADY,\n\t\t// verilator coverage_off",
            "input ",
            "wire [IW-1:0]\tM_AXI_RID,\n\t\t// verilator coverage_on",
            "input ",
            "wire [DW-1:0]\tM_AXI_RDATA,",
            "input ",
            "wire M_AXI_RLAST,",
            "input ",
            "wire [1:0]\tM_AXI_RRESP\n\t\t// }}}\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam [1:0]\tINCR = 2'b01,\n\t\t\t\tWRAP = 2'b10;",
            "localparam [1:0]\tOKAY = 2'b00,\n\t\t\t\tEXOKAY = 2'b01;\n\t// Verilator lint_off UNUSED",
            "localparam DSZ = 2;\n\t// Verilator lint_on  UNUSED\n\n\t// The cache itself\n\t// {{{",
            "reg [(1<<(CS-LS))-1:0]\tcache_valid;",
            "reg [TW-1:0]\tcache_tag\t[0:(1<<LGNLINES)-1];",
            "reg [DW-1:0]\tcache_mem\t[0:(1<<CS)-1];",
            "reg [DW-1:0]\tcached_iword, cached_rword;\n\t// }}}",
            "reg misaligned;",
            "wire cache_miss_inow, address_is_cachable;",
            "wire cachable_request, cachable_read_request;",
            "wire i_read, i_write;",
            "reg [AW-AXILSB-1:0]\tr_addr;",
            "wire [CS-LS-1:0]\ti_cline, r_cline;",
            "wire [CS-1:0]\ti_caddr, r_caddr;",
            "reg [TW-1:0]\tlast_tag, r_itag, r_rtag, w_tag;",
            "reg [CS-LS-1:0]\tlast_tag_line;",
            "wire [TW-1:0]\tr_ctag, i_ctag, axi_tag;",
            "wire [CS-LS-1:0]\taxi_line;",
            "reg r_iv, r_rv, r_check, w_v, set_vflag;",
            "reg zero_noutstanding, last_ack, full_pipe,\n\t\t\t\tnearly_full_pipe;",
            "wire w_pipe_stalled;",
            "reg [LGPIPE-1:0]\tnoutstanding;",
            "reg [CS-1:0]\twcache_addr;",
            "reg [DW-1:0]\twcache_data;",
            "reg [DW/8-1:0]\twcache_strb;",
            "reg [TW-1:0]\twcache_tag;\n\tinteger\t\t\tik;",
            "reg good_cache_read;",
            "reg [1:0]\t\tstate;",
            "reg r_dvalid, r_svalid, r_cachable,\n\t\t\t\tr_cache_miss, flushing, r_rd_pending,\n\t\t\t\tlast_tag_valid, w_cache_miss;",
            "reg [DW-1:0]\tpre_data, shifted_data;",
            "reg [AXILSB+1:0]\treq_data;",
            "wire [AXILSB-1:0]\treq_lsb;",
            "wire [1:0]\t\treq_op;",
            "reg [1:0]\t\tsuppress_miss;",
            "reg [CS-1:0]\tread_addr;\n\n\tassign\ti_write = i_op[0];\n\tassign\ti_read  = !i_op[0];\n\n\t// AXI",
            "reg isters\n\t// {{{",
            "reg axi_awvalid, axi_wvalid;",
            "reg [AW-1:0]\taxi_awaddr;",
            "reg [2:0]\t\taxi_awsize;",
            "reg [DW-1:0]\taxi_wdata;",
            "reg [DW/8-1:0]\taxi_wstrb;",
            "wire [DW-1:0]\taxi_rdata;",
            "wire axi_awlock;",
            "reg axi_arvalid;",
            "reg [AW-1:0]\taxi_araddr;",
            "reg [7:0]\t\taxi_arlen;",
            "reg [2:0]\t\taxi_arsize;",
            "wire [1:0]\t\taxi_arburst;",
            "wire axi_arlock;\n\t// }}}\n\n\t// LOCK handling declarations\n\t// {{{",
            "wire [AW-1:0]\trestart_pc;",
            "wire locked_write_in_progress,\n\t\t\t\tlocked_read_in_progress,\n\t\t\t\tlocked_read_in_cache;\n\t// }}}\n\t// }}}\n\n\t// Fixed AXI",
            "output s that aren't changing\n\t// {{{\n\tassign\tM_AXI_AWID = AXI_ID;\n\tassign\tM_AXI_ARID = AXI_ID;\n\tassign\tM_AXI_AWLEN = 0;\t// All writes are one beat only\n\n\tassign\tM_AXI_AWBURST = INCR;\t// INCR addressing only\n\tassign\tM_AXI_ARBURST = axi_arburst;\n\n\tassign\tM_AXI_AWLOCK = OPT_LOCK && axi_awlock;\n\tassign\tM_AXI_ARLOCK = OPT_LOCK && axi_arlock;\n\n\tassign\tM_AXI_AWCACHE = M_AXI_AWLOCK ? 0 : 4'b011;\n\tassign\tM_AXI_ARCACHE = M_AXI_ARLOCK ? 0 : 4'b011;\n\n\tassign\tM_AXI_AWPROT = 3'b0;\t// == 3'b001 if GIE is clear, 3'b000 if\n\tassign\tM_AXI_ARPROT = 3'b0;\t// not\n\n\tassign\tM_AXI_AWQOS = 0;\n\tassign\tM_AXI_ARQOS = 0;\n\n\tassign\tM_AXI_WLAST = 1;\n\n\tassign\tM_AXI_BREADY = 1;\n\tassign\tM_AXI_RREADY = 1;\n\t// }}}\n\n\t// Misalignment detection\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tmisaligned = checklsb(i_op[2:1], i_addr[1:0]);\n\tend\n\n\tfunction checklsb;",
            "input [1:0]\top;",
            "input [1:0]\taddr;\n\n\t\tcasez(op[1:0])\n\t\t2'b0?:\tchecklsb = (addr[1:0] != 2'b00); // 32'bit words\n\t\t2'b10:\tchecklsb = addr[0];\t// 16-bit words\n\t\t2'b11:\tchecklsb = 1'b0;\t// Bytes are never misaligned\n\t\tendcase\n\tendfunction\n\t// }}}\n\n\t// Address decoding\n\t//  {{{\n\tassign\ti_cline = i_addr[LS+AXILSB +: (CS-LS)];\t// Cache line\n\tassign\ti_caddr = i_addr[AXILSB +: CS];\t\t// Cache address\n\tassign\ti_ctag  = i_addr[AW-1:CS+AXILSB];\t// Associated tag\n\n\t// Unlike i_addr, r_addr doesn't include the AXI LSB's\n\tassign\tr_cline = r_addr[CS-1:LS];\t// Cache line\n\tassign\tr_caddr = r_addr[CS-1:0];\t// Cache address\n\tassign\tr_ctag  = r_addr[AW-AXILSB-1 : CS];\t// Associated tag\n\n\tassign\tcache_miss_inow = (!last_tag_valid\n\t\t\t|| last_tag != i_ctag\n\t\t\t|| last_tag_line != i_cline);\n\t// }}}\n\n\t// Cache lookup\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\t\tr_check <= i_pipe_stb;\n\n\talways @(posedge S_AXI_ACLK)\n\tif (i_pipe_stb)\n\t\tr_itag  <= cache_tag[i_cline];\n\n\talways @(posedge S_AXI_ACLK)\n\tif (o_pipe_stalled)\n\t\tr_rtag  <= cache_tag[r_cline];\n\n\talways @(posedge S_AXI_ACLK)\n\tif (i_pipe_stb)\n\t\tr_iv  <= cache_valid[i_cline];\n\n\talways @(posedge S_AXI_ACLK)\n\t\tr_rv  <= cache_valid[r_cline] && r_rd_pending;\n\n\talways @(*)\n\t\tw_v = (r_check) ? r_iv : r_rv;\n\n\talways @(*)\n\t\tw_tag = (r_check) ? r_itag : r_rtag;\n\n\t// Cachability checking\n\t// {{{\n\t// Note that the correct address width must be built-in to the\n\t// iscachable routine.  It is *not*",
            "parameter izable.  iscachable must\n\t// be rewritten if the address width changes because, of necessity, that\n\t// also means the address map is changing and therefore what is and\n\t// isn't cachable.  etc.\n\tiscachable chkaddress(\n\t\ti_addr[AW-1:0], address_is_cachable\n\t);\n\t// }}}\n\n\t// Locked requests are *not* cachable, but *must* go to the bus\n\tassign\tcachable_request = address_is_cachable&& (!OPT_LOCK || !i_lock);\n\tassign\tcachable_read_request = i_pipe_stb && i_read\n\t\t\t\t\t\t&& cachable_request;\n\n\tinitial\tr_rd_pending = 0;\n\tinitial\tr_cache_miss = 0;\n\tinitial\tlast_tag_valid = 0;\n\tinitial\tr_dvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tbegin\n\t\tr_svalid <= cachable_read_request && !misaligned\n\t\t\t&& !cache_miss_inow && (wcache_strb == 0);\n\n\t\tif (!o_pipe_stalled)\n\t\t\tr_addr <= i_addr[AW-1:AXILSB];\n\n\t\tif (!o_pipe_stalled && !r_rd_pending)\n\t\tbegin\n\t\t\tr_cachable <= cachable_read_request;\n\t\t\tr_rd_pending <= cachable_read_request\n\t\t\t\t\t&& !misaligned\n\t\t\t\t\t&& (cache_miss_inow || (|wcache_strb));\n\t\tend else if (r_rd_pending)\n\t\tbegin\n\t\t\tr_rd_pending <= (w_tag != r_ctag || !w_v);\n\t\t\tif (OPT_WRAP && M_AXI_RVALID)\n\t\t\t\tr_rd_pending <= 0;\n\t\tend\n\n\t\tif (M_AXI_RVALID && M_AXI_RRESP[1])\n\t\t\tr_rd_pending <= 1'b0;\n\n\t\t// r_rd <= (i_pipe_stb && !i_read);\n\n\t\tr_dvalid <= !r_svalid && !r_dvalid\n\t\t\t\t&& (w_tag == r_ctag) && w_v\n\t\t\t\t&& r_cachable && r_rd_pending;\n\n\t\tif (w_tag == r_ctag && w_v && r_cachable && r_rd_pending)\n\t\tbegin\n\t\t\tlast_tag_valid <= 1'b1;\n\t\t\tlast_tag_line <= r_cline;\n\t\t\tlast_tag      <= r_ctag;\n\t\tend else if (state == DC_READC)\n\t\t\t//\t&& (last_tag == r_ctag)\n\t\t\t//\t&& (M_AXI_RVALID))\n\t\t\tlast_tag_valid <= 1'b0;\n\n\t\tr_cache_miss <= (r_cachable && !r_svalid\n\t\t\t\t&& (r_rd_pending && !r_svalid)\n\t\t\t\t&& (w_tag != r_ctag || !w_v));\n\n\t\tif (i_clear)\n\t\t\tlast_tag_valid <= 0;\n\t\tif (OPT_PIPE && M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\tlast_tag_valid <= 0;\n\n\t\tif (!S_AXI_ARESETN || i_cpu_reset)\n\t\tbegin\n\t\t\tr_cachable <= 1'b0;\n\t\t\tr_svalid <= 1'b0;\n\t\t\tr_dvalid <= 1'b0;\n\t\t\tr_cache_miss <= 1'b0;\n\t\t\tr_rd_pending <= 0;\n\t\t\tlast_tag_valid <= 0;\n\t\tend\n\tend\n\t// }}}\n\n\t// Transaction counting\n\t// {{{\n\tinitial\tnoutstanding = 0;\n\tinitial\tzero_noutstanding = 1;\n\tinitial\tnearly_full_pipe = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\tbegin\n\t\tnoutstanding <= 0;\n\t\tzero_noutstanding <= 1;\n\t\tnearly_full_pipe <= 0;\n\tend else case( { ((M_AXI_AWVALID && M_AXI_AWREADY)\n\t\t\t\t\t||(M_AXI_ARVALID && M_AXI_ARREADY)),\n\t\t\t((M_AXI_RVALID && M_AXI_RLAST) || M_AXI_BVALID)\n\t\t\t})\n\t2'b10: begin\n\t\tnoutstanding <= noutstanding + 1;\n\t\tzero_noutstanding <= 1'b0;\n\t\tnearly_full_pipe <= (noutstanding >= (1<<LGPIPE)-3);\n\t\tend\n\t2'b01: begin\n\t\tnoutstanding <= noutstanding - 1;\n\t\tzero_noutstanding <= (noutstanding == 1);\n\t\tnearly_full_pipe <= (&noutstanding);\n\t\tend\n\tdefault: begin end\n\tendcase\n\n`ifdef\tFORMAL\n\talways @(*)\n\tbegin\n\t\tassert(zero_noutstanding == (noutstanding == 0));\n\t\tassert(nearly_full_pipe == (noutstanding >= (1<<LGPIPE)-2));\n\tend\n`endif\n\n\talways @(*)\n\tbegin\n\t\tfull_pipe = 1'b0;\n\t\tif (nearly_full_pipe)\n\t\t\tfull_pipe = noutstanding[0]\n\t\t\t\t\t|| (M_AXI_AWVALID || M_AXI_WVALID);\n\tend\n\n\talways @(*)\n\t\tlast_ack = (noutstanding <= 1)&&(!M_AXI_ARVALID && !M_AXI_AWVALID);\n\n\tinitial\tflushing = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tflushing <= 0;\n\telse if (flushing)\n\tbegin // Can we clear flushing?\n\t\tif (zero_noutstanding)\n\t\t\tflushing <= 1'b0;\n\t\tif (last_ack && (M_AXI_BVALID\n\t\t\t\t|| (M_AXI_RVALID && M_AXI_RLAST)))\n\t\t\tflushing <= 1'b0;\n\t\tif (M_AXI_AWVALID || M_AXI_ARVALID || M_AXI_WVALID)\n\t\t\tflushing <= 1'b1;\n\tend else if (i_cpu_reset\n\t\t\t|| (M_AXI_RVALID && M_AXI_RRESP[1])\n\t\t\t|| (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t|| (OPT_PIPE && i_pipe_stb && misaligned))\n\tbegin // Flushing causes\n\t\tflushing <= 1'b0;\n\t\tif (M_AXI_ARVALID || M_AXI_AWVALID || M_AXI_WVALID)\n\t\t\tflushing <= 1'b1;\n\t\tif (!last_ack)\n\t\t\tflushing <= 1'b1;\n\t\tif ((noutstanding >= 1) && !M_AXI_BVALID\n\t\t\t\t\t&& (!M_AXI_RVALID || !M_AXI_RLAST))\n\t\t\tflushing <= 1'b1;\n\tend\n\t// }}}\n\n\t// Read handling\n\t// {{{\n\t// Read state machine\n\t// {{{\n\tinitial\tstate = DC_IDLE;\n\tinitial\tset_vflag = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\tbegin\n\t\t// {{{\n\t\tcache_valid <= 0;\n\t\t// end_of_line <= 1'b0;\n\t\t// last_line_stb <= 1'b0;\n\t\tstate <= DC_IDLE;\n\t\tset_vflag <= 1'b0;\n\t\t// }}}\n\tend else begin\n\t\t// {{{\n\t\tset_vflag <= 1'b0;\n\t\tif (set_vflag)\n\t\t\tcache_valid[r_cline] <= 1'b1;\n\n\t\tcase(state)\n\t\tDC_IDLE: begin\n\t\t\t// {{{\n\t\t\tgood_cache_read <= 1'b1;\n\t\t\tif (i_pipe_stb && i_write && !misaligned)\n\t\t\t\tstate <= DC_WRITE;\n\t\t\telse if (w_cache_miss)\n\t\t\t\tstate <= DC_READC;\n\t\t\telse if (i_pipe_stb && i_read && !cachable_request\n\t\t\t\t\t&& !misaligned)\n\t\t\t\tstate <= DC_READS;\n\n\t\t\tif (i_cpu_reset)\n\t\t\t\tstate <= DC_IDLE;\n\t\t\tend\n\t\t\t// }}}\n\t\tDC_READC: begin\t// Read cache line\n\t\t\t// {{{\n\t\t\tif (M_AXI_RVALID)\n\t\t\tbegin\n\t\t\t\tgood_cache_read\n\t\t\t\t\t<= good_cache_read && !M_AXI_RRESP[1];\n\t\t\t\tcache_valid[r_cline] <= 1'b0;\n\t\t\tend\n\t\t\tif (M_AXI_RVALID && M_AXI_RLAST)\n\t\t\tbegin\n\t\t\t\tstate <= DC_IDLE;\n\t\t\t\tset_vflag <= !i_cpu_reset && !i_clear && !flushing && !M_AXI_RRESP[1] && good_cache_read;\n\t\t\tend end\n\t\t\t// }}}\n\t\tDC_READS: begin\t// Read single value\n\t\t\t// {{{\n\t\t\tif (M_AXI_RVALID && last_ack)\n\t\t\t\tstate <= DC_IDLE;\n\t\t\tend\n\t\t\t// }}}\n\t\tDC_WRITE: begin\n\t\t\t// {{{\n\t\t\tif (M_AXI_BVALID && M_AXI_BREADY\n\t\t\t\t&& (!OPT_PIPE || (last_ack && !i_pipe_stb)))\n\t\t\t\tstate <= DC_IDLE;\n\t\t\tend\n\t\t\t// }}}\n\t\tendcase\n\n\t\tif (i_clear || i_cpu_reset)\n\t\t\tcache_valid <= 0;\n\t\tif (OPT_PIPE && M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\tcache_valid <= 0;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// axi_axlock\n\t// {{{\n\tgenerate if (OPT_LOCK)\n\tbegin : GEN_AXLOCK",
            "reg r_arlock, r_awlock;",
            "reg [2:0]\tr_read_in_cache;\n\n\t\tinitial\tr_arlock = 1'b0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_arlock <= 1'b0;\n\t\telse if (i_pipe_stb)\n\t\tbegin\n\t\t\tr_arlock <= i_lock;\n\n\t\t\tif (misaligned || i_write)\n\t\t\t\tr_arlock <= 1'b0;\n\t\tend else if (M_AXI_RVALID)\n\t\t\tr_arlock <= 1'b0;\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || r_rd_pending || M_AXI_RVALID)\n\t\t\tr_read_in_cache <= 3'b00;\n\t\telse if (i_pipe_stb)\n\t\tbegin\n\t\t\tr_read_in_cache <= 3'b00;\n\t\t\tr_read_in_cache[0] <= address_is_cachable && i_read && i_lock;\n\t\tend else if (r_read_in_cache != 0)\n\t\tbegin\n\t\t\tr_read_in_cache[2:1] <= { r_read_in_cache[1:0] };\n\t\t\tif (r_read_in_cache[1] && ((w_tag != r_ctag) || !w_v))\n\t\t\t\tr_read_in_cache <= 0;\n\t\t\t\t// && (w_tag == r_ctag) && w_v\n\t\tend\n\n\t\tinitial\tr_awlock = 1'b0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_awlock <= 1'b0;\n\t\telse if (i_pipe_stb)\n\t\tbegin\n\t\t\tr_awlock <= i_lock;\n\n\t\t\tif (misaligned || i_read)\n\t\t\t\tr_awlock <= 1'b0;\n\t\tend else if (M_AXI_BVALID)\n\t\t\tr_awlock <= 1'b0;\n\n\t\tassign\tlocked_write_in_progress = r_awlock;\n\t\tassign\tlocked_read_in_progress  = r_arlock;\n\t\tassign\tlocked_read_in_cache = r_read_in_cache[2];\n\t\tassign\taxi_awlock = r_awlock;\n\t\tassign\taxi_arlock = r_arlock;\n\tend else begin : NO_LOCK\n\t\tassign\taxi_awlock = 1'b0;\n\t\tassign\taxi_arlock = 1'b0;\n\t\tassign\tlocked_write_in_progress = 1'b0;\n\t\tassign\tlocked_read_in_progress  = 1'b0;\n\t\tassign\tlocked_read_in_cache = 1'b0;\n\tend endgenerate\n\t// }}}\n\n\t// M_AXI_ARVALID, axi_arvalid\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\t\tsuppress_miss <= { suppress_miss[0] || set_vflag, set_vflag };\n\talways @(*)\n\t\tw_cache_miss = r_cache_miss && state == DC_IDLE\n\t\t\t\t&& !r_dvalid && !o_err\n\t\t\t\t&& wcache_strb == 0 && !suppress_miss[1];\n\n\tinitial\taxi_arvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_arvalid <= 0;\n\telse if (!M_AXI_ARVALID || M_AXI_ARREADY)\n\tbegin\n\t\taxi_arvalid <= 1'b0;\n\t\tif (i_pipe_stb && i_read && !misaligned\n\t\t\t&& ((OPT_LOCK && i_lock) || !address_is_cachable))\n\t\t\taxi_arvalid <= 1;\n\t\tif (w_cache_miss)\n\t\t\taxi_arvalid <= 1;\n\t\tif (i_cpu_reset)\n\t\t\taxi_arvalid <= 0;\n\tend\n\n\tassign\tM_AXI_ARVALID = axi_arvalid;\n\t// }}}\n\n\t// M_AXI_ARADDR, M_AXI_ARSIZE, M_AXI_ARLEN\n\t// {{{\n\tinitial\taxi_araddr = 0;\n\tinitial\taxi_arsize = 3'd2;\n\tinitial\taxi_arlen  = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\tbegin\n\t\t// {{{\n\t\taxi_araddr <= 0;\n\t\taxi_arsize <= 3'd2;\n\t\taxi_arlen  <= 0;\n\t\t// }}}\n\tend else if (!M_AXI_ARVALID || M_AXI_ARREADY)\n\tbegin\n\t\taxi_arlen  <= 0;\n\t\tif (r_cache_miss)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tif (OPT_WRAP)\n\t\t\t\taxi_araddr <= { r_ctag, r_caddr[CS-1:0],\n\t\t\t\t\t\t\t{(AXILSB){1'b0}} };\n\t\t\telse\n\t\t\t\taxi_araddr <= { r_ctag, r_cline, {(LS+AXILSB){1'b0}} };\n\t\t\taxi_arlen  <= (1 << LS) - 1;\n\t\t\taxi_arsize <= AXILSB[2:0];\n\t\t\t// }}}\n\t\tend else begin\n\t\t\t// {{{\n\t\t\taxi_araddr <= i_addr;\n\t\t\taxi_arlen  <= 0;\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b0?: axi_arsize <= 3'd2;\n\t\t\t2'b10: axi_arsize <= 3'd1;\n\t\t\t2'b11: axi_arsize <= 3'd0;\n\t\t\t// default:  axi_arsize <= 3'd2; (Messes w/ coverage)\n\t\t\tendcase\n\n\t\t\tif (SWAP_WSTRB)\n\t\t\tbegin\n\t\t\t\t// axi_araddr[AXILSB-1:0] <= ~i_addr[AXILSB-1:0];\n\t\t\t\taxi_araddr[1:0] <= 0;\n\t\t\t\taxi_arsize <= 3'b010;\n\t\t\tend\n\t\t\t// }}}\n\t\tend\n\n\t\tif (OPT_LOWPOWER && (i_cpu_reset || (!w_cache_miss\n\t\t\t&& (!i_pipe_stb || i_op[0] || misaligned\n\t\t\t\t\t|| (address_is_cachable && !i_lock)))))\n\t\tbegin\n\t\t\t// {{{\n\t\t\taxi_araddr <= 0;\n\t\t\taxi_arlen  <= 0;\n\t\t\taxi_arsize <= 3'd2;\n\t\t\t// }}}\n\t\tend\n\tend\n\n\tassign\taxi_tag  = axi_araddr[AW-1:AW-TW];\n\tassign\taxi_line = axi_araddr[AXILSB+LS +: CS-LS];\n\n\tassign\tM_AXI_ARADDR = axi_araddr;\n\tassign\tM_AXI_ARLEN  = axi_arlen;\n\tassign\tM_AXI_ARSIZE = axi_arsize;\n\t// }}}\n\n\t// M_AXI_ARBURST\n\t// {{{\n\tgenerate if (OPT_WRAP)\n\tbegin : GEN_ARBURST",
            "reg r_wrap;\n\n\t\tinitial\tr_wrap = 1'b0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tr_wrap <= 1'b0;\n\t\t\t// }}}\n\t\tend else if (!M_AXI_ARVALID || M_AXI_ARREADY)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tr_wrap <= 1'b0;\n\t\t\tif (r_cache_miss)\n\t\t\t\tr_wrap <= 1'b1;\n\t\t\t// }}}\n\t\tend\n\n\t\tassign\taxi_arburst = r_wrap ? WRAP : INCR;\n\n\tend else begin : NO_WRAPBURST\n\n\t\tassign\taxi_arburst = INCR;\n\tend endgenerate\n\n\t// }}}\n\t// }}}\n\n\t// Writes always go straight to the bus\n\t// {{{\n\n\t// M_AXI_AWVALID, axi_awvalid\n\t// {{{\n\tinitial\taxi_awvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_awvalid <= 1'b0;\n\telse if (!M_AXI_AWVALID || M_AXI_AWREADY)\n\tbegin\n\t\taxi_awvalid <= i_pipe_stb && i_op[0] && !misaligned;\n\t\tif (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\taxi_awvalid <= 1'b0;\n\t\tif (i_cpu_reset || flushing)\n\t\t\taxi_awvalid <= 1'b0;\n\tend\n\n\tassign\tM_AXI_AWVALID = axi_awvalid;\n\t// }}}\n\n\t// M_AXI_AWADDR\n\t// {{{\n\tinitial\taxi_awaddr = 0;\n\tinitial\taxi_awsize = 3'd2;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN && OPT_LOWPOWER)\n\tbegin\n\t\taxi_awaddr <= 0;\n\t\taxi_awsize <= 3'd2;\n\tend else if (!M_AXI_AWVALID || M_AXI_AWREADY)\n\tbegin\n\t\taxi_awaddr <= i_addr;\n\n\t\tcasez(i_op[2:1])\n\t\t2'b0?: axi_awsize <= 3'd2;\n\t\t2'b10: axi_awsize <= 3'd1;\n\t\t2'b11: axi_awsize <= 3'd0;\n\t\t// default:  axi_awsize <= 3'd2;\t(Unused, messes w/ covr)\n\t\tendcase\n\n\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\t// axi_awaddr[AXILSB-1:0] <= ~i_addr[AXILSB-1:0];\n\t\t\taxi_awaddr[1:0] <= 0;\n\t\t\taxi_awsize <= 3'd2;\n\t\tend\n\n\t\tif (OPT_LOWPOWER && (!i_pipe_stb || !i_op[0] || misaligned\n\t\t\t\t|| i_cpu_reset || flushing\n\t\t\t\t|| (M_AXI_BVALID && M_AXI_BRESP[1])))\n\t\tbegin\n\t\t\taxi_awaddr <= 0;\n\t\t\taxi_awsize <= 3'd2;\n\t\tend\n\tend\n\n\tassign\tM_AXI_AWADDR = axi_awaddr;\n\tassign\tM_AXI_AWSIZE = axi_awsize;\n\t// }}}\n\n\t// M_AXI_WVALID\n\t// {{{\n\tinitial\taxi_wvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_wvalid <= 0;\n\telse if (!M_AXI_WVALID || M_AXI_WREADY)\n\tbegin\n\t\taxi_wvalid <= i_pipe_stb && i_op[0] && !misaligned;\n\t\tif (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\taxi_wvalid <= 1'b0;\n\t\tif (i_cpu_reset || flushing)\n\t\t\taxi_wvalid <= 1'b0;\n\tend\n\n\tassign\tM_AXI_WVALID = axi_wvalid;\n\t// }}}\n\n\t// M_AXI_WDATA, M_AXI_WSTRB\n\t// {{{\n\tinitial\taxi_wdata = 0;\n\tinitial\taxi_wstrb = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN && OPT_LOWPOWER)\n\tbegin\n\t\taxi_wdata <= 0;\n\t\taxi_wstrb <= 0;\n\tend else if (!M_AXI_WVALID || M_AXI_WREADY)\n\tbegin\n\n\t\t// WDATA\n\t\t// {{{\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tcasez(i_op[2:1])\n\t\t\t// Write a 16b half-word\n\t\t\t2'b10: axi_wdata <= { i_data[15:0],\n\t\t\t\t{(C_AXI_DATA_WIDTH-16){1'b0}} }\n\t\t\t\t>> (8*i_addr[AXILSB-1:0]);\n\t\t\t// Write an 8b half-word\n\t\t\t2'b11: axi_wdata <= { i_data[7:0],\n\t\t\t\t\t{(C_AXI_DATA_WIDTH-8){1'b0}} }\n\t\t\t\t>> (8*i_addr[AXILSB-1:0]);\n\t\t\tdefault: axi_wdata <= { i_data,\n\t\t\t\t\t{(C_AXI_DATA_WIDTH-32){1'b0}} }\n\t\t\t\t>> (8*i_addr[AXILSB-1:0]);\n\t\t\tendcase\n\t\t\t// }}}\n\t\tend else begin\n\t\t\t// {{{\n\t\t\tcasez(i_op[2:1])\n\t\t\t// Write a 16b half-word\n\t\t\t2'b10: axi_wdata <= { {(C_AXI_DATA_WIDTH-16){1'b0}},\n\t\t\t\ti_data[15:0] } << (8*i_addr[AXILSB-1:0]);\n\t\t\t// Write an 8b half-word\n\t\t\t2'b11: axi_wdata <= { {(C_AXI_DATA_WIDTH-8){1'b0}},\n\t\t\t\ti_data[7:0] } << (8*i_addr[AXILSB-1:0]);\n\t\t\tdefault: axi_wdata <= { {(C_AXI_DATA_WIDTH-32){1'b0}},\n\t\t\t\ti_data } << (8*i_addr[AXILSB-1:0]);\n\t\t\tendcase\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\n\t\t// WSTRB\n\t\t// {{{\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tcasez(i_op[2:1])\n\t\t\t// Write a 16b half-word\n\t\t\t2'b10: axi_wstrb <= { 2'b11,\n\t\t\t\t{(C_AXI_DATA_WIDTH/8-2){1'b0}} }\n\t\t\t\t>> (i_addr[AXILSB-1:0]);\n\t\t\t// Write an 8b half-word\n\t\t\t2'b11: axi_wstrb <= { 1'b1,\n\t\t\t\t{(C_AXI_DATA_WIDTH/8-1){1'b0}} }\n\t\t\t\t>> (i_addr[AXILSB-1:0]);\n\t\t\tdefault: axi_wstrb <= { 4'b1111,\n\t\t\t\t\t{(C_AXI_DATA_WIDTH/8-4){1'b0}} }\n\t\t\t\t\t>> (i_addr[AXILSB-1:0]);\n\t\t\tendcase\n\t\t\t// }}}\n\t\tend else begin\n\t\t\t// {{{\n\t\t\tcasez(i_op[2:1])\n\t\t\t// Write a 16b half-word\n\t\t\t2'b10: axi_wstrb <= { {(C_AXI_DATA_WIDTH/8-4){1'b0}},\n\t\t\t\t4'b0011 } << (i_addr[AXILSB-1:0]);\n\t\t\t// Write an 8b half-word\n\t\t\t2'b11: axi_wstrb <= { {(C_AXI_DATA_WIDTH/8-4){1'b0}},\n\t\t\t\t4'b0001 } << (i_addr[AXILSB-1:0]);\n\t\t\tdefault: axi_wstrb <= { {(C_AXI_DATA_WIDTH/8-4){1'b0}},\n\t\t\t\t\t4'b1111 } << (i_addr[AXILSB-1:0]);\n\t\t\tendcase\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\n\t\t// OPT_LOWPOWER: Clear if nothing is being used\n\t\t// {{{\n\t\tif (OPT_LOWPOWER && ((!i_pipe_stb || !i_op[0] || misaligned)\n\t\t\t|| (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t|| (i_cpu_reset || flushing)))\n\t\tbegin\n\t\t\taxi_wdata <= 0;\n\t\t\taxi_wstrb <= 0;\n\t\tend\n\t\t// }}}\n\tend\n\n\tgenvar\tgk;\n\tgenerate if (!SWAP_WSTRB)\n\tbegin : NO_SWAP_WSTRB\n\t\tassign\tM_AXI_WDATA = axi_wdata;\n\t\tassign\tM_AXI_WSTRB = axi_wstrb;\n\n\t\tassign\taxi_rdata   = M_AXI_RDATA;\n\tend else begin : J\n\tfor(gk=0; gk<C_AXI_DATA_WIDTH/32; gk=gk+1)\n\tbegin : GEN_SWAP_WSTRB\n\t\tassign\tM_AXI_WDATA[32*gk +: 32] = axi_wdata[C_AXI_DATA_WIDTH - (gk+1)*32 +: 32];\n\t\tassign\tM_AXI_WSTRB[ 4*gk +:  4] = axi_wstrb[C_AXI_DATA_WIDTH/8 - (gk+1)*4 +: 4];\n\n\t\tassign\taxi_rdata[32*gk +: 32] = M_AXI_RDATA[C_AXI_DATA_WIDTH - (gk+1)*32 +: 32];\n\tend end endgenerate\n\t// }}}\n\t// }}}\n\n\t// Writes take a clock to go to the cache\n\t// {{{",
            "reg [AW-1:0]\trev_addr;\n\talways @(*)\n\tbegin\n\t\trev_addr = i_addr;\n\t\t/*\n\t\tif (SWAP_WSTRB && C_AXI_DATA_WIDTH != 32)\n\t\tbegin\n\t\t\trev_addr[AXILSB-1:0] = ~i_addr[AXILSB-1:0];\n\t\t\trev_addr[1:0] = i_addr[1:0];\n\t\tend\n\t\t*/\n\tend\n\n\talways @(posedge S_AXI_ACLK)\n\tbegin\n\t\twcache_strb <= 0;\n\n\t\tif (i_pipe_stb && (!OPT_LOWPOWER || i_read))\n\t\tbegin\n\t\t\tif (i_lock && OPT_LOCK)\n\t\t\t\tread_addr <= i_addr[LGCACHELEN-1:AXILSB];\n\t\t\telse if (OPT_WRAP)\n\t\t\t\tread_addr <= i_addr[LGCACHELEN-1:AXILSB];\n\t\t\telse\n\t\t\t\tread_addr <= { i_addr[LGCACHELEN-1:AXILSB+LS], {(LS){1'b0}} };\n\t\tend\n\n\t\tif (state == DC_READC)\n\t\tbegin\n\t\t\t// {{{\n\t\t\t// Write returning read data to the cache\n\t\t\tif (M_AXI_RVALID)\n\t\t\t\tread_addr[LS-1:0]\n\t\t\t\t\t<= read_addr[LS-1:0] + 1;\n\t\t\tread_addr[CS-1:LS] <= r_cline;\n\t\t\twcache_addr <= read_addr;\n\t\t\twcache_data <= axi_rdata;\n\t\t\twcache_strb <= -1;\n\t\t\tif (!M_AXI_RVALID || flushing || i_cpu_reset\n\t\t\t\t|| M_AXI_RRESP[1])\n\t\t\t\twcache_strb <= 0;\n\t\t\twcache_tag  <= w_tag;\n\t\t\t// }}}\n\t\tend else begin\n\t\t\t// {{{\n\t\t\tif (i_pipe_stb)\n\t\t\t\t{ wcache_tag, wcache_addr } <= i_addr[AW-1:AXILSB];\n\t\t\telse if (locked_read_in_progress)\n\t\t\t\twcache_addr <= read_addr;\n\t\t\telse\n\t\t\t\twcache_addr[LS-1:0] <= 0;\n\n\t\t\t// wcache_data\n\t\t\t// {{{\n\t\t\tif (SWAP_WSTRB)\n\t\t\tbegin\n\t\t\t\tcasez(i_op[2:1])\n\t\t\t\t// Write a 16b half-word\n\t\t\t\t2'b10: wcache_data <= { i_data[15:0],\n\t\t\t\t\t\t\t{(DW-16){1'b0}} }\n\t\t\t\t\t>> (8*i_addr[AXILSB-1:0]);\n\t\t\t\t// Write an 8b half-word\n\t\t\t\t2'b11: wcache_data <= { i_data[7:0],\n\t\t\t\t\t\t\t{(DW-8){1'b0}} }\n\t\t\t\t\t>> (8*i_addr[AXILSB-1:0]);\n\t\t\t\tdefault: wcache_data <= { i_data,\n\t\t\t\t\t\t\t{(DW-32){1'b0}} }\n\t\t\t\t\t>> (8*i_addr[AXILSB-1:0]);\n\t\t\t\tendcase\n\t\t\tend else begin\n\t\t\t\tcasez(i_op[2:1])\n\t\t\t\t// Write a 16b half-word\n\t\t\t\t2'b10: wcache_data <= { {(DW-16){1'b0}},\n\t\t\t\t\ti_data[15:0] } << (8*i_addr[AXILSB-1:0]);\n\t\t\t\t// Write an 8b half-word\n\t\t\t\t2'b11: wcache_data <= { {(DW-8){1'b0}},\n\t\t\t\t\ti_data[7:0] } << (8*i_addr[AXILSB-1:0]);\n\t\t\t\tdefault: wcache_data <= { {(DW-32){1'b0}},\n\t\t\t\t\ti_data } << (8*i_addr[AXILSB-1:0]);\n\t\t\t\tendcase\n\t\t\tend\n\n\t\t\tif (locked_read_in_progress)\n\t\t\t\twcache_data <= axi_rdata;\n\t\t\t// }}}\n\n\t\t\t// wcache_strb\n\t\t\t// {{{\n\t\t\tif (SWAP_WSTRB)\n\t\t\tbegin\n\t\t\t\tcase(i_op[2:1])\n\t\t\t\t// Write a 16b half-word\n\t\t\t\t2'b10: wcache_strb<=\n\t\t\t\t\t{ 2'h3, {(C_AXI_DATA_WIDTH/8-2){1'b0}} }\n\t\t\t\t\t\t>> (i_addr[AXILSB-1:0]);\n\t\t\t\t// Write an 8b byte\n\t\t\t\t2'b11: wcache_strb<=\n\t\t\t\t\t{ 1'b1, {(C_AXI_DATA_WIDTH/8-1){1'b0}} }\n\t\t\t\t\t\t>> (i_addr[AXILSB-1:0]);\n\t\t\t\tdefault: wcache_strb<=\n\t\t\t\t\t{ 4'hf, {(C_AXI_DATA_WIDTH/8-4){1'b0}} }\n\t\t\t\t\t\t>> (i_addr[AXILSB-1:0]);\n\t\t\t\tendcase\n\t\t\tend else begin\n\t\t\t\tcase(i_op[2:1])\n\t\t\t\t// Write a 16b half-word\n\t\t\t\t2'b10: wcache_strb<=\n\t\t\t\t\t{ {(C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'h3 }\n\t\t\t\t\t\t<< (i_addr[AXILSB-1:0]);\n\t\t\t\t// Write an 8b byte\n\t\t\t\t2'b11: wcache_strb<=\n\t\t\t\t\t{ {(C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'h1 }\n\t\t\t\t\t\t<< (i_addr[AXILSB-1:0]);\n\t\t\t\tdefault: wcache_strb<=\n\t\t\t\t\t{{(C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'hf }\n\t\t\t\t\t\t<< (i_addr[AXILSB-1:0]);\n\t\t\t\tendcase\n\t\t\tend\n\t\t\t// }}}\n\n\t\t\tif (locked_read_in_progress)\n\t\t\tbegin\n\t\t\t\tif (!locked_read_in_cache || !M_AXI_RVALID\n\t\t\t\t\t\t|| M_AXI_RRESP != EXOKAY)\n\t\t\t\t\twcache_strb <= 0;\n\t\t\tend else if (!i_pipe_stb || !i_op[0] || misaligned)\n\t\t\t\twcache_strb <= 0;\n\t\t\t// }}}\n\t\tend\n\tend\n\t// }}}\n\n\t// Actually write to the cache\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (state != DC_WRITE || (r_iv && wcache_tag == r_itag))\n\tbegin\n\t\tfor(ik=0; ik<DW/8; ik=ik+1)\n\t\tif (wcache_strb[ik])\n\t\t\tcache_mem[wcache_addr][8*ik +: 8] <= wcache_data[8*ik +: 8];\n\tend\n\t// }}}\n\n\t// Update the cache tag\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!flushing && M_AXI_RVALID && state == DC_READC)\n\t\tcache_tag[r_cline] <= r_ctag;\n\t// }}}\n\n\t// o_busy\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\to_busy <= 1'b0;\n\telse if (flushing || (i_pipe_stb && !misaligned))\n\t\to_busy <= 1'b1;\n\telse if (state  == DC_READS && M_AXI_RVALID && last_ack)\n\t\to_busy <= 1'b0;\n\telse if (OPT_WRAP\n\t\t\t// && state  == DC_READC && M_AXI_RVALID && M_AXI_RLAST\n\t\t\t&& state == DC_IDLE && !r_rd_pending)\n\t\to_busy <= 1'b0;\n\telse if ((r_dvalid || r_svalid) && (!OPT_WRAP || state == DC_IDLE))\n\t\to_busy <= 1'b0;\n\telse if (M_AXI_BVALID && last_ack && (!OPT_PIPE || !i_pipe_stb))\n\t\to_busy <= 1'b0;\n\t// }}}\n\n\t// o_rdbusy\n\t// {{{\n\tinitial\to_rdbusy = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\to_rdbusy <= 1'b0;\n\telse if (i_cpu_reset)\n\t\to_rdbusy <= 1'b0;\n\telse if (i_pipe_stb && (i_read || (i_lock && OPT_LOCK))&& !misaligned)\n\t\to_rdbusy <= 1'b1;\n\telse if (state == DC_READS && M_AXI_RVALID)\n\t\to_rdbusy <= 1'b0;\n\telse if (state == DC_READC && M_AXI_RVALID && (OPT_WRAP || M_AXI_RRESP[1]))\n\t\to_rdbusy <= 1'b0;\n\telse if (locked_write_in_progress && M_AXI_BVALID)\n\t\to_rdbusy <= 1'b0;\n\telse if (r_svalid || r_dvalid)\n\t\to_rdbusy <= 1'b0;\n\t// }}}\n\n\t// o_pipe_stalled\n\t// {{{\n\tgenerate if (OPT_PIPE)\n\tbegin : GEN_PIPE_STALL",
            "reg r_pipe_stalled, pipe_stalled;\n\t\t(* keep *)",
            "reg [3:0]\tr_pipe_code;\n\n\t// else case( { ((M_AXI_AWVALID && M_AXI_AWREADY)\n\t//\t\t\t\t||(M_AXI_ARVALID && M_AXI_ARREADY)),\n\t//\t\t((M_AXI_RVALID && M_AXI_RLAST) || M_AXI_BVALID)\n\t//\t\t})\n\t// 2'b10: noutstanding <= noutstanding + 1;\n\t// 2'b01: noutstanding <= noutstanding - 1;\n\n\t\tinitial\tr_pipe_stalled = 1'b0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\tr_pipe_stalled <= 1'b0;\n\t\t\tr_pipe_code <= 4'h0;\n\t\tend else begin\n\t\t\t// Clear any stall on the last outstanding bus response\n\t\t\tif ((!OPT_WRAP && r_dvalid)\n\t\t\t\t// || (OPT_WRAP && state == DC_READC\n\t\t\t\t//\t\t&& M_AXI_RVALID && M_AXI_RLAST)\n\t\t\t\t|| (OPT_WRAP && state == DC_IDLE && !r_rd_pending))\n\t\t\tbegin\n\t\t\t\tr_pipe_stalled <= 1'b0;\n\t\t\t\tr_pipe_code  <= 4'h1;\n\t\t\tend\n\t\t\tif (r_svalid)\n\t\t\tbegin\n\t\t\t\tr_pipe_stalled <= 1'b0;\n\t\t\t\tr_pipe_code  <= 4'h2;\n\t\t\tend\n\t\t\tif (last_ack && (M_AXI_BVALID\n\t\t\t\t||(OPT_WRAP && state == DC_IDLE && !r_rd_pending)\n\t\t\t\t||(state  == DC_READS && M_AXI_RVALID\n\t\t\t\t\t\t\t\t&& last_ack)\n\t\t\t\t||(!OPT_WRAP && !r_rd_pending\n\t\t\t\t\t&& M_AXI_RVALID && M_AXI_RLAST)))\n\t\t\tbegin\n\t\t\t\tr_pipe_stalled <= 1'b0;\n\t\t\t\tr_pipe_code <= 4'h3;\n\t\t\tend\n\n\t\t\t// If we have to start flushing, then we have to stall\n\t\t\t// while flushing\n\n\t\t\tif (i_cpu_reset\n\t\t\t|| (M_AXI_RVALID && M_AXI_RRESP[1])\n\t\t\t|| (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t|| (i_pipe_stb && misaligned))\n\t\t\tbegin\n\t\t\t// {{{\n\t\t\tr_pipe_stalled <= 1'b0;\n\t\t\tr_pipe_code <= 4'ha;\n\n\t\t\t// Always stall if we have to start flushing\n\t\t\tif (M_AXI_ARVALID || M_AXI_AWVALID || M_AXI_WVALID)\n\t\t\tbegin\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\t\tr_pipe_code <= 4'h4;\n\t\t\tend\n\t\t\tif (!last_ack)\n\t\t\tbegin\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\t\tr_pipe_code <= 4'h5;\n\t\t\tend\n\t\t\tif ((noutstanding >= 1) && !M_AXI_BVALID\n\t\t\t\t\t\t&& (!M_AXI_RVALID || !M_AXI_RLAST))\n\t\t\tbegin\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\t\tr_pipe_code <= 4'h6;\n\t\t\tend\n\t\t\t// }}}\n\t\t\tend\n\n\t\t\t// All cachable read requests will stall our pipeline\n\t\t\tif (!i_cpu_reset && i_pipe_stb && i_read && !misaligned)\n\t\t\tbegin\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\t\tr_pipe_code <= 4'h7;\n\t\t\tend\n\t\t\tif (!i_cpu_reset && i_pipe_stb && i_lock && !misaligned)\n\t\t\tbegin\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\t\tr_pipe_code <= 4'h8;\n\t\t\tend\n\n\t\t\tif (flushing && (M_AXI_AWVALID || M_AXI_ARVALID || M_AXI_WVALID))\n\t\t\tbegin\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\t\tr_pipe_code <= 4'h9;\n\t\t\tend\n\t\tend\n\n\t\talways @(*)\n\t\tif (r_pipe_stalled)\n\t\t\tpipe_stalled = 1'b1;\n\t\telse if (M_AXI_AWVALID && !M_AXI_AWREADY)\n\t\t\tpipe_stalled = 1'b1;\n\t\telse if (M_AXI_WVALID && !M_AXI_WREADY)\n\t\t\tpipe_stalled = 1'b1;\n\t\telse if (full_pipe)\n\t\t\tpipe_stalled = 1'b1;\n\t\telse\n\t\t\tpipe_stalled = 1'b0;\n\n\t\tassign\tw_pipe_stalled = r_pipe_stalled;\n\t\tassign\to_pipe_stalled = pipe_stalled;\n\n\t\t// Verilator lint_off UNUSED",
            "wire unused_pipe;\n\t\tassign\tunused_pipe = &{ 1'b0, r_pipe_code };\n\t\t// Verilator lint_on  UNUSED\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && locked_write_in_progress)\n\t\tbegin\n\t\t\tassert(r_pipe_stalled);\n\t\tend\n`endif\n\tend else begin : PIPE_STALL_ON_BUSY\n\t\tassign\tw_pipe_stalled = 1'b0;\n\t\tassign\to_pipe_stalled = o_busy;\n\n\t\t// Verilator lint_off UNUSED",
            "wire unused_pipe;\n\t\tassign\tunused_pipe = &{ 1'b0, full_pipe };\n\t\t// Verilator lint_on  UNUSED\n\tend endgenerate\n\t// }}}\n\n\t// o_w",
            "reg // {{{\n\t// generate if (!OPT_PIPE)\n\talways @(posedge S_AXI_ACLK)\n\tif (i_pipe_stb)\n\tbegin\n\t\to_w",
            "reg <= i_o",
            "reg ;\n\t\tif (OPT_LOCK && i_lock && i_op[0])\n\t\t\to_w",
            "reg <= { i_o",
            "reg [4], 4'hf };\n\tend\n`ifdef\tFORMAL\n\talways @(*)\n\tif (S_AXI_ARESETN && locked_write_in_progress)\n\t\tassert(o_w",
            "reg [3:0] == 4'hf);\n`endif\n\t// }}}\n\n\t// restart_pc\n\t// {{{\n\tgenerate if (OPT_LOCK)\n\tbegin : GEN_RESTART_PC",
            "reg [AW-1:0]\tr_pc;\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (i_pipe_stb && i_lock && i_op[0])\n\t\t\tr_pc <= i_restart_pc;\n\n\t\tassign\trestart_pc = r_pc;\n\n\tend else begin : NO_RESTART_PC\n\t\tassign\trestart_pc = 0;\n\n\t\t// Verilator lint_off UNUSED",
            "wire unused_restart_pc;\n\t\tassign\tunused_restart_pc = &{ 1'b0, i_restart_pc };\n\t\t// Verilator lint_on  UNUSED\n\tend endgenerate\n\t// }}}\n\n\t// req_data\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (i_pipe_stb)\n\t\treq_data <= { i_op[2:1], rev_addr[AXILSB-1:0] };\n\n\tassign\treq_lsb = req_data[AXILSB-1:0];\n\tassign\treq_op  = req_data[AXILSB +: 2];\n\t// }}}\n\n\t// o_err\n\t// {{{\n\tinitial\to_err = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\to_err <= 1'b0;\n\telse if (i_cpu_reset || flushing)\n\t\to_err <= 1'b0;\n\telse begin\n\t\to_err <= 1'b0;\n\t\tif (M_AXI_RVALID && M_AXI_RRESP[1] && o_rdbusy && !r_dvalid)\n\t\t\to_err <= 1'b1;\n\t\tif (M_AXI_RVALID && locked_read_in_progress\n\t\t\t\t\t\t&& M_AXI_RRESP != EXOKAY)\n\t\t\to_err <= 1'b1;\n\t\tif (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\to_err <= 1'b1;\n\t\tif (i_pipe_stb && misaligned)\n\t\t\to_err <= 1'b1;\n\tend\n\t// }}}\n\n\t// Read from the cache\n\t// {{{\n\tgenerate if (OPT_DUAL_READ_PORT)\n\tbegin : GEN_DUALREAD\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!OPT_LOWPOWER || (i_pipe_stb && !i_op[0]))\n\t\t\tcached_iword <= cache_mem[i_caddr];\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!OPT_LOWPOWER || o_rdbusy)\n\t\t\tcached_rword <= cache_mem[r_caddr];\n\tend else begin : GEN_SINGLE_READ_PORT\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\t\tcached_rword <= cache_mem[(o_busy) ? r_caddr : i_caddr];\n\n\t\talways @(*)\n\t\t\tcached_iword = cached_rword;\n\tend endgenerate\n\t// }}}\n\n\t// o_data, pre_data\n\t// {{{\n\talways @(*)\n\tif (r_svalid)\n\t\tpre_data = cached_iword;\n\telse if (state == DC_READS || (OPT_WRAP && state == DC_READC))\n\t\tpre_data = axi_rdata;\n\telse\n\t\tpre_data = cached_rword;\n\n\talways @(*)\n\tif (SWAP_WSTRB)\n\tbegin\n\t\tshifted_data = pre_data << (8*req_lsb);\n\n\t\tcasez(req_op)\n\t\t2'b10: shifted_data[31:0] = { 16'h0, shifted_data[DW-1:DW-16] };\n\t\t2'b11: shifted_data[31:0] = { 24'h0, shifted_data[DW-1:DW- 8] };\n\t\tdefault: shifted_data[31:0] = shifted_data[DW-1:DW-32];\n\t\tendcase\n\tend else\n\t\tshifted_data = pre_data >> (8*req_lsb);\n\n\t// o_data\n\talways @(posedge S_AXI_ACLK)\n\tbegin\n\t\to_data <= shifted_data[31:0];\n\t\tif (OPT_SIGN_EXTEND)\n\t\tbegin\n\t\t\t// verilator coverage_off\n\t\t\t// Unused, would violate ZipCPU ISA\n\t\t\tcasez(req_op)\n\t\t\t2'b10: o_data[31:16] <= {(16){shifted_data[15]}};\n\t\t\t2'b11: o_data[31: 8] <= {(24){shifted_data[ 7]}};\n\t\t\tdefault: begin end\n\t\t\tendcase\n\t\t\t// verilator coverage_on\n\t\tend else begin\n\t\t\tcasez(req_op)\n\t\t\t2'b10: o_data[31:16] <= 0;\n\t\t\t2'b11: o_data[31: 8] <= 0;\n\t\t\tdefault: begin end\n\t\t\tendcase\n\t\tend\n\n\t\tif (locked_write_in_progress)\n\t\tbegin\n\t\t\to_data <= 0;\n\t\t\to_data[AW-1:0] <= restart_pc;\n\t\tend\n\tend\n\t// }}}\n\n\t// o_valid\n\t// {{{\n\tinitial\to_valid = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_cpu_reset || flushing)\n\t\to_valid <= 1'b0;\n\telse if (state == DC_READS)\n\tbegin\n\t\to_valid <= M_AXI_RVALID && !M_AXI_RRESP[1];\n\t\tif (OPT_LOCK && locked_read_in_progress && M_AXI_RRESP != EXOKAY)\n\t\t\to_valid <= 0;\n\tend else if (locked_write_in_progress && M_AXI_BVALID\n\t\t\t\t\t\t&& M_AXI_BRESP == OKAY)\n\t\to_valid <= 1'b1;\n\telse if (OPT_WRAP && r_rd_pending && state == DC_READC)\n\t\to_valid <= M_AXI_RVALID  && !M_AXI_RRESP[1];\n\telse\n\t\to_valid <= r_svalid || r_dvalid;\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, M_AXI_BID, M_AXI_RID, r_addr, M_AXI_RRESP[0],\n\t\t\t\tM_AXI_BRESP[0], i_lock, shifted_data,\n\t\t\t\tw_pipe_stalled, axi_tag, axi_line,\n\t\t\t\trev_addr[C_AXI_ADDR_WIDTH-1:AXILSB] };\n\t// Verilator lint_on UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Declarations\n\t// {{{",
            "localparam F_LGDEPTH = 10;",
            "wire [F_LGDEPTH-1:0]\tfaxi_awr_nbursts,\n\t\t\t\tfaxi_rd_nbursts, faxi_rd_outstanding;",
            "wire [8:0]\t\tfaxi_wr_pending;",
            "wire [IW-1:0]\tfaxi_wr_checkid;",
            "wire faxi_wr_ckvalid;",
            "wire [F_LGDEPTH-1:0]\tfaxi_wrid_nbursts;",
            "wire [AW-1:0]\tfaxi_wr_addr;",
            "wire [7:0]\t\tfaxi_wr_incr;",
            "wire [1:0]\t\tfaxi_wr_burst;",
            "wire [2:0]\t\tfaxi_wr_size;",
            "wire [7:0]\t\tfaxi_wr_len;",
            "wire faxi_wr_lockd;\n\t//",
            "wire faxi_rd_checkid;",
            "wire faxi_rd_ckvalid;",
            "wire [8:0]\t\tfaxi_rd_cklen;",
            "wire [AW-1:0]\tfaxi_rd_ckaddr;",
            "reg [AW-1:0]\tfaxi_rd_lastaddr;",
            "wire [7:0]\t\tfaxi_rd_ckincr;",
            "wire [1:0]\t\tfaxi_rd_ckburst;",
            "wire [2:0]\t\tfaxi_rd_cksize;",
            "wire [7:0]\t\tfaxi_rd_ckarlen;",
            "wire faxi_rd_cklockd;\n\t//",
            "wire [F_LGDEPTH-1:0]\tfaxi_rdid_nbursts;",
            "wire [F_LGDEPTH-1:0]\tfaxi_rdid_outstanding;",
            "wire [F_LGDEPTH-1:0]\tfaxi_rdid_ckign_nbursts;",
            "wire [F_LGDEPTH-1:0]\tfaxi_rdid_ckign_outstanding;\n\n\t// Verilator lint_off UNDRIVEN\n\t// Verilator lint_off UNUSED",
            "wire [1:0]\t\tfaxi_ex_state;",
            "wire faxi_ex_checklock;",
            "wire [F_LGDEPTH-1:0]\tfaxi_rdid_bursts_to_lock;",
            "wire [F_LGDEPTH-1:0]\tfaxi_wrid_bursts_to_exwrite;",
            "wire faxi_active_lock;",
            "wire [AW-1:0]\tfaxi_exreq_addr;",
            "wire [7:0]\t\tfaxi_exlock_len,   faxi_exreq_len;",
            "wire [1:0]\t\tfaxi_exlock_burst, faxi_exreq_burst;",
            "wire [2:0]\t\tfaxi_exreq_size;",
            "reg [AW-1:0]\tfaxi_exlock_addr;",
            "reg [2:0]\t\tfaxi_exlock_size;",
            "wire faxi_exreq_return;\n\t// Verilator lint_on  UNUSED\n\t// Verilator lint_on  UNDRIVEN",
            "wire [LGPIPE:0]\tcpu_outstanding;",
            "wire cpu_pc;",
            "wire cpu_gie;",
            "wire cpu_read_cycle, cpu_lockd_write_cycle;",
            "wire [4:0]\t\tcpu_last_",
            "reg ;",
            "wire [4:0]\t\tcpu_addr_",
            "reg ;",
            "reg f_done;",
            "reg f_was_locked_write;\n\t// Verilator lint_off UNDRIVEN\n\t(* anyseq *)",
            "reg [4:0]\tf_a",
            "reg ;\n\t// Verilator lint_on  UNDRIVEN",
            "wire [1:0]\t\treq_size;\n\n\tassign\treq_size = req_data[AXILSB +: 2];\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tfaxi_master #(\n\t\t// {{{\n\t\t.C_AXI_ID_WIDTH(IW),\n\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t.C_AXI_DATA_WIDTH(DW),\n\t\t.OPT_EXCLUSIVE(OPT_LOCK),\n\t\t.F_LGDEPTH(F_LGDEPTH)\n\t\t// }}}\n\t) faxi (\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN),\n\t\t// AW*\n\t\t// {{{\n\t\t.i_axi_awvalid(M_AXI_AWVALID),\n\t\t.i_axi_awready(M_AXI_AWREADY),\n\t\t.i_axi_awid(M_AXI_AWID),\n\t\t.i_axi_awaddr(M_AXI_AWADDR),\n\t\t.i_axi_awlen(M_AXI_AWLEN),\n\t\t.i_axi_awsize(M_AXI_AWSIZE),\n\t\t.i_axi_awburst(M_AXI_AWBURST),\n\t\t.i_axi_awlock(M_AXI_AWLOCK),\n\t\t.i_axi_awcache(M_AXI_AWCACHE),\n\t\t.i_axi_awprot(M_AXI_AWPROT),\n\t\t.i_axi_awqos(M_AXI_AWQOS),\n\t\t// }}}\n\t\t// W*\n\t\t// {{{\n\t\t.i_axi_wvalid(M_AXI_WVALID),\n\t\t.i_axi_wready(M_AXI_WREADY),\n\t\t.i_axi_wdata(M_AXI_WDATA),\n\t\t.i_axi_wstrb(M_AXI_WSTRB),\n\t\t.i_axi_wlast(M_AXI_WLAST),\n\t\t// }}}\n\t\t// B*\n\t\t// {{{\n\t\t.i_axi_bvalid(M_AXI_BVALID),\n\t\t.i_axi_bready(M_AXI_BREADY),\n\t\t.i_axi_bid(M_AXI_RID),\n\t\t.i_axi_bresp(M_AXI_BRESP),\n\t\t// }}}\n\t\t// AR*\n\t\t// {{{\n\t\t.i_axi_arvalid(\tM_AXI_ARVALID),\n\t\t.i_axi_arready(\tM_AXI_ARREADY),\n\t\t.i_axi_arid(\tM_AXI_ARID),\n\t\t.i_axi_araddr(\tM_AXI_ARADDR),\n\t\t.i_axi_arlen(\tM_AXI_ARLEN),\n\t\t.i_axi_arsize(\tM_AXI_ARSIZE),\n\t\t.i_axi_arburst(\tM_AXI_ARBURST),\n\t\t.i_axi_arlock(\tM_AXI_ARLOCK),\n\t\t.i_axi_arcache(\tM_AXI_ARCACHE),\n\t\t.i_axi_arprot(\tM_AXI_ARPROT),\n\t\t.i_axi_arqos(\tM_AXI_ARQOS),\n\t\t// }}}\n\t\t// R*\n\t\t// {{{\n\t\t.i_axi_rvalid(\tM_AXI_RVALID),\n\t\t.i_axi_rready(\tM_AXI_RREADY),\n\t\t.i_axi_rid(\tM_AXI_RID),\n\t\t.i_axi_rdata(\tM_AXI_RDATA),\n\t\t.i_axi_rlast(\tM_AXI_RLAST),\n\t\t.i_axi_rresp(\tM_AXI_RRESP),\n\t\t// }}}\n\t\t// Induction\n\t\t// {{{\n\t\t.f_axi_awr_nbursts(faxi_awr_nbursts),\n\t\t.f_axi_wr_pending(faxi_wr_pending),\n\t\t.f_axi_rd_nbursts(faxi_rd_nbursts),\n\t\t.f_axi_rd_outstanding(faxi_rd_outstanding),\n\t\t// Write checking\n\t\t// {{{\n\t\t.f_axi_wr_checkid(\tfaxi_wr_checkid),\n\t\t.f_axi_wr_ckvalid(\tfaxi_wr_ckvalid),\n\t\t.f_axi_wrid_nbursts(\tfaxi_wrid_nbursts),\n\t\t.f_axi_wr_addr(\t\tfaxi_wr_addr),\n\t\t.f_axi_wr_incr(\t\tfaxi_wr_incr),\n\t\t.f_axi_wr_burst(\tfaxi_wr_burst),\n\t\t.f_axi_wr_size(\t\tfaxi_wr_size),\n\t\t.f_axi_wr_len(\t\tfaxi_wr_len),\n\t\t.f_axi_wr_lockd(\tfaxi_wr_lockd),\n\t\t// }}}\n\t\t// Read checking\n\t\t// {{{\n\t\t.f_axi_rd_checkid(\tfaxi_rd_checkid),\n\t\t.f_axi_rd_ckvalid(\tfaxi_rd_ckvalid),\n\t\t.f_axi_rd_cklen(\tfaxi_rd_cklen),\n\t\t.f_axi_rd_ckaddr(\tfaxi_rd_ckaddr),\n\t\t.f_axi_rd_ckincr(\tfaxi_rd_ckincr),\n\t\t.f_axi_rd_ckburst(\tfaxi_rd_ckburst),\n\t\t.f_axi_rd_cksize(\tfaxi_rd_cksize),\n\t\t.f_axi_rd_ckarlen(\tfaxi_rd_ckarlen),\n\t\t.f_axi_rd_cklockd(\tfaxi_rd_cklockd),\n\t\t//\n\t\t.f_axi_rdid_nbursts(\t\tfaxi_rdid_nbursts),\n\t\t.f_axi_rdid_outstanding(\tfaxi_rdid_outstanding),\n\t\t.f_axi_rdid_ckign_nbursts(\tfaxi_rdid_ckign_nbursts),\n\t\t.f_axi_rdid_ckign_outstanding(\tfaxi_rdid_ckign_outstanding),\n\t\t// }}}\n\t\t// Exclusive access checking\n\t\t// {{{\n\t\t.f_axi_ex_state(faxi_ex_state),\n\t\t.f_axi_ex_checklock(faxi_ex_checklock),\n\t\t.f_axi_rdid_bursts_to_lock(faxi_rdid_bursts_to_lock),\n\t\t.f_axi_wrid_bursts_to_exwrite(faxi_wrid_bursts_to_exwrite),\n\t\t.i_active_lock( faxi_active_lock),\n\t\t.i_exlock_addr( faxi_exlock_addr),\n\t\t.i_exlock_len(  faxi_exlock_len),\n\t\t.i_exlock_burst(faxi_exlock_burst),\n\t\t.i_exlock_size( faxi_exlock_size),\n\t\t.f_axi_exreq_addr(faxi_exreq_addr),\n\t\t.f_axi_exreq_len(faxi_exreq_len),\n\t\t.f_axi_exreq_burst(faxi_exreq_burst),\n\t\t.f_axi_exreq_size(faxi_exreq_size),\n\t\t.f_axi_exreq_return(faxi_exreq_return)\n\t\t// }}}\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// ID checking\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tassume(faxi_rd_checkid == AXI_ID);\n\t\tassert(faxi_rdid_nbursts == faxi_rd_nbursts);\n\t\tassert(faxi_rdid_outstanding == faxi_rd_outstanding);\n\n\t\tassume(faxi_wr_checkid == AXI_ID);\n\t\tassert(faxi_wrid_nbursts == faxi_awr_nbursts);\n\tend\n\t// }}}\n\n\t// Never both reads and writes outstanding\n\t// {{{\n\talways @(*)\n\tif (faxi_rd_outstanding > 0)\n\tbegin\n\t\tassert(!M_AXI_AWVALID);\n\t\tassert(!M_AXI_WVALID);\n\t\tassert(faxi_awr_nbursts == 0);\n\t\tassert(o_busy);\n\t\tif (r_rd_pending)\n\t\tbegin\n\t\t\tassert(o_rdbusy);\n\t\tend\n\t\tif (flushing)\n\t\t\tassert(!o_rdbusy);\n\t\tassert(!locked_write_in_progress);\n\tend else if (faxi_awr_nbursts > 0)\n\tbegin\n\t\tassert(!locked_read_in_progress);\n\t\tassert(o_busy);\n\t\tif (locked_write_in_progress)\n\t\tbegin\n\t\t\tassert(o_rdbusy);\n\t\tend else\n\t\t\tassert(!o_rdbusy);\t// || OPT_LOCK && LOCKD WRITE\n\t\tassert(!M_AXI_ARVALID);\n\t\t// assert(f_wr_pending == (M_AXI_WVALID ? 1:0));\n\tend\n\t// }}}\n\n\t// Read count checking\n\t// {{{\n\talways @(*)\n\tif (S_AXI_ARESETN)\n\tbegin\n\t\tif (state == DC_READC)\n\t\tbegin\n\t\t\tassert(faxi_rd_nbursts == (M_AXI_ARVALID ? 0:1));\n\t\tend else if (state == DC_READS)\n\t\tbegin\n\t\t\tassert(faxi_rd_nbursts == faxi_rd_outstanding);\n\t\t\tif (!OPT_PIPE)\n\t\t\t\tassert(faxi_rd_nbursts == (M_AXI_ARVALID ? 0:1));\n\t\tend else\n\t\t\tassert(faxi_rd_nbursts == 0);\n\tend\n\t// }}}\n\n\t// Write packet checking\n\t// {{{\n\talways @(*)\n\tif (faxi_wr_ckvalid)\n\tbegin\n\t\tassert(faxi_wr_burst == M_AXI_AWBURST);\n\t\tassert(faxi_wr_len == 8'h00);\n\t\tassert(faxi_wr_lockd == locked_write_in_progress);\n\t\t//\n\t\tif (SWAP_WSTRB)\n\t\t\tassert(faxi_wr_size == 3'd2);\n\t\telse casez(f_op[AXILSB+1:AXILSB])\n\t\t2'b0?: assert(faxi_wr_size == 3'd2);\n\t\t2'b10: assert(faxi_wr_size == 3'd1);\n\t\t2'b11: assert(faxi_wr_size == 3'd0);\n\t\tendcase\n\tend\n\t// }}}\n\n\t// CPU matching -- write cycle\n\t// {{{\n\talways @(*)\n\tif (!cpu_read_cycle)\n\tbegin\n\t\tif (OPT_WRAP && state == DC_READC)\n\t\tbegin\n\t\t\tassert(!r_rd_pending);\n\t\t\tassert(faxi_rd_nbursts == (M_AXI_ARVALID ? 0:1));\n\t\t\tassert(faxi_awr_nbursts == 0);\n\t\tend else begin\n\t\t\tassert(flushing || (faxi_rd_nbursts == 0));\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tassert(flushing || o_err\n\t\t\t\t|| (cpu_outstanding == faxi_awr_nbursts\n\t\t\t\t\t+ ((OPT_LOCK && f_was_locked_write\n\t\t\t\t\t\t&& !locked_write_in_progress) ? 1:0)\n\t\t\t\t\t+ (M_AXI_AWVALID ? 1:0)));\n\t\t\t// Verilator lint_on  WIDTH\n\t\tend\n\tend else // if (!flushing)\n\t\tassert(faxi_awr_nbursts == 0);\n\t// }}}\n\n\t// Read request checking\n\t// {{{\n\talways @(*)\n\tif (!S_AXI_ARESETN)\n\tbegin end\n\telse if (state == DC_IDLE || state == DC_WRITE)\n\tbegin\n\t\tassert(!M_AXI_ARVALID);\n\t\tassert(flushing || faxi_rd_outstanding == 0);\n\tend else if (M_AXI_ARVALID && !flushing)\n\tbegin\n\t\tassert(faxi_rd_outstanding == 0);\n\t\tif (state == DC_READC)\n\t\tbegin\n\t\t\tassert(M_AXI_ARBURST == (OPT_WRAP) ? WRAP : INCR);\n\t\t\tassert(!M_AXI_ARLOCK);\n\t\t\tassert(M_AXI_ARLEN == (1 << LS) - 1);\n\t\t\tif (!OPT_LOWPOWER || M_AXI_ARVALID)\n\t\t\tbegin\n\t\t\t\tassert(M_AXI_ARADDR[AW-1:CS+AXILSB] == r_ctag);\n\t\t\t\tassert(axi_tag == r_ctag);\n\t\t\t\tassert(M_AXI_ARADDR[CS+AXILSB-1:LS+AXILSB] == r_cline);\n\t\t\t\tassert(axi_line == r_cline);\n\t\t\tend\n\t\t\tassert(M_AXI_ARADDR[AXILSB-1:0] == 0);\n\t\t\tif (!OPT_WRAP)\n\t\t\tbegin\n\t\t\t\tassert(read_addr[LS-1:0] == 0);\n\t\t\tend\n\t\t\tassert((OPT_LOWPOWER && !M_AXI_ARVALID)\n\t\t\t\t|| M_AXI_ARADDR[AXILSB +: CS] == read_addr);\n\t\tend else begin\n\t\t\tassert(state == DC_READS);\n\t\t\tassert(M_AXI_ARBURST == INCR);\n\t\t\tassert(M_AXI_ARLEN   == 0);\n\t\t\tassert(M_AXI_ARLOCK == locked_read_in_progress);\n\t\t\tif (locked_read_in_progress || OPT_WRAP)\n\t\t\t\tassert((OPT_LOWPOWER && !M_AXI_ARVALID)\n\t\t\t\t\t||M_AXI_ARADDR[AXILSB +: CS] == read_addr);\n\t\tend\n\tend\n\t// }}}\n\n\t// Read packet checking\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tfaxi_rd_lastaddr = faxi_rd_ckaddr;\n\t\t// Verilator lint_off WIDTH\n\t\tfaxi_rd_lastaddr = faxi_rd_ckaddr\n\t\t\t\t+ ((faxi_rd_cklen - 1) << faxi_rd_cksize);\n\t\t// Verilator lint_on  WIDTH\n\tend\n\n\talways @(*)\n\tif (faxi_rd_ckvalid)\n\tbegin\n\t\t// .f_axi_rd_cklen(\tfaxi_rd_cklen),\n\t\t// .f_axi_rd_ckaddr(\tfaxi_rd_ckaddr),\n\t\tif (state == DC_READC)\n\t\tbegin\n\t\t\t// Read to cache\n\t\t\tassert(faxi_rd_ckarlen == (1 << LS) - 1);\n\t\t\tassert(faxi_rd_nbursts == 1);\n\t\t\tassert(faxi_rd_cksize  == AXILSB[2:0]);\n\t\t\tif (!OPT_WRAP)\n\t\t\tbegin\n\t\t\t\tassert(faxi_rd_lastaddr[AXILSB-1:0] == 0);\n\t\t\t\tassert(&faxi_rd_lastaddr[AXILSB +: LS]);\n\t\t\tend\n\t\t\tassert(last_ack == (axi_arvalid ? 0:1));\n\t\t\tassert(r_ctag == faxi_rd_ckaddr[AW-1:CS+AXILSB]);\n\t\t\tassert(!faxi_rd_cklockd);\n\t\t\tassert(faxi_rd_ckburst == (OPT_WRAP) ? WRAP : INCR);\n\t\t\t// Need to verify wcache_addr\n\t\tend else begin\n\t\t\t// Single, uncachable reads\n\t\t\t// assert(!w_v || wcache_tag != r_ctag);\n\t\t\tassert(faxi_rd_ckarlen == 0);\n\t\t\tassert(locked_read_in_progress == faxi_rd_cklockd);\n\t\t\tassert(faxi_rd_ckburst == INCR);\n\t\t\tif (SWAP_WSTRB)\n\t\t\tbegin\n\t\t\t\tassert(faxi_rd_cksize == 3'b010);\n\t\t\tend else case(req_size)\n\t\t\t2'b10: assert(faxi_rd_cksize  == 3'd1);\n\t\t\t2'b11: assert(faxi_rd_cksize  == 3'd0);\n\t\t\tdefault: assert(faxi_rd_cksize  == 3'd2);\n\t\t\tendcase\n\t\tend\n\tend\n\t// }}}\n\n\talways @(*)\n\tif (S_AXI_ARESETN && (state != DC_WRITE || !OPT_LOCK))\n\t\tassert(!locked_write_in_progress);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// CPU/memory interface\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tfmem #(\n\t\t// {{{\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_AXI_LOCK(OPT_LOCK),\n\t\t.F_LGDEPTH(LGPIPE+1),\n\t\t.OPT_MAXDEPTH((OPT_PIPE) ? ((1<<LGPIPE)-1) : 1)\n\t\t// }}}\n\t) fmemp (\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_sys_reset(!S_AXI_ARESETN),\n\t\t\t.i_cpu_reset(i_cpu_reset),\n\t\t.i_stb(i_pipe_stb),\n\t\t\t.i_pipe_stalled(o_pipe_stalled),\n\t\t.i_clear_cache(i_clear),\n\t\t\t.i_lock(i_lock),\n\t\t.i_op(i_op),\n\t\t\t.i_addr(i_addr),\n\t\t\t.i_data(i_data),\n\t\t\t.i_o",
            "reg (i_o",
            "reg ),\n\t\t\t.i_a",
            "reg (f_a",
            "reg ),\n\t\t//\n\t\t\t.i_busy(o_busy),\n\t\t\t.i_rdbusy(o_rdbusy),\n\t\t.i_valid(o_valid),\n\t\t\t.i_done(f_done),\n\t\t\t.i_err(o_err),\n\t\t\t.i_w",
            "reg (o_w",
            "reg ),\n\t\t\t.i_result(o_data),\n\t\t//\n\t\t.f_outstanding(cpu_outstanding),\n\t\t.f_pc(cpu_pc),\n\t\t.f_gie(cpu_gie),\n\t\t.f_read_cycle(cpu_read_cycle),\n\t\t.f_axi_write_cycle(cpu_lockd_write_cycle),\n\t\t.f_last_",
            "reg (cpu_last_",
            "reg ),\n\t\t.f_addr_",
            "reg (cpu_addr_",
            "reg )\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (o_rdbusy)\n\t\tassert(cpu_outstanding <= 1);\n\n\talways @(*)\n\tif (o_rdbusy && (cpu_outstanding == 1 + ((f_done || o_err) ? 1:0))\n\t\t\t&& (r_rd_pending))\n\t\tassert(o_pipe_stalled);\n\n\tinitial\tf_was_locked_write = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || !OPT_LOCK)\n\t\tf_was_locked_write <= 1'b0;\n\telse\n\t\tf_was_locked_write <= locked_write_in_progress;\n\n\talways @(*)\n\tbegin\n\t\tf_done = 0;\n\t\tif (M_AXI_BVALID && !flushing && !M_AXI_BRESP[1]\n\t\t\t\t&& (!OPT_LOCK || !locked_write_in_progress))\n\t\t\tf_done = 1'b1;\n\t\tif (OPT_LOCK && f_was_locked_write && !locked_write_in_progress)\n\t\t\tf_done = 1'b1;\n\t\tif (cpu_read_cycle && (o_valid || o_err))\n\t\t\tf_done = 1'b1;\n\n\t\tif (flushing)\n\t\t\tassert(!o_rdbusy);\n\tend\n\n\talways @(*)\n\tif (!OPT_LOCK)\n\t\tassert(!cpu_lockd_write_cycle);\n\n\talways @(*)\n\tif (o_rdbusy)\n\t\tassert(cpu_gie == o_w",
            "reg [4]);\n\n\talways @(*)\n\tif (o_rdbusy && !locked_write_in_progress)\n\tbegin\n\t\tassert(cpu_gie == o_w",
            "reg [4]);\n\t\tif (locked_write_in_progress)\n\t\tbegin\n\t\t\tassert(o_w",
            "reg [3:0] == 4'hf);\n\t\tend else\n\t\t\tassert(cpu_last_",
            "reg == o_w",
            "reg );\n\tend\n\n\talways @(*)\n\tif (S_AXI_ARESETN\n\t\t&& (locked_write_in_progress || locked_read_in_progress))\n\tbegin\n\t\tassert(OPT_LOCK);\n\t\tassert(o_pipe_stalled);\n\tend\n\n\talways @(*)\n\tif (S_AXI_ARESETN && OPT_PIPE\n\t\t&& (locked_write_in_progress || locked_read_in_progress))\n\tbegin\n\t\tassert(w_pipe_stalled);\n\tend\n\n\talways @(*)\n\tif (OPT_PIPE && state == DC_READC)\n\t\tassert(w_pipe_stalled);\n\n\talways @(*)\n\tif (OPT_PIPE && flushing)\n\t\tassert(w_pipe_stalled);\n\n\talways @(posedge S_AXI_ACLK)\n\tif (S_AXI_ARESETN && OPT_PIPE && $past(S_AXI_ARESETN))\n\tbegin\n\t\tif ($past(!i_cpu_reset && i_pipe_stb && i_read && !misaligned))\n\t\t\tassert(w_pipe_stalled);\n\t\telse if (M_AXI_ARVALID)\n\t\t\tassert(o_pipe_stalled);\n\t\telse if ((faxi_rd_nbursts == 0) && (faxi_awr_nbursts == 0)\n\t\t\t\t&& !r_rd_pending && !r_svalid && !r_dvalid\n\t\t\t\t&& (!M_AXI_AWVALID && !M_AXI_WVALID))\n\t\tbegin\n\t\t\tif ($past(state) != DC_READC)\n\t\t\t\tassert(!w_pipe_stalled);\n\t\tend\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Induction properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// State checking\n\t// {{{\n\talways @(*)\n\tif (S_AXI_ARESETN)\n\tcase(state)\n\tDC_IDLE: begin\n\t\t// {{{\n\t\tassert(!flushing);\n\t\tassert(!M_AXI_AWVALID);\n\t\tassert(!M_AXI_WVALID);\n\t\tassert(!M_AXI_ARVALID);\n\t\tassert(faxi_rd_nbursts  == 0);\n\t\tassert(faxi_awr_nbursts == 0);\n\t\tassert(noutstanding == 0);\n\t\tassert(cpu_outstanding <= 1);\n\t\tif (r_rd_pending)\n\t\t\tassert(o_rdbusy);\n\t\tif (cpu_outstanding > 0)\n\t\tbegin\n\t\t\tif (r_svalid || r_dvalid || o_valid || o_err)\n\t\t\t\tassert(!r_rd_pending);\n\t\t\tif (!r_rd_pending)\n\t\t\t\tassert(f_done || o_err || r_svalid || r_dvalid);\n\t\t\t// else\n\t\t\t//\tassert(r_svalid || r_dvalid || o_valid || o_err);\n\t\t\t//\n\t\t\t// Older",
            "logic // if (r_svalid || r_dvalid || o_valid || o_err)\n\t\t\t//\tassert(!r_rd_pending);\n\t\t\t// if (!r_svalid && !r_dvalid && !o_err && !o_valid && !f_done)\n\t\t\t//\tassert(cpu_outstanding == (r_rd_pending ? 1:0));\n\t\tend else\n\t\t\tassert(!r_rd_pending);\n\t\t/*\n\t\tif (cpu_read_cycle && !o_err && o_busy)\n\t\tbegin\n\t\t\tassert(o_rdbusy || o_valid);\n\t\t\tassert(o_valid || r_rd_pending);\n\t\t// assert(!r_cache_miss);\n\t\tend\n\t\t*/\n\t\tend\n\t\t// }}}\n\tDC_WRITE: begin\n\t\t// {{{\n\t\tassert(!M_AXI_ARVALID);\n\t\tassert(noutstanding == faxi_awr_nbursts);\n\t\tif (!OPT_PIPE)\n\t\tbegin\n\t\t\tassert(faxi_awr_nbursts == (M_AXI_AWVALID ? 0:1));\n\t\t\tassert(noutstanding == (M_AXI_AWVALID ? 0:1));\n\t\tend else begin\n\t\t\tassert(faxi_awr_nbursts == noutstanding);\n\t\tend\n\t\tassert(o_rdbusy == locked_write_in_progress);\n\t\tassert(!cpu_read_cycle);\n\t\tassert(o_busy);\n\t\tassert(!r_rd_pending);\n\t\tassert(!r_cache_miss);\n\t\tassert(faxi_wr_pending\n\t\t\t== ((M_AXI_WVALID && !M_AXI_AWVALID) ? 1:0));\n\t\tif (flushing)\n\t\t\tassert(o_err || cpu_outstanding == 0);\n\t\tend\n\t\t// }}}\n\tDC_READC: begin\n\t\t// {{{\n\t\tassert(!M_AXI_AWVALID);\n\t\tassert(!M_AXI_WVALID);\n\t\tif (M_AXI_ARVALID)\n\t\t\tassert(M_AXI_ARLEN == (1 << LS) - 1);\n\t\t// assert(!M_AXI_ARVALID);\n\t\t// assert(faxi_rd_nbursts == 0);\n\t\tassert(noutstanding == (M_AXI_ARVALID ? 0:1));\n\t\tassert(faxi_awr_nbursts == 0);\n\t\tassert(flushing || (OPT_WRAP || o_rdbusy));\n\t\tassert(o_busy);\n\t\tassert(faxi_rd_nbursts == (M_AXI_ARVALID ? 0:1));\n\t\tassert(faxi_rd_outstanding <= (1<<LS));\n\t\tassert(OPT_WRAP || r_cache_miss || flushing);\n\t\tassert(OPT_WRAP || !r_dvalid);\n\t\tassert(!r_svalid);\n\t\tassert(good_cache_read || flushing);\n\t\tassert(wcache_addr[CS-1:LS] == r_cline);\n\t\tassert(read_addr[CS-1:LS] == r_cline);\n\t\tif (!OPT_WRAP)\n\t\t\tassert(r_rd_pending || flushing);\n\t\tif (flushing)\n\t\tbegin\n\t\t\tassert(!r_rd_pending);\n\t\t\tassert(cpu_outstanding == (o_err ? 1:0));\n\t\tend else\n\t\t\tassert(OPT_WRAP || r_rd_pending);\n\t\tend\n\t\t// }}}\n\tDC_READS: begin\n\t\t// {{{\n\t\tassert(!M_AXI_AWVALID);\n\t\tassert(!M_AXI_WVALID);\n\t\tassert(noutstanding == (M_AXI_ARVALID ? 0:1));\n\t\tassert(faxi_awr_nbursts == 0);\n\t\t// assert(!M_AXI_ARVALID);\n\t\tassert(faxi_rd_nbursts == faxi_rd_outstanding);\n\t\tassert(faxi_rd_nbursts == noutstanding);\n\t\tassert(flushing || o_rdbusy);\n\t\tassert(o_busy);\n\t\tassert(!r_rd_pending);\n\t\tassert(!r_cache_miss);\n\t\tif (flushing)\n\t\tbegin\n\t\t\tassert(!o_rdbusy);\n\t\t\tassert(cpu_outstanding == (o_err ? 1:0));\n\t\tend end\n\t\t// }}}\n\tendcase\n\t// }}}\n\n\t/*\n\n\t// Issues with the following:\n\t//   1. Can't handle errors\n\t//   2. Can't handle the wrong cache read ...\n\t//\n\t*/",
            "reg [3:0]\tf_read_state;\n\t(* anyconst *)",
            "reg f_never_err;\n\n\talways @(*)\n\tif (f_never_err)\n\tbegin\n\t\tassume(!M_AXI_RVALID || !M_AXI_RRESP[1]);\n\t\t// assume(!M_AXI_BVALID || !M_AXI_BRESP[1]);\n\tend\n\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN) // || !f_never_err)\n\t\tf_read_state <= 0;\n\telse if (i_cpu_reset)\n\t\tf_read_state <= 0;\n\telse case(f_read_state)\n\t4'h0: begin // Idle.  What operation do we start?\n\t\t// {{{\n\t\tassert(!r_rd_pending);\n\t\tassert(!set_vflag);\n\t\tif (!flushing)\n\t\tbegin\n\t\t\tassert(state == DC_IDLE || state == DC_WRITE);\n\t\t\tassert(faxi_rd_nbursts == 0);\n\t\t\tif (i_pipe_stb && i_read && !misaligned)\n\t\t\tbegin\n\t\t\t\tif (cachable_read_request)\n\t\t\t\t\tf_read_state <= 4'h1;\n\t\t\t\telse\n\t\t\t\t\tf_read_state <= 4'h6;\n\t\t\tend\n\t\tend end\n\t\t// }}}\n\t4'h1: begin // Cachable read request, checking if its in the cache\n\t\t// {{{\n\t\tassert(r_svalid ^ r_rd_pending);\n\t\tassert(state == DC_IDLE);\n\t\tassert(r_check);\n\t\tassert(!set_vflag);\n\t\tassert(o_rdbusy);\n\t\tassert(o_busy);\n\t\tif (r_svalid)\n\t\t\tf_read_state <= 4'h7;\n\t\telse\n\t\t\tf_read_state <= 4'h2;\n\t\tend\n\t\t// }}}\n\t4'h2: begin // Cachable read, checking in the cache step #2\n\t\t// {{{\n\t\tassert(!flushing);\n\t\tassert(r_cachable);\n\t\tassert(r_rd_pending ^ r_dvalid);\n\t\tassert(o_rdbusy);\n\t\tassert(!r_check);\n\t\tassert(state == DC_IDLE);\n\t\tassert(!set_vflag);\n\t\tassert(o_busy);\n\t\tif (r_dvalid)\n\t\t\tf_read_state <= 4'h7;\n\t\telse begin\n\t\t\tassert(!r_rv || r_rtag != r_ctag);\t// !!!\n\t\t\tf_read_state <= 4'h3;\n\t\tend end\n\t\t// }}}\n\t4'h3: begin // Cachable read, now starting the read operation\n\t\t// {{{\n\t\tassert(faxi_rd_nbursts == (M_AXI_ARVALID ? 0:1));\n\t\tassert(!flushing);\n\t\tassert(!r_svalid);\n\t\tassert(!r_dvalid);\n\t\tassert(!r_check);\n\t\tassert(!r_rv || r_rtag != r_ctag);\n\t\tassert(r_rd_pending);\n\t\tassert(r_cachable);\n\t\tassert(state == DC_READC);\n\t\tassert(good_cache_read);\n\t\tassert(!set_vflag);\n\t\tassert(o_busy);\n\t\tif (OPT_WRAP && M_AXI_RVALID)\n\t\t\tf_read_state <= M_AXI_RLAST ? 4'h9 : 4'h8;\n\t\tif (!OPT_WRAP && M_AXI_RVALID && M_AXI_RLAST)\n\t\t\tf_read_state <= 4'h4;\n\t\tif (M_AXI_RVALID && M_AXI_RRESP[1])\n\t\t\tf_read_state <= 4'h0;\n\t\tend\n\t\t// }}}\n\t4'h4: begin // Completed the cachable read operation into the cache\n\t\t// {{{\n\t\tassert(!OPT_WRAP);\n\t\tassert(!flushing);\n\t\tassert(!r_svalid);\n\t\tassert(r_cachable);\n\t\tassert(r_rd_pending);\n\t\tassert(r_rtag == r_ctag);\n\t\tassert(state == DC_IDLE);\n\t\tassert(set_vflag);\n\t\tassert(o_busy);\n\t\tf_read_state <= 4'h5;\n\n\t\t// r_dvalid <= !r_svalid && !r_dvalid\n\t\t//\t\t&& (w_tag == r_ctag) && w_v\n\n\t\tend\n\t\t// }}}\n\t4'h5: begin // Final step of the cachable read\n\t\t// {{{\n\t\tassert(!OPT_WRAP);\n\t\tassert(!flushing);\n\t\tassert(r_cachable);\n\t\tassert(r_rd_pending != r_dvalid);\n\t\t// assert(w_v && w_tag == r_ctag);\n\t\t// assert(r_dvalid == $stable(f_read_state));\n\t\tassert(state == DC_IDLE);\n\t\tassert(!set_vflag);\n\t\tif (r_dvalid)\n\t\t\tf_read_state <= 4'h7;\n\t\tend\n\t\t// }}}\n\t4'h6: begin // Read single state\n\t\t// {{{\n\t\tassert(!flushing);\n\t\tassert(faxi_rd_nbursts == (M_AXI_ARVALID ? 0:1));\n\t\tassert(faxi_rd_outstanding == (M_AXI_ARVALID ? 0:1));\n\t\tassert(!flushing);\n\t\tassert(state == DC_READS);\n\t\tif (M_AXI_RVALID)\n\t\t\tf_read_state <= 4'h7;\n\t\tend\n\t\t// }}}\n\t4'h7: begin\n\t\t// {{{\n\t\tassert(faxi_rd_outstanding == 0);\n\t\t// assert(r_rd_pending);\n\t\tassert(o_valid || o_err);\n\t\tf_read_state <= 4'h000;\n\t\tif (!flushing && i_pipe_stb && !i_op[0] && !misaligned)\n\t\tbegin\n\t\t\tif (address_is_cachable && (!OPT_LOCK || !i_lock))\n\t\t\t\tf_read_state <= 4'h1;\n\t\t\telse\n\t\t\t\tf_read_state <= 4'h6;\n\t\tend end\n\t\t// }}}\n\t4'h8: begin // WRAP Read\n\t\t// {{{\n\t\tassert(OPT_WRAP);\n\t\tassert(!flushing);\n\t\tassert(faxi_rd_nbursts == 1);\n\t\tassert(!r_rd_pending);\n\t\tassert(!set_vflag);\n\t\tassert(o_busy);\n\t\tif (M_AXI_RVALID && M_AXI_RLAST)\n\t\t\tf_read_state <= 4'h9;\n\t\tend\n\t\t// }}}\n\t4'h9: begin // Concluding WRAP read\n\t\t// {{{\n\t\tassert(OPT_WRAP);\n\t\tassert(faxi_rd_nbursts == 0);\n\t\tassert(!r_rd_pending);\n\t\tassert(!flushing);\n\t\tassert(state == DC_IDLE);\n\t\tassert(o_busy);\n\t\tif (!$past(i_clear))\n\t\t\tassert(set_vflag || !good_cache_read);\n\t\tf_read_state <= 4'h0;\n\t\tif (!flushing && i_pipe_stb && i_read && !misaligned)\n\t\tbegin\n\t\t\tif (address_is_cachable && (!OPT_LOCK || !i_lock))\n\t\t\t\tf_read_state <= 4'h1;\n\t\t\telse\n\t\t\t\tf_read_state <= 4'h6;\n\t\tend end\n\t\t// }}}\n\tdefault: assert(0);\n\tendcase\n\n\talways @(*)\n\tif (S_AXI_ARESETN && faxi_rd_outstanding > 0 && !flushing)\n\t\tassert(f_read_state != 0);\n\n\talways @(*)\n\tif (S_AXI_ARESETN && (state == DC_READS || state == DC_READC))\n\tbegin\n\t\tassert(flushing || (f_read_state != 0));\n\tend\n\n\t// DC_READC checks\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (state == DC_READC)\n\tbegin\n\t\tassert(read_addr[CS-1:LS] == r_cline);\n\t\tif (M_AXI_ARVALID)\n\t\tbegin\n\t\t\tassert(axi_araddr[AW-1:AXILSB+LS] == { r_ctag, r_cline });\n\t\t\tif (!OPT_WRAP)\n\t\t\tbegin\n\t\t\t\tassert(axi_araddr[AXILSB+LS-1:0] == 0);\n\t\t\tend\n\t\t\tassert(axi_araddr[AXILSB +: CS] == read_addr[CS-1:0]);\n\t\t\t// read_addr <= { i_addr[LGCACHELEN-1:AXILSB+LS], {(LS){1'b0}} };\n\t\t\tif (!OPT_WRAP)\n\t\t\t\tassert(read_addr[LS-1:0] == 0);\n\t\tend else if (faxi_rd_ckvalid)\n\t\tbegin\n\t\t\tassert(faxi_rd_ckaddr[AW-1:AXILSB+LS] == { r_ctag, r_cline });\n\t\t\tassert(faxi_rd_ckaddr[AXILSB-1:0] == 0);\n\t\t\tassert(faxi_rd_ckaddr[AXILSB +: CS] == read_addr[CS-1:0]);\n\t\tend\n\tend\n\t// }}}\n\n\t// last_tag_valid checking\n\t// {{{\n\talways @(*)\n\tif (last_tag_valid)\n\tbegin\n\t\tassert(cache_tag[last_tag_line] == last_tag);\n\t\tassert(cache_valid[last_tag_line]);\n\tend\n\t// }}}\n\n\talways @(*)\n\tif (!cpu_read_cycle && S_AXI_ARESETN && !flushing && !o_err)\n\tcase(state)\n\tDC_WRITE: begin\n\t\tif (locked_write_in_progress)\n\t\tbegin\n\t\t\tassert(cpu_outstanding == faxi_awr_nbursts\n\t\t\t\t+ ((o_valid || f_done) ? 1:0)\n\t\t\t\t+ (M_AXI_AWVALID ? 1:0));\n\t\tend else begin\n\t\t\tassert(cpu_outstanding == faxi_awr_nbursts\n\t\t\t\t+ (o_valid ? 1:0)\n\t\t\t\t+ (M_AXI_AWVALID ? 1:0));\n\t\tend end\n\tdefault:\n\t\tassert(cpu_outstanding == ((o_valid || o_err || f_done) ? 1:0));\n\tendcase\n\n\talways @(*)\n\tif (S_AXI_ARESETN && !flushing && (!f_done && !o_valid && !o_err))\n\t\tassert(cpu_lockd_write_cycle == locked_write_in_progress);\n\n\talways @(*)\n\tif (S_AXI_ARESETN && locked_write_in_progress)\n\tbegin\n\t\tassert(state == DC_WRITE);\n\t\tassert(faxi_awr_nbursts + (M_AXI_AWVALID ? 1:0) == 1);\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Lowpower checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_LOWPOWER)\n\tbegin : F_LOWPOWER\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !M_AXI_AWVALID)\n\t\tbegin\n\t\t\tassert(axi_awaddr == 0);\n\t\tend\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !M_AXI_WVALID)\n\t\tbegin\n\t\t\tassert(axi_wdata == 0);\n\t\t\tassert(axi_wstrb == 0);\n\t\tend\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !M_AXI_ARVALID)\n\t\tbegin\n\t\t\tassert(axi_araddr == 0);\n\t\t\tassert(axi_arlen == 0);\n\t\t\tassert(axi_arsize == 3'd2);\n\t\tend\n\n\tend endgenerate\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t(* anyconst *)",
            "reg [AW-1:0]\tf_const_addr;\n\t(* anyconst *)",
            "reg f_const_err;",
            "reg [DW-1:0]\tf_mem_data;",
            "wire [DW-1:0]\tf_word_swapped_mem_data;",
            "wire [TW-1:0]\tf_const_tag;",
            "wire [CS-LS-1:0]\tf_const_line;",
            "wire [LS-1:0]\tf_const_caddr;",
            "reg f_this_return, f_this_line;",
            "reg [AW-1:0]\tf_request_addr;",
            "reg f_simple_return;",
            "reg [31:0]\t\tf_return;",
            "reg [DW-1:0]\tf_wide_return;",
            "reg [AXILSB+1:0]\tf_op;",
            "wire f_special_valid;",
            "wire [DW-1:0]\tf_special_cached_data;",
            "wire [TW-1:0]\tf_special_tag;",
            "reg [CS-1:0]\tf_wcache_addr_diff;\n\n\n\talways @(*)\n\t\tassume(f_const_addr[AXILSB-1:0] == 0);\n\n\tassign\t{ f_const_tag, f_const_line, f_const_caddr }\n\t\t\t\t= f_const_addr[AW-1:AXILSB];\n\n\t// f_this_return\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tf_this_return = r_rd_pending && M_AXI_RVALID;\n\t\tif (OPT_WRAP)\n\t\t\tf_this_return = (state == DC_READC && M_AXI_RVALID);\n\t\tif (read_addr[CS-1:LS] != f_const_line)\n\t\t\tf_this_return = 0;\n\t\tif ({ r_ctag, r_cline } != { f_const_tag, f_const_line })\n\t\t\tf_this_return = 0;\n\t\tif (faxi_rd_ckvalid)\n\t\tbegin\n\t\t\tif (faxi_rd_ckaddr[AW-1:AXILSB] != f_const_addr[AW-1:AXILSB])\n\t\t\t\tf_this_return = 0;\n\t\tend else begin\n\t\t\tif (read_addr[CS-1:0] != f_const_addr[AXILSB +: CS])\n\t\t\t\tf_this_return = 0;\n\t\tend\n\t\tif (state != DC_READC)\n\t\t\tf_this_return = 0;\n\tend\n\t// }}}\n\n\t// f_simple_return, f_request_addr\n\t// {{{\n\tinitial\tf_simple_return = 0;\n\talways @(posedge S_AXI_ACLK)\n\tbegin\n\t\tif (i_pipe_stb)\n\t\tbegin\n\t\t\tf_request_addr <= rev_addr;\n\t\t\tf_simple_return = (f_const_addr[AW-1:AXILSB]\n\t\t\t\t\t\t\t== i_addr[AW-1:AXILSB]);\n\t\t\tif (misaligned || i_op[0])\n\t\t\t\tf_simple_return <= 1'b0;\n\t\t\tif (address_is_cachable && (!OPT_LOCK || !i_lock))\n\t\t\t\tf_simple_return <= 1'b0;\n\t\tend else if (M_AXI_RVALID)\n\t\t\tf_simple_return <= 1'b0;\n\n\t\tif (state == DC_READC)\n\t\tbegin\n\t\t\tassert(read_addr[CS-1:LS] == f_request_addr[AXILSB +LS\n\t\t\t\t\t\t\t+: (CS-LS)]);\n\t\t\tif (M_AXI_ARVALID)\n\t\t\tbegin\n\t\t\t\tif (!OPT_WRAP)\n\t\t\t\tbegin\n\t\t\t\t\tassert({ f_request_addr[AW-1:AXILSB+LS], {(LS){1'b0}}, {(AXILSB){1'b0}} } == M_AXI_ARADDR);\n\t\t\t\t\tassert(read_addr[LS-1:0] == 0);\n\t\t\t\t\tassert(axi_araddr == { f_request_addr[AW-1:AXILSB+LS],\n\t\t\t\t\t\t\t{(LS+AXILSB){1'b0}} });\n\t\t\t\tend else begin\n\t\t\t\t\tassert({ f_request_addr[AW-1:AXILSB], {(AXILSB){1'b0}} } == M_AXI_ARADDR);\n\t\t\t\t\tassert(read_addr[LS-1:0] == M_AXI_ARADDR[AXILSB+LS-1:AXILSB]);\n\t\t\t\tend\n\t\t\tend else if (faxi_rd_ckvalid)\n\t\t\t\tassert(faxi_rd_ckaddr[AW-1:AXILSB+LS]\n\t\t\t\t\t== f_request_addr[AW-1:AXILSB+LS]);\n\t\tend else if (state == DC_READS)\n\t\t\tassert(read_addr[CS-1:LS] == f_request_addr[AXILSB+LS +: (CS-LS)]);\n\n\t\tif (i_cpu_reset)\n\t\t\tf_simple_return <= 0;\n\tend\n\t// }}}\n\n\t// f_this_line\n\t// {{{\n\talways @(*)\n\t\tf_this_line = (f_request_addr[AW-1:AXILSB+LS] == f_const_addr[AW-1:AXILSB+LS]);\n\t// }}}\n\n\t// f_op\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (i_pipe_stb)\n\t\tf_op <= { i_op[2:1], rev_addr[AXILSB-1:0] };\n\n\talways @(*)\n\tif (cpu_outstanding > 0)\n\t\tassert(f_op == req_data);\n\n\talways @(*)\n\tif (cpu_outstanding > 0 && !o_err)\n\tbegin\n\t\tassert(!checklsb(f_op[AXILSB+1:AXILSB], f_op[1:0]));\n\t\tassert(f_op[AXILSB-1:0] == f_request_addr[AXILSB-1:0]);\n\t\tif (!OPT_PIPE)\n\t\t\tassert(f_request_addr[AW-1:AXILSB] == r_addr);\n\tend\n\t// }}}\n\n\t// Check f_simple_return and f_request_addr\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (flushing)\n\tbegin\n\t\tassert(!f_simple_return);\n\tend else if (state != DC_READS)\n\tbegin\n\t\tassert(!f_simple_return);\n\tend else if (f_simple_return)\n\tbegin\n\t\tassert(f_request_addr[AW-1:AXILSB]== f_const_addr[AW-1:AXILSB]);\n\tend else\n\t\tassert(f_request_addr[AW-1:AXILSB]!= f_const_addr[AW-1:AXILSB]);\n\t// }}}\n\n\t// Update f_mem_data\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (M_AXI_AWVALID && M_AXI_WVALID\n\t\t&& M_AXI_AWADDR[AW-1:AXILSB] == f_const_addr[AW-1:AXILSB])\n\tbegin\n\t\tfor(ik=0; ik<DW/8; ik=ik+1)\n\t\tif (M_AXI_WSTRB[ik])\n\t\t\tf_mem_data[ik*8 +: 8] <= M_AXI_WDATA[ik*8 +: 8];\n\tend\n\n\tgenerate if (!SWAP_WSTRB)\n\tbegin\n\t\tassign\tf_word_swapped_mem_data = f_mem_data;\n\n\tend else for(gk=0; gk<C_AXI_DATA_WIDTH/32; gk=gk+1)\n\tbegin\n\t\tassign\tf_word_swapped_mem_data[32*gk +: 32]\n\t\t\t\t=f_mem_data[C_AXI_DATA_WIDTH - (gk+1)*32 +: 32];\n\tend endgenerate\n\t// }}}\n\n\t// Property #1: Assume a known return\n\t// {{{\n\talways @(*)\n\tif (M_AXI_RVALID && (f_simple_return || f_this_return))\n\tbegin\n\t\tassume(M_AXI_RRESP[1] == f_const_err);\n\t\tif (!f_const_err)\n\t\t\tassume(M_AXI_RDATA == f_mem_data);\n\tend else if (M_AXI_RVALID && f_this_line)\n\tbegin\n\t\tif (!f_const_err)\n\t\t\tassume(!M_AXI_RRESP[1]);\n\tend\n\n\talways @(*)\n\tif (M_AXI_BVALID && (f_request_addr[AW-1:AXILSB] == f_const_addr[AW-1:AXILSB]))\n\t\tassume(M_AXI_BRESP[1] == f_const_err);\n\t// }}}\n\n\t// Check good_cache_read\n\t// {{{\n\talways @(*)\n\tif (state == DC_READC && f_this_line)\n\tbegin\n\t\tif (!f_const_err)\n\t\tbegin\n\t\t\tassert(good_cache_read);\n\t\tend else if (!OPT_WRAP && read_addr[LS-1:0] > f_const_addr[LS+AXILSB-1:AXILSB])\n\t\t\tassert(flushing);\n\tend\n\t// }}}\n\n\t// f_wide_return, f_return\n\t// {{{\n\talways @(*)\n\tif (SWAP_WSTRB)\n\tbegin\n\t\tf_wide_return = f_word_swapped_mem_data << (8*f_op[AXILSB-1:0]);\n\t\tcasez(f_op[AXILSB +: 2])\n\t\t2'b0?:\tf_wide_return[31:0] = f_wide_return[DW-1:DW-32];\n\t\t2'b10:\tf_wide_return[31:0] = { 16'h0, f_wide_return[DW-1:DW-16] };\n\t\t2'b11:\tf_wide_return[31:0] = { 24'h0, f_wide_return[DW-1:DW- 8] };\n\t\tendcase\n\tend else\n\t\tf_wide_return = f_mem_data >> (8*f_op[AXILSB-1:0]);\n\n\talways @(*)\n\tbegin\n\t\tcasez(f_op[AXILSB +: 2])\n\t\t2'b0?:\tf_return = f_wide_return[31:0];\n\t\t2'b10:\tf_return = { 16'h0, f_wide_return[15:0] };\n\t\t2'b11:\tf_return = { 24'h0, f_wide_return[ 7:0] };\n\t\tendcase\n\n\t\tif (OPT_SIGN_EXTEND)\n\t\tcasez(f_op[AXILSB +: 2])\n\t\t2'b0?:\tbegin end\n\t\t2'b10:\tf_return[31:16] = {(16){f_wide_return[15]}};\n\t\t2'b11:\tf_return[31:24] = {(24){f_wide_return[ 7]}};\n\t\tendcase\n\tend\n\t// }}}\n\n\t// Property #2: Assert a known response\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (S_AXI_ARESETN && !OPT_PIPE\n\t\t&& (!OPT_LOCK || !f_was_locked_write)\n\t\t&& (f_request_addr[AW-1:AXILSB] == f_const_addr[AW-1:AXILSB]))\n\tbegin\n\t\tif (o_valid)\n\t\tbegin\n\t\t\tassert(!f_const_err);\n\t\t\tassert(f_return == o_data);\n\t\tend else if (o_err)\n\t\tbegin\n\t\t\tif (!OPT_LOCK)\n\t\t\t\tassert(f_const_err || $past(misaligned));\n\t\t\t// else if OPT_LOCK\n\t\t\t//\n\t\t\t// We might also produce an error if the value isn't\n\t\t\t// lockable\n\t\tend\n\tend\n\t// }}}\n\n\t// Property #3: Assert valid cache\n\t// {{{\n\tassign\tf_special_valid = cache_valid[f_const_line]\n\t\t\t\t&& (cache_tag[f_const_line] == f_const_tag);\n\tassign\tf_special_tag = cache_tag[f_const_line];\n\tassign\tf_special_cached_data = cache_mem[{ f_const_line, f_const_caddr }];\n\n\talways @(*)\n\tif (S_AXI_ARESETN // && (!OPT_PIPE || (!flushing && !o_err))\n\t\t\t&& f_special_valid)\n\tbegin\n\t\tassert(f_special_cached_data == f_word_swapped_mem_data);// !!!\n\t\tassert(!f_const_err);\n\tend\n\n\talways @(*)\n\tif (!OPT_PIPE && last_tag_valid && last_tag_line == f_const_line && last_tag == f_const_tag)\n\t\tassert(!f_const_err);\n\n\talways @(*)\n\t\tf_wcache_addr_diff = wcache_addr - f_const_addr[LGCACHELEN-1:AXILSB];\n\n\talways @(*)\n\tif (S_AXI_ARESETN && !OPT_PIPE && !flushing && (state == DC_READC\n\t\t\t|| (state == DC_IDLE && !set_vflag && r_rd_pending\n\t\t\t\t&& r_ctag == f_const_tag\n\t\t\t\t&& (r_dvalid || r_svalid)))\n\t\t&& f_this_line\n\t\t&& !f_wcache_addr_diff[CS-1] && f_wcache_addr_diff != 0)\n\tbegin\n\t\t// The cache read is in progress.  Verify any partial results\n\t\tif (f_const_err)\n\t\tbegin\n\t\t\tassert(OPT_WRAP || (!good_cache_read && !r_rd_pending));\n\t\tend else if (!flushing)\n\t\t\tassert(OPT_WRAP || (f_special_cached_data == f_word_swapped_mem_data));\n\tend\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Exclusive access\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tassign\tfaxi_exlock_len = 0;\n\tassign\tfaxi_exlock_burst = INCR;\n\n\talways @(posedge S_AXI_ACLK)\n\tif (M_AXI_ARVALID && M_AXI_ARREADY && M_AXI_ARLOCK)\n\tbegin\n\t\tfaxi_exlock_addr <= M_AXI_ARADDR;\n\t\tfaxi_exlock_size <= M_AXI_ARSIZE;\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg cvr_idle;",
            "reg [3:0]\tcvr_cache_reads, cvr_cache_writes, cvr_cache_misses,\n\t\t\tcvr_simple_reads, cvr_simple_writes;\n\n\t// cvr_idle\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tcvr_idle = 1;\n\t\tif (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID)\n\t\t\tcvr_idle = 0;\n\t\tif (M_AXI_RVALID || M_AXI_BVALID)\n\t\t\tcvr_idle = 0;\n\t\tif (faxi_awr_nbursts > 0)\n\t\t\tcvr_idle = 0;\n\t\tif (faxi_rd_nbursts > 0)\n\t\t\tcvr_idle = 0;\n\t\tif (o_busy || f_done)\n\t\t\tcvr_idle = 0;\n\t\tif (i_pipe_stb)\n\t\t\tcvr_idle = 0;\n\tend\n\t// }}}\n\n\t// cvr_simple_writes\n\t// {{{\n\tinitial\tcvr_simple_writes = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || i_cpu_reset)\n\t\tcvr_simple_writes <= 0;\n\telse if (wcache_strb != 0 && w_v && wcache_tag == r_ctag)\n\t\tcvr_simple_writes <= 0;\n\telse if (M_AXI_BVALID && !(&cvr_simple_writes))\n\t\tcvr_simple_writes <= cvr_simple_writes + 1;\n\n\talways @(*)\n\tbegin\n\t\t// cover(cvr_idle && cvr_simple_writes > 0);\n\t\t// cover(cvr_idle && cvr_simple_writes > 1);\n\t\tcover(cvr_idle && cvr_simple_writes > 4);\n\tend\n\t// }}}\n\n\t// cvr_simple_reads\n\t// {{{\n\tinitial\tcvr_simple_reads = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || o_err || i_cpu_reset)\n\t\tcvr_simple_reads <= 0;\n\telse if (i_pipe_stb && !i_op[0] && !misaligned && !address_is_cachable\n\t\t\t&& !(&cvr_simple_reads))\n\t\tcvr_simple_reads <= cvr_simple_reads + 1;\n\n\talways @(*)\n\tbegin\n\t\t// cover(cvr_idle && cvr_simple_reads > 0);\n\t\t// cover(cvr_idle && cvr_simple_reads > 1);\n\t\tcover(cvr_idle && cvr_simple_reads > 4);\n\tend\n\t// }}}\n\n\t// cvr_cache_misses\n\t// {{{\n\tinitial\tcvr_cache_misses = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || state == DC_READS || i_cpu_reset)\n\t\tcvr_cache_misses <= 0;\n\telse if (M_AXI_ARVALID && M_AXI_ARREADY &&\n\t\t\t\t(state == DC_READC) && !(&cvr_cache_misses))\n\t\tcvr_cache_misses <= cvr_cache_misses + 1;\n\n\talways @(*)\n\tbegin\n\t\t// cover(cvr_idle && cvr_cache_misses > 0);\n\t\t// cover(cvr_idle && cvr_cache_misses > 1);\n\t\tcover(cvr_idle && cvr_cache_misses > 2);\n\tend\n\t// }}}\n\n\t// cvr_cache_reads\n\t// {{{\n\tinitial\tcvr_cache_reads = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || M_AXI_ARVALID || M_AXI_RVALID || i_cpu_reset)\n\t\tcvr_cache_reads <= 0;\n\telse if (o_valid && $past(r_dvalid || r_svalid) && !(&cvr_cache_reads))\n\t\tcvr_cache_reads <= cvr_cache_reads + 1;\n\n\talways @(*)\n\tbegin\n\t\t// cover(cvr_idle && cvr_cache_reads > 0);\n\t\t// cover(cvr_idle && cvr_cache_reads > 1);\n\t\tcover(cvr_idle && cvr_cache_reads > 4);\n\tend\n\t// }}}\n\n\t// cvr_cache_writes\n\t// {{{\n\tinitial\tcvr_cache_writes = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || M_AXI_ARVALID || M_AXI_RVALID || i_cpu_reset)\n\t\tcvr_cache_writes <= 0;\n\telse if (!(&cvr_cache_writes) && state == DC_WRITE\n\t\t\t&& w_v && wcache_tag == r_ctag && wcache_strb != 0)\n\t\tcvr_cache_writes <= cvr_cache_writes + 1;\n\n\talways @(*)\n\tbegin\n\t\t// cover(cvr_idle && cvr_cache_writes > 0);\n\t\t// cover(cvr_idle && cvr_cache_writes > 1);\n\t\tcover(cvr_idle && cvr_cache_writes > 4);\n\tend\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// \"Careless\" constraining assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (i_pipe_stb && i_write && i_lock)\n\tbegin\n\t\tassume(i_addr == faxi_exlock_addr);\n\t\tassume(faxi_ex_state == 2'b10);\n\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tassert(faxi_exlock_size == DSZ);\n\t\tend else casez(i_op[2:1])\n\t\t2'b0?: assume(faxi_exlock_size == 3'b010); // Word\n\t\t2'b10: assume(faxi_exlock_size == 3'b001); // Half-word\n\t\t2'b11: assume(faxi_exlock_size == 3'b000); // Byte\n\t\tendcase\n\tend\n\n\talways @(*)\n\tcasez(faxi_ex_state)\n\t2'b01: begin\n\t\tassert(faxi_exreq_len == 0);\n\t\tassert(faxi_exreq_size <= 3'd2);\n\n\t\tif (faxi_exreq_addr[0])\n\t\tbegin\n\t\t\tassert(faxi_exreq_size == 3'd0);\n\t\tend else if (faxi_exreq_addr[1])\n\t\t\tassert(faxi_exreq_size <= 3'd1);\n\n\t\tif (SWAP_WSTRB)\n\t\t\tassert(faxi_exreq_size == 3'd2);\n\t\t// assert(faxi_exlock_size  == faxi_exreq_size);\n\t\tend\n\t2'b1?: begin\n\t\tassert(faxi_exlock_addr  == faxi_exreq_addr);\n\t\tassert(faxi_exlock_len   == faxi_exreq_len);\n\t\tassert(faxi_exlock_size  == faxi_exreq_size);\n\t\tassert(faxi_exlock_burst == faxi_exreq_burst);\n\t\tassert(faxi_exlock_size <= 3'd2);\n\n\t\tif (SWAP_WSTRB)\n\t\t\tassert(faxi_exlock_size == 3'd2);\n\t\tif (faxi_exlock_addr[0])\n\t\tbegin\n\t\t\tassert(faxi_exlock_size == 3'd0);\n\t\tend else if (faxi_exlock_addr[1])\n\t\t\tassert(faxi_exlock_size <= 3'd1);\n\t\tend\n\tdefault: begin end\n\tendcase\n\n\talways @(*)\n\tif (i_pipe_stb && i_lock)\n\t\tassume(!i_cpu_reset);\n\n\talways @(posedge S_AXI_ACLK)\n\tif ($past(i_cpu_reset))\n\t\tassume((faxi_ex_state == 2'b00) || (faxi_ex_state == 2'b01));\n\n\talways @(*)\n\tif (OPT_WRAP && S_AXI_ARESETN && !i_cpu_reset\n\t\t&& !r_rd_pending && state == DC_READC && M_AXI_RVALID)\n\t\tassume(M_AXI_RRESP[1] == !good_cache_read);\n\n\talways @(*)\n\tif (S_AXI_ARESETN && OPT_LOCK && cpu_outstanding > 0)\n\t\tassume(!i_pipe_stb || !i_lock);\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "wire unused_formal;\n\tassign\tunused_formal = &{ 1'b0, cpu_pc,\n\t\t\tfaxi_rdid_ckign_nbursts, faxi_rdid_ckign_outstanding,\n\t\t\tfaxi_wr_incr, faxi_wr_pending, faxi_wr_addr,\n\t\t\tcpu_addr_",
            "reg , faxi_rd_ckincr,\n\t\t\tfaxi_rd_lastaddr };\n\t// Verilator lint_on  UNUSED\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipcore.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/zipcore.v",
        "chunks": [
            "module zipcore #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=30,\t// 32-b word addr width",
            "parameter [31:0] RESET_ADDRESS=32'h010_0000,",
            "parameter OPT_MPY = 0,",
            "parameter [0:0]\tOPT_SHIFTS = 1,",
            "parameter [0:0]\tOPT_DIV = 1,",
            "parameter [0:0]\tIMPLEMENT_FPU = 0,",
            "parameter [0:0]\tOPT_EARLY_BRANCHING = 1,",
            "parameter [0:0]\tOPT_CIS = 1'b1,",
            "parameter [0:0]\tOPT_SIM = 1'b0,",
            "parameter [0:0]\tOPT_DISTRIBUTED_REGS = 1'b1,",
            "parameter [0:0]\tOPT_PIPELINED = 1'b1,",
            "parameter [0:0]\tOPT_PIPELINED_BUS_ACCESS = (OPT_PIPELINED),",
            "parameter [0:0]\tOPT_LOCK=1,",
            "parameter [0:0]\tOPT_DCACHE = 1,",
            "parameter [0:0]\tOPT_USERMODE = 1'b1,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,",
            "parameter [0:0]\tOPT_CLKGATE = 1'b1,",
            "parameter [0:0]\tOPT_START_HALTED = 1'b1,",
            "parameter [0:0]\tOPT_DBGPORT = 1'b1,",
            "parameter [0:0]\tOPT_TRACE_PORT = 1'b0,",
            "parameter [0:0]\tOPT_PROFILER = 1'b0,",
            "localparam AW=ADDRESS_WIDTH\n`ifdef\tFORMAL\n\t\t,",
            "parameter F_LGDEPTH=4\n`endif\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset, i_interrupt,",
            "output ",
            "wire o_clken,\n\t\t// Debug interface\n\t\t// {{{",
            "input ",
            "wire i_halt, i_clear_cache,",
            "input ",
            "wire [4:0]\ti_dbg_w",
            "reg ,",
            "input ",
            "wire i_dbg_we,",
            "input ",
            "wire [31:0]\ti_dbg_data,",
            "input ",
            "wire [4:0]\ti_dbg_r",
            "reg ,\n\t\t//",
            "output ",
            "wire o_dbg_stall,",
            "output ",
            "wire [31:0]\to_dbg_",
            "reg ,",
            "output ",
            "reg [2:0]\to_dbg_cc,",
            "output ",
            "wire o_break,\n\t\t// }}}\n\t\t// Instruction fetch interface\n\t\t// {{{",
            "output ",
            "wire o_pf_new_pc,",
            "output ",
            "wire o_clear_icache,",
            "output ",
            "wire o_pf_ready,",
            "output ",
            "wire [(AW+1):0]\to_pf_request_address,",
            "input ",
            "wire i_pf_valid, i_pf_illegal,",
            "input ",
            "wire [31:0]\ti_pf_instruction,",
            "input ",
            "wire [(AW+1):0]\ti_pf_instruction_pc,\n\t\t// }}}\n\t\t// Memory unit interface\n\t\t// {{{",
            "output ",
            "wire o_clear_dcache,",
            "output ",
            "wire o_mem_ce,",
            "output ",
            "wire o_bus_lock,",
            "output ",
            "wire [2:0]\to_mem_op,",
            "output ",
            "wire [31:0]\to_mem_addr,",
            "output ",
            "wire [31:0]\to_mem_data,",
            "output ",
            "wire [AW+1:0]\to_mem_lock_pc,",
            "output ",
            "wire [4:0]\to_mem_",
            "reg ,",
            "input ",
            "wire i_mem_busy, i_mem_rdbusy,\n\t\t\t\t\ti_mem_pipe_stalled, i_mem_valid,",
            "input ",
            "wire i_bus_err,",
            "input ",
            "wire [4:0]\ti_mem_w",
            "reg ,",
            "input ",
            "wire [31:0]\ti_mem_result,\n\t\t// }}}\n\t\t// Accounting",
            "output s ... to help us count stalls and usage\n\t\t// {{{",
            "output ",
            "wire o_op_stall,",
            "output ",
            "wire o_pf_stall,",
            "output ",
            "wire o_i_count,\n\t\t// }}}\n\t\t// Debug data for on-line/live tracing\n\t\t// {{{",
            "output ",
            "wire [31:0]\to_debug,\n\t\t//}}}\n\t\t// (Optional) Profiler data\n\t\t// {{{",
            "output ",
            "wire o_prof_stb,",
            "output ",
            "wire [AW+1:0]\to_prof_addr,",
            "output ",
            "wire [31:0]\to_prof_ticks\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Local",
            "parameter definitions\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "localparam [0:0]\tOPT_MEMPIPE = OPT_PIPELINED_BUS_ACCESS;",
            "localparam [(AW-1):0]\tRESET_BUS_ADDRESS = RESET_ADDRESS[AW+1:2];",
            "localparam [3:0]\tCPU_CC_REG = 4'he,\n\t\t\t\tCPU_PC_REG = 4'hf;",
            "localparam [3:0]\tCPU_SUB_OP = 4'h0,// also a compare instruction\n\t\t\t\tCPU_AND_OP = 4'h1,// also a test instruction\n\t\t\t\tCPU_BREV_OP= 4'h8,\n\t\t\t\tCPU_MOV_OP = 4'hd;",
            "localparam CPU_CLRDCACHE_BIT=15, // Set to clr D-cache,auto clears\n\t\t\tCPU_CLRICACHE_BIT=14, // Set to clr I-cache,auto clears\n\t\t\tCPU_PHASE_BIT   = 13, // Set on last half of a CIS\n\t\t\tCPU_FPUERR_BIT  = 12, // Set on floating point error\n\t\t\tCPU_DIVERR_BIT  = 11, // Set on divide error\n\t\t\tCPU_BUSERR_BIT  = 10, // Set on bus error\n\t\t\tCPU_TRAP_BIT    =  9, // User TRAP has taken place\n\t\t\tCPU_ILL_BIT     =  8, // Illegal instruction\n\t\t\tCPU_BREAK_BIT   =  7,\n\t\t\tCPU_STEP_BIT    =  6, // Will step one (or two CIS) ins\n\t\t\tCPU_GIE_BIT     =  5,\n\t\t\tCPU_SLEEP_BIT   =  4;\n\t// Verilator lint_on  UNUSED\n\t// }}}\n\n\t// Register declarations\n\t// {{{\n\t//\tThe distributed RAM style comment is necessary on the\n\t// SPARTAN6 with XST to prevent XST from oversimplifying the",
            "reg ister\n\t// set and in the process ruining everything else.  It basically\n\t// optimizes",
            "logic away, to where it no longer works.  The",
            "logic // as described herein will work, this just makes sure XST implements\n\t// that",
            "logic .\n\t//\n\t// (* ram_style = \"distributed\" *)",
            "reg [31:0]",
            "reg set\t[0:(OPT_USERMODE)? 31:15];\n\n\t// Condition codes\n\t// (BUS, TRAP,ILL,BREAKEN,STEP,GIE,SLEEP ), V, N, C, Z",
            "reg [3:0]\tflags, iflags;",
            "wire [15:0]\tw_uflags, w_iflags;",
            "reg break_en, user_step, sleep, r_halted;",
            "wire break_pending, trap, gie, ubreak, pending_interrupt,\n\t\t\tstepped;",
            "wire step;",
            "wire ill_err_u;",
            "reg ill_err_i;",
            "reg ibus_err_flag;",
            "wire ubus_err_flag;",
            "wire idiv_err_flag, udiv_err_flag;\n\t// Verilator coverage_off",
            "wire ifpu_err_flag, ufpu_err_flag;\n\t// Verilator coverage_on",
            "wire ihalt_phase, uhalt_phase;\n\n\t// The master chip enable",
            "wire master_ce, master_stall;\n\t//\n\n\t//\n\t//\tPIPELINE STAGE #1 :: Prefetch\n\t//\t\tVariable declarations\n\t//\n\t// {{{",
            "reg [(AW+1):0]\tpf_pc;",
            "reg new_pc;",
            "wire clear_pipeline;",
            "reg dcd_stalled;\n\t//",
            "wire pf_cyc, pf_stb, pf_we, pf_stall, pf_ack, pf_err;\n\t//",
            "wire [(AW-1):0]\tpf_addr;\n\t//",
            "wire pf_valid, pf_gie, pf_illegal;",
            "wire pf_gie;\n`ifdef\tFORMAL",
            "wire [31:0]\t\tf_dcd_insn_word;",
            "wire f_dcd_insn_gie;",
            "wire f_dcd_insn_is_pipeable;",
            "reg [31:0]\t\tf_op_insn_word;",
            "reg [31:0]\t\tf_alu_insn_word;\n`endif\n\n\tassign\tclear_pipeline = new_pc;\n\t// }}}\n\n\t//\n\t//\tPIPELINE STAGE #2 :: Instruction Decode\n\t//\t\tVariable declarations\n\t//\n\t//\n\t// {{{",
            "wire [3:0]\tdcd_opn;",
            "wire dcd_ce, dcd_phase;",
            "wire [4:0]\tdcd_A, dcd_B, dcd_R, dcd_preA, dcd_preB;",
            "wire dcd_Acc, dcd_Bcc, dcd_Apc, dcd_Bpc, dcd_Rcc, dcd_Rpc;",
            "wire [3:0]\tdcd_F;",
            "wire dcd_wR, dcd_rA, dcd_rB,\n\t\t\t\tdcd_ALU, dcd_M, dcd_DIV, dcd_FP,\n\t\t\t\tdcd_wF, dcd_gie, dcd_break, dcd_lock,\n\t\t\t\tdcd_pipe, dcd_ljmp;",
            "wire dcd_valid;",
            "wire [AW+1:0]\tdcd_pc /* verilator public_flat */;",
            "wire [31:0]\tdcd_I;",
            "wire dcd_zI;\t// true if dcd_I == 0",
            "wire dcd_A_stall, dcd_B_stall, dcd_F_stall;",
            "wire dcd_illegal;",
            "wire dcd_early_branch, dcd_early_branch_stb;",
            "wire [(AW+1):0]\tdcd_branch_pc;",
            "wire dcd_sim;",
            "wire [22:0]\tdcd_sim_immv;",
            "wire prelock_stall, last_lock_insn;",
            "wire cc_invalid_for_dcd;",
            "wire pending_s",
            "reg _write;\n\t// }}}\n\n\n\t//\n\t//\n\t//\tPIPELINE STAGE #3 :: Read Operands\n\t//\t\tVariable declarations\n\t//\n\t//\n\t//\n\t// {{{\n\t// Now, let's read our operands",
            "reg op_valid /* verilator public_flat */,\n\t\t\top_valid_mem, op_valid_alu;",
            "reg op_valid_div, op_valid_fpu;",
            "wire op_stall;",
            "wire [3:0]\top_opn;",
            "wire [4:0]\top_R;",
            "reg op_Rcc;",
            "wire [4:0]\top_Aid, op_Bid;",
            "wire op_rA, op_rB;",
            "reg [31:0]\tr_op_Av, r_op_Bv;",
            "wire [AW+1:0]\top_pc;",
            "wire [31:0]\tw_op_Av, w_op_Bv, op_Av, op_Bv;",
            "reg [31:0]\tw_pcB_v, w_pcA_v;",
            "reg [31:0]\tw_op_BnI;",
            "wire op_wR;",
            "reg op_wF;",
            "wire op_gie;",
            "wire [3:0]\top_Fl;",
            "reg [6:0]\tr_op_F;",
            "wire [7:0]\top_F;",
            "wire op_ce, op_phase, op_pipe;",
            "reg r_op_break;",
            "wire w_op_valid;",
            "wire op_lowpower_clear;",
            "wire [8:0]\tw_cpu_info;\n\t// Some pipeline control",
            "wire s",
            "reg op_illegal;",
            "wire op_break;",
            "wire op_lock;",
            "wire op_sim\t\t/* verilator public_flat */;",
            "wire [22:0]\top_sim_immv\t/* verilator public_flat */;",
            "wire alu_sim\t\t/* verilator public_flat */;",
            "wire [22:0]\talu_sim_immv\t/* verilator public_flat */;\n\t// }}}\n\n\n\t//\n\t//\n\t//\tPIPELINE STAGE #4 :: ALU / Memory\n\t//\t\tVariable declarations\n\t//\n\t//\n\t// {{{",
            "wire [(AW+1):0]\talu_pc;",
            "reg [4:0]\talu_",
            "reg ;",
            "reg r_alu_pc_valid, mem_pc_valid;",
            "wire alu_pc_valid;",
            "wire alu_phase;",
            "wire alu_ce /* verilator public_flat */, alu_stall;",
            "wire [31:0]\talu_result;",
            "wire [3:0]\talu_flags;",
            "wire alu_valid, alu_busy;",
            "wire set_cond;",
            "reg alu_wR, alu_wF;",
            "wire alu_gie, alu_illegal;",
            "wire mem_ce, mem_stalled;",
            "wire div_ce, div_error, div_busy, div_valid;",
            "wire [31:0]\tdiv_result;",
            "wire [3:0]\tdiv_flags;\n\n\t// Verilator coverage_off",
            "wire fpu_ce, fpu_error, fpu_busy, fpu_valid;",
            "wire [31:0]\tfpu_result;",
            "wire [3:0]\tfpu_flags;\n\t// Verilator coverage_on",
            "reg adf_ce_unconditional;",
            "reg dbgv, dbg_clear_pipe;",
            "reg [31:0]\tdbg_val;",
            "reg [31:0]\tdebug_pc;",
            "reg r_dbg_stall;\n\n\tassign\tdiv_ce = (op_valid_div)&&(adf_ce_unconditional)&&(set_cond);\n\tassign\tfpu_ce = (IMPLEMENT_FPU)&&(op_valid_fpu)&&(adf_ce_unconditional)&&(set_cond);\n\n\t// }}}\n\n\t//\n\t//\n\t//\tPIPELINE STAGE #5 :: Write-back\n\t//\t\tVariable declarations\n\t//\n\t// {{{",
            "wire wr_write_pc, wr_write_cc,\n\t\t\twr_write_scc, wr_write_ucc;",
            "reg wr_",
            "reg _ce, wr_flags_ce;",
            "reg [3:0]\twr_flags;",
            "reg [2:0]\twr_index;",
            "wire [4:0]\twr_",
            "reg _id;",
            "reg [31:0]\twr_gp",
            "reg _vl, wr_sp",
            "reg _vl;",
            "wire w_switch_to_interrupt, w_release_from_interrupt;",
            "reg [(AW+1):0]\tipc;",
            "wire [(AW+1):0]\tupc;",
            "reg last_write_to_cc;",
            "wire cc_write_hold;",
            "reg r_clear_icache;",
            "reg pfpcset;",
            "reg [2:0]\tpfpcsrc;",
            "wire w_clken;\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// MASTER: clock enable.\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tassign\tmaster_ce = (!i_halt || alu_phase)\n\t\t\t\t&&(!cc_write_hold)&&(!o_break)&&(!sleep);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Calculate stall conditions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// PIPELINE STAGE #1 :: Prefetch\n\t//\tThese are calculated externally, within the prefetch",
            "module .\n\t//\n\t// PIPELINE STAGE #2 :: Instruction Decode\n\t// {{{\n\talways @(*)\n\tif (OPT_PIPELINED)\n\t\tdcd_stalled = (dcd_valid && op_stall);\n\telse\n\t\tdcd_stalled = (!master_ce)\n\t\t\t// Can't step forward when we need to be halted\n\t\t\t||(ill_err_i)||(ibus_err_flag)||(idiv_err_flag)\n\t\t\t||((dcd_valid || op_valid) && !dcd_early_branch)\n\t\t\t||(alu_busy)||(div_busy)||(fpu_busy)||(i_mem_busy);\n\t// }}}\n\t//\n\t// PIPELINE STAGE #3 :: Read Operands\n\t// {{{\n\tgenerate if (OPT_PIPELINED)\n\tbegin : GEN_OP_STALL",
            "reg r_cc_invalid_for_dcd;",
            "reg r_pending_s",
            "reg _write;\n\n\t\t// cc_invalid_for_dcd\n\t\t// {{{\n\t\tinitial\tr_cc_invalid_for_dcd = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (clear_pipeline)\n\t\t\tr_cc_invalid_for_dcd <= 1'b0;\n\t\telse if ((alu_ce || mem_ce)&&(set_cond)&&(op_valid) &&((op_wF)\n\t\t\t\t||((op_wR)&&(op_R[4:0] == { op_gie, CPU_CC_REG }))))\n\t\t\t// If an instruction in the pipeline will write to the\n\t\t\t// CC",
            "reg ister, then we can't be allowed to release\n\t\t\t// any instruction depending upon the CC",
            "reg ister\n\t\t\t// (for other than conditional execution) into the\n\t\t\t// pipeline.\n\t\t\tr_cc_invalid_for_dcd <= 1'b1;\n\t\telse if (r_cc_invalid_for_dcd)\n\t\t\t// While the pipeline is busy, keep r_cc_invalid_for_dcd\n\t\t\t// high.\n\t\t\tr_cc_invalid_for_dcd <= ((alu_busy)||(i_mem_rdbusy)||(div_busy)||(fpu_busy));\n\t\telse\n\t\t\tr_cc_invalid_for_dcd <= 1'b0;\n\n\t\tassign\tcc_invalid_for_dcd = r_cc_invalid_for_dcd;\n\t\t// }}}\n\n\t\t// pending_s",
            "reg _write\n\t\t// {{{\n\t\t// Used to determine if we need to stall for flags to be ready\n\t\tinitial\tr_pending_s",
            "reg _write = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (clear_pipeline)\n\t\t\tr_pending_s",
            "reg _write <= 1'b0;\n\t\telse if (((adf_ce_unconditional)||(mem_ce))\n\t\t\t\t&&(set_cond)&&(!op_illegal)\n\t\t\t\t&&(op_wR)\n\t\t\t\t&&(op_R[3:1] == 3'h7)\n\t\t\t\t&&(op_R[4:0] != { gie, 4'hf }))\n\t\t\tr_pending_s",
            "reg _write <= 1'b1;\n\t\telse if ((!i_mem_rdbusy)&&(!alu_busy))\n\t\t\tr_pending_s",
            "reg _write <= 1'b0;\n\n\t\tassign\tpending_s",
            "reg _write = r_pending_s",
            "reg _write;\n\t\t// }}}\n\n\t\tassign\top_stall = (op_valid)&&(\n\t\t// {{{\n\t\t\t// Only stall if we're loaded w/valid insns and the\n\t\t\t// next stage is accepting our instruction\n\t\t\t(!adf_ce_unconditional)&&(!mem_ce)\n\t\t\t)\n\t\t\t||(dcd_valid)&&(\n\t\t\t\t// If we are halted, then accepting anything\n\t\t\t\t// into the Op stage might accept a",
            "reg ister\n\t\t\t\t// that then gets modified by the debugging\n\t\t\t\t// interface so as to be invalid.\n\t\t\t\ti_halt\n\t\t\t\t// Stall if we need to wait for an operand A\n\t\t\t\t// to be ready to read\n\t\t\t\t|| (dcd_A_stall)\n\t\t\t\t// Likewise for B, also includes",
            "logic //",
            "reg arding immediate offset (",
            "reg ister must\n\t\t\t\t// be in",
            "reg ister file if we need to add to\n\t\t\t\t// an immediate)\n\t\t\t\t||(dcd_B_stall)\n\t\t\t\t// Or if we need to wait on flags to work on the\n\t\t\t\t// CC",
            "reg ister\n\t\t\t\t||(dcd_F_stall)\n\t\t\t);\n\t\t// }}}\n\t\tassign\top_ce = ((dcd_valid)||(dcd_illegal)||(dcd_early_branch))&&(!op_stall);\n\n\tend else begin : NO_OP_STALLS // !OPT_PIPELINED\n\t\t// {{{\n\t\tassign\top_stall = 1'b0; // (o_break)||(pending_interrupt);\n\t\tassign\top_ce = ((dcd_valid)||(dcd_early_branch))&&(!op_stall);\n\t\tassign\tpending_s",
            "reg _write = 1'b0;\n\t\tassign\tcc_invalid_for_dcd = 1'b0;\n\n\t\t// verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire pipe_unused;\n\t\tassign\t\tpipe_unused = &{ 1'b0, cc_invalid_for_dcd,\n\t\t\t\t\tpending_s",
            "reg _write };\n\t\t// Verilator lint_on UNUSED\n\t\t// verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\n\t// BUT ... op_ce is too complex for many of the data operations.  So\n\t// let's make their circuit enable code simpler.  In particular, if\n\t// op_ doesn't need to be preserved, we can change it all we want\n\t// ... right?  The clear_pipeline code, for example, really only needs\n\t// to determine whether op_valid is true.\n\t// assign\top_change_data_ce = (!op_stall);\n\t// }}}\n\t//\n\t// PIPELINE STAGE #4 :: ALU / Memory\n\t// {{{\n\t// 1. Basic stall is if the previous stage is valid and the next is\n\t//\tbusy.\n\t// 2. Also stall if the prior stage is valid and the master clock enable\n\t//\tis de-selected\n\t// 3. Stall if someone on the other end is writing the CC",
            "reg ister,\n\t//\tsince we don't know if it'll put us to sleep or not.\n\t// 4. Last case: Stall if we would otherwise move a break instruction\n\t//\tthrough the ALU.  Break instructions are not allowed through\n\t//\tthe ALU.\n\tgenerate if (OPT_PIPELINED)\n\tbegin : GEN_ALU_STALL\n\t\t// alu_stall, alu_ce\n\t\t// {{{\n\t\tassign\talu_stall = (((master_stall)||(i_mem_rdbusy))&&(op_valid_alu)) //Case 1&2\n\t\t\t||(wr_",
            "reg _ce)&&(wr_write_cc);\n\t\t// assign // alu_ce = (master_ce)&&(op_valid_alu)&&(!alu_stall)\n\t\t//\t&&(!clear_pipeline)&&(!op_illegal)\n\t\t//\t&&(!pending_s",
            "reg _write)\n\t\t//\t&&(!alu_s",
            "reg _stall);\n\t\tassign\talu_ce = (adf_ce_unconditional)&&(op_valid_alu);\n\n\t\t// verilator coverage_off\n\t\t// Verilator lint_off unused",
            "wire unused_alu_stall = &{ 1'b0, alu_stall };\n\t\t// Verilator lint_on  unused\n\t\t// verilator coverage_on\n\t\t// }}}\n\tend else begin : NO_ALU_STALLS\n\t\t// alu_stall, alu_ce\n\t\t// {{{\n\t\tassign\talu_stall = (master_stall);\n\t\t//assign\talu_ce = (master_ce)&&(op_valid_alu)\n\t\t//\t\t\t&&(!clear_pipeline)\n\t\t//\t\t\t&&(!alu_stall);\n\t\tassign\talu_ce = (adf_ce_unconditional)&&(op_valid_alu);\n\n\t\t// verilator coverage_off\n\t\t// Verilator lint_off unused",
            "wire unused_alu_stall = &{ 1'b0, alu_stall };\n\t\t// Verilator lint_on  unused\n\t\t// verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\t//\n\n\t// mem_ce\n\t// {{{\n\t// Note: if you change the conditions for mem_ce, you must also change\n\t// alu_pc_valid.\n\t//\n\tassign\tmem_ce = (master_ce)&&(op_valid_mem)&&(!mem_stalled)\n\t\t\t&&(!clear_pipeline);\n\t// }}}\n\n\t// mem_stalled\n\t// {{{\n\tgenerate if (OPT_PIPELINED_BUS_ACCESS)\n\tbegin : GEN_PIPELINE_MEM_STALL\n\t\t// {{{\n\t\tassign\tmem_stalled = (master_stall)||((op_valid_mem)&&(\n\t\t\t\t(i_mem_pipe_stalled)\n\t\t\t\t||(i_bus_err)||(div_error)\n\t\t\t\t||(!op_pipe && i_mem_busy)\n\t\t\t\t// Stall waiting for flags to be valid\n\t\t\t\t// Or waiting for a write to the PC",
            "reg ister\n\t\t\t\t// Or CC",
            "reg ister, since that can change the\n\t\t\t\t//  PC as well\n\t\t\t\t||((wr_",
            "reg _ce)\n\t\t\t\t\t&&((wr_write_pc)||(wr_write_cc)))));\n\t\t// }}}\n\tend else if (OPT_PIPELINED)\n\tbegin : GEN_MEM_STALL\n\t\t// {{{\n\t\tassign\tmem_stalled = (master_stall)||((op_valid_mem)&&(\n\t\t\t\t(i_bus_err)||(div_error)||(i_mem_busy)\n\t\t\t\t// Stall waiting for flags to be valid\n\t\t\t\t// Or waiting for a write to the PC",
            "reg ister\n\t\t\t\t// Or CC",
            "reg ister, since that can change the\n\t\t\t\t//  PC as well\n\t\t\t\t||((wr_",
            "reg _ce)\n\t\t\t\t\t&&((wr_write_pc)||(wr_write_cc)))));\n\t\t// }}}\n\tend else begin : NO_MEM_STALL\n\t\t// {{{\n\t\tassign\tmem_stalled = master_stall || i_mem_busy;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t// }}}\n\n\t//\n\t// Master stall condition\n\t// {{{\n\tassign\tmaster_stall = (!master_ce)||(!op_valid)||(ill_err_i)\n\t\t\t||(step && stepped)\n\t\t\t||(ibus_err_flag)||(idiv_err_flag)\n\t\t\t||(pending_interrupt && !o_bus_lock)&&(!alu_phase)\n\t\t\t||(alu_busy)||(div_busy)||(fpu_busy)||(op_break)\n\t\t\t||((OPT_PIPELINED)&&(\n\t\t\t\tprelock_stall\n\t\t\t\t||((i_mem_busy)&&(op_illegal))\n\t\t\t\t||((i_mem_busy)&&(op_valid_div))\n\t\t\t\t||(alu_illegal)||(o_break)));\n\t// }}}\n\t//\n\t// (Everything but memory) stall condition\n\t// {{{\n\n\t// ALU, DIV, or FPU CE ... equivalent to the OR of all three of these\n\talways @(*)\n\tif (OPT_PIPELINED)\n\t\tadf_ce_unconditional =\n\t\t\t(!master_stall)&&(!op_valid_mem)&&(!i_mem_rdbusy)\n\t\t\t&&(!i_mem_busy || !op_wR\n\t\t\t\t|| op_R[4:0] != { gie, CPU_CC_REG });\n\telse\n\t\tadf_ce_unconditional = (!master_stall)&&(op_valid)&&(!op_valid_mem);\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// PIPELINE STAGE #1 :: Instruction fetch\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tassign\to_pf_ready = (!dcd_stalled && !dcd_phase);\n\n\tassign\to_pf_new_pc = (new_pc)||((dcd_early_branch_stb)&&(!clear_pipeline));\n\n\tassign\to_pf_request_address = ((dcd_early_branch_stb)&&(!clear_pipeline))\n\t\t\t\t? dcd_branch_pc:pf_pc;\n\tassign\tpf_gie = gie;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// PIPELINE STAGE #2 :: Instruction Decode\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tassign\t\tdcd_ce =((OPT_PIPELINED)&&(!dcd_valid))||(!dcd_stalled);",
            "wire [6:0]\tdcd_full_R, dcd_full_A, dcd_full_B;\n\n\tidecode #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(AW),\n\t\t.OPT_MPY((OPT_MPY!=0)? 1'b1:1'b0),\n\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t.OPT_DIVIDE(OPT_DIV),\n\t\t.OPT_FPU(IMPLEMENT_FPU),\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_OPIPE(OPT_PIPELINED_BUS_ACCESS),\n\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t.OPT_SIM(OPT_SIM),\n\t\t.OPT_CIS(OPT_CIS),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER)\n\t\t// }}}\n\t) instruction_decoder(\n\t\t// {{{\n\t\t\t.i_clk(i_clk),\n\t\t\t.i_reset(i_reset||clear_pipeline||o_clear_icache),\n\t\t\t.i_ce(dcd_ce),\n\t\t\t.i_stalled(dcd_stalled),\n\t\t\t.i_instruction(i_pf_instruction), .i_gie(pf_gie),\n\t\t\t.i_pc(i_pf_instruction_pc), .i_pf_valid(i_pf_valid),\n\t\t\t\t.i_illegal(i_pf_illegal),\n\t\t\t.o_valid(dcd_valid), .o_phase(dcd_phase),\n\t\t\t.o_illegal(dcd_illegal), .o_pc(dcd_pc),\n\t\t\t.o_dcdR(dcd_full_R), .o_dcdA(dcd_full_A),\n\t\t\t\t.o_dcdB(dcd_full_B),\n\t\t\t.o_preA(dcd_preA), .o_preB(dcd_preB),\n\t\t\t.o_I(dcd_I), .o_zI(dcd_zI), .o_cond(dcd_F),\n\t\t\t.o_wF(dcd_wF), .o_op(dcd_opn),\n\t\t\t.o_ALU(dcd_ALU), .o_M(dcd_M), .o_DV(dcd_DIV),\n\t\t\t.o_FP(dcd_FP), .o_break(dcd_break), .o_lock(dcd_lock),\n\t\t\t.o_wR(dcd_wR), .o_rA(dcd_rA), .o_rB(dcd_rB),\n\t\t\t.o_early_branch(dcd_early_branch),\n\t\t\t.o_early_branch_stb(dcd_early_branch_stb),\n\t\t\t.o_branch_pc(dcd_branch_pc), .o_ljmp(dcd_ljmp),\n\t\t\t.o_pipe(dcd_pipe),\n\t\t\t.o_sim(dcd_sim), .o_sim_immv(dcd_sim_immv)\n`ifdef\tFORMAL\n\t\t\t, .f_insn_word(f_dcd_insn_word),\n\t\t\t.f_insn_gie(f_dcd_insn_gie),\n\t\t\t.f_insn_is_pipeable(f_dcd_insn_is_pipeable)\n`endif\n\t\t// }}}\n\t);\n\n\tassign\t{ dcd_Rcc, dcd_Rpc, dcd_R } = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ? dcd_full_R : 7'h0;\n\tassign\t{ dcd_Acc, dcd_Apc, dcd_A } = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ? dcd_full_A : 7'h0;\n\tassign\t{ dcd_Bcc, dcd_Bpc, dcd_B } = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ? dcd_full_B : 7'h0;\n\tassign\tdcd_gie = pf_gie;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// PIPELINE STAGE #3 :: Read Operands (Registers)\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// op_pipe\n\t// {{{\n\tgenerate if (OPT_PIPELINED_BUS_ACCESS)\n\tbegin : GEN_OP_PIPE // Memory pipelining",
            "reg r_op_pipe;\n\n\t\t// To be a pipeable operation, there must be\n\t\t//\ttwo valid adjacent instructions\n\t\t//\tBoth must be memory instructions\n\t\t//\tBoth must be writes, or both must be reads\n\t\t//\tBoth operations must be to the same identical address,\n\t\t//\t\tor at least a single (one) increment above that\n\t\t//\t\taddress\n\t\t//\n\t\t// However ... we need to know this before this clock, hence\n\t\t// this is calculated in the instruction decoder.\n\t\tinitial\tr_op_pipe = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif ((OPT_LOWPOWER && i_reset)||(clear_pipeline)||(i_halt))\n\t\t\tr_op_pipe <= 1'b0;\n\t\telse if (op_ce)\n\t\t\tr_op_pipe <= (dcd_pipe)&&(op_valid_mem)&&(!OPT_LOWPOWER || !dcd_illegal);\n\t\telse if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == op_Bid[4:0]))\n\t\t\tr_op_pipe <= 1'b0;\n\t\telse if (mem_ce) // Clear us any time an op_ is clocked in\n\t\t\tr_op_pipe <= 1'b0;\n\n\t\tassign\top_pipe = r_op_pipe;\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (OPT_LOWPOWER && !op_valid_mem)\n\t\t\tassert(!r_op_pipe);\n`endif\n\tend else begin : NO_OP_PIPE\n\n\t\tassign\top_pipe = 1'b0;\n\n\tend endgenerate\n\t// }}}\n\n\t// Read from our",
            "reg ister set\n\t// {{{\n\tgenerate if (OPT_DISTRIBUTED_REGS)\n\tbegin : GEN_DISTRIBUTED_REGS\n\t\t// {{{\n\t\tif (OPT_USERMODE)\n\t\tbegin : GEN_FULL_REGSET\n\n\t\t\tassign\tw_op_Av = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ?",
            "reg set[dcd_A] : 32'h0;\n\t\t\tassign\tw_op_Bv = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ?",
            "reg set[dcd_B] : 32'h0;\n\n\t\tend else begin : GEN_NO_USERREGS\n\t\t\tassign\tw_op_Av = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ?",
            "reg set[dcd_A[3:0]] : 32'h0;\n\t\t\tassign\tw_op_Bv = (!OPT_LOWPOWER || dcd_valid || !OPT_PIPELINED) ?",
            "reg set[dcd_B[3:0]] : 32'h0;\n\t\tend\n\n\t\t// verilator coverage_off\n\t\t// verilator lint_off UNUSED",
            "wire unused_pre",
            "reg _addrs;\n\t\tassign\tunused_pre",
            "reg _addrs = &{ 1'b0, dcd_preA, dcd_preB };\n\t\t// verilator lint_on  UNUSED\n\t\t// verilator coverage_on\n\t\t// }}}\n\tend else begin : GEN_BLOCKRAM\n\t\t// {{{",
            "reg [31:0]\tpre_rewrite_value, pre_op_Av, pre_op_Bv;",
            "reg pre_rewrite_flag_A, pre_rewrite_flag_B;\n\n\t\talways @(posedge i_clk)\n\t\tif (dcd_ce)\n\t\tbegin\n\t\t\tpre_rewrite_flag_A <= (wr_",
            "reg _ce)&&(dcd_preA == wr_",
            "reg _id);\n\t\t\tpre_rewrite_flag_B <= (wr_",
            "reg _ce)&&(dcd_preB == wr_",
            "reg _id);\n\t\t\tpre_rewrite_value  <= wr_gp",
            "reg _vl;\n\t\tend else if (OPT_PIPELINED && dcd_valid)\n\t\tbegin\n\t\t\tpre_rewrite_flag_A <= (wr_",
            "reg _ce)&&(dcd_A == wr_",
            "reg _id);\n\t\t\tpre_rewrite_flag_B <= (wr_",
            "reg _ce)&&(dcd_B == wr_",
            "reg _id);\n\t\t\tpre_rewrite_value  <= wr_gp",
            "reg _vl;\n\t\tend\n\n\t\tif (OPT_USERMODE)\n\t\tbegin : GEN_FULL_REGSET\n\n\t\t\talways @(posedge i_clk)\n\t\t\tif (dcd_ce || (OPT_PIPELINED && dcd_valid))\n\t\t\t\tpre_op_Av <=",
            "reg set[dcd_ce ? dcd_preA : dcd_A];\n\n\t\t\talways @(posedge i_clk)\n\t\t\tif (dcd_ce || (OPT_PIPELINED && dcd_valid))\n\t\t\t\tpre_op_Bv <=",
            "reg set[dcd_ce ? dcd_preB : dcd_B];\n\n\t\tend else begin : GEN_NO_USERREGS\n\t\t\talways @(posedge i_clk)\n\t\t\tif (dcd_ce || (OPT_PIPELINED && dcd_valid))\n\t\t\t\tpre_op_Av <=",
            "reg set[dcd_ce ? dcd_preA[3:0] : dcd_A[3:0]];\n\n\t\t\talways @(posedge i_clk)\n\t\t\tif (dcd_ce || (OPT_PIPELINED && dcd_valid))\n\t\t\t\tpre_op_Bv <=",
            "reg set[dcd_ce ? dcd_preB[3:0] : dcd_B[3:0]];\n\t\tend\n\n\t\tassign\tw_op_Av = (pre_rewrite_flag_A) ? pre_rewrite_value : pre_op_Av;\n\t\tassign\tw_op_Bv = (pre_rewrite_flag_B) ? pre_rewrite_value : pre_op_Bv;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\tassign\tw_cpu_info = {\n\t// {{{\n\t1'b1,\n\t(OPT_MPY    >0)? 1'b1:1'b0,\n\t(OPT_DIV >0)? 1'b1:1'b0,\n\t(IMPLEMENT_FPU    >0)? 1'b1:1'b0,\n\tOPT_PIPELINED,\n\t1'b0,\n\t(OPT_EARLY_BRANCHING > 0)? 1'b1:1'b0,\n\tOPT_PIPELINED_BUS_ACCESS,\n\tOPT_CIS\n\t};\n\t// }}}\n\n\talways @(*)\n\tbegin\n\t\tw_pcA_v = 0;\n\t\tif ((!OPT_USERMODE)||(dcd_A[4] == dcd_gie))\n\t\t\tw_pcA_v[(AW+1):0] = { dcd_pc[AW+1:2], 2'b00 };\n\t\telse\n\t\t\tw_pcA_v[(AW+1):0] = { upc[(AW+1):2], uhalt_phase, 1'b0 };\n\tend\n\n\t// Op",
            "reg ister addresses\n\t// {{{\n\tgenerate if (OPT_PIPELINED)\n\tbegin : OP_REG_ADVANEC\n\t\t// {{{",
            "reg [4:0]\tr_op_R;",
            "reg [4:0]\tr_op_Aid, r_op_Bid;",
            "reg r_op_rA, r_op_rB;\n\n\t\tinitial\tr_op_R   = 0;\n\t\tinitial\tr_op_Aid = 0;\n\t\tinitial\tr_op_Bid = 0;\n\t\tinitial\tr_op_rA  = 0;\n\t\tinitial\tr_op_rB  = 0;\n\t\tinitial\top_Rcc = 0;\n\t\talways @(posedge i_clk)\n\t\tbegin\n\t\t\tif (op_ce && (!OPT_LOWPOWER || w_op_valid))\n\t\t\tbegin\n\t\t\t\tr_op_R   <= dcd_R;\n\t\t\t\tr_op_Aid <= dcd_A;\n\t\t\t\tif ((dcd_rB)&&(!dcd_early_branch)&&(!dcd_illegal))\n\t\t\t\t\tr_op_Bid <= dcd_B;\n\t\t\t\tr_op_rA  <= (dcd_rA)&&(!dcd_early_branch)&&(!dcd_illegal);\n\t\t\t\tr_op_rB  <= (dcd_rB)&&(!dcd_early_branch)&&(!dcd_illegal);\n\t\t\t\top_Rcc <= (dcd_Rcc)&&(dcd_wR)&&(dcd_R[4]==dcd_gie);\n\t\t\tend\n\n\t\t\tif (op_lowpower_clear)\n\t\t\tbegin\n\t\t\t\tr_op_rA <= 1'b0;\n\t\t\t\tr_op_rB <= 1'b0;\n\t\t\tend\n\t\tend\n\n\t\tassign\top_R   = r_op_R;\n\t\tassign\top_Aid = r_op_Aid;\n\t\tassign\top_Bid = r_op_Bid;\n\t\tassign\top_rA  = r_op_rA;\n\t\tassign\top_rB  = r_op_rB;\n\t\t// }}}\n\tend else begin : OP_REG_COPY\n\t\t// {{{\n\t\tassign\top_R = dcd_R;\n\t\tassign\top_Aid = dcd_A;\n\t\tassign\top_Bid = dcd_B;\n\t\tassign\top_rA  = dcd_rA;\n\t\tassign\top_rB  = dcd_rB;\n\n\t\talways @(*)\n\t\t\top_Rcc = (dcd_Rcc)&&(dcd_wR)&&(dcd_R[4]==dcd_gie);\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// r_op_Av -- The",
            "reg istered value of the op A",
            "reg ister\n\t// {{{",
            "reg [2:0]\tavsrc;",
            "reg [2:0]\tbvsrc;",
            "reg [1:0]\tbisrc;\n\n\talways @(*)\n\tbegin\n\t\tavsrc = 3'b000;\n\t\tif (!OPT_PIPELINED || op_ce)\n\t\tbegin\n\t\t\tif (dcd_Apc)\n\t\t\t\tavsrc = 3'b101;\n\t\t\telse if (dcd_Acc)\n\t\t\t\tavsrc = 3'b110;\n\t\t\telse\n\t\t\t\tavsrc = 3'b111;\n\t\tend\n\n\t\tif (OPT_PIPELINED && wr_",
            "reg _ce)\n\t\tbegin\n\t\t\tif (!op_ce && wr_",
            "reg _id == op_Aid && op_rA)\n\t\t\t\tavsrc = 3'b100;\n\t\t\telse if (op_ce && wr_",
            "reg _id == dcd_A)\n\t\t\t\tavsrc = 3'b100;\n\t\tend\n\tend\n\n// 44313\n\tinitial\tr_op_Av = 0;\n\talways @(posedge i_clk)\n\tbegin\n\t\tif (avsrc[2])\n\t\tcase(avsrc[1:0])\n\t\t2'b00:\tr_op_Av <= wr_gp",
            "reg _vl;\n\t\t2'b01:\tr_op_Av <= w_pcA_v;\n\t\t2'b10:\tr_op_Av <= { w_cpu_info, w_op_Av[22:16], (dcd_A[4])?w_uflags:w_iflags };\n\t\t2'b11:\tr_op_Av <= w_op_Av;\n\t\tendcase\n\n\t\tif (op_lowpower_clear)\n\t\t\tr_op_Av <= 0;\n\tend\n\t// }}}\n\n\t// w_op_B -- The",
            "reg istered value of the op B",
            "reg ister\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tw_pcB_v = 0;\n\t\tif ((!OPT_USERMODE)||(dcd_B[4] == dcd_gie))\n\t\t\tw_pcB_v[(AW+1):0] = { dcd_pc[AW+1:2], 2'b00 };\n\t\telse\n\t\t\tw_pcB_v[(AW+1):0] = { upc[(AW+1):2], uhalt_phase, 1'b0 };\n\tend\n\n\talways @(*)\n\tif (!dcd_rB)\n\t\tbisrc = 0;\n\telse if ((OPT_PIPELINED)&&(wr_",
            "reg _ce)&&(wr_",
            "reg _id == dcd_B))\n\t\tbisrc = 1;\n\telse if (dcd_Bcc)\n\t\tbisrc = 2;\n\telse\n\t\tbisrc = 3;\n\n\talways @(*)\n\tcase(bisrc[1:0])\n\t2'b00: w_op_BnI = 0;\n\t2'b01: w_op_BnI = wr_gp",
            "reg _vl;\n\t2'b10: w_op_BnI = { w_cpu_info, w_op_Bv[22:16],\n\t\t\t\t(dcd_B[4]) ? w_uflags : w_iflags };\n\t2'b11: w_op_BnI = w_op_Bv;\n\tendcase\n\n\talways @(*)\n\tbegin\n\t\tbvsrc = 0;\n\t\tif ((!OPT_PIPELINED)||(op_ce))\n\t\tbegin\n\t\t\tif ((dcd_Bpc)&&(dcd_rB))\n\t\t\t\tbvsrc = 3'b100;\n\t\t\telse\n\t\t\t\tbvsrc = 3'b101;\n\t\tend else if ((OPT_PIPELINED)&&(op_rB)\n\t\t\t&&(wr_",
            "reg _ce)&&(op_Bid == wr_",
            "reg _id))\n\t\t\tbvsrc = 3'b110;\n\tend\n\n\tinitial\tr_op_Bv = 0;\n\talways @(posedge i_clk)\n\tbegin\n\t\tif (bvsrc[2]) casez(bvsrc[1:0])\n\t\t2'b00: r_op_Bv <= w_pcB_v + { dcd_I[29:0], 2'b00 };\n\t\t2'b01: r_op_Bv <= w_op_BnI + dcd_I;\n\t\t2'b1?: r_op_Bv <= wr_gp",
            "reg _vl;\n\t\tendcase\n\n\t\tif (op_lowpower_clear)\n\t\t\tr_op_Bv <= 0;\n\tend\n\t// }}}\n\n\t// op_F\n\t// {{{\n\t// The",
            "logic here has become more complex than it should be, no thanks\n\t// to Xilinx's Vivado trying to help.  The conditions are supposed to\n\t// be two sets of four bits: the top bits specify what bits matter, the\n\t// bottom specify what those top bits must equal.  However, two of\n\t// conditions check whether bits are on, and those are the only two\n\t// conditions checking those bits.  Therefore, Vivado complains that\n\t// these two bits are redundant.  Hence the convoluted expression\n\t// below, arriving at what we finally want in the (now",
            "wire net)\n\t// op_F.\n\tinitial\tr_op_F = 7'h00;\n\talways @(posedge i_clk)\n\tbegin\n\t\tif ((!OPT_PIPELINED)||(op_ce))\n\t\t\t// Cannot do op_change_data_ce here since op_F depends\n\t\t\t// upon being either correct for a valid op, or correct\n\t\t\t// for the last valid op\n\t\tbegin // Set the flag condition codes, bit order is [3:0]=VNCZ\n\t\t\tcase(dcd_F[2:0])\n\t\t\t3'h0:\tr_op_F <= 7'h00;\t// Always\n\t\t\t3'h1:\tr_op_F <= 7'h11;\t// Z\n\t\t\t3'h2:\tr_op_F <= 7'h44;\t// LT\n\t\t\t3'h3:\tr_op_F <= 7'h22;\t// C\n\t\t\t3'h4:\tr_op_F <= 7'h08;\t// V\n\t\t\t3'h5:\tr_op_F <= 7'h10;\t// NE\n\t\t\t3'h6:\tr_op_F <= 7'h40;\t// GE (!N)\n\t\t\t3'h7:\tr_op_F <= 7'h20;\t// NC\n\t\t\tendcase\n\t\tend\n\n\t\tif (op_lowpower_clear)\n\t\t\tr_op_F <= 7'h00;\n\tend // Bit order is { (flags_not_used), VNCZ mask, VNCZ value }\n\tassign\top_F = { r_op_F[3], r_op_F[6:0] };\n\t// }}}\n\n\t// op_valid\n\t// {{{\n\tassign\tw_op_valid = (!clear_pipeline)&&(dcd_valid)\n\t\t\t\t\t&&(!dcd_ljmp)&&(!dcd_early_branch);\n\n\tinitial\top_valid     = 1'b0;\n\tinitial\top_valid_alu = 1'b0;\n\tinitial\top_valid_mem = 1'b0;\n\tinitial\top_valid_div = 1'b0;\n\tinitial\top_valid_fpu = 1'b0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(clear_pipeline))\n\tbegin\n\t\t// {{{\n\t\top_valid     <= 1'b0;\n\t\top_valid_alu <= 1'b0;\n\t\top_valid_mem <= 1'b0;\n\t\top_valid_div <= 1'b0;\n\t\top_valid_fpu <= 1'b0;\n\t\t// }}}\n\tend else if (op_ce)\n\tbegin\n\t\t// {{{\n\t\t// Do we have a valid instruction?\n\t\t//   The decoder may vote to stall one of its\n\t\t//   instructions based upon something we currently\n\t\t//   have in our queue.  This instruction must then\n\t\t//   move forward, and get a stall cycle inserted.\n\t\t//   Hence, the test on dcd_stalled here.  If we must\n\t\t//   wait until our operands are valid, then we aren't\n\t\t//   valid yet until then.\n\t\tif (OPT_PIPELINED || !op_valid)\n\t\tbegin\n\t\t\top_valid     <= (w_op_valid)||(dcd_early_branch);\n\t\t\top_valid_alu <= (w_op_valid)&&((dcd_ALU)||(dcd_illegal));\n\t\t\top_valid_mem <= (dcd_M)&&(!dcd_illegal)\n\t\t\t\t\t&&(w_op_valid);\n\t\t\top_valid_div <= (OPT_DIV)&&(dcd_DIV)&&(!dcd_illegal)&&(w_op_valid);\n\t\t\top_valid_fpu <= (IMPLEMENT_FPU)&&(dcd_FP)&&(!dcd_illegal)&&(w_op_valid);\n\t\tend else if ((adf_ce_unconditional)||(mem_ce))\n\t\tbegin\n\t\t\top_valid     <= 1'b0;\n\t\t\top_valid_alu <= 1'b0;\n\t\t\top_valid_mem <= 1'b0;\n\t\t\top_valid_div <= 1'b0;\n\t\t\top_valid_fpu <= 1'b0;\n\t\tend\n\t\t// }}}\n\tend else if ((adf_ce_unconditional)||(mem_ce))\n\tbegin\n\t\t// {{{\n\t\t// If nothing advances into the OP stage, yet what was in\n\t\t// the OP stage moves forward, then we need to invalidate what\n\t\t// used to be here.\n\t\top_valid     <= 1'b0;\n\t\top_valid_alu <= 1'b0;\n\t\top_valid_mem <= 1'b0;\n\t\top_valid_div <= 1'b0;\n\t\top_valid_fpu <= 1'b0;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// op_lowpower_clear\n\t// {{{\n\tgenerate if (!OPT_LOWPOWER || !OPT_PIPELINED)\n\tbegin : NO_OP_LOWPOWER_CLEAR\n\n\t\tassign\top_lowpower_clear = 1'b0;\n\n\tend else begin : GEN_OP_LOWPOWER_CLEAR",
            "reg r_op_lowpower_clear;\n\n\t\talways @(*)\n\t\tif (i_reset || clear_pipeline)\n\t\t\tr_op_lowpower_clear = 1'b1;\n\t\telse if (op_ce && !w_op_valid)\n\t\t\tr_op_lowpower_clear = 1'b1;\n\t\telse if ((!op_ce || !w_op_valid)&&(adf_ce_unconditional || mem_ce))\n\t\t\tr_op_lowpower_clear = 1'b1;\n\t\telse\n\t\t\tr_op_lowpower_clear = 1'b0;\n\n\t\tassign\top_lowpower_clear = r_op_lowpower_clear;\n\tend endgenerate\n\t// }}}\n\n\t// op_break\n\t// {{{\n\t// Here's part of our debug interface.  When we recognize a break\n\t// instruction, we set the op_break flag.  That'll prevent this\n\t// instruction from entering the ALU, and cause an interrupt before\n\t// this instruction.  Thus, returning to this code will cause the\n\t// break to repeat and continue upon return.  To get out of this\n\t// condition, replace the break instruction with what it is supposed\n\t// to be, step through it, and then replace it back.  In this fashion,\n\t// a debugger can step through code.\n\t// assign w_op_break = (dcd_break)&&(r_dcd_I[15:0] == 16'h0001);\n\n\tinitial\tr_op_break = 1'b0;\n\talways @(posedge i_clk)\n\tif (clear_pipeline)\n\t\tr_op_break <= 1'b0;\n\telse if ((OPT_PIPELINED)&&(op_ce))\n\t\tr_op_break <= (dcd_valid)&&(dcd_break)&&(!dcd_illegal);\n\telse if ((!OPT_PIPELINED)&&(dcd_valid))\n\t\tr_op_break <= (dcd_break)&&(!dcd_illegal)&&(!step || !stepped);\n\n\tassign\top_break = r_op_break;\n`ifdef\tFORMAL\n\talways @(*)\n\tif (op_break)\n\t\tassert(op_valid || clear_pipeline);\n`endif\n\t// }}}\n\n\t// op_lock\n\t// {{{\n\tgenerate if (!OPT_LOCK)\n\tbegin : NO_OPLOCK\n\n\t\tassign op_lock       = 1'b0;\n\n\t\t// verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire dcd_lock_unused;\n\t\tassign\tdcd_lock_unused = &{ 1'b0, dcd_lock };\n\t\t// Verilator lint_on  UNUSED\n\t\t// verilator coverage_on\n\n\tend else // if (!OPT_LOCK)\n\tbegin : GEN_OPLOCK",
            "reg r_op_lock;\n\n\t\tinitial\tr_op_lock = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (clear_pipeline)\n\t\t\tr_op_lock <= 1'b0;\n\t\telse if (op_ce)\n\t\t\tr_op_lock <= (dcd_valid)&&(dcd_lock)\n\t\t\t\t\t&&(!dcd_illegal);\n\t\tassign\top_lock = r_op_lock;\n\n\tend endgenerate\n\t// }}}\n\n\t// op_illegal\n\t// {{{\n\tinitial\top_illegal = 1'b0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(clear_pipeline))\n\t\top_illegal <= 1'b0;\n\telse if (OPT_PIPELINED)\n\tbegin\n\t\tif (op_ce)\n\t\t\top_illegal <= (dcd_valid)&&(!dcd_ljmp)\n\t\t\t\t&&(!dcd_early_branch)&&(dcd_illegal);\n\tend else if (!OPT_PIPELINED)\n\tbegin\n\t\tif (dcd_valid)\n\t\t\top_illegal <= (!dcd_ljmp)&&(!dcd_early_branch)&&(dcd_illegal);\n\tend\n\t// }}}\n\n\t// op_wF\n\t// {{{\n\talways @(posedge i_clk)\n\tbegin\n\t\tif ((!OPT_PIPELINED)||(op_ce))\n\t\t\top_wF <= (dcd_wF)&&((!dcd_Rcc)||(!dcd_wR))\n\t\t\t\t&&(!dcd_early_branch);\n\n\t\tif (op_lowpower_clear)\n\t\t\top_wF <= 1'b0;\n\tend\n\t// }}}\n\n\t// op_wR\n\t// {{{\n\tgenerate if ((OPT_PIPELINED)||(OPT_EARLY_BRANCHING))\n\tbegin : GEN_OP_WR",
            "reg r_op_wR;\n\n\t\tinitial\tr_op_wR = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tbegin\n\t\t\tif (op_ce)\n\t\t\t\tr_op_wR <= (dcd_wR)&&(!dcd_early_branch);\n\t\t\tif (op_lowpower_clear)\n\t\t\t\tr_op_wR <= 1'b0;\n\t\tend\n\n\t\tassign\top_wR = r_op_wR;\n\tend else begin : COPY_OP_WR\n\n\t\tassign\top_wR = dcd_wR;\n\n\tend endgenerate\n\t// }}}\n\n\t// op_sim, op_sim_immv\n\t// {{{\n\tgenerate if (OPT_SIM)\n\tbegin : OP_SIM\n\t\t//\n\t\t// Only execute this if OPT_SIM is true--that is, if we\n\t\t// are running from a simulated environment.\n\t\t//",
            "reg r_op_sim;",
            "reg [22:0]\tr_op_sim_immv;\n\n\t\talways @(posedge i_clk)\n\t\tif (op_ce)\n\t\tbegin\n\t\t\tr_op_sim    <= dcd_sim && (!OPT_LOWPOWER || w_op_valid);\n\t\t\tr_op_sim_immv <= dcd_sim_immv;\n\t\t\tif (OPT_LOWPOWER && (!dcd_sim || !w_op_valid))\n\t\t\t\tr_op_sim_immv <= 0;\n\t\tend else if (adf_ce_unconditional)\n\t\tbegin\n\t\t\tr_op_sim <= 1'b0;\n\t\t\tif (OPT_LOWPOWER)\n\t\t\t\tr_op_sim_immv <= 0;\n\t\tend\n\n\t\tassign\top_sim = r_op_sim;\n\t\tassign\top_sim_immv = r_op_sim_immv;\n\n\tend else begin : NO_OP_SIM\n\n\t\tassign\top_sim = 0;\n\t\tassign\top_sim_immv = 0;\n\n\t\t// verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire op_sim_unused;\n\t\tassign\top_sim_unused = &{ 1'b0, dcd_sim, dcd_sim_immv };\n\t\t// Verilator lint_on  UNUSED\n\t\t// verilator coverage_on\n\tend endgenerate\n\t// }}}\n\n\t// op_pc\n\t// {{{\n\tgenerate if ((OPT_PIPELINED)||(OPT_EARLY_BRANCHING))\n\tbegin : SET_OP_PC",
            "reg [AW+1:0]\tr_op_pc;\n\n\t\tinitial r_op_pc[0] = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (op_ce)\n\t\tbegin\n\t\t\tif (dcd_early_branch)\n\t\t\t\t// Need to retire an early branch as a NOOP,\n\t\t\t\t// to make sure our PC is properly updated\n\t\t\t\tr_op_pc <= dcd_branch_pc;\n\t\t\telse if (!OPT_LOWPOWER || w_op_valid)\n\t\t\t\tr_op_pc <= dcd_pc;\n\t\tend\n\n\t\tassign\top_pc = r_op_pc;\n\n\tend else begin : SET_OP_PC\n\n\t\tassign op_pc = dcd_pc;\n\n\tend endgenerate\n\t// }}}\n\n\t// op_opn -- the opcode of the current operation\n\t// {{{\n\tgenerate if (!OPT_PIPELINED)\n\tbegin : COPY_DCD_OPN\n\n\t\tassign\top_opn = dcd_opn;\n\n\tend else begin : FWD_OPERATION",
            "reg [3:0]\tr_op_opn;\n\n\t\talways @(posedge i_clk)\n\t\tif (op_ce && (!OPT_LOWPOWER || w_op_valid || dcd_early_branch))\n\t\tbegin\n\t\t\t// Which ALU operation?  Early branches are\n\t\t\t// unimplemented moves\n\t\t\tr_op_opn    <= ((dcd_early_branch)||(dcd_illegal))\n\t\t\t\t\t? CPU_MOV_OP : dcd_opn;\n\t\t\t// opM  <= dcd_M;\t// Is this a memory operation?\n\t\t\t// What",
            "reg ister will these results be written into?\n\t\tend\n\n\t\tassign\top_opn = r_op_opn;\n\n\tend endgenerate\n\t// }}}\n\tassign\top_gie = gie;\n\n\tassign\top_Fl = (op_gie)?(w_uflags[3:0]):(w_iflags[3:0]);\n\n\t// op_phase\n\t// {{{\n\tgenerate if (OPT_CIS)\n\tbegin : OPT_CIS_OP_PHASE",
            "reg r_op_phase;\n\n\t\tinitial\tr_op_phase = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif ((i_reset)||(clear_pipeline))\n\t\t\tr_op_phase <= 1'b0;\n\t\telse if (op_ce)\n\t\t\tr_op_phase <= (dcd_phase)&&((!dcd_wR)||(!dcd_Rpc));\n\n\t\tassign\top_phase = r_op_phase;\n\tend else begin : OPT_NOCIS_OP_PHASE\n\t\tassign\top_phase = 1'b0;\n\n\t\t// verilator lint_off UNUSED",
            "wire OPT_CIS_dcdRpc;\n\t\tassign\tOPT_CIS_dcdRpc = dcd_Rpc;\n\t\t// verilator lint_on  UNUSED\n\tend endgenerate\n\t// }}}\n\n\t// op_Av -- the combinatorial A value",
            "input to the ALU/MEM/DIV stage\n\t// {{{\n\t// This is tricky.  First, the PC and Flags",
            "reg isters aren't kept in\n\t//",
            "reg ister set but in special",
            "reg isters of their own.  So step one\n\t// is to select the right",
            "reg ister.  Step to is to replace that\n\t//",
            "reg ister with the results of an ALU or memory operation, if such\n\t// results are now available.  Otherwise, we'd need to insert a wait\n\t// state of some type.\n\t//\n\t// The alternative approach would be to define some sort of\n\t// op_stall",
            "wire , which would stall any upstream stage.\n\t// We'll create a flag here to start our coordination.  Once we\n\t// define this flag to something other than just plain zero, then\n\t// the stalls will already be in place.\n\tgenerate if (OPT_PIPELINED)\n\tbegin : FWD_OP_AV\n\n\t\tassign\top_Av = ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == op_Aid))\n\t\t\t?  wr_gp",
            "reg _vl : r_op_Av;\n\n\tend else begin : COPY_OP_AV\n\n\t\tassign\top_Av = r_op_Av;\n\n\tend endgenerate\n\t// }}}\n\n\t// dcd_A_stall\n\t// {{{\n\t// Stall if we have decoded an instruction that will read",
            "reg ister A\n\t//\tAND ... something that may write a",
            "reg ister is running\n\t//\tAND (series of conditions here ...)\n\t//\t\tThe operation might set flags, and we wish to read the\n\t//\t\t\tCC",
            "reg ister\n\t//\t\tOR ... (No other conditions)\n\tgenerate if (OPT_PIPELINED)\n\tbegin : GEN_DCDA_STALL\n\n\t\tassign\tdcd_A_stall = (dcd_rA) // &&(dcd_valid) is checked for elsewhere\n\t\t\t\t&&((op_valid)||(i_mem_rdbusy)\n\t\t\t\t\t||(div_busy)||(fpu_busy))\n\t\t\t\t&&(((op_wF)||(cc_invalid_for_dcd))&&(dcd_Acc))\n\t\t\t||((dcd_rA)&&(dcd_Acc)&&(cc_invalid_for_dcd));\n\tend else begin : NO_DCDA_STALL\n\n\t\t// There are no pipeline hazards, if we aren't pipelined\n\t\tassign\tdcd_A_stall = 1'b0;\n\n\tend endgenerate\n\t// }}}\n\n\t// op_Bv\n\t// {{{\n\tassign\top_Bv = ((OPT_PIPELINED)&&(wr_",
            "reg _ce)\n\t\t\t\t\t&&(wr_",
            "reg _id == op_Bid)&&(op_rB))\n\t\t\t? wr_gp",
            "reg _vl: r_op_Bv;\n\t// }}}\n\n\t// dcd_B_stall, dcd_F_stall\n\t// {{{\n\tgenerate if (OPT_PIPELINED)\n\tbegin : DCD_BF_STALLS\n\t// Stall if we have decoded an instruction that will read",
            "reg ister B\n\t//\tAND ... something that may write a (unknown)",
            "reg ister is running\n\t//\tAND (series of conditions here ...)\n\t//\t\tThe operation might set flags, and we wish to read the\n\t//\t\t\tCC",
            "reg ister\n\t//\t\tOR the operation might set",
            "reg ister B, and we still need\n\t//\t\t\ta clock to add the offset to it\n\tassign\tdcd_B_stall = (dcd_rB) // &&(dcd_valid) is checked for elsewhere\n\t// {{{\n\t\t\t\t// If the op stage isn't valid, yet something\n\t\t\t\t// is running, then it must have been valid.\n\t\t\t\t// We'll use the last values from that stage\n\t\t\t\t// (op_wR, op_wF, op_R) in our",
            "logic below.\n\t\t\t\t&&((op_valid)||(i_mem_rdbusy)\n\t\t\t\t\t||(div_busy)||(fpu_busy)||(alu_busy))\n\t\t\t\t&&(\n\t\t\t\t// Okay, what happens if the result",
            "reg ister\n\t\t\t\t// from instruction 1 becomes the",
            "input for\n\t\t\t\t// instruction two, *and* there's an immediate\n\t\t\t\t// offset in instruction two?  In that case, we\n\t\t\t\t// need an extra clock between the two\n\t\t\t\t// instructions to calculate the base plus\n\t\t\t\t// offset.\n\t\t\t\t//\n\t\t\t\t// What if instruction 1 (or before) is in a\n\t\t\t\t// memory pipeline?  We may no longer know what\n\t\t\t\t// the",
            "reg ister was!  We will then need  to\n\t\t\t\t// blindly wait.  We'll temper this only waiting\n\t\t\t\t// if we're not piping this new instruction.\n\t\t\t\t// If we were piping, the pipe",
            "logic in the\n\t\t\t\t// decode circuit has told us that the hazard\n\t\t\t\t// is clear, so we're okay then.\n\t\t\t\t//\n\t\t\t\t((!dcd_zI)&&(\n\t\t\t\t\t((op_R == dcd_B)&&(op_wR))\n\t\t\t\t\t||((i_mem_rdbusy)&&(!dcd_pipe))\n\t\t\t\t\t||(((alu_busy ||\n\t\t\t\t\t\tdiv_busy || i_mem_rdbusy))\n\t\t\t\t\t\t&&(alu_",
            "reg == dcd_B))\n\t\t\t\t\t||((wr_",
            "reg _ce)&&(wr_",
            "reg _id[3:1] == 3'h7))\n\t\t\t\t\t))\n\t\t\t\t// Stall following any instruction that will\n\t\t\t\t// set the flags, if we're going to need the\n\t\t\t\t// flags (CC)",
            "reg ister for op_B.\n\t\t\t\t||(((op_wF)||(cc_invalid_for_dcd))&&(dcd_Bcc))\n\t\t\t\t// Stall on any ongoing memory operation that\n\t\t\t\t// will write to op_B -- captured above\n\t\t\t\t// ||((i_mem_busy)&&(!mem_we)&&(mem_last_",
            "reg ==dcd_B)&&(!dcd_zI))\n\t\t\t\t)\n\t\t\t||((dcd_rB)&&(dcd_Bcc)&&(cc_invalid_for_dcd));\n\t\t// }}}\n\t\tassign\tdcd_F_stall = ((!dcd_F[3])\n\t\t// {{{\n\t\t\t\t\t||((dcd_rA)&&(dcd_A[3:1]==3'h7)\n\t\t\t\t\t\t&&(dcd_A[4:0] != { gie, 4'hf}))\n\t\t\t\t\t||((dcd_rB)&&(dcd_B[3:1]==3'h7))\n\t\t\t\t\t\t&&(dcd_B[4:0] != { gie, 4'hf}))\n\t\t\t\t\t&&(((op_valid)&&(op_wR)\n\t\t\t\t\t\t&&(op_R[3:1]==3'h7)\n\t\t\t\t\t\t&&(op_R[4:0]!={gie, 4'hf}))\n\t\t\t\t\t\t||(pending_s",
            "reg _write));\n\t\t\t\t// &&(dcd_valid) is checked for elsewhere\n\t\t// }}}\n\tend else begin : NO_PIPELINE_NO_STALL\n\t\t// {{{\n\t\t// No stalls without pipelining, 'cause how can you have a\n\t\t// pipeline hazard without the pipeline?\n\t\tassign\tdcd_B_stall = 1'b0;\n\t\tassign\tdcd_F_stall = 1'b0;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// PIPELINE STAGE #4 :: Apply Instruction\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// The ALU itself\n\tcpuops\t#(\n\t\t// {{{\n\t\t.OPT_MPY(OPT_MPY),\n\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER)\n\t\t// }}}\n\t) doalu(\n\t// {{{\n\t\t.i_clk(i_clk), .i_reset((i_reset)||(clear_pipeline)),\n\t\t.i_stb(alu_ce),\n\t\t.i_op((!OPT_LOWPOWER || alu_ce) ? op_opn : 4'h0),\n\t\t.i_a( (!OPT_LOWPOWER || alu_ce) ? op_Av  : 32'h0),\n\t\t.i_b( (!OPT_LOWPOWER || alu_ce) ? op_Bv  : 32'h0),\n\t\t.o_c(alu_result), .o_f(alu_flags),\n\t\t.o_valid(alu_valid),\n\t\t.o_busy(alu_busy)\n\t// }}}\n\t);\n\n\t// Divide\n\t// {{{\n\tgenerate if (OPT_DIV != 0)\n\tbegin : DIVIDE\n`ifdef\tFORMAL\n`define\tDIVIDE_MODULE\tabs_div\n`else\n`define\tDIVIDE_MODULE\tdiv\n`endif\n\t\t`DIVIDE_MODULE #(\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER)\n\t\t) thedivide(\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset || clear_pipeline),\n\t\t\t\t.i_wr(div_ce), .i_signed(op_opn[0]),\n\t\t\t.i_numerator(op_Av), .i_denominator(op_Bv),\n\t\t\t.o_busy(div_busy), .o_valid(div_valid),\n\t\t\t\t.o_err(div_error), .o_quotient(div_result),\n\t\t\t.o_flags(div_flags)\n\t\t\t// }}}\n\t\t);\n\n\tend else begin : NO_DIVIDE\n\t\t// {{{\n\t\tassign\tdiv_error = 1'b0; // Can't be high unless div_valid\n\t\tassign\tdiv_busy  = 1'b0;\n\t\tassign\tdiv_valid = 1'b0;\n\t\tassign\tdiv_result= 32'h00;\n\t\tassign\tdiv_flags = 4'h0;\n\n\t\t// Make verilator happy here\n\t\t// verilator coverage_off\n\t\t// verilator lint_off UNUSED",
            "wire unused_divide;\n\t\tassign\tunused_divide = &{ 1'b0, div_ce };\n\t\t// verilator lint_on  UNUSED\n\t\t// verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// (Non-existent) FPU\n\t// {{{\n\tgenerate if (IMPLEMENT_FPU != 0)\n\tbegin : FPU\n\t\t//\n\t\t// sfpu thefpu(i_clk, i_reset, fpu_ce, op_opn[2:0],\n\t\t//\top_Av, op_Bv, fpu_busy, fpu_valid, fpu_err, fpu_result,\n\t\t//\tfpu_flags);\n\t\t//\n`ifdef\tFORMAL\n\t\tabs_div thefpu(i_clk, ((i_reset)||(clear_pipeline)),\n\t\t\t\tfpu_ce, op_opn[2:0],\n\t\t\top_Av, op_Bv, fpu_busy, fpu_valid, fpu_error, fpu_result,\n\t\t\tfpu_flags);\n\n`else\n\t\tassign\tfpu_error = 1'b0; // Must only be true if fpu_valid\n\t\tassign\tfpu_busy  = 1'b0;\n\t\tassign\tfpu_valid = 1'b0;\n\t\tassign\tfpu_result= 32'h00;\n\t\tassign\tfpu_flags = 4'h0;\n`endif\n\tend else begin : GEN_NOFPU\n\t\tassign\tfpu_error = 1'b0;\n\t\tassign\tfpu_busy  = 1'b0;\n\t\tassign\tfpu_valid = 1'b0;\n\t\tassign\tfpu_result= 32'h00;\n\t\tassign\tfpu_flags = 4'h0;\n\tend endgenerate\n\t// }}}\n\n\t// Condition handling\n\t// {{{\n\tassign\tset_cond = ((op_F[7:4]&op_Fl[3:0])==op_F[3:0]);\n\tinitial\talu_wF   = 1'b0;\n\tinitial\talu_wR   = 1'b0;\n\tgenerate if (OPT_PIPELINED)\n\tbegin : GEN_COND_PIPELINED\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\tbegin\n\t\t\talu_wR   <= 1'b0;\n\t\t\talu_wF   <= 1'b0;\n\t\tend else if (alu_ce)\n\t\tbegin\n\t\t\t// alu_",
            "reg <= op_R;\n\t\t\talu_wR  <= (op_wR)&&(set_cond)&&(!op_illegal);\n\t\t\talu_wF  <= (op_wF)&&(set_cond)&&(!op_illegal);\n\t\tend else if (!alu_busy)\n\t\tbegin\n\t\t\t// These are strobe signals, so clear them if they\n\t\t\t// aren't going to be set for any particular clock\n\t\t\talu_wR <= (r_halted)&&(OPT_DBGPORT && i_dbg_we && !o_dbg_stall);\n\t\t\talu_wF <= 1'b0;\n\t\tend\n\tend else begin : GEN_COND_NOPIPE\n\n\t\talways @(posedge i_clk)\n\t\tbegin\n\t\t\talu_wR  <= (op_wR)&&(set_cond)&&(!op_illegal);\n\t\t\talu_wF  <= (op_wF)&&(set_cond)&&(!op_illegal);\n\t\tend\n\n\tend endgenerate\n\t// }}}\n\n\t// alu_phase\n\t// {{{\n\t// Instruction phase (which half of the instruction we are on) tracking\n\tgenerate if (OPT_CIS)\n\tbegin : GEN_ALU_PHASE",
            "reg r_alu_phase;\n\n\t\tinitial\tr_alu_phase = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif ((i_reset)||(clear_pipeline))\n\t\t\tr_alu_phase <= 1'b0;\n\t\telse if (((adf_ce_unconditional)||(mem_ce))&&(op_valid))\n\t\t\tr_alu_phase <= op_phase;\n\t\telse if ((adf_ce_unconditional)||(mem_ce))\n\t\t\tr_alu_phase <= 1'b0;\n\n\t\tassign\talu_phase = r_alu_phase;\n\tend else begin : NO_ALUPHASE\n\n\t\tassign\talu_phase = 1'b0;\n\tend endgenerate\n\t// }}}\n\n\t// alu_",
            "reg // {{{\n\tgenerate if (OPT_PIPELINED)\n\tbegin : GEN_ALUREG_PIPE\n\n\t\talways @(posedge i_clk)\n\t\tif (alu_ce || div_ce || o_mem_ce || fpu_ce)\n\t\t\talu_",
            "reg <= op_R;\n\t\telse if (OPT_DBGPORT && i_dbg_we && !o_dbg_stall)\n\t\t\talu_",
            "reg <= i_dbg_w",
            "reg ;\n\n\tend else begin : GEN_ALUREG_NOPIPE\n\n\t\talways @(posedge i_clk)\n\t\tif (OPT_DBGPORT && i_dbg_we && !o_dbg_stall)\n\t\t\talu_",
            "reg <= i_dbg_w",
            "reg ;\n\t\telse\n\t\t\talu_",
            "reg <= op_R;\n\tend endgenerate\n\t// }}}\n\n\t// wr_index\n\t// {{{\n\tinitial\twr_index = 0;\n\talways @(posedge i_clk)\n\tbegin\n\t\tif ((OPT_PIPELINED && (mem_ce || adf_ce_unconditional))\n\t\t\t||(!OPT_PIPELINED && op_valid))\n\t\tbegin\n\t\t\twr_index <= 0;\n\t\t\t/*\n\t\t\tif (op_valid_mem)\n\t\t\t\twr_index <= 3'b001;\n\t\t\tif (op_valid_alu)\n\t\t\t\twr_index <= 3'b010;\n\t\t\tif (op_valid_div)\n\t\t\t\twr_index <= 3'b011;\n\t\t\tif (op_valid_fpu)\n\t\t\t\twr_index <= 3'b100;\n\t\t\t*/\n\n\t\t\twr_index[0] <= (op_valid_mem | op_valid_div);\n\t\t\twr_index[1] <= (op_valid_alu | op_valid_div);\n\t\t\twr_index[2] <= (op_valid_fpu);\n\t\tend\n\n\t\tif (OPT_DBGPORT && i_dbg_we && !o_dbg_stall)\n\t\t\twr_index <= 3'b000;\n\n\t\tif (!IMPLEMENT_FPU)\n\t\t\twr_index[2] <= 1'b0;\n\tend\n\t// }}}\n\n\t//\n\t// DEBUG Register write access starts here\n\t//\n\t// {{{\n\tinitial\tdbgv = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || !r_halted)\n\t\tdbgv <= 0;\n\telse\n\t\tdbgv <= OPT_DBGPORT && i_dbg_we && !o_dbg_stall;\n\n\talways @(posedge i_clk)\n\tif (!OPT_LOWPOWER || (OPT_DBGPORT && i_dbg_we))\n\t\tdbg_val <= i_dbg_data;\n\n\t// dbg_clear_pipe\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_reset || clear_pipeline || !r_halted)\n\t\tdbg_clear_pipe <= 0;\n\telse if (OPT_DBGPORT && i_dbg_we && !o_dbg_stall)\n\tbegin\n\t\tdbg_clear_pipe <= 1'b0;\n\n\t\tif (!OPT_PIPELINED)\n\t\t\tdbg_clear_pipe <= 1'b1;\n\t\tif ((i_dbg_w",
            "reg == op_Bid)&&(op_rB))\n\t\t\tdbg_clear_pipe <= 1'b1;\n\t\tif (i_dbg_w",
            "reg [3:1] == 3'h7)\n\t\t\tdbg_clear_pipe <= 1'b1;\n\tend else if ((!OPT_PIPELINED)&&(i_clear_cache && !o_dbg_stall))\n\t\tdbg_clear_pipe <= 1'b1;\n\telse\n\t\tdbg_clear_pipe <= 1'b0;\n\t// }}}\n\n\tassign\talu_gie = gie;\n\t// }}}\n\n\t// r_alu_pc\n\t// {{{\n\tgenerate if (OPT_PIPELINED)\n\tbegin : GEN_ALU_PC",
            "reg [(AW+1):0]\tr_alu_pc;\n\t\tinitial\tr_alu_pc = 0;\n\t\talways @(posedge i_clk)\n\t\tif ((adf_ce_unconditional)\n\t\t\t\t||((master_ce)&&(op_valid_mem)\n\t\t\t\t\t&&(!clear_pipeline)&&(!mem_stalled)))\n\t\t\tr_alu_pc  <= op_pc;\n\t\tassign\talu_pc = r_alu_pc;\n\n\tend else begin : GEN_ALU_PC_NOPIPE\n\n\t\tassign\talu_pc = op_pc;\n\n\tend endgenerate\n\t// }}}\n\n\t// r_alu_illegal\n\t// {{{\n\tgenerate if (OPT_PIPELINED)\n\tbegin : SET_ALU_ILLEGAL",
            "reg r_alu_illegal;\n\n\t\tinitial\tr_alu_illegal = 0;\n\t\talways @(posedge i_clk)\n\t\tif (clear_pipeline)\n\t\t\tr_alu_illegal <= 1'b0;\n\t\telse if (adf_ce_unconditional)\n\t\t\tr_alu_illegal <= op_illegal;\n\t\telse\n\t\t\tr_alu_illegal <= 1'b0;\n\n\t\tassign\talu_illegal = (r_alu_illegal);\n\tend else begin : SET_ALU_ILLEGAL\n\t\tassign\talu_illegal = op_illegal;\n\tend endgenerate\n\t// }}}\n\n\t// r_alu_pc_valid, mem_pc_valid\n\t// {{{\n\tinitial\tr_alu_pc_valid = 1'b0;\n\tinitial\tmem_pc_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (clear_pipeline)\n\t\tr_alu_pc_valid <= 1'b0;\n\telse if ((adf_ce_unconditional)&&(!op_phase))\n\t\tr_alu_pc_valid <= 1'b1;\n\telse if (((!alu_busy)&&(!div_busy)&&(!fpu_busy))||(clear_pipeline))\n\t\tr_alu_pc_valid <= 1'b0;\n\n\tassign\talu_pc_valid = (r_alu_pc_valid)\n\t\t\t&&((!alu_busy)&&(!div_busy)&&(!fpu_busy));\n\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tmem_pc_valid <= 1'b0;\n\telse\n\t\tmem_pc_valid <= (mem_ce);\n\t// }}}\n\n\t// Bus lock",
            "logic // {{{\n\tgenerate if (OPT_LOCK)\n\tbegin : BUSLOCK",
            "reg r_prelock_stall;",
            "reg [1:0]\tr_bus_lock;",
            "reg [AW+1:0]\tr_lock_pc;\n\n\t\t// r_prelock_stall\n\t\t// {{{\n\t\tinitial\tr_prelock_stall = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (!OPT_PIPELINED || clear_pipeline)\n\t\t\tr_prelock_stall <= 1'b0;\n\t\telse if (op_valid && op_lock && r_bus_lock == 2'b00\n\t\t\t\t\t\t&& adf_ce_unconditional)\n\t\t\tr_prelock_stall <= 1'b1;\n\t\telse if (op_valid && dcd_valid\n\t\t\t\t\t&& (i_pf_valid || dcd_early_branch))\n\t\t\tr_prelock_stall <= 1'b0;\n\t\t// }}}\n\n\t\t// r_lock_pc\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (op_valid && op_ce && op_lock)\n\t\t\tr_lock_pc <= op_pc-4;\n`ifdef\tFORMAL\n\t\talways @(posedge i_clk)\n\t\t\tcover(op_valid && op_ce && op_lock);\n`endif\n\t\t// }}}\n\n\t\t// r_bus_lock\n\t\t// {{{\n\t\t// Count 3 cycles.  The lock will only hold solid for three\n\t\t// cycles after the LOCK instruction is received.  Count those\n\t\t// cycles here.\n\t\tinitial\tr_bus_lock = 2'b00;\n\t\talways @(posedge i_clk)\n\t\tif (clear_pipeline)\n\t\t\tr_bus_lock <= 2'b00;\n\t\telse if (op_valid && (adf_ce_unconditional||mem_ce))\n\t\tbegin\n\t\t\tif (r_bus_lock != 2'b00)\n\t\t\t\tr_bus_lock <= r_bus_lock - 1;\n\t\t\telse if (op_lock)\n\t\t\t\tr_bus_lock <= 2'b11;\n\t\tend\n\t\t// }}}\n\n\t\tassign\tprelock_stall = OPT_PIPELINED && r_prelock_stall;\n\t\tassign\to_bus_lock    = |r_bus_lock;\n\t\tassign\to_mem_lock_pc = r_lock_pc;\n\t\tassign\tlast_lock_insn = (r_bus_lock <= 1);\n`ifdef\tFORMAL\n\t\t// {{{\n\t\tif (OPT_PIPELINED)\n\t\tbegin\n\t\t\t(* anyconst *)",
            "reg r_nojump_lock;\n\n\t\t\talways @(*)\n\t\t\tif (r_nojump_lock && (r_prelock_stall || r_bus_lock))\n\t\t\tbegin\n\t\t\t\tassume(!dcd_early_branch);\n\t\t\t\tassume(!dcd_ljmp);\n\t\t\tend\n\n\t\t\talways @(*)\n\t\t\tif (!clear_pipeline) case(r_bus_lock)\n\t\t\t2'b11: if (!prelock_stall && r_nojump_lock)\n\t\t\t\tbegin\n\t\t\t\tassert(op_valid && dcd_valid && i_pf_valid);\n\t\t\t\tend\n\t\t\t2'b10:\tbegin\n\t\t\t\tassert(!prelock_stall);\n\t\t\t\tif (r_nojump_lock)\n\t\t\t\tbegin\n\t\t\t\t\tassert(dcd_valid);\n\t\t\t\t\tassert(op_valid + dcd_valid + i_pf_valid >= 2'b10);\n\t\t\t\tend end\n\t\t\t2'b01: begin\n\t\t\t\tassert(!prelock_stall);\n\t\t\t\tif (r_nojump_lock && !dcd_illegal)\n\t\t\t\tbegin\n\t\t\t\t\tassert(op_valid || dcd_valid\n\t\t\t\t\t\t\t|| i_pf_valid);\n\t\t\t\tend end\n\t\t\t2'b00: assert(!prelock_stall);\n\t\t\tendcase\n\t\tend else begin\n\n\t\t\talways @(*)\n\t\t\t\tassert(!prelock_stall);\n\t\tend\n\t\t// }}}\n`endif\n\tend else begin : NO_BUSLOCK\n\t\t// {{{\n\t\tassign\tprelock_stall = 1'b0;\n\t\tassign\to_bus_lock    = 1'b0;\n\t\tassign\to_mem_lock_pc = 0;\n\t\tassign\tlast_lock_insn= 1;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// Memory interface\n\t// {{{\n\t// This",
            "logic is now managed outside the ZipCore\n\t//\n\tassign\to_mem_ce   = mem_ce && set_cond;\n\tassign\to_mem_op   = ((mem_ce && set_cond) || !OPT_LOWPOWER) ? op_opn[2:0] : 3'h0;\n\tassign\to_mem_data = ((mem_ce && set_cond) || !OPT_LOWPOWER) ? op_Av : 32'h0;\n\tassign\to_mem_addr = ((mem_ce && set_cond) || !OPT_LOWPOWER) ? op_Bv : 32'h0;\n\tassign\to_mem_",
            "reg = ((mem_ce && set_cond) || !OPT_LOWPOWER) ? op_R : 5'h0;\n\n\t// }}}\n\n\t// Sim instructions, alu_sim, alu_sim_immv\n\t// {{{",
            "wire cpu_sim;\n\n\tgenerate if (OPT_SIM)\n\tbegin : ALU_SIM",
            "reg r_alu_sim;",
            "reg [22:0]\tr_alu_sim_immv;",
            "wire [4:0]",
            "reg id;\n\n\t\tassign",
            "reg id = { (OPT_USERMODE && gie), op_sim_immv[3:0]};\n\n\t\tif (OPT_USERMODE)\n\t\tbegin : GEN_ALLSIM\n\t\t\t// {{{\n\t\t\tassign\tcpu_sim = !i_reset && !clear_pipeline\n\t\t\t\t\t&& adf_ce_unconditional && set_cond\n\t\t\t\t\t&& op_sim && op_valid_alu\n\t\t\t\t\t&&(!wr_",
            "reg _ce || !wr_write_pc\n\t\t\t\t\t\t|| wr_",
            "reg _id[4] != alu_gie);\n\n\t\t\tinitial\tr_alu_sim = 1'b0;\n\t\t\talways @(posedge i_clk)\n\t\t\tbegin\n\t\t\t\tif (cpu_sim)\n\t\t\t\tbegin\n\t\t\t\t// Execute simulation only instructions\n\t\t\t\t// {{{\n\t\t\t\tif ((op_sim_immv[19:10] == 10'h0)&&(op_sim_immv[8]))\n\t\t\t\tbegin // [N/S]EXIT\n\t\t\t\t\t// {{{\n\t\t\t\t\t$finish;\n\n\t\t\t\t\t// if (op_sim_immv[19:4] == 16'h0031)\n\t\t\t\t\t\t// Exit(User",
            "reg ), code cpu_wr_gp",
            "reg // Verilog offers no support for this.\n\t\t\t\t\t\t// Veri1ator might, but it isn't\n\t\t\t\t\t\t// standard.\n\t\t\t\t\t// if (op_sim_immv[19:4] == 16'h0030)\n\t\t\t\t\t\t// Exit(Normal",
            "reg ), code cpu_wr_gp",
            "reg // $finish;\n\t\t\t\t\t// if (op_sim_immv[19:8] == 12'h001)\n\t\t\t\t\t\t// Exit(Immediate), code cpu_wr_gp",
            "reg // $finish;\n\t\t\t\t\t// }}}\n\t\t\t\tend\n\n\t\t\t\tif (op_sim_immv[19:0] == 20'h2ff)\n\t\t\t\tbegin\n\t\t\t\t\t// DUMP all",
            "reg isters\n\t\t\t\t\t// {{{\n\t\t\t\t\tif (!op_gie)\n\t\t\t\t\tbegin\n\t\t\t\t\t$write(\"sR0 : %08x \",",
            "reg set[0]);\n\t\t\t\t\t$write(\"sR1 : %08x \",",
            "reg set[1]);\n\t\t\t\t\t$write(\"sR2 : %08x \",",
            "reg set[2]);\n\t\t\t\t\t$write(\"sR3 : %08x\\n\",",
            "reg set[3]);\n\n\t\t\t\t\t$write(\"sR4 : %08x \",",
            "reg set[4]);\n\t\t\t\t\t$write(\"sR5 : %08x \",",
            "reg set[5]);\n\t\t\t\t\t$write(\"sR6 : %08x \",",
            "reg set[6]);\n\t\t\t\t\t$write(\"sR7 : %08x\\n\",",
            "reg set[7]);\n\n\t\t\t\t\t$write(\"sR8 : %08x \",",
            "reg set[8]);\n\t\t\t\t\t$write(\"sR9 : %08x \",",
            "reg set[9]);\n\t\t\t\t\t$write(\"sR10: %08x \",",
            "reg set[10]);\n\t\t\t\t\t$write(\"sR11: %08x\\n\",",
            "reg set[11]);\n\n\t\t\t\t\t$write(\"sR12: %08x \",",
            "reg set[12]);\n\t\t\t\t\t$write(\"sSP : %08x \",",
            "reg set[13]);\n\t\t\t\t\t$write(\"sCC : %08x \", w_iflags);\n\t\t\t\t\t$write(\"sPC : %08x\\n\", (!op_gie) ? op_pc : ipc);\n\t\t\t\t\t$write(\"\\n\", (!op_gie) ? op_pc : ipc);\n\t\t\t\t\tend\n\n\t\t\t\t\t$write(\"uR0 : %08x \",",
            "reg set[16]);\n\t\t\t\t\t$write(\"uR1 : %08x \",",
            "reg set[17]);\n\t\t\t\t\t$write(\"uR2 : %08x \",",
            "reg set[18]);\n\t\t\t\t\t$write(\"uR3 : %08x\\n\",",
            "reg set[19]);\n\n\t\t\t\t\t$write(\"uR4 : %08x \",",
            "reg set[20]);\n\t\t\t\t\t$write(\"uR5 : %08x \",",
            "reg set[21]);\n\t\t\t\t\t$write(\"uR6 : %08x \",",
            "reg set[22]);\n\t\t\t\t\t$write(\"uR7 : %08x\\n\",",
            "reg set[23]);\n\n\t\t\t\t\t$write(\"uR8 : %08x \",",
            "reg set[24]);\n\t\t\t\t\t$write(\"uR9 : %08x \",",
            "reg set[25]);\n\t\t\t\t\t$write(\"uR10: %08x \",",
            "reg set[26]);\n\t\t\t\t\t$write(\"uR11: %08x\\n\",",
            "reg set[27]);\n\n\t\t\t\t\t$write(\"uR12: %08x \",",
            "reg set[28]);\n\t\t\t\t\t$write(\"uSP : %08x \",",
            "reg set[29]);\n\t\t\t\t\t$write(\"uCC : %08x \", w_uflags);\n\t\t\t\t\t$write(\"uPC : %08x\\n\", (op_gie) ? op_pc : upc);\n\t\t\t\t\t// }}}\n\t\t\t\tend\n\n\t\t\t\tif (op_sim_immv[19:4] == 16'h0020)\n\t\t\t\tbegin\n\t\t\t\t\t// Dump a",
            "reg ister\n\t\t\t\t\t// {{{\n\t\t\t\t\t$write(\"@%08x \", op_pc);\n\t\t\t\t\t$write(\"%c\", (op_gie) ? \"s\":\"u\");\n\t\t\t\t\t$write(\"R[%2d] = 0x\", op_sim_immv[3:0]);\n\t\t\t\t\t// Dump a",
            "reg ister\n\t\t\t\t\tif (wr_",
            "reg _ce && wr_",
            "reg _id ==",
            "reg id)\n\t\t\t\t\t\t$display(\"%08x\", wr_gp",
            "reg _vl);\n\t\t\t\t\telse\n\t\t\t\t\t\t$display(\"%08x\",",
            "reg set[",
            "reg id]);\n\t\t\t\t\t// }}}\n\t\t\t\tend\n\t\t\t\tif (op_sim_immv[19:4] == 16'h0021)\n\t\t\t\tbegin\n\t\t\t\t\t// Dump a user",
            "reg ister\n\t\t\t\t\t// {{{\n\t\t\t\t\t$write(\"@%08x u\", op_pc);\n\t\t\t\t\t$write(\"R[%2d] = 0x\", op_sim_immv[3:0]);\n\t\t\t\t\tif (wr_",
            "reg _ce && wr_",
            "reg _id == { 1'b1, op_sim_immv[3:0] })\n\t\t\t\t\t\t$display(\"%08x\\n\", wr_gp",
            "reg _vl);\n\t\t\t\t\telse\n\t\t\t\t\t\t$display(\"%08x\\n\",",
            "reg set[{ 1'b1,\n\t\t\t\t\t\t\t\top_sim_immv[3:0]}]);\n\t\t\t\t\t// }}}\n\t\t\t\tend\n\t\t\t\tif (op_sim_immv[19:4] == 16'h0023)\n\t\t\t\tbegin\n\t\t\t\t\t// SOUT(user",
            "reg ister)\n\t\t\t\t\t// {{{\n\t\t\t\t\tif (wr_",
            "reg _ce && wr_",
            "reg _id == { 1'b1, op_sim_immv[3:0] })\n\t\t\t\t\t\t$write(\"%c\", wr_gp",
            "reg _vl[7:0]);\n\t\t\t\t\telse\n\t\t\t\t\t\t$write(\"%c\",",
            "reg set[{ 1'b1, op_sim_immv[3:0]}][7:0]);\n\t\t\t\t\t// }}}\n\t\t\t\tend\n\t\t\t\tif (op_sim_immv[19:4] == 16'h0022)\n\t\t\t\tbegin\n\t\t\t\t\t// SOUT(",
            "reg ister)\n\t\t\t\t\t// {{{\n\t\t\t\t\tif (wr_",
            "reg _ce && wr_",
            "reg _id ==",
            "reg id)\n\t\t\t\t\t\t$write(\"%c\", wr_gp",
            "reg _vl[7:0]);\n\t\t\t\t\telse\n\t\t\t\t\t\t$write(\"%c\",",
            "reg set[",
            "reg id][7:0]);\n\t\t\t\t\t// }}}\n\t\t\t\tend\n\n\t\t\t\tif (op_sim_immv[19:8] == 12'h004)\n\t\t\t\tbegin\n\t\t\t\t\t// SOUT(Immediate)\n\t\t\t\t\t// {{{\n\t\t\t\t\t$write(\"%c\", op_sim_immv[7:0]);\n\t\t\t\t\t// }}}\n\t\t\t\tend\n\n\t\t\t\t// ELSE unrecognized SIM instruction\n\n\t\t\t\t// Set alu_sim either way\n\t\t\t\tr_alu_sim <= 1'b1;\n\t\t\t\t// }}}\n\t\t\t\tend else\n\t\t\t\t\tr_alu_sim <= 1'b0;\n\n\t\t\t\tif (adf_ce_unconditional)\n\t\t\t\t\tr_alu_sim_immv <= op_sim_immv;\n\t\t\tend\n\t\t\t// }}}\n\t\tend else begin : GEN_NO_USERSIM\n\t\t\t// {{{\n\t\t\tassign\tcpu_sim = !i_reset && !clear_pipeline\n\t\t\t\t\t&& adf_ce_unconditional && set_cond\n\t\t\t\t\t&& op_sim && op_valid_alu\n\t\t\t\t\t&&(!wr_",
            "reg _ce || !wr_write_pc\n\t\t\t\t\t\t|| wr_",
            "reg _id[4] != alu_gie);\n\n\t\t\tinitial\tr_alu_sim = 1'b0;\n\t\t\talways @(posedge i_clk)\n\t\t\tbegin\n\t\t\t\tif (cpu_sim)\n\t\t\t\tbegin\n\t\t\t\t// Execute simulation only instructions\n\t\t\t\t// {{{\n\t\t\t\tif ((op_sim_immv[19:10] == 10'h0)&&(op_sim_immv[8]))\n\t\t\t\tbegin // [N/S]EXIT\n\t\t\t\t\t// {{{\n\t\t\t\t\t$finish;\n\n\t\t\t\t\t// if (op_sim_immv[19:4] == 16'h0031)\n\t\t\t\t\t\t// Exit(User",
            "reg ), code cpu_wr_gp",
            "reg // Verilog offers no support for this.\n\t\t\t\t\t\t// Veri1ator might, but it isn't\n\t\t\t\t\t\t// standard.\n\t\t\t\t\t// if (op_sim_immv[19:4] == 16'h0030)\n\t\t\t\t\t\t// Exit(Normal",
            "reg ), code cpu_wr_gp",
            "reg // $finish;\n\t\t\t\t\t// if (op_sim_immv[19:8] == 12'h001)\n\t\t\t\t\t\t// Exit(Immediate), code cpu_wr_gp",
            "reg // $finish;\n\t\t\t\t\t// }}}\n\t\t\t\tend\n\n\t\t\t\tif (op_sim_immv[19:0] == 20'h2ff)\n\t\t\t\tbegin\n\t\t\t\t\t// DUMP all",
            "reg isters\n\t\t\t\t\t// {{{\n\t\t\t\t\tif (!op_gie)\n\t\t\t\t\tbegin\n\t\t\t\t\t$write(\" R0 : %08x \",",
            "reg set[0]);\n\t\t\t\t\t$write(\" R1 : %08x \",",
            "reg set[1]);\n\t\t\t\t\t$write(\" R2 : %08x \",",
            "reg set[2]);\n\t\t\t\t\t$write(\" R3 : %08x\\n\",",
            "reg set[3]);\n\n\t\t\t\t\t$write(\" R4 : %08x \",",
            "reg set[4]);\n\t\t\t\t\t$write(\" R5 : %08x \",",
            "reg set[5]);\n\t\t\t\t\t$write(\" R6 : %08x \",",
            "reg set[6]);\n\t\t\t\t\t$write(\" R7 : %08x\\n\",",
            "reg set[7]);\n\n\t\t\t\t\t$write(\" R8 : %08x \",",
            "reg set[8]);\n\t\t\t\t\t$write(\" R9 : %08x \",",
            "reg set[9]);\n\t\t\t\t\t$write(\" R10: %08x \",",
            "reg set[10]);\n\t\t\t\t\t$write(\" R11: %08x\\n\",",
            "reg set[11]);\n\n\t\t\t\t\t$write(\" R12: %08x \",",
            "reg set[12]);\n\t\t\t\t\t$write(\" SP : %08x \",",
            "reg set[13]);\n\t\t\t\t\t$write(\" CC : %08x \", w_iflags);\n\t\t\t\t\t$write(\" PC : %08x\\n\", op_pc);\n\t\t\t\t\tend\n\n\t\t\t\t\t// }}}\n\t\t\t\tend\n\n\t\t\t\tif (op_sim_immv[19:5] == 15'h0010)\n\t\t\t\tbegin\n\t\t\t\t\t// Dump a",
            "reg ister\n\t\t\t\t\t// {{{\n\t\t\t\t\t$write(\"@%08x \", op_pc);\n\t\t\t\t\t$write(\" R[%2d] = 0x\", op_sim_immv[3:0]);\n\t\t\t\t\t// Dump a",
            "reg ister\n\t\t\t\t\tif (wr_",
            "reg _ce&&wr_",
            "reg _id[3:0] ==",
            "reg id[3:0])\n\t\t\t\t\t\t$display(\"%08x\", wr_gp",
            "reg _vl);\n\t\t\t\t\telse\n\t\t\t\t\t\t$display(\"%08x\",",
            "reg set[",
            "reg id[3:0]]);\n\t\t\t\t\t// }}}\n\t\t\t\tend\n\t\t\t\tif (op_sim_immv[19:5] == 15'h0011)\n\t\t\t\tbegin\n\t\t\t\t\t// SOUT(user",
            "reg ister)\n\t\t\t\t\t// {{{\n\t\t\t\t\tif (wr_",
            "reg _ce && wr_",
            "reg _id[3:0] == op_sim_immv[3:0])\n\t\t\t\t\t\t$write(\"%c\", wr_gp",
            "reg _vl[7:0]);\n\t\t\t\t\telse\n\t\t\t\t\t\t$write(\"%c\",",
            "reg set[op_sim_immv[3:0]][7:0]);\n\t\t\t\t\t// }}}\n\t\t\t\tend\n\n\t\t\t\tif (op_sim_immv[19:8] == 12'h004)\n\t\t\t\tbegin\n\t\t\t\t\t// SOUT(Immediate)\n\t\t\t\t\t// {{{\n\t\t\t\t\t$write(\"%c\", op_sim_immv[7:0]);\n\t\t\t\t\t// }}}\n\t\t\t\tend\n\n\t\t\t\t// ELSE unrecognized SIM instruction\n\n\t\t\t\t// Set alu_sim either way\n\t\t\t\tr_alu_sim <= 1'b1;\n\t\t\t\t// }}}\n\t\t\t\tend else\n\t\t\t\t\tr_alu_sim <= 1'b0;\n\n\t\t\t\tif (adf_ce_unconditional)\n\t\t\t\t\tr_alu_sim_immv <= op_sim_immv;\n\t\t\tend\n\n\t\t\t// Verilator lint_off UNUSED",
            "wire unused_simmv;\n\t\t\tassign\tunused_simmv = &{ 1'b0,",
            "reg id[4] };\n\t\t\t// Verilator lint_on  UNUSED\n\t\t\t// }}}\n\t\tend\n\n\t\tassign\talu_sim      = r_alu_sim;\n\t\tassign\talu_sim_immv = r_alu_sim_immv;\n\n\tend else begin : NO_ALU_SIM\n\n\t\tassign\talu_sim = 0;\n\t\tassign\talu_sim_immv = 0;\n\t\tassign\tcpu_sim = 0;\n\n\tend endgenerate\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// PIPELINE STAGE #5 :: Write-back results\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// This stage is not allowed to stall.  If results are ready to be\n\t// written back, they are written back at all cost.  Sleepy CPU's\n\t// won't prevent write back, nor debug modes, halting the CPU, nor\n\t// anything else.  Indeed, the (master_ce) bit is only as relevant\n\t// as knowinig something is available for writeback.\n\n\t// (was) wr_discard, wr_",
            "reg _ce\n\t// {{{\n\t//\n\t// Write back to our generic",
            "reg ister set ...\n\t// When shall we write back?  On one of two conditions\n\t//\tNote that the flags needed to be checked before issuing the\n\t//\tbus instruction, so they don't need to be checked here.\n\t//\tFurther, alu_wR includes (set_cond), so we don't need to\n\t//\tcheck for that here either.  It also includes alu_illegal, so\n\t//\tagain--doesn't need to be checked again here.\n\n/*\n\t// 12",
            "input s.  This implementation is made worse by wr_index.\n\talways @(*)\n\tcase(wr_index)\n\t3'b000: wr_",
            "reg _ce  = dbgv;\n\t3'b001: wr_",
            "reg _ce  = i_mem_valid;\n\t//3'b010: wr_",
            "reg _ce = (!clear_pipeline)&&(alu_wR && alu_valid);\n\t3'b011: wr_",
            "reg _ce  = (!clear_pipeline)&&(div_valid)&&(!div_error);\n\t3'b1??: wr_",
            "reg _ce  = (!clear_pipeline)&&(fpu_valid)&&(!fpu_error);\n\tdefault: wr_",
            "reg _ce = (!clear_pipeline)&&(alu_wR && alu_valid);\n\tendcase\n*/\n\t// 7-LUT -- without FPU or wr_index (which wasn't needed)\n\talways @(*)\n\tbegin\n\t\twr_",
            "reg _ce = dbgv || i_mem_valid;\n\t\tif ((alu_wR && alu_valid)\n\t\t\t\t||(div_valid && !div_error)\n\t\t\t\t||(fpu_valid && !fpu_error))\n\t\t\twr_",
            "reg _ce = wr_",
            "reg _ce || !clear_pipeline;\n\tend\n`ifdef\tFORMAL\n\talways @(*)\n\tif (!i_reset && ((alu_wR && alu_valid)\n\t\t\t\t||(div_valid && !div_error)\n\t\t\t\t||(fpu_valid && !fpu_error)))\n\t\tassert(!dbgv && !i_mem_valid);\n\n\talways @(*)\n\tif (!i_reset)\n\tcasez(wr_index)\n\t3'b000: assert(!i_mem_valid && (!alu_wR || !alu_valid)\n\t\t\t&& (!div_valid || div_error)\n\t\t\t&& (!fpu_valid || fpu_error));\n\t3'b001: assert(!dbgv && (!alu_wR || !alu_valid)\n\t\t\t&& (!div_valid || div_error)\n\t\t\t&& (!fpu_valid || fpu_error));\n\t3'b010: assert(!dbgv && !i_mem_valid\n\t\t\t// && (!alu_wR || !alu_valid)\n\t\t\t&& (!div_valid || div_error)\n\t\t\t&& (!fpu_valid || fpu_error));\n\t3'b011: assert(!dbgv && !i_mem_valid\n\t\t\t&& (!alu_wR || !alu_valid)\n\t\t\t// && (!div_valid || div_error)\n\t\t\t&& (!fpu_valid || fpu_error));\n\t3'b100: assert(!dbgv && !i_mem_valid\n\t\t\t&& (!alu_wR || !alu_valid)\n\t\t\t&& (!div_valid || div_error));\n\t\t\t// && (!fpu_valid || fpu_error);\n\tdefault: assert(0);\n\tendcase\n`endif\n\t// }}}\n\n\t// wr_",
            "reg _id, wr_write-cc, wr_write_scc, wr_write_ucc, wr_write_pc\n\t// {{{\n\t// Which",
            "reg ister shall be written?\n\t//\tCOULD SIMPLIFY THIS: by adding three bits to these",
            "reg isters,\n\t//\t\tOne or PC, one for CC, and one for GIE match\n\t//\tNote that the alu_",
            "reg is the",
            "reg ister to write on a divide or\n\t//\tFPU operation.\n\tgenerate if (OPT_USERMODE)\n\tbegin : GEN_USERREG\n\t\tassign\twr_",
            "reg _id = (i_mem_valid) ? i_mem_w",
            "reg : alu_",
            "reg ;\n\tend else begin : NO_USERREG\n\t\tassign\twr_",
            "reg _id[3:0] = (i_mem_valid)\n\t\t\t\t\t? i_mem_w",
            "reg [3:0] : alu_",
            "reg [3:0];\n\n\t\tassign\twr_",
            "reg _id[4] = 1'b0;\n\tend endgenerate\n\n\t// Are we writing to the CC",
            "reg ister?\n\t// one 5-LUT ea\n\tassign\twr_write_cc = (wr_",
            "reg _id[3:0] == CPU_CC_REG);\n\tassign\twr_write_scc = (wr_",
            "reg _id[4:0] == {1'b0, CPU_CC_REG});\n\tassign\twr_write_ucc = (wr_",
            "reg _id[4:0] == {1'b1, CPU_CC_REG});\n\t// Are we writing to the PC?\n\tassign\twr_write_pc = (wr_",
            "reg _id[3:0] == CPU_PC_REG);\n\t// }}}\n\n\t// wr_?p",
            "reg _vl: Select from among sources the value to be writtena\n\t// {{{\n\t// One 6-LUT per bit, or 32 6-LUTs w/o FPU\n\talways @(*)\n\tcasez(wr_index)\n\t3'b000: wr_gp",
            "reg _vl = dbg_val;\n\t3'b001: wr_gp",
            "reg _vl = i_mem_result;\n\t// 3'b010: wr_gp",
            "reg _vl = alu_result;\n\t3'b011: wr_gp",
            "reg _vl = div_result;\n\t3'b1??: wr_gp",
            "reg _vl = fpu_result;\n\tdefault: wr_gp",
            "reg _vl = alu_result;\n\tendcase\n\n\t// One 6-LUT per bit, or 32 6-LUTs\n\talways @(*)\n\tcase(wr_index[1:0])\n\t2'b00: wr_sp",
            "reg _vl = dbg_val;\n\t2'b01: wr_sp",
            "reg _vl = i_mem_result;\n\t// 3'b010: wr_gp",
            "reg _vl = alu_result;\n\tdefault: wr_sp",
            "reg _vl = alu_result;\n\tendcase\n\t// }}}\n\n\t// Update the",
            "reg ister set\n\t// {{{\n\tgenerate if (OPT_USERMODE)\n\tbegin : SET_REGISTERS\n\n\t\talways @(posedge i_clk)\n\t\tif (wr_",
            "reg _ce)",
            "reg set[wr_",
            "reg _id] <= wr_gp",
            "reg _vl;\n\n\tend else begin : SET_SREGISTERS\n\n\t\talways @(posedge i_clk)\n\t\tif (wr_",
            "reg _ce)",
            "reg set[wr_",
            "reg _id[3:0]] <= wr_gp",
            "reg _vl;\n\n\tend endgenerate\n\t// }}}\n\n\t//\n\t// Write back to the condition codes/flags",
            "reg ister ...\n\n\t// wr_flags_ce : should condition codes be written to?\n\t// {{{\n\t// When shall we write to our flags",
            "reg ister?  alu_wF already\n\t// includes the set condition ...\n\t// assign\twr_flags_ce = (alu_wF)&&((alu_valid)\n\t\t\t\t// ||(div_valid)||(fpu_valid))\n\t\t\t\t// &&(!clear_pipeline)&&(!alu_illegal);\n/*\n\t// 10",
            "input s\n\talways @(*)\n\tbegin\n\t\twr_flags_ce = 0;\n\t\tif (alu_wF && !clear_pipeline) // Includes !alu_illegal in wF\n\t\tcase(wr_index)\n\t\t// 3'b000: wr_flags_ce = 0; // Debug\n\t\t// 3'b001: wr_flags_ce = 0; // Memory\n\t\t3'b010: wr_flags_ce = alu_valid; // ALU\n\t\t3'b011: wr_flags_ce = div_valid && !div_error; // DIV\n\t\t3'b1??: wr_flags_ce = fpu_valid && !fpu_error; // FPU\n\t\tdefault: wr_flags_ce = 0;\n\t\tendcase\n\tend\n*/\n\t// 7-LUT -- since we don't need wr_index\n\talways @(*)\n\tbegin\n\t\twr_flags_ce = alu_valid || (div_valid && !div_error)\n\t\t\t\t|| (fpu_valid && !fpu_error);\n\t\tif (!alu_wF || clear_pipeline)\n\t\t\twr_flags_ce = 1'b0;\n\tend\n`ifdef\tFORMAL\n\talways @(*)\n\tif (!i_reset)\n\tbegin\n\t\tcasez(wr_index)\n\t\t3'b000:\tassert(wr_flags_ce == 1'b0);\n\t\t3'b001:\tassert(wr_flags_ce == 1'b0);\n\t\t3'b010:\tassert(wr_flags_ce == (alu_wF && !clear_pipeline && alu_valid));\n\t\t3'b011:\tassert(wr_flags_ce == (alu_wF && !clear_pipeline && div_valid && !div_error));\n\t\t3'b100:\tassert(IMPLEMENT_FPU && wr_flags_ce == (alu_wF && !clear_pipeline && fpu_valid && !fpu_error));\n\t\tdefault: assert(0);\n\t\tendcase\n\n\t\tif (alu_illegal)\n\t\t\tassert(!div_valid && !fpu_valid\n\t\t\t\t&& (!alu_wF || !alu_valid));\n\tend\n`endif\n\t// }}}\n\n\t// wr_flags: what should the new condition codes be?\n\t// {{{\n\talways @(*)\n\tbegin\n\t\twr_flags = 0;\n\t\tcasez(wr_index)\n\t\t3'b010: wr_flags = alu_flags;\n\t\t3'b011: wr_flags = div_flags;\n\t\t3'b1??: wr_flags = fpu_flags;\n\t\tdefault: wr_flags = 0;\n\t\tendcase\n\tend\n\t// }}}\n\n\t// w_uflags, w_iflags : Define the current CC",
            "reg isters\n\t// {{{\n\tassign\tw_uflags = { 2'b00, uhalt_phase, ufpu_err_flag,\n\t\t\tudiv_err_flag, ubus_err_flag, trap, ill_err_u,\n\t\t\tubreak, !gie && user_step, 1'b1, sleep,\n\t\t\t(wr_flags_ce &&  alu_gie) ? wr_flags :  flags };\n\tassign\tw_iflags = { 2'b00, ihalt_phase, ifpu_err_flag,\n\t\t\tidiv_err_flag, ibus_err_flag, trap, ill_err_i,\n\t\t\tbreak_en, 1'b0, 1'b0, sleep,\n\t\t\t(wr_flags_ce && !alu_gie) ? wr_flags : iflags };\n\t// }}}\n\n\t// flags: The user condition codes, Z, C, N, and V\n\t// {{{\n\t// What value to write?\n\talways @(posedge i_clk)\n\t// If explicitly writing the",
            "reg ister itself\n\tif (wr_",
            "reg _ce && wr_write_ucc)\n\t\tflags <= wr_gp",
            "reg _vl[3:0];\n\t// Otherwise if we're setting the flags from an ALU operation\n\telse if (wr_flags_ce && alu_gie)\n\t\tflags <= wr_flags;\n\t// }}}\n\n\t// iflags: The supervisor condition codes, Z, C, N, and V\n\t// {{{\n\talways @(posedge i_clk)\n\tif (wr_",
            "reg _ce && wr_write_scc)\n\t\tiflags <= wr_gp",
            "reg _vl[3:0];\n\telse if (wr_flags_ce && !alu_gie)\n\t\tiflags <= wr_flags;\n\t// }}}\n\n\t// break_en\n\t// {{{\n\t// The 'break' enable  bit.  This bit can only be set from supervisor\n\t// mode.  It controls what the CPU does upon encountering a break\n\t// instruction.\n\t//\n\t// The goal, upon encountering a break is that the CPU should stop and\n\t// not execute the break instruction, choosing instead to enter into\n\t// either interrupt mode or halt first.\n\t//\tif ((break_en) AND (break_instruction)) // user mode or not\n\t//\t\tHALT CPU\n\t//\telse if (break_instruction) // only in user mode\n\t//\t\tset an interrupt flag, set the user break bit,\n\t//\t\tgo to supervisor mode, allow supervisor to step the CPU.\n\tinitial\tbreak_en = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tbreak_en <= 1'b0;\n\telse if ((wr_",
            "reg _ce)&&(wr_write_scc))\n\t\tbreak_en <= wr_sp",
            "reg _vl[CPU_BREAK_BIT];\n\t// }}}\n\n\t// break_pending\n\t// {{{\n\tgenerate if (OPT_PIPELINED)\n\tbegin : GEN_PENDING_BREAK",
            "reg r_break_pending;\n\n\t\tinitial\tr_break_pending = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (clear_pipeline || !op_valid)\n\t\t\tr_break_pending <= 1'b0;\n\t\telse if (op_break && !r_break_pending)\n\t\t\tr_break_pending <= (!alu_busy)&&(!div_busy)\n\t\t\t\t&&(!fpu_busy)&&(!i_mem_busy)\n\t\t\t\t&&(!wr_",
            "reg _ce) && (!step || !stepped);\n\t\t// else\n\t\t\t// No need to clear this here.  The break will force the\n\t\t\t// pipeline to be cleared above, at which point we can\n\t\t\t// clear this",
            "reg ister.\n\t\t\t// r_break_pending <= 1'b0;\n\n\t\tassign\tbreak_pending = r_break_pending;\n\tend else begin : GEN_BREAK_NOPIPE\n\n\t\tassign\tbreak_pending = op_break;\n\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (!gie && user_step && stepped)\n\t\t\tassert(!op_break);\n`endif\n\tend endgenerate\n\t// }}}\n\n\t// o_break\n\t// {{{\n\t//\n\t// This is a 12-",
            "input equation on an",
            "output .  Can this be\n\t// simplified any?  What happens if o_break is set?  Will it ever\n\t// clear on its own, or does it require a write to the debug port?\n\tassign\to_break = (break_en || !op_gie)&&(break_pending)\n\t\t\t\t&&(!clear_pipeline)\n\t\t\t||(ill_err_i)\n\t\t\t||((!alu_gie)&&(i_bus_err))\n\t\t\t||((!alu_gie)&&(div_error))\n\t\t\t||((!alu_gie)&&(fpu_error))\n\t\t\t||((!alu_gie)&&(alu_illegal)&&(!clear_pipeline));\n\n`ifdef\tFORMAL\n\t// Can I assume that, if break_pending is true, that we're either\n\t// in supervisor mode, or that break_en is set?  If so, can I\n\t// simplify the calculation above?\n\t//\n\t// No, because once break_pending is set, the supervisor can then\n\t// adjust break_en without adjusting the external break.\n\t//\n\t// always @(*)\n\t// if (break_pending)\n\t//\tassert(!op_gie || break_en);\n\n\talways @(*)\n\tif (!alu_gie && alu_illegal && !clear_pipeline)\n\t\tassert(!master_ce);\n\n\t// Do I need to break on the last condition above?\n\talways @(posedge i_clk)\n\tif (!i_reset && $past(!i_reset && !alu_gie && alu_illegal\n\t\t\t\t\t\t&& !clear_pipeline && !dbgv))\n\t\tassert(ill_err_i);\n\n\talways @(*)\n\tif (!i_reset)\n\t\tassert(!dbgv || !alu_valid);\n`endif\n\t// }}}\n\n\t// sleep\n\t// {{{\n\t// The sleep",
            "reg ister.  Setting the sleep",
            "reg ister causes the CPU to\n\t// sleep until the next interrupt.  Setting the sleep",
            "reg ister within\n\t// interrupt mode causes the processor to halt until a reset.  This is\n\t// a panic/fault halt.  The trick is that you cannot be allowed to\n\t// set the sleep bit and switch to supervisor mode in the same\n\t// instruction: users are not allowed to halt the CPU.\n\tinitial\tsleep = 1'b0;\n\tgenerate if (OPT_USERMODE)\n\tbegin : GEN_SLEEP\n\t\t// {{{\n\t\tinitial\tsleep = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || w_switch_to_interrupt)\n\t\t\t// Wake up on any reset or any switch to supervisor mode\n\t\t\tsleep <= 1'b0;\n\t\telse if (wr_",
            "reg _ce && wr_write_cc)\n\t\tbegin\n\t\t\t//\n\t\t\t// !GIE && SLEEP ==> halted\n\t\t\t//  GIE && SLEEP ==> sleep until an interrupt\n\t\t\t//\n\t\t\tif (!alu_gie)\n\t\t\t\t// In supervisor mode, we have no protections.\n\t\t\t\t// The supervisor can set the sleep bit however\n\t\t\t\t// he wants.  Well ... not quite.  Switching to\n\t\t\t\t// user mode and sleep mode should only be\n\t\t\t\t// possible if the interrupt flag isn't set.\n\t\t\t\t// Hence, if an interrupt is pending, then any\n\t\t\t\t// WAIT instruction essentially becomes a NOOP.\n\t\t\t\t//\n\t\t\t\t//\tThus: if (i_interrupt)\n\t\t\t\t//\t\t\t&&(wr_sp",
            "reg _vl[GIE])\n\t\t\t\t//\t\tdon't set the sleep bit\n\t\t\t\t//\totherwise however it would o.w. be set\n\t\t\t\tsleep <= (wr_sp",
            "reg _vl[CPU_SLEEP_BIT])\n\t\t\t\t\t&&((!i_interrupt)\n\t\t\t\t\t\t||(!wr_sp",
            "reg _vl[CPU_GIE_BIT]));\n\t\t\telse if (wr_sp",
            "reg _vl[CPU_GIE_BIT])\n\t\t\t\t// In user mode, however, you can only set the\n\t\t\t\t// sleep mode while remaining in user mode.\n\t\t\t\t// You can't switch to sleep mode *and*\n\t\t\t\t// supervisor mode at the same time, lest you\n\t\t\t\t// halt the CPU.\n\t\t\t\tsleep <= wr_sp",
            "reg _vl[CPU_SLEEP_BIT];\n\t\tend\n\t\t// }}}\n\tend else begin : GEN_NO_USERMODE_SLEEP\n\t\t// {{{\n\t\t// Even with no user mode, we still want to implement a sleep\n\t\t// instruction.  Here, we create an r_sleep_is_halt to\n\t\t// differentiate between the halt and the sleep condition\n\t\t// so that the supervisor can still cause the CPU to sleep.\n\t\t//",
            "reg r_sleep_is_halt;\n\t\tinitial\tr_sleep_is_halt = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_sleep_is_halt <= 1'b0;\n\t\telse if (wr_",
            "reg _ce && wr_write_cc\n\t\t\t\t&&  wr_sp",
            "reg _vl[CPU_SLEEP_BIT]\n\t\t\t\t&& !wr_sp",
            "reg _vl[CPU_GIE_BIT])\n\t\t\t// Setting SLEEP and supervisor mode at the same time\n\t\t\t// halts the CPU.  Halts can only be set here.\n\t\t\t// They can only be cleared on reset.\n\t\t\tr_sleep_is_halt <= 1'b1;\n\n\t\t// Trying to switch to user mode, either via a WAIT or an RTU\n\t\t// instruction will cause the CPU to sleep until an interrupt,\n\t\t// in the NO-USERMODE build.\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || (i_interrupt && !r_sleep_is_halt))\n\t\t\tsleep <= 1'b0;\n\t\telse if ((wr_",
            "reg _ce)&&(wr_write_cc)\n\t\t\t\t&&(wr_sp",
            "reg _vl[CPU_GIE_BIT]))\n\t\t\tsleep <= 1'b1;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// step : debug single-step control\n\t// {{{\n\tinitial\tuser_step = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || !OPT_USERMODE)\n\t\tuser_step <= 1'b0;\n\telse if ((wr_",
            "reg _ce)&&(!alu_gie)&&(wr_write_ucc))\n\t\t// The supervisor can adjust whether or not we are stepping\n\t\t// the user mode process.  This bit does not automatically\n\t\t// clear, but can always be written while in supervisor mode.\n\t\tuser_step <= wr_sp",
            "reg _vl[CPU_STEP_BIT];\n\n\tassign\tstep = user_step && gie;\n\t// }}}\n\n\t// o_clken\n\t// {{{\n\tgenerate if (!OPT_CLKGATE)\n\tbegin : NO_CLOCK_GATE\n\n\t\tassign\tw_clken = 1'b1;\n\t\tassign\to_clken = 1'b1;\n\n\tend else begin : GEN_CLOCK_GATE",
            "reg r_clken;\n\n\t\t// Actual clock gating signal\n\t\t//\n\t\t//\t= r_clken || (i_interrupt&&!i_halt) || i_dbg_we\n\t\t//\n\t\tinitial\tr_clken = !OPT_START_HALTED;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_clken <= !OPT_START_HALTED;\n\t\telse if (i_halt && r_halted && (!OPT_DBGPORT || !i_dbg_we))\n\t\t\tr_clken <= i_mem_busy || !i_halt || o_mem_ce;\n\t\telse if (!i_halt&& (!sleep || i_interrupt || pending_interrupt))\n\t\t\tr_clken <= 1'b1;\n\t\telse // if (sleep || i_halt)\n\t\tbegin\n\t\t\tr_clken <= 1'b0;\n\n\t\t\t// If we are in the middle of a lock operation, then\n\t\t\t// don't shut the clock off\n\t\t\tif (o_bus_lock)\n\t\t\t\tr_clken <= 1'b1;\n\n\t\t\t// If we are in between two compressed instructions\n\t\t\t// from the same word, then don't disable the clock\n\t\t\tif (alu_phase)\n\t\t\t\tr_clken <= 1'b1;\n\n\t\t\t// Don't shut the clock off if we are still busy with\n\t\t\t// any previous operation(s)\n\t\t\tif (i_mem_busy || o_mem_ce\n\t\t\t\t\t|| alu_busy || div_busy || fpu_busy\n\t\t\t\t\t|| wr_",
            "reg _ce ||(OPT_DBGPORT && i_dbg_we)\n\t\t\t\t\t|| i_bus_err)\n\t\t\t\tr_clken <= 1'b1;\n\n\t\t\tif (i_halt && !r_halted)\n\t\t\t\tr_clken <= 1'b1;\n\n\t\t\t// Should we wait for a valid PF result before halting?\n\t\t\t// if (!i_pf_valid) r_clken <= 1'b1;\n\t\t\t// if (!op_valid  && !dcd_illegal)  r_clken <= 1'b1;\n\t\t\t// if (!dcd_valid && !i_pf_illegal) r_clken <= 1'b1;\n\t\tend\n\n\t\tassign\tw_clken = r_clken;\n\n\t\t// Wake up on interrupts, debug write requests, or the raising\n\t\t// of the halt flag if we're not sleeping.\n\t\tassign\to_clken = r_clken || (OPT_DBGPORT && i_dbg_we)\n\t\t\t\t\t|| i_clear_cache\n\t\t\t\t\t|| (!i_halt && (i_interrupt || !sleep));\n\tend endgenerate\n\t// }}}\n\n\t// gie, switch_to_interrupt, release_from_interrupt, r_user_stepped\n\t// {{{\n\t// The GIE",
            "reg ister.  Only interrupts can disable the interrupt",
            "reg ister\n\tgenerate if (OPT_USERMODE)\n\tbegin : GEN_PENDING_INTERRUPT\n\t\t// {{{",
            "reg r_pending_interrupt;",
            "reg r_user_stepped;\n\n\t\t// r_user_stepped is used to make certain that we stop a\n\t\t// user task once a full instruction has been accomplished.\n\t\tinitial\tr_user_stepped = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !gie || !user_step)\n\t\t\tr_user_stepped <= 1'b0;\n\t\t// else if(w_switch_to_interrupt)\n\t\t//\tWhile this is technically what we want, we can wait\n\t\t//\ta clock cycle to speed up the CPU by not depending upon\n\t\t//\tthe complex w_switch_to_interrupt calculation here\n\t\t//\tr_user_stepped <= 1'b0;\n\t\telse if (op_valid && !op_phase && !op_lock && last_lock_insn\n\t\t\t\t&& (adf_ce_unconditional || mem_ce))\n\t\t\tr_user_stepped <= 1'b1;\n\n\t\tinitial\tr_pending_interrupt = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_pending_interrupt <= 1'b0;\n\t\telse if (!gie || w_switch_to_interrupt)\n\t\t\tr_pending_interrupt <= 1'b0;\n\t\telse if (clear_pipeline && (!user_step || !stepped))\n\t\t\tr_pending_interrupt <= 1'b0;\n\t\telse begin\n\t\t\tif (i_interrupt)\n\t\t\t\tr_pending_interrupt <= 1'b1;\n\n\t\t\tif (break_pending)\n\t\t\t\tr_pending_interrupt <= 1'b1;\n\n\t\t\tif (adf_ce_unconditional && op_illegal)\n\t\t\t\tr_pending_interrupt <= 1'b1;\n\n\t\t\tif (((!alu_busy && !i_mem_busy && !div_busy && !fpu_busy)\n\t\t\t\t|| wr_",
            "reg _ce) && user_step && stepped)\n\t\t\t\tr_pending_interrupt <= 1'b1;\n\t\tend\n\n\t\tassign\tpending_interrupt = r_pending_interrupt && !i_halt;\n\n\n\t\tassign\tw_switch_to_interrupt = (gie)&&(\n\t\t\t// On interrupt (obviously)\n\t\t\t((pending_interrupt)\n\t\t\t\t&&(!alu_phase)&&(!o_bus_lock)&&(!i_mem_busy))\n\t\t\t//\n\t\t\t// On division by zero.  If the divide isn't\n\t\t\t// implemented, div_valid and div_error will be short\n\t\t\t// circuited and that",
            "logic will be bypassed\n\t\t\t||(div_error)\n\t\t\t//\n\t\t\t// Same thing on a floating point error.  Note that\n\t\t\t// fpu_error must *never* be set unless fpu_valid is\n\t\t\t// also set as well, else this will fail.\n\t\t\t||(fpu_error)\n\t\t\t//\n\t\t\t//\n\t\t\t||(i_bus_err)\n\t\t\t//\n\t\t\t// If we write to the CC",
            "reg ister\n\t\t\t||((wr_",
            "reg _ce)&&(!wr_sp",
            "reg _vl[CPU_GIE_BIT])\n\t\t\t\t&&(wr_",
            "reg _id[4])&&(wr_write_cc))\n\t\t\t);\n\t\tassign\tw_release_from_interrupt = (!gie)&&(!i_interrupt)\n\t\t\t// Then if we write the sCC",
            "reg ister\n\t\t\t&&(((wr_",
            "reg _ce)&&(wr_sp",
            "reg _vl[CPU_GIE_BIT])\n\t\t\t\t&&(wr_write_scc))\n\t\t\t);\n\n`ifdef\tFORMAL\n\t\talways @(posedge i_clk)\n\t\tif (r_pending_interrupt && gie && !clear_pipeline)\n\t\t\tassert(i_interrupt || user_step || alu_illegal\n\t\t\t\t\t|| ill_err_u || break_pending);\n\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && $past(user_step && stepped && !o_bus_lock\n\t\t\t\t\t\t\t&& !o_dbg_stall))\n\t\t\tassert(!gie || r_pending_interrupt);\n`endif\n\t\tassign\tstepped = r_user_stepped;\n\t\t// }}}\n\tend else begin : NO_PENDING_INTS\n\t\t// {{{\n\t\tassign\tw_switch_to_interrupt    = 1'b0;\n\t\tassign\tw_release_from_interrupt = 1'b0;\n\t\tassign\tpending_interrupt = 1'b0;\n\t\tassign\tstepped = 1'b0;\n\n\t\t// Verilator lint_off UNUSED",
            "wire unused_int_signals;\n\t\tassign\tunused_int_signals = &{ 1'b0, last_lock_insn };\n\t\t// Verilator lint_on  UNUSED\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate if (OPT_USERMODE)\n\tbegin : SET_GIE",
            "reg r_gie;\n\n\t\tinitial\tr_gie = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_gie <= 1'b0;\t// Supervisor mode\n\t\telse if (w_switch_to_interrupt)\n\t\t\tr_gie <= 1'b0;\t// Supervisor mode\n\t\telse if (w_release_from_interrupt)\n\t\t\tr_gie <= 1'b1;\t// User mode\n\n\t\tassign\tgie = r_gie;\n\tend else begin : ZERO_GIE\n\n\t\tassign\tgie = 1'b0;\n\n\tend endgenerate\n\t// }}}\n\n\t// trap, ubreak\n\t// {{{\n\tgenerate if (OPT_USERMODE)\n\tbegin : SET_TRAP_N_UBREAK\n\t\t// {{{",
            "reg r_trap;",
            "reg r_ubreak;\n\n\t\t// A trap is generated when the user writes to the CC\n\t\t//",
            "reg ister to clear the GIE bit.  This is how the supervisor\n\t\t// can tell that supervisor mode was entered by a request from\n\t\t// usermode.\n\t\tinitial\tr_trap = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif ((i_reset)||(w_release_from_interrupt))\n\t\t\tr_trap <= 1'b0;\n\t\telse if (wr_",
            "reg _ce && wr_write_ucc)\n\t\tbegin\n\t\t\tif (!alu_gie)\n\t\t\t\t// The trap bit can only be cleared by the\n\t\t\t\t// supervisor.\n\t\t\t\tr_trap <= (r_trap)&&(wr_sp",
            "reg _vl[CPU_TRAP_BIT]);\n\t\t\telse if (!wr_sp",
            "reg _vl[CPU_GIE_BIT]) // && alu_gie\n\t\t\t\t// Execute a trap\n\t\t\t\tr_trap <= !dbgv;\n\t\tend\n\n\t\t// A user break is an indication of an exception.  Something\n\t\t// went wrong.  When entering supervisor mode, if this bit\n\t\t// is set the supervisor then knows something went wrong in\n\t\t// userspace that needs to be looked into.\n\t\tinitial\tr_ubreak = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || w_release_from_interrupt)\n\t\t\tr_ubreak <= 1'b0;\n\t\telse if (op_gie && break_pending && w_switch_to_interrupt)\n\t\t\t// Breaks are set when a BREAK instruction is accepted\n\t\t\t// for execution from the OP stage, *and* when in user\n\t\t\t// mode\n\t\t\tr_ubreak <= 1'b1;\n\t\telse if ((!alu_gie || dbgv)&&(wr_",
            "reg _ce)&&(wr_write_ucc))\n\t\t\t// Allow the supervisor or debug port to clear this\n\t\t\t//",
            "reg ister--but not to set it\n\t\t\tr_ubreak <= (ubreak)&&(wr_sp",
            "reg _vl[CPU_BREAK_BIT]);\n\n\t\tassign\ttrap = r_trap;\n\t\tassign\tubreak = r_ubreak;\n\t\t// }}}\n\tend else begin : NO_USERTRAP\n\n\t\tassign\ttrap   = 1'b0;\n\t\tassign\tubreak = 1'b0;\n\n\tend endgenerate\n\t// }}}\n\n\t// ill_err_i, ill_err_u: Illegal instruction flags\n\t// {{{\n\tinitial\till_err_i = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\till_err_i <= 1'b0;\n\telse if (dbgv && wr_write_scc)\n\t\t// Only the debug interface (or a CPU reset) can clear the\n\t\t// supervisor's illegal instruction flag\n\t\till_err_i <= (ill_err_i)&&(wr_sp",
            "reg _vl[CPU_ILL_BIT]);\n\telse if (!alu_gie && alu_illegal && !clear_pipeline)\n\t\t// The supervisor's illegal instruction flag is set in\n\t\t// supervisor (not user) mode, on trying to execute the illegal\n\t\t// instruction\n\t\till_err_i <= 1'b1;\n\n\tgenerate if (OPT_USERMODE)\n\tbegin : SET_USER_ILLEGAL_INSN",
            "reg r_ill_err_u;\n\n\t\t//\n\t\t// The user's illegal instruction exception flag.  Used and\n\t\t// cleared by the supervisor.\n\t\t//\n\n\t\tinitial\tr_ill_err_u = 1'b0;\n\t\talways @(posedge i_clk)\n\t\t// The bit is automatically cleared on release from interrupt\n\t\t// or reset\n\t\tif (i_reset || w_release_from_interrupt)\n\t\t\tr_ill_err_u <= 1'b0;\n\t\telse if ((!alu_gie || dbgv)&&(wr_",
            "reg _ce)&&(wr_write_ucc))\n\t\t\t// Either the supervisor or the debugger can clear this\n\t\t\t// bit.  (Neither can set it)\n\t\t\tr_ill_err_u <=((ill_err_u)&&(wr_sp",
            "reg _vl[CPU_ILL_BIT]));\n\t\telse if (alu_gie && alu_illegal && !clear_pipeline)\n\t\t\t// This flag is set if the CPU ever attempts to execute\n\t\t\t// an illegal instruction while in user mode.\n\t\t\tr_ill_err_u <= 1'b1;\n\n\t\tassign\till_err_u = r_ill_err_u;\n\n\tend else begin : NO_USER_ILL\n\n\t\tassign\till_err_u = 1'b0;\n\n\tend endgenerate\n\t// }}}\n\n\t// ibus_err_flag, ubus_err_flag : Bus error flags\n\t// {{{\n\t// Supervisor/interrupt bus error flag -- this will crash the CPU if\n\t// ever set.\n\tinitial\tibus_err_flag = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tibus_err_flag <= 1'b0;\n\telse if ((dbgv)&&(wr_write_scc))\n\t\tibus_err_flag <= (ibus_err_flag)&&(wr_sp",
            "reg _vl[CPU_BUSERR_BIT]);\n\telse if ((i_bus_err)&&(!alu_gie))\n\t\tibus_err_flag <= 1'b1;\n\n\t// User bus error flag -- if ever set, it will cause an interrupt to\n\t// supervisor mode.\n\tgenerate if (OPT_USERMODE)\n\tbegin : SET_USER_BUSERR",
            "reg r_ubus_err_flag;\n\n\t\tinitial\tr_ubus_err_flag = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif ((i_reset)||(w_release_from_interrupt))\n\t\t\tr_ubus_err_flag <= 1'b0;\n\t\telse if (((!alu_gie)||(dbgv))&&(wr_",
            "reg _ce)&&(wr_write_ucc))\n\t\t\tr_ubus_err_flag <= (ubus_err_flag)&&(wr_sp",
            "reg _vl[CPU_BUSERR_BIT]);\n\t\telse if ((i_bus_err)&&(alu_gie))\n\t\t\tr_ubus_err_flag <= 1'b1;\n\n\t\tassign\tubus_err_flag = r_ubus_err_flag;\n\tend else begin : NO_USER_BUSERR\n\n\t\tassign\tubus_err_flag = 1'b0;\n\n\tend endgenerate\n\t// }}}\n\n\t// idiv_err_flag, udiv_err_flag : Divide by zero error flags\n\t// {{{\n\tgenerate if (OPT_DIV != 0)\n\tbegin : DIVERR\n\t\t// {{{",
            "reg r_idiv_err_flag;\n\n\t\t// Supervisor/interrupt divide (by zero) error flag -- this will\n\t\t// crash the CPU if ever set.  This bit is thus available for us\n\t\t// to be able to tell if/why the CPU crashed.\n\t\tinitial\tr_idiv_err_flag = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_idiv_err_flag <= 1'b0;\n\t\telse if ((dbgv)&&(wr_write_scc))\n\t\t\tr_idiv_err_flag <= (r_idiv_err_flag)&&(wr_sp",
            "reg _vl[CPU_DIVERR_BIT]);\n\t\telse if ((div_error)&&(!alu_gie))\n\t\t\tr_idiv_err_flag <= 1'b1;\n\n\t\tassign\tidiv_err_flag = r_idiv_err_flag;\n\n\t\tif (OPT_USERMODE)\n\t\tbegin : USER_DIVERR",
            "reg r_udiv_err_flag;\n\n\t\t\t// User divide (by zero) error flag -- if ever set, it will\n\t\t\t// cause a sudden switch interrupt to supervisor mode.\n\t\t\tinitial\tr_udiv_err_flag = 1'b0;\n\t\t\talways @(posedge i_clk)\n\t\t\tif ((i_reset)||(w_release_from_interrupt))\n\t\t\t\tr_udiv_err_flag <= 1'b0;\n\t\t\telse if (((!alu_gie)||(dbgv))&&(wr_",
            "reg _ce)\n\t\t\t\t\t&&(wr_write_ucc))\n\t\t\t\tr_udiv_err_flag <= (r_udiv_err_flag)&&(wr_sp",
            "reg _vl[CPU_DIVERR_BIT]);\n\t\t\telse if ((div_error)&&(alu_gie))\n\t\t\t\tr_udiv_err_flag <= 1'b1;\n\n\t\t\tassign\tudiv_err_flag = r_udiv_err_flag;\n\t\tend else begin : NO_USER_DIVERR\n\t\t\tassign\tudiv_err_flag = 1'b0;\n\t\tend\n\t\t// }}}\n\tend else begin : NO_DIVERR\n\t\t// {{{\n\t\tassign\tidiv_err_flag = 1'b0;\n\t\tassign\tudiv_err_flag = 1'b0;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// ifpu_err_flag, ufpu_err_flag : Floating point error flag(s)\n\t// {{{\n\tgenerate if (IMPLEMENT_FPU !=0)\n\tbegin : FPUERR\n\t\t// {{{\n\t\t// Supervisor/interrupt floating point error flag -- this will\n\t\t// crash the CPU if ever set.",
            "reg r_ifpu_err_flag, r_ufpu_err_flag;\n\t\tinitial\tr_ifpu_err_flag = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_ifpu_err_flag <= 1'b0;\n\t\telse if ((dbgv)&&(wr_write_scc))\n\t\t\tr_ifpu_err_flag <= (r_ifpu_err_flag)&&(wr_sp",
            "reg _vl[CPU_FPUERR_BIT]);\n\t\telse if ((fpu_error)&&(fpu_valid)&&(!alu_gie))\n\t\t\tr_ifpu_err_flag <= 1'b1;\n\t\t// User floating point error flag -- if ever set, it will cause\n\t\t// a sudden switch interrupt to supervisor mode.\n\t\tinitial\tr_ufpu_err_flag = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif ((i_reset)&&(w_release_from_interrupt))\n\t\t\tr_ufpu_err_flag <= 1'b0;\n\t\telse if (((!alu_gie)||(dbgv))&&(wr_",
            "reg _ce)\n\t\t\t\t&&(wr_write_ucc))\n\t\t\tr_ufpu_err_flag <= (r_ufpu_err_flag)&&(wr_sp",
            "reg _vl[CPU_FPUERR_BIT]);\n\t\telse if ((fpu_error)&&(alu_gie)&&(fpu_valid))\n\t\t\tr_ufpu_err_flag <= 1'b1;\n\n\t\tassign\tifpu_err_flag = r_ifpu_err_flag;\n\t\tassign\tufpu_err_flag = r_ufpu_err_flag;\n\t\t// }}}\n\tend else begin : NO_FPUERR\n\t\t// {{{\n\t\tassign\tifpu_err_flag = 1'b0;\n\t\tassign\tufpu_err_flag = 1'b0;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// ihalt_phase, uhalt_phase : If an instruction was broken when halting\n\t// {{{\n\tgenerate if (OPT_CIS)\n\tbegin : GEN_IHALT_PHASE",
            "reg r_ihalt_phase;\n\n\t\tinitial\tr_ihalt_phase = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_ihalt_phase <= 1'b0;\n\t\telse if ((!alu_gie)&&(alu_pc_valid)&&(!clear_pipeline))\n\t\t\tr_ihalt_phase <= alu_phase;\n\n\t\tassign\tihalt_phase = r_ihalt_phase;\n\tend else begin : GEN_IHALT_PHASE\n\n\t\tassign\tihalt_phase = 1'b0;\n\n\tend endgenerate\n\n\tgenerate if ((!OPT_CIS) || (!OPT_USERMODE))\n\tbegin : GEN_UHALT_PHASE\n\n\t\tassign\tuhalt_phase = 1'b0;\n\n\tend else begin : GEN_UHALT_PHASE",
            "reg r_uhalt_phase;\n\n\t\tinitial\tr_uhalt_phase = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif ((i_reset)||(w_release_from_interrupt))\n\t\t\tr_uhalt_phase <= 1'b0;\n\t\telse if ((alu_gie)&&(alu_pc_valid))\n\t\t\tr_uhalt_phase <= alu_phase;\n\t\telse if ((!alu_gie)&&(wr_",
            "reg _ce)&&(wr_write_pc)\n\t\t\t\t&&(wr_",
            "reg _id[4]))\n\t\t\tr_uhalt_phase <= wr_sp",
            "reg _vl[1];\n\n\t\tassign\tuhalt_phase = r_uhalt_phase;\n\n\tend endgenerate\n\t// }}}\n\n\t// ipc, upc: Program counters\n\t// {{{\n\t//\n\t// Write backs to the PC",
            "reg ister, and general increments of it\n\t//\tWe support two: upc and ipc.  If the instruction is normal,\n\t// we increment upc, if interrupt level we increment ipc.  If\n\t// the instruction writes the PC, we write whichever PC is appropriate.\n\t//\n\t// Do we need to all our partial results from the pipeline?\n\t// What happens when the pipeline has gie and !gie instructions within\n\t// it?  Do we clear both?  What if a gie instruction tries to clear\n\t// a non-gie instruction?\n\n\t// upc\n\tgenerate if (OPT_USERMODE)\n\tbegin : SET_USER_PC\n\t\t// {{{",
            "reg [(AW+1):0]\tr_upc;\n\n\t\talways @(posedge i_clk)\n\t\tif ((wr_",
            "reg _ce)&&(wr_",
            "reg _id[4])&&(wr_write_pc))\n\t\t\tr_upc <= { wr_sp",
            "reg _vl[(AW+1):2], 2'b00 };\n\t\telse if ((alu_gie)&&\n\t\t\t\t(((alu_pc_valid)&&(!clear_pipeline)&&(!alu_illegal))\n\t\t\t\t||(mem_pc_valid)))\n\t\t\tr_upc <= alu_pc;\n\n\t\tassign\tupc = r_upc;\n\t\t// }}}\n\tend else begin : NO_UPC\n\t\t// {{{\n\t\tassign\tupc = {(AW+2){1'b0}};\n\t\t// }}}\n\tend endgenerate\n\n\t// ipc\n\t// {{{\n\tinitial\tipc = { RESET_BUS_ADDRESS, 2'b00 };\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tipc <= { RESET_BUS_ADDRESS, 2'b00 };\n\telse if ((wr_",
            "reg _ce)&&(!wr_",
            "reg _id[4])&&(wr_write_pc))\n\t\tipc <= { wr_sp",
            "reg _vl[(AW+1):2], 2'b00 };\n\telse if ((!alu_gie)&&(!alu_phase)&&\n\t\t\t(((alu_pc_valid)&&(!clear_pipeline)&&(!alu_illegal))\n\t\t\t||(mem_pc_valid)))\n\t\tipc <= alu_pc;\n\t// }}}\n\t// }}}\n\n\t// pf_pc : the program counter used by the pre-fetch\n\t// {{{\n\n\t// pfpcset, pfpcsrc\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tpfpcset = 0;\n\t\tpfpcsrc = 0;\n\t\tif (i_reset)\n\t\tbegin\n\t\t\tpfpcsrc = 0;\n\t\t\tpfpcset = 1;\n\t\tend else if ((dbgv)&&(wr_",
            "reg _ce)&&(wr_",
            "reg _id[4] == gie && wr_write_pc))\n\t\tbegin\n\t\t\tpfpcsrc = 1; // sp",
            "reg pfpcset = 1;\n\t\tend else if ((w_switch_to_interrupt)\n\t\t\t\t||((!gie)&&((o_clear_icache)||(dbg_clear_pipe))))\n\t\tbegin\n\t\t\tpfpcsrc = 2; // ipc\n\t\t\tpfpcset = 1;\n\t\tend else if ((w_release_from_interrupt)||((gie)&&((o_clear_icache)||(dbg_clear_pipe))))\n\t\tbegin\n\t\t\tpfpcsrc = 3; // upc\n\t\t\tpfpcset = 1;\n\t\tend else if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id[4] == gie && wr_write_pc))\n\t\tbegin\n\t\t\tpfpcsrc = 1; // sp",
            "reg pfpcset = 1;\n\t\tend else if ((dcd_early_branch_stb)&&(!clear_pipeline))\n\t\tbegin\n\t\t\tpfpcsrc = 4; // branch\n\t\t\tpfpcset = 1;\n\t\tend else if ((new_pc)||(o_pf_ready&& i_pf_valid))\n\t\tbegin\n\t\t\tpfpcsrc = 5; // PC increment\n\t\t\tpfpcset = 1;\n\t\tend\n\tend\n\t// }}}\n\n\tinitial pf_pc = { RESET_BUS_ADDRESS, 2'b00 };\n\talways @(posedge i_clk)\n\tif (pfpcset)\n\tcase(pfpcsrc)\n\t3'b000: pf_pc <= { RESET_BUS_ADDRESS, 2'b00 };\n\t3'b001: pf_pc <= { wr_sp",
            "reg _vl[(AW+1):2], 2'b00 };\n\t3'b010: pf_pc <= { ipc[(AW+1):2], 2'b00 };\n\t3'b011: pf_pc <= { upc[(AW+1):2], 2'b00 };\n\t3'b100: pf_pc <= { dcd_branch_pc[AW+1:2] + 1'b1, 2'b00 };\n\t3'b101: pf_pc <= { pf_pc[(AW+1):2] + 1'b1, 2'b00 };\n\tdefault: pf_pc <= { RESET_BUS_ADDRESS, 2'b00 };\n\tendcase\n/*\n\tif (i_reset)\n\t\tpf_pc <= { RESET_BUS_ADDRESS, 2'b00 };\n\telse if ((dbg_clear_pipe)&&(wr_",
            "reg _ce)&&(wr_write_pc))\n\t\tpf_pc <= { wr_sp",
            "reg _vl[(AW+1):2], 2'b00 };\n\telse if ((w_switch_to_interrupt)\n\t\t\t||((!gie)&&((o_clear_icache)||(dbg_clear_pipe))))\n\t\tpf_pc <= { ipc[(AW+1):2], 2'b00 };\n\telse if ((w_release_from_interrupt)||((gie)&&((o_clear_icache)||(dbg_clear_pipe))))\n\t\tpf_pc <= { upc[(AW+1):2], 2'b00 };\n\telse if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id[4] == gie)&&(wr_write_pc))\n\t\tpf_pc <= { wr_sp",
            "reg _vl[(AW+1):2], 2'b00 };\n\telse if ((dcd_early_branch_stb)&&(!clear_pipeline))\n\t\tpf_pc <= { dcd_branch_pc[AW+1:2] + 1'b1, 2'b00 };\n\telse if ((new_pc)||((!pf_stalled)&&(i_pf_valid)))\n\t\tpf_pc <= { pf_pc[(AW+1):2] + 1'b1, 2'b00 };\n*/\n\t// }}}\n\n\tinitial\tlast_write_to_cc = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tlast_write_to_cc <= 1'b0;\n\telse\n\t\tlast_write_to_cc <= (wr_",
            "reg _ce)&&(wr_write_cc);\n\tassign\tcc_write_hold = (wr_",
            "reg _ce && wr_write_cc)||(last_write_to_cc);\n\n\t// o_clear_icache\n\t// {{{\n\t// If we aren't pipelined, or equivalently if we have no cache, these\n\t// instructions will get quietly (or not so quietly) ignored by the\n\t// optimizer.\n\tinitial\tr_clear_icache = 1'b1;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_clear_icache <= 1'b0;\n\telse if (i_clear_cache && !o_dbg_stall)\n\t\tr_clear_icache <= 1'b1;\n\telse if ((wr_",
            "reg _ce)&&(wr_write_scc))\n\t\tr_clear_icache <=  wr_sp",
            "reg _vl[CPU_CLRICACHE_BIT];\n\telse\n\t\tr_clear_icache <= 1'b0;\n\n\tassign\to_clear_icache = r_clear_icache;\n\t// }}}\n\n\t// o_clear_dcache\n\t// {{{\n\tgenerate if (OPT_DCACHE)\n\tbegin : CLEAR_DCACHE",
            "reg r_clear_dcache;\n\n\t\tinitial\tr_clear_dcache = 1'b1;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_clear_dcache <= 1'b0;\n\t\telse if (i_clear_cache && !o_dbg_stall)\n\t\t\tr_clear_dcache <= 1'b1;\n\t\telse if ((wr_",
            "reg _ce)&&(wr_write_scc))\n\t\t\tr_clear_dcache <=  wr_sp",
            "reg _vl[CPU_CLRDCACHE_BIT];\n\t\telse\n\t\t\tr_clear_dcache <= 1'b0;\n\n\t\tassign\to_clear_dcache = r_clear_dcache;\n\tend else begin : NOCLEAR_DCACHE\n\n\t\tassign\to_clear_dcache = 1'b0;\n\n\tend endgenerate\n\t// }}}\n\n\t// new_pc : does the Prefetch need to clear the pipeline and start over?\n\t// {{{\n\tinitial\tnew_pc = 1'b1;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(o_clear_icache)||(dbg_clear_pipe))\n\t\tnew_pc <= 1'b1;\n\telse if (w_switch_to_interrupt)\n\t\tnew_pc <= 1'b1;\n\telse if (w_release_from_interrupt)\n\t\tnew_pc <= 1'b1;\n\t// else if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id[4] == gie)&&(wr_write_pc))\n\t// Can't check for *this* PC here, since a user PC might be\n\t// loaded in the pipeline and hence rewritten.  Thus, while\n\t// I hate to do it, we'll need to clear the pipeline on any\n\t// PC write\n\telse if ((wr_",
            "reg _ce)&&(alu_gie == wr_",
            "reg _id[4])&&(wr_write_pc))\n\t\tnew_pc <= 1'b1;\n\telse\n\t\tnew_pc <= 1'b0;\n\t// }}}\n\n\t//\n\t// The debug write-back interface\n\t// {{{\n\n\t// debug_pc\n\t// {{{\n\tgenerate if (OPT_USERMODE)\n\tbegin : DBGPC_FULL\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tdebug_pc = 0;\n\t\t\tif (!OPT_DBGPORT)\n\t\t\tbegin\n\t\t\t\t// Empty block--if there's no debug port, we'll\n\t\t\t\t// leave this valu at zero to reduce power\n\t\t\tend else if (i_dbg_r",
            "reg [4])\n\t\t\t\t// User mode\n\t\t\t\tdebug_pc[(AW+1):0]\n\t\t\t\t\t= { upc[(AW+1):2], uhalt_phase, 1'b0 };\n\t\t\telse\n\t\t\t\t// Supervisor mode\n\t\t\t\tdebug_pc[(AW+1):0]\n\t\t\t\t\t= { ipc[(AW+1):2], ihalt_phase, 1'b0 };\n\t\tend\n\t\t// }}}\n\tend else begin : DBGPC_NO_USER\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tdebug_pc = 0;\n\t\t\tif (OPT_DBGPORT)\n\t\t\tdebug_pc[(AW+1):0] = { ipc[AW+1:2], ihalt_phase, 1'b0 };\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// o_dbg_",
            "reg // {{{\n\tgenerate if (!OPT_DBGPORT)\n\tbegin : NO_DBGPORT\n\n\t\tassign\to_dbg_",
            "reg = 0;\n\n\t\t// verilator lint_off UNUSED",
            "wire unused_dbgport;\n\t\tassign\tunused_dbgport = &{ 1'b0, i_dbg_r",
            "reg , debug_pc };\n\t\t// verilator lint_on  UNUSED\n\n\tend else if (OPT_USERMODE)\n\tbegin : SETDBG\n\t\t// {{{",
            "reg [31:0]\tpre_dbg_",
            "reg , r_dbg_",
            "reg ;\n\n\t\tif (OPT_DISTRIBUTED_REGS)\n\t\tbegin : GEN_DISTRIBUTED_RAM_DBG\n\t\t\t// {{{\n\t\t\talways @(*)\n\t\t\t\tpre_dbg_",
            "reg =",
            "reg set[i_dbg_r",
            "reg ];\n\n\t\t\talways @(posedge i_clk)\n\t\t\tbegin\n\t\t\t\tr_dbg_",
            "reg <= pre_dbg_",
            "reg ;\n\t\t\t\tif (i_dbg_r",
            "reg [3:0] == CPU_PC_REG)\n\t\t\t\t\tr_dbg_",
            "reg <= debug_pc;\n\t\t\t\telse if (i_dbg_r",
            "reg [3:0] == CPU_CC_REG)\n\t\t\t\tbegin\n\t\t\t\t\tr_dbg_",
            "reg [15:0] <= (i_dbg_r",
            "reg [4])\n\t\t\t\t\t\t\t? w_uflags : w_iflags;\n\t\t\t\t\tr_dbg_",
            "reg [31:23] <= w_cpu_info;\n\t\t\t\t\tr_dbg_",
            "reg [CPU_GIE_BIT] <= i_dbg_r",
            "reg [4];\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tassign\to_dbg_",
            "reg = r_dbg_",
            "reg ;\n\t\t\t// }}}\n\t\tend else begin : GEN_BKRAM_DBG\n\t\t\t// {{{",
            "reg [1:0]\tdbg_",
            "reg _sel;",
            "reg [31:0]\tpre_dbg_special;\n\n\t\t\t// First clock\n\n\t\t\talways @(posedge i_clk)\n\t\t\tbegin\n\t\t\t\tdbg_",
            "reg _sel[1] <= (i_dbg_r",
            "reg [3:1] == 3'h7);\n\t\t\t\tdbg_",
            "reg _sel[0] <= i_dbg_r",
            "reg [0];\n\t\t\tend\n\n\t\t\talways @(posedge i_clk)\n\t\t\t\tpre_dbg_",
            "reg <=",
            "reg set[i_dbg_r",
            "reg ];\n\n\t\t\talways @(posedge i_clk)\n\t\t\tif (i_dbg_r",
            "reg [0])\n\t\t\t\tpre_dbg_special <= debug_pc;\n\t\t\telse begin\n\t\t\t\tpre_dbg_special <= 0;\n\t\t\t\tpre_dbg_special[15:0] <= (i_dbg_r",
            "reg [4])\n\t\t\t\t\t\t\t? w_uflags : w_iflags;\n\t\t\t\tpre_dbg_special[31:23] <= w_cpu_info;\n\t\t\t\tpre_dbg_special[CPU_GIE_BIT] <= i_dbg_r",
            "reg [4];\n\t\t\tend\n\n\t\t\t// Second clock\n\n\t\t\talways @(posedge i_clk)\n\t\t\tif (!dbg_",
            "reg _sel[1])\n\t\t\t\tr_dbg_",
            "reg <= pre_dbg_",
            "reg ;\n\t\t\telse if (dbg_",
            "reg _sel[0])\n\t\t\t\tr_dbg_",
            "reg <= pre_dbg_special;\n\t\t\telse begin\n\t\t\t\tr_dbg_",
            "reg <= pre_dbg_special;\n\t\t\t\tr_dbg_",
            "reg [22:16] <= pre_dbg_",
            "reg [22:16];\n\t\t\tend\n\n\n\t\t\tassign\to_dbg_",
            "reg = r_dbg_",
            "reg ;\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\tend else begin : NO_USER_SETDBG\n\t\t// {{{",
            "reg [31:0]\tr_dbg_",
            "reg , pre_dbg_",
            "reg ;\n\n\t\tif (OPT_DISTRIBUTED_REGS)\n\t\tbegin : GEN_DISTRIBUTED_RAM_DBG\n\n\t\t\talways @(*)\n\t\t\t\tpre_dbg_",
            "reg =",
            "reg set[i_dbg_r",
            "reg [3:0]];\n\n\t\t\talways @(posedge i_clk)\n\t\t\tbegin\n\t\t\t\tr_dbg_",
            "reg <= pre_dbg_",
            "reg ;\n\t\t\t\tif (i_dbg_r",
            "reg [3:0] == CPU_PC_REG)\n\t\t\t\t\tr_dbg_",
            "reg <= debug_pc;\n\t\t\t\telse if (i_dbg_r",
            "reg [3:0] == CPU_CC_REG)\n\t\t\t\tbegin\n\t\t\t\t\tr_dbg_",
            "reg [15:0] <= w_iflags;\n\t\t\t\t\tr_dbg_",
            "reg [31:23] <= w_cpu_info;\n\t\t\t\t\tr_dbg_",
            "reg [CPU_GIE_BIT] <= 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\tend else begin : GEN_BKRAM_DBG\n\t\t\t// {{{",
            "reg [1:0]\tdbg_",
            "reg _sel;",
            "reg [31:0]\tpre_dbg_special;\n\n\t\t\t// First clock\n\n\t\t\talways @(posedge i_clk)\n\t\t\tbegin\n\t\t\t\tdbg_",
            "reg _sel[1] <= (i_dbg_r",
            "reg [3:1] == 3'h7);\n\t\t\t\tdbg_",
            "reg _sel[0] <= i_dbg_r",
            "reg [0];\n\t\t\tend\n\n\t\t\talways @(posedge i_clk)\n\t\t\t\tpre_dbg_",
            "reg <=",
            "reg set[i_dbg_r",
            "reg [3:0]];\n\n\t\t\talways @(posedge i_clk)\n\t\t\tif (i_dbg_r",
            "reg [0])\n\t\t\t\tpre_dbg_special <= debug_pc;\n\t\t\telse begin\n\t\t\t\tpre_dbg_special <= 0;\n\t\t\t\tpre_dbg_special[15:0] <= w_iflags;\n\t\t\t\tpre_dbg_special[31:23] <= w_cpu_info;\n\t\t\t\tpre_dbg_special[CPU_GIE_BIT] <= 1'b0;\n\t\t\tend\n\n\t\t\t// Second clock\n\n\t\t\talways @(posedge i_clk)\n\t\t\tif (!dbg_",
            "reg _sel[1])\n\t\t\t\tr_dbg_",
            "reg <= pre_dbg_",
            "reg ;\n\t\t\telse if (dbg_",
            "reg _sel[0])\n\t\t\t\tr_dbg_",
            "reg <= pre_dbg_special;\n\t\t\telse begin\n\t\t\t\tr_dbg_",
            "reg <= pre_dbg_special;\n\t\t\t\tr_dbg_",
            "reg [22:16] <= pre_dbg_",
            "reg [22:16];\n\t\t\tend\n\n\t\t\tassign\to_dbg_",
            "reg = r_dbg_",
            "reg ;\n\t\t\t// }}}\n\t\tend\n\n\t\tassign\to_dbg_",
            "reg = r_dbg_",
            "reg ;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\talways @(posedge i_clk)\n\t\to_dbg_cc <= { i_bus_err, gie, sleep };\n\n\t// r_halted\n\t// {{{\n\tgenerate if (OPT_PIPELINED)\n\tbegin : GEN_HALT_PIPELINED\n\t\t// {{{\n\t\tinitial\tr_halted = OPT_START_HALTED;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_halted <= OPT_START_HALTED;\n\t\telse if (!i_halt)\n\t\t\tr_halted <= 1'b0;\n\t\telse if (r_halted)\n\t\t\tr_halted <= 1'b1;\n\t\telse\n\t\t\tr_halted <= (!alu_phase)&&(!o_bus_lock)&&(\n\t\t\t\t// To be halted, any long lasting instruction\n\t\t\t\t// must be completed.\n\t\t\t\t(i_pf_valid)&&(!i_mem_busy)&&(!alu_busy)\n\t\t\t\t\t&&(!div_busy)&&(!fpu_busy)\n\t\t\t\t// Operations must either be valid, or illegal\n\t\t\t\t&&((dcd_valid)||(dcd_illegal)));\n\t\t// }}}\n\tend else begin : GEN_HALT_NOPIPE\n\t\t// {{{\n\t\tinitial\tr_halted = OPT_START_HALTED;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_halted <= OPT_START_HALTED;\n\t\telse if (!i_halt)\n\t\t\tr_halted <= 1'b0;\n\t\telse if (r_halted)\n\t\t\tr_halted <= 1'b1;\n\t\telse\n\t\t\tr_halted <= (!alu_phase)\n\t\t\t\t// To be halted, any long lasting instruction\n\t\t\t\t// must be completed.\n\t\t\t\t&&(i_pf_valid)&&(!i_mem_busy)&&(!alu_busy)\n\t\t\t\t\t&&(!div_busy)&&(!fpu_busy);\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// o_dbg_stall\n\t// {{{\n\tinitial\tr_dbg_stall = 1'b1;\n\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_dbg_stall <= 1'b1;\n\telse if (!r_halted || (wr_",
            "reg _ce && wr_",
            "reg _id[3:1] == 3'h7))\n\t\tr_dbg_stall <= 1'b1;\n\telse\n\t\tr_dbg_stall <= (OPT_DBGPORT && i_dbg_we && !o_dbg_stall);\n\n\tassign\to_dbg_stall = OPT_DBGPORT && (!r_halted || r_dbg_stall);\n\t// }}}\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Accounting",
            "output s\n\t// {{{\n\n\t//\n\t//\n\t// Produce accounting",
            "output s: Account for any CPU stalls, so we can\n\t// later evaluate how well we are doing.\n\t//\n\t//\n\tassign\to_op_stall = (master_ce)&&(op_stall);\n\tassign\to_pf_stall = (master_ce)&&(!i_pf_valid);\n\tassign\to_i_count  = (alu_pc_valid)&&(!clear_pipeline);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The debug scope",
            "output // {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_TRACE_PORT)\n\tbegin : GEN_DEBUG_PORT",
            "localparam [1:0]\n\t\t\t\tDBGSRC_FLAGS\t= 2'b00,\n\t\t\t\tDBGSRC_WRITEBACK = 2'b01,\n\t\t\t\tDBGSRC_JUMP\t= 2'b10;",
            "reg [31:0]\tr_debug;",
            "reg debug_trigger, dbg_mem_we;",
            "wire [27:0]\tdebug_flags;",
            "reg [1:0]\tdbgsrc;\n\t\t// Verilator lint_off UNUSED",
            "wire [27:0]\tdbg_pc, dbg_wb_addr;\n\t\t// Verilator lint_on  UNUSED\n\n\n\t\tinitial\tdebug_trigger = 1'b0;\n\t\talways @(posedge i_clk)\n\t\t\tdebug_trigger <= (!i_halt)&&(o_break);\n\n\t\talways @(posedge i_clk)\n\t\tif (o_mem_ce)\n\t\t\tdbg_mem_we <= o_mem_op[0];\n\n\t\tassign debug_flags = { master_ce, i_halt, o_break, sleep,\n\t\t\t\tgie, ibus_err_flag, trap, ill_err_i,\n\t\t\t\to_clear_icache, i_pf_valid, i_pf_illegal, dcd_ce,\n\t\t\t\tdcd_valid, dcd_stalled, op_ce, op_valid,\n\t\t\t\top_pipe, alu_ce, alu_busy, alu_wR,\n\t\t\t\talu_illegal, alu_wF, mem_ce, dbg_mem_we,\n\t\t\t\ti_mem_busy, i_mem_pipe_stalled, (new_pc), (dcd_early_branch) };\n\n\t\tif (AW-1 < 27)\n\t\tbegin : GEN_SHORT_DBGPC\n\t\t\tassign\tdbg_pc[(AW-1):0] = pf_pc[(AW+1):2];\n\t\t\tassign\tdbg_pc[27:AW] = 0;\n\n\t\t\tassign\tdbg_wb_addr[(AW-1):0] = 0;\n\t\t\tassign\tdbg_wb_addr[27:AW] = 0;\n\t\tend else // if (AW-1 >= 27)\n\t\tbegin : GEN_WIDE_DBGPC\n\t\t\tassign\tdbg_pc[27:0] = pf_pc[29:2];\n\t\t\tassign\tdbg_wb_addr = 0;\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tbegin\n\t\t\tdbgsrc <= 0;\n\t\t\tif ((i_halt)||(!master_ce)||(debug_trigger)||(o_break))\n\t\t\t\tdbgsrc <= DBGSRC_FLAGS;\n\t\t\telse if ((i_mem_valid)||((!clear_pipeline)&&(!alu_illegal)\n\t\t\t\t\t&&(((alu_wR)&&(alu_valid))\n\t\t\t\t\t\t||(div_valid)||(fpu_valid))))\n\t\t\t\tdbgsrc <= DBGSRC_WRITEBACK;\n\t\t\telse if (clear_pipeline)\n\t\t\t\tdbgsrc <= DBGSRC_JUMP;\n\t\t\telse\n\t\t\t\tdbgsrc <= DBGSRC_FLAGS;\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tcasez(dbgsrc)\n\t\tDBGSRC_FLAGS:\n\t\t\tr_debug <= { debug_trigger, 3'b101,\n\t\t\t\tdebug_flags };\n\t\tDBGSRC_WRITEBACK:\n\t\t\tr_debug <= { debug_trigger, 1'b0,\n\t\t\t\twr_",
            "reg _id[3:0], wr_gp",
            "reg _vl[25:0]};\n\t\tDBGSRC_JUMP: r_debug <= { debug_trigger, 3'b100,\n\t\t\t\tdbg_pc };\n\t\tdefault: r_debug <= 32'h0;\n\t\tendcase\n\n\t\tassign\to_debug = r_debug;\n\n\tend else begin : NO_TRACE_PORT\n\n\t\tassign\to_debug = 32'h0;\n\n\tend endgenerate\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Optional) Hardware profiler support\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_PROFILER)\n\tbegin : GEN_PROFILER",
            "reg prof_stb;",
            "reg [AW+1:0]\tprof_addr;",
            "reg [31:0]\t\tprof_ticks;\n\n\t\tinitial\tprof_stb = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || clear_pipeline)\n\t\t\tprof_stb <= 1'b0;\n\t\telse\n\t\t\tprof_stb <= (alu_pc_valid || mem_pc_valid);\n\n\t\tinitial\tprof_addr = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || clear_pipeline)\n\t\t\tprof_addr <= RESET_ADDRESS[AW+1:0];\n\t\telse if (alu_pc_valid || mem_pc_valid)\n\t\t\tprof_addr <= alu_pc;\n\n\t\tinitial\tprof_ticks = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tprof_ticks <= 0;\n\t\telse if (!i_halt)\n\t\t\tprof_ticks <= prof_ticks + 1;\n\n\t\tassign\to_prof_stb   = prof_stb;\n\t\tassign\to_prof_addr  = prof_addr;\n\t\tassign\to_prof_ticks = prof_ticks;\n\tend else begin : NO_PROFILER\n\t\tassign\to_prof_stb = 1'b0;\n\t\tassign\to_prof_addr = 0;\n\t\tassign\to_prof_ticks = 0;\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Optional) Verilator $display simulation dumping support\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// The following is somewhat useful for debugging under Icarus Verilog.\n\t// In that case, the VCD file can tell you what's going on at any\n\t// specific moment, but it doesn't put the",
            "reg ister set into the VCD\n\t// file, nor does it give you any insight into the current contents of\n\t// the memory, or how they got that way.  The following is intended to\n\t// be a first step towards that end.\n\t//\n\t// As currently envisioned, we track values written to the",
            "reg isters,\n\t// and values read and written to memory.  The program counter offered\n\t// is typically off by 4 from the actual instruction address being\n\t// completed.  It may be off by more in the case of memory instructions.\n\t// I haven't (yet) tried to make the PC given match the instruction\n\t// address--so that may be an item to do later.\n\t//\n\t// You can activate (or de-activate) these instructions via the\n\t// OPT_SIM_DEBUG flag below.  If set to one, the simulation debuggin\n\t// statements will be",
            "output as the CPU executes.",
            "localparam OPT_SIM_DEBUG = 1'b0;\n\tgenerate if (OPT_SIM_DEBUG)\n\tbegin : GEN_SIM_DEBUG",
            "reg [31:0]\tnstime;\n\n\t\tinitial\tnstime = 0;\n\t\talways @(posedge i_clk)\n\t\t\tnstime <= nstime + 10;\n\n\t\talways @(posedge i_clk)\n\t\tif (!i_reset && o_mem_ce)\n\t\tbegin\n\t\t\tif (o_mem_",
            "reg [4] && !o_mem_op[0])\n\t\t\tbegin\n\t\t\t\tcase(o_mem_op[2:1])\n\t\t\t\t// 3'b000:\n\t\t\t\t// 3'b001:\n\t\t\t\t2'b01: $display(\"MEM: %8d LW uR%1d         <- @%08x\", nstime, o_mem_",
            "reg [3:0], o_mem_addr);\n\t\t\t\t2'b10: $display(\"MEM: %8d LH uR%1d         <- @%08x\", nstime, o_mem_",
            "reg [3:0], o_mem_addr);\n\t\t\t\t2'b11: $display(\"MEM: %8d LB uR%1d         <- @%08x\", nstime, o_mem_",
            "reg [3:0], o_mem_addr);\n\t\t\t\tdefault: $display(\"MEM: %8d Unknown MEM op: %d\\n\", nstime, o_mem_op);\n\t\t\tendcase\n\t\t\tend else case(o_mem_op[2:0])\n\t\t\t// 3'b000:\n\t\t\t// 3'b001:\n\t\t\t3'b010: $display(\"MEM: %8d LW sR%1d         <- @%08x\", nstime, o_mem_",
            "reg , o_mem_addr);\n\t\t\t3'b011: $display(\"MEM: %8d SW 0x%08x -> @%08x\", nstime, o_mem_data, o_mem_addr);\n\t\t\t3'b100: $display(\"MEM: %8d LH sR%1d         <- @%08x\", nstime, o_mem_",
            "reg , o_mem_addr);\n\t\t\t3'b101: $display(\"MEM: %8d SH 0x%08x -> @%04x\", nstime, o_mem_data[15:0], o_mem_addr);\n\t\t\t3'b110: $display(\"MEM: %8d LB sR%1d         <- @%08x\", nstime, o_mem_",
            "reg , o_mem_addr);\n\t\t\t3'b111: $display(\"MEM: %8d SB 0x%08x -> @%02x\", nstime, o_mem_data[7:0], o_mem_addr);\n\t\t\tdefault: $display(\"MEM: %8d Unknown MEM op: %d\\n\", nstime, o_mem_op);\n\t\t\tendcase\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tif (!i_reset && i_bus_err)\n\t\tbegin\n\t\t\t$display(\"MEM: %8d BUS ERROR!!\", nstime);\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tif (!i_reset && wr_",
            "reg _ce)\n\t\tbegin\n\t\t\tif (i_mem_valid)\n\t\t\tbegin\n\t\t\t\tif (i_mem_w",
            "reg [4])\n\t\t\t\t\t$display(\"MEM: %8d Load 0x%08x -> uR%1d\", nstime, i_mem_result, i_mem_w",
            "reg [3:0]);\n\t\t\t\telse\n\t\t\t\t\t$display(\"MEM: %8d Load 0x%08x -> sR%1d\", nstime, i_mem_result, i_mem_w",
            "reg [3:0]);\n\t\t\tend\n\n\t\t\tif (wr_",
            "reg _id[4] && OPT_USERMODE)\n\t\t\tbegin\n\t\t\t\tif (wr_",
            "reg _id[3:0] == CPU_PC_REG)\n\t\t\t\t\t$display(\"REG: %8d   uPC          <- 0x%08x [0x%08x]\", nstime, wr_sp",
            "reg _vl, (gie) ? upc : ipc);\n\t\t\t\telse if (wr_",
            "reg _id[3:0] == CPU_CC_REG)\n\t\t\t\t\t$display(\"REG: %8d   uCC          <- 0x%08x [0x%08x]\", nstime, wr_sp",
            "reg _vl, (gie) ? upc : ipc);\n\t\t\t\telse if (wr_",
            "reg _id == 4'hd)\n\t\t\t\t\t$display(\"REG: %8d   uSP          <- 0x%08x [0x%08x]\", nstime, wr_gp",
            "reg _vl, (gie) ? upc : ipc);\n\t\t\t\telse\n\t\t\t\t\t$display(\"REG: %8d   uR%1x          <- 0x%08x [0x%08x]\", nstime, wr_",
            "reg _id[3:0], wr_gp",
            "reg _vl, (gie) ? upc : ipc);\n\t\t\tend else begin\n\n\t\t\t\tif (wr_",
            "reg _id[3:0] == CPU_PC_REG)\n\t\t\t\t\t$display(\"REG: %8d   sPC          <- 0x%08x [0x%08x]\", nstime, wr_sp",
            "reg _vl, ipc);\n\t\t\t\telse if (wr_",
            "reg _id[3:0] == CPU_CC_REG)\n\t\t\t\t\t$display(\"REG: %8d   sCC          <- 0x%08x [0x%08x]\", nstime, wr_sp",
            "reg _vl, ipc);\n\t\t\t\telse if (wr_",
            "reg _id[3:0] == 4'hd)\n\t\t\t\t\t$display(\"REG: %8d   sSP          <- 0x%08x [0x%08x]\", nstime, wr_gp",
            "reg _vl, ipc);\n\t\t\t\telse\n\t\t\t\t\t$display(\"REG: %8d   sR%1x          <- 0x%08x [0x%08x]\", nstime, wr_",
            "reg _id[3:0], wr_gp",
            "reg _vl, ipc);\n\t\t\tend\n\t\tend\n\tend endgenerate\n\t// }}}\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, fpu_ce, wr_sp",
            "reg _vl[1:0],\n\t\tipc[1:0], upc[1:0], pf_pc[1:0],\n\t\tdcd_rA, dcd_pipe, dcd_zI,\n\t\tdcd_A_stall, dcd_B_stall, dcd_F_stall,\n\t\top_Rcc, op_pipe, op_lock, i_mem_pipe_stalled, prelock_stall,\n\t\tdcd_F, w_clken };\n\tgenerate if (AW+2 < 32)\n\tbegin : UNUSED_AW",
            "wire generic_ignore;\n\t\tassign\tgeneric_ignore = &{ 1'b0, wr_sp",
            "reg _vl[31:(AW+2)] };\n\tend if (!OPT_USERMODE)\n\tbegin : UNUSED_USERMODE",
            "wire unused_usermode;\n\t\tassign\tunused_usermode = &{ 1'b0, alu_",
            "reg [4], i_mem_w",
            "reg [4],\n\t\t\t\ti_dbg_r",
            "reg [4] };\n\tend endgenerate\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Declarations\n\t// {{{\n`ifdef\tZIPCPU\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif\n`define\tASSERT\tassert\n//\n//",
            "wire [1+1+4+15+6+4+13+AW+1+32+4+23-1:0]\tf_dcd_data;",
            "wire fc_op_prepipe;",
            "wire [6:0]\tfc_alu_Aid;",
            "wire fc_alu_wR, fc_alu_M, fc_alu_prepipe;",
            "reg f_alu_phase;",
            "reg f_past_valid;",
            "reg [2:0]\tf_dbg_pc_seq, f_dbg_cc_seq, f_dbg_",
            "reg _seq;",
            "wire fc_op_illegal, fc_op_wF, fc_op_ALU, fc_op_M,\n\t\t\tfc_op_DV, fc_op_FP, fc_op_break,\n\t\t\tfc_op_lock, fc_op_wR, fc_op_rA, fc_op_rB,\n\t\t\tfc_op_sim;",
            "wire [6:0]\tfc_op_Rid, fc_op_Aid, fc_op_Bid;",
            "wire [31:0]\tfc_op_I;",
            "wire [3:0]\tfc_op_cond;",
            "wire [3:0]\tfc_op_op;",
            "wire [22:0]\tfc_op_sim_immv;",
            "wire f_op_insn; //f_alu_insn,f_wb_insn",
            "reg f_op_phase, f_op_early_branch;",
            "reg f_op_zI;",
            "reg f_op_branch;",
            "wire [31:0]\tf_Bv;",
            "reg [31:0]\tf_Av, f_pre_Bv;",
            "reg f_alu_branch;",
            "wire [31:0]\tf_dcd_mem_addr;",
            "wire [AW-1:0]\tf_next_mem, f_op_mem_addr;",
            "wire [4+AW+2+7+4-1:0]\tf_op_data;",
            "wire fc_alu_illegal, fc_alu_wF, fc_alu_ALU, fc_alu_DV,\n\t\t\tfc_alu_FP, fc_alu_break, fc_alu_lock,\n\t\t\tfc_alu_rA, fc_alu_rB, fc_alu_sim;",
            "wire [6:0]\tfc_alu_Rid, fc_alu_Bid;",
            "wire [31:0]\tfc_alu_I;",
            "wire [3:0]\tfc_alu_cond;",
            "wire [3:0]\tfc_alu_op;",
            "wire [22:0]\tfc_alu_sim_immv;",
            "wire [F_LGDEPTH-1:0]\tf_mem_outstanding;",
            "wire f_mem_gie, f_mem_pc, f_read_cycle,\n\t\t\t\tf_exwrite_cycle;",
            "wire [4:0]\t\tf_last_",
            "reg , f_addr_",
            "reg ;\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n`ifndef\tVERIFIC\n\tinitial\tassume(i_reset);\n`endif\n\talways @(posedge i_clk)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The debugging interface\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tfdebug #(\n\t\t.OPT_START_HALTED(OPT_START_HALTED),\n\t\t.OPT_DISTRIBUTED_RAM(OPT_DISTRIBUTED_REGS)\n\t) fdbg (\n\t\t// {{{\n\t\t.i_clk(i_clk),\n\t\t.i_reset(i_reset),\n\t\t.i_cpu_reset(i_reset),\n\t\t.i_halt(i_halt),\n\t\t.i_halted(r_halted),\n\t\t.i_clear_cache(i_clear_cache),\n\t\t.i_dbg_we(i_dbg_we),\n\t\t.i_dbg_",
            "reg (i_dbg_w",
            "reg ),\n\t\t.i_dbg_data(i_dbg_data),\n\t\t.i_dbg_stall(o_dbg_stall),\n\t\t.i_dbg_break(o_break),\n\t\t.i_dbg_cc(o_dbg_cc)\n\t\t// , .i_dbg_r",
            "reg (i_dbg_r",
            "reg ),\n\t\t// .i_dbg_rdata(o_dbg_rdata),\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (i_halt && r_halted)\n\tbegin\n\t\t`ASSERT(!alu_ce);\n\t\t`ASSERT(!alu_phase);\n\t\t`ASSERT(!div_ce);\n\t\t`ASSERT(!o_mem_ce);\n\t\t`ASSERT(f_mem_outstanding == 0);\n\tend\n\n\tinitial\tf_dbg_pc_seq = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_dbg_pc_seq <= 0;\n\telse begin\n\t\tf_dbg_pc_seq[0] <= i_dbg_we && !o_dbg_stall\n\t\t\t\t&& (i_dbg_w",
            "reg == { gie, CPU_PC_REG });\n\t\tf_dbg_pc_seq[2:1] <= f_dbg_pc_seq[1:0];\n\tend\n\n\talways @(posedge i_clk)\n\tbegin\n\t\tif (f_dbg_pc_seq[0])\n\t\tbegin\n\t\t\t`ASSERT(dbgv && alu_",
            "reg == { gie, CPU_PC_REG });\n\t\tend\n\n\t\tif (f_dbg_pc_seq[1])\n\t\tbegin\n\t\t\t`ASSERT(clear_pipeline);\n\t\t\t`ASSERT(o_pf_request_address == $past({ i_dbg_data[31:2], 2'b00 },2));\n\t\tend\n\tend\n\n\tinitial\tf_dbg_cc_seq = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_dbg_cc_seq <= 0;\n\telse begin\n\t\tf_dbg_cc_seq[0] <= i_dbg_we && !o_dbg_stall\n\t\t\t\t&& (i_dbg_w",
            "reg == { gie, CPU_CC_REG });\n\t\tf_dbg_cc_seq[2:1] <= f_dbg_cc_seq[1:0];\n\tend\n\n\talways @(posedge i_clk)\n\tif (f_dbg_cc_seq[0])\n\tbegin\n\t\t`ASSERT(wr_",
            "reg _ce);\n\t\t`ASSERT(wr_",
            "reg _id == $past(i_dbg_w",
            "reg ));\n\t\t`ASSERT(wr_sp",
            "reg _vl == $past(i_dbg_data));\n\tend\n\n\tinitial\tf_dbg_",
            "reg _seq = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_dbg_",
            "reg _seq <= 0;\n\telse begin\n\t\tf_dbg_",
            "reg _seq[0] <= i_dbg_we && !o_dbg_stall\n\t\t\t\t&& (i_dbg_r",
            "reg [3:1] != 3'h7 );\n\t\tf_dbg_",
            "reg _seq[2:1] <= f_dbg_",
            "reg _seq[1:0];\n\tend\n\n\talways @(posedge i_clk)\n\tbegin\n\t\tif (f_dbg_",
            "reg _seq[0] && !i_reset)\n\t\tbegin\n\t\t\t`ASSERT(dbgv && alu_",
            "reg == $past(i_dbg_w",
            "reg ));\n\t\t\t`ASSERT($past(i_dbg_r",
            "reg [3:1]) != 3'h7);\n\t\t\t`ASSERT(dbg_val == $past(i_dbg_data));\n\n\t\t\t`ASSERT(wr_",
            "reg _ce);\n\t\t\t`ASSERT(wr_gp",
            "reg _vl == $past(i_dbg_data));\n\t\t\t`ASSERT(wr_",
            "reg _id == $past(i_dbg_w",
            "reg ));\n\t\tend\n\n\t\t// if (f_dbg_",
            "reg _seq[1])\n\t\t// begin\n\t\t// end\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Reset checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\tbegin\n\t\t// Initial assertions\n\t\t`ASSERT(!i_pf_valid);\n\t\t`ASSERT(!dcd_phase);\n\t\t`ASSERT(!op_phase);\n\t\t`ASSERT(!alu_phase);\n\t\t//\n\t\t`ASSERT(!i_pf_valid);\n\t\t`ASSERT(!dcd_valid);\n\t\t`ASSERT(!op_valid);\n\t\t`ASSERT(!op_valid_mem);\n\t\t`ASSERT(!op_valid_div);\n\t\t`ASSERT(!op_valid_alu);\n\t\t`ASSERT(!op_valid_fpu);\n\t\t//\n\t\t`ASSERT(!alu_valid);\n\t\t`ASSERT(!alu_busy);\n\t\t//\n\t\t`ASSERT(!i_mem_valid);\n\t\t`ASSERT(!i_mem_rdbusy);\n\t\t`ASSERT(!i_bus_err);\n\t\t//\n\t\t`ASSERT(!div_valid);\n\t\t`ASSERT(!div_busy);\n\t\t`ASSERT(!div_error);\n\t\t//\n\t\t`ASSERT(!fpu_valid);\n\t\t`ASSERT(!fpu_busy);\n\t\t`ASSERT(!fpu_error);\n\t\t//\n\t\t`ASSERT(!ill_err_i);\n\t\t`ASSERT(!ill_err_u);\n\t\t`ASSERT(!idiv_err_flag);\n\t\t`ASSERT(!udiv_err_flag);\n\t\t`ASSERT(!ibus_err_flag);\n\t\t`ASSERT(!ubus_err_flag);\n\t\t`ASSERT(!ifpu_err_flag);\n\t\t`ASSERT(!ufpu_err_flag);\n\t\t`ASSERT(!ihalt_phase);\n\t\t`ASSERT(!uhalt_phase);\n\tend\n\n\talways @(*)\n\tbegin\n\t\tif (i_pf_valid)\t\t`ASSERT(f_past_valid);\n\t\tif (dcd_valid)\t\t`ASSERT(f_past_valid);\n\t\tif (alu_pc_valid)\t`ASSERT(f_past_valid);\n\t\tif (i_mem_valid)\t`ASSERT(f_past_valid);\n\t\tif (div_valid)\t\t`ASSERT(f_past_valid);\n\t\tif (fpu_valid)\t\t`ASSERT(f_past_valid);\n\t\tif (w_op_valid)\t\t`ASSERT(f_past_valid);\n\t\t// if (i_mem_busy)\t`ASSERT(f_past_valid);\n\t\tif (i_mem_rdbusy)\t`ASSERT(f_past_valid);\n\t\tif (div_busy)\t\t`ASSERT(f_past_valid);\n\t\tif (fpu_busy)\t\t`ASSERT(f_past_valid);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Pipeline signaling check\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif (clear_pipeline)\n\tbegin\n\t\t// `ASSERT(!alu_ce);\n\t\t`ASSERT(!mem_ce);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(clear_pipeline)))\n\tbegin\n\t\t`ASSERT(!alu_busy);\n\t\t`ASSERT(!div_busy);\n\t\t`ASSERT(!i_mem_rdbusy);\n\t\t`ASSERT(!fpu_busy);\n\t\t//\n\t\t`ASSERT(!alu_valid);\n\t\t`ASSERT(!div_valid);\n\t\t`ASSERT(!fpu_valid);\n\tend\n\n\talways @(*)\n\tif (dcd_ce)\n\t\t`ASSERT((op_ce)||(!dcd_valid));\n\n\talways @(*)\n\tif ((op_ce)&&(!clear_pipeline))\n\t\t`ASSERT((adf_ce_unconditional)||(mem_ce)||(!op_valid));\n\n\t//\n\t// Make sure the dcd stage is never permanently stalled\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(alu_wR))&&(!$past(alu_wF))\n\t\t&&($past(f_past_valid,2))&&(!$past(alu_wR,2))&&(!$past(alu_wF))\n\t\t&&(!op_valid)&&(master_ce)\n\t\t&&(!clear_pipeline)&&(!i_reset)\n\t\t&&(!div_busy)&&(!div_valid)\n\t\t&&(!i_mem_busy)&&(!i_mem_valid)&&(!i_bus_err)\n\t\t&&(!alu_busy)&&(!alu_pc_valid)&&(!alu_valid)\n\t\t&&(!fpu_busy)&&(!fpu_valid)&&(!fpu_error)\n\t\t&&(!op_break)&&(!o_break)\n\t\t&&(!w_switch_to_interrupt)\n\t\t&&(!ibus_err_flag)&&(!ill_err_i)&&(!idiv_err_flag))\n\tbegin\n\t\tif (OPT_PIPELINED)\n\t\t\t`ASSERT(dcd_ce || cc_invalid_for_dcd || i_halt);\n\t\tif (!dcd_valid)\n\t\t\t`ASSERT(dcd_ce);\n\tend\n\n\talways @(posedge i_clk)\n\tif (OPT_PIPELINED && !i_halt && !i_reset && (wr_flags_ce\n\t\t\t|| (wr_",
            "reg _ce && wr_",
            "reg _id == { op_gie, CPU_CC_REG })))\n\t\t`ASSERT(cc_invalid_for_dcd);\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || !OPT_PIPELINED)\n\tbegin\n\t\t`ASSERT(!cc_invalid_for_dcd);\n\tend else if (alu_busy)\n\tbegin\n\t\t`ASSERT(cc_invalid_for_dcd == (alu_wF || alu_",
            "reg == { gie, CPU_CC_REG }));\n\tend else if (i_mem_rdbusy || i_bus_err)\n\tbegin\n\t\t`ASSERT(i_bus_err || f_exwrite_cycle\n\t\t\t|| cc_invalid_for_dcd == (alu_",
            "reg == { gie, CPU_CC_REG }));\n\tend else if (!clear_pipeline && cc_invalid_for_dcd)\n\tbegin\n\t\t`ASSERT(alu_illegal || wr_flags_ce\n\t\t\t|| ((i_mem_valid || i_bus_err)\n\t\t\t\t&& ($past(i_mem_rdbusy\n\t\t\t\t\t&& f_last_",
            "reg == { gie, CPU_CC_REG })))\n\t\t\t|| (wr_flags_ce || (wr_",
            "reg _ce && wr_",
            "reg _id == { op_gie, CPU_CC_REG }))\n\t\t\t|| ($past(wr_flags_ce)\n\t\t\t\t|| $past(wr_",
            "reg _ce && wr_",
            "reg _id == { op_gie, CPU_CC_REG })));\n\tend\n\n\t//\n\t// Make sure the ops stage is never permanently stalled\n\talways @(*)\n\tif ((op_valid)&&(master_ce)&&(!clear_pipeline)&&(!i_reset)\n\t\t&&(!div_busy)&&(!div_valid)\n\t\t&&(!i_mem_busy)&&(!i_mem_valid)&&(!i_bus_err)\n\t\t&&(!alu_busy)&&(!alu_pc_valid)\n\t\t&&(!fpu_busy)&&(!fpu_valid)&&(!fpu_error)\n\t\t&&(!op_break)&&(!o_break)\n\t\t&&(!w_switch_to_interrupt)\n\t\t&&(!alu_illegal) && (!prelock_stall)\n\t\t&&(!step || !stepped)\n\t\t&&(!ibus_err_flag)&&(!ill_err_i)&&(!idiv_err_flag))\n\t\t`ASSERT(adf_ce_unconditional | mem_ce);\n\n\t// always @(posedge i_clk)\n\t// if (f_past_valid&& $past(op_valid && dcd_valid && i_pf_valid\n\t//\t\t\t&& !op_ce))\n\t//\t`ASSERT(!prelock_stall);\n\n\t//\n\t// Make sure that, following an op_ce && op_valid, op_valid is only\n\t// true if dcd_valid was as well\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(op_ce && op_valid && !dcd_valid)))\n\tbegin\n\t\tif ($past(dcd_early_branch))\n\t\tbegin\n\t\t\t`ASSERT(!dcd_early_branch);\n\t\tend else\n\t\t\t`ASSERT(!op_valid);\n\tend\n\n\t//\n\t// Same for the next step\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(op_valid && (mem_ce ||adf_ce_unconditional)))\n\t\t\t&&(!$past(dcd_valid)))\n\tbegin\n\t\tif ($past(dcd_early_branch))\n\t\tbegin\n\t\t\t`ASSERT(!dcd_early_branch);\n\t\tend else\n\t\t\t`ASSERT(!op_valid);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about the Program counter\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(*)\n\tif (i_pf_valid)\n\t\t`ASSERT(i_pf_instruction_pc[1:0]==2'b00);\n\n\talways @(*)\n\tif ((dcd_valid)&&(!dcd_illegal))\n\t\t`ASSERT((!dcd_pc[1])||(dcd_phase));\n\n\talways @(*)\n\t\t`ASSERT(!op_pc[0]);\n\n\talways @(*)\n\t\t`ASSERT(!alu_pc[0]);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about the prefetch (",
            "output ) stage\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif ((!clear_pipeline)&&(i_pf_valid))\n\t\t`ASSERT(pf_gie == gie);\n\n\talways @(*)\n\tif ((i_pf_valid)&&(!clear_pipeline))\n\t\t`ASSERT(pf_gie == gie);\n\n\tffetch #(.ADDRESS_WIDTH(ADDRESS_WIDTH), .OPT_CONTRACT(1'b0),\n\t\t.OPT_ALIGNED(1'b1))\n\tchkifetch(\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.cpu_new_pc(o_pf_new_pc),\n\t\t.cpu_clear_cache(o_clear_icache),\n\t\t.cpu_pc(o_pf_request_address), .pf_valid(i_pf_valid),\n\t\t.cpu_ready(o_pf_ready), .pf_pc(i_pf_instruction_pc),\n\t\t.pf_insn(i_pf_instruction), .pf_illegal(i_pf_illegal));\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about the decode stage\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tassign\tf_dcd_data = {\n\t\t\tdcd_phase,\n\t\t\tdcd_opn, dcd_A, dcd_B, dcd_R,\t// 4+15\n\t\t\tdcd_Acc, dcd_Bcc, dcd_Apc, dcd_Bpc, dcd_Rcc, dcd_Rpc,//6\n\t\t\tdcd_F,\t\t// 4\n\t\t\tdcd_wR, dcd_rA, dcd_rB,\n\t\t\t\tdcd_ALU, dcd_M, dcd_DIV, dcd_FP,\n\t\t\t\tdcd_wF, dcd_gie, dcd_break, dcd_lock,\n\t\t\t\tdcd_pipe, dcd_ljmp,\n\t\t\tdcd_pc, \t// AW+1\n\t\t\tdcd_I,\t\t// 32\n\t\t\tdcd_zI,\t// true if dcd_I == 0\n\t\t\tdcd_illegal,\n\t\t\tdcd_early_branch,\n\t\t\tdcd_sim, dcd_sim_immv\n\t\t};\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&(!$past(clear_pipeline))\n\t\t\t&&(!$past(o_clear_icache))\n\t\t\t&&($past(dcd_valid))&&($past(dcd_stalled))\n\t\t\t&&(!clear_pipeline))\n\tbegin\n\t\t`ASSERT((!OPT_PIPELINED)||(dcd_valid));\n\t\t`ASSERT((!dcd_valid && OPT_LOWPOWER) || $stable(f_dcd_data));\n\t\t`ASSERT((!dcd_valid && OPT_LOWPOWER) || $stable(f_dcd_insn_word));\n\tend\n\n\talways @(*)\n\tif ((dcd_valid || dcd_phase)&&(!clear_pipeline))\n\t\t`ASSERT(f_dcd_insn_gie == dcd_gie);\n\n\talways @(posedge i_clk)\n\tif ((dcd_valid)&&(!dcd_illegal)&&(!clear_pipeline))\n\tbegin\n\t\t`ASSERT(dcd_gie == gie);\n\t\tif ((gie)||(dcd_phase))\n\t\tbegin\n\t\t\t`ASSERT((!dcd_wR)||(dcd_R[4]==dcd_gie));\n\t\t\t`ASSERT((!dcd_rA)||(dcd_A[4]==dcd_gie));\n\t\t\t`ASSERT((!dcd_rB)||(dcd_B[4]==dcd_gie));\n\t\tend else if ((!dcd_early_branch)&&((dcd_M)\n\t\t\t\t||(dcd_DIV)||(dcd_FP)||(!dcd_wR)))\n\t\t\t`ASSERT(!dcd_gie);\n\t\tif ((dcd_ALU)&&(dcd_opn==CPU_MOV_OP))\n\t\tbegin\n\t\t\t`ASSERT(((!dcd_rA)&&(dcd_wR))\n\t\t\t\t||((!dcd_rA)&&(!dcd_rB)&&(!dcd_wR)));\n\t\tend else if (dcd_ALU)\n\t\t\t`ASSERT(\n\t\t\t\t(gie == dcd_R[4])\n\t\t\t\t&&(gie == dcd_A[4])\n\t\t\t\t&&((!dcd_rB)||(gie == dcd_B[4]))\n\t\t\t\t&&(dcd_gie == gie));\n\tend\n\n\talways @(*)\n\tif ((op_valid)&&(op_rA)&&(op_Aid[3:1] == 3'h7)&&(!clear_pipeline)\n\t\t\t\t&&(op_Aid[4:0] != { gie, 4'hf}))\n\t\t`ASSERT(!pending_s",
            "reg _write);\n\n\talways @(*)\n\tif ((op_valid)&&(op_rB)&&(op_Bid[3:1] == 3'h7)&&(!clear_pipeline)\n\t\t\t\t&&(op_Bid[4:0] != { gie, 4'hf}))\n\t\t`ASSERT(!pending_s",
            "reg _write);\n\n\n\talways @(*)\n\tif ((dcd_valid)&&(!clear_pipeline))\n\t\t`ASSERT(dcd_gie == gie);\n\n\t//\n\t//\n\t// Piped Memory assertions\n\t//\n\t//\n\talways @(*)\n\tif ((dcd_valid)&&(dcd_M)&&(dcd_pipe)&&(!dcd_illegal)&&(!alu_illegal)\n\t\t\t&&(!break_pending)&&(!clear_pipeline))\n\tbegin\n\t\tif (op_valid_mem)\n\t\tbegin\n\t\t\t`ASSERT(op_opn[0]   == dcd_opn[0]);\n\t\t\t`ASSERT((!dcd_rB)\n\t\t\t\t||(op_Bid[4:0] == dcd_B[4:0]));\n\t\t\t`ASSERT(op_rB  == dcd_rB);\n\t\tend\n\t\t`ASSERT(dcd_B[4] == dcd_gie);\n\tend\n\n\talways @(*)\n\tif (op_valid_mem && op_pipe && i_mem_busy)\n\t\t`ASSERT(f_read_cycle == !op_opn[0]);\n\n\talways @(*)\n\tif ((dcd_valid)&&(!dcd_M))\n\t\t`ASSERT((dcd_illegal)||(!dcd_pipe));\n\n\tassign\tf_dcd_mem_addr = w_op_BnI+dcd_I;\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(dcd_early_branch))&&(!dcd_early_branch)\n\t\t\t&&(dcd_valid))\n\t\t`ASSERT(!dcd_pipe);\n\talways @(*)\n\tif ((dcd_valid)&&(dcd_early_branch))\n\t\t`ASSERT(!dcd_M);\n\n\talways @(*)\n\tif ((dcd_valid)&&(!dcd_illegal)&&(!fc_op_prepipe))\n\t\t`ASSERT(!dcd_pipe);\n\n\talways @(*)\n\tif ((dcd_valid)&&(dcd_pipe)&&(w_op_valid))\n\tbegin\n\t\t// `ASSERT((dcd_A[3:1] != 3'h7)||(dcd_opn[0]));\n\t\t`ASSERT(dcd_B[3:1] != 3'h7);\n\t\t`ASSERT(dcd_rB);\n\t\t`ASSERT(dcd_M);\n\t\t`ASSERT(dcd_B == op_Bid);\n\t\tif (op_valid)\n\t\t\t`ASSERT((op_valid_mem)||(op_illegal));\n\n\t\tif (op_valid_mem)\n\t\tbegin\n\t\t\t`ASSERT((dcd_I[AW+1:3] == 0)\n\t\t\t\t||(!alu_busy)||(!div_busy)\n\t\t\t\t||(!alu_wR)||(alu_",
            "reg != dcd_B));\n\t\t\t`ASSERT((!op_wR)||(op_Aid != op_Bid));\n\t\tend\n\tend\n\n\t//\n\t// Decode option processing\n\t//\n\n\t// OPT_CIS ... the compressed instruction set\n\talways @(*)\n\tif ((!OPT_CIS)&&(dcd_valid))\n\tbegin\n\t\t`ASSERT(!dcd_phase);\n\t\t`ASSERT(dcd_pc[1:0] == 2'b0);\n\tend\n\n\talways @(*)\n\tif ((dcd_valid)&&(dcd_phase))\n\t\t`ASSERT(f_dcd_insn_word[31]);\n\n\n\t// OPT_EARLY_BRANCHING\n\talways @(*)\n\tif (!OPT_EARLY_BRANCHING)\n\t\t`ASSERT((!dcd_early_branch)\n\t\t\t\t\t&&(!dcd_early_branch_stb)\n\t\t\t\t\t&&(!dcd_ljmp));\n\n\t// OPT_DIV\n\talways @(*)\n\tif ((dcd_DIV)&&(dcd_valid)&&(!dcd_illegal))\n\t\t`ASSERT(dcd_wR);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about the op stage\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tassign\tf_op_data = { op_valid_mem, op_valid_alu,\n\t\t\top_valid_div, op_valid_fpu,\n\t\t// The Av and Bv values can change while we are stalled in the\n\t\t// op stage--that's why we are stalled there\n\t\t//\tr_op_Av, r_op_Bv,\t// 32 ea\n\t\t\top_pc[AW+1:2],\t\t// AW\n\t\t\top_wR, op_wF,\n\t\t\tr_op_F,\t\t\t// 7\n\t\t\top_illegal, op_break,\n\t\t\top_lock, op_pipe\n\t\t\t};\n\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(op_valid))&&(!$past(i_reset))\n\t\t\t&&(!$past(clear_pipeline)))\n\tbegin\n\t\tif (($past(op_valid_mem))&&($past(mem_stalled)))\n\t\t\t`ASSERT($stable(f_op_data[AW+16:1])&&(!$rose(op_pipe)));\n\t\tif (($past(op_valid_div))&&($past(div_busy)))\n\t\t\t`ASSERT($stable(f_op_data));\n\tend\n\n\tf_idecode #(\n\t\t// {{{\n\t\t.OPT_MPY((OPT_MPY!=0)? 1'b1:1'b0),\n\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t.OPT_DIVIDE(OPT_DIV),\n\t\t.OPT_FPU(IMPLEMENT_FPU),\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_OPIPE(OPT_PIPELINED_BUS_ACCESS),\n\t\t.OPT_SIM(1'b0),\n\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.OPT_CIS(OPT_CIS)\n\t\t// }}}\n\t) f_insn_decode_op(\n\t\t// {{{\n\t\tf_op_insn_word, f_op_phase, op_gie,\n\t\tfc_op_illegal, fc_op_Rid, fc_op_Aid, fc_op_Bid,\n\t\tfc_op_I, fc_op_cond, fc_op_wF, fc_op_op, fc_op_ALU,\n\t\tfc_op_M, fc_op_DV, fc_op_FP, fc_op_break, fc_op_lock,\n\t\tfc_op_wR, fc_op_rA, fc_op_rB, fc_op_prepipe,\n\t\tfc_op_sim, fc_op_sim_immv\n\t\t// }}}\n\t);\n\n\tinitial\tf_op_early_branch = 1'b0;\n\talways @(posedge i_clk)\n\tif (op_ce && (!OPT_MEMPIPE || dcd_valid || dcd_illegal || dcd_early_branch))\n\tbegin\n\t\tf_op_insn_word <= f_dcd_insn_word;\n\t\tf_op_phase <= dcd_phase;\n\t\tf_op_early_branch <= dcd_early_branch;\n\t\tf_op_zI <= dcd_zI;\n\tend\n\n\tinitial\tf_op_branch = 1'b0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(clear_pipeline))\n\t\tf_op_branch <= 1'b0;\n\telse if (op_ce)\n\t\tf_op_branch <= (dcd_early_branch)||dcd_ljmp;\n\telse if ((adf_ce_unconditional)||(mem_ce))\n\t\tf_op_branch <= 1'b0;\n\n\talways @(*)\n\tif (!OPT_EARLY_BRANCHING)\n\tbegin\n\t\t`ASSERT(!f_op_branch);\n\tend else if ((f_op_early_branch)&&(op_valid))\n\t\t`ASSERT(f_op_branch);\n\n\n\talways @(posedge i_clk)\n\tif (op_valid &&(f_op_branch || !fc_op_illegal)&& !clear_pipeline)\n\tbegin\n\t\t// {{{\n\t\tif (f_op_branch)\n\t\tbegin\n\t\t\t// {{{\n\t\t\t`ASSERT(!op_valid_alu);\n\t\t\t`ASSERT(!op_valid_mem);\n\t\t\t`ASSERT(!op_valid_div);\n\t\t\t`ASSERT(!op_valid_fpu);\n\t\t\t`ASSERT(!op_illegal);\n\t\t\t`ASSERT(!op_rA);\n\t\t\t`ASSERT(!op_rB);\n\t\t\t`ASSERT(!op_wR);\n\t\t\t`ASSERT(!op_wF);\n\t\t\t`ASSERT(op_opn == CPU_MOV_OP);\n\t\t\t// }}}\n\t\tend\n\n\t\tif (op_illegal)\n\t\tbegin\n\t\t\t// {{{\n\t\t\t`ASSERT(!op_valid_mem);\n\t\t\t`ASSERT(!op_valid_div);\n\t\t\t`ASSERT(!op_valid_fpu);\n\t\t\t`ASSERT( op_valid_alu);\n\t\t\t`ASSERT((!OPT_PIPELINED)||(!op_rA));\n\t\t\t`ASSERT((!OPT_PIPELINED)||(!op_rB));\n\t\t\t`ASSERT(!f_op_branch);\n\t\t\t// }}}\n\t\tend else begin\n\t\t\tif (!f_op_branch)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\t`ASSERT(fc_op_ALU == op_valid_alu);\n\t\t\t\t`ASSERT(fc_op_M   == op_valid_mem);\n\t\t\t\t`ASSERT(fc_op_DV  == op_valid_div);\n\t\t\t\t`ASSERT(fc_op_FP  == op_valid_fpu);\n\t\t\t\t`ASSERT(fc_op_rA == op_rA);\n\t\t\t\t`ASSERT(fc_op_rB == op_rB);\n\t\t\t\t`ASSERT(fc_op_wF == op_wF);\n\t\t\t\t`ASSERT(fc_op_Rid[4:0] == op_R);\n\t\t\t\t`ASSERT(f_op_zI == (fc_op_I == 0));\n\t\t\t\t`ASSERT(fc_op_wF  == op_wF);\n\t\t\t\t`ASSERT(fc_op_lock == op_lock);\n\t\t\t\tif (!OPT_PIPELINED && step && stepped)\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!op_break);\n\t\t\t\tend else begin\n\t\t\t\t\t`ASSERT(fc_op_break == op_break);\n\t\t\t\tend\n\t\t\t\t`ASSERT(fc_op_I == 0 || !i_mem_rdbusy\n\t\t\t\t\t|| f_exwrite_cycle\n\t\t\t\t\t|| !fc_op_rB\n\t\t\t\t\t|| (fc_op_Bid[4:0] != f_last_",
            "reg && (f_mem_outstanding <= 1)\n\t\t\t\t\t\t&& (!fc_op_M || !op_pipe))\n\t\t\t\t\t|| fc_op_Bid[4:0] == f_addr_",
            "reg );\n\t\t\t\tif (!i_halt && !i_reset && !f_exwrite_cycle)\n\t\t\t\t`ASSERT((!wr_",
            "reg _ce)\n\t\t\t\t\t||(wr_",
            "reg _id != fc_op_Bid[4:0])\n\t\t\t\t\t||(!op_rB)||(fc_op_I == 0));\n\n\t\t\t\t`ASSERT(fc_op_sim == op_sim);\n\t\t\t\t`ASSERT(fc_op_sim_immv == op_sim_immv);\n\n\t\t\t\tcase(fc_op_cond[2:0])\n\t\t\t\t3'h0:\t`ASSERT(op_F == 8'h00);\t// Always\n\t\t\t\t3'h1:\t`ASSERT(op_F == 8'h11);\t// Z\n\t\t\t\t3'h2:\t`ASSERT(op_F == 8'h44);\t// LT\n\t\t\t\t3'h3:\t`ASSERT(op_F == 8'h22);\t// C\n\t\t\t\t3'h4:\t`ASSERT(op_F == 8'h88);\t// V\n\t\t\t\t3'h5:\t`ASSERT(op_F == 8'h10);\t// NE\n\t\t\t\t3'h6:\t`ASSERT(op_F == 8'h40);\t// GE (!N)\n\t\t\t\t3'h7:\t`ASSERT(op_F == 8'h20);\t// NC\n\t\t\t\tendcase\n\n\t\t\t\tif ((fc_op_wR)&&(fc_op_Rid[4:0] == { gie, CPU_PC_REG}))\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!op_phase);\n\t\t\t\tend else\n\t\t\t\t\t`ASSERT(f_op_phase == op_phase);\n\t\t\t\t// }}}\n\t\t\tend // Bit order is { (flags_not_used), VNCZ mask, VNCZ value }\n\t\t\t`ASSERT((!op_wR)||(fc_op_Rid[4:0] == op_R));\n\t\t\t`ASSERT(((!op_wR)&&(!op_rA))||(fc_op_Aid[4:0] == op_Aid[4:0]));\n\t\t\t`ASSERT((!op_rB)||(fc_op_Bid[4:0] == op_Bid));\n\t\t\t//\n\t\t\t// if ((!alu_illegal)&&(!ill_err_i)&&(!clear_pipeline))\n\n\t\t\tif (f_op_early_branch)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\t`ASSERT(op_opn  == CPU_MOV_OP);\n\t\t\t\t`ASSERT(!op_wR);\n\t\t\t\t`ASSERT(!op_wF);\n\t\t\t\t`ASSERT(f_op_branch);\n\t\t\t\t// }}}\n\t\t\tend else begin\n\t\t\t\t// {{{\n\t\t\t\t`ASSERT(fc_op_op  == op_opn);\n\t\t\t\t`ASSERT(fc_op_wR == op_wR);\n\t\t\t\t// }}}\n\t\t\tend\n\t\tend\n\t\tif (!OPT_PIPELINED_BUS_ACCESS)\n\t\t\t`ASSERT((!i_mem_rdbusy)||(i_mem_w",
            "reg != fc_op_Bid)\n\t\t\t\t||(!fc_op_rB)||(fc_op_I == 0));\n\t\t// }}}\n\tend else if (op_valid && !clear_pipeline && fc_op_illegal)\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(op_illegal);\n\t\t`ASSERT(op_valid_alu);\n\t\t`ASSERT(!f_op_branch);\n\t\t// }}}\n\tend\n\n\talways @(*)\n\tif ((op_valid)&&(op_illegal))\n\tbegin\n\t\t`ASSERT(!op_valid_div);\n\t\t`ASSERT(!op_valid_fpu);\n\t\t`ASSERT(!op_valid_mem);\n\tend\n\n//\talways @(*)\n//\tif (!op_valid)\n//\t\t`ASSERT(!op_break);\n\n\talways @(*)\n\tif ((!OPT_CIS)&&(op_valid))\n\tbegin\n\t\t`ASSERT((!op_phase)||(op_illegal));\n\t\t`ASSERT(op_pc[1:0] == 2'b0);\n\tend\n\n\talways @(*)\n\tif ((!OPT_LOCK)&&(op_valid))\n\t\t`ASSERT((!op_lock)||(op_illegal));\n\n\talways @(*)\n\tif (!OPT_EARLY_BRANCHING)\n\t\t`ASSERT(!f_op_early_branch);\n\n\n\talways @(*)\n\tif (op_ce)\n\t\t`ASSERT((dcd_valid)||(dcd_illegal)||(dcd_early_branch));\n\n\talways @(*)\n\tif ((f_past_valid)&&(!f_op_zI)&&(i_mem_rdbusy)&&(op_valid)&&(op_rB))\n\t\t`ASSERT((!OPT_DCACHE)||(OPT_MEMPIPE)\n\t\t\t||(i_mem_w",
            "reg != op_Bid));\n\n\talways @(posedge i_clk)\n\tif ((op_valid)&&(op_rB)&&(!f_op_zI)&&((i_mem_rdbusy)||(i_mem_valid))\n\t\t&&(i_mem_w",
            "reg != {gie, CPU_PC_REG}))\n\tbegin\n\t\tif (!OPT_MEMPIPE)\n\t\tbegin\n\t\t\t`ASSERT(fc_alu_Aid[4:0] == i_mem_w",
            "reg );\n\t\t\t`ASSERT(i_mem_w",
            "reg != op_Bid);\n\t\tend\n\tend\n\n\talways @(posedge i_clk)\n\tif (i_mem_rdbusy)\n\tbegin\n\t\t`ASSERT(fc_alu_M);\n\t\t`ASSERT(!OPT_PIPELINED||fc_alu_wR || (OPT_LOCK && f_mem_pc));\n\tend\n\n\talways @(*)\n\tif ((op_valid)&&(!clear_pipeline))\n\t\t`ASSERT(op_gie == gie);\n\n\talways @(*)\n\tif ((op_valid_alu)&&(!op_illegal))\n\tbegin\n\t\tif ((op_opn != CPU_SUB_OP)\n\t\t\t&&(op_opn != CPU_AND_OP)\n\t\t\t&&(op_opn != CPU_MOV_OP))\n\t\tbegin\n\t\t\t`ASSERT(op_wR);\n\t\tend\n\t\tif ((op_opn != CPU_MOV_OP)&&(op_opn != CPU_BREV_OP))\n\t\t\t`ASSERT(op_rA);\n\tend\n\n\n\talways @(posedge i_clk)\n\tif ((op_valid)&&(!op_illegal)\n\t\t\t&&(!alu_illegal)&&(!ill_err_i)&&(!clear_pipeline))\n\tbegin\n\t\t`ASSERT(op_gie == gie);\n\t\tif ((gie)||(op_phase))\n\t\tbegin\n\t\t\t`ASSERT((!op_wR)||(op_R[4] == gie));\n\t\t\t`ASSERT((!op_rA)||(op_Aid[4] == gie));\n\t\t\t`ASSERT((!op_rB)||(op_Bid[4] == gie));\n\t\tend else if (((op_valid_mem)\n\t\t\t\t||(op_valid_div)||(op_valid_fpu)\n\t\t\t\t||((op_valid_alu)&&(op_opn!=CPU_MOV_OP))))\n\t\tbegin\n\t\t\t`ASSERT((!op_wR)||(op_R[4] == gie));\n\t\t\t`ASSERT((!op_rA)||(op_Aid[4] == gie));\n\t\t\t`ASSERT((!op_rB)||(op_Bid[4] == gie));\n\t\tend\n\tend\n\n\talways @(posedge i_clk)\n\tif ((!op_valid)&&(!$past(op_illegal))\n\t\t\t&&(!clear_pipeline)&&(!pending_interrupt))\n\t\t`ASSERT(!op_illegal);\n\n\talways @(*)\n\tbegin\n\t\tif (alu_ce)\n\t\t\t`ASSERT(adf_ce_unconditional);\n\t\tif (div_ce)\n\t\t\t`ASSERT(adf_ce_unconditional);\n\t\tif (fpu_ce)\n\t\t\t`ASSERT(adf_ce_unconditional);\n\n\t\tif ((op_valid)&&(op_illegal))\n\t\t\t`ASSERT(op_valid_alu);\n\tend\n\n\talways @(*)\n\tif (mem_ce)\n\t\t`ASSERT((op_valid)&&(op_valid_mem)&&(!op_illegal));\n\n\talways @(*)\n\tif (div_ce)\n\t\t`ASSERT(op_valid_div);\n\n\n\talways @(*)\n\tif ((ibus_err_flag)||(ill_err_i)||(idiv_err_flag))\n\tbegin\n\t\t`ASSERT(master_stall);\n\t\t`ASSERT(!mem_ce);\n\t\t`ASSERT(!alu_ce);\n\t\t`ASSERT(!div_ce);\n\t\t`ASSERT(!adf_ce_unconditional);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((adf_ce_unconditional)||(mem_ce))\n\t\t`ASSERT(op_valid);\n\n\talways @(*)\n\tif ((op_valid_alu)&&(!adf_ce_unconditional)&&(!clear_pipeline))\n\t\t`ASSERT(!op_ce);\n\n\talways @(*)\n\tif ((op_valid_div)&&(!adf_ce_unconditional))\n\t\t`ASSERT(!op_ce);\n\n\talways @(posedge i_clk)\n\tif (alu_stall)\n\t\t`ASSERT(!alu_ce);\n\talways @(posedge i_clk)\n\tif (mem_stalled)\n\t\t`ASSERT(!o_mem_ce);\n\talways @(posedge i_clk)\n\tif (div_busy)\n\t\t`ASSERT(!div_ce);\n\n\talways @(*)\n\tif ((!i_reset)&&(break_pending)&&(!clear_pipeline))\n\t\t`ASSERT((op_valid)&&(op_break));\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Memory\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Op: Memory pipeline assertions\n\t//\n\n\tassign\tf_next_mem    = o_mem_addr + 1'b1;\n\tassign\tf_op_mem_addr = op_Bv[AW+1:2];\n\n\tfmem #(\n\t\t// {{{\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t.OPT_MAXDEPTH((OPT_PIPELINED && OPT_PIPELINED_BUS_ACCESS)\n\t\t\t\t\t? 14:1),\n\t\t.OPT_AXI_LOCK(2)\t// Let the solver pick\n\t\t// }}}\n\t) chkmemops(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_sys_reset(i_reset), .i_cpu_reset(i_reset),\n\t\t//\n\t\t.i_stb(o_mem_ce),\n\t\t.i_pipe_stalled(i_mem_pipe_stalled),\n\t\t.i_clear_cache(o_clear_dcache),\n\t\t.i_lock(o_bus_lock),\n\t\t.i_op(o_mem_op), .i_data(o_mem_data), .i_addr(o_mem_addr),\n\t\t\t.i_o",
            "reg (o_mem_",
            "reg ), .i_a",
            "reg (op_Bid),\n\t\t.i_busy(i_mem_busy),.i_rdbusy(i_mem_rdbusy),\n\t\t.i_valid(i_mem_valid), .i_err(i_bus_err), .i_w",
            "reg (i_mem_w",
            "reg ),\n\t\t.i_result(i_mem_result),\n\t\t.f_outstanding(f_mem_outstanding),\n\t\t.f_pc(f_mem_pc), .f_gie(f_mem_gie),\n\t\t.f_read_cycle(f_read_cycle),\n\t\t.f_axi_write_cycle(f_exwrite_cycle),\n\t\t.f_last_",
            "reg (f_last_",
            "reg ), .f_addr_",
            "reg (f_addr_",
            "reg )\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif ((op_valid)&&(!fc_alu_prepipe))\n\t\t`ASSERT((!op_valid_mem)||(!op_pipe));\n\n\t// Validate op_opn and (some of) op_Bid\n\t// {{{\n\talways @(*)\n\tif ((op_valid_mem)&&(op_pipe))\n\tbegin\n\t\t// {{{\n\t\tif (i_mem_rdbusy)\n\t\t\t`ASSERT(op_opn[0] == f_exwrite_cycle);\n\t\tif (f_mem_outstanding > ((i_bus_err || i_mem_valid) ? 1:0))\n\t\t\t`ASSERT(op_opn[0] != fc_alu_wR);\n\n\t\t// if ((i_mem_busy)&&(!i_mem_rdbusy && !i_mem_valid))\n\t\t//\t`ASSERT(!o_mem_ce || op_opn[0] == 1'b1);\n\n\t\tif (i_mem_rdbusy)\n\t\tbegin\n\t\t\tif (OPT_PIPELINED_BUS_ACCESS)\n\t\t\tbegin end\n\t\t\telse if (OPT_DCACHE)\n\t\t\t\t`ASSERT(!i_mem_valid || i_mem_w",
            "reg != op_Bid);\n\t\tend\n\t\t// }}}\n\tend\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif (op_valid_mem && op_pipe)\n\tbegin\n\t\t// {{{\n\t\tif ((i_mem_busy)&&(!OPT_DCACHE))\n\t\t\t`ASSERT((f_op_mem_addr == o_mem_addr)\n\t\t\t\t||(f_op_mem_addr == f_next_mem));\n\t\tif (i_mem_valid)\n\t\t\t`ASSERT(op_Bid != i_mem_w",
            "reg );\n\n\t\tif (alu_busy||alu_valid)\n\t\t\t`ASSERT((!alu_wR)||(op_Bid != alu_",
            "reg ));\n\n\t\tif (f_past_valid)\n\t\tbegin\n\t\t\tif ((i_mem_busy)&&(!OPT_DCACHE))\n\t\t\t`ASSERT((op_Bv[(AW+1):2]==o_mem_addr[(AW-1):0])\n\t\t\t\t||(op_Bv[(AW+1):2]==o_mem_addr[(AW-1):0]+1'b1));\n\n\t\t\tif ($past(mem_ce))\n\t\t\t\t`ASSERT(op_Bid == $past(op_Bid));\n\t\tend\n\n\t\t`ASSERT(op_Bid[3:1] != 3'h7);\n\n\t\tif ((i_mem_rdbusy||i_mem_valid) && !f_exwrite_cycle)\n\t\tbegin\n\t\t\tif (!OPT_MEMPIPE)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\t`ASSERT(fc_alu_Aid[4:0] == i_mem_w",
            "reg );\n\t\t\t\t`ASSERT(i_mem_w",
            "reg != op_Bid);\n\t\t\t\t// }}}\n\t\t\tend else if (OPT_DCACHE)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\t`ASSERT(fc_alu_Aid[4:0] != op_Bid);\n\t\t\t\t// }}}\n\t\t\tend else // if (!OPT_DCACHE)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\tif ((i_mem_valid)\n\t\t\t\t\t||($past(i_mem_rdbusy)))\n\t\t\t\t\t`ASSERT(i_mem_w",
            "reg != op_Bid);\n\t\t\t\t// }}}\n\t\t\tend\n\t\tend\n\t\t// }}}\n\tend\n\n\talways @(*)\n\tif ((dcd_valid)&&(dcd_pipe))\n\t\t`ASSERT((op_Aid[3:1] != 3'h7)||(op_opn[0]));\n\n\talways @(*)\n\tif ((op_valid)&(!op_valid_mem))\n\t\t`ASSERT((op_illegal)||(!op_pipe));\n\n\t// Check f_addr_",
            "reg and f_last_",
            "reg // {{{\n\talways @(*)\n\tif (OPT_MEMPIPE && (op_valid && op_rB) && !f_exwrite_cycle\n\t\t\t&&(!f_op_zI)&&(i_mem_rdbusy || i_mem_valid))\n\t\t`ASSERT(f_last_",
            "reg != op_Bid);\n\n\talways @(*)\n\tif (i_mem_rdbusy && !f_exwrite_cycle)\n\t\t`ASSERT(f_last_",
            "reg == alu_",
            "reg );\n\n\talways @(*)\n\tif ((op_valid_mem)&&(op_pipe) && i_mem_valid)\n\t\t`ASSERT(op_Bid != i_mem_w",
            "reg );\n\n\talways @(*)\n\tif ((op_valid_mem)&&(op_pipe) && (i_mem_rdbusy || i_mem_valid))\n\t\t`ASSERT(op_Bid == f_addr_",
            "reg );\n\n\talways @(*)\n\tif (i_mem_rdbusy)\n\tbegin\n\t\tif (op_valid_mem && op_pipe)\n\t\tbegin\n\t\t\t`ASSERT(op_Bid == f_addr_",
            "reg );\n\t\t\t`ASSERT(op_Bid != f_last_",
            "reg );\n\t\t\tif (dcd_M && dcd_pipe && !dcd_illegal\n\t\t\t\t\t\t\t&& !dcd_early_branch)\n\t\t\t\t`ASSERT(op_Bid == dcd_B[4:0]);\n\t\tend else if (!op_valid_mem && dcd_M && dcd_pipe\n\t\t\t\t\t&& !dcd_illegal && !dcd_early_branch)\n\t\t\t`ASSERT(dcd_B[4:0] == f_addr_",
            "reg );\n\tend\n\t// }}}\n\n\talways @(*)\n\tif (op_valid && !f_op_zI && i_mem_rdbusy && (f_last_",
            "reg != { gie, CPU_PC_REG }))\n\t\t`ASSERT(!op_rB || fc_op_Bid[4:0] == f_addr_",
            "reg ||((f_mem_outstanding == 1) && (fc_op_Bid[4:0] != f_last_",
            "reg )));\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about the ALU stage\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif ((alu_ce)&&(!clear_pipeline))\n\t\t`ASSERT((op_valid_alu)&&(op_gie == gie));\n\talways @(*)\n\tif ((mem_ce)&&(!clear_pipeline))\n\t\t`ASSERT((op_valid_mem)&&(op_gie == gie));\n\talways @(*)\n\tif ((div_ce)&&(!clear_pipeline))\n\t\t`ASSERT((op_valid_div)&&(op_gie == gie));\n\n\talways @(*)\n\tif ((!clear_pipeline)&&((i_mem_valid)||(div_valid)||(div_busy)\n\t\t\t\t\t||(i_mem_rdbusy)||(alu_valid)))\n\t\t`ASSERT(alu_gie == gie);\n\talways @(*)\n\tif ((!OPT_CIS)&&(alu_pc_valid))\n\t\t`ASSERT(alu_pc[1:0] == 2'b0);\n\talways @(*)\n\tif (!OPT_LOCK)\n\t\t`ASSERT((!o_bus_lock)&&(!prelock_stall));\n\talways @(*)\n\tif (!OPT_DIV)\n\t\t`ASSERT((!dcd_DIV)&&(!op_valid_div)&&(!div_busy)&&(!div_valid)&&(!div_ce));\n\talways @(*)\n\tif (OPT_MPY == 0)\n\t\t`ASSERT(alu_busy == 1'b0);\n\n\n\talways @(*)\n\tif (!clear_pipeline)\n\tbegin\n\t\tif ((alu_valid)||(alu_illegal))\n\t\t\t`ASSERT(alu_gie == gie);\n\t\tif (div_valid)\n\t\t\t`ASSERT(alu_gie == gie);\n\tend\n\n\talways @(*)\n\tif (alu_busy)\n\tbegin\n\t\t`ASSERT(!i_mem_rdbusy);\n\t\t`ASSERT(!div_busy);\n\t\t`ASSERT(!fpu_busy);\n\tend else if (i_mem_rdbusy)\n\tbegin\n\t\t`ASSERT(!div_busy);\n\t\t`ASSERT(!fpu_busy);\n\tend else if (div_busy)\n\t\t`ASSERT(!fpu_busy);\n\n\talways @(posedge i_clk)\n\tif ((div_valid)||(div_busy))\n\t\t`ASSERT(alu_",
            "reg [3:1] != 3'h7);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(wr_",
            "reg _ce)\n\t\t\t&&((!$past(r_halted))||(!$past(i_dbg_we))))\n\t\t`ASSERT(alu_gie == gie);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract checking : A operand\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tbegin\n\t\tf_Av =",
            "reg set[fc_op_Aid[4:0]];\n\t\tif (fc_op_Aid[3:0] == CPU_PC_REG)\n\t\tbegin\n\t\t\tif ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Aid[4:0]))\n\t\t\t\tf_Av = wr_sp",
            "reg _vl;\n\t\t\telse if (fc_op_Aid[4] == op_gie)\n\t\t\t\tf_Av = op_pc; // f_next_addr;\n\t\t\telse if (fc_op_Aid[3:0] == { 1'b1, CPU_PC_REG })\n\t\t\tbegin\n\t\t\t\tf_Av[31:(AW+1)] = 0;\n\t\t\t\tf_Av[(AW+1):0] = { upc, uhalt_phase, 1'b0 };\n\t\t\tend\n\t\tend else if (fc_op_Aid[4:0] == { 1'b0, CPU_CC_REG })\n\t\tbegin\n\t\t\tf_Av = { w_cpu_info,",
            "reg set[fc_op_Aid[4:0]][22:16], w_iflags };\n\t\t\tif ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Aid[4:0]))\n\t\t\t\tf_Av[22:16] = wr_sp",
            "reg _vl[22:16];\n\t\tend else if (fc_op_Aid[4:0] == { 1'b1, CPU_CC_REG })\n\t\tbegin\n\t\t\tf_Av = { w_cpu_info,",
            "reg set[fc_op_Aid[4:0]][22:16], w_uflags };\n\t\t\tif ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Aid[4:0]))\n\t\t\t\tf_Av[22:16] = wr_sp",
            "reg _vl[22:16];\n\t\tend else if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Aid[4:0]))\n\t\t\tf_Av = wr_gp",
            "reg _vl;\n\t\telse\n\t\t\tf_Av =",
            "reg set[fc_op_Aid[4:0]];\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract checking : B operand\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// The PRE-",
            "logic always @(*)\n\tbegin\n\t\tf_pre_Bv =",
            "reg set[fc_op_Bid[4:0]];\n\t\t//\n\t\tif (fc_op_Bid[3:0] == CPU_PC_REG)\n\t\tbegin\n\t\t\t// Can always read your own address\n\t\t\tif (fc_op_Bid[4] == op_gie)\n\t\t\t\tf_pre_Bv = { {(30-AW){1'b0}}, op_pc[(AW+1):2], 2'b00 }; // f_next_addr;\n\t\t\telse // if (fc_op_Bid[4])\n\t\t\t\t// Supervisor or user may read the users PC",
            "reg begin\n\t\t\t\tf_pre_Bv = 0;\n\t\t\t\tf_pre_Bv[(AW+1):0] = { upc[(AW+1):2], uhalt_phase, 1'b0 };\n\t\t\t\tif ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Bid[4:0]))\n\t\t\t\t\tf_pre_Bv = wr_sp",
            "reg _vl;\n\t\t\tend\n\t\tend else if (fc_op_Bid[3:0] == CPU_CC_REG)\n\t\tbegin\n\t\t\tf_pre_Bv = { w_cpu_info,",
            "reg set[fc_op_Bid[4:0]][22:16],\n\t\t\t\t\tw_uflags };\n\t\t\t// if ((fc_op_Bid[4] == op_gie)&&(!fc_op_Bid[4]))\n\t\t\tf_pre_Bv[15:0] = (gie || fc_op_Bid[4]) ? w_uflags : w_iflags;\n\n\t\t\tif ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Bid[4:0]))\n\t\t\t\tf_pre_Bv[22:16] = wr_sp",
            "reg _vl[22:16];\n\n\t\tend else if ((wr_",
            "reg _ce)&&(wr_",
            "reg _id == fc_op_Bid[4:0]))\n\t\t\tf_pre_Bv = wr_gp",
            "reg _vl;\n\t\telse\n\t\t\tf_pre_Bv =",
            "reg set[fc_op_Bid[4:0]];\n\tend\n\n\n\t// The actual calculation of B\n\tassign\tf_Bv = (fc_op_rB)\n\t\t\t? ((fc_op_Bid[5])\n\t\t\t\t? ( { f_pre_Bv }+{ fc_op_I[29:0],2'b00 })\n\t\t\t\t: (f_pre_Bv + fc_op_I))\n\t\t\t: fc_op_I;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// CONTRACT: The operands to an ALU/MEM/DIV operation must be valid.\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(posedge i_clk)\n\tif (!i_reset && op_valid && !op_illegal\n\t\t&& (!clear_pipeline && !dbg_clear_pipe)\n\t\t&& (!i_halt || !dbgv)\n\t\t&&((!wr_",
            "reg _ce)||(wr_",
            "reg _id!= { gie, CPU_PC_REG }))\n\t\t&&(!f_op_branch))\n\tbegin\n\t\tif ((fc_op_rA)&&(fc_op_Aid[3:1] != 3'h7))\n\t\t\t`ASSERT(f_Av == op_Av);\n\n\t\tif (!fc_op_rB || fc_op_Bid[4:0] != { gie, CPU_CC_REG }\n\t\t\t\t|| !OPT_PIPELINED)\n\t\tbegin\n\t\t\t`ASSERT(f_Bv == op_Bv);\n\t\tend else if (f_op_zI)\n\t\t\t`ASSERT(((f_Bv ^ op_Bv) & 32'hffff_c0ff) == 0);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about the ALU stage\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// alu_valid\n\t// alu_ce\n\t// alu_stall\n\t// ALU stage assertions\n\n\talways @(posedge i_clk)\n\tif ((alu_ce)||(mem_ce)||(div_ce)||(fpu_ce))\n\tbegin\n\t\tf_alu_insn_word <= f_op_insn_word;\n\t\tf_alu_phase  <= f_op_phase;\n\tend\n\n\tinitial\tf_alu_branch = 1'b0;\n\talways @(posedge i_clk)\n\tif ((adf_ce_unconditional)||(mem_ce))\n\t\tf_alu_branch <= f_op_branch;\n\telse\n\t\tf_alu_branch <= 1'b0;\n\n\tf_idecode #(\n\t\t// {{{\n\t\t.OPT_MPY((OPT_MPY!=0)? 1'b1:1'b0),\n\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t.OPT_DIVIDE(OPT_DIV),\n\t\t.OPT_FPU(IMPLEMENT_FPU),\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_OPIPE(OPT_PIPELINED_BUS_ACCESS),\n\t\t.OPT_SIM(1'b0),\n\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.OPT_CIS(OPT_CIS)\n\t\t// }}}\n\t) f_insn_decode_alu(\n\t\t// {{{\n\t\tf_alu_insn_word, f_alu_phase, alu_gie,\n\t\t\tfc_alu_illegal, fc_alu_Rid, fc_alu_Aid, fc_alu_Bid,\n\t\t\tfc_alu_I, fc_alu_cond, fc_alu_wF, fc_alu_op, fc_alu_ALU,\n\t\t\tfc_alu_M, fc_alu_DV, fc_alu_FP, fc_alu_break,\n\t\t\tfc_alu_lock, fc_alu_wR, fc_alu_rA, fc_alu_rB,\n\t\t\tfc_alu_prepipe, fc_alu_sim, fc_alu_sim_immv\n\t\t// }}}\n\t);\n\n\talways @(posedge i_clk)\n\tif (!wr_",
            "reg _ce)\n\tbegin\n\t\tif (f_alu_branch)\n\t\tbegin\n\t\t\t`ASSERT((!div_valid)&&(!div_busy));\n\t\t\t`ASSERT((!fpu_valid)&&(!fpu_busy));\n\t\t\t`ASSERT(!i_mem_rdbusy);\n\t\t\t`ASSERT(!alu_busy);\n\t\tend else begin\n\t\t\t`ASSERT(fc_alu_sim == alu_sim);\n\t\t\t`ASSERT(fc_alu_sim_immv == alu_sim_immv);\n\n\t\t\tif (!fc_alu_DV)\n\t\t\t\t`ASSERT((!div_valid)&&(!div_busy)&&(!div_error));\n\t\t\tif (!fc_alu_M)\n\t\t\t\t`ASSERT(!i_mem_rdbusy);\n\t\t\tif (!fc_alu_ALU)\n\t\t\t\t`ASSERT(!alu_busy);\n\t\t\tif (!fc_alu_FP)\n\t\t\t\t`ASSERT((!fpu_busy)&&(!fpu_error));\n\t\t\tif (alu_busy)\n\t\t\t\t`ASSERT((fc_alu_op[3:1] == 3'h5)\n\t\t\t\t\t||(fc_alu_op[3:0] == 4'hc));\n\t\t\tif ((alu_busy)||(div_busy)||(fpu_busy))\n\t\t\tbegin\n\t\t\t\t`ASSERT(!i_mem_rdbusy);\n\t\t\t\t`ASSERT((clear_pipeline)\n\t\t\t\t\t||(fc_alu_Rid[4:0] == alu_",
            "reg ));\n\t\t\t\tif (alu_busy)\n\t\t\t\t\t`ASSERT(fc_alu_wF == alu_wF);\n\t\t\t\tif ((fc_alu_Rid[3:1] == 3'h7)&&(alu_wR)\n\t\t\t\t\t&&(fc_alu_Rid[4:0] != { gie, 4'hf }))\n\t\t\t\t\t`ASSERT(pending_s",
            "reg _write);\n\t\t\tend else if (i_mem_rdbusy)\n\t\t\tbegin\n\t\t\t\tif ($past(i_mem_rdbusy))\n\t\t\t\t\t`ASSERT(fc_alu_Rid[4] == f_mem_gie);\n\t\t\tend\n\n\t\t\t//if ((div_busy)||(fpu_busy))\n\t\t\t//\t`ASSERT(alu_wR);\n\t\t\t//else\n\t\t\tif ((alu_busy)&&(alu_wR))\n\t\t\t\t`ASSERT(fc_alu_wR);\n\n\t\t\tif (alu_busy || i_mem_rdbusy || div_busy)\n\t\t\tbegin\n\t\t\t\tif ((fc_alu_wR)&&(fc_alu_Rid[4:0] == { gie, CPU_PC_REG}))\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!alu_phase);\n\t\t\t\tend else\n\t\t\t\t\t`ASSERT(f_alu_phase == alu_phase);\n\t\t\tend\n\t\tend\n\n\tend else if (!dbgv) // && wr_",
            "reg _ce\n\tbegin\n\t\t`ASSERT(fc_alu_DV || (!div_valid)&&(!div_error));\n\t\t`ASSERT(fc_alu_ALU|| !alu_valid);\n\t\t`ASSERT(fc_alu_M  || !i_mem_valid);\n\t\t`ASSERT(fc_alu_FP || (!fpu_valid)&&(!fpu_error));\n\t\t`ASSERT((!alu_busy)&&(!div_busy)&&(!fpu_busy));\n\n\t\tif ((!alu_illegal)&&(fc_alu_cond[3])&&(fc_alu_wR)&&(fc_alu_ALU))\n\t\t\t`ASSERT(alu_wR);\n\t\tif (!i_mem_valid)\n\t\t\t`ASSERT(fc_alu_Rid[4:0] == alu_",
            "reg );\n\t\tif (f_exwrite_cycle)\n\t\tbegin\n\t\t\t`ASSERT(!alu_wR);\n\t\tend else\n\t\t\t`ASSERT((!alu_wR)||(fc_alu_wR  == alu_wR));\n\t\tif (alu_valid)\n\t\t\t`ASSERT(fc_alu_wF == alu_wF);\n\t\tif (!fc_alu_wF)\n\t\t\t`ASSERT(!wr_flags_ce);\n\n\t\t`ASSERT(!f_alu_branch);\n\tend\n\n\talways @(posedge i_clk)\n\tif (f_mem_pc && i_mem_rdbusy)\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(!OPT_PIPELINED || cc_invalid_for_dcd || !fc_alu_wR\n\t\t\t|| fc_alu_Rid[4:0] != { gie, CPU_CC_REG });\n\t\t`ASSERT(!mem_ce);\n\n\t\tif (OPT_PIPELINED && fc_alu_Rid[4:0] != { gie, CPU_PC_REG }\n\t\t\t\t&& (!OPT_LOCK || fc_alu_wR))\n\t\t\t`ASSERT(pending_s",
            "reg _write);\n\t\tif ((!OPT_DCACHE)||(!OPT_MEMPIPE))\n\t\tbegin\n\t\t\t`ASSERT(!fc_alu_prepipe);\n\t\tend else if ((i_mem_rdbusy && !f_exwrite_cycle)\n\t\t\t\t&&(!$past(mem_ce))&&(!$past(mem_ce,2)))\n\t\t\t`ASSERT(!fc_alu_prepipe);\n\t\t// }}}\n\tend else if (i_mem_rdbusy)\n\tbegin\n\t\t`ASSERT(!pending_s",
            "reg _write);\n\t\t// assert(!cc_invalid_for_dcd);\n\tend\n\n\t// Ongoing memory operation check\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_mem_rdbusy)\n\tbegin\n\t\t// In pipelined mode, this is an ongoing load operation\n\t\t// Otherwise, mem_rdbusy == i_mem_busy and we have no idea\n\t\t// what type of operation we are in\n\t\t`ASSERT(!fc_alu_illegal);\n\t\t`ASSERT(fc_alu_M);\n\t\t`ASSERT(gie == alu_",
            "reg [4]);\n\t\tif (fc_alu_rB)\n\t\t\t`ASSERT(fc_alu_Bid[4:0] == f_addr_",
            "reg );\n\n\t\tif (!f_exwrite_cycle)\n\t\tbegin\n\t\t\t`ASSERT(alu_",
            "reg == f_last_",
            "reg );\n\t\t\tif (alu_",
            "reg == f_addr_",
            "reg )\n\t\t\t\t`ASSERT(!op_pipe);\n\t\tend\n\t\tif (fc_alu_cond[3])\n\t\t\t`ASSERT(fc_alu_Rid[4:0] == alu_",
            "reg );\n\n\t\tif ((fc_alu_wR)&&(fc_alu_Rid[4:0] == { gie, CPU_PC_REG}))\n\t\tbegin\n\t\t\t`ASSERT(!alu_phase);\n\t\tend else\n\t\t\t`ASSERT(f_alu_phase == alu_phase);\n\n\t\tif (f_exwrite_cycle)\n\t\tbegin\n\t\t\t`ASSERT(!fc_alu_wR);\n\t\tend else\n\t\t\t`ASSERT(fc_alu_wR);\n\tend else if ((i_mem_busy)&&(fc_alu_M)\n\t\t&&(f_mem_outstanding > ((i_mem_valid || i_bus_err) ? 1:0))\n\t\t&&(!i_bus_err))\n\tbegin // Ongoing store operation\n\t\t// {{{\n\t\t`ASSERT(!fc_alu_illegal);\n\t\t`ASSERT(fc_alu_M);\n\t\t`ASSERT(!fc_alu_wR);\n\t\t// }}}\n\tend\n\t// }}}\n\n\talways @(*)\n\tif (!fc_alu_wR && i_mem_rdbusy)\n\tbegin\n\t\t`ASSERT(OPT_LOCK);\n\t\t`ASSERT(f_mem_outstanding == 1);\n\t\t`ASSERT(f_mem_pc);\n\t\t`ASSERT(!f_read_cycle);\n\t\t`ASSERT(!cc_invalid_for_dcd);\n\t\t`ASSERT(f_exwrite_cycle);\n\t\t// `ASSERT(i_mem_w",
            "reg [3:0] == 4'hf);\n\t\t`ASSERT(fc_alu_M);\n\t\t`ASSERT(!pending_s",
            "reg _write);\n\t\t`ASSERT(!alu_wR);\n\tend else if (i_mem_rdbusy)\n\tbegin\n\t\t`ASSERT(fc_alu_wR);\n\t\t`ASSERT(!f_exwrite_cycle);\n\t\t`ASSERT(f_read_cycle);\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about the writeback stage\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_reset))&&($past(gie) != gie))\n\t\t`ASSERT(clear_pipeline);\n\n\talways @(*)\n\tif (!IMPLEMENT_FPU)\n\tbegin\n\t\t`ASSERT(!ifpu_err_flag);\n\t\t`ASSERT(!ufpu_err_flag);\n\tend\n\n\talways @(posedge i_clk)\n\tif (dbgv)\n\tbegin\n\t\t`ASSERT(wr_index == 3'h0);\n\t\t`ASSERT(wr_gp",
            "reg _vl == $past(i_dbg_data));\n\t\t`ASSERT(wr_sp",
            "reg _vl == $past(i_dbg_data));\n\tend\n\n\talways @(*)\n\tif (i_mem_rdbusy || i_mem_valid)\n\tbegin\n\t\t`ASSERT(wr_index == 3'h1);\n\t\tif (i_mem_valid)\n\t\t\t`ASSERT(wr_gp",
            "reg _vl == i_mem_result);\n\tend\n\n\talways @(*)\n\tif (alu_busy || alu_valid)\n\tbegin\n\t\t`ASSERT(wr_index == 3'h2);\n\t\tif (alu_valid)\n\t\tbegin\n\t\t\t`ASSERT(wr_gp",
            "reg _vl == alu_result);\n\t\t\t`ASSERT(wr_sp",
            "reg _vl == alu_result);\n\t\tend\n\tend\n\n\talways @(*)\n\tif (div_busy || div_valid || div_error)\n\tbegin\n\t\t`ASSERT(wr_index == 3'h3);\n\t\tif (div_valid)\n\t\t\t`ASSERT(wr_gp",
            "reg _vl == div_result);\n\tend\n\n\talways @(*)\n\tif (fpu_busy || fpu_valid || fpu_error)\n\tbegin\n\t\t`ASSERT(wr_index == 3'h4);\n\t\tif (fpu_valid)\n\t\t\t`ASSERT(wr_gp",
            "reg _vl == fpu_result);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(r_halted))\n\tbegin\n\t\t`ASSERT(!div_busy);\n\t\t`ASSERT(!i_mem_rdbusy);\n\t\t`ASSERT(!alu_busy);\n\t\t`ASSERT(!div_valid);\n\t\t`ASSERT(!i_mem_valid);\n\t\t`ASSERT(!alu_valid);\n\tend\n\n\talways @(*)\n\tif (((wr_",
            "reg _ce)||(wr_flags_ce))&&(!dbgv))\n\t\t`ASSERT(!alu_illegal);\n\n\talways @(*)\n\tif (!fc_alu_wR && (!OPT_LOCK || !f_mem_pc))\n\t\t`ASSERT(!i_mem_rdbusy);\n\n\talways @(*)\n\tif (alu_illegal)\n\t\t`ASSERT(!i_mem_rdbusy);\n\n\talways @(posedge i_clk)\n\tif (wr_",
            "reg _ce && !$past(i_dbg_we))\n\tbegin\n\t\tif (!fc_alu_wR)\n\t\t\t`ASSERT(OPT_LOCK && f_exwrite_cycle);\n\n\t\t// Since writes are asynchronous, they can create errors later\n\t\t`ASSERT((!i_bus_err)||(!i_mem_valid));\n\t\t`ASSERT(!fpu_error);\n\t\t`ASSERT(!div_error);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Clock enable checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif (!OPT_CLKGATE)\n\tbegin\n\t\tassert(w_clken);\n\t\tassert(o_clken);\n\tend else if (!f_past_valid)\n\tbegin end // clken can be anything on the first clock\n\telse if ($past(i_reset))\n\tbegin\n\t\tassert(w_clken != OPT_START_HALTED);\n\tend else if ($past((!i_halt || !r_halted) && (!sleep || i_interrupt)))\n\tbegin\n\t\tassert(w_clken);\n\tend else if ($past((i_mem_busy && f_mem_outstanding > 0) || o_mem_ce))\n\tbegin\n\t\tassert(w_clken);\n\tend else if (i_mem_busy || div_busy || alu_busy || fpu_busy)\n\tbegin\n\t\tassert(o_clken);\n\tend else if ($past((i_interrupt || pending_interrupt) && !i_halt))\n\tbegin\n\t\tassert(o_clken);\n\tend else if (!sleep && !r_halted)\n\tbegin\n\t\tassert(o_clken);\n\tend\n\n\t// always @(posedge i_clk)\n\t// if (f_past_valid && i_mem_busy)\n\t//\tassert(!r_halted);\n\n\talways @(posedge i_clk)\n\tif (!OPT_CLKGATE)\n\tbegin\n\t\tassert(o_clken);\n\tend else if (!f_past_valid)\n\tbegin\n\tend else if (i_dbg_we || i_clear_cache || f_mem_outstanding > 0)\n\tbegin\n\t\tassert(o_clken);\n\tend else if (!i_halt && (i_interrupt || !sleep))\n\t\tassert(o_clken);\n\n\n\talways @(posedge i_clk)\n\tif (!i_reset && sleep)\n\tbegin\n\t\tassert(!wr_",
            "reg _ce || dbgv);\n\t\tassert(!i_mem_rdbusy);\n\tend\n\n\talways @(posedge i_clk)\n\tif (!i_reset && r_halted)\n\t\tassert(!i_mem_rdbusy);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Low power checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// In low power mode, *nothing* should change unless we are doing\n\t// something.\n\n\tgenerate if (OPT_LOWPOWER && OPT_PIPELINED)\n\tbegin : F_OPT_LOWPOWER_CHECK",
            "wire [70:0]\top_state;\n\n\t\t//\n\t\t// OP*",
            "reg isters can only be expected to hold steady if\n\t\t// pipelined.  If not pipelined, many of these",
            "reg isters\n\t\t// become aliases for the decode",
            "reg isters which will\n\t\t// (of course) change from one clock to the next.\n\t\t//\n\t\tassign\top_state = { op_valid_mem, op_valid_div, op_valid_alu,\n\t\t\t\top_valid_fpu,\n\t\t\t\top_opn, op_R, op_Rcc, op_Aid,\n\t\t\t\top_Bid, op_pc,\n\t\t\t\tr_op_break, op_illegal };\n\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && !$past(i_reset) && !$past(clear_pipeline)\n\t\t\t&& ($past(op_valid && !adf_ce_unconditional && !mem_ce)\n\t\t\t\t||($past(!op_valid && !dcd_ljmp) && !op_valid)))\n\t\tbegin\n\t\t\tassert($stable(op_state));\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && !op_valid)\n\t\tbegin\n\t\t\tassert(r_op_F == 7'h00);\n\t\t\tassert(!op_wR);\n\t\t\tassert(!op_wF);\n\t\t\tassert(!op_rA);\n\t\t\tassert(!op_rB);\n\n\t\t\tassert(r_op_Av == 0);\n\t\t\tassert(r_op_Bv == 0);\n\t\tend\n\n\tend endgenerate\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Step properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && !i_reset && $past(!gie))\n\t\tassert(!stepped);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && step && stepped)\n\tbegin\n\t\tassert(!break_pending);\n\t\tassert(!o_bus_lock);\n\tend\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && !i_reset && !o_bus_lock && !$past(o_bus_lock)\n\t\t\t&& !$past(o_dbg_stall) && !o_dbg_stall)\n\tbegin\n\t\tif (step && !stepped)\n\t\tbegin\n\t\t\t`ASSERT(!i_mem_rdbusy);\n\t\t\t`ASSERT(!div_busy);\n\t\t\t`ASSERT(!alu_busy);\n\t\t\t`ASSERT(!fpu_busy);\n\t\tend\n\n\t\tif (wr_",
            "reg _ce || wr_flags_ce)\n\t\t\t`ASSERT(!step || stepped);\n\tend\n\n\talways @(posedge i_clk)\n\tif (!i_reset &&(i_mem_rdbusy|| div_busy|| alu_busy || fpu_busy))\n\t\tassert(!r_halted);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && !$past(i_reset) && i_mem_busy)\n\t\tassert(!$rose(r_halted));\n\n\talways @(posedge i_clk)\n\tif (step && stepped)\n\tbegin\n\t\tassert(!adf_ce_unconditional);\n\t\tassert(!div_ce);\n\t\tassert(!mem_ce);\n\t\tassert(!fpu_ce);\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Ad-hoc (unsorted) properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_mem_rdbusy))\n\t\t\t&&(!$past(i_mem_valid)\n\t\t\t\t\t||($past(i_mem_w",
            "reg [3:1] != 3'h7))))\n\t\t`ASSERT(!i_mem_valid || i_mem_w",
            "reg [4] == alu_gie);\n\n\talways @(posedge i_clk)\n\tif (i_mem_valid)\n\t\t`ASSERT(i_mem_w",
            "reg [4] == alu_gie);\n\n\talways @(posedge i_clk)\n\tif (i_mem_rdbusy)\n\t\t`ASSERT(alu_gie == f_mem_gie);\n\n\talways @(posedge i_clk)\n\tif (f_mem_outstanding > 0)\n\t\t`ASSERT(alu_gie == f_mem_gie);\n\n\n\n\t// Break instructions are not allowed to move past the op stage\n\talways @(*)\n\tif ((break_pending)||(op_break))\n\t\t`ASSERT((!alu_ce)&&(!mem_ce)&&(!div_ce)&&(!fpu_ce));\n\n\talways @(*)\n\tif (op_break)\n\t\t`ASSERT((!alu_ce)&&(!mem_ce)&&(!div_ce)&&(!fpu_ce));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t\t&&($past(break_pending))&&(!break_pending))\n\t\t`ASSERT((clear_pipeline)||($past(clear_pipeline)));\n\n\talways @(*)\n\tif ((o_break)||((alu_valid)&&(alu_illegal)))\n\tbegin\n\t\t`ASSERT(!alu_ce);\n\t\t`ASSERT(!mem_ce);\n\t\t`ASSERT(!div_ce);\n\t\t`ASSERT(!fpu_ce);\n\t\t`ASSERT(!i_mem_rdbusy);\n\t\t// The following two shouldn't be true, but will be true\n\t\t// following a bus error\n\t\tif (!i_bus_err)\n\t\tbegin\n\t\t\t`ASSERT(!alu_busy);\n\t\t\t`ASSERT(!div_busy);\n\t\t\t`ASSERT(!fpu_busy);\n\t\tend\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&(!$past(clear_pipeline))&&\n\t\t\t($past(div_busy))&&(!clear_pipeline))\n\tbegin\n\t\t`ASSERT($stable(alu_",
            "reg ));\n\t\t`ASSERT(alu_",
            "reg [4] == alu_gie);\n\t\t`ASSERT($stable(alu_pc));\n\t\t`ASSERT($stable(alu_phase));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&(!i_reset)\n\t\t\t&&(!$past(clear_pipeline))&&(!clear_pipeline)\n\t\t\t&&(($past(div_busy))||($past(i_mem_rdbusy))))\n\t\t`ASSERT($stable(alu_gie));\n\n\talways @(posedge i_clk)\n\tif (i_mem_rdbusy && f_mem_outstanding > 0)\n\t\t`ASSERT(!new_pc);\n\n\talways @(posedge i_clk)\n\tif ((wr_",
            "reg _ce)&&((wr_write_cc)||(wr_write_pc)))\n\t\t`ASSERT(wr_sp",
            "reg _vl == wr_gp",
            "reg _vl);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(clear_pipeline))&&(!$past(i_reset))\n\t\t&&($past(op_valid))&&($past(op_illegal))&&(!op_illegal))\n\t\t`ASSERT(alu_illegal);\n\n\talways @(*)\n\tif ((OPT_PIPELINED)&&(alu_valid)&&(alu_wR)&&(!clear_pipeline)\n\t\t\t&&(alu_",
            "reg [3:1] == 3'h7)\n\t\t\t&&(alu_",
            "reg [4:0] != { gie, CPU_PC_REG }))\n\t\t`ASSERT(pending_s",
            "reg _write);\n\n\talways @(posedge i_clk)\n\tif ((OPT_PIPELINED)&&(i_mem_valid || i_mem_rdbusy)\n\t\t\t&&(f_last_",
            "reg [3:1] == 3'h7)\n\t\t\t&&(!f_exwrite_cycle\n\t\t\t\t&& f_last_",
            "reg [4:0] != { gie, CPU_PC_REG }))\n\tbegin\n\t\t`ASSERT(pending_s",
            "reg _write);\n\tend else if ((OPT_PIPELINED)&&(OPT_DCACHE)\n\t\t\t&& i_mem_valid\n\t\t\t&&($past(i_mem_rdbusy))\n\t\t\t&&($past(i_mem_rdbusy,2)))\n\t\t`ASSERT((i_mem_w",
            "reg [3:1] != 3'h7)\n\t\t\t||f_exwrite_cycle\n\t\t\t||(i_mem_w",
            "reg == { gie, CPU_PC_REG})\n\t\t\t\t||(pending_s",
            "reg _write));\n\n\talways @(*)\n\tif ((op_valid_alu)||(op_valid_div)||(op_valid_mem)||(op_valid_fpu))\n\t\t`ASSERT(op_valid);\n\n\talways @(*)\n\tif (!OPT_PIPELINED)\n\tbegin\n\t\tif (op_valid)\n\t\tbegin\n\t\t\t`ASSERT(!dcd_valid);\n\t\t\t`ASSERT(!i_mem_busy || f_mem_outstanding == 0);\n\t\t\t`ASSERT(!alu_busy);\n\t\t\t`ASSERT(!div_busy);\n\t\t\t`ASSERT((!wr_",
            "reg _ce)||(dbgv));\n\t\t\t`ASSERT(!wr_flags_ce);\n\t\tend\n\tend\n\n\talways @(posedge i_clk)\n\tif ((!OPT_PIPELINED)&&(f_past_valid))\n\tbegin\n\t\tif (op_valid)\n\t\t\t`ASSERT($stable(f_dcd_insn_word));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((alu_ce)||(div_ce)||(fpu_ce))\n\t\t`ASSERT(adf_ce_unconditional);\n\n\talways @(posedge i_clk)\n\tif ((!clear_pipeline)&&(master_ce)&&(op_ce)&&(op_valid))\n\tbegin\n\t\tif (op_valid_mem)\n\t\tbegin\n\t\t\t`ASSERT((mem_ce)||(!set_cond));\n\t\tend else begin\n\t\t\t`ASSERT(!master_stall);\n\t\t\tif ((set_cond)&&(op_valid_div))\n\t\t\t\t`ASSERT(div_ce||pending_s",
            "reg _write);\n\t\t\tif (!op_valid_alu)\n\t\t\t\t`ASSERT(!alu_ce);\n\t\tend\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Debug port read properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\n\tgenerate if (OPT_DBGPORT)\n\tbegin : CHK_DBGPORT_READS",
            "reg [31:0]\tf_dbg_check;\n\n\t\t// o_dbg_",
            "reg -- Reading from the debugging interface\n\t\tif (OPT_DISTRIBUTED_REGS)\n\t\tbegin : F_CHK_DISTRIBUTED_RAM\n\t\t\t// {{{\n\t\t\talways @(posedge i_clk)\n\t\t\tif ((f_past_valid)&&($past(i_halt))&&(!$past(i_dbg_we)))\n\t\t\tbegin\n\t\t\t\tif ($past(i_dbg_r",
            "reg [3:1]) != 3'h7)\n\t\t\t\t\t`ASSERT(o_dbg_",
            "reg == $past(",
            "reg set[i_dbg_r",
            "reg ]));\n\t\t\t\tif ($past(i_dbg_r",
            "reg [4:0]) == 5'h0f)\n\t\t\t\t\t`ASSERT(o_dbg_",
            "reg [AW+1:0] == $past({ ipc[(AW+1):2], ihalt_phase, 1'b0}));\n\t\t\t\tif ($past(i_dbg_r",
            "reg [4:0]) == 5'h1f)\n\t\t\t\t\t`ASSERT(o_dbg_",
            "reg [AW+1:0] == $past({ upc[(AW+1):2], uhalt_phase, 1'b0}));\n\t\t\t\tif ($past(i_dbg_r",
            "reg [4:0]) == 5'h0e)\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(o_dbg_",
            "reg [15:6] == $past(w_iflags[15:6]));\n\t\t\t\t\t`ASSERT(o_dbg_",
            "reg [ 4:0] == $past(w_iflags[ 4:0]));\n\t\t\t\tend\n\n\t\t\t\tif ($past(i_dbg_r",
            "reg [4:0]) == 5'h1e)\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(o_dbg_",
            "reg [15:6] == $past(w_uflags[15:6]));\n\t\t\t\t\t`ASSERT(o_dbg_",
            "reg [ 4:0] == $past(w_uflags[ 4:0]));\n\t\t\t\tend\n\n\t\t\t\tif ($past(i_dbg_r",
            "reg [3:0]) == 4'he)\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(o_dbg_",
            "reg [15] == 1'b0);\n\t\t\t\t\t`ASSERT(o_dbg_",
            "reg [31:23] == w_cpu_info);\n\t\t\t\t\t`ASSERT(o_dbg_",
            "reg [CPU_GIE_BIT] == $past(i_dbg_r",
            "reg [4]));\n\t\t\t\tend\n\t\t\tend\n\t\t\t// }}}\n\t\tend else begin : F_CHK_NO_DISTRIBUTED_RAM\n\t\t\t// {{{\n\t\t\talways @(posedge i_clk)\n\t\t\tif (f_past_valid&&$past(f_past_valid)\n\t\t\t\t\t&& $past(i_halt)&&$past(i_halt,2)\n\t\t\t\t\t&&(!$past(i_dbg_we)))\n\t\t\tbegin\n\t\t\t\tif ($past(i_dbg_r",
            "reg [3:1],2) != 3'h7)\n\t\t\t\t\t`ASSERT(o_dbg_",
            "reg == $past(",
            "reg set[i_dbg_r",
            "reg ],2));\n\t\t\tend\n\t\t\t// }}}\n\t\tend\n\n\n\t\tif (OPT_USERMODE)\n\t\tbegin : CHK_USER\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\tf_dbg_check =",
            "reg set[i_dbg_r",
            "reg ];\n\t\t\t\tcase(i_dbg_r",
            "reg )\n\t\t\t\t5'h0e: begin\n\t\t\t\t\tf_dbg_check[15:0] = w_iflags;\n\t\t\t\t\tf_dbg_check[31:23] = w_cpu_info;\n\t\t\t\t\tf_dbg_check[CPU_GIE_BIT] <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\t5'h0f: f_dbg_check[(AW+1):0]\n\t\t\t\t\t\t= { ipc[(AW+1):2], ihalt_phase, 1'b0 };\n\t\t\t\t5'h1e: begin\n\t\t\t\t\tf_dbg_check[15:0] = w_uflags;\n\t\t\t\t\tf_dbg_check[31:23] = w_cpu_info;\n\t\t\t\t\tf_dbg_check[CPU_GIE_BIT] <= 1'b1;\n\t\t\t\t\tend\n\t\t\t\t5'h1f: f_dbg_check[(AW+1):0]\n\t\t\t\t\t\t= { upc[(AW+1):2], uhalt_phase, 1'b0 };\n\t\t\t\tdefault:\n\t\t\t\t\tf_dbg_check =",
            "reg set[i_dbg_r",
            "reg ];\n\t\t\t\tendcase\n\t\t\tend\n\t\tend else begin : NO_USER\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\tif (OPT_DISTRIBUTED_REGS)\n\t\t\t\t\tf_dbg_check =",
            "reg set[i_dbg_r",
            "reg ];\n\t\t\t\telse\n\t\t\t\t\tf_dbg_check = 0;\n\t\t\t\tcase(i_dbg_r",
            "reg [3:0])\n\t\t\t\t4'h0e: begin\n\t\t\t\t\tf_dbg_check[15:0] = w_iflags;\n\t\t\t\t\tf_dbg_check[31:23] = w_cpu_info;\n\t\t\t\t\tf_dbg_check[CPU_GIE_BIT] <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\t4'h0f: f_dbg_check[(AW+1):0]\n\t\t\t\t\t\t= { ipc[(AW+1):2], ihalt_phase, 1'b0 };\n\t\t\t\tdefault:\n\t\t\t\t\tf_dbg_check =",
            "reg set[i_dbg_r",
            "reg [3:0]];\n\t\t\t\tendcase\n\t\t\tend\n\t\tend\n\n\t\tif (OPT_DISTRIBUTED_REGS)\n\t\tbegin\n\t\t\talways @(posedge i_clk)\n\t\t\tif (!i_reset && !$past(i_reset))\n\t\t\t\tassert(o_dbg_",
            "reg == $past(f_dbg_check));\n\t\tend else begin\n\t\t\talways @(posedge i_clk)\n\t\t\tif (!i_reset && !$past(i_reset) && !$past(i_reset,2))\n\t\t\t\tassert(o_dbg_",
            "reg == $past(f_dbg_check,2));\n\t\tend\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover statements\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\talways @(posedge i_clk)\n\tbegin\n\t\tcover(!i_reset);\n\t\tcover(!i_halt);\n\t\tcover(!i_reset && !i_halt);\n\tend\n\n\talways @(posedge i_clk)\n\tif (!i_halt && !i_reset)\n\tbegin\n\t\tcover(i_pf_valid &&  i_pf_illegal);\n\t\tcover(i_pf_valid && !i_pf_illegal);\n\n\t\tcover(dcd_valid &&  dcd_illegal);\n\t\tcover(dcd_valid && !dcd_illegal);\n\n\t\tcover(op_valid && !op_illegal);\n\t\tcover(op_valid &&  op_illegal);\n\t\tcover(op_valid && !op_illegal && op_ce);\n\t\tcover(op_valid &&  op_illegal && op_ce);\n\n\t\tcover(alu_valid);\n\t\tcover(div_valid);\n\t\tcover(o_mem_ce);\n\t\tcover(i_mem_valid);\n\n\t\tcover(wr_",
            "reg _ce);\n\n\t\tcover(gie);\n\tend\n\n\talways @(posedge i_clk)\n\tif (!i_halt && !i_reset && !$past(i_reset))\n\tbegin\n\t\tcover(i_interrupt && !alu_phase && !o_bus_lock);\n\t\tcover(alu_illegal);\n\t\tcover( gie && w_switch_to_interrupt);\n\t\tcover(!gie && w_release_from_interrupt);\n\n\t\t// Cover an illegal instruction\n\t\tcover(alu_illegal);\n\t\tcover(alu_illegal && !clear_pipeline);\n\n\n\t\t// Cover a break instruction\n\t\tcover((master_ce)&&(break_pending)&&(!break_en));\n\t\tcover(o_break);\n//\t\tif (master_ce && (break_en || break_pending))\n//\t\t\t`ASSERT(!wr_",
            "reg _ce);\n\n\n\t\tcover(gie);\n\t\tcover(step);\n\t\tcover(step && w_switch_to_interrupt);\n\t\tcover(step && w_switch_to_interrupt && !i_interrupt);\n\tend\n\n\talways @(posedge i_clk)\n\tif (!i_halt && !i_reset && !$past(i_reset))\n\tbegin\n\t\tcover(step);\n\t\tcover(step && wr_",
            "reg _ce);\n\t\tcover($fell(step) && $stable(!i_reset && !i_halt));\n\t\tcover($past(step && !i_reset && !i_halt));\n\t\tcover($past(step && !i_reset && !i_halt,2));\n\t\tcover(!o_bus_lock && alu_ce && step);\n\t\tcover(user_step && !gie);\n\t\tcover(user_step &&  gie);\n\t\tcover(user_step &&  gie && wr_",
            "reg _ce);\n\n\t\t// Cover a division by zero\n\t\tcover(!OPT_DIV || div_busy);\n\t\tcover(!OPT_DIV || div_error);\n\t\tcover(!OPT_DIV || div_valid);\n\tend\n\n\tgenerate if (OPT_DIV)\n\tbegin : F_DIVIDE\n\t\talways @(posedge i_clk)\n\t\tif (!i_halt && !i_reset && !$past(i_reset))\n\t\tbegin\n\t\t\t// Cover a division by zero\n\t\t\tcover(div_busy);\n\t\t\tcover(div_error);\n\t\t\tcover(div_valid);\n\t\tend\n\tend endgenerate\n\n\tgenerate if (OPT_LOCK)\n\tbegin : F_CVR_LOCK\n\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && !i_reset\n\t\t\t\t&& !$past(i_reset || clear_pipeline))\n\t\tbegin\n\t\t\tcover($rose(o_bus_lock));\n\t\t\tcover($fell(o_bus_lock));\n\t\t\tcover($fell(o_bus_lock)\n\t\t\t\t&& !$past(i_bus_err || div_error || alu_illegal));\n\t\tend\n\n\tend else begin\n\n\t\talways @(*)\n\t\t\t`ASSERT(!o_bus_lock);\n\n\tend endgenerate\n\n\talways @(posedge i_clk)\n\tif (!i_halt && !i_reset && !$past(i_reset) && wr_",
            "reg _ce)\n\tbegin\n\t\t`ASSERT(!alu_illegal);\n\tend\n\n\talways @(posedge i_clk)\n\tif (!i_halt && !i_reset && wr_",
            "reg _ce)\n\tbegin\n\t\tcover(o_bus_lock);\n\n\t\t// Cover the switch to interrupt\n\t\tcover(i_interrupt);\n\t\tcover(i_interrupt && !alu_phase);\n\t\tcover(i_interrupt && !o_bus_lock);\n\t\tcover((i_interrupt)&&(!alu_phase)&&(!o_bus_lock));\n\n\t\t// Cover a \"step\" instruction\n\t\t//\n\t\tcover(((alu_pc_valid)||(mem_pc_valid))\n\t\t\t\t&&(step)&&(!alu_phase)&&(!o_bus_lock));\n\t\t// `ASSERT(!(((alu_pc_valid)||(mem_pc_valid))\n\t\t//\t\t&&(step)&&(!alu_phase)&&(!o_bus_lock)));\n\n\t\t// Cover a bus error\n\t\tcover(i_bus_err);\n\n\t\t// Cover a TRAP instruction to the CC",
            "reg ister\n\t\tcover(!alu_gie && !wr_sp",
            "reg _vl[CPU_GIE_BIT]\n\t\t\t\t&&(wr_",
            "reg _id[4])&&(wr_write_cc));\n\n\t\t// Cover an AXI lock return branch\n\t\tcover(i_mem_valid && f_exwrite_cycle && !f_read_cycle);\n\tend\n\n\t// Cover all the various reasons to switch to an interrupt\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((f_past_valid && !i_reset && !$past(i_reset) && !i_halt) && gie)\n\tbegin\n\t\tcover((pending_interrupt)\n\t\t\t\t&&(!alu_phase)&&(!o_bus_lock)&&(!i_mem_busy));\n\n\t\tcover(div_error);\n\t\t// cover(fpu_error);\n\t\tcover(i_bus_err);\n\t\tcover(wr_",
            "reg _ce && !wr_sp",
            "reg _vl[CPU_GIE_BIT]\n\t\t\t&& wr_",
            "reg _id[4] && wr_write_cc);\n\n\t\tif (!clear_pipeline && !w_switch_to_interrupt)\n\t\tbegin\n\t\t\tcover(pending_interrupt);\n\n\t\t\tcover(i_interrupt);\n\n\t\t\tcover(mem_ce && step);\n\t\t\tcover(break_pending && !adf_ce_unconditional);\n\t\t\tcover(adf_ce_unconditional && op_illegal);\n\t\t\tcover(adf_ce_unconditional && step);\n\t\tend\n\n\t\t`ASSERT(!adf_ce_unconditional || !break_pending);\n\tend\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Careless assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Once asserted, an interrupt will stay asserted while the CPU is\n\t// in user mode\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_interrupt && (gie || !i_mem_busy))))\n\t\tassume(i_interrupt);\n\t// }}}\n`endif\t// FORMAL\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "slowmpy.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/slowmpy.v",
        "chunks": [
            "logic and slow data signals.  It\n// \ttakes one clock per bit plus two more to complete the multiply.\n//\n//\tThe OPT_SIGNED version of this algorithm was found on Wikipedia at\n//\thttps://en.wikipedia.org/wiki/Binary_multiplier.\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2018-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module slowmpy #(\n\t\t// {{{",
            "parameter LGNA = 6,",
            "parameter [LGNA:0]\tNA = 33,",
            "parameter [0:0]\t\tOPT_SIGNED = 1'b1,",
            "parameter [0:0]\t\tOPT_LOWPOWER = 1'b0,",
            "localparam NB = NA // Must be = NA for OPT_SIGNED to work\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t//",
            "input ",
            "wire i_stb,",
            "input ",
            "wire signed\t[(NA-1):0]\ti_a,",
            "input ",
            "wire signed\t[(NB-1):0]\ti_b,\n\t\t// verilator coverage_off",
            "input ",
            "wire i_aux,\n\t\t// verilator coverage_on",
            "output ",
            "reg o_busy, o_done,",
            "output ",
            "reg signed\t[(NA+NB-1):0]\to_p,\n\t\t// verilator coverage_off",
            "output ",
            "reg o_aux\n\t\t// verilator coverage_on\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "reg [LGNA-1:0]\tcount;",
            "reg [NA-1:0]\tp_a;",
            "reg [NB-1:0]\tp_b;",
            "reg [NA+NB-1:0]\tpartial;\n\t// verilator coverage_off",
            "reg aux;\n\t// verilator coverage_on",
            "reg almost_done;",
            "wire pre_done;",
            "wire [NA-1:0]\tp",
            "wire ;\n\t// }}}\n\n\tassign\tpre_done = (count == 0);\n\n\t// almost_done\n\t// {{{\n\tinitial\talmost_done = 1'b0;\n\talways @(posedge i_clk)\n\t\talmost_done <= (!i_reset)&&(o_busy)&&(pre_done);\n\t// }}}\n\n\t// aux, o_done, o_busy\n\t// {{{\n\tinitial\taux    = 0;\n\tinitial\to_done = 0;\n\tinitial\to_busy = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\t// {{{\n\t\taux    <= 0;\n\t\to_done <= 0;\n\t\to_busy <= 0;\n\t\t// }}}\n\tend else if (!o_busy)\n\tbegin\n\t\t// {{{\n\t\to_done <= 0;\n\t\to_busy <= i_stb;\n\t\taux    <= (!OPT_LOWPOWER || i_stb) ? i_aux : 0;\n\t\t// }}}\n\tend else if (almost_done)\n\tbegin\n\t\t// {{{\n\t\to_done <= 1;\n\t\to_busy <= 0;\n\t\t// }}}\n\tend else\n\t\to_done <= 0;\n\t// }}}\n\n\tassign\tp",
            "wire = (p_b[0] ? p_a : 0);\n\n\t// count, partial, p_a, p_b\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!o_busy)\n\tbegin\n\t\tcount <= NA[LGNA-1:0]-1;\n\t\tpartial <= 0;\n\t\tp_a <= i_a;\n\t\tp_b <= i_b;\n\n\t\tif (OPT_LOWPOWER && !i_stb)\n\t\tbegin\n\t\t\tp_a <= 0;\n\t\t\tp_b <= 0;\n\t\tend\n\tend else begin\n\t\tp_b <= (p_b >> 1);\n\t\t// partial[NA+NB-1:NB] <= partial[NA+NB\n\t\tpartial[NB-2:0] <= partial[NB-1:1];\n\t\tif ((OPT_SIGNED)&&(pre_done))\n\t\t\tpartial[NA+NB-1:NB-1] <= { 1'b0, partial[NA+NB-1:NB]} +\n\t\t\t\t{ 1'b0, p",
            "wire [NA-1], ~p",
            "wire [NA-2:0] };\n\t\telse if (OPT_SIGNED)\n\t\t\tpartial[NA+NB-1:NB-1] <= {1'b0,partial[NA+NB-1:NB]} +\n\t\t\t\t{ 1'b0, !p",
            "wire [NA-1], p",
            "wire [NA-2:0] };\n\t\telse\n\t\t\tpartial[NA+NB-1:NB-1] <= {1'b0, partial[NA+NB-1:NB]}\n\t\t\t\t+ ((p_b[0]) ? {1'b0,p_a} : 0);\n\t\tcount <= count - 1;\n\tend\n\t// }}}\n\n\t// o_p, o_aux\n\t// {{{\n\talways @(posedge i_clk)\n\tif (almost_done)\n\tbegin\n\t\tif (OPT_SIGNED)\n\t\t\to_p   <= partial[NA+NB-1:0]\n\t\t\t\t+ { 1'b1, {(NA-2){1'b0}}, 1'b1, {(NB){1'b0}} };\n\t\telse\n\t\t\to_p   <= partial[NA+NB-1:0];\n\t\to_aux <= aux;\n\tend\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Declarations and reset\n\t// {{{\n`define\tASSERT\tassert\n`ifdef\tSLOWMPY\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "reg f_past_valid;\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\tinitial\tassume(i_reset);\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(i_reset);\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\tbegin\n\t\t`ASSERT(almost_done == 0);\n\t\t`ASSERT(o_done == 0);\n\t\t`ASSERT(o_busy == 0);\n\t\t`ASSERT(aux == 0);\n\tend\n\n\t// Assumptions about our",
            "input s\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_stb))&&($past(o_busy)))\n\tbegin\n\t\t`ASSUME(i_stb);\n\t\t`ASSUME($stable(i_a));\n\t\t`ASSUME($stable(i_b));\n\tend\n\n\t//\n\t// For now, just formally verify our internal signaling\n\t// {{{\n\n\talways @(posedge i_clk)\n\t\t`ASSERT(almost_done == (o_busy&&(&count)));\n\n\talways @(*)\n\t\tif (!(&count[LGNA-1:1])||(count[0]))\n\t\t\t`ASSERT(!o_done);\n\n\talways @(posedge i_clk)\n\tif (o_done)\n\t\t`ASSERT(!o_busy);\n\talways @(posedge i_clk)\n\tif (!o_busy)\n\t\t`ASSERT(!almost_done);",
            "reg [NA-1:0]\tf_a, f_b;\n\talways @(posedge i_clk)\n\tif ((i_stb)&&(!o_busy))\n\tbegin\n\t\tf_a <= i_a;\n\t\tf_b <= i_b;\n\tend\n\n\talways @(*)\n\tif (o_done)\n\tbegin\n\t\tif ((f_a == 0)||(f_b == 0))\n\t\tbegin\n\t\t\t`ASSERT(o_p == 0);\n\t\tend else\n\t\t\t`ASSERT(o_p[NA+NB-1] == f_a[NA-1] ^ f_b[NA-1]);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\talways @(posedge i_clk)\n\t\tcover(o_done);",
            "reg cvr_past_done;\n\tinitial\tcvr_past_done = 1'b0;\n\talways @(posedge i_clk)\n\tif (o_done)\n\t\tcvr_past_done <= 1'b1;\n\n\talways @(posedge i_clk)\n\t\tcover((o_done)&&(cvr_past_done));\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "axiops.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axiops.v",
        "chunks": [
            "module axiops #(\n\t\t// {{{",
            "parameter C_AXI_ADDR_WIDTH = 32,",
            "parameter C_AXI_DATA_WIDTH = 32,",
            "parameter C_AXI_ID_WIDTH = 1,",
            "parameter [((C_AXI_ID_WIDTH > 0)? C_AXI_ID_WIDTH:1)-1:0]\n\t\t\t\t\tAXI_ID = 0,\n\t\t//\n\t\t// SWAP_ENDIANNESS\n\t\t// {{{\n\t\t// The ZipCPU was designed to be a big endian machine.  With\n\t\t// no other adjustments, this design will make the ZipCPU\n\t\t// *little* endian, for the simple reason that the AXI bus is\n\t\t// a little endian bus.  However, if SWAP_ENDIANNESS is set,\n\t\t// the bytes within 32-bit words on the AXI bus will be swapped.\n\t\t// This will return the CPU to being a big endian CPU on a\n\t\t// little endian bus.  It will also break any design that\n\t\t// assumes the bus is presented to it in its proper order.\n\t\t// Simple things like counters or interrupt controllers will\n\t\t// therefore cease to work with this option unless they also\n\t\t// swap the endianness of the words they are given.",
            "parameter [0:0]\tSWAP_ENDIANNESS = 1'b0,\n\t\t// }}}\n\t\t// SWAP_WSTRB\n\t\t// {{{\n\t\t// SWAP_WSTRB represents a second attempt to fix the endianness\n\t\t// issue.  It is incompatible with the SWAP_ENDIANNESS option\n\t\t// above.  If SWAP_WSTRB is set, then half words and words will\n\t\t// be placed on the bus in little endian order, but at big\n\t\t// endian addresses.  Words written to the bus will be written\n\t\t// in little endian order.  Halfwords written to the bus at\n\t\t// address 2 will be written to address 0, halfwords written to\n\t\t// address 0 will be written to address 2.  Bytes written to the\n\t\t// but at address 3 will be written to address 0, address 2\n\t\t// will be written to address 1, address 1 to address 2, and\n\t\t// address 3 to address 0.\n\t\t//\n\t\t// This may just be a half baked attempt to solve this problem,\n\t\t// since it will fail if you ever trie to access bytes or\n\t\t// halfwords at other than their intended widths.",
            "parameter [0:0]\tSWAP_WSTRB = 1'b0,\n\t\t// }}}\n\t\t// OPT_SIGN_EXTEND\n\t\t// {{{\n\t\t// Some CPU's want memory accesses to be sign extended upon\n\t\t// return.  The ZipCPU is not one of those CPU's.  However,\n\t\t// since it's fairly easy to do so, we'll implement this",
            "logic // if ever OPT_SIGN_EXTEND is true so you can see how it would\n\t\t// be done if necessary.",
            "parameter [0:0]\tOPT_SIGN_EXTEND = 1'b0,\n\t\t// }}}",
            "parameter [0:0]\t\tOPT_LOCK=1'b1,\n\t\t// OPT_ALIGNMENT_ERR\n\t\t// {{{\n\t\t// If set, OPT_ALIGNMENT_ERR will generate an alignment error\n\t\t// on any attempt to write to or read from an unaligned word.\n\t\t// If not set, unaligned reads (or writes) will be expanded into\n\t\t// pairs so as to still accomplish the action requested.  The\n\t\t// bus does not guarantee protection, however, that these two\n\t\t// writes or two reads will proceed uninterrupted.  Since\n\t\t// unaligned writes and unaligned reads are no longer\n\t\t// guaranteed to be atomic by the AXI bus, it is possible that\n\t\t// any unaligned operations might yield an incoherent result.",
            "parameter [0:0]\t\tOPT_ALIGNMENT_ERR = 1'b0,\n\t\t// }}}\n\t\t// OPT_LOWPOWER\n\t\t// {{{\n\t\t// If set, the design will use extra",
            "logic to guarantee that any\n\t\t// unused",
            "reg isters are kept at zero until they are used.  This\n\t\t// will help to guarantee the design (ideally) has fewer\n\t\t// transitions and therefore uses lower power.",
            "parameter [0:0]\t\tOPT_LOWPOWER = 1'b1,\n\t\t// }}}",
            "parameter [3:0]\tOPT_QOS = 0,",
            "localparam IW = (C_AXI_ID_WIDTH > 0) ? C_AXI_ID_WIDTH:1,",
            "localparam AW = C_AXI_ADDR_WIDTH,",
            "localparam DW = C_AXI_DATA_WIDTH,",
            "localparam AXILSB = $clog2(C_AXI_DATA_WIDTH/8)\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,",
            "input ",
            "wire i_cpu_reset,\n\t\t//\n\t\t// CPU interface\n\t\t// {{{",
            "input ",
            "wire i_stb,",
            "input ",
            "wire i_lock,",
            "input ",
            "wire [2:0]\t\t\ti_op,",
            "input ",
            "wire [AW-1:0]\t\ti_addr,",
            "input ",
            "wire [AW-1:0]\t\ti_restart_pc,",
            "input ",
            "wire [31:0]\t\t\ti_data,",
            "input ",
            "wire [4:0]\t\t\ti_o",
            "reg ,",
            "output ",
            "reg o_busy,",
            "output ",
            "reg o_rdbusy,",
            "output ",
            "reg o_valid,",
            "output ",
            "reg o_err,",
            "output ",
            "reg [4:0]\t\t\to_w",
            "reg ,",
            "output ",
            "reg [31:0]\t\t\to_result,\n\t\t// }}}\n\t\t// AXI4 bus interface\n\t\t//\n\t\t// Writes\n\t\t// {{{",
            "output ",
            "reg M_AXI_AWVALID,",
            "input ",
            "wire M_AXI_AWREADY,\n\t\t// verilator coverage_off",
            "output ",
            "wire [IW-1:0]\t\tM_AXI_AWID,\n\t\t// verilator coverage_on",
            "output ",
            "reg [AW-1:0]\t\tM_AXI_AWADDR,",
            "output ",
            "wire [7:0]\t\t\tM_AXI_AWLEN,",
            "output ",
            "wire [2:0]\t\t\tM_AXI_AWSIZE,",
            "output ",
            "wire [1:0]\t\t\tM_AXI_AWBURST,",
            "output ",
            "wire M_AXI_AWLOCK,",
            "output ",
            "wire [3:0]\t\t\tM_AXI_AWCACHE,\n\t\t// verilator coverage_off",
            "output ",
            "wire [2:0]\t\t\tM_AXI_AWPROT,",
            "output ",
            "wire [3:0]\t\t\tM_AXI_AWQOS,\n\t\t// verilator coverage_on\n\t\t//",
            "output ",
            "reg M_AXI_WVALID,",
            "input ",
            "wire M_AXI_WREADY,",
            "output ",
            "reg [DW-1:0]\t\tM_AXI_WDATA,",
            "output ",
            "reg [DW/8-1:0]\t\tM_AXI_WSTRB,",
            "output ",
            "wire M_AXI_WLAST,\n\t\t//",
            "input ",
            "wire M_AXI_BVALID,",
            "output ",
            "reg M_AXI_BREADY,\n\t\t// verilator coverage_off",
            "input ",
            "wire [IW-1:0]\t\tM_AXI_BID,\n\t\t// verilator coverage_on",
            "input ",
            "wire [1:0]\t\t\tM_AXI_BRESP,\n\t\t// }}}\n\t\t// Reads\n\t\t// {{{",
            "output ",
            "reg M_AXI_ARVALID,",
            "input ",
            "wire M_AXI_ARREADY,\n\t\t// verilator coverage_off",
            "output ",
            "wire [IW-1:0]\t\tM_AXI_ARID,\n\t\t// verilator coverage_on",
            "output ",
            "reg [AW-1:0]\t\tM_AXI_ARADDR,",
            "output ",
            "wire [7:0]\t\t\tM_AXI_ARLEN,",
            "output ",
            "wire [2:0]\t\t\tM_AXI_ARSIZE,",
            "output ",
            "wire [1:0]\t\t\tM_AXI_ARBURST,",
            "output ",
            "wire M_AXI_ARLOCK,",
            "output ",
            "wire [3:0]\t\t\tM_AXI_ARCACHE,\n\t\t// verilator coverage_off",
            "output ",
            "wire [2:0]\t\t\tM_AXI_ARPROT,",
            "output ",
            "wire [3:0]\t\t\tM_AXI_ARQOS,\n\t\t// verilator coverage_on\n\t\t//",
            "input ",
            "wire M_AXI_RVALID,",
            "output ",
            "reg M_AXI_RREADY,\n\t\t// verilator coverage_off",
            "input ",
            "wire [IW-1:0]\t\tM_AXI_RID,\n\t\t// verilator coverage_on",
            "input ",
            "wire [DW-1:0]\t\tM_AXI_RDATA,",
            "input ",
            "wire M_AXI_RLAST,",
            "input ",
            "wire [1:0]\t\t\tM_AXI_RRESP\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam CPU_DATA_WIDTH = 32;\n\t// Verilator lint_off WIDTH",
            "localparam [2:0]\tDSZ = $clog2(CPU_DATA_WIDTH/8);\n\t// Verilator lint_on  WIDTH",
            "localparam [1:0]\tAXI_INCR = 2'b01,\n\t\t\t\tOKAY   = 2'b00,\n\t\t\t\tEXOKAY = 2'b01;",
            "wire i_clk = S_AXI_ACLK;\n\t//",
            "wire i_reset = !S_AXI_ARESETN;",
            "reg w_misaligned, w_misalignment_err;",
            "wire misaligned_request, misaligned_aw_request,\n\t\tmisaligned_response_pending, pending_err, misaligned_read;",
            "reg r_flushing;",
            "reg [AW-1:0]\t\tr_pc;",
            "reg [AXILSB+1:0]\t\tr_op;",
            "reg [DW-1:0]\t\tnext_wdata;",
            "reg [DW/8-1:0]\t\tnext_wstrb;",
            "reg [DW-1:0]\t\tlast_result;\n\t//",
            "reg [31:0]\t\t\tendian_swapped_wdata;\n\t//",
            "reg [31:0]\t\t\tendian_swapped_result;",
            "reg [2*DW/8-1:0]\t\tshifted_wstrb_word,\n\t\t\t\t\tshifted_wstrb_halfword,\n\t\t\t\t\tshifted_wstrb_byte;",
            "reg [2*DW/8-1:0]\t\tswapped_wstrb_word,\n\t\t\t\t\tswapped_wstrb_halfword,\n\t\t\t\t\tswapped_wstrb_byte;",
            "reg [DW-1:0]\t\taxi_wdata;",
            "reg [DW/8-1:0]\t\taxi_wstrb;",
            "reg axlock;",
            "reg [AXILSB-1:0]\t\tswapaddr;",
            "wire [DW-1:0]\t\tendian_swapped_rdata;",
            "reg [2*DW-1:0]\t\twide_return;",
            "reg [31:0]\t\t\tpre_result;\n\n\t// }}}\n\n\t// xVALID, and xREADY\n\t// {{{\n\tinitial\tM_AXI_AWVALID = 1'b0;\n\tinitial\tM_AXI_WVALID = 1'b0;\n\tinitial\tM_AXI_ARVALID = 1'b0;\n\tinitial\tM_AXI_BREADY = 1'b0;\n\tinitial\tM_AXI_RREADY = 1'b0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN)\n\tbegin\n\t\t// {{{\n\t\tM_AXI_AWVALID <= 1'b0;\n\t\tM_AXI_WVALID  <= 1'b0;\n\t\tM_AXI_ARVALID <= 1'b0;\n\t\tM_AXI_BREADY  <= 1'b0;\n\t\tM_AXI_RREADY  <= 1'b0;\n\t\t// }}}\n\tend else if (M_AXI_BREADY || M_AXI_RREADY)\n\tbegin // Something is outstanding\n\t\t// {{{\n\t\tif (M_AXI_AWREADY)\n\t\t\tM_AXI_AWVALID <= M_AXI_AWVALID && misaligned_aw_request;\n\t\tif (M_AXI_WREADY)\n\t\t\tM_AXI_WVALID  <= M_AXI_WVALID && misaligned_request;\n\t\tif (M_AXI_ARREADY)\n\t\t\tM_AXI_ARVALID <= M_AXI_ARVALID && misaligned_request;\n\n\t\tif ((M_AXI_BVALID || M_AXI_RVALID) && !misaligned_response_pending)\n\t\tbegin\n\t\t\tM_AXI_BREADY <= 1'b0;\n\t\t\tM_AXI_RREADY <= 1'b0;\n\t\tend\n\t\t// }}}\n\tend else begin // New memory operation\n\t\t// {{{\n\t\t// Initiate a request\n\t\tM_AXI_AWVALID <=  i_op[0];\t// Write request\n\t\tM_AXI_WVALID  <=  i_op[0];\t// Write request\n\t\tM_AXI_ARVALID <= !i_op[0];\t// Read request\n\n\t\t// Set BREADY or RREADY to accept the response.  These will\n\t\t// remain ready until the response is returned.\n\t\tM_AXI_BREADY  <=  i_op[0];\n\t\tM_AXI_RREADY  <= !i_op[0];\n\n\t\tif (i_cpu_reset || o_err || !i_stb || w_misalignment_err)\n\t\tbegin\n\t\t\tM_AXI_AWVALID <= 0;\n\t\t\tM_AXI_WVALID  <= 0;\n\t\t\tM_AXI_ARVALID <= 0;\n\n\t\t\tM_AXI_BREADY <= 0;\n\t\t\tM_AXI_RREADY <= 0;\n\t\tend\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// axlock\n\t// {{{\n\tinitial\taxlock = 1'b0;\n\talways @(posedge i_clk)\n\tif (!OPT_LOCK || (!S_AXI_ARESETN && OPT_LOWPOWER))\n\tbegin\n\t\t// {{{\n\t\taxlock <= 1'b0;\n\t\t// }}}\n\tend else if (M_AXI_BREADY || M_AXI_RREADY)\n\tbegin // Something is outstanding\n\t\t// {{{\n\t\tif (OPT_LOWPOWER && (M_AXI_BVALID || M_AXI_RVALID))\n\t\t\taxlock <= axlock && i_lock && M_AXI_RVALID;\n\t\t// }}}\n\tend else begin // New memory operation\n\t\t// {{{\n\t\t// Initiate a request\n\t\tif (!OPT_LOWPOWER)\n\t\t\taxlock <= i_lock;\n\t\telse begin\n\t\t\tif (i_stb)\n\t\t\t\taxlock <= i_lock;\n\n\t\t\tif (i_cpu_reset || o_err || w_misaligned)\n\t\t\t\taxlock <= 1'b0;\n\t\tend\n\t\t// }}}\n\tend\n\n\tassign\tM_AXI_AWLOCK = axlock;\n\tassign\tM_AXI_ARLOCK = axlock;\n\t// }}}\n\n\t// r_flushing\n\t// {{{\n\tinitial\tr_flushing = 1'b0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN)\n\t\t// If everything is reset, then we don't need to worry about\n\t\t// or wait for any pending returns--they'll be canceled by the\n\t\t// global reset.\n\t\tr_flushing <= 1'b0;\n\telse if (M_AXI_BREADY || M_AXI_RREADY)\n\tbegin\n\t\tif (i_cpu_reset)\n\t\t\t// If only the CPU is reset, however, we have a problem.\n\t\t\t// The bus hasn't been reset, and so it is still active.\n\t\t\t// We can't respond to any new requests from the CPU\n\t\t\t// until we flush any transactions that are currently\n\t\t\t// active.\n\t\t\tr_flushing <= 1'b1;\n\t\tif (M_AXI_BVALID || M_AXI_RVALID)\n\t\t\t// A request just came back, therefore we can clear\n\t\t\t// r_flushing\n\t\t\tr_flushing <= 1'b0;\n\t\tif (misaligned_response_pending)\n\t\t\t// ... unless we're in the middle of a misaligned\n\t\t\t// request.  In that case, there will be a second\n\t\t\t// return that we still need to wait for.  This request,\n\t\t\t// though, will clear misaligned_response_pending.\n\t\t\tr_flushing <= r_flushing || i_cpu_reset;\n\tend else\n\t\t// If nothing is active, we don't care about the CPU reset.\n\t\t// Flushing just stays at zero.\n\t\tr_flushing <= 1'b0;\n\t// }}}\n\n\t// M_AXI_AxADDR\n\t// {{{\n\tinitial\tM_AXI_AWADDR = 0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN && OPT_LOWPOWER)\n\t\tM_AXI_AWADDR <= 0;\n\telse if (!M_AXI_BREADY && !M_AXI_RREADY)\n\tbegin // Initial address\n\t\t// {{{\n\t\tM_AXI_AWADDR <= i_addr;\n\n\t\tif (OPT_LOWPOWER && (i_cpu_reset || o_err || !i_stb || w_misalignment_err))\n\t\t\tM_AXI_AWADDR <= 0;\n\n\t\tif (SWAP_ENDIANNESS || SWAP_WSTRB)\n\t\tbegin\n\t\t\t// When adjusting endianness, reads (or writes) are\n\t\t\t// always full words.  This is important since the\n\t\t\t// the bytes at issues may (or may not) be in their\n\t\t\t// expected locations\n\t\t\tif (OPT_ALIGNMENT_ERR)\n\t\t\t\tM_AXI_AWADDR[AXILSB-1:0] <= 0;\n\t\t\telse\n\t\t\t\tM_AXI_AWADDR[1:0] <= 0;\n\t\tend\n\t\t// }}}\n\tend else if ((M_AXI_AWVALID && M_AXI_AWREADY)\n\t\t\t||(M_AXI_ARVALID && M_AXI_ARREADY))\n\tbegin // Subsequent addresses\n\t\t// {{{\n\t\tM_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:AXILSB]\n\t\t\t<= M_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:AXILSB] + 1;\n\n\t\tM_AXI_AWADDR[AXILSB-1:0] <= 0;\n\n\t\tif (OPT_LOWPOWER && ((M_AXI_RREADY && !misaligned_request)\n\t\t\t|| (M_AXI_BREADY && !misaligned_aw_request)))\n\t\t\tM_AXI_AWADDR <= 0;\n\t\t// }}}\n\tend\n\n\talways @(*)\n\t\tM_AXI_ARADDR = M_AXI_AWADDR;\n\t// }}}\n\n\t// M_AXI_AxSIZE\n\t// {{{",
            "reg [2:0]\taxsize;\n\n\tinitial\taxsize = DSZ;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN)\n\t\taxsize <= DSZ;\n\telse if (!M_AXI_BREADY && !M_AXI_RREADY && (!OPT_LOWPOWER || i_stb))\n\tbegin\n\t\tcasez(i_op[2:1])\n\t\t2'b0?: begin\n\t\t\taxsize <= 3'b010;\t// Word\n\t\t\tif ((|i_addr[1:0]) && !w_misaligned)\n\t\t\t\taxsize <= AXILSB[2:0];\n\t\t\tend\n\t\t2'b10: begin\n\t\t\taxsize <= 3'b001;\t// Half-word\n\t\t\tif (i_addr[0] && !w_misaligned)\n\t\t\t\taxsize <= AXILSB[2:0];\n\t\t\tend\n\t\t2'b11: axsize <= 3'b000;\t// Byte\n\t\tendcase\n\n\t\tif (SWAP_WSTRB)\n\t\t\taxsize <= (OPT_ALIGNMENT_ERR) ? DSZ : AXILSB[2:0];\n\tend\n\n\tassign\tM_AXI_AWSIZE = axsize;\n\tassign\tM_AXI_ARSIZE = axsize;\n\t// }}}\n\n\t// AxOTHER\n\t// {{{",
            "localparam [3:0]\tAXI_NON_CACHABLE_BUFFERABLE = 4'h3;",
            "localparam [3:0]\tOPT_CACHE = AXI_NON_CACHABLE_BUFFERABLE;",
            "localparam [2:0]\tAXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS = 3'h0;",
            "localparam [2:0]\tOPT_PROT=AXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS;\n\n\tassign\tM_AXI_AWID    = AXI_ID;\n\tassign\tM_AXI_AWLEN   = 0;\n\tassign\tM_AXI_AWBURST = AXI_INCR;\n\tassign\tM_AXI_AWCACHE = M_AXI_AWLOCK ? 0: OPT_CACHE;\n\tassign\tM_AXI_AWPROT  = OPT_PROT;\n\tassign\tM_AXI_AWQOS   = OPT_QOS;\n\tassign\tM_AXI_WLAST   = 1;\n\n\tassign\tM_AXI_ARID    = AXI_ID;\n\tassign\tM_AXI_ARLEN   = 0;\n\tassign\tM_AXI_ARBURST = AXI_INCR;\n\tassign\tM_AXI_ARCACHE = M_AXI_ARLOCK ? 0: OPT_CACHE;\n\tassign\tM_AXI_ARPROT  = OPT_PROT;\n\tassign\tM_AXI_ARQOS   = OPT_QOS;\n\t// }}}\n\n\t// shifted_wstrb_*\n\t// {{{\n\tgenerate if (SWAP_WSTRB)\n\tbegin : BIG_ENDIAN_WSTRB\n\t\talways @(*)\n\t\t\tshifted_wstrb_word = { 4'b1111, {(2*DW/8-4){1'b0}} }\n\t\t\t\t\t\t>> i_addr[AXILSB-1:0];\n\n\t\talways @(*)\n\t\t\tshifted_wstrb_halfword = { 2'b11, {(2*DW/8-2){1'b0}} }\n\t\t\t\t\t\t>> i_addr[AXILSB-1:0];\n\n\t\talways @(*)\n\t\t\tshifted_wstrb_byte = { 1'b1, {(2*DW/8-1){1'b0}} }\n\t\t\t\t\t\t>> i_addr[AXILSB-1:0];\n\tend else begin : NORMAL_SHIFTED_WSTRB\n\t\talways @(*)\n\t\tshifted_wstrb_word = { {(2*DW/8-4){1'b0}},\n\t\t\t\t\t\t4'b1111} << i_addr[AXILSB-1:0];\n\n\t\talways @(*)\n\t\tshifted_wstrb_halfword = { {(2*DW/8-4){1'b0}},\n\t\t\t\t\t\t4'b0011} << i_addr[AXILSB-1:0];\n\n\t\talways @(*)\n\t\tshifted_wstrb_byte = { {(2*DW/8-4){1'b0}},\n\t\t\t\t\t\t4'b0001} << i_addr[AXILSB-1:0];\n\tend endgenerate\n\t// }}}\n\n\t// Swapping WSTRB bits\n\t// {{{\n\tgenerate if (SWAP_ENDIANNESS)\n\tbegin : SWAPPING_ENDIANNESS\n\t\t// {{{\n\t\tgenvar\tgw, gb;\n\n\t\tfor(gw=0; gw<2*DW/32; gw=gw+1)\n\t\tbegin : FOREACH_32B_WORD\n\t\tfor(gb=0; gb<32/8; gb=gb+1)\n\t\tbegin : FOREACH_BYTE\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tswapped_wstrb_word[gw*4+gb]\n\t\t\t\t\t= shifted_wstrb_word[gw*4+(3-gb)];\n\t\t\tswapped_wstrb_halfword[gw*4+gb]\n\t\t\t\t\t= shifted_wstrb_halfword[gw*4+(3-gb)];\n\t\t\tswapped_wstrb_byte[gw*4+gb]\n\t\t\t\t\t= shifted_wstrb_byte[gw*4+(3-gb)];\n\t\tend end end\n\t\t// }}}\n\tend else begin : KEEP_WSTRB\n\t\t// {{{\n\n\t\talways @(*)\n\t\t\tswapped_wstrb_word = shifted_wstrb_word;\n\n\t\talways @(*)\n\t\t\tswapped_wstrb_halfword = shifted_wstrb_halfword;\n\n\t\talways @(*)\n\t\t\tswapped_wstrb_byte = shifted_wstrb_byte;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// wdata, wstrb\n\t// {{{\n\talways @(*)\n\t\tswapaddr = i_addr[AXILSB-1:0];\n\n\tinitial\taxi_wdata = 0;\n\tinitial\taxi_wstrb = 0;\n\tinitial\tnext_wdata  = 0;\n\tinitial\tnext_wstrb  = 0;\n\talways @(posedge i_clk)\n\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\tbegin\n\t\t// {{{\n\t\taxi_wdata <= 0;\n\t\taxi_wstrb <= 0;\n\n\t\tnext_wdata  <= 0;\n\t\tnext_wstrb  <= 0;\n\n\t\tr_op <= 0;\n\t\t// }}}\n\tend else if (i_stb)\n\tbegin\n\t\t// {{{\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b10: { axi_wdata, next_wdata }\n\t\t\t\t<= { i_data[15:0], {(2*C_AXI_DATA_WIDTH-16){1'b0}} }\n\t\t\t\t\t>> (8*swapaddr);\n\t\t\t2'b11: { axi_wdata, next_wdata }\n\t\t\t\t<= { i_data[7:0], {(2*C_AXI_DATA_WIDTH-8){1'b0}} }\n\t\t\t\t\t>> (8*swapaddr);\n\t\t\tdefault: { axi_wdata, next_wdata }\n\t\t\t\t<= { i_data, {(2*C_AXI_DATA_WIDTH-32){1'b0}} }\n\t\t\t\t\t>> (8*swapaddr);\n\t\t\tendcase\n\t\tend else begin\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b10: { next_wdata, axi_wdata }\n\t\t\t\t<= { {(2*C_AXI_DATA_WIDTH-16){1'b0}},\n\t\t\t\ti_data[15:0] } << (8*swapaddr);\n\t\t\t2'b11: { next_wdata, axi_wdata }\n\t\t\t\t<= { {(2*C_AXI_DATA_WIDTH-8){1'b0}},\n\t\t\t\ti_data[7:0] } << (8*swapaddr);\n\t\t\tdefault: { next_wdata, axi_wdata }\n\t\t\t\t<= { {(2*C_AXI_DATA_WIDTH-32){1'b0}},\n\t\t\t\ti_data } << (8*swapaddr);\n\t\t\tendcase\n\t\tend\n\n\t\t// next_wstrb, axi_wstrb\n\t\t// {{{\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b0?: { axi_wstrb, next_wstrb } <= swapped_wstrb_word;\n\t\t\t2'b10: { axi_wstrb, next_wstrb } <= swapped_wstrb_halfword;\n\t\t\t2'b11: { axi_wstrb, next_wstrb } <= swapped_wstrb_byte;\n\t\t\tendcase\n\t\tend else begin\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b0?: { next_wstrb, axi_wstrb } <= swapped_wstrb_word;\n\t\t\t2'b10: { next_wstrb, axi_wstrb } <= swapped_wstrb_halfword;\n\t\t\t2'b11: { next_wstrb, axi_wstrb } <= swapped_wstrb_byte;\n\t\t\tendcase\n\t\tend\n\t\t// }}}\n\n\t\tr_op <= { i_op[2:1] , i_addr[AXILSB-1:0] };\n\n\t\t// On a read set everything to zero but only if OPT_LOWPOWER\n\t\t// is set\n\t\t// {{{\n\t\tif (OPT_LOWPOWER && !i_op[0])\n\t\t\t{ next_wstrb, next_wdata, axi_wstrb, axi_wdata } <= 0;\n\n\t\tif (w_misalignment_err)\n\t\t\t{ next_wstrb, next_wdata } <= 0;\n\t\tif (OPT_LOWPOWER)\n\t\tbegin\n\t\t\tif (w_misalignment_err)\n\t\t\t\t{ axi_wdata, axi_wstrb, r_op } <= 0;\n\t\t\tif (o_err || i_cpu_reset)\n\t\t\t\t{ next_wdata, next_wstrb,\n\t\t\t\t\taxi_wdata, axi_wstrb, r_op } <= 0;\n\t\tend\n\t\t// }}}\n\t\t// }}}\n\tend else if ((misaligned_request || !OPT_LOWPOWER) && M_AXI_WREADY)\n\tbegin\n\t\t// {{{\n\t\taxi_wdata <= next_wdata;\n\t\taxi_wstrb <= next_wstrb;\n\t\tif (OPT_LOWPOWER)\n\t\t\t{ next_wdata, next_wstrb } <= 0;\n\t\t// }}}\n\tend else if (OPT_LOWPOWER && M_AXI_WREADY)\n\tbegin\n\t\t// {{{\n\t\taxi_wdata <= 0;\n\t\taxi_wstrb <= 0;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// M_AXI_WDATA, M_AXI_WSTRB\n\t// {{{\n\tgenerate if (SWAP_ENDIANNESS)\n\tbegin : SWAP_WRITE_DATA_STRB\n\t\t// {{{\n\t\tgenvar\tgw, gb;\n\n\t\tfor(gw=0; gw<C_AXI_DATA_WIDTH/32; gw=gw+1)\n\t\tbegin\n\t\t\tfor(gb=0; gb<32/8; gb=gb+1)\n\t\t\tbegin\n\t\t\t\talways @(*)\n\t\t\t\tbegin\n\t\t\t\t\tM_AXI_WDATA[32*gw + 8*gb +: 8] = axi_wdata[32*gw+8*(3-gb) +: 8];\n\t\t\t\t\tM_AXI_WSTRB[4*gw + gb] = axi_wstrb[4*gw+(3-gb)];\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t// }}}\n\tend else begin : KEEP_WRITE_DATA_STRB\n\t\t// {{{\n\t\talways @(*)\n\t\t\t{ M_AXI_WSTRB, M_AXI_WDATA } = { axi_wstrb, axi_wdata };\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// w_misaligned\n\t// {{{\n\talways @(*)\n\tcasez(i_op[2:1])\n\t// Full word\n\t2'b0?: w_misaligned = ((i_addr[AXILSB-1:0]+3) >= (1<<AXILSB));\n\t// Half word\n\t2'b10: w_misaligned = ((i_addr[AXILSB-1:0]+1) >= (1<<AXILSB));\n\t// Bytes are always aligned\n\t2'b11: w_misaligned = 1'b0;\n\tendcase\n\t// }}}\n\n\t// w_misalignment_err\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tw_misalignment_err = OPT_ALIGNMENT_ERR && w_misaligned;\n\t\tif (OPT_LOCK && i_lock)\n\t\tbegin\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b0?: w_misalignment_err = (|i_addr[1:0]);\n\t\t\t2'b10: w_misalignment_err = i_addr[0];\n\t\t\tdefault:\n\t\t\t\tw_misalignment_err = 1'b0;\n\t\t\tendcase\n\t\tend\n\tend\n\t// }}}\n\n\t// misaligned_[aw_|]request, pending_err, misaligned_response_pending\n\t// {{{\n\tgenerate if (OPT_ALIGNMENT_ERR)\n\tbegin : GEN_ALIGNMENT_ERR\n\t\t// {{{\n\t\tassign\tmisaligned_request = 1'b0;\n\n\t\tassign\tmisaligned_aw_request = 1'b0;\n\t\tassign\tmisaligned_response_pending = 1'b0;\n\t\tassign\tmisaligned_read = 1'b0;\n\t\tassign\tpending_err = 1'b0;\n\t\t// }}}\n\tend else begin : GEN_REALIGN\n\t\t// {{{",
            "reg r_misaligned_request, r_misaligned_aw_request,\n\t\t\tr_misaligned_response_pending, r_misaligned_read,\n\t\t\tr_pending_err;\n\n\t\t// misaligned_request\n\t\t// {{{\n\t\tinitial\tr_misaligned_request = 0;\n\t\talways @(posedge i_clk)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_misaligned_request <= 0;\n\t\telse if (i_stb && !o_err && !i_cpu_reset)\n\t\t\tr_misaligned_request <= w_misaligned\n\t\t\t\t\t\t&& !w_misalignment_err;\n\t\telse if ((M_AXI_WVALID && M_AXI_WREADY)\n\t\t\t\t\t|| (M_AXI_ARVALID && M_AXI_ARREADY))\n\t\t\tr_misaligned_request <= 1'b0;\n\n\t\tassign\tmisaligned_request = r_misaligned_request;\n\t\t// }}}\n\n\t\t// misaligned_aw_request\n\t\t// {{{\n\t\tinitial\tr_misaligned_aw_request = 0;\n\t\talways @(posedge i_clk)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_misaligned_aw_request <= 0;\n\t\telse if (i_stb && !o_err && !i_cpu_reset)\n\t\t\tr_misaligned_aw_request <= w_misaligned && i_op[0]\n\t\t\t\t\t&& !w_misalignment_err;\n\t\telse if (M_AXI_AWREADY)\n\t\t\tr_misaligned_aw_request <= 1'b0;\n\n\t\tassign\tmisaligned_aw_request = r_misaligned_aw_request;\n\t\t// }}}\n\n\t\t// misaligned_response_pending\n\t\t// {{{\n\t\tinitial\tr_misaligned_response_pending = 0;\n\t\talways @(posedge i_clk)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_misaligned_response_pending <= 0;\n\t\telse if (i_stb && !o_err && !i_cpu_reset)\n\t\t\tr_misaligned_response_pending <= w_misaligned\n\t\t\t\t\t\t&& !w_misalignment_err;\n\t\telse if (M_AXI_BVALID || M_AXI_RVALID)\n\t\t\tr_misaligned_response_pending <= 1'b0;\n\n\t\tassign\tmisaligned_response_pending\n\t\t\t\t\t= r_misaligned_response_pending;\n\t\t// }}}\n\n\t\t// misaligned_read\n\t\t// {{{\n\t\tinitial\tr_misaligned_read = 0;\n\t\talways @(posedge i_clk)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_misaligned_read <= 0;\n\t\telse if (i_stb && !o_err && !i_cpu_reset)\n\t\t\tr_misaligned_read <= w_misaligned && !i_op[0]\n\t\t\t\t\t\t&& !w_misalignment_err;\n\t\telse if (M_AXI_RVALID)\n\t\t\tr_misaligned_read <= (misaligned_response_pending);\n\n\t\tassign\tmisaligned_read = r_misaligned_read;\n\t\t// }}}\n\n\t\t// pending_err\n\t\t// {{{\n\t\tinitial\tr_pending_err = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_cpu_reset || (!M_AXI_BREADY && !M_AXI_RREADY)\n\t\t\t\t|| r_flushing)\n\t\t\tr_pending_err <= 1'b0;\n\t\telse if ((M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t\t|| (M_AXI_RVALID && M_AXI_RRESP[1]))\n\t\t\tr_pending_err <= 1'b1;\n\n\t\tassign\tpending_err = r_pending_err;\n\t\t// }}}\n\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// o_valid\n\t// {{{\n\tinitial\to_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || r_flushing)\n\t\to_valid <= 1'b0;\n\telse if (axlock)\n\t\to_valid <= (M_AXI_RVALID && M_AXI_RRESP == EXOKAY)\n\t\t\t\t|| (M_AXI_BVALID && M_AXI_BRESP == OKAY);\n\telse\n\t\to_valid <= M_AXI_RVALID && !M_AXI_RRESP[1] && !pending_err\n\t\t\t\t&& !misaligned_response_pending;\n\t// }}}\n\n\t// o_err\n\t// {{{\n\tinitial\to_err = 1'b0;\n\talways @(posedge i_clk)\n\tif (r_flushing || i_cpu_reset || o_err)\n\t\to_err <= 1'b0;\n\telse if (i_stb && w_misalignment_err)\n\t\to_err <= 1'b1;\n\telse if (axlock)\n\tbegin\n\t\to_err <= (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t || (M_AXI_RVALID && M_AXI_RRESP != EXOKAY);\n\tend else if ((M_AXI_BVALID || M_AXI_RVALID)\n\t\t\t\t\t\t&& !misaligned_response_pending)\n\t\to_err <= (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t|| (M_AXI_RVALID && M_AXI_RRESP[1])\n\t\t\t|| pending_err;\n\telse\n\t\to_err <= 1'b0;\n\t// }}}\n\n\t// o_busy, o_rdbusy\n\t// {{{\n\talways @(*)\n\tbegin\n\t\to_busy   = M_AXI_BREADY || M_AXI_RREADY;\n\t\to_rdbusy = (M_AXI_BREADY && axlock) || M_AXI_RREADY;\n\t\tif (r_flushing)\n\t\t\to_rdbusy = 1'b0;\n\tend\n\t// }}}\n\n\t// o_w",
            "reg // {{{\n\talways @(posedge i_clk)\n\tif (i_stb)\n\tbegin\n\t\to_w",
            "reg <= i_o",
            "reg ;\n\t\tif (OPT_LOCK && i_stb && i_lock && i_op[0])\n\t\t\to_w",
            "reg [3:0] <= 4'hf;\n\tend\n\t// }}}\n\n\t// r_pc\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!OPT_LOCK)\n\t\tr_pc <= 0;\n\telse if (i_stb && i_lock && !i_op[0])\n\t\tr_pc <= i_restart_pc;\n\t// }}}\n\n\t// endian_swapped_rdata\n\t// {{{\n\tgenerate if (SWAP_ENDIANNESS)\n\tbegin : SWAP_RDATA_ENDIANNESS\n\t\tgenvar\tgw, gb;\n\n\t\tfor(gw=0; gw<C_AXI_DATA_WIDTH/32; gw=gw+1)\n\t\tbegin\n\t\t\tfor(gb=0; gb<32/8; gb=gb+1)\n\t\t\tbegin\n\t\t\t\tassign\tendian_swapped_rdata[gw*32+gb*8 +: 8]\n\t\t\t\t\t= M_AXI_RDATA[gw*32+(3-gb)*8 +: 8];\n\t\t\tend\n\t\tend\n\tend else begin : KEEP_RDATA\n\t\tassign\tendian_swapped_rdata = M_AXI_RDATA;\n\tend endgenerate\n\t// }}}\n\n\t// pre_result\n\t// {{{\n\t// The purpose of the pre-result is to guarantee that the synthesis\n\t// tool knows we want a shift of the full 2*DW width.\n\talways @(*)\n\tbegin\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tif (misaligned_read && !OPT_ALIGNMENT_ERR)\n\t\t\t\twide_return={ last_result, endian_swapped_rdata }\n\t\t\t\t\t\t<< (8*r_op[AXILSB-1:0]);\n\t\t\telse\n\t\t\t\twide_return = { endian_swapped_rdata, {(DW){1'b0}} }\n\t\t\t\t\t\t<< (8*r_op[AXILSB-1:0]);\n\n\t\tend else begin\n\t\t\tif (misaligned_read && !OPT_ALIGNMENT_ERR)\n\t\t\t\twide_return={ endian_swapped_rdata, last_result }\n\t\t\t\t\t\t>> (8*r_op[AXILSB-1:0]);\n\t\t\telse\n\t\t\t\twide_return = { {(DW){1'b0}}, endian_swapped_rdata }\n\t\t\t\t\t\t>> (8*r_op[AXILSB-1:0]);\n\t\tend\n\n\t\tif (OPT_LOWPOWER && (!M_AXI_RVALID || M_AXI_RRESP[1]))\n\t\t\twide_return = 0;\n\tend\n\n\talways @(*)\n\tbegin\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tpre_result = 0;\n\n\t\t\tcasez(r_op[AXILSB +: 2])\n\t\t\t2'b10: pre_result[15:0] = {\n\t\t\t\t\twide_return[(2*DW)-1:(2*DW)-16] };\n\t\t\t2'b11: pre_result[7:0] = {\n\t\t\t\t\twide_return[(2*DW)-1:(2*DW)-8] };\n\t\t\tdefault: pre_result[31:0] = wide_return[(2*DW-1):(2*DW-32)];\n\t\t\tendcase\n\n\t\tend else\n\t\t\tpre_result = wide_return[31:0];\n\tend\n\n\t// }}}\n\t// last_result, o_result\n\t// {{{\n\talways @(posedge i_clk)\n\tif (OPT_LOWPOWER &&((!M_AXI_RREADY && (!OPT_LOCK || !M_AXI_BREADY))\n\t\t\t|| !S_AXI_ARESETN || r_flushing || i_cpu_reset))\n\t\t{ last_result, o_result } <= 0;\n\telse begin\n\t\t// {{{\n\t\tif (OPT_LOWPOWER)\n\t\t\to_result <= 0;\n\n\t\tif (OPT_LOCK && M_AXI_BVALID && (!OPT_LOWPOWER\n\t\t\t\t\t|| (axlock && M_AXI_BRESP == OKAY)))\n\t\tbegin\n\t\t\to_result <= 0;\n\t\t\to_result[AW-1:0] <= r_pc;\n\t\tend\n\n\t\tif (M_AXI_RVALID)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tif (OPT_LOWPOWER && (M_AXI_RRESP[1] || !misaligned_response_pending))\n\t\t\t\tlast_result <= 0;\n\t\t\telse\n\t\t\t\tlast_result <= endian_swapped_rdata;\n\n\t\t\to_result <= pre_result[31:0];\n\n\t\t\tif (OPT_SIGN_EXTEND)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\t// verilator coverage_off\n\t\t\t\t// Optionally sign extend the return result.\n\t\t\t\t//   Not covered, since this violates ZipCPU ISA\n\t\t\t\tcasez(r_op[AXILSB +: 2])\n\t\t\t\t2'b10: o_result[31:16] <= {(16){pre_result[15]}};\n\t\t\t\t2'b11: o_result[31: 8] <= {(24){pre_result[7]}};\n\t\t\t\tdefault: begin end\n\t\t\t\tendcase\n\t\t\t\t// verilator coverage_off\n\t\t\t\t// }}}\n\t\t\tend else begin\n\t\t\t\t// Fill unused return bits with zeros\n\t\t\t\tcasez(r_op[AXILSB +: 2])\n\t\t\t\t2'b10: o_result[31:16] <= 0;\n\t\t\t\t2'b11: o_result[31: 8] <= 0;\n\t\t\t\tdefault: begin end\n\t\t\t\tendcase\n\t\t\tend\n\n\t\t\tif (OPT_LOWPOWER && (M_AXI_RRESP[1]\n\t\t\t\t\t|| (axlock && !M_AXI_RRESP[0])))\n\t\t\t\to_result <= 0;\n\t\t\t// }}}\n\t\tend\n\n\t\tif (OPT_ALIGNMENT_ERR)\n\t\t\tlast_result <= 0;\n\n\t\tif (OPT_LOWPOWER && (pending_err || misaligned_response_pending))\n\t\t\to_result <= 0;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, M_AXI_BID, M_AXI_RID, M_AXI_RLAST };\n\n\tgenerate if (SWAP_WSTRB)\n\tbegin : GEN_UNUSED",
            "wire wide_unused;\n\n\t\tif (SWAP_WSTRB)\n\t\tbegin : UNUSED_SWAP_RETURN\n\t\t\tassign\twide_unused = &{ 1'b0,\n\t\t\t\t\twide_return[2*DW-32-1:0] };\n\t\tend else begin : UNUSED_RETURN\n\t\t\tassign\twide_unused = &{ 1'b0, wide_return[2*DW-1:32] };\n\t\tend\n\tend endgenerate\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Local declarations\n\t// {{{\n`define\tASSERT\tassert\n`ifdef\tAXIOPS\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "localparam F_LGDEPTH = 10;",
            "reg f_misaligned;",
            "wire [F_LGDEPTH-1:0]\tfaxi_awr_nbursts,\n\t\t\t\tfaxi_rd_nbursts, faxi_rd_outstanding;",
            "wire [8:0]\t\tfaxi_wr_pending;",
            "wire [IW-1:0]\tfaxi_wr_checkid;",
            "wire faxi_wr_ckvalid;",
            "wire [F_LGDEPTH-1:0]\tfaxi_wrid_nbursts;",
            "wire [AW-1:0]\tfaxi_wr_addr;",
            "wire [7:0]\t\tfaxi_wr_incr;",
            "wire [1:0]\t\tfaxi_wr_burst;",
            "wire [2:0]\t\tfaxi_wr_size;",
            "wire [7:0]\t\tfaxi_wr_len;",
            "wire faxi_wr_lockd;\n\t//",
            "wire [IW-1:0]\tfaxi_rd_checkid;",
            "wire faxi_rd_ckvalid;",
            "wire [8:0]\t\tfaxi_rd_cklen;",
            "wire [AW-1:0]\tfaxi_rd_ckaddr;",
            "wire [7:0]\t\tfaxi_rd_ckincr;",
            "wire [1:0]\t\tfaxi_rd_ckburst;",
            "wire [2:0]\t\tfaxi_rd_cksize;",
            "wire [7:0]\t\tfaxi_rd_ckarlen;",
            "wire faxi_rd_cklockd;",
            "wire [F_LGDEPTH-1:0]\tfaxi_rdid_nbursts, faxi_rdid_outstanding;",
            "wire [F_LGDEPTH-1:0]\tfaxi_rdid_ckign_nbursts, faxi_rdid_ckign_outstanding;",
            "wire [1:0]\t\tfaxi_ex_state;",
            "wire faxi_ex_checklock;",
            "wire [F_LGDEPTH-1:0]\tfaxi_rdid_bursts_to_lock;",
            "wire [F_LGDEPTH-1:0]\tfaxi_wrid_bursts_to_exwrite;\n\t(* anyseq *)",
            "wire f_active_lock;",
            "reg [AW-1:0]\tf_exlock_addr;",
            "wire [AW-1:0]\tfaxi_exreq_addr;",
            "wire [7:0]\t\tf_exlock_len, faxi_exreq_len;",
            "wire [1:0]\t\tf_exlock_burst, faxi_exreq_burst;",
            "wire [2:0]\t\tfaxi_exreq_size;",
            "reg [2:0]\t\tf_exlock_size;",
            "wire faxi_exlock_return;",
            "wire f_pc, f_gie, f_read_cycle, f_exwrite_cycle;",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid = 1'b1;\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(!S_AXI_ARESETN);\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tfaxi_master #(\n\t\t// {{{\n\t\t.C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),\n\t\t.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),\n\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t.OPT_EXCLUSIVE(OPT_LOCK),\n\t\t.F_OPT_ASSUME_RESET(1'b1),\n\t\t.F_LGDEPTH(F_LGDEPTH)\n\t\t// }}}\n\t) faxi(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK),\n\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t//\n\t\t// Write address channel\n\t\t// {{{\n\t\t.i_axi_awvalid(M_AXI_AWVALID),\n\t\t.i_axi_awready(M_AXI_AWREADY),\n\t\t.i_axi_awid(   M_AXI_AWID),\n\t\t.i_axi_awaddr( M_AXI_AWADDR),\n\t\t.i_axi_awlen(  M_AXI_AWLEN),\n\t\t.i_axi_awsize( M_AXI_AWSIZE),\n\t\t.i_axi_awburst(M_AXI_AWBURST),\n\t\t.i_axi_awlock( M_AXI_AWLOCK),\n\t\t.i_axi_awcache(M_AXI_AWCACHE),\n\t\t.i_axi_awprot( M_AXI_AWPROT),\n\t\t.i_axi_awqos(  M_AXI_AWQOS),\n\t\t// }}}\n\t\t// Write data\n\t\t// {{{\n\t\t.i_axi_wvalid(M_AXI_WVALID),\n\t\t.i_axi_wready(M_AXI_WREADY),\n\t\t.i_axi_wdata( M_AXI_WDATA),\n\t\t.i_axi_wstrb( M_AXI_WSTRB),\n\t\t.i_axi_wlast( M_AXI_WLAST),\n\t\t// }}}\n\t\t// Write return\n\t\t// {{{\n\t\t.i_axi_bvalid(M_AXI_BVALID),\n\t\t.i_axi_bready(M_AXI_BREADY),\n\t\t.i_axi_bid( M_AXI_BID),\n\t\t.i_axi_bresp( M_AXI_BRESP),\n\t\t// }}}\n\t\t// Read address\n\t\t// {{{\n\t\t.i_axi_arvalid(M_AXI_ARVALID),\n\t\t.i_axi_arready(M_AXI_ARREADY),\n\t\t.i_axi_arid(   M_AXI_ARID),\n\t\t.i_axi_araddr( M_AXI_ARADDR),\n\t\t.i_axi_arlen(  M_AXI_ARLEN),\n\t\t.i_axi_arsize( M_AXI_ARSIZE),\n\t\t.i_axi_arburst(M_AXI_ARBURST),\n\t\t.i_axi_arlock( M_AXI_ARLOCK),\n\t\t.i_axi_arcache(M_AXI_ARCACHE),\n\t\t.i_axi_arprot( M_AXI_ARPROT),\n\t\t.i_axi_arqos(  M_AXI_ARQOS),\n\t\t// }}}\n\t\t// Read return\n\t\t// {{{\n\t\t.i_axi_rvalid(M_AXI_RVALID),\n\t\t.i_axi_rready(M_AXI_RREADY),\n\t\t.i_axi_rid(   M_AXI_RID),\n\t\t.i_axi_rdata( M_AXI_RDATA),\n\t\t.i_axi_rlast( M_AXI_RLAST),\n\t\t.i_axi_rresp( M_AXI_RRESP),\n\t\t// }}}\n\t\t// Induction values\n\t\t// {{{\n\t\t.f_axi_awr_nbursts(faxi_awr_nbursts),\n\t\t.f_axi_wr_pending(faxi_wr_pending),\n\t\t.f_axi_rd_nbursts(faxi_rd_nbursts),\n\t\t.f_axi_rd_outstanding(faxi_rd_outstanding),\n\t\t// Write counters\n\t\t// {{{\n\t\t.f_axi_wr_checkid(faxi_wr_checkid),\n\t\t.f_axi_wr_ckvalid(faxi_wr_ckvalid),\n\t\t.f_axi_wrid_nbursts(faxi_wrid_nbursts),\n\t\t.f_axi_wr_addr(faxi_wr_addr),\n\t\t.f_axi_wr_incr(faxi_wr_incr),\n\t\t.f_axi_wr_burst(faxi_wr_burst),\n\t\t.f_axi_wr_size(faxi_wr_size),\n\t\t.f_axi_wr_len(faxi_wr_len),\n\t\t.f_axi_wr_lockd(faxi_wr_lockd),\n\t\t// }}}\n\t\t// Read counters\n\t\t// {{{\n\t\t.f_axi_rd_checkid(faxi_rd_checkid),\n\t\t.f_axi_rd_ckvalid(faxi_rd_ckvalid),\n\t\t.f_axi_rd_cklen(faxi_rd_cklen),\n\t\t.f_axi_rd_ckaddr(faxi_rd_ckaddr),\n\t\t.f_axi_rd_ckincr(faxi_rd_ckincr),\n\t\t.f_axi_rd_ckburst(faxi_rd_ckburst),\n\t\t.f_axi_rd_cksize(faxi_rd_cksize),\n\t\t.f_axi_rd_ckarlen(faxi_rd_ckarlen),\n\t\t.f_axi_rd_cklockd(faxi_rd_cklockd),\n\t\t.f_axi_rdid_nbursts(faxi_rdid_nbursts),\n\t\t.f_axi_rdid_outstanding(faxi_rdid_outstanding),\n\t\t.f_axi_rdid_ckign_nbursts(faxi_rdid_ckign_nbursts),\n\t\t.f_axi_rdid_ckign_outstanding(faxi_rdid_ckign_outstanding),\n\t\t// }}}\n\t\t// Exclusive access checks\n\t\t// {{{\n\t\t.f_axi_ex_state(faxi_ex_state),\n\t\t.f_axi_ex_checklock(faxi_ex_checklock),\n\t\t.f_axi_rdid_bursts_to_lock(faxi_rdid_bursts_to_lock),\n\t\t.f_axi_wrid_bursts_to_exwrite(faxi_wrid_bursts_to_exwrite),\n\t\t.i_active_lock( f_active_lock),\n\t\t.i_exlock_addr( f_exlock_addr),\n\t\t.i_exlock_len(  f_exlock_len),\n\t\t.i_exlock_burst(f_exlock_burst),\n\t\t.i_exlock_size( f_exlock_size),\n\t\t.f_axi_exreq_addr( faxi_exreq_addr),\n\t\t.f_axi_exreq_len(  faxi_exreq_len),\n\t\t.f_axi_exreq_burst(faxi_exreq_burst),\n\t\t.f_axi_exreq_size( faxi_exreq_size),\n\t\t.f_axi_exreq_return( faxi_exlock_return)\n\t\t// }}}\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\n\talways @(*)\n\tbegin\n\t\tassert(faxi_wrid_nbursts == faxi_awr_nbursts);\n\t\tassert(faxi_rdid_nbursts == faxi_rd_nbursts);\n\t\tassert(faxi_rdid_outstanding == faxi_rd_outstanding);\n\t\tassert(faxi_rd_nbursts == faxi_rd_outstanding);\n\n\t\tassume(faxi_rd_checkid == faxi_wr_checkid);\n\t\tassume(faxi_rd_checkid == AXI_ID);\n\n\t\tif (faxi_wr_ckvalid)\n\t\tbegin\n\t\t\tassert(faxi_wr_burst == M_AXI_AWBURST);\n\t\t\t// assert(faxi_wr_size  == M_AXI_AWSIZE);\n\t\t\tassert(faxi_wr_len   == M_AXI_AWLEN);\t// == 0\n\t\t\tassert(faxi_wr_lockd == axlock);\n\t\tend\n\n\t\tif (faxi_rd_ckvalid)\n\t\tbegin\n\t\t\tassert(faxi_rd_ckburst == M_AXI_ARBURST);\n\t\t\t// assert(faxi_rd_cksize  == M_AXI_ARSIZE);\n\t\t\tassert(faxi_rd_ckarlen == M_AXI_ARLEN);\t// == 0\n\t\t\tassert(faxi_rd_cklockd == axlock);\n\t\tend\n\n\t\tif (misaligned_request)\n\t\t\t`ASSERT(M_AXI_WVALID || M_AXI_ARVALID);\n\t\tif (misaligned_aw_request)\n\t\t\t`ASSERT(M_AXI_AWVALID);\n\n\t\tif (!misaligned_response_pending)\n\t\tbegin\n\t\t\t`ASSERT(faxi_rd_outstanding  <= (M_AXI_ARVALID ? 0:1));\n\t\t\t// `ASSERT(faxi_wr_outstanding  <= (M_AXI_WVALID ? 0:1));\n\t\t\t`ASSERT(faxi_awr_nbursts <= (M_AXI_AWVALID ? 0:1));\n\n\t\t\t`ASSERT(!misaligned_request);\n\t\t\t`ASSERT(!misaligned_aw_request);\n\t\tend else if (M_AXI_RREADY)\n\t\t\t`ASSERT(misaligned_read);\n\n\t\tif (!M_AXI_RREADY)\n\t\tbegin\n\t\t\t`ASSERT(!M_AXI_ARVALID);\n\t\t\t`ASSERT(faxi_rd_outstanding == 0);\n\t\t\t`ASSERT(misaligned_read == 1'b0);\n\t\tend else begin\n\t\t\tif (misaligned_request)\n\t\t\t\t`ASSERT(faxi_rd_outstanding <= 0);\n\t\t\t`ASSERT(faxi_rd_outstanding <= 1 + (misaligned_read ? 1:0));\n\t\t\t// `ASSERT(faxi_rd_outstanding ==\n\t\t\t//\t(M_AXI_RREADY && misaligned_request) ? 1:0)\n\t\t\t//\t((M_AXI_RREADY && !M_AXI_RVALID) ? 1:0)\n\t\t\t//\t);\n\t\tend\n\n\t\tif (!M_AXI_BREADY)\n\t\tbegin\n\t\t\t`ASSERT(!M_AXI_AWVALID);\n\t\t\t`ASSERT(!M_AXI_WVALID);\n\t\t\t`ASSERT(faxi_awr_nbursts == 0);\n\t\t\t`ASSERT(faxi_wr_pending  == 0);\n\t\tend else begin\n\t\t\tif (misaligned_request)\n\t\t\t\t`ASSERT(faxi_wr_pending == (((!M_AXI_AWVALID || !misaligned_aw_request) && M_AXI_WVALID) ? 1:0));\n\n\t\t\tif (misaligned_aw_request)\n\t\t\tbegin\n\t\t\t\t`ASSERT(faxi_awr_nbursts == 0);\n\t\t\t\t`ASSERT(misaligned_request);\n\t\t\t\t`ASSERT(M_AXI_AWVALID);\n\t\t\t\t`ASSERT(M_AXI_WVALID);\n\t\t\tend\n\t\t\t`ASSERT(!M_AXI_AWVALID || M_AXI_WVALID);\n\t\t\t`ASSERT(faxi_awr_nbursts <= 2);\n\t\t\t`ASSERT(faxi_wr_pending <= 2);\n\n\t\t\tcase({misaligned_request,\n\t\t\t\t\tmisaligned_aw_request,\n\t\t\t\t\tmisaligned_response_pending})\n\t\t\t3'b000: begin\n\t\t\t\t`ASSERT(faxi_awr_nbursts<= (M_AXI_BREADY ? 1:0));\n\t\t\t\t`ASSERT(faxi_wr_pending <= (M_AXI_BREADY ? 1:0));\n\t\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\t`ASSERT(faxi_awr_nbursts<= 1 + (M_AXI_AWVALID ? 0:1));\n\t\t\t\t`ASSERT(faxi_wr_pending <= 1 + (M_AXI_WVALID ? 0:1));\n\t\t\t\tend\n\t\t\t3'b010: `ASSERT(0);\n\t\t\t3'b011: begin\n\t\t\t\t`ASSERT(faxi_wr_pending<= 1 + (M_AXI_WVALID ? 0:1));\n\t\t\t\t`ASSERT(faxi_awr_nbursts == 0);\n\t\t\t\t`ASSERT(M_AXI_AWVALID);\n\t\t\t\tend\n\t\t\t3'b100: `ASSERT(0);\n\t\t\t3'b101: begin\n\t\t\t\t`ASSERT(faxi_awr_nbursts<= 1 + (M_AXI_AWVALID ? 0:1));\n\t\t\t\t// `ASSERT(faxi_wr_pending == 0);\n\t\t\t\t`ASSERT(M_AXI_WVALID);\n\t\t\t\tend\n\t\t\t3'b110: `ASSERT(0);\n\t\t\t3'b111: begin\n\t\t\t\t`ASSERT(faxi_awr_nbursts == 0);\n\t\t\t\t// `ASSERT(faxi_wr_pending == 0);\n\t\t\t\t`ASSERT(M_AXI_AWVALID);\n\t\t\t\t`ASSERT(M_AXI_WVALID);\n\t\t\t\tend\n\t\t\tdefault: begin end\n\t\t\tendcase\n\t\tend\n\n\n\t\t// Rule: Only one of the two xREADY's may be valid, never both\n\t\t`ASSERT(!M_AXI_BREADY || !M_AXI_RREADY);\n\n\t\t// Rule: Only one of the two VALID's may be valid, never both\n\t\t`ASSERT(!M_AXI_RVALID || (!M_AXI_AWVALID && !M_AXI_WVALID));\n\tend\n\n\t// f_exlock_*\n\t// {{{\n\tinitial\tf_exlock_size = 3'b010;\n\talways @(posedge i_clk)\n\tif (M_AXI_ARVALID && M_AXI_ARREADY && M_AXI_ARLOCK)\n\tbegin\n\t\tf_exlock_addr <= M_AXI_ARADDR;\n\t\tf_exlock_size <= M_AXI_ARSIZE;\n\tend\n\n\tassign\tf_exlock_len = 0;\n\tassign\tf_exlock_burst = M_AXI_AWBURST;\n\n\t// f_misaligned\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tf_misaligned = 0;\n\t\tcase(r_op[AXILSB +: 2])\n\t\t2'b01: f_misaligned = ((r_op[AXILSB-1:0] + 3) >= (1<<AXILSB));\n\t\t2'b10: f_misaligned = ((r_op[AXILSB-1:0] + 1) >= (1<<AXILSB));\n\t\tdefault: f_misaligned = 0;\n\t\tendcase\n\n\t\tif (!M_AXI_BREADY && !M_AXI_RREADY)\n\t\t\tf_misaligned = 0;\n\tend\n\t// }}}\n\n\talways @(*)\n\tif (!M_AXI_RREADY && !M_AXI_BREADY)\n\tbegin\n\t\t// {{{\n\t\tassert(!misaligned_aw_request);\n\t\tassert(!misaligned_request);\n\t\tassert(!misaligned_response_pending);\n\t\tassert(faxi_awr_nbursts == 0);\n\t\tassert(faxi_wr_pending  == 0);\n\t\tassert(faxi_rd_outstanding  == 0);\n\t\t// }}}\n\tend else if (f_misaligned)\n\tbegin\n\t\t// {{{\n\t\tassert(!OPT_ALIGNMENT_ERR);\n\n\t\tif (misaligned_aw_request || misaligned_request)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tif (misaligned_aw_request)\n\t\t\tbegin\n\t\t\t\tassert(faxi_awr_nbursts == 0);\n\t\t\tend else if (M_AXI_BREADY)\n\t\t\tbegin\n\t\t\t\tassert(faxi_awr_nbursts\n\t\t\t\t\t== (M_AXI_AWVALID ? 0:1)\n\t\t\t\t\t\t+ (misaligned_response_pending ? 1:0));\n\t\t\tend else\n\t\t\t\tassert(faxi_awr_nbursts == 0);\n\n\t\t\tif (misaligned_request && M_AXI_BREADY)\n\t\t\tbegin\n\t\t\t\t// assert(faxil_wr_outstanding  == 0);\n\t\t\t\tassert(faxi_rd_outstanding == 0);\n\t\t\tend else if (M_AXI_RREADY)\n\t\t\tbegin\n\t\t\t\tassert(faxi_rd_outstanding\n\t\t\t\t\t== (M_AXI_ARVALID ? 0:1)\n\t\t\t\t\t\t+ (!misaligned_request && misaligned_response_pending ? 1:0));\n\t\t\t\t// assert(faxil_wr_outstanding == 0);\n\t\t\tend else begin\n\t\t\t\t//assert(faxil_wr_outstanding\n\t\t\t\t//\t== (M_AXI_WVALID ? 0:1)\n\t\t\t\t//\t\t+ (misaligned_response_pending ? 1:0));\n\t\t\t\tassert(faxi_rd_outstanding == 0);\n\t\t\tend\n\t\t\t// }}}\n\t\tend else if (M_AXI_BREADY)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tassert(faxi_awr_nbursts\n\t\t\t\t== (M_AXI_AWVALID ? 0:1)\n\t\t\t\t\t+ (misaligned_response_pending ? 1:0));\n\t\t\t//assert(faxil_wr_outstanding\n\t\t\t//\t== (M_AXI_WVALID ? 0:1)\n\t\t\t//\t\t+ (misaligned_response_pending ? 1:0));\n\t\t\t// }}}\n\t\tend else begin // Read cycle\n\t\t\t// {{{\n\t\t\tassert(M_AXI_RREADY);\n\t\t\tassert(faxi_rd_outstanding\n\t\t\t\t== (M_AXI_ARVALID ? 0:1)\n\t\t\t\t\t+ (misaligned_response_pending ? 1:0));\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\tend else if (M_AXI_BREADY)\n\tbegin\n\t\t// {{{\n\t\tassert(!misaligned_aw_request);\n\t\tassert(!misaligned_request);\n\t\tassert(!misaligned_response_pending);\n\t\tassert(!pending_err);\n\t\tassert(faxi_awr_nbursts == (M_AXI_AWVALID ? 0:1));\n\t\t// assert(faxil_wr_outstanding  == (M_AXI_WVALID  ? 0:1));\n\t\tassert(faxi_rd_outstanding  == 0);\n\t\tassert(!misaligned_read);\n\t\t// }}}\n\tend else begin\n\t\t// {{{\n\t\tassert(M_AXI_RREADY);\n\t\tassert(!misaligned_aw_request);\n\t\tassert(!misaligned_request);\n\t\tassert(!misaligned_response_pending);\n\t\tassert(!misaligned_read);\n\t\tassert(!pending_err);\n\t\tassert(faxi_awr_nbursts == 0);\n\t\t// assert(faxil_wr_outstanding  == 0);\n\t\tassert(faxi_rd_outstanding  == (M_AXI_ARVALID ? 0:1));\n\t\t// }}}\n\tend\n\t// }}}\n\n\talways @(*)\n\tif (!o_busy)\n\t\t`ASSERT(!r_flushing);\n\n\t// Following any i_stb request, assuming we are idle, immediately\n\t// begin a bus transaction\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_stb && !o_err))\n\t\t&&(!$past(o_busy))&&($past(!i_cpu_reset)))\n\tbegin\n\t\t`ASSERT(o_busy || ($past(w_misalignment_err) && o_err));\n\tend\n\n\talways @(*)\n\t\t`ASSERT(o_busy == (M_AXI_BREADY || M_AXI_RREADY));\n\n\talways @(*)\n\tif (o_busy && !misaligned_request && OPT_LOWPOWER)\n\tbegin\n\t\tassert(next_wdata == 0);\n\t\tassert(next_wstrb == 0);\n\tend\n\n\t// If a transaction ends in an error, send o_err on the",
            "output port.\n\talways @(posedge i_clk)\n\tif (f_past_valid)\n\tbegin\n\t\tif ($past(i_cpu_reset || r_flushing || o_err))\n\t\tbegin\n\t\t\t`ASSERT(!o_err);\n\t\tend else if ($past(M_AXI_BVALID && M_AXI_BRESP[1]))\n\t\tbegin\n\t\t\tif ($past(misaligned_response_pending))\n\t\t\tbegin\n\t\t\t\t`ASSERT((!o_err && pending_err) || r_flushing);\n\t\t\tend else\n\t\t\t\t`ASSERT(o_err);\n\t\tend else if ($past(M_AXI_RVALID && M_AXI_RRESP[1]\n\t\t\t\t|| (M_AXI_RVALID && axlock && M_AXI_RRESP != EXOKAY)))\n\t\tbegin\n\t\t\tif ($past(misaligned_response_pending))\n\t\t\tbegin\n\t\t\t\t`ASSERT((!o_err && pending_err) || r_flushing);\n\t\t\tend else\n\t\t\t\t`ASSERT(o_err);\n\t\tend else if ($past(i_stb && w_misalignment_err))\n\t\tbegin\n\t\t\t`ASSERT(o_err);\n\t\tend else if (!$past(pending_err))\n\t\t\t`ASSERT(!o_err);\n\t\t//else if ($past(misaligned))\n\t\t\t//`ASSERT(o_err);\n\tend\n\n\talways @(*)\n\tif (misaligned_response_pending || misaligned_aw_request\n\t\t\t\t|| misaligned_read || misaligned_request)\n\t\tassert(!axlock);\n\n\talways @(*)\n\tif (o_busy && misaligned_response_pending)\n\t\t`ASSERT(!pending_err);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(!i_cpu_reset))&&($past(i_stb)))\n\tbegin\n\t\t// On a write, assert o_wb_we should be true\n\t\tassert($past(i_op[0] && !o_err && !w_misalignment_err)\n\t\t\t\t== (M_AXI_AWVALID && M_AXI_WVALID));\n\tend\n\n\talways @(*)\n\tif (axlock && M_AXI_BREADY)\n\t\tassert(o_w",
            "reg [3:0] == 4'hf);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// OPT_LOWPOWER / Zero on idle checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (OPT_LOWPOWER)\n\tbegin\n\t\tgenvar\tfb;\n\n\t\talways @(*)\n\t\tif (!M_AXI_AWVALID && !M_AXI_ARVALID)\n\t\t\t`ASSERT(M_AXI_AWADDR == 0);\n\n\t\talways @(*)\n\t\tif (!M_AXI_WVALID)\n\t\tbegin\n\t\t\t`ASSERT(M_AXI_WDATA == 0);\n\t\t\t`ASSERT(M_AXI_WSTRB == 0);\n\n\t\t\t`ASSERT(next_wdata == 0);\n\t\t\t`ASSERT(next_wstrb == 0);\n\t\tend\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !o_valid)\n\t\t\t`ASSERT(o_result == 0);\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && (OPT_ALIGNMENT_ERR || !M_AXI_RREADY\n\t\t\t\t\t|| misaligned_response_pending))\n\t\t\t`ASSERT(last_result == 0);\n\n\t\tfor(fb=0; fb<C_AXI_DATA_WIDTH/8; fb=fb+1)\n\t\tbegin\n\t\t\talways @(*)\n\t\t\tif (S_AXI_ARESETN && !M_AXI_WSTRB[fb])\n\t\t\t\t`ASSERT(M_AXI_WDATA[fb*8 +: 8] == 8'h0);\n\t\tend\n\n\t\talways @(*)\n\t\t\tcover(M_AXI_WVALID && M_AXI_WDATA[31:24] != 8'h00);\n\n\t\t// always @(*)\n\t\t// if (!o_valid)\n\t\t//\t`ASSERT(o_result == 0);\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "wire [3:0]\tcpu_outstanding;",
            "reg f_done;",
            "wire [4:0]\tf_last_",
            "reg , f_addr_",
            "reg ;\n\t(* anyseq *)",
            "reg [4:0]\tf_a",
            "reg ;\n\n\tinitial\tf_done = 1'b0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN || r_flushing || i_cpu_reset)\n\t\tf_done <= 1'b0;\n\telse begin\n\t\tf_done <= (M_AXI_RVALID && !M_AXI_RRESP[1]\n\t\t\t|| M_AXI_BVALID && !M_AXI_BRESP[1]);\n\t\tif (pending_err || misaligned_response_pending)\n\t\t\tf_done <= 0;\n\tend\n\n\tfmem #(\n\t\t// {{{\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_AXI_LOCK(1)\n\t\t// }}}\n\t) fcheck(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK),\n\t\t.i_sys_reset(!S_AXI_ARESETN),\n\t\t.i_cpu_reset(i_cpu_reset),\n\t\t.i_stb(i_stb),\n\t\t.i_pipe_stalled(o_busy),\n\t\t.i_clear_cache(1'b0),\n\t\t.i_lock(i_lock), .i_op(i_op), .i_addr(i_addr),\n\t\t.i_data(i_data), .i_o",
            "reg (i_o",
            "reg ), .i_busy(o_busy),\n\t\t\t.i_a",
            "reg (f_a",
            "reg ),\n\t\t.i_rdbusy(o_rdbusy), .i_valid(o_valid), .i_done(f_done),\n\t\t.i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_result),\n\t\t.f_outstanding(cpu_outstanding),\n\t\t.f_pc(f_pc),\n\t\t.f_gie(f_gie),\n\t\t.f_read_cycle(f_read_cycle),\n\t\t.f_axi_write_cycle(f_exwrite_cycle),\n\t\t.f_last_",
            "reg (f_last_",
            "reg ), .f_addr_",
            "reg (f_addr_",
            "reg )\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (r_flushing)\n\tbegin\n\t\t`ASSERT(cpu_outstanding == 0);\n\tend else\n\t\t`ASSERT(cpu_outstanding == (o_busy ? 1:0)\n\t\t\t+ ((f_done || o_err) ? 1 : 0));\n\n\talways @(*)\n\tif (o_rdbusy && M_AXI_BREADY)\n\tbegin\n\t\tassert(f_exwrite_cycle);\n\t\tassert(axlock);\n\tend else if (M_AXI_RREADY)\n\t\tassert(!f_exwrite_cycle);\n\n\talways @(*)\n\tif (M_AXI_BREADY && (M_AXI_AWLOCK || f_exwrite_cycle || axlock))\n\tbegin\n\t\tassert(!pending_err);\n\t\tassert(!misaligned_response_pending);\n\t\tassert(M_AXI_AWLOCK && f_exwrite_cycle && axlock);\n\t\tif (f_active_lock)\n\t\t\tassert((M_AXI_AWVALID || M_AXI_WVALID) || faxi_ex_state == 2'b11);\n\tend else\n\t\tassert(faxi_ex_state != 2'b11);\n\n\talways @(*)\n\tif (M_AXI_RREADY && !r_flushing)\n\t\tassert(f_last_",
            "reg == o_w",
            "reg );\n\n\talways @(*)\n\tif (f_pc || (axlock && M_AXI_BREADY))\n\tbegin\n\t\tassert(o_w",
            "reg [3:1] == 3'h7);\n\tend else if (o_rdbusy)\n\t\tassert(o_w",
            "reg [3:1] != 3'h7);\n\n\talways @(*)\n\tif (o_busy)\n\t\tassert(o_w",
            "reg [4] == f_gie);\n\n\talways @(*)\n\tif (M_AXI_RREADY)\n\tbegin\n\t\tassert(f_read_cycle || r_flushing);\n\tend else if (M_AXI_BREADY)\n\t\tassert(!f_read_cycle);\n\n\talways @(*)\n\tif (!OPT_LOCK)\n\t\tassert(!axlock);\n\n\talways @(posedge S_AXI_ACLK)\n\tif (S_AXI_ARESETN && $past(S_AXI_ARESETN) && !$past(i_cpu_reset)\n\t\t\t&& $past(M_AXI_BVALID && axlock))\n\tbegin\n\t\tif ($past(M_AXI_BRESP == OKAY))\n\t\tbegin\n\t\t\tassert(o_valid);\n\t\t\tassert(o_w",
            "reg [3:0] == 4'hf);\n\t\t\tassert(o_result == {{(32-AW){1'b0}}, $past(r_pc)});\n\t\tend else if ($past(M_AXI_BRESP == EXOKAY))\n\t\tbegin\n\t\t\tassert(!o_valid);\n\t\t\tassert(!o_err);\n\t\t\tassert(!o_busy);\n\t\t\tassert(!o_rdbusy);\n\t\tend else if ($past(M_AXI_BRESP[1]))\n\t\t\tassert(o_err);\n\tend\n\n\t// ????   Not written yet\n\t//\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg [3:0]\tcvr_writes, cvr_reads;\n\n\tinitial\tcvr_writes = 0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN)\n\t\tcvr_writes <= 0;\n\telse if (M_AXI_BVALID&& !misaligned_response_pending  && !cvr_writes[3])\n\t\tcvr_writes <= cvr_writes + 1;\n\n\tinitial\tcvr_reads = 0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN)\n\t\tcvr_reads <= 0;\n\telse if (M_AXI_RVALID && !misaligned_response_pending && !cvr_reads[3])\n\t\tcvr_reads <= cvr_reads + 1;\n\n\t// Cover a write response\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_BVALID && !M_AXI_BRESP[1]);\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_BVALID &&  M_AXI_BRESP[1]);\n\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_RVALID && !M_AXI_RRESP[1]);\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_RVALID &&  M_AXI_RRESP[1]);\n\n\n\talways @(posedge i_clk)\n\t\tcover(cvr_writes > 3);\n\n\talways @(posedge i_clk)\n\t\tcover(cvr_reads > 3);\n\n\tgenerate if (OPT_LOCK)\n\tbegin : COVER_LOCK\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(axlock);\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(o_valid && $past(axlock && M_AXI_RVALID));\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(!o_valid && !o_err && faxi_ex_state == 2'b10);\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(i_stb && i_op[0] && i_lock && faxi_ex_state == 2'b10);\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(i_stb && i_op[0] && i_lock && faxi_ex_state == 2'b10 && !w_misalignment_err);\n\t\talways @(posedge i_clk)\n\t\tif (S_AXI_ARESETN && $past(S_AXI_ARESETN)\n\t\t\t&& !i_cpu_reset && !$past(i_cpu_reset))\n\t\t\tcover($past(i_stb && i_op[0] && i_lock && faxi_ex_state == 2'b10 && !w_misalignment_err));\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(M_AXI_AWVALID && M_AXI_AWLOCK);\n\t\talways @(posedge i_clk)\n\t\t\tcover(M_AXI_BVALID && axlock);\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(o_valid && $past(axlock && M_AXI_BVALID));\n\n\tend endgenerate\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// \"Careless\" assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (i_stb && i_op[0] && i_lock)\n\tbegin\n\t\tassume(i_addr == f_exlock_addr);\n\t\tassume(faxi_ex_state == 2'b10);\n\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tassert(f_exlock_size == DSZ);\n\t\tend else casez(i_op[2:1])\n\t\t2'b0?: assume(f_exlock_size == 3'b010);\t// Word\n\t\t2'b10: assume(f_exlock_size == 3'b001);\t// Half-word\n\t\t2'b11: assume(f_exlock_size == 3'b000);\t// Byte\n\t\tendcase\n\tend\n\n\talways @(*)\n\tif (faxi_ex_state == 2'b10)\n\tbegin\n\t\tassert(f_exlock_addr  == faxi_exreq_addr);\n\t\tassert(f_exlock_len   == faxi_exreq_len);\n\t\tassert(f_exlock_size  == faxi_exreq_size);\n\t\tassert(f_exlock_burst == faxi_exreq_burst);\n\tend\n\n\talways @(*)\n\tif (i_stb && i_lock)\n\t\tassume(!i_cpu_reset);\n\n\talways @(posedge i_clk)\n\tif ($past(i_cpu_reset))\n\t\tassume((faxi_ex_state == 2'b00) || (faxi_ex_state == 2'b01));\n\t// }}}\n`endif\n// }}}",
            "endmodule // yosys -p 'read -sv axiops.v ; synth_xilinx -flatten -top axiops'\n//\n// Usage (from yosys):\n//\t\t\t(!LOWPOWER)\tLOWPOWER,AW=DW=32,LOCK,!ALGNERR\n//\tCells\t\t 932\t\t1076\n//\t  FDRE,FDSE\t 216\t\t 217\n//\t  LUT1\t\t   6\t\t   4\n//\t  LUT2\t\t  53\t\t  32\n//\t  LUT3\t\t  57\t\t  38\n//\t  LUT4\t\t  54\t\t  76\n//\t  LUT5\t\t  67\t\t  92\n//\t  LUT6\t\t  70\t\t 123\n//\t  MUX7\t\t  25\t\t  37\n//\t  MUX8\t\t   5\t\t   1\n//\tEstimated LCs:\t 248\t\t 329\n//\n//"
        ]
    },
    {
        "file_name": "axilops.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axilops.v",
        "chunks": [
            "logic and yet\n//\tto still support a lot of options.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2020-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype\tnone\n// }}}",
            "module axilops #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=30,",
            "parameter C_AXI_ADDR_WIDTH = ADDRESS_WIDTH,",
            "parameter C_AXI_DATA_WIDTH = 32,\n\t\t//\n\t\t// SWAP_ENDIANNESS\n\t\t// {{{\n\t\t// The ZipCPU was designed to be a big endian machine.  With\n\t\t// no other adjustments, this design will make the ZipCPU\n\t\t// *little* endian, for the simple reason that the AXI bus is\n\t\t// a little endian bus.  However, if SWAP_ENDIANNESS is set,\n\t\t// the bytes within 32-bit words on the AXI bus will be swapped.\n\t\t// This will return the CPU to being a big endian CPU on a\n\t\t// little endian bus.  It will also break any design that\n\t\t// assumes the bus is presented to it in its proper order.\n\t\t// Simple things like counters or interrupt controllers will\n\t\t// therefore cease to work with this option unless they also\n\t\t// swap the endianness of the words they are given.",
            "parameter [0:0]\tSWAP_ENDIANNESS = 1'b0,\n\t\t// }}}\n\t\t// SWAP_WSTRB\n\t\t// {{{\n\t\t// SWAP_WSTRB represents a second attempt to fix the endianness\n\t\t// issue.  It is incompatible with the SWAP_ENDIANNESS option\n\t\t// above.  If SWAP_WSTRB is set, then half words and words will\n\t\t// be placed on the bus in little endian order, but at big\n\t\t// endian addresses.  Words written to the bus will be written\n\t\t// in little endian order.  Halfwords written to the bus at\n\t\t// address 2 will be written to address 0, halfwords written to\n\t\t// address 0 will be written to address 2.  Bytes written to the\n\t\t// but at address 3 will be written to address 0, address 2\n\t\t// will be written to address 1, address 1 to address 2, and\n\t\t// address 3 to address 0.\n\t\t//\n\t\t// This may just be a half baked attempt to solve this problem,\n\t\t// since it will fail if you ever trie to access bytes or\n\t\t// halfwords at other than their intended widths.",
            "parameter [0:0]\tSWAP_WSTRB = 1'b0,\n\t\t// }}}\n\t\t// OPT_SIGN_EXTEND\n\t\t// {{{\n\t\t// Some CPU's want memory accesses to be sign extended upon\n\t\t// return.  The ZipCPU is not one of those CPU's.  However,\n\t\t// since it's fairly easy to do so, we'll implement this",
            "logic // if ever OPT_SIGN_EXTEND is true so you can see how it would\n\t\t// be done if necessary.",
            "parameter [0:0]\tOPT_SIGN_EXTEND = 1'b0,\n\t\t// }}}\n\t\t// OPT_ALIGNMENT_ERR\n\t\t// {{{\n\t\t// If set, OPT_ALIGNMENT_ERR will generate an alignment error\n\t\t// on any attempt to write to or read from an unaligned word.\n\t\t// If not set, unaligned reads (or writes) will be expanded into\n\t\t// pairs so as to still accomplish the action requested.  The\n\t\t// bus does not guarantee protection, however, that these two\n\t\t// writes or two reads will proceed uninterrupted.  Since\n\t\t// unaligned writes and unaligned reads are no longer\n\t\t// guaranteed to be atomic by the AXI bus, it is possible that\n\t\t// any unaligned operations might yield an incoherent result.",
            "parameter [0:0]\t\tOPT_ALIGNMENT_ERR = 1'b1,\n\t\t// }}}\n\t\t// OPT_LOWPOWER\n\t\t// {{{\n\t\t// If set, the design will use extra",
            "logic to guarantee that any\n\t\t// unused",
            "reg isters are kept at zero until they are used.  This\n\t\t// will help to guarantee the design (ideally) has fewer\n\t\t// transitions and therefore uses lower power.",
            "parameter [0:0]\t\tOPT_LOWPOWER = 1'b0,\n\t\t// }}}",
            "localparam AW = C_AXI_ADDR_WIDTH,",
            "localparam DW = C_AXI_DATA_WIDTH,",
            "localparam AXILSB = $clog2(C_AXI_DATA_WIDTH/8)\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,",
            "input ",
            "wire i_cpu_reset,\n\t\t//\n\t\t// CPU interface\n\t\t// {{{",
            "input ",
            "wire i_stb,",
            "input ",
            "wire i_lock,",
            "input ",
            "wire [2:0]\t\t\ti_op,",
            "input ",
            "wire [AW-1:0]\t\ti_addr,",
            "input ",
            "wire [31:0]\t\t\ti_data,",
            "input ",
            "wire [4:0]\t\t\ti_o",
            "reg ,",
            "output ",
            "reg o_busy,",
            "output ",
            "reg o_rdbusy,",
            "output ",
            "reg o_valid,",
            "output ",
            "reg o_err,",
            "output ",
            "reg [4:0]\t\t\to_w",
            "reg ,",
            "output ",
            "reg [31:0]\t\t\to_result,\n\t\t// }}}\n\t\t// AXI-Lite bus interface\n\t\t//\n\t\t// Writes\n\t\t// {{{",
            "output ",
            "reg M_AXI_AWVALID,",
            "input ",
            "wire M_AXI_AWREADY,",
            "output ",
            "reg [AW-1:0]\t\tM_AXI_AWADDR,\n\t\t// verilator coverage_off",
            "output ",
            "wire [2:0]\t\t\tM_AXI_AWPROT,\n\t\t// verilator coverage_on\n\t\t//",
            "output ",
            "reg M_AXI_WVALID,",
            "input ",
            "wire M_AXI_WREADY,",
            "output ",
            "reg [DW-1:0]\t\tM_AXI_WDATA,",
            "output ",
            "reg [DW/8-1:0]\t\tM_AXI_WSTRB,\n\t\t//",
            "input ",
            "wire M_AXI_BVALID,",
            "output ",
            "reg M_AXI_BREADY,",
            "input ",
            "wire [1:0]\t\t\tM_AXI_BRESP,\n\t\t// }}}\n\t\t// Reads\n\t\t// {{{",
            "output ",
            "reg M_AXI_ARVALID,",
            "input ",
            "wire M_AXI_ARREADY,",
            "output ",
            "reg [AW-1:0]\t\tM_AXI_ARADDR,\n\t\t// verilator coverage_off",
            "output ",
            "wire [2:0]\t\t\tM_AXI_ARPROT,\n\t\t// verilator coverage_on\n\t\t//",
            "input ",
            "wire M_AXI_RVALID,",
            "output ",
            "reg M_AXI_RREADY,",
            "input ",
            "wire [DW-1:0]\t\tM_AXI_RDATA,",
            "input ",
            "wire [1:0]\t\t\tM_AXI_RRESP\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "wire i_clk = S_AXI_ACLK;\n\t//",
            "wire i_reset = !S_AXI_ARESETN;",
            "reg w_misaligned, w_misalignment_err;",
            "wire misaligned_request, misaligned_aw_request,\n\t\tmisaligned_response_pending, pending_err, misaligned_read;",
            "reg r_flushing;",
            "reg [AXILSB+1:0]\t\tr_op;",
            "reg [DW-1:0]\t\tnext_wdata;",
            "reg [DW/8-1:0]\t\tnext_wstrb;",
            "reg [DW-1:0]\t\tlast_result;\n\t//",
            "reg [31:0]\t\t\tendian_swapped_wdata;\n\t//",
            "reg [31:0]\t\t\tendian_swapped_result;",
            "reg [2*DW/8-1:0]\t\tshifted_wstrb_word,\n\t\t\t\t\tshifted_wstrb_halfword,\n\t\t\t\t\tshifted_wstrb_byte;",
            "reg [2*DW/8-1:0]\t\tswapped_wstrb_word,\n\t\t\t\t\tswapped_wstrb_halfword,\n\t\t\t\t\tswapped_wstrb_byte;",
            "reg [DW-1:0]\t\taxi_wdata;",
            "reg [DW/8-1:0]\t\taxi_wstrb;",
            "reg [AXILSB-1:0]\t\tswapaddr;",
            "wire [DW-1:0]\t\tendian_swapped_rdata;",
            "reg [31:0]\t\t\tpre_result;",
            "reg [2*DW-1:0]\t\twide_return;\n\n\t// }}}\n\n\t// xVALID, and xREADY\n\t// {{{\n\tinitial\tM_AXI_AWVALID = 1'b0;\n\tinitial\tM_AXI_WVALID = 1'b0;\n\tinitial\tM_AXI_ARVALID = 1'b0;\n\tinitial\tM_AXI_BREADY = 1'b0;\n\tinitial\tM_AXI_RREADY = 1'b0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN)\n\tbegin\n\t\t// {{{\n\t\tM_AXI_AWVALID <= 1'b0;\n\t\tM_AXI_WVALID  <= 1'b0;\n\t\tM_AXI_ARVALID <= 1'b0;\n\t\tM_AXI_BREADY  <= 1'b0;\n\t\tM_AXI_RREADY  <= 1'b0;\n\t\t// }}}\n\tend else if (M_AXI_BREADY || M_AXI_RREADY)\n\tbegin // Something is outstanding\n\t\t// {{{\n\t\tif (M_AXI_AWREADY)\n\t\t\tM_AXI_AWVALID <= M_AXI_AWVALID && misaligned_aw_request;\n\t\tif (M_AXI_WREADY)\n\t\t\tM_AXI_WVALID  <= M_AXI_WVALID && misaligned_request;\n\t\tif (M_AXI_ARREADY)\n\t\t\tM_AXI_ARVALID <= M_AXI_ARVALID && misaligned_request;\n\n\t\tif ((M_AXI_BVALID || M_AXI_RVALID) && !misaligned_response_pending)\n\t\tbegin\n\t\t\tM_AXI_BREADY <= 1'b0;\n\t\t\tM_AXI_RREADY <= 1'b0;\n\t\tend\n\t\t// }}}\n\tend else begin // New memory operation\n\t\t// {{{\n\t\t// Initiate a request\n\t\tM_AXI_AWVALID <=  i_op[0];\t// Write request\n\t\tM_AXI_WVALID  <=  i_op[0];\t// Write request\n\t\tM_AXI_ARVALID <= !i_op[0];\t// Read request\n\n\t\t// Set BREADY or RREADY to accept the response.  These will\n\t\t// remain ready until the response is returned.\n\t\tM_AXI_BREADY  <=  i_op[0];\n\t\tM_AXI_RREADY  <= !i_op[0];\n\n\t\tif (i_cpu_reset || o_err || !i_stb || w_misalignment_err)\n\t\tbegin\n\t\t\tM_AXI_AWVALID <= 0;\n\t\t\tM_AXI_WVALID  <= 0;\n\t\t\tM_AXI_ARVALID <= 0;\n\n\t\t\tM_AXI_BREADY <= 0;\n\t\t\tM_AXI_RREADY <= 0;\n\t\tend\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// r_flushing\n\t// {{{\n\tinitial\tr_flushing = 1'b0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN)\n\t\t// If everything is reset, then we don't need to worry about\n\t\t// or wait for any pending returns--they'll be canceled by the\n\t\t// global reset.\n\t\tr_flushing <= 1'b0;\n\telse if (M_AXI_BREADY || M_AXI_RREADY)\n\tbegin\n\t\tif (i_cpu_reset)\n\t\t\t// If only the CPU is reset, however, we have a problem.\n\t\t\t// The bus hasn't been reset, and so it is still active.\n\t\t\t// We can't respond to any new requests from the CPU\n\t\t\t// until we flush any transactions that are currently\n\t\t\t// active.\n\t\t\tr_flushing <= 1'b1;\n\t\tif (M_AXI_BVALID || M_AXI_RVALID)\n\t\t\t// A request just came back, therefore we can clear\n\t\t\t// r_flushing\n\t\t\tr_flushing <= 1'b0;\n\t\tif (misaligned_response_pending)\n\t\t\t// ... unless we're in the middle of a misaligned\n\t\t\t// request.  In that case, there will be a second\n\t\t\t// return that we still need to wait for.  This request,\n\t\t\t// though, will clear misaligned_response_pending.\n\t\t\tr_flushing <= r_flushing || i_cpu_reset;\n\tend else\n\t\t// If nothing is active, we don't care about the CPU reset.\n\t\t// Flushing just stays at zero.\n\t\tr_flushing <= 1'b0;\n\t// }}}\n\n\t// M_AXI_AxADDR\n\t// {{{\n\tinitial\tM_AXI_AWADDR = 0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN && OPT_LOWPOWER)\n\t\tM_AXI_AWADDR <= 0;\n\telse if (!M_AXI_BREADY && !M_AXI_RREADY)\n\tbegin // Initial address\n\t\t// {{{\n\t\tM_AXI_AWADDR <= i_addr;\n\n\t\tif (OPT_LOWPOWER && (i_cpu_reset || o_err || !i_stb || w_misalignment_err))\n\t\t\tM_AXI_AWADDR <= 0;\n\n\t\tif (SWAP_ENDIANNESS || SWAP_WSTRB)\n\t\tbegin\n\t\t\t// When adjusting endianness, reads (or writes) are\n\t\t\t// always full words.  This is important since the\n\t\t\t// the bytes at issues may (or may not) be in their\n\t\t\t// expected locations\n\t\t\tif (OPT_ALIGNMENT_ERR)\n\t\t\t\tM_AXI_AWADDR[AXILSB-1:0] <= 0;\n\t\t\telse\n\t\t\t\tM_AXI_AWADDR[1:0] <= 0;\n\t\tend\n\t\t// }}}\n\tend else if ((M_AXI_AWVALID && M_AXI_AWREADY)\n\t\t\t||(M_AXI_ARVALID && M_AXI_ARREADY))\n\tbegin // Subsequent addresses\n\t\t// {{{\n\t\tM_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:AXILSB]\n\t\t\t<= M_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:AXILSB] + 1;\n\n\t\tM_AXI_AWADDR[AXILSB-1:0] <= 0;\n\n\t\tif (OPT_LOWPOWER && ((M_AXI_RREADY && !misaligned_request)\n\t\t\t|| (M_AXI_BREADY && !misaligned_aw_request)))\n\t\t\tM_AXI_AWADDR <= 0;\n\t\t// }}}\n\tend\n\n\talways @(*)\n\t\tM_AXI_ARADDR = M_AXI_AWADDR;\n\t// }}}\n\n\t// AxPROT\n\t// {{{",
            "localparam [2:0]\tAXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS = 3'h0;",
            "localparam [2:0]\tOPT_PROT=AXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS;\n\n\tassign\tM_AXI_AWPROT  = OPT_PROT;\n\tassign\tM_AXI_ARPROT  = OPT_PROT;\n\t// }}}\n\n\t// shifted_wstrb_*\n\t// {{{\n\tgenerate if (SWAP_WSTRB)\n\tbegin : BIG_ENDIAN_WSTRB\n\t\talways @(*)\n\t\t\tshifted_wstrb_word = { 4'b1111, {(2*DW/8-4){1'b0}} }\n\t\t\t\t\t\t>> i_addr[AXILSB-1:0];\n\n\t\talways @(*)\n\t\t\tshifted_wstrb_halfword = { 2'b11, {(2*DW/8-2){1'b0}} }\n\t\t\t\t\t\t>> i_addr[AXILSB-1:0];\n\n\t\talways @(*)\n\t\t\tshifted_wstrb_byte = { 1'b1, {(2*DW/8-1){1'b0}} }\n\t\t\t\t\t\t>> i_addr[AXILSB-1:0];\n\tend else begin : NORMAL_SHIFTED_WSTRB\n\t\talways @(*)\n\t\tshifted_wstrb_word = { {(2*DW/8-4){1'b0}},\n\t\t\t\t\t\t4'b1111} << i_addr[AXILSB-1:0];\n\n\t\talways @(*)\n\t\tshifted_wstrb_halfword = { {(2*DW/8-4){1'b0}},\n\t\t\t\t\t\t4'b0011} << i_addr[AXILSB-1:0];\n\n\t\talways @(*)\n\t\tshifted_wstrb_byte = { {(2*DW/8-4){1'b0}},\n\t\t\t\t\t\t4'b0001} << i_addr[AXILSB-1:0];\n\tend endgenerate\n\t// }}}\n\n\t// Swapping WSTRB bits\n\t// {{{\n\tgenerate if (SWAP_ENDIANNESS)\n\tbegin : SWAPPING_ENDIANNESS\n\t\t// {{{\n\t\tgenvar\tgw, gb;\n\n\t\tfor(gw=0; gw<2*DW/32; gw=gw+1)\n\t\tbegin : FOREACH_32B_WORD\n\t\tfor(gb=0; gb<32/8; gb=gb+1)\n\t\tbegin : FOREACH_BYTE\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tswapped_wstrb_word[gw*4+gb]\n\t\t\t\t\t= shifted_wstrb_word[gw*4+(3-gb)];\n\t\t\tswapped_wstrb_halfword[gw*4+gb]\n\t\t\t\t\t= shifted_wstrb_halfword[gw*4+(3-gb)];\n\t\t\tswapped_wstrb_byte[gw*4+gb]\n\t\t\t\t\t= shifted_wstrb_byte[gw*4+(3-gb)];\n\t\tend end end\n\t\t// }}}\n\tend else begin : KEEP_WSTRB\n\t\t// {{{\n\n\t\talways @(*)\n\t\t\tswapped_wstrb_word = shifted_wstrb_word;\n\n\t\talways @(*)\n\t\t\tswapped_wstrb_halfword = shifted_wstrb_halfword;\n\n\t\talways @(*)\n\t\t\tswapped_wstrb_byte = shifted_wstrb_byte;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// wdata, wstrb\n\t// {{{\n\talways @(*)\n\t\tswapaddr = i_addr[AXILSB-1:0];\n\n\tinitial\taxi_wdata = 0;\n\tinitial\taxi_wstrb = 0;\n\tinitial\tnext_wdata  = 0;\n\tinitial\tnext_wstrb  = 0;\n\talways @(posedge i_clk)\n\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\tbegin\n\t\t// {{{\n\t\taxi_wdata <= 0;\n\t\taxi_wstrb <= 0;\n\n\t\tnext_wdata  <= 0;\n\t\tnext_wstrb  <= 0;\n\n\t\tr_op <= 0;\n\t\t// }}}\n\tend else if (i_stb)\n\tbegin\n\t\t// {{{\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b10: { axi_wdata, next_wdata }\n\t\t\t\t<= { i_data[15:0], {(2*C_AXI_DATA_WIDTH-16){1'b0}} }\n\t\t\t\t\t>> (8*swapaddr);\n\t\t\t2'b11: { axi_wdata, next_wdata }\n\t\t\t\t<= { i_data[7:0], {(2*C_AXI_DATA_WIDTH-8){1'b0}} }\n\t\t\t\t\t>> (8*swapaddr);\n\t\t\tdefault: { axi_wdata, next_wdata }\n\t\t\t\t<= { i_data, {(2*C_AXI_DATA_WIDTH-32){1'b0}} }\n\t\t\t\t\t>> (8*swapaddr);\n\t\t\tendcase\n\t\tend else begin\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b10: { next_wdata, axi_wdata }\n\t\t\t\t<= { {(2*C_AXI_DATA_WIDTH-16){1'b0}},\n\t\t\t\ti_data[15:0] } << (8*swapaddr);\n\t\t\t2'b11: { next_wdata, axi_wdata }\n\t\t\t\t<= { {(2*C_AXI_DATA_WIDTH-8){1'b0}},\n\t\t\t\ti_data[7:0] } << (8*swapaddr);\n\t\t\tdefault: { next_wdata, axi_wdata }\n\t\t\t\t<= { {(2*C_AXI_DATA_WIDTH-32){1'b0}},\n\t\t\t\ti_data } << (8*swapaddr);\n\t\t\tendcase\n\t\tend\n\n\t\t// next_wstrb, axi_wstrb\n\t\t// {{{\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b0?: { axi_wstrb, next_wstrb } <= swapped_wstrb_word;\n\t\t\t2'b10: { axi_wstrb, next_wstrb } <= swapped_wstrb_halfword;\n\t\t\t2'b11: { axi_wstrb, next_wstrb } <= swapped_wstrb_byte;\n\t\t\tendcase\n\t\tend else begin\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b0?: { next_wstrb, axi_wstrb } <= swapped_wstrb_word;\n\t\t\t2'b10: { next_wstrb, axi_wstrb } <= swapped_wstrb_halfword;\n\t\t\t2'b11: { next_wstrb, axi_wstrb } <= swapped_wstrb_byte;\n\t\t\tendcase\n\t\tend\n\t\t// }}}\n\n\t\tr_op <= { i_op[2:1] , i_addr[AXILSB-1:0] };\n\n\t\t// On a read set everything to zero but only if OPT_LOWPOWER\n\t\t// is set\n\t\t// {{{\n\t\tif (OPT_LOWPOWER && !i_op[0])\n\t\t\t{ next_wstrb, next_wdata, axi_wstrb, axi_wdata } <= 0;\n\n\t\tif (OPT_ALIGNMENT_ERR)\n\t\t\t{ next_wstrb, next_wdata } <= 0;\n\t\tif (OPT_LOWPOWER)\n\t\tbegin\n\t\t\tif (w_misalignment_err)\n\t\t\t\t{ axi_wdata, axi_wstrb, r_op } <= 0;\n\t\t\tif (o_err || i_cpu_reset)\n\t\t\t\t{ next_wdata, next_wstrb,\n\t\t\t\t\taxi_wdata, axi_wstrb, r_op } <= 0;\n\t\tend\n\t\t// }}}\n\t\t// }}}\n\tend else if ((misaligned_request || !OPT_LOWPOWER) && M_AXI_WREADY)\n\tbegin\n\t\t// {{{\n\t\taxi_wdata <= next_wdata;\n\t\taxi_wstrb <= next_wstrb;\n\t\tif (OPT_LOWPOWER)\n\t\t\t{ next_wdata, next_wstrb } <= 0;\n\t\t// }}}\n\tend else if (OPT_LOWPOWER && M_AXI_WREADY)\n\tbegin\n\t\t// {{{\n\t\taxi_wdata <= 0;\n\t\taxi_wstrb <= 0;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// M_AXI_WDATA, M_AXI_WSTRB\n\t// {{{\n\tgenerate if (SWAP_ENDIANNESS)\n\tbegin : SWAP_WRITE_DATA_STRB\n\t\t// {{{\n\t\tgenvar\tgw, gb;\n\n\t\tfor(gw=0; gw<C_AXI_DATA_WIDTH/32; gw=gw+1)\n\t\tfor(gb=0; gb<32/8; gb=gb+1)\n\t\talways @(*)\n\t\tbegin\n\t\t\tM_AXI_WDATA[32*gw + 8*gb +: 8] = axi_wdata[32*gw+8*(3-gb) +: 8];\n\t\t\tM_AXI_WSTRB[4*gw + gb] = axi_wstrb[4*gw+(3-gb)];\n\t\tend\n\t\t// }}}\n\tend else begin : KEEP_WRITE_DATA_STRB\n\t\t// {{{\n\t\talways @(*)\n\t\t\t{ M_AXI_WSTRB, M_AXI_WDATA } = { axi_wstrb, axi_wdata };\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// w_misaligned\n\t// {{{\n\talways @(*)\n\tcasez(i_op[2:1])\n\t// Full word\n\t2'b0?: w_misaligned = ((i_addr[AXILSB-1:0]+3) >= (1<<AXILSB));\n\t// Half word\n\t2'b10: w_misaligned = ((i_addr[AXILSB-1:0]+1) >= (1<<AXILSB));\n\t// Bytes are always aligned\n\t2'b11: w_misaligned = 1'b0;\n\tendcase\n\t// }}}\n\n\t// w_misalignment_err\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tw_misalignment_err = OPT_ALIGNMENT_ERR && w_misaligned;\n\tend\n\t// }}}\n\n\t// misaligned_[aw_|]request, pending_err, misaligned_response_pending\n\t// {{{\n\tgenerate if (OPT_ALIGNMENT_ERR)\n\tbegin : GEN_ALIGNMENT_ERR\n\t\t// {{{\n\t\tassign\tmisaligned_request = 1'b0;\n\n\t\tassign\tmisaligned_aw_request = 1'b0;\n\t\tassign\tmisaligned_response_pending = 1'b0;\n\t\tassign\tmisaligned_read = 1'b0;\n\t\tassign\tpending_err = 1'b0;\n\t\t// }}}\n\tend else begin : GEN_REALIGNMENT\n\t\t// {{{",
            "reg r_misaligned_request, r_misaligned_aw_request,\n\t\t\tr_misaligned_response_pending, r_misaligned_read,\n\t\t\tr_pending_err;\n\n\t\t// misaligned_request\n\t\t// {{{\n\t\tinitial\tr_misaligned_request = 0;\n\t\talways @(posedge i_clk)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_misaligned_request <= 0;\n\t\telse if (i_stb && !o_err && !i_cpu_reset)\n\t\t\tr_misaligned_request <= w_misaligned\n\t\t\t\t\t\t&& !w_misalignment_err;\n\t\telse if ((M_AXI_WVALID && M_AXI_WREADY)\n\t\t\t\t\t|| (M_AXI_ARVALID && M_AXI_ARREADY))\n\t\t\tr_misaligned_request <= 1'b0;\n\n\t\tassign\tmisaligned_request = r_misaligned_request;\n\t\t// }}}\n\n\t\t// misaligned_aw_request\n\t\t// {{{\n\t\tinitial\tr_misaligned_aw_request = 0;\n\t\talways @(posedge i_clk)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_misaligned_aw_request <= 0;\n\t\telse if (i_stb && !o_err && !i_cpu_reset)\n\t\t\tr_misaligned_aw_request <= w_misaligned && i_op[0]\n\t\t\t\t\t&& !w_misalignment_err;\n\t\telse if (M_AXI_AWREADY)\n\t\t\tr_misaligned_aw_request <= 1'b0;\n\n\t\tassign\tmisaligned_aw_request = r_misaligned_aw_request;\n\t\t// }}}\n\n\t\t// misaligned_response_pending\n\t\t// {{{\n\t\tinitial\tr_misaligned_response_pending = 0;\n\t\talways @(posedge i_clk)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_misaligned_response_pending <= 0;\n\t\telse if (i_stb && !o_err && !i_cpu_reset)\n\t\t\tr_misaligned_response_pending <= w_misaligned\n\t\t\t\t\t\t&& !w_misalignment_err;\n\t\telse if (M_AXI_BVALID || M_AXI_RVALID)\n\t\t\tr_misaligned_response_pending <= 1'b0;\n\n\t\tassign\tmisaligned_response_pending\n\t\t\t\t\t= r_misaligned_response_pending;\n\t\t// }}}\n\n\t\t// misaligned_read\n\t\t// {{{\n\t\tinitial\tr_misaligned_read = 0;\n\t\talways @(posedge i_clk)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_misaligned_read <= 0;\n\t\telse if (i_stb && !o_err && !i_cpu_reset)\n\t\t\tr_misaligned_read <= w_misaligned && !i_op[0]\n\t\t\t\t\t\t&& !w_misalignment_err;\n\t\telse if (M_AXI_RVALID)\n\t\t\tr_misaligned_read <= (misaligned_response_pending);\n\n\t\tassign\tmisaligned_read = r_misaligned_read;\n\t\t// }}}\n\n\t\t// pending_err\n\t\t// {{{\n\t\tinitial\tr_pending_err = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_cpu_reset || (!M_AXI_BREADY && !M_AXI_RREADY)\n\t\t\t\t|| r_flushing)\n\t\t\tr_pending_err <= 1'b0;\n\t\telse if ((M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t\t|| (M_AXI_RVALID && M_AXI_RRESP[1]))\n\t\t\tr_pending_err <= 1'b1;\n\n\t\tassign\tpending_err = r_pending_err;\n\t\t// }}}\n\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// o_valid\n\t// {{{\n\tinitial\to_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || r_flushing)\n\t\to_valid <= 1'b0;\n\telse\n\t\to_valid <= M_AXI_RVALID && !M_AXI_RRESP[1] && !pending_err\n\t\t\t\t&& !misaligned_response_pending;\n\t// }}}\n\n\t// o_err\n\t// {{{\n\tinitial\to_err = 1'b0;\n\talways @(posedge i_clk)\n\tif (r_flushing || i_cpu_reset || o_err)\n\t\to_err <= 1'b0;\n\telse if (i_stb && w_misalignment_err)\n\t\to_err <= 1'b1;\n\telse if ((M_AXI_BVALID || M_AXI_RVALID) && !misaligned_response_pending)\n\t\to_err <= (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t|| (M_AXI_RVALID && M_AXI_RRESP[1])\n\t\t\t|| pending_err;\n\telse\n\t\to_err <= 1'b0;\n\t// }}}\n\n\t// o_busy, o_rdbusy\n\t// {{{\n\talways @(*)\n\tbegin\n\t\to_busy   = M_AXI_BREADY || M_AXI_RREADY;\n\t\to_rdbusy = M_AXI_RREADY && !r_flushing;\n\tend\n\t// }}}\n\n\t// o_w",
            "reg // {{{\n\talways @(posedge i_clk)\n\tif (OPT_LOWPOWER && (!S_AXI_ARESETN || i_cpu_reset || o_err || (i_stb && w_misalignment_err)))\n\t\to_w",
            "reg <= 0;\n\telse if (i_stb && (!OPT_LOWPOWER || !i_op[0]))\n\t\to_w",
            "reg <= i_o",
            "reg ;\n\telse if (OPT_LOWPOWER && (o_valid || o_err))\n\t\to_w",
            "reg <= 0;\n\t// }}}\n\n\t// endian_swapped_rdata\n\t// {{{\n\tgenerate if (SWAP_ENDIANNESS)\n\tbegin : SWAP_RDATA_ENDIANNESS\n\t\tgenvar\tgw, gb;\n\n\t\tfor(gw=0; gw<C_AXI_DATA_WIDTH/32; gw=gw+1)\n\t\tfor(gb=0; gb<32/8; gb=gb+1)\n\t\t\tassign\tendian_swapped_rdata[gw*32+gb*8 +: 8]\n\t\t\t\t\t= M_AXI_RDATA[gw*32+(3-gb)*8 +: 8];\n\tend else begin : KEEP_RDATA\n\t\tassign\tendian_swapped_rdata = M_AXI_RDATA;\n\tend endgenerate\n\t// }}}\n\n\t// pre_result\n\t// {{{\n\t// The purpose of the pre-result is to guarantee that the synthesis\n\t// tool knows we want a shift of the full 2*DW width.\n\talways @(*)\n\tbegin\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tif (misaligned_read && !OPT_ALIGNMENT_ERR)\n\t\t\t\twide_return={ last_result, endian_swapped_rdata }\n\t\t\t\t\t\t<< (8*r_op[AXILSB-1:0]);\n\t\t\telse\n\t\t\t\twide_return = { endian_swapped_rdata, {(DW){1'b0}} }\n\t\t\t\t\t\t<< (8*r_op[AXILSB-1:0]);\n\n\t\tend else begin\n\t\t\tif (misaligned_read && !OPT_ALIGNMENT_ERR)\n\t\t\t\twide_return={ endian_swapped_rdata, last_result }\n\t\t\t\t\t\t>> (8*r_op[AXILSB-1:0]);\n\t\t\telse\n\t\t\t\twide_return = { {(DW){1'b0}}, endian_swapped_rdata }\n\t\t\t\t\t\t>> (8*r_op[AXILSB-1:0]);\n\t\tend\n\n\t\tif (OPT_LOWPOWER && (!M_AXI_RVALID || M_AXI_RRESP[1]))\n\t\t\twide_return = 0;\n\tend\n\n\talways @(*)\n\tbegin\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tpre_result = 0;\n\t\t\tcasez(r_op[AXILSB +: 2])\n\t\t\t2'b10: pre_result[15:0] = wide_return[(2*DW)-1:(2*DW)-16];\n\t\t\t2'b11: pre_result[7:0] = wide_return[(2*DW)-1:(2*DW)-8];\n\t\t\tdefault: pre_result[31:0] = wide_return[(2*DW-1):(2*DW-32)];\n\t\t\tendcase\n\n\t\tend else\n\t\t\tpre_result = wide_return[31:0];\n\tend\n\n\t// }}}\n\t// last_result, o_result\n\t// {{{\n\talways @(posedge i_clk)\n\tif (OPT_LOWPOWER &&(!M_AXI_RREADY\n\t\t\t|| !S_AXI_ARESETN || r_flushing || i_cpu_reset))\n\t\t{ last_result, o_result } <= 0;\n\telse begin\n\t\t// {{{\n\t\tif (OPT_LOWPOWER)\n\t\t\to_result <= 0;\n\n\t\tif (M_AXI_RVALID)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tif (OPT_LOWPOWER && (M_AXI_RRESP[1] || !misaligned_response_pending))\n\t\t\t\tlast_result <= 0;\n\t\t\telse\n\t\t\t\tlast_result <= endian_swapped_rdata;\n\n\t\t\to_result <= pre_result[31:0];\n\n\t\t\tif (OPT_SIGN_EXTEND)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\t// verilator coverage_off\n\t\t\t\t// Optionally sign extend the return result.\n\t\t\t\t//   ... would violate ZipCPU ISA\n\t\t\t\tcasez(r_op[AXILSB +: 2])\n\t\t\t\t2'b10: o_result[31:16] <= {(16){pre_result[15]}};\n\t\t\t\t2'b11: o_result[31: 8] <= {(24){pre_result[7]}};\n\t\t\t\tdefault: begin end\n\t\t\t\tendcase\n\t\t\t\t// verilator coverage_on\n\t\t\t\t// }}}\n\t\t\tend else begin\n\t\t\t\t// Fill unused return bits with zeros\n\t\t\t\tcasez(r_op[AXILSB +: 2])\n\t\t\t\t2'b10: o_result[31:16] <= 0;\n\t\t\t\t2'b11: o_result[31: 8] <= 0;\n\t\t\t\tdefault: begin end\n\t\t\t\tendcase\n\t\t\tend\n\n\t\t\tif (OPT_LOWPOWER && M_AXI_RRESP[1])\n\t\t\t\to_result <= 0;\n\t\t\t// }}}\n\t\tend\n\n\t\tif (OPT_ALIGNMENT_ERR)\n\t\t\tlast_result <= 0;\n\n\t\tif (OPT_LOWPOWER && (pending_err || misaligned_response_pending))\n\t\t\to_result <= 0;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, i_lock, M_AXI_RRESP[0], M_AXI_BRESP[0] };\n\n\tgenerate if (SWAP_WSTRB)\n\tbegin : GEN_UNUSED_SWAP",
            "wire wide_unused;\n\n\t\tif (SWAP_WSTRB)\n\t\tbegin : UNUSED_SWAP_WSTRB\n\t\t\tassign\twide_unused = &{ 1'b0,\n\t\t\t\t\twide_return[2*DW-32-1:0] };\n\t\tend else begin : UNUSED_NO_SWAP\n\t\t\tassign\twide_unused = &{ 1'b0, wide_return[2*DW-1:32] };\n\t\tend\n\tend endgenerate\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Local declarations\n\t// {{{\n`define\tASSERT\tassert\n`ifdef\tAXILOPS\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "localparam F_LGDEPTH = 2;",
            "reg f_misaligned;",
            "wire [F_LGDEPTH-1:0]\tfaxil_rd_outstanding, faxil_wr_outstanding,\n\t\t\t\tfaxil_awr_outstanding;",
            "wire f_pc, f_gie, f_read_cycle;",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid = 1'b1;\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(!S_AXI_ARESETN);\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus property checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tfaxil_master #(\n\t\t// {{{\n\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),\n\t\t.F_OPT_ASSUME_RESET(1'b1),\n\t\t.F_LGDEPTH(F_LGDEPTH)\n\t\t// }}}\n\t) faxil(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN),\n\t\t//\n\t\t.i_axi_awvalid(M_AXI_AWVALID),\n\t\t.i_axi_awready(M_AXI_AWREADY),\n\t\t.i_axi_awaddr( M_AXI_AWADDR),\n\t\t.i_axi_awprot( M_AXI_AWPROT),\n\t\t//\n\t\t.i_axi_wvalid(M_AXI_WVALID),\n\t\t.i_axi_wready(M_AXI_WREADY),\n\t\t.i_axi_wdata( M_AXI_WDATA),\n\t\t.i_axi_wstrb( M_AXI_WSTRB),\n\t\t//\n\t\t.i_axi_bvalid(M_AXI_BVALID),\n\t\t.i_axi_bready(M_AXI_BREADY),\n\t\t.i_axi_bresp( M_AXI_BRESP),\n\t\t//\n\t\t.i_axi_arvalid(M_AXI_ARVALID),\n\t\t.i_axi_arready(M_AXI_ARREADY),\n\t\t.i_axi_araddr( M_AXI_ARADDR),\n\t\t.i_axi_arprot( M_AXI_ARPROT),\n\t\t//\n\t\t.i_axi_rvalid(M_AXI_RVALID),\n\t\t.i_axi_rready(M_AXI_RREADY),\n\t\t.i_axi_rdata( M_AXI_RDATA),\n\t\t.i_axi_rresp( M_AXI_RRESP),\n\t\t//\n\t\t.f_axi_rd_outstanding(faxil_rd_outstanding),\n\t\t.f_axi_wr_outstanding(faxil_wr_outstanding),\n\t\t.f_axi_awr_outstanding(faxil_awr_outstanding)\n\t\t// }}}\n\t);\n\n\n\talways @(*)\n\tbegin\n\t\tif (misaligned_request)\n\t\t\t`ASSERT(M_AXI_WVALID || M_AXI_ARVALID);\n\t\tif (misaligned_aw_request)\n\t\t\t`ASSERT(M_AXI_AWVALID);\n\t\tif (!misaligned_response_pending)\n\t\tbegin\n\t\t\t`ASSERT(faxil_awr_outstanding <= (M_AXI_AWVALID ? 0:1));\n\t\t\t`ASSERT(faxil_wr_outstanding  <= (M_AXI_WVALID ? 0:1));\n\t\t\t`ASSERT(faxil_rd_outstanding  <= (M_AXI_ARVALID ? 0:1));\n\n\t\t\t`ASSERT(!misaligned_request);\n\t\t\t`ASSERT(!misaligned_aw_request);\n\t\tend else if (M_AXI_RREADY)\n\t\t\t`ASSERT(misaligned_read);\n\n\t\tif (!M_AXI_RREADY)\n\t\tbegin\n\t\t\t`ASSERT(!M_AXI_ARVALID);\n\t\t\t`ASSERT(faxil_rd_outstanding == 0);\n\t\t\t// `ASSERT(misaligned_read == 1'b0);\n\t\tend else begin\n\t\t\tif (misaligned_request)\n\t\t\t\t`ASSERT(faxil_rd_outstanding == 0);\n\t\t\t`ASSERT(faxil_rd_outstanding <= 1 + (misaligned_read ? 1:0));\n\t\tend\n\n\t\tif (!M_AXI_BREADY)\n\t\tbegin\n\t\t\t`ASSERT(!M_AXI_AWVALID);\n\t\t\t`ASSERT(!M_AXI_WVALID);\n\t\t\t`ASSERT(faxil_awr_outstanding == 0);\n\t\t\t`ASSERT(faxil_wr_outstanding  == 0);\n\t\tend else begin\n\t\t\tif (misaligned_request)\n\t\t\t\t`ASSERT(faxil_wr_outstanding == 0);\n\t\t\tif (misaligned_aw_request)\n\t\t\t\t`ASSERT(faxil_awr_outstanding == 0);\n\t\t\t`ASSERT(faxil_awr_outstanding <= 2);\n\t\t\t`ASSERT(faxil_wr_outstanding <= 2);\n\n\t\t\tcase({misaligned_request,\n\t\t\t\t\tmisaligned_aw_request,\n\t\t\t\t\tmisaligned_response_pending})\n\t\t\t3'b000: begin\n\t\t\t\t`ASSERT(faxil_awr_outstanding<= (M_AXI_BREADY ? 1:0));\n\t\t\t\t`ASSERT(faxil_wr_outstanding <= (M_AXI_BREADY ? 1:0));\n\t\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\t`ASSERT(faxil_awr_outstanding<= 1 + (M_AXI_AWVALID ? 0:1));\n\t\t\t\t`ASSERT(faxil_wr_outstanding <= 1 + (M_AXI_WVALID ? 0:1));\n\t\t\t\tend\n\t\t\t3'b010: `ASSERT(0);\n\t\t\t3'b011: begin\n\t\t\t\t`ASSERT(faxil_wr_outstanding<= 1 + (M_AXI_WVALID ? 0:1));\n\t\t\t\t`ASSERT(faxil_awr_outstanding == 0);\n\t\t\t\t`ASSERT(M_AXI_AWVALID);\n\t\t\t\tend\n\t\t\t3'b100: `ASSERT(0);\n\t\t\t3'b101: begin\n\t\t\t\t`ASSERT(faxil_awr_outstanding<= 1 + (M_AXI_AWVALID ? 0:1));\n\t\t\t\t`ASSERT(faxil_wr_outstanding == 0);\n\t\t\t\t`ASSERT(M_AXI_WVALID);\n\t\t\t\tend\n\t\t\t3'b110: `ASSERT(0);\n\t\t\t3'b111: begin\n\t\t\t\t`ASSERT(faxil_awr_outstanding == 0);\n\t\t\t\t`ASSERT(faxil_wr_outstanding == 0);\n\t\t\t\t`ASSERT(M_AXI_AWVALID);\n\t\t\t\t`ASSERT(M_AXI_WVALID);\n\t\t\t\tend\n\t\t\tdefault: begin end\n\t\t\tendcase\n\t\tend\n\n\n\t\t// Rule: Only one of the two xREADY's may be valid, never both\n\t\t`ASSERT(!M_AXI_BREADY || !M_AXI_RREADY);\n\tend\n\n\t// f_misaligned\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tf_misaligned = 0;\n\t\tcase(r_op[AXILSB +: 2])\n\t\t2'b01: f_misaligned = ((r_op[AXILSB-1:0] + 3) >= (1<<AXILSB));\n\t\t2'b10: f_misaligned = ((r_op[AXILSB-1:0] + 1) >= (1<<AXILSB));\n\t\tdefault: f_misaligned = 0;\n\t\tendcase\n\n\t\tif (!M_AXI_BREADY && !M_AXI_RREADY)\n\t\t\tf_misaligned = 0;\n\tend\n\t// }}}\n\n\talways @(*)\n\tif (!M_AXI_RREADY && !M_AXI_BREADY)\n\tbegin\n\t\t// {{{\n\t\tassert(!misaligned_aw_request);\n\t\tassert(!misaligned_request);\n\t\tassert(!misaligned_response_pending);\n\t\tassert(faxil_awr_outstanding == 0);\n\t\tassert(faxil_wr_outstanding  == 0);\n\t\tassert(faxil_rd_outstanding  == 0);\n\t\t// }}}\n\tend else if (f_misaligned)\n\tbegin\n\t\t// {{{\n\t\tassert(!OPT_ALIGNMENT_ERR);\n\n\t\tif (misaligned_aw_request || misaligned_request)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tif (misaligned_aw_request)\n\t\t\tbegin\n\t\t\t\tassert(faxil_awr_outstanding == 0);\n\t\t\tend else if (M_AXI_BREADY)\n\t\t\tbegin\n\t\t\t\tassert(faxil_awr_outstanding\n\t\t\t\t\t== (M_AXI_AWVALID ? 0:1)\n\t\t\t\t\t\t+ (misaligned_response_pending ? 1:0));\n\t\t\tend else\n\t\t\t\tassert(faxil_awr_outstanding == 0);\n\n\t\t\tif (misaligned_request && M_AXI_BREADY)\n\t\t\tbegin\n\t\t\t\tassert(faxil_wr_outstanding  == 0);\n\t\t\t\tassert(faxil_rd_outstanding == 0);\n\t\t\tend else if (M_AXI_RREADY)\n\t\t\tbegin\n\t\t\t\tassert(faxil_rd_outstanding\n\t\t\t\t\t== (M_AXI_ARVALID ? 0:1)\n\t\t\t\t\t\t+ (!misaligned_request && misaligned_response_pending ? 1:0));\n\t\t\t\tassert(faxil_wr_outstanding == 0);\n\t\t\tend else begin\n\t\t\t\tassert(faxil_wr_outstanding\n\t\t\t\t\t== (M_AXI_WVALID ? 0:1)\n\t\t\t\t\t\t+ (misaligned_response_pending ? 1:0));\n\t\t\t\tassert(faxil_rd_outstanding == 0);\n\t\t\tend\n\t\t\t// }}}\n\t\tend else if (M_AXI_BREADY)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tassert(faxil_awr_outstanding\n\t\t\t\t== (M_AXI_AWVALID ? 0:1)\n\t\t\t\t\t+ (misaligned_response_pending ? 1:0));\n\t\t\tassert(faxil_wr_outstanding\n\t\t\t\t== (M_AXI_WVALID ? 0:1)\n\t\t\t\t\t+ (misaligned_response_pending ? 1:0));\n\t\t\t// }}}\n\t\tend else begin // Read cycle\n\t\t\t// {{{\n\t\t\tassert(M_AXI_RREADY);\n\t\t\tassert(faxil_rd_outstanding\n\t\t\t\t== (M_AXI_ARVALID ? 0:1)\n\t\t\t\t\t+ (misaligned_response_pending ? 1:0));\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\tend else if (M_AXI_BREADY)\n\tbegin\n\t\t// {{{\n\t\tassert(!misaligned_aw_request);\n\t\tassert(!misaligned_request);\n\t\tassert(!misaligned_response_pending);\n\t\tassert(!pending_err);\n\t\tassert(faxil_awr_outstanding == (M_AXI_AWVALID ? 0:1));\n\t\tassert(faxil_wr_outstanding  == (M_AXI_WVALID  ? 0:1));\n\t\tassert(faxil_rd_outstanding  == 0);\n\t\tassert(!misaligned_read);\n\t\t// }}}\n\tend else begin\n\t\t// {{{\n\t\tassert(M_AXI_RREADY);\n\t\tassert(!misaligned_aw_request);\n\t\tassert(!misaligned_request);\n\t\tassert(!misaligned_response_pending);\n\t\tassert(!misaligned_read);\n\t\tassert(!pending_err);\n\t\tassert(faxil_awr_outstanding == 0);\n\t\tassert(faxil_wr_outstanding  == 0);\n\t\tassert(faxil_rd_outstanding  == (M_AXI_ARVALID ? 0:1));\n\t\t// }}}\n\tend\n\t// }}}\n\n\talways @(*)\n\tif (!o_busy)\n\t\t`ASSERT(!r_flushing);\n\n\t// Following any i_stb request, assuming we are idle, immediately\n\t// begin a bus transaction\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_stb && !o_err))\n\t\t&&(!$past(o_busy))&&($past(!i_cpu_reset)))\n\tbegin\n\t\t`ASSERT(o_busy || (OPT_ALIGNMENT_ERR && o_err));\n\tend\n\n\talways @(*)\n\t\t`ASSERT(o_busy == (M_AXI_BREADY || M_AXI_RREADY));\n\talways @(*)\n\t\t`ASSERT(o_rdbusy == (M_AXI_RREADY && !r_flushing));\n\n\talways @(*)\n\tif (o_busy && !misaligned_request && OPT_LOWPOWER)\n\tbegin\n\t\tassert(next_wdata == 0);\n\t\tassert(next_wstrb == 0);\n\tend\n\n\t// If a transaction ends in an error, send o_err on the",
            "output port.\n\talways @(posedge i_clk)\n\tif (f_past_valid)\n\tbegin\n\t\tif ($past(i_cpu_reset || r_flushing || o_err))\n\t\tbegin\n\t\t\t`ASSERT(!o_err);\n\t\tend else if ($past(M_AXI_BVALID && M_AXI_BRESP[1]))\n\t\tbegin\n\t\t\tif ($past(misaligned_response_pending))\n\t\t\tbegin\n\t\t\t\t`ASSERT((!o_err && pending_err) || r_flushing);\n\t\t\tend else\n\t\t\t\t`ASSERT(o_err);\n\t\tend else if ($past(M_AXI_RVALID && M_AXI_RRESP[1]))\n\t\tbegin\n\t\t\tif ($past(misaligned_response_pending))\n\t\t\tbegin\n\t\t\t\t`ASSERT((!o_err && pending_err) || r_flushing);\n\t\t\tend else\n\t\t\t\t`ASSERT(o_err);\n\t\tend else if (OPT_ALIGNMENT_ERR && $past(i_stb && w_misaligned))\n\t\tbegin\n\t\t\t`ASSERT(o_err);\n\t\tend else if (!$past(pending_err))\n\t\t\t`ASSERT(!o_err);\n\t\t//else if ($past(misaligned))\n\t\t\t//`ASSERT(o_err);\n\tend\n\n\talways @(*)\n\tif (o_busy && misaligned_response_pending)\n\t\t`ASSERT(!pending_err);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(!i_cpu_reset))&&($past(i_stb)))\n\tbegin\n\t\t// On a write, assert o_wb_we should be true\n\t\tassert($past(i_op[0] && !o_err\n\t\t\t&& (!OPT_ALIGNMENT_ERR || !w_misaligned))\n\t\t\t\t== (M_AXI_AWVALID && M_AXI_WVALID));\n\tend\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// OPT_LOWPOWER / Zero on idle checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (OPT_LOWPOWER)\n\tbegin\n\t\tgenvar\tfb;\n\n\t\talways @(*)\n\t\tif (!M_AXI_AWVALID && !M_AXI_ARVALID)\n\t\t\t`ASSERT(M_AXI_AWADDR == 0);\n\n\t\talways @(*)\n\t\tif (!M_AXI_WVALID)\n\t\tbegin\n\t\t\t`ASSERT(M_AXI_WDATA == 0);\n\t\t\t`ASSERT(M_AXI_WSTRB == 0);\n\n\t\t\t`ASSERT(next_wdata == 0);\n\t\t\t`ASSERT(next_wstrb == 0);\n\t\tend\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !o_valid)\n\t\t\t`ASSERT(o_result == 0);\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && (!o_valid && !o_err) && (!M_AXI_RREADY || r_flushing))\n\t\t\t`ASSERT(o_w",
            "reg == 0);\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && (OPT_ALIGNMENT_ERR || !M_AXI_RREADY\n\t\t\t\t\t|| misaligned_response_pending))\n\t\t\t`ASSERT(last_result == 0);\n\n\t\tfor(fb=0; fb<C_AXI_DATA_WIDTH/8; fb=fb+1)\n\t\tbegin\n\t\t\talways @(*)\n\t\t\tif (S_AXI_ARESETN && !M_AXI_WSTRB[fb])\n\t\t\t\t`ASSERT(M_AXI_WDATA[fb*8 +: 8] == 8'h0);\n\n\t\t\talways @(*)\n\t\t\tif (S_AXI_ARESETN && !next_wstrb[fb])\n\t\t\t\t`ASSERT(next_wdata[fb*8 +: 8] == 8'h0);\n\t\tend\n\n\t\t// always @(*)\n\t\t// if (!o_valid)\n\t\t//\t`ASSERT(o_result == 0);\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "wire [3:0]\tcpu_outstanding;",
            "reg f_done;",
            "wire [4:0]\tf_last_",
            "reg , f_addr_",
            "reg ;\n\t(* anyseq *)",
            "reg [4:0]\tf_a",
            "reg ;\n\n\tinitial\tf_done = 1'b0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN || r_flushing || i_cpu_reset)\n\t\tf_done <= 1'b0;\n\telse\n\t\tf_done <= (M_AXI_RVALID && !M_AXI_RRESP[1]\n\t\t\t|| M_AXI_BVALID && !M_AXI_BRESP[1]) && !pending_err\n\t\t\t\t&& !misaligned_response_pending;\n\n\n\tfmem\n\tfcheck(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK),\n\t\t.i_sys_reset(!S_AXI_ARESETN),\n\t\t.i_cpu_reset(i_cpu_reset),\n\t\t.i_stb(i_stb),\n\t\t.i_pipe_stalled(o_busy),\n\t\t.i_clear_cache(1'b0),\n\t\t.i_lock(i_lock), .i_op(i_op), .i_addr(i_addr),\n\t\t.i_data(i_data), .i_o",
            "reg (i_o",
            "reg ), .i_busy(o_busy),\n\t\t\t.i_a",
            "reg (f_a",
            "reg ),\n\t\t.i_rdbusy(o_rdbusy), .i_valid(o_valid), .i_done(f_done),\n\t\t.i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_result),\n\t\t.f_outstanding(cpu_outstanding),\n\t\t.f_pc(f_pc),\n\t\t.f_gie(f_gie),\n\t\t.f_read_cycle(f_read_cycle),\n\t\t.f_last_",
            "reg (f_last_",
            "reg ), .f_addr_",
            "reg (f_addr_",
            "reg )\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (r_flushing)\n\tbegin\n\t\t`ASSERT(cpu_outstanding == 0);\n\tend else\n\t\t`ASSERT(cpu_outstanding == (o_busy ? 1:0)\n\t\t\t+ ((f_done || o_err) ? 1 : 0));\n\n\talways @(*)\n\tif (f_pc)\n\tbegin\n\t\tassert(o_w",
            "reg [3:1] == 3'h7 || (OPT_LOWPOWER && o_err));\n\tend else if (o_rdbusy)\n\t\tassert(o_w",
            "reg [3:1] != 3'h7);\n\n\talways @(*)\n\tif (cpu_outstanding > 0 && (!OPT_LOWPOWER || (f_read_cycle && !o_err)))\n\t\tassert(o_w",
            "reg == f_last_",
            "reg );\n\n\talways @(*)\n\tif (o_busy && (!OPT_LOWPOWER || (M_AXI_RREADY && !r_flushing)))\n\t\tassert(o_w",
            "reg [4] == f_gie);\n\n\talways @(*)\n\tif (M_AXI_RREADY)\n\tbegin\n\t\tassert(f_read_cycle || r_flushing);\n\tend else if (M_AXI_BREADY)\n\t\tassert(!f_read_cycle);\n\n\t// ????   Not written yet\n\t//\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg [3:0]\tcvr_writes, cvr_reads;\n\n\tinitial\tcvr_writes = 0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN)\n\t\tcvr_writes <= 0;\n\telse if (M_AXI_BVALID&& !misaligned_response_pending  && !cvr_writes[3])\n\t\tcvr_writes <= cvr_writes + 1;\n\n\tinitial\tcvr_reads = 0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN)\n\t\tcvr_reads <= 0;\n\telse if (M_AXI_RVALID && !misaligned_response_pending && !cvr_reads[3])\n\t\tcvr_reads <= cvr_reads + 1;\n\n\t// Cover a write response\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_BVALID && !M_AXI_BRESP[1]);\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_BVALID &&  M_AXI_BRESP[1]);\n\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_RVALID && !M_AXI_RRESP[1]);\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_RVALID &&  M_AXI_RRESP[1]);\n\n\n\talways @(posedge i_clk)\n\t\tcover(cvr_writes > 3);\n\n\talways @(posedge i_clk)\n\t\tcover(cvr_reads > 3);\n\t// }}}\n`endif\n// }}}",
            "endmodule //\n//\n// Usage (from yosys):\n//\t\t(BFOR)\t(!ZOI,ALIGN)\t(ZOI,ALIGN)\t(!ZOI,!ALIGN)\n//\tCells\t 230\t\t226\t\t281\t\t225\n//\t  FDRE\t 114\t\t116\t\t116\t\t116\n//\t  LUT2\t  17\t\t 23\t\t 76\t\t 19\n//\t  LUT3\t   9\t\t 23\t\t 17\t\t 20\n//\t  LUT4\t  15\t\t  4\t\t 11\t\t 14\n//\t  LUT5\t  18\t\t 18\t\t  7\t\t 15\n//\t  LUT6\t  33\t\t 18\t\t 54\t\t 38\n//\t  MUX7\t  16\t\t 12\t\t  \t\t  2\n//\t  MUX8\t   8\t\t  1\t\t\t\t  1\n//\n//"
        ]
    },
    {
        "file_name": "div.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/div.v",
        "chunks": [
            "input .\n//\n//\ti_wr\tWhen i_reset is asserted, a divide begins.  On the next clock:\n//\n//\t  o_busy is set high so everyone else knows we are at work and they can\n//\t\twait for us to complete.\n//\n//\t  pre_sign is set to true if we need to do a signed divide.  In this\n//\t\tcase, we take a clock cycle to turn the divide into an unsigned\n//\t\tdivide.\n//\n//\t  o_quotient, a place to store our result, is initialized to all zeros.\n//\n//\t  r_dividend is set to the numerator\n//\n//\t  r_divisor is set to 2^31 * the denominator (shift left by 31, or add\n//\t\t31 zeros to the right of the number.\n//\n//\tpre_sign When true (clock cycle after i_wr), a clock cycle is used\n//\t\tto take the absolute value of the various arguments (r_dividend\n//\t\tand r_divisor), and to calculate what sign the",
            "output result\n//\t\tshould be.\n//\n//\n//\tAt this point, the divide is has started.  The divide works by walking\n//\tthrough every shift of the\n//\n//\t\t    DIVIDEND\tover the\n//\t\tDIVISOR\n//\n//\tIf the DIVISOR is bigger than the dividend, the divisor is shifted\n//\tright, and nothing is done to the",
            "output quotient.\n//\n//\t\t    DIVIDEND\n//\t\t DIVISOR\n//\n//\tThis repeats, until DIVISOR is less than or equal to the divident, as in\n//\n//\t\tDIVIDEND\n//\t\tDIVISOR\n//\n//\tAt this point, if the DIVISOR is less than the dividend, the\n//\tdivisor is subtracted from the dividend, and the DIVISOR is again\n//\tshifted to the right.  Further, a '1' bit gets set in the",
            "output //\tquotient.\n//\n//\tOnce we've done this for 32 clocks, we've accumulated our answer into\n//\tthe",
            "output quotient, and we can proceed to the next step.  If the\n//\tresult will be signed, the next step negates the quotient, otherwise\n//\tit returns the result.\n//\n//\tOn the clock when we are done, o_busy is set to false, and o_valid set\n//\tto true.  (It is a violation of the ZipCPU internal protocol for both\n//\tbusy and valid to ever be true on the same clock.  It is also a\n//\tviolation for busy to be false with valid true thereafter.)\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module div #(",
            "parameter BW=32, LGBW = 5,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Input",
            "parameter s",
            "input ",
            "wire i_wr, i_signed,",
            "input ",
            "wire [(BW-1):0]\ti_numerator, i_denominator,\n\t\t// Output",
            "parameter s",
            "output ",
            "reg o_busy, o_valid, o_err,",
            "output ",
            "reg [(BW-1):0]\to_quotient,",
            "output ",
            "wire [3:0]\to_flags\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{\n\t// r_busy is an internal busy",
            "reg ister.  It will clear one clock\n\t// before we are valid, so it can't be o_busy ...\n\t//",
            "reg r_busy;",
            "reg [BW-1:0]\tr_divisor;",
            "reg [(2*BW-2):0]\tr_dividend;",
            "wire [(BW):0]\tdiff; // , xdiff[(BW-1):0];\n\tassign\tdiff = r_dividend[2*BW-2:BW-1] - r_divisor;",
            "reg r_sign, pre_sign, r_z, r_c, last_bit;",
            "reg [(LGBW-1):0]\tr_bit;",
            "reg zero_divisor;",
            "wire w_n;\n\t// }}}\n\n\t// r_busy\n\t// {{{\n\t// The Divide",
            "logic begins with r_busy.  We use r_busy to determine\n\t// whether or not the divide is in progress, vs being complete.\n\t// Here, we clear r_busy on any reset and set it on i_wr (the request\n\t// to do a divide).  The divide ends when we are on the last bit,\n\t// or equivalently when we discover we are dividing by zero.\n\tinitial\tr_busy = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_busy <= 1'b0;\n\telse if (i_wr)\n\t\tr_busy <= 1'b1;\n\telse if ((last_bit)||(zero_divisor))\n\t\tr_busy <= 1'b0;\n\t// }}}\n\n\t// o_busy\n\t// {{{\n\t// o_busy is very similar to r_busy, save for some key differences.\n\t// Primary among them is that o_busy needs to (possibly) be true\n\t// for an extra clock after r_busy clears.  This would be that extra\n\t// clock where we negate the result (assuming a signed divide, and that\n\t// the result is supposed to be negative.)  Otherwise, the two are\n\t// identical.\n\tinitial\to_busy = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_busy <= 1'b0;\n\telse if (i_wr)\n\t\to_busy <= 1'b1;\n\telse if (((last_bit)&&(!r_sign))||(zero_divisor))\n\t\to_busy <= 1'b0;\n\telse if (!r_busy)\n\t\to_busy <= 1'b0;\n\t// }}}\n\n\t// zero_divisor\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_wr)\n\t\tzero_divisor <= (i_denominator == 0);\n\t// }}}\n\n\t// o_valid\n\t// {{{\n\t// o_valid is part of the ZipCPU protocol.  It will be set to true\n\t// anytime our answer is valid and may be used by the calling",
            "module .\n\t// Indeed, the ZipCPU will halt (and ignore us) once the i_wr has been\n\t// set until o_valid gets set.\n\t//\n\t// Here, we clear o_valid on a reset, and any time we are on the last\n\t// bit while busy (provided the sign is zero, or we are dividing by\n\t// zero).  Since o_valid is self-clearing, we don't need to clear\n\t// it on an i_wr signal.\n\tinitial\to_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(o_valid))\n\t\to_valid <= 1'b0;\n\telse if ((r_busy)&&(zero_divisor))\n\t\to_valid <= 1'b1;\n\telse if (r_busy)\n\tbegin\n\t\tif (last_bit)\n\t\t\to_valid <= (!r_sign);\n\tend else if (r_sign)\n\tbegin\n\t\to_valid <= 1'b1;\n\tend else\n\t\to_valid <= 1'b0;\n\t// }}}\n\n\t// o_err\n\t// {{{\n\t// Division by zero error reporting.  Anytime we detect a zero divisor,\n\t// we set our",
            "output error, and then hold it until we are valid and\n\t// everything clears.\n\tinitial\to_err = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_err <= 1'b0;\n\telse if ((r_busy)&&(zero_divisor))\n\t\to_err <= 1'b1;\n\telse\n\t\to_err <= 1'b0;\n\t// }}}\n\n\t// r_bit\n\t// {{{\n\t// Keep track of which \"bit\" of our divide we are on.  This number\n\t// ranges from 31 down to zero.  On any write, we set ourselves to\n\t// 5'h1f.  Otherwise, while we are busy (but not within the pre-sign\n\t// adjustment stage), we subtract one from our value on every clock.\n\tinitial\tr_bit = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_bit <= 0;\n\telse if ((r_busy)&&(!pre_sign))\n\t\tr_bit <= r_bit + 1'b1;\n\telse\n\t\tr_bit <= 0;\n\t// }}}\n\n\t// last_bit\n\t// {{{\n\t// This",
            "logic replaces a lot of",
            "logic that was inside our giant state\n\t// machine with ... something simpler.  In particular, we'll use this\n\t//",
            "logic to determine if we are processing our last bit.  The only trick\n\t// is, this bit needs to be set whenever (r_busy) and (r_bit == -1),\n\t// hence we need to set on (r_busy) and (r_bit == -2) so as to be set\n\t// when (r_bit == 0).\n\tinitial\tlast_bit = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tlast_bit <= 1'b0;\n\telse if (r_busy)\n\t\tlast_bit <= (r_bit == {(LGBW){1'b1}}-1'b1);\n\telse\n\t\tlast_bit <= 1'b0;\n\t// }}}\n\n\t// pre_sign\n\t// {{{\n\t// This is part of the state machine.  pre_sign indicates that we need\n\t// a extra clock to take the absolute value of our",
            "input s.  It need only\n\t// be true for the one clock, and then it must clear itself.\n\tinitial\tpre_sign = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tpre_sign <= 1'b0;\n\telse\n\t\tpre_sign <= (i_wr)&&(i_signed)&&((i_numerator[BW-1])||(i_denominator[BW-1]));\n\t// }}}\n\n\t// r_z\n\t// {{{\n\t// As a result of our operation, we need to set the flags.  The most\n\t// difficult of these is the \"Z\" flag indicating that the result is\n\t// zero.  Here, we'll use the same",
            "logic that sets the low-order\n\t// bit to clear our zero flag, and leave the zero flag set in all\n\t// other cases.\n\talways @(posedge i_clk)\n\tif (i_wr)\n\t\tr_z <= 1'b1;\n\telse if ((r_busy)&&(!pre_sign)&&(!diff[BW]))\n\t\tr_z <= 1'b0;\n\t// }}}\n\n\t// r_dividend\n\t// {{{\n\t// This is initially the numerator.  On a signed divide, it then becomes\n\t// the absolute value of the numerator.  We'll subtract from this value\n\t// the divisor for every",
            "output bit we are looking for--just as with\n\t// traditional long division.\n\talways @(posedge i_clk)\n\tif (pre_sign)\n\tbegin\n\t\t// If we are doing a signed divide, then take the\n\t\t// absolute value of the dividend\n\t\tif (r_dividend[BW-1])\n\t\tbegin\n\t\t\tr_dividend[2*BW-2:0] <= {(2*BW-1){1'b0}};\n\t\t\tr_dividend[BW:0] <= -{ 1'b1, r_dividend[BW-1:0] };\n\t\tend\n\tend else if (r_busy)\n\tbegin\n\t\tr_dividend <= { r_dividend[2*BW-3:0], 1'b0 };\n\t\tif (!diff[BW])\n\t\t\tr_dividend[2*BW-2:BW] <= diff[(BW-2):0];\n\tend else if (!r_busy && (!OPT_LOWPOWER || i_wr))\n\t\t// Once we are done, and r_busy is no longer high, we'll\n\t\t// always accept new values into our dividend.  This\n\t\t// guarantees that, when i_wr is set, the new value\n\t\t// is already set as desired.\n\t\tr_dividend <=  { 31'h0, i_numerator };\n\t// }}}\n\n\t// r_divisor\n\t// {{{\n\tinitial\tr_divisor = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_divisor <= 0;\n\telse if ((pre_sign)&&(r_busy))\n\tbegin\n\t\tif (r_divisor[BW-1])\n\t\t\tr_divisor <= -r_divisor;\n\tend else if (!r_busy && (!OPT_LOWPOWER || i_wr))\n\t\tr_divisor <= i_denominator;\n\t// }}}\n\n\t// r_sign\n\t// {{{\n\t// is a flag for our state machine control(s).  r_sign will be set to\n\t// true any time we are doing a signed divide and the result must be\n\t// negative.  In that case, we take a final",
            "logic stage at the end of\n\t// the divide to negate the",
            "output .  This flag is what tells us we need\n\t// to do that.  r_busy will be true during the divide, then when r_busy\n\t// goes low, r_sign will be checked, then the idle/reset stage will have\n\t// been reached.  For this reason, we cannot set r_sign unless we are\n\t// up to something.\n\tinitial\tr_sign = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_sign <= 1'b0;\n\telse if (pre_sign)\n\t\tr_sign <= ((r_divisor[(BW-1)])^(r_dividend[(BW-1)]));\n\telse if (r_busy)\n\t\tr_sign <= (r_sign)&&(!zero_divisor);\n\telse\n\t\tr_sign <= 1'b0;\n\t// }}}\n\n\t// o_quotient\n\t// {{{\n\tinitial\to_quotient = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_quotient <= 0;\n\telse if (r_busy)\n\tbegin\n\t\to_quotient <= { o_quotient[(BW-2):0], 1'b0 };\n\t\tif (!diff[BW])\n\t\t\to_quotient[0] <= 1'b1;\n\tend else if (r_sign)\n\t\to_quotient <= -o_quotient;\n\telse\n\t\to_quotient <= 0;\n\t// }}}\n\n\t// r_c\n\t// {{{\n\t// Set Carry on an exact divide\n\t// Perhaps nothing uses this, but ... well, I suppose we could remove\n\t// this",
            "logic eventually, just ... not yet.\n\tinitial\tr_c = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_c <= 1'b0;\n\telse\n\t\tr_c <= (r_busy)&&(diff == 0);\n\t// }}}\n\n\t// w_n\n\t// {{{\n\t// The last flag: Negative.  This flag is set assuming that the result\n\t// of the divide was negative (i.e., the high order bit is set).  This\n\t// will also be true of an unsigned divide--if the high order bit is\n\t// ever set upon completion.  Indeed, you might argue that there's no\n\t//",
            "logic involved.\n\tassign w_n = o_quotient[(BW-1)];\n\t// }}}\n\n\tassign o_flags = { 1'b0, w_n, r_c, r_z };\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n`ifdef\tDIV\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif\n\n\tinitial\t`ASSUME(i_reset);\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(i_reset);\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\tbegin\n\t\tassert(!o_busy);\n\t\tassert(!o_valid);\n\t\tassert(!o_err);\n\t\t//\n\t\tassert(!r_busy);\n\t\t// assert(!zero_divisor);\n\t\tassert(r_bit==0);\n\t\tassert(!last_bit);\n\t\tassert(!pre_sign);\n\t\t// assert(!r_z);\n\t\t// assert(r_dividend==0);\n\t\tassert(o_quotient==0);\n\t\tassert(!r_c);\n\t\tassert(r_divisor==0);\n\n\t\t`ASSUME(!i_wr);\n\tend\n\n\talways @(*)\n\tif (o_busy)\n\t\t`ASSUME(!i_wr);\n\n\talways @(*)\n\tif (r_busy)\n\t\tassert(o_busy);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(o_busy))&&(!o_busy))\n\tbegin\n\t\tassert(o_valid);\n\tend\n\n\t// A formal methods section\n\t//\n\t// This section isn't yet complete.  For now, it is just\n\t// a description of things I think should be in here ... not\n\t// yet a description of what it would take to prove\n\t// this divide (yet).\n\talways @(*)\n\tif (o_err)\n\t\tassert(o_valid);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_wr)))\n\t\tassert(!pre_sign);\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wr))&&($past(i_signed))\n\t\t\t&&(|$past({i_numerator[BW-1],i_denominator[BW-1]})))\n\t\tassert(pre_sign);\n\n\t// always @(posedge i_clk)\n\t// if ((f_past_valid)&&(!$past(pre_sign)))\n\t\t// assert(!r_sign);",
            "reg [BW:0]\tf_bits_set;\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wr)))\n\t\tassert(o_busy);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_valid)))\n\t\tassert(!o_valid);\n\n\talways @(*)\n\tif ((o_valid)&&(!o_err))\n\tbegin\n\t\tassert(r_z == ((o_quotient == 0)? 1'b1:1'b0));\n\tend else if (o_busy)\n\t\tassert(r_z == (((o_quotient&f_bits_set[BW-1:0]) == 0)? 1'b1: 1'b0));\n\n\talways @(*)\n\tif ((o_valid)&&(!o_err))\n\t\tassert(w_n == o_quotient[BW-1]);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(r_busy))&&(!$past(i_wr)))\n\t\tassert(!o_busy);\n\talways @(posedge i_clk)\n\t\tassert((!o_busy)||(!o_valid));\n\n\talways @(*)\n\tif(r_busy)\n\t\tassert(o_busy);\n\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_bits_set <= 0;\n\telse if (i_wr)\n\t\tf_bits_set <= 0;\n\telse if ((r_busy)&&(!pre_sign))\n\t\tf_bits_set <= { f_bits_set[BW-1:0], 1'b1 };\n\n\talways @(posedge i_clk)\n\tif (r_busy)\n\t\tassert(((1<<r_bit)-1) == f_bits_set);\n\n\talways @(*)\n\tif ((o_valid)&&(!o_err))\n\t\tassert((!f_bits_set[BW])&&(&f_bits_set[BW-1:0]));\n\n\n\t/*\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(r_busy))\n\t\t&&($past(r_divisor[2*BW-2:BW])==0))\n\tbegin\n\t\tif ($past(r_divisor) == 0)\n\t\tbegin\n\t\t\tassert(o_err);\n\t\tend else if ($past(pre_sign))\n\t\tbegin\n\t\t\tif ($past(r_dividend[BW-1]))\n\t\t\t\tassert(r_dividend == -$past(r_dividend));\n\t\t\tif ($past(r_divisor[(2*BW-2)]))\n\t\t\tbegin\n\t\t\t\tassert(r_divisor[(2*BW-2):(BW-1)]\n\t\t\t\t\t== -$past(r_divisor[(2*BW-2):(BW-1)]));\n\t\t\t\tassert(r_divisor[BW-2:0] == 0);\n\t\t\tend\n\t\tend else begin\n\t\t\tif (o_quotient[0])\n\t\t\tbegin\n\t\t\t\tassert(r_dividend == $past(diff));\n\t\t\tend else\n\t\t\t\tassert(r_dividend == $past(r_dividend));\n\n\t\t\t// r_divisor should shift down on every step\n\t\t\tassert(r_divisor[2*BW-2]==0);\n\t\t\tassert(r_divisor[2*BW-3:0]==$past(r_divisor[2*BW-2:1]));\n\t\tend\n\t\tif ($past(r_dividend) >= $past(r_divisor[BW-1:0]))\n\t\tbegin\n\t\t\tassert(o_quotient[0]);\n\t\tend else\n\t\t\tassert(!o_quotient[0]);\n\tend\n\t*/\n\n       \talways @(*)\n\tif (r_busy)\n\t\tassert((f_bits_set & r_dividend[BW-1:0])==0);\n\n       \talways @(*)\n\tif (r_busy)\n\t\tassert((r_divisor == 0) == zero_divisor);\n\n`ifdef\tVERIFIC\n\t// {{{\n\t// Verify unsigned division\n\tassert property (@(posedge i_clk)\n\t\tdisable iff (i_reset)\n\t\t(i_wr)&&(i_denominator != 0)&&(!i_signed)\n\t\t|=> ((!o_err)&&(!o_valid)&&(o_busy)&&(!r_sign)&&(!pre_sign)\n\t       \t\t\tthroughout (r_bit == 0)\n\t\t\t##1 ((r_bit == $past(r_bit)+1)&&({1'b0,r_bit}< BW-1))\n\t\t\t\t\t[*0:$]\n\t\t\t##1 ({ 1'b0, r_bit } == BW-1))\n\t\t\t##1 (!o_err)&&(o_valid));\n\n\t// Verify division by zero\n\tassert property (@(posedge i_clk)\n\t\tdisable iff (i_reset)\n\t\t(i_wr)&&(i_denominator == 0)\n\t\t|=> (zero_divisor throughout\n\t\t\t(!o_err)&&(!o_valid)&&(pre_sign) [*0:1]\n\t\t\t##1 ((r_busy)&&(!o_err)&&(!o_valid))\n\t\t\t##1 ((o_err)&&(o_valid))));\n\n\t// }}}\n`endif\t// VERIFIC\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "pffifo.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/pffifo.v",
        "chunks": [
            "module pffifo #(\n\t\t// {{{",
            "parameter LGFIFO = 4,",
            "parameter AW = 30,",
            "parameter BUS_WIDTH = 128, // Num data bits on the bus",
            "parameter INSN_WIDTH = 32,",
            "parameter [0:0]\tOPT_LITTLE_ENDIAN = 1'b0,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,",
            "parameter [0:0]\tOPT_ASYNC_READ = (BUS_WIDTH != INSN_WIDTH),",
            "localparam BUSW = BUS_WIDTH,",
            "localparam WBLSB = $clog2(BUS_WIDTH/8),",
            "localparam ADDRESS_WIDTH=AW + WBLSB\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t//\n\t\t// The interface with the rest of the CPU\n\t\t// {{{",
            "input ",
            "wire i_new_pc,",
            "input ",
            "wire i_clear_cache,",
            "input ",
            "wire i_ready,",
            "input ",
            "wire [ADDRESS_WIDTH-1:0]\ti_pc,",
            "output ",
            "wire o_valid,",
            "output ",
            "wire o_illegal,",
            "output ",
            "wire [INSN_WIDTH-1:0]\to_insn,",
            "output ",
            "reg [ADDRESS_WIDTH-1:0]\to_pc,\n\t\t// }}}\n\t\t// The wishbone bus interface\n\t\t// {{{",
            "output ",
            "reg o_wb_cyc, o_wb_stb,\n\t\t// verilator coverage_off",
            "output ",
            "wire o_wb_we,\n\t\t// verilator coverage_on",
            "output ",
            "reg [AW-1:0]\to_wb_addr,\n\t\t// verilator coverage_off",
            "output ",
            "wire [BUSW-1:0]\to_wb_data,",
            "output ",
            "wire [BUSW/8-1:0]\to_wb_sel,\n\t\t// verilator coverage_on\n\t\t//",
            "input ",
            "wire i_wb_stall, i_wb_ack, i_wb_err,",
            "input ",
            "wire [BUSW-1:0]\ti_wb_data\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam INLSB = $clog2(INSN_WIDTH/8);",
            "reg pending_err;",
            "reg [LGFIFO:0]\twb_pending, pipe_fill;",
            "wire [LGFIFO:0]\tw_pipe_fill;",
            "wire pipe_full, last_ack;",
            "wire sfifo_reset, ign_sfifo_full, sfifo_empty,pf_err;",
            "wire [LGFIFO:0]\tsfifo_fill;\t// Used to start operation",
            "wire [BUS_WIDTH-1:0]\tsfifo_word;",
            "wire sfifo_read, pf_last;\n`ifdef\tFORMAL",
            "wire [LGFIFO:0]\tf_first_addr, f_second_addr,\n\t\t\t\tf_distance_to_first, f_distance_to_second;",
            "wire [BUS_WIDTH:0]\tf_first_data, f_second_data;",
            "wire f_first_in_fifo, f_second_in_fifo;",
            "wire [BUS_WIDTH-1:0]\tf_wide_data;\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Request instructions from the bus\n\t// {{{\n\n\t// o_wb_cyc, o_wb_stb, o_wb_addr, pending_err\n\t// {{{\n\tinitial\tpending_err = 1'b0;\n\tinitial\t{ o_wb_cyc, o_wb_stb } = 2'b00;\n\talways @(posedge i_clk)\n\tif (sfifo_reset)\n\tbegin\n\t\tpending_err <= 1'b0;\n\t\to_wb_cyc <= 1'b0;\n\t\to_wb_stb <= 1'b0;\n\t\tif (i_new_pc)\n\t\t\to_wb_addr <= i_pc[ADDRESS_WIDTH-1:WBLSB];\n\t\tif (i_reset)\n\t\t\to_wb_addr <= 0;\n\tend else if (o_wb_cyc && i_wb_err)\n\tbegin\n\t\tpending_err <= 1'b1;\n\t\to_wb_cyc <= 1'b0;\n\t\to_wb_stb <= 1'b0;\n\t\t// Verilator lint_off WIDTH\n\t\to_wb_addr <= o_wb_addr - wb_pending;\n\t\t// Verilator lint_on  WIDTH\n\tend else if (o_wb_cyc)\n\tbegin\n\t\tpending_err <= 1'b0;\n\t\tif (o_wb_stb && !i_wb_stall)\n\t\t\to_wb_addr <= o_wb_addr + 1;\n\t\tif (pipe_full && !i_wb_stall)\n\t\t\to_wb_stb <= 1'b0;\n\t\tif ((!o_wb_stb || (pipe_full && !i_wb_stall)) && last_ack)\n\t\t\to_wb_cyc <= 1'b0;\n\tend else if (sfifo_fill[LGFIFO:LGFIFO-1] == 2'b00 && !pending_err)\n\tbegin\n\t\to_wb_cyc <= 1'b1;\n\t\to_wb_stb <= 1'b1;\n\t\t// o_wb_addr == same as before\n\tend\n`ifdef\tFORMAL\n\talways @(*)\n\tif (!i_reset)\n\t\tassert(o_wb_cyc == (o_wb_stb || wb_pending > 0));\n`endif\n\t// }}}\n\n\t// o_wb_sel\n\t// {{{\n\tgenerate if (INSN_WIDTH == BUS_WIDTH)\n\tbegin : GEN_ALWAYS_SEL\n\t\tassign\to_wb_sel = {(BUS_WIDTH/8){1'b1}};\n\tend else begin : GEN_WB_SEL",
            "reg [BUS_WIDTH/8-1:0]\tr_sel;",
            "wire [WBLSB-INLSB-1:0]\tnew_shift;\n\n\t\tassign\tnew_shift = i_pc[WBLSB-1:INLSB];\n\n\t\talways @(posedge i_clk)\n\t\tif (i_new_pc)\n\t\tbegin\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\tr_sel <= {(BUS_WIDTH/8){1'b1}}\n\t\t\t\t\t\t<< ((INSN_WIDTH/8)*new_shift);\n\t\t\tend else begin\n\t\t\t\tr_sel <= {(BUS_WIDTH/8){1'b1}}\n\t\t\t\t\t\t>> ((INSN_WIDTH/8)*new_shift);\n\t\t\tend\n\t\tend else if (o_wb_stb && !i_wb_stall)\n\t\t\tr_sel <= {(BUS_WIDTH/8){1'b1}};\n\n\t\tassign\to_wb_sel = r_sel;\n\tend endgenerate\n\t// }}}\n\n\t// wb_pending: When do we shut off CYC?\n\t// {{{\n\tinitial\twb_pending = 0;\n\talways @(posedge i_clk)\n\tif (sfifo_reset || i_wb_err)\n\t\twb_pending <= 0;\n\telse case({ (o_wb_stb && !i_wb_stall), (o_wb_cyc && i_wb_ack) })\n\t2'b10: wb_pending <= wb_pending + 1;\n\t2'b01: wb_pending <= wb_pending - 1;\n\tdefault: begin end\n\tendcase\n\t// }}}\n\n\t// pipe_fill: When do we shut off STB?\n\t// {{{\n\tinitial\tpipe_fill = 0;\n\talways @(posedge i_clk)\n\tif (sfifo_reset || (o_wb_cyc && i_wb_err))\n\t\tpipe_fill <= 0;\n\telse if (!pending_err)\n\tcase({ (o_wb_stb && !i_wb_stall), o_valid && i_ready && pf_last })\n\t2'b10: pipe_fill <= pipe_fill + 1;\n\t2'b01: pipe_fill <= pipe_fill - 1;\n\tdefault: begin end\n\tendcase\n\t// }}}\n\n\tassign\tw_pipe_fill = pipe_fill + (o_wb_stb ? 1:0);\n\tassign\tpipe_full = pending_err || w_pipe_fill[LGFIFO];\n\n\tassign\tlast_ack = (wb_pending + (o_wb_stb ? 1:0)) == (i_wb_ack ? 1:0);\n\tassign\to_wb_we = 1'b0;\n\tassign\to_wb_data = {(BUS_WIDTH){1'b0}};\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Placed returned instructions into a FIFO\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tassign\tsfifo_reset = i_reset || i_clear_cache || i_new_pc;\n\n\tsfifo #(\n\t\t.BW(BUS_WIDTH+1), .LGFLEN(LGFIFO),\n\t\t.OPT_ASYNC_READ(OPT_ASYNC_READ)\n\t) u_sfifo (\n\t\t.i_clk(i_clk), .i_reset(sfifo_reset),\n\t\t.i_wr(o_wb_cyc && (i_wb_ack || i_wb_err) && !pending_err),\n\t\t\t.i_data({ i_wb_err, i_wb_data }),\n\t\t.o_full(ign_sfifo_full), .o_fill(sfifo_fill),\n\t\t.i_rd(sfifo_read),\n\t\t.o_data({ pf_err, sfifo_word }),\n\t\t.o_empty(sfifo_empty)\n`ifdef\tFORMAL\n\t\t, .f_first_addr(f_first_addr),\n\t\t.f_second_addr(f_second_addr),\n\t\t.f_first_data(f_first_data),\n\t\t.f_second_data(f_second_data),\n\t\t.f_first_in_fifo(f_first_in_fifo),\n\t\t.f_second_in_fifo(f_second_in_fifo),\n\t\t.f_distance_to_first(f_distance_to_first),\n\t\t.f_distance_to_second(f_distance_to_second)\n`endif\n\t);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Unpack wide responses into instructions for the CPU\n\t// {{{\n\n\t// o_pc\n\t// {{{\n\talways @(posedge i_clk)\n\tbegin\n\t\tif (i_reset)\n\t\t\to_pc <= 0;\n\t\telse if (i_new_pc)\n\t\t\to_pc <= i_pc;\n\t\telse if (o_valid && i_ready)\n\t\t\to_pc <= o_pc + INSN_WIDTH/8;\n\n\t\to_pc[$clog2(INSN_WIDTH/8)-1:0] <= 0;\n\tend\n\t// }}}\n\n\tgenerate if (BUS_WIDTH == INSN_WIDTH)\n\tbegin : NO_UNPACKING",
            "reg r_illegal;\n\n\t\tassign\to_valid = !sfifo_empty;\n\t\tassign\tsfifo_read = o_valid && i_ready;\n\n\t\tassign\to_insn = sfifo_word;\n\n\t\t// o_illegal\n\t\t// {{{\n\t\tinitial\tr_illegal = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (sfifo_reset)\n\t\t\tr_illegal <= 1'b0;\n\t\telse if (o_valid && o_illegal)\n\t\t\tr_illegal <= 1'b1;\n\n\t\tassign\to_illegal = (pf_err && !sfifo_empty) || r_illegal;\n\t\t// }}}\n\n\t\tassign\tpf_last = 1;\n`ifdef\tFORMAL\n\t\tassign\tf_wide_data = sfifo_word;\n`endif\n\tend else begin : UNPACK_BUS\n\t\t// {{{",
            "reg r_valid, r_illegal;",
            "reg [BUS_WIDTH-1:0]\t\tr_data;",
            "reg [WBLSB-INLSB-1:0]\tfirst_shift;\n\n\t\t// o_valid\n\t\t// {{{\n\t\tinitial\tr_valid = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (sfifo_reset)\n\t\t\tr_valid <= 1'b0;\n\t\telse if (!o_valid || i_ready)\n\t\t\tr_valid <= !sfifo_empty || (o_valid && !pf_last);\n\n\t\tassign\to_valid = r_valid;\n\t\t// }}}\n\n\t\t// first_shift\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tfirst_shift <= 0;\n\t\telse if (i_new_pc)\n\t\t\tfirst_shift <= i_pc[WBLSB-1:INLSB];\n\t\telse if (sfifo_read && !sfifo_empty)\n\t\t\tfirst_shift <= 0;\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (i_reset)\n\t\tbegin\n\t\tend else if (o_valid)\n\t\tbegin\n\t\t\tassert(first_shift == 0);\n\t\tend else if (o_wb_cyc || pipe_fill > 0)\n\t\t\tassert(first_shift == o_pc[WBLSB-1:INLSB]);\n`endif\n\t\t// }}}\n\n\t\t// o_insn\n\t\t// {{{\n\t\tinitial\tr_data = {(BUS_WIDTH){1'b0}};\n\t\talways @(posedge i_clk)\n\t\tif (OPT_LOWPOWER && (sfifo_reset))\n\t\t\tr_data <= 0;\n\t\telse if (!o_valid || i_ready)\n\t\tbegin\n\t\t\tif (o_valid && !pf_last)\n\t\t\tbegin\n\t\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\t\t\tr_data <= r_data >> INSN_WIDTH;\n\t\t\t\telse\n\t\t\t\t\tr_data <= r_data << INSN_WIDTH;\n\t\t\tend else if ((!OPT_LOWPOWER || !sfifo_empty)\n\t\t\t\t&& (pf_last || !o_valid))\n\t\t\tbegin\n\t\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\t\t\tr_data <= sfifo_word >> (INSN_WIDTH * first_shift);\n\t\t\t\telse\n\t\t\t\t\tr_data <= sfifo_word << (INSN_WIDTH * first_shift);\n\t\t\tend\n\t\tend\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin : ASSIGN_LOWBITS\n\t\t\tassign\to_insn = r_data[INSN_WIDTH-1:0];\n\t\tend else begin : ASSIGN_HIBITS\n\t\t\tassign\to_insn = r_data[BUS_WIDTH-INSN_WIDTH +: INSN_WIDTH];\n\t\tend\n\t\t// }}}\n\n\t\tassign\tsfifo_read = (!o_valid || i_ready)\n\t\t\t\t\t\t&& (!o_valid || pf_last);\n\n\t\tassign\tpf_last = (&o_pc[WBLSB-1:INLSB]);\n\n\t\t// o_illegal\n\t\t// {{{\n\t\tinitial\tr_illegal = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (sfifo_reset)\n\t\t\tr_illegal <= 1'b0;\n\t\telse if (sfifo_read && !sfifo_empty)\n\t\t\tr_illegal <= r_illegal || pf_err;\n\n\t\tassign\to_illegal = r_illegal;\n\t\t// }}}\n`ifdef\tFORMAL\n\t\tassign\tf_wide_data = r_data;\n`endif\n\t\t// }}}\n\tend endgenerate\n\n\n\t// }}}\n\n\t// Keep Verilator happy\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\n\tassign\tunused = &{ 1'b0, sfifo_fill[LGFIFO-2:0], ign_sfifo_full };\n\t// Verilator lint_on  UNUSED\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal property section\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Declarations, reset, and f_past_valid\n\t// {{{",
            "localparam F_LGDEPTH=LGFIFO+1;",
            "reg f_past_valid;",
            "reg [4:0]\t\tf_cpu_delay;",
            "wire [WBLSB+AW-1:0]\tf_const_addr, f_address;",
            "wire f_const_illegal;",
            "wire [INSN_WIDTH-1:0]\tf_const_insn;",
            "wire f_fifo_extra;",
            "wire [(F_LGDEPTH-1):0]\tf_nreqs, f_nacks, f_outstanding;",
            "wire [INSN_WIDTH-1:0]\tf_insn;\n\n\t(* anyconst *)",
            "reg [BUS_WIDTH-1:0]\t\tf_const_word;\n\t(* anyconst *)",
            "reg fnvr_err;",
            "reg f_this_return, f_this_fifo;",
            "reg [AW-1:0]\tf_return_addr;\n\n\n\n\t// Keep track of a flag telling us whether or not $past()\n\t// will return valid results\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\t//\n\t// Assume we start from a reset condition\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions about our",
            "input s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tffetch #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(AW + WBLSB-INLSB), .OPT_CONTRACT(1'b1),\n\t\t.INSN_WIDTH(INSN_WIDTH)\n\t\t// }}}\n\t) fcpu(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.cpu_new_pc(i_new_pc),\n\t\t.cpu_clear_cache(i_clear_cache),\n\t\t.cpu_pc(i_pc), .cpu_ready(i_ready), .pf_valid(o_valid),\n\t\t.pf_insn(o_insn), .pf_pc(o_pc), .pf_illegal(o_illegal),\n\t\t.fc_pc(f_const_addr), .fc_illegal(f_const_illegal),\n\t\t.fc_insn(f_const_insn), .f_address(f_address)\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tbegin\n\t\tassume(f_address[INLSB-1:0] == 0);\n\tend\n\n\talways @(*)\n\tbegin\n\t\tf_return_addr = o_wb_addr - wb_pending;\n\t\tf_this_return = (f_return_addr == f_const_addr[WBLSB +: AW]);\n\tend\n\n\talways @(*)\n\tif (f_this_return)\n\tbegin\n\t\tif (f_const_illegal)\n\t\t\tassume(!i_wb_ack);\n\t\telse\n\t\t\tassume(!i_wb_err);\n\n\t\tif (i_wb_ack)\n\t\t\tassume(i_wb_data == f_const_word);\n\tend\n\n\t// f_const_word -- a wide bus word to check against\n\t// {{{\n\tgenerate if (INSN_WIDTH == BUS_WIDTH)\n\tbegin : F_CONST_NOSHIFT\n\t\talways @(*)\n\t\t\tassume(f_const_word == f_const_insn);\n\tend else begin : F_CONST_SHIFT",
            "wire [WBLSB-INLSB-1:0]\tf_shift, f_shift_now;",
            "wire [BUS_WIDTH-1:0]\t\tf_shifted, f_now;",
            "wire [INSN_WIDTH-1:0]\tf_insn_check, f_insn_now;",
            "wire f_now_check;\n\n\t\tassign\tf_shift = f_const_addr[WBLSB-1:INLSB];\n\t\tassign\tf_shift_now = f_const_addr[WBLSB-1:INLSB] - o_pc[WBLSB-1:INLSB];\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tassign\tf_shifted = f_const_word >> (INSN_WIDTH * f_shift);\n\t\t\tassign\tf_insn_check = f_shifted[INSN_WIDTH-1:0];\n\n\n\t\t\tassign\tf_now = f_wide_data >> (INSN_WIDTH * f_shift_now);\n\t\t\tassign\tf_insn_now = f_now[INSN_WIDTH-1:0];\n\t\tend else begin\n\t\t\tassign\tf_shifted = f_const_word << (INSN_WIDTH * f_shift);\n\t\t\tassign\tf_insn_check = f_shifted[BUS_WIDTH-1:BUS_WIDTH-INSN_WIDTH];\n\n\t\t\tassign\tf_now = f_wide_data << (INSN_WIDTH * f_shift_now);\n\t\t\tassign\tf_insn_now = f_now[BUS_WIDTH-1:BUS_WIDTH-INSN_WIDTH];\n\t\tend\n\n\t\tassign\tf_now_check = o_valid && !o_illegal\n\t\t\t\t&& o_pc[WBLSB +: AW]==f_const_addr[WBLSB +: AW]\n\t\t\t\t&& f_const_addr[WBLSB-1:INLSB] >= o_pc[WBLSB-1:INLSB];\n\n\t\talways @(*)\n\t\t\tassume(f_insn_check == f_const_insn);\n\n\t\talways @(*)\n\t\tif (f_past_valid && f_now_check)\n\t\t\tassert(f_insn_now == f_const_insn);\n\n\tend endgenerate\n\t// }}}\n\n`ifdef\tSKIPME\n\t// {{{\n\t// Let's make some assumptions about how long it takes our\n\t// phantom bus and phantom CPU to respond.\n\t//\n\t// These delays need to be long enough to flush out any potential\n\t// errors, yet still short enough that the formal method doesn't\n\t// take forever to solve.\n\t//",
            "localparam F_CPU_DELAY = 4;\n\n\n\t// Now, let's repeat this bit but now looking at the delay the CPU\n\t// takes to accept an instruction.\n\talways @(posedge i_clk)\n\t// If no instruction is ready, then keep our counter at zero\n\tif ((!o_valid)||(i_ready))\n\t\tf_cpu_delay <= 0;\n\telse\n\t\t// Otherwise, count the clocks the CPU takes to respond\n\t\tf_cpu_delay <= f_cpu_delay + 1'b1;\n\n`ifdef\tPFCACHE\n\talways @(posedge i_clk)\n\t\tassume(f_cpu_delay < F_CPU_DELAY);\n`endif\n\t// }}}\n`else\n\talways @(*)\n\t\tf_cpu_delay = 0;\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// FIFO checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg [AW-1:0]\tfifo_addr, f_first_wbaddr, f_second_wbaddr;",
            "reg f_first_is_last, f_second_is_last,\n\t\t\t\tf_known_return;\n\n\tassign\tf_fifo_extra = o_valid && (INSN_WIDTH != BUS_WIDTH);\n\n\t// Relating o_pc to o_wb_addr\n\talways @(*)\n\tbegin\n\t\tif (pending_err)\n\t\t\tfifo_addr = o_pc[WBLSB +: AW] + (f_fifo_extra ? 1:0);\n\t\telse begin\n\t\t\tfifo_addr = o_wb_addr - pipe_fill;\n\t\t\tif (f_fifo_extra)\n\t\t\t\tfifo_addr = fifo_addr + 1;\n\t\tend\n\n\t\tf_this_fifo = !sfifo_empty\n\t\t\t\t&& (fifo_addr == f_const_addr[WBLSB +: AW]);\n\n\t\tf_first_wbaddr  = o_pc[WBLSB +: AW] + f_distance_to_first;\n\t\tf_second_wbaddr = o_pc[WBLSB +: AW] + f_distance_to_second;\n\n\t\tif(f_fifo_extra)\n\t\tbegin\n\t\t\tf_first_wbaddr  = f_first_wbaddr  + 1;\n\t\t\tf_second_wbaddr = f_second_wbaddr + 1;\n\t\tend\n\n\t\tf_first_is_last = (f_distance_to_first + 1 == sfifo_fill);\n\t\tf_second_is_last = (f_distance_to_second + 1 == sfifo_fill);\n\n\t\tf_known_return = (f_first_in_fifo && f_distance_to_first==0)\n\t\t\t|| (f_second_in_fifo && f_distance_to_second == 0);\n\tend\n\n\talways @(*)\n\tif (f_past_valid && (o_valid || o_wb_cyc || sfifo_fill > 0))\n\t\tassert(o_pc == f_address);\n\n\talways @(*)\n\tif (!sfifo_reset && !o_illegal && !pending_err)\n\t\tassert(o_pc[WBLSB +: AW] == fifo_addr - f_fifo_extra);\n\n\talways @(*)\n\tif (f_past_valid)\n\tbegin\n\t\tif (f_first_in_fifo&& !o_illegal && f_first_wbaddr\n\t\t\t\t\t\t== f_const_addr[WBLSB +: AW])\n\t\tbegin\n\t\t\tif (f_const_illegal)\n\t\t\t\tassert(f_first_data[BUS_WIDTH]);\n\t\t\telse\n\t\t\t\tassert(f_first_data== { 1'b0,f_const_word });\n\t\tend\n\n\t\tif (f_second_in_fifo&& !o_illegal && f_second_wbaddr\n\t\t\t\t\t\t== f_const_addr[WBLSB +: AW])\n\t\tbegin\n\t\t\tif (f_const_illegal)\n\t\t\t\tassert(f_second_data[BUS_WIDTH]);\n\t\t\telse\n\t\t\t\tassert(f_second_data=={ 1'b0,f_const_word });\n\t\tend\n\n\t\tif (f_first_in_fifo && !f_first_is_last)\n\t\t\tassert(!f_first_data[BUS_WIDTH]);\n\t\tif (f_second_in_fifo && !f_second_is_last)\n\t\t\tassert(!f_second_data[BUS_WIDTH]);\n\t\tif (!f_known_return)\n\t\tbegin\n\t\t\tif (sfifo_fill > 1)\n\t\t\t\tassume(!pf_err);\n\t\t\tif (!pending_err)\n\t\t\t\tassume(!pf_err);\n\t\t\tif (f_this_fifo)\n\t\t\tbegin\n\t\t\t\tif (f_const_illegal)\n\t\t\t\t\tassume(pf_err);\n\t\t\t\telse\n\t\t\t\t\tassume(!pf_err && sfifo_word == f_const_word);\n\t\t\tend\n\t\tend\n\n\t\tif (!pending_err)\n\t\t\tassert(!o_illegal);\n\t\tif (o_valid && f_const_addr[WBLSB +: AW] == o_pc[WBLSB +: AW])\n\t\tbegin\n\t\t\tif (f_const_illegal)\n\t\t\t\tassert(o_illegal);\n\t\tend\n\n\t\tif (pending_err)\n\t\tbegin\n\t\t\tif (f_first_in_fifo && f_first_is_last)\n\t\t\tbegin\n\t\t\t\tassert(f_first_data[BUS_WIDTH]);\n\t\t\tend else if (f_second_in_fifo && f_second_is_last)\n\t\t\tbegin\n\t\t\t\tassert(f_second_data[BUS_WIDTH]);\n\t\t\tend else if (sfifo_fill == 1)\n\t\t\t\tassume(pf_err);\n\t\tend else begin\n\t\t\tif (f_first_in_fifo)\n\t\t\t\tassert(!f_first_data[BUS_WIDTH]);\n\t\t\tif (f_second_in_fifo)\n\t\t\t\tassert(!f_second_data[BUS_WIDTH]);\n\t\tend\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about our",
            "output s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.AW(AW), .DW(BUSW), .F_LGDEPTH(F_LGDEPTH),\n\t\t.F_MAX_STALL(2), .F_MAX_ACK_DELAY(3),\n\t\t.F_MAX_REQUESTS(0), .F_OPT_SOURCE(1),\n\t\t.F_OPT_RMW_BUS_OPTION(0),\n\t\t.F_OPT_DISCONTINUOUS(0)\n\t\t// }}}\n\t) f_wbm(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_wb_cyc(o_wb_cyc), .i_wb_stb(o_wb_stb),\n\t\t.i_wb_we(o_wb_we), .i_wb_addr(o_wb_addr),\n\t\t\t.i_wb_data(o_wb_data), .i_wb_sel(o_wb_sel),\n\t\t.i_wb_ack(i_wb_ack), .i_wb_stall(i_wb_stall),\n\t\t\t.i_wb_data(i_wb_data), .i_wb_err(i_wb_err),\n\t\t.f_nreqs(f_nreqs), .f_nacks(f_nacks),\n\t\t\t.f_outstanding(f_outstanding)\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (fnvr_err)\n\t\tassume(!i_wb_err);\n\n\talways @(*)\n\tif (!i_reset && fnvr_err)\n\tbegin\n\t\tassert(!pending_err);\n\t\tassert(!o_illegal);\n\tend\n\n\t// writes are also illegal for a prefetch.\n\talways @(posedge i_clk)\n\tif (o_wb_stb)\n\t\tassert(!o_wb_we);\n\n\talways @(posedge i_clk)\n\tbegin\n\t\tassert(f_outstanding == wb_pending);\n\t\tassert(pipe_fill >= wb_pending);\n\t\tif (!pending_err)\n\t\tbegin\n\t\t\tassert(pipe_fill >= sfifo_fill);\n\t\t\tassert(pipe_fill == sfifo_fill + wb_pending + f_fifo_extra);\n\t\tend\n\t\tassert(pipe_fill <= (1<<LGFIFO));\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about our return responses to the CPU\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (!sfifo_reset)\n\t\tassert(o_illegal || o_pc == f_address);\n\n\t//\n\t// If an instruction is accepted, we should *always* move on to another\n\t// instruction.  The only exception is following an i_new_pc (or\n\t// other invalidator), at which point the next instruction should\n\t// be invalid.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&& $past(o_valid && i_ready && !o_illegal && !i_new_pc))\n\tbegin\n\t\t// Should always advance the instruction pointer\n\t\tassert((!o_valid)||(o_pc != $past(o_pc)));\n\tend\n\n\t//\n\t// Once an instruction becomes valid, it should never become invalid\n\t// unless there's been a request for a new instruction.\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(sfifo_reset))\n\tbegin\n\t\tassert(!o_valid);\n\t\tassert(!o_illegal);\n\tend else if ($past(o_valid && !i_ready))\n\tbegin\n\t\tif (!$past(o_illegal))\n\t\tbegin\n\t\t\tassert(o_valid);\n\t\t\tassert(!o_illegal);\n\t\t\tassert($stable(o_insn));\n\t\tend else\n\t\t\tassert(o_illegal);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg f_valid_legal;\n\talways @(*)\n\t\tf_valid_legal = o_valid && (!o_illegal);\n\talways @(posedge i_clk)\t\t// Trace 0\n\t\tcover((o_valid)&&( o_illegal));\n\talways @(posedge i_clk)\t\t// Trace 1\n\t\tcover(f_valid_legal);\n\talways @(posedge i_clk)\t\t// Trace 2\n\t\tcover((f_valid_legal)\n\t\t\t&&($past(!o_valid && !i_new_pc))\n\t\t\t&&($past(i_new_pc,4)));\n\talways @(posedge i_clk)\n\t\tcover((f_valid_legal)&&($past(f_valid_legal && i_ready)));\n\talways @(posedge i_clk)\n\t\tcover((f_valid_legal)\n\t\t\t&&($past(f_valid_legal && i_ready))\n\t\t\t&&($past(f_valid_legal && i_ready,2))\n\t\t\t&&($past(f_valid_legal && i_ready,3)));\n\talways @(posedge i_clk)\n\t\tcover((f_valid_legal)\n\t\t\t&&($past(f_valid_legal && i_ready))\n\t\t\t&&($past(f_valid_legal && i_ready,2))\n\t\t\t&&($past(!o_illegal && i_ready && i_new_pc,5))\n\t\t\t&&($past(f_valid_legal && i_ready,6)));\n\t// }}}\n`endif\t// FORMAL\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "axiicache.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axiicache.v",
        "chunks": [
            "logic is driven by a couple realities:\n//\t1. It takes a clock to read from a block RAM address, and hence a clock\n//\t\tto read from the cache.\n//\t2. It takes another clock to check that the tag matches\n//\n//\t\tOur goal will be to avoid this second check if at all possible.\n//\t\tHence, we'll test on the clock of any given request whether\n//\t\tor not the request matches the last tag value, and on the next\n//\t\tclock whether it new tag value (if it has changed).  Hence,\n//\t\tfor anything found within the cache, there will be a one\n//\t\tcycle delay on any branch.\n//\n//\n//\tAddress Words are separated into three components:\n//\t[ Tag bits ] [ Cache line number ] [ Cache position w/in the line ]\n//\n//\tOn any read from the cache, only the second two components are required.\n//\tOn any read from memory, the first two components will be fixed across\n//\tthe bus, and the third component will be adjusted from zero to its\n//\tmaximum value.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype\tnone\n// }}}",
            "module axiicache #(\n\t\t// {{{\n\t\t// LGCACHESZ is the log(based two) of the cache size *in bytes*",
            "parameter LGCACHESZ = 14,\n\t\t//\n\t\t// LGLINESZ is the size of one cache line, represented in\n\t\t// words",
            "parameter LGLINESZ=3,\n\t\t//\n\t\t// LGWAYS is the number of cache \"ways\"\n\t\t//",
            "parameter LGWAYS = 0,\n\t\t//",
            "parameter C_AXI_ID_WIDTH = 1,",
            "parameter C_AXI_ADDR_WIDTH = 32,",
            "parameter C_AXI_DATA_WIDTH = 32,",
            "parameter [0:0]\tOPT_WRAP     = 1'b0,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,\n\t\t//\n\t\t// SWAP_ENDIANNESS",
            "parameter [0:0]\tSWAP_ENDIANNESS = 1'b0,\n\t\t//",
            "parameter INSN_WIDTH = 32,",
            "parameter [C_AXI_ID_WIDTH-1:0]\tAXI_ID = 0,",
            "localparam ADDRLSB = $clog2(C_AXI_DATA_WIDTH/8),",
            "localparam LGINSN  = $clog2(INSN_WIDTH/8),\n\t\t//",
            "localparam INSN_PER_WORD = C_AXI_DATA_WIDTH/INSN_WIDTH,",
            "localparam AW=C_AXI_ADDR_WIDTH,",
            "localparam DW=C_AXI_DATA_WIDTH,",
            "localparam LS=LGLINESZ, // Size of a cache line in words\n\t\t\t\tLSB=LGLINESZ+ADDRLSB\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,\n\t\t//\n\t\t// The AXI Master (cache) interface\n\t\t// {{{\n\t\t// An instruction cache only needs to support cache reads",
            "output ",
            "wire M_AXI_ARVALID,",
            "input ",
            "wire M_AXI_ARREADY,\n\t\t// verilator coverage_off",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_AXI_ARID,\n\t\t// verilator coverage_on",
            "output ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tM_AXI_ARADDR,",
            "output ",
            "wire [7:0]\t\t\tM_AXI_ARLEN,",
            "output ",
            "wire [2:0]\t\t\tM_AXI_ARSIZE,",
            "output ",
            "wire [1:0]\t\t\tM_AXI_ARBURST,\n\t\t// verilator coverage_off",
            "output ",
            "wire M_AXI_ARLOCK,\t// = 0",
            "output ",
            "wire [3:0]\t\t\tM_AXI_ARCACHE,",
            "output ",
            "wire [2:0]\t\t\tM_AXI_ARPROT,",
            "output ",
            "wire [3:0]\t\t\tM_AXI_ARQOS,\n\t\t// verilator coverage_on\n\t\t//",
            "input ",
            "wire M_AXI_RVALID,",
            "output ",
            "wire M_AXI_RREADY,\n\t\t// verilator coverage_off",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_AXI_RID,\n\t\t// verilator coverage_on",
            "input ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_AXI_RDATA,",
            "input ",
            "wire M_AXI_RLAST,",
            "input ",
            "wire [1:0]\t\t\tM_AXI_RRESP,\n\t\t// }}}\n\t\t// CPU interface\n\t\t// {{{",
            "input ",
            "wire i_cpu_reset,",
            "input ",
            "wire i_new_pc,",
            "input ",
            "wire i_clear_cache,",
            "input ",
            "wire i_ready,",
            "input ",
            "wire [AW-1:0]\ti_pc,",
            "output ",
            "wire [INSN_WIDTH-1:0] o_insn,",
            "output ",
            "reg [AW-1:0]\to_pc,",
            "output ",
            "reg o_valid,",
            "output ",
            "reg o_illegal\n\t\t// }}}\n`ifdef\tDEPRECATED",
            "output ",
            "wire [AW-1:0]\t\tillegal_addr,",
            "output ",
            "wire [AW-LSB-1:0]\tbus_tag,",
            "output ",
            "wire [AW-LSB-1:0]\to_tag,",
            "output ",
            "wire [AW-LSB-1:0]\ti_tag,",
            "output ",
            "wire [AW-LSB-1:0]\tlastpc_tag\n`endif\n\t\t// }}}\n\t);\n\n\t// Register/local",
            "parameter declarations\n\t// {{{",
            "localparam [1:0]\tINCR = 2'b01, WRAP = 2'b10;\n\n\t//",
            "localparam CACHELEN=(1<<LGCACHESZ); //Byte Size of our cache memory\n\t//",
            "localparam CACHELENW = CACHELEN/(C_AXI_DATA_WIDTH/8); // Word sz",
            "localparam CWB=LGCACHESZ, // Short hand for LGCACHESZ\n\t\t\tCW=LGCACHESZ-ADDRLSB; // now in words",
            "localparam LGLINES=CWB-LSB;\n\t//",
            "reg [DW-1:0]\tcache\t\t[0:((1<<CW)-1)];",
            "reg [(AW-CWB-1):0]\tcache_tags\t[0:((1<<(LGLINES))-1)];",
            "reg [((1<<(LGLINES))-1):0]\tcache_valid;",
            "reg [DW-1:0]\tcache_word;",
            "reg last_valid, from_pc, pc_valid,\n\t\t\t\tillegal_valid, request_pending, bus_abort,\n\t\t\t\tvalid_line;",
            "reg [AW-1:LSB]\tpc_tag, last_tag, illegal_tag;",
            "reg [LS-1:0]\twrite_posn;",
            "reg axi_arvalid;",
            "reg [AW-1:0]\taxi_araddr, last_pc;",
            "reg start_read;",
            "wire wrap_valid;",
            "wire [CWB-LSB-1:0]\taxi_line, pc_line, last_line;",
            "wire [AW-CWB-1:0]\taxi_tag;\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Check whether or not the instruction requested from the CPU is\n\t// in the cache or not\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// from_pc\n\t// {{{\n\t// Whether our next address comes from the just-give program counter\n\t// from the CPU, or from our own internal measure.  Why?  Because the\n\t// CPU will move on to the next address on the next cycle,",
            "reg ardless\n\t// of whether or not we meet this one, therefore we need to latch it\n\t// for later.\n\tinitial\tfrom_pc = 1;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_new_pc || i_clear_cache || (o_valid && i_ready))\n\t\tfrom_pc <= 1;\n\telse\n\t\tfrom_pc <= 0;\n\t// }}}\n\n\tassign\taxi_line = axi_araddr[CWB-1:LSB];\n\tassign\taxi_tag  = axi_araddr[AW-1:CWB];\n\tassign\tpc_line  = i_pc[CWB-1:LSB];\n\tassign\tlast_line= last_pc[CWB-1:LSB];\n\n\t//\n\t// From the PC\n\t// pc_valid\n\t// {{{\n\t// True if the cache is valid at the address in the program counter\n\talways @(posedge S_AXI_ACLK)\n\t\tpc_valid <= cache_valid[pc_line];\n\t// }}}\n\n\t// pc_tag\n\t// {{{\n\t// Evaluates to the cache tag, at the program counter address for the\n\t// incoming/requested program counter\n\talways @(posedge S_AXI_ACLK)\n\t\tpc_tag <= { cache_tags[pc_line], pc_line };\n\t// }}}\n\n\t//\n\t// Repeat for the last program counter--since the current counter\n\t// will be given only once.  The last_* values will be used any time\n\t// we have to stall a request before it can be served\n\t//\n\t// last_pc\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (i_new_pc || (o_valid && i_ready && !o_illegal))\n\t\tlast_pc <= i_pc;\n\t// }}}\n\n\t// last_valid\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\t\tlast_valid <= cache_valid[last_line];\n\t// }}}\n\n\t// last_tag\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\t\tlast_tag <= { cache_tags[last_line], last_line };\n\t// }}}\n\n\t// valid_line --- are we serving a valid request line?\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tvalid_line = 1'b0;\n\n\t\t// Zero delay lookup: New PC, but staying w/in same cache line\n\t\t//   This only works if the entire line is full--so no requests\n\t\t//   may be pending at this time.\n\t\tif (i_new_pc)\n\t\t\tvalid_line = !request_pending && pc_valid\n\t\t\t\t\t&& pc_tag == i_pc[AW-1:LSB];\n\t\telse if (o_valid && i_ready)\n\t\tbegin\n\t\t\t// Zero delay lookup, tag matches last lookup\n\t\t\tvalid_line = pc_valid && (i_pc[AW-1:LSB] == pc_tag[AW-1:LSB]);\n\t\t\tif (wrap_valid && i_pc[AW-1:LSB] == axi_araddr[AW-1:LSB])\n\t\t\t\tvalid_line = 1;\n\t\tend else begin\n\t\t\t// Longer lookups.  Several possibilities here.\n\n\t\t\t// 1. We might be working through recent reads from the\n\t\t\t//    cache, for which the cache line isn't yet full\n\t\t\tvalid_line = wrap_valid;\n\n\t\t\t// 2. One delay lookup.  Request was for an address with\n\t\t\t//    a different tag.  Since it was different, we had\n\t\t\t//    to do a memory read to look it up.  After lookup,\n\t\t\t//    the tag now matches.\n\t\t\tif (from_pc && pc_valid && pc_tag == last_pc[AW-1:LSB])\n\t\t\t\tvalid_line = 1'b1;\n\n\t\t\t// 3. Many delay lookup.  The tag didn't match, so we\n\t\t\t//    had to go search for it from memory.  The cache\n\t\t\t//    line is now valid, so now we can use it.\n\t\t\tif (!from_pc && last_valid\n\t\t\t\t\t&& last_tag == last_pc[AW-1:LSB])\n\t\t\t\tvalid_line = 1'b1;\n\n\t\t\t// 4. Illegal lookup.\n\t\t\tif (!o_valid && illegal_valid && illegal_tag == last_pc[AW-1:LSB])\n\t\t\t\tvalid_line = 1;\n\t\tend\n\tend\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Request data from the AXI bus to fill a cache miss\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// start_read\n\t// {{{\n\t// Issue a bus transaction -- the cache line requested couldn't be\n\t// found in the bus anywhere, so we need to go look for it",
            "reg wait_on_read;\n\tinitial\twait_on_read = 1;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\twait_on_read <= 1;\n\telse begin\n\t\twait_on_read <= request_pending; // M_AXI_RVALID && M_AXI_RLAST;\n\t\tif (i_clear_cache || i_new_pc || i_cpu_reset)\n\t\t\twait_on_read <= 1;\n\tend\n\n\talways @(*)\n\tbegin\n\t\tstart_read = !valid_line && !o_valid;\n\t\tif (i_clear_cache || i_new_pc || wait_on_read)\n\t\t\tstart_read = 0;\n\t\tif (o_illegal)\n\t\t\tstart_read = 0;\n\t\tif (M_AXI_ARVALID)\n\t\t\tstart_read = 0;\n\t\tif (request_pending || i_cpu_reset || !S_AXI_ARESETN)\n\t\t\tstart_read = 0;\n\tend\n\t// }}}\n\n\t// axi_arvalid\n\t// {{{\n\tinitial\taxi_arvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_arvalid <= 0;\n\telse if (!M_AXI_ARVALID || M_AXI_ARREADY)\n\t\taxi_arvalid <= start_read;\n\t// }}}\n\n\t// request_pending, bus_abort\n\t// {{{\n\tinitial\trequest_pending = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\tbegin\n\t\trequest_pending <= 0;\n\t\tbus_abort <= 0;\n\tend else if (request_pending)\n\tbegin\n\t\tif (i_cpu_reset || i_clear_cache)\n\t\t\tbus_abort <= 1;\n\t\tif (M_AXI_RVALID && M_AXI_RRESP[1])\n\t\t\tbus_abort <= 1;\n\t\tif (i_new_pc && i_pc[AW-1:LSB] != axi_araddr[AW-1:LSB])\n\t\t\tbus_abort <= 1;\n\n\t\tif (M_AXI_RVALID && M_AXI_RLAST)\n\t\tbegin\n\t\t\trequest_pending <= 0;\n\t\t\tbus_abort <= 0;\n\t\tend\n\tend else if (!M_AXI_ARVALID || M_AXI_ARREADY)\n\tbegin\n\t\trequest_pending <= start_read;\n\t\tbus_abort <= 0;\n\tend\n\t// }}}\n\n\t// axi_araddr\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif ((!M_AXI_ARVALID || M_AXI_ARREADY) && !request_pending)\n\tbegin\n\t\taxi_araddr <= last_pc;\n\t\tif (OPT_WRAP)\n\t\t\taxi_araddr[ADDRLSB-1:0] <= 0;\n\t\telse\n\t\t\taxi_araddr[LSB-1:0] <= 0;\n\n\t\tif (OPT_LOWPOWER && !start_read)\n\t\t\taxi_araddr <= 0;\n\tend\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Fill the cache with the new data\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// write_posn -- the sub-address w/in the cache to write to\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!request_pending)\n\t\twrite_posn <= (OPT_WRAP) ? last_pc[LSB-1:ADDRLSB] : 0;\n\telse if (M_AXI_RVALID && M_AXI_RREADY)\n\t\twrite_posn <= write_posn + 1;\n\t// }}}\n\n\t// cache -- Actually do the write to cache memory\n\t// {{{\n\tgenerate if (SWAP_ENDIANNESS)\n\tbegin : BIG_TO_LITTLE_ENDIAN\n\t\t// {{{\n\t\t//\n\t\t// The ZipCPU is originally a big endian machine.  Bytes on the\n\t\t// AXI bus are by nature little endian.  The following little\n\t\t// snippet rearranges bytes so that they have the proper bus\n\t\t// order.  Whether or not this is required, however, is ...\n\t\t// another issue entirely.",
            "reg [C_AXI_DATA_WIDTH-1:0]\tswapped_data;\n\t\tgenvar\tgw, gb;\t// Word count, byte count\n\n\t\tfor(gw=0; gw<C_AXI_DATA_WIDTH/32; gw=gw+1)\n\t\tbegin\n\t\t\tfor(gb=0; gb<4; gb=gb+1)\n\t\t\tbegin\n\t\t\t\talways @(*)\n\t\t\t\tswapped_data[gw*32+(3-gb)*8 +: 8]\n\t\t\t\t\t= M_AXI_RDATA[gw*32+gb*8 +: 8];\n\t\t\tend\n\t\tend\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (M_AXI_RVALID && M_AXI_RREADY)\n\t\t\tcache[{ axi_araddr[CWB-1:LSB], write_posn }]\n\t\t\t\t\t\t\t<= swapped_data;\n\t\t// }}}\n\tend else begin : KEEP_ENDIANNESS\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (M_AXI_RVALID && M_AXI_RREADY)\n\t\t\tcache[{ axi_araddr[CWB-1:LSB], write_posn }]\n\t\t\t\t\t\t\t<= M_AXI_RDATA;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// cache_tags, set/control/write-to the cache tags array\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (request_pending)\n\t\tcache_tags[axi_line] <= axi_tag;\n\t// }}}\n\n\t// cache_valid--keep track of which cache entry has valid data w/in it\n\t// {{{\n\tinitial\tcache_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_cpu_reset || i_clear_cache)\n\t\tcache_valid <= 0;\n\telse if (request_pending)\n\t\tcache_valid[axi_line]\n\t\t\t<= (M_AXI_RVALID && M_AXI_RREADY && M_AXI_RLAST\n\t\t\t\t&& !M_AXI_RRESP[1]);\n\t// }}}\n\n\t// wrap_valid\n\t// {{{\n\tgenerate if (OPT_WRAP)\n\tbegin : GEN_WRAP_VALID\n\t\t// {{{",
            "reg r_wrap, r_valid, r_poss;",
            "reg [(1<<LS):0]\tr_count;\n\n\t\t// r_wrap-- Can we keep continuing prior to the cache being vld?\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_wrap <= 0;\n\t\telse if (M_AXI_ARVALID)\n\t\t\tr_wrap <= 1;\n\t\telse if (M_AXI_RVALID && (&write_posn))\n\t\t\tr_wrap <= 0;\n\t\t// }}}\n\n\t\t// r_poss, r_count\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\tr_poss  <= 0;\n\t\t\tr_count <= 0;\n\t\tend else if (i_new_pc || i_clear_cache || i_cpu_reset\n\t\t\t|| (M_AXI_RVALID && (M_AXI_RLAST||M_AXI_RRESP[1])))\n\t\tbegin\n\t\t\tr_poss  <= 0;\n\t\t\tr_count <= 0;\n\t\tend else if (M_AXI_ARVALID && M_AXI_ARADDR[AW-1:ADDRLSB] == last_pc[AW-1:ADDRLSB])\n\t\tbegin\n\t\t\tr_poss  <= !bus_abort;\n\t\t\tr_count <= 0;\n\t\tend else if (r_poss)\n\t\tcase({ (M_AXI_RVALID && M_AXI_RREADY && r_wrap),\n\t\t\t\t\t\t(o_valid && i_ready)})\n\t\t2'b01: begin\n\t\t\tr_count <= r_count - 1;\n\t\t\tr_poss  <= (r_count > 1) || r_wrap;\n\t\t\tend\n\t\t2'b10: r_count <= r_count + 1;\n\t\t// 2'b00:\n\t\t// 2'b11:\n\t\tdefault: begin end\n\t\tendcase\n\t\t// }}}\n\n\t\t// wrap_valid itself\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_valid  <= 0;\n\t\telse if (i_cpu_reset || i_new_pc || i_clear_cache || bus_abort\n\t\t\t\t|| (M_AXI_RVALID && M_AXI_RRESP[1])\n\t\t\t\t|| !r_poss)\n\t\t\tr_valid  <= 0;\n\t\telse if (!r_valid || !o_valid || i_ready)\n\t\tbegin\n\t\t\t// We can be valid if there's one more in the buffer\n\t\t\t// than we've read so far.\n\t\t\tr_valid <=(r_count >\n\t\t\t\t((r_valid&&(!o_valid||i_ready)) ? 1:0)\n\t\t\t\t+ (o_valid ? 1:0));\n\t\t\t// We can also be valid if another one has just been\n\t\t\t//   read--as long as it's not due to a bus error.\n\t\t\tif (M_AXI_RVALID && r_wrap)\n\t\t\t\tr_valid <= 1'b1;\n\t\tend\n\n\t\tassign\twrap_valid = r_valid;\n\t\t// }}}\n\n`ifdef\tFORMAL\n\t\t// {{{\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && M_AXI_ARVALID)\n\t\t\tassert(!r_valid && r_count == 0);\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && (!request_pending || bus_abort))\n\t\t\tassert(!r_poss);\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !r_poss)\n\t\t\tassert(r_count == 0);\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && r_poss)\n\t\tbegin\n\t\t\tif (!r_wrap)\n\t\t\t\tassert(r_count < write_posn\n\t\t\t\t\t\t- last_pc[LSB-1:ADDRLSB]);\n\t\t\telse\n\t\t\t\tassert(r_count <= (1<<LS) - last_pc[LSB-1:ADDRLSB]);\n\t\tend\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && (r_poss || r_valid))\n\t\t\tassert(last_pc[AW-1:LSB] == axi_araddr[AW-1:LSB]);\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && request_pending)\n\t\t\tassert(r_valid == (r_count > (o_valid ? 1:0)));\n\t\t// }}}\n`endif\n\t\t// }}}\n\tend else begin : NO_WRAP_MODE\n\t\t// {{{\n\t\tassign\twrap_valid = 1'b0;\n\n\t\t// verilator coverage_off\n\t\t// verilator lint_off UNUSED",
            "wire unused_nowrap;\n\t\tassign\tunused_nowrap = &{ 1'b0, bus_abort };\n\t\t// verilator lint_on UNUSED\n\t\t// verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read the instruction from the cache\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// cache_word -- the cache word at the requested address\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (i_new_pc || (!o_valid || i_ready))\n\tbegin\n\t\tcache_word <= cache[(i_new_pc || o_valid)\n\t\t\t\t? i_pc[CWB-1:ADDRLSB] : o_pc[CWB-1:ADDRLSB]];\n\tend\n\t// }}}\n\n\t// o_insn\n\t// {{{\n\t// Generate the outgoing instruction from the given cache_word\n\t// This involves shifting large cache words down to the desired/correct\n\t// word of interest\n\tgenerate if (C_AXI_DATA_WIDTH == INSN_WIDTH)\n\tbegin : NO_LINE_SHIFT\n\n\t\tassign\to_insn = cache_word;\n\n\t\t// Make Verilator happy\n\t\t// {{{\n\t\t// Verilator lint_off UNUSED\n\t\tif (DW > INSN_WIDTH)\n\t\tbegin : GEN_UNUSED_WIDE",
            "wire unused_wide;\n\t\t\tassign\tunused_wide = &{ 1'b0, cache_word[DW-1:INSN_WIDTH] };\n\t\tend\n\t\t// Verilator lint_on  UNUSED\n\t\t// }}}\n\tend else begin : SHIFT_CACHE_LINE",
            "reg [C_AXI_DATA_WIDTH-1:0]\tshifted;\n\n\t\talways @(*)\n\t\t\tshifted=cache_word >> (INSN_WIDTH * o_pc[ADDRLSB-1:LGINSN]);\n\n\t\tassign\to_insn = shifted[INSN_WIDTH-1:0];\n\n\t\t// Make Verilator happy\n\t\t// {{{\n\t\t// Verilator lint_off UNUSED\n\t\tif (DW > INSN_WIDTH)\n\t\tbegin : GEN_UNUSED_WIDE",
            "wire unused_wide;\n\t\t\tassign\tunused_wide = &{ 1'b0, shifted[DW-1:INSN_WIDTH] };\n\t\tend\n\t\t// Verilator lint_on  UNUSED\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// o_pc\n\t// {{{\n\t// Signal the CPU with the actual address of the value we are returning\n\t// The ffetch properties will insure this value is correct.  This CPU\n\t// then uses it for knowing the program counter of the instruction\n\t// contained within each stage of the pipeline\n\tinitial\to_pc = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_new_pc)\n\t\to_pc <= i_pc;\n\telse if (o_valid && i_ready)\n\tbegin\n\t\to_pc[AW-1:2] <= o_pc[AW-1:2]+1;\n\t\to_pc[1:0]    <= 0;\n\tend\n\t// }}}\n\n\t// o_valid\n\t// {{{\n\t// Are we returning a valid instruction to the CPU on this cycle?\n\tinitial\to_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_cpu_reset || i_clear_cache)\n\t\to_valid <= 0;\n\telse if (o_valid && (i_ready || i_new_pc))\n\tbegin\n\t\t// Grab the next instruction--always ready on the same cycle\n\t\t// if we stay within the same cache line\n\t\to_valid <= valid_line;\n\t\tif (o_illegal)\n\t\t\to_valid <= 0;\n\tend else if (!o_valid && !i_new_pc)\n\tbegin\n\t\t// We're stuck waiting for the cache line to become valid.\n\t\t// Don't forget to check for the illegal flag.\n\t\to_valid <= valid_line;\n\t\tif (illegal_valid && o_pc[AW-1:LSB] == illegal_tag)\n\t\t\to_valid <= 1;\n\tend\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Handle bus errors here.\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// If a bus read request returns an error, then we'll mark the entire\n\t// line as having a (valid) illegal value.  Once the o_illegal value\n\t// is set, it will remain set until either the CPU branches, or the\n\t// cache is cleared.\n\t//\n\n\t// illegal_tag, illegal_valid\n\t// {{{\n\t// Here's the rule: if illegal_valid is true, then we know that address\n\t// at that illegal_tag value will produce a bus error, and we can serve\n\t// a bus error request response on any read request.\n\tinitial\tillegal_tag = 0;\n\tinitial\tillegal_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif ((i_cpu_reset)||(i_clear_cache))\n\tbegin\n\t\tillegal_tag <= 0;\n\t\tillegal_valid <= 0;\n\tend else if (M_AXI_RVALID && M_AXI_RRESP[1])\n\tbegin\n\t\tillegal_tag <= axi_araddr[AW-1:LSB];\n\t\tillegal_valid <= 1'b1;\n\tend\n\t// }}}\n\n\t// o_illegal\n\t// {{{\n\tinitial o_illegal = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_cpu_reset || i_clear_cache || i_new_pc)\n\t\to_illegal <= 1'b0;\n\telse if (o_valid && !o_illegal)\n\t\to_illegal <= 1'b0;\n\telse if (illegal_valid && o_pc[AW-1:LSB] == illegal_tag)\n\t\to_illegal <= 1'b1;\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Fixed/constant bus values, map",
            "reg isters to AXI",
            "wire s/ etc.\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Fixed bus",
            "output s: we read from the bus only, never write.\n\t// Thus the",
            "output data is ... irrelevant and don't care.  We set it\n\t// to zero just to set it to something.\n\tassign\tM_AXI_ARVALID= axi_arvalid;\n\tassign\tM_AXI_ARID   = AXI_ID;\n\tassign\tM_AXI_ARADDR = axi_araddr;\n\tassign\tM_AXI_ARLEN  = (1<<LS)-1;\n\tassign\tM_AXI_ARSIZE = ADDRLSB[2:0];\n\t// ARBURST.  AXI supports a WRAP burst specifically for the purpose\n\t// of a CPU.  Not all peripherals support it.  For compatibility and\n\t// simplicities sake, we'll just use INCR here.\n\tassign\tM_AXI_ARBURST= (OPT_WRAP) ? WRAP : INCR;\n\tassign\tM_AXI_ARLOCK = 0;\n\tassign\tM_AXI_ARCACHE= 4'b0011;\n\t// ARPROT = 3'b100 for an unprivileged, secure instruction access\n\t// (not sure what unprivileged or secure mean--even after reading the\n\t//  spec)\n\tassign\tM_AXI_ARPROT = 3'b100;\n\tassign\tM_AXI_ARQOS  = 4'h0;\n\tassign\tM_AXI_RREADY = 1'b1;\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, M_AXI_RID, M_AXI_RRESP[0] };\n\t// Verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal property section\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "reg f_past_valid;",
            "reg [4:0]\tf_cpu_delay;",
            "reg [((1<<(LGLINES))-1):0]\tf_past_valid_mask;",
            "reg [(AW+1):0]\tf_next_pc;",
            "reg [AW+1:0]\tf_next_lastpc;",
            "reg [AW-1:0]\tf_cklast, f_ckfirst;",
            "reg [AW-1:0]\tnext_addr;\n\n\n\t// Keep track of a flag telling us whether or not $past()\n\t// will return valid results\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\t\tf_past_valid = 1'b1;\n\n\talways @(*)\n\tif (!S_AXI_ARESETN)\n\t\tassume(i_cpu_reset);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions about our",
            "input s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "wire [AW-1:0]\tf_const_addr, f_address;",
            "wire f_const_illegal;",
            "wire [INSN_WIDTH-1:0]\tf_const_insn;\n\n\t//\n\t// Assume/assert the properties of the PF <-> CPU interface\n\t//\n\tffetch #(.ADDRESS_WIDTH(AW-LGINSN))\n\tfcpu(.i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset),\n\t\t.cpu_new_pc(i_new_pc), .cpu_clear_cache(i_clear_cache),\n\t\t.cpu_pc(i_pc), .cpu_ready(i_ready), .pf_valid(o_valid),\n\t\t.pf_insn(o_insn), .pf_pc(o_pc), .pf_illegal(o_illegal),\n\t\t.fc_pc(f_const_addr), .fc_illegal(f_const_illegal),\n\t\t.fc_insn(f_const_insn), .f_address(f_address));\n\n\talways @(*)\n\tif (!i_cpu_reset && !i_new_pc && !i_clear_cache)\n\t\tassert(o_pc == f_address);\n\n\t//\n\t// Let's make some assumptions about how long it takes our\n\t// phantom bus and phantom CPU to respond.\n\t//\n\t// These delays need to be long enough to flush out any potential\n\t// errors, yet still short enough that the formal method doesn't\n\t// take forever to solve.\n\t//",
            "localparam F_CPU_DELAY = 4;\n\n\n\t// Now, let's repeat this bit but now looking at the delay the CPU\n\t// takes to accept an instruction.\n\talways @(posedge S_AXI_ACLK)\n\t// If no instruction is ready, then keep our counter at zero\n\tif ((!o_valid)||(i_ready))\n\t\tf_cpu_delay <= 0;\n\telse\n\t\t// Otherwise, count the clocks the CPU takes to respond\n\t\tf_cpu_delay <= f_cpu_delay + 1'b1;\n\n\talways @(posedge S_AXI_ACLK)\n\t\tassume(f_cpu_delay < F_CPU_DELAY);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Formal AXI bus properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "localparam F_LGDEPTH=12;",
            "wire M_AXI_AWREADY = 0, M_AXI_WREADY = 0, M_AXI_BVALID = 0;",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_AXI_BID = 0;",
            "wire [1:0]\t\t\tM_AXI_BRESP = 0;",
            "wire [F_LGDEPTH-1:0]\tfaxi_awr_nbursts, faxi_wr_pending,\n\t\t\t\tfaxi_rd_nbursts, faxi_rd_outstanding;",
            "wire [C_AXI_ID_WIDTH-1:0]\tfaxi_rd_checkid;",
            "wire faxi_rd_ckvalid;",
            "wire [9-1:0]\t\t\tfaxi_rd_cklen;",
            "wire [AW-1:0]\t\tfaxi_rd_ckaddr;",
            "wire [7:0]\t\t\tfaxi_rd_ckincr;",
            "wire [1:0]\t\t\tfaxi_rd_ckburst;",
            "wire [2:0]\t\t\tfaxi_rd_cksize;",
            "wire [7:0]\t\t\tfaxi_rd_ckarlen;",
            "wire faxi_rd_cklockd;\n\t//",
            "wire [F_LGDEPTH-1:0]\t\tfaxi_rdid_nbursts,\n\t\t\t\t\tfaxi_rdid_outstanding,\n\t\t\t\t\tfaxi_rdid_ckign_nbursts,\n\t\t\t\t\tfaxi_rdid_ckign_outstanding;\n\n\tfaxi_master #(\n\t\t// {{{\n\t\t.C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),\n\t\t.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),\n\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t.OPT_NARROW_BURST(1'b0),\n\t\t.OPT_ASYNC_RESET(1'b0),\t// We don't use asynchronous resets\n\t\t.OPT_EXCLUSIVE(1'b0),\t// We don't use the LOCK signal\n\t\t.F_OPT_ASSUME_RESET(1'b1), // We aren't generating the reset\n\t\t.F_OPT_NO_RESET(1'b1),\n\t\t.F_LGDEPTH(F_LGDEPTH)\t// Width of the counters\n\t\t// }}}\n\t) faxi(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN),\n\t\t// Write signals\n\t\t// {{{\n\t\t.i_axi_awvalid(1'b0),\n\t\t.i_axi_awready(M_AXI_AWREADY),\n\t\t.i_axi_awid(   M_AXI_ARID),\n\t\t.i_axi_awaddr( M_AXI_ARADDR),\n\t\t.i_axi_awlen(  M_AXI_ARLEN),\n\t\t.i_axi_awsize( M_AXI_ARSIZE),\n\t\t.i_axi_awburst(M_AXI_ARBURST),\n\t\t.i_axi_awlock( M_AXI_ARLOCK),\n\t\t.i_axi_awcache(M_AXI_ARCACHE),\n\t\t.i_axi_awprot( M_AXI_ARPROT),\n\t\t.i_axi_awqos(  M_AXI_ARQOS),\n\t\t//\n\t\t.i_axi_wvalid(1'b0),\n\t\t.i_axi_wready(M_AXI_WREADY),\n\t\t.i_axi_wdata( {(C_AXI_DATA_WIDTH  ){1'b0}}),\n\t\t.i_axi_wstrb( {(C_AXI_DATA_WIDTH/8){1'b0}}),\n\t\t.i_axi_wlast( 1'b0),\n\t\t//\n\t\t.i_axi_bvalid(M_AXI_BVALID),\n\t\t.i_axi_bready(1'b1),\n\t\t.i_axi_bid(   M_AXI_BID),\n\t\t.i_axi_bresp( M_AXI_BRESP),\n\t\t// }}}\n\t\t// Read signals\n\t\t// {{{\n\t\t.i_axi_arvalid(M_AXI_ARVALID),\n\t\t.i_axi_arready(M_AXI_ARREADY),\n\t\t.i_axi_arid(   M_AXI_ARID),\n\t\t.i_axi_araddr( M_AXI_ARADDR),\n\t\t.i_axi_arlen(  M_AXI_ARLEN),\n\t\t.i_axi_arsize( M_AXI_ARSIZE),\n\t\t.i_axi_arburst(M_AXI_ARBURST),\n\t\t.i_axi_arlock( M_AXI_ARLOCK),\n\t\t.i_axi_arcache(M_AXI_ARCACHE),\n\t\t.i_axi_arprot( M_AXI_ARPROT),\n\t\t.i_axi_arqos(  M_AXI_ARQOS),\n\t\t//\n\t\t//\n\t\t.i_axi_rvalid(M_AXI_RVALID),\n\t\t.i_axi_rready(M_AXI_RREADY),\n\t\t.i_axi_rid(   M_AXI_RID),\n\t\t.i_axi_rdata( M_AXI_RDATA),\n\t\t.i_axi_rlast( M_AXI_RLAST),\n\t\t.i_axi_rresp( M_AXI_RRESP),\n\t\t// }}}\n\t\t// Induction signals\n\t\t// {{{\n\t\t.f_axi_awr_nbursts(faxi_awr_nbursts),\n\t\t.f_axi_wr_pending(faxi_wr_pending),\n\t\t.f_axi_rd_nbursts(faxi_rd_nbursts),\n\t\t.f_axi_rd_outstanding(faxi_rd_outstanding),\n\t\t//\n\t\t.f_axi_rd_checkid(faxi_rd_checkid),\n\t\t.f_axi_rd_ckvalid(faxi_rd_ckvalid),\n\t\t.f_axi_rd_cklen(  faxi_rd_cklen),\n\t\t.f_axi_rd_ckaddr( faxi_rd_ckaddr),\n\t\t.f_axi_rd_ckincr( faxi_rd_ckincr),\n\t\t.f_axi_rd_ckburst(faxi_rd_ckburst),\n\t\t.f_axi_rd_cksize( faxi_rd_cksize),\n\t\t.f_axi_rd_ckarlen(faxi_rd_ckarlen),\n\t\t.f_axi_rd_cklockd(faxi_rd_cklockd),\n\t\t.f_axi_rdid_nbursts(          faxi_rdid_nbursts),\n\t\t.f_axi_rdid_outstanding(      faxi_rdid_outstanding),\n\t\t.f_axi_rdid_ckign_nbursts(    faxi_rdid_ckign_nbursts),\n\t\t.f_axi_rdid_ckign_outstanding(faxi_rdid_ckign_outstanding)\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\n\talways @(*)\n\tbegin\n\t\tassert(faxi_awr_nbursts == 0);\n\t\tassert(faxi_wr_pending == 0);\n\tend\n\n\talways @(*)\n\tbegin\n\t\tif (faxi_rd_checkid == AXI_ID)\n\t\tbegin\n\t\t\tassert(faxi_rdid_nbursts == faxi_rd_nbursts);\n\t\t\tassert(faxi_rdid_outstanding == faxi_rd_outstanding);\n\t\tend else begin\n\t\t\tassert(faxi_rdid_nbursts == 0);\n\t\t\tassert(faxi_rdid_outstanding == 0);\n\t\tend\n\t\tassert(faxi_rd_nbursts <= 1);\n\t\tassert(faxi_rd_outstanding <= (1<<LS));\n\t\tassert(faxi_rd_nbursts == 0 || !M_AXI_ARVALID);\n\tend\n\n\talways @(*)\n\t\tassert(request_pending == (M_AXI_ARVALID\n\t\t\t\t\t\t|| faxi_rd_outstanding > 0));\n\n\talways @(*)\n\tbegin\n\t\tf_cklast = faxi_rd_ckaddr;\n\t\tf_cklast[AW-1:ADDRLSB] = f_cklast[AW-1:ADDRLSB] + faxi_rd_cklen\n\t\t\t\t- 1;\n\t\tf_cklast[ADDRLSB-1:0] = 0;\n\n\t\tf_ckfirst = faxi_rd_ckaddr;\n\t\tf_ckfirst[LSB-1:ADDRLSB]\n\t\t\t= f_ckfirst[LSB-1:ADDRLSB] + faxi_rd_cklen;\n\tend\n\n\talways @(*)\n\tif (faxi_rd_ckvalid)\n\tbegin\n\t\tassert(faxi_rd_ckarlen == M_AXI_ARLEN);\n\t\tassert(faxi_rd_cksize  == M_AXI_ARSIZE);\n\t\tassert(faxi_rd_ckburst == M_AXI_ARBURST);\n\t\tassert(!faxi_rd_cklockd);\n\t\tassert(faxi_rd_ckaddr[AW-1:LSB] == axi_araddr[AW-1:LSB]);\n\n\t\tassert(write_posn == faxi_rd_ckaddr[LSB-1:ADDRLSB]);\n\t\tif (!OPT_WRAP)\n\t\t\t// If we aren't in wrap mode, then the last address\n\t\t\t// should be the last address in a cache line\n\t\t\tassert(&f_cklast[LSB-1:ADDRLSB]);\n\tend else if (!OPT_WRAP)\n\tbegin\n\t\tassume(!M_AXI_RVALID || (M_AXI_RLAST == (&f_cklast[AW-1:LSB])));\n\n\t\tif (faxi_rd_outstanding > 0)\n\t\t\tassert(write_posn + faxi_rd_outstanding == (1<<LS));\n\tend\n\n\talways @(*)\n\tif (!OPT_WRAP && faxi_rd_nbursts > 0)\n\t\tassert(bus_abort || last_pc[AW-1:LSB] == axi_araddr[AW-1:LSB]);\n\n\talways @(*)\n\tbegin\n\t\tnext_addr = o_pc + (1<<LGINSN);\n\t\tnext_addr[LGINSN-1:0] = 0;\n\tend\n\n\talways @(*)\n\tif (!i_cpu_reset && !i_new_pc && !i_clear_cache && !o_illegal)\n\t\tassert(last_pc == o_pc);\n\n\talways @(*)\n\tif (!i_cpu_reset && !i_new_pc && !i_clear_cache)\n\t\tassert(next_addr == i_pc);\n\n`ifdef\tDEPRECATED\n\tassign\tillegal_addr = { illegal_tag, {(LSB){1'b0}} };\n\tassign\tbus_tag = axi_araddr[AW-1:LSB];\n\tassign\to_tag   = o_pc[AW-1:LSB];\n\tassign\ti_tag   = i_pc[AW-1:LSB];\n\tassign\tlastpc_tag= last_pc[AW-1:LSB];\n`endif\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about our return responses to the CPU\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge S_AXI_ACLK)\n\tif (f_past_valid && $past(i_clear_cache || i_cpu_reset))\n\tbegin\n\t\tassert(cache_valid == 0);\n\t\tassert(!o_valid);\n\t\tassert(!illegal_valid);\n\tend\n\n\talways @(posedge S_AXI_ACLK)\n\tif (S_AXI_ARESETN && o_valid && !o_illegal && !request_pending\n\t\t\t\t&& $past(!o_valid || i_ready))\n\tbegin\n\t\tif (!$past(wrap_valid))\n\t\tbegin\n\t\t\tif ($past(i_new_pc || (o_valid && i_ready)))\n\t\t\tbegin\n\t\t\t\tassert(pc_valid);\n\t\t\t\tassert(pc_tag == o_pc[AW-1:LSB]);\n\t\t\tend else begin\n\t\t\t\tassert(last_valid);\n\t\t\t\tassert(last_tag == o_pc[AW-1:LSB]);\n\t\t\tend\n\t\tend\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t(* anyconst *)",
            "reg [DW-1:0]\tfc_line;\n\n\t//\n\t// 1. Assume a known response to a known address\n\t// {{{\n\tgenerate if (INSN_WIDTH == C_AXI_DATA_WIDTH)\n\tbegin\n\t\talways @(*)\n\t\t\tassume(fc_line == f_const_insn);\n\n\tend else begin : SHIFT_FC_LINE",
            "reg [DW-1:0]\tshifted_line;\n\n\t\talways @(*)\n\t\t\tshifted_line = fc_line >> (INSN_WIDTH * f_const_addr[ADDRLSB-1:LGINSN]);\n\t\talways @(*)\n\t\t\tassume(shifted_line[INSN_WIDTH-1:0] == f_const_insn);\n\n\tend endgenerate\n\n\talways @(*)\n\tif (M_AXI_RVALID && axi_araddr[AW-1:LSB] == f_const_addr[AW-1:LSB])\n\t\tassume(f_const_illegal == M_AXI_RRESP[1]);\n\n\tgenerate if (SWAP_ENDIANNESS)\n\tbegin : ASSUME_BIG_TO_LITTLE_ENDIAN\n\n\t\talways @(*)\n\t\tif (M_AXI_RVALID && {axi_araddr[AW-1:LSB], write_posn} == f_const_addr[AW-1:ADDRLSB])\n\t\tbegin\n\t\t\tif (!M_AXI_RRESP[1])\n\t\t\t\tassume(BIG_TO_LITTLE_ENDIAN.swapped_data\n\t\t\t\t\t\t\t\t== fc_line);\n\t\tend\n\n\tend else begin : ASSUME_BUS_ENDIAN\n\n\t\talways @(*)\n\t\tif (M_AXI_RVALID && {axi_araddr[AW-1:LSB], write_posn} == f_const_addr[AW-1:ADDRLSB])\n\t\tbegin\n\t\t\tif (!M_AXI_RRESP[1])\n\t\t\t\tassume(M_AXI_RDATA == fc_line);\n\t\tend\n\n\tend endgenerate\n\t// }}}\n\n\t//\n\t// 2. Assert that if the known address is in the cache, the data must be\n\t//\tthe correct data\n\t// {{{\n\talways @(*)\n\tif (cache_valid[f_const_addr[CWB-1:LSB]]\n\t\t\t&& cache_tags[f_const_addr[CWB-1:LSB]]\n\t\t\t\t\t\t== f_const_addr[AW-1:CWB])\n\t\tassert(cache[f_const_addr[CWB-1:ADDRLSB]] == fc_line);\n\n\tgenerate if (OPT_WRAP)\n\tbegin : GEN_WRAPCHECK\n\t\t// {{{",
            "reg f_wrap_written;",
            "reg [LS-1:0]\tf_wrap_distance;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\t// f_const_addr[CWB-1:LSB]]\n\t\t\tf_wrap_distance= f_const_addr[LSB-1:ADDRLSB]-write_posn;\n\n\t\t\tf_wrap_written = f_wrap_distance > faxi_rd_outstanding;\n\t\t\tif (M_AXI_ARVALID)\n\t\t\t\tf_wrap_written = 0;\n\t\tend\n\n\t\talways @(*)\n\t\tif (!f_const_illegal && request_pending\n\t\t\t&& faxi_rd_nbursts > 0 && f_wrap_written\n\t\t\t&& !cache_valid[f_const_addr[CWB-1:LSB]]\n\t\t\t&& axi_araddr[AW-1:LSB] == f_const_addr[AW-1:LSB])\n\t\tbegin\n\t\t\tassert(cache[f_const_addr[CWB-1:ADDRLSB]] == fc_line);\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\talways @(*)\n\tif (f_const_illegal)\n\t\tassert(!cache_valid[f_const_addr[CWB-1:LSB]]\n\t\t\t|| cache_tags[f_const_addr[CWB-1:LSB]]\n\t\t\t\t\t\t!= f_const_addr[AW-1:CWB]);\n\telse\n\t\tassert(!illegal_valid || illegal_tag != f_const_addr[AW-1:LSB]);\n\n\t//\n\t// Anything else in a line with one illegal element must also be illegal\n\talways @(*)\n\tif (o_valid && o_pc[AW-1:LSB] == f_const_addr[AW-1:LSB]\n\t\t\t&& f_const_illegal)\n\t\tassert(o_illegal);\n\t// }}}\n\n\t//\n\t// 3. If our chosen address is ever returned, assert that it contains\n\t//\tthe correct data and illegal flag within it\n\t// {{{\n\n\t// Captured inside ffetch above\n\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg f_valid_legal;",
            "reg [LGLINESZ+2:0]\tcvr_valids, cvr_consecutive, cvr_resets;\n\n\talways @(*)\n\t\tf_valid_legal = o_valid && (!o_illegal);\n\n\tinitial\tcvr_valids = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tcvr_valids <= 0;\n\telse if (i_cpu_reset || i_clear_cache || i_new_pc || o_illegal)\n\t\tcvr_valids <= 0;\n\telse if (o_valid && i_ready && !cvr_valids[LGLINESZ+2])\n\t\tcvr_valids <= cvr_valids + 1;\n\n\tinitial\tcvr_resets = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tcvr_resets <= 0;\n\telse if (i_cpu_reset || i_clear_cache || i_new_pc || o_illegal)\n\t\tcvr_resets <= cvr_resets + 1;\n\n\talways @(*)\n\tif (S_AXI_ARESETN && i_cpu_reset && !i_clear_cache && !i_new_pc && !o_illegal)\n\t\tcover(cvr_valids == (1<<(LGLINESZ+1)));\n\n\talways @(posedge S_AXI_ACLK)\t\t// Trace 0\n\t\tcover((o_valid)&&( o_illegal));\n\talways @(posedge S_AXI_ACLK)\t\t// Trace 1\n\t\tcover(f_valid_legal);\n\talways @(posedge S_AXI_ACLK)\t\t// Trace 2\n\t\tcover((f_valid_legal)\n\t\t\t&&($past(!o_valid && !i_new_pc))\n\t\t\t&&($past(i_new_pc,2)));\n\talways @(posedge S_AXI_ACLK)\t\t// Trace 3\n\t\tcover((f_valid_legal)&&($past(i_ready))&&($past(i_new_pc)));\n\talways @(posedge S_AXI_ACLK)\t\t// Trace 4\n\t\tcover((f_valid_legal)&&($past(f_valid_legal && i_ready)));\n\talways @(posedge S_AXI_ACLK)\t\t// Trace 5\n\t\tcover((f_valid_legal)\n\t\t\t&&($past(f_valid_legal && i_ready))\n\t\t\t&&($past(f_valid_legal && i_ready,2))\n\t\t\t&&($past(f_valid_legal && i_ready,3)));\n\talways @(posedge S_AXI_ACLK)\t\t// Trace 6\n\t\tcover((f_valid_legal)\n\t\t\t&&($past(f_valid_legal && i_ready))\n\t\t\t&&($past(f_valid_legal && i_ready,2))\n\t\t\t&&($past(!o_illegal && i_ready && i_new_pc,3))\n\t\t\t&&($past(f_valid_legal && i_ready,4))\n\t\t\t&&($past(f_valid_legal && i_ready,5))\n\t\t\t&&($past(f_valid_legal && i_ready,6)));\n\n\talways @(posedge S_AXI_ACLK)\t\t// Trace 7\n\t\tcover((f_valid_legal)\n\t\t\t&&($past(f_valid_legal && i_ready))\n\t\t\t&&($past(!o_illegal && i_ready,2))\n\t\t\t&&($past(!o_illegal && i_ready && i_new_pc,3))\n\t\t\t&&($past(f_valid_legal && i_ready,4))\n\t\t\t&&($past(f_valid_legal && i_ready,5))\n\t\t\t&&($past(f_valid_legal && i_ready,6)));\n\n\talways @(*)\n\tbegin\n\t\tcover(cvr_valids == (1<<(LGLINESZ+1)));\n\t\tcover(cvr_valids == 4'b0101);\n\t\tcover(cvr_valids == (1<<(LGLINESZ+1))\n\t\t\t\t+ (1<<(LGLINESZ)));\n\t\tcover((cvr_valids == (1<<(LGLINESZ+1))\n\t\t\t\t+ (1<<(LGLINESZ))) && (cvr_resets == 1));\n\tend\n\n\tgenerate if (OPT_WRAP)\n\tbegin : CVR_WRAP // Cover properties for OPT_WRAP\n\t\t// {{{",
            "reg [LGLINESZ+2:0]\tcvr_wrap_count, cvr_wrap_valid;\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || i_new_pc || i_clear_cache|| M_AXI_ARVALID)\n\t\t\tcvr_wrap_count <= 0;\n\t\telse if (wrap_valid && (!o_valid || i_ready))\n\t\t\tcvr_wrap_count <= cvr_wrap_count + 1;\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || i_new_pc || i_clear_cache|| M_AXI_ARVALID\n\t\t\t\t|| !o_valid) // || !wrap_valid)\n\t\t\tcvr_wrap_valid <= 0;\n\t\telse if (!cvr_wrap_valid[LGLINESZ+2] && o_valid && i_ready)\n\t\t\tcvr_wrap_valid <= cvr_wrap_valid + 1;\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !i_new_pc && !i_clear_cache && !o_illegal)\n\t\t\tcover(o_valid && cvr_wrap_valid == (1<<(LGLINESZ-1)));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !i_new_pc && !i_clear_cache && !o_illegal)\n\t\t\tcover(o_valid && cvr_wrap_valid == (1<<(LGLINESZ-1)));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !i_new_pc && !i_clear_cache && !o_illegal)\n\t\t\tcover(o_valid && cvr_wrap_valid == (1<<(LGLINESZ)));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !i_new_pc && !i_clear_cache && !o_illegal)\n\t\t\tcover(o_valid && cvr_wrap_valid == (1<<(LGLINESZ)) + (1<<(LGLINESZ-1)));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !i_new_pc && !i_clear_cache && !o_illegal)\n\t\t\tcover(o_valid && cvr_wrap_count == (1<<(LGLINESZ-1)));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && M_AXI_RVALID)\n\t\t\tassume(faxi_rd_ckvalid);\n\t\t// }}}\n\tend endgenerate\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Illegal instruction checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t(* anyconst *)",
            "reg f_never_illegal, f_always_illegal;\n\talways @(*)\n\t\tassume(!f_never_illegal || !f_always_illegal);\n\n\talways @(*)\n\tif (M_AXI_RVALID)\n\tbegin\n\t\tassume(!f_never_illegal  || !M_AXI_RRESP[1]);\n\t\tassume(!f_always_illegal ||  M_AXI_RRESP[1]);\n\tend\n\n\talways @(*)\n\tif (f_always_illegal && o_valid)\n\t\tassert(o_illegal);\n\n\talways @(*)\n\tif (f_always_illegal)\n\t\tassert(cache_valid == 0);\n\n\talways @(*)\n\tif (f_never_illegal)\n\t\tassert(!illegal_valid);\n\n\talways @(*)\n\tif (f_never_illegal)\n\t\tassert(!o_illegal);\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Constraining assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// None currently\n\n\t// }}}\n`endif\t// FORMAL\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "prefetch.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/prefetch.v",
        "chunks": [
            "input ",
            "wire is just a\n//\tsuggestion of what to load.  Other",
            "wire s may be loaded instead. i_pc\n//\tis what must be",
            "output , not necessarily",
            "input .\n//\n//   20150919 -- Added support for the WB error signal.  When reading an\n//\tinstruction results in this signal being raised, the pipefetch",
            "module //\twill set an illegal instruction flag to be returned to the CPU together\n//\twith the instruction.  Hence, the ZipCPU can trap on it if necessary.\n//\n//   20171020 -- Added a formal proof to prove that the",
            "module works.  This\n//\talso involved adding a req_addr",
            "reg ister, and the",
            "logic associated\n//\twith it.\n//\n//   20171113 -- Removed the req_addr",
            "reg ister, replacing it with a bus abort\n//\tcapability.\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module prefetch #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=30,\t// Byte addr wid\n\t\t\t\t\tINSN_WIDTH=32,\n\t\t\t\t\tDATA_WIDTH=INSN_WIDTH,",
            "localparam AW=ADDRESS_WIDTH,\n\t\t\t\t\tDW=DATA_WIDTH,",
            "parameter [0:0]\tOPT_ALIGNED = 1'b0,",
            "parameter [0:0]\tOPT_LITTLE_ENDIAN = 1'b1\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// CPU interaction",
            "wire s",
            "input ",
            "wire i_new_pc, i_clear_cache,\n\t\t\t\t\t\ti_ready,\n\t\t// We ignore i_pc unless i_new_pc is true as well",
            "input ",
            "wire [AW-1:0]\ti_pc,",
            "output ",
            "reg o_valid, // If",
            "output is valid",
            "output ",
            "reg o_illegal, // bus err result",
            "output ",
            "reg [INSN_WIDTH-1:0]\to_insn,\t// Insn read from WB",
            "output ",
            "reg [AW-1:0]\to_pc,\t// Byt addr of that insn\n\t\t// Wishbone",
            "output s",
            "output ",
            "reg o_wb_cyc, o_wb_stb,\n\t\t// verilator coverage_off",
            "output ",
            "wire o_wb_we,\t// == const 0\n\t\t// verilator coverage_on",
            "output ",
            "reg [AW-$clog2(DW/8)-1:0]\to_wb_addr,\n\t\t// verilator coverage_off",
            "output ",
            "wire [DW-1:0]\to_wb_data,\t// == const 0\n\t\t// verilator coverage_on\n\t\t// And return",
            "input s",
            "input ",
            "wire i_wb_stall, i_wb_ack, i_wb_err,",
            "input ",
            "wire [DW-1:0]\ti_wb_data\n\t\t// }}}\n\t);\n\n\t// Declare local variables\n\t// {{{",
            "reg invalid;",
            "wire r_valid;",
            "wire [DATA_WIDTH-1:0]\tr_insn, i_wb_shifted;\n\t// }}}\n\n\t// These are kind of obligatory",
            "output s when dealing with a bus, that\n\t// we'll set them here.  Nothing's going to pay attention to these,\n\t// though, this is primarily for form.\n\tassign\to_wb_we = 1'b0;\n\tassign\to_wb_data = {(DATA_WIDTH){1'b0}};\n\n\t// o_wb_cyc, o_wb_stb\n\t// {{{\n\t// Let's build it simple and upgrade later: For each instruction\n\t// we do one bus cycle to get the instruction.  Later we should\n\t// pipeline this, but for now let's just do one at a time.\n\tinitial\to_wb_cyc = 1'b0;\n\tinitial\to_wb_stb = 1'b0;\n\talways @(posedge i_clk)\n\tif ((i_reset || i_clear_cache)||(o_wb_cyc &&(i_wb_ack||i_wb_err)))\n\tbegin\n\t\t// {{{\n\t\t// End any bus cycle on a reset, or a return ACK\n\t\t// or error.\n\t\to_wb_cyc <= 1'b0;\n\t\to_wb_stb <= 1'b0;\n\t\t// }}}\n\tend else if (!o_wb_cyc &&(\n\t\t\t// Start if the last instruction",
            "output was\n\t\t\t// accepted, *and* it wasn't a bus error\n\t\t\t// response\n\t\t\t(i_ready && !o_illegal && !r_valid)\n\t\t\t// Start if the last bus result ended up\n\t\t\t// invalid\n\t\t\t||(invalid)\n\t\t\t// Start on any request for a new address\n\t\t\t||i_new_pc))\n\tbegin\n\t\t// {{{\n\t\t// Initiate a bus transaction\n\t\to_wb_cyc <= 1'b1;\n\t\to_wb_stb <= 1'b1;\n\t\t// }}}\n\tend else if (o_wb_cyc)\n\tbegin\n\t\t// {{{\n\t\t// If our request has been accepted, then drop the\n\t\t// strobe line\n\t\tif (!i_wb_stall)\n\t\t\to_wb_stb <= 1'b0;\n\n\t\t// Abort on new-pc\n\t\t// ... clear_cache  is identical, save that it will\n\t\t// immediately be followed by a new PC, so we don't\n\t\t// need to worry about that other than to drop\n\t\t// CYC and STB here.\n\t\tif (i_new_pc)\n\t\tbegin\n\t\t\to_wb_cyc <= 1'b0;\n\t\t\to_wb_stb <= 1'b0;\n\t\tend\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// invalid\n\t// {{{\n\t// If during the current bus request, a command came in from the CPU\n\t// that will invalidate the results of that request, then we need to\n\t// keep track of an \"invalid\" flag to remember that and so squash\n\t// the result.\n\t//\n\tinitial\tinvalid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || !o_wb_cyc)\n\t\tinvalid <= 1'b0;\n\telse if (i_new_pc)\n\t\tinvalid <= 1'b1;\n\t// }}}\n\n\t// The wishbone request address, o_wb_addr\n\t// {{{\n\t// The rule",
            "reg arding this address is that it can *only* be changed\n\t// when no bus request is active.  Further, since the CPU is depending\n\t// upon this value to know what \"PC\" is associated with the instruction\n\t// it is processing, we can't change until either the CPU has accepted\n\t// our result, or it is requesting a new PC (and hence not using the\n\t//",
            "output ).\n\t//\n\tinitial\to_wb_addr= 0;\n\talways @(posedge i_clk)\n\tif (i_new_pc)\n\t\to_wb_addr  <= i_pc[AW-1:$clog2(DATA_WIDTH/8)];\n\telse if (o_valid && i_ready && !r_valid)\n\t\to_wb_addr  <= o_wb_addr + 1'b1;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Optionally) shift the",
            "output word into place\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// This only applies when the bus size doesn't match the instruction\n\t// word size.  Here, we only support bus sizes greater than the\n\t// instruction word size.\n`ifdef\tFORMAL",
            "wire [DATA_WIDTH-1:0]\tf_bus_word;\n`endif\n\n\tgenerate if (DATA_WIDTH > INSN_WIDTH)\n\tbegin : GEN_SUBSHIFT\n\t\t// {{{",
            "localparam NSHIFT = $clog2(DATA_WIDTH/INSN_WIDTH);",
            "reg rg_valid;",
            "reg [DATA_WIDTH-1:0]\trg_insn;",
            "reg [NSHIFT:0]\tr_count;",
            "reg [NSHIFT-1:0]\tr_shift;\n\n\t\t// rg_valid\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || i_new_pc || i_clear_cache)\n\t\t\trg_valid <= 1'b0;\n\t\telse if (r_count <= ((o_valid && i_ready) ? 1:0))\n\t\tbegin\n\t\t\trg_valid <= 1'b0;\n\t\t\tif (o_wb_cyc && i_wb_ack && !(&r_shift))\n\t\t\t\trg_valid <= 1'b1;\n\t\tend\n\t\t// }}}\n\n\t\t// rg_insn\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (i_wb_ack && (r_count <= ((o_valid && i_ready) ? 1:0)))\n\t\tbegin\n\t\t\trg_insn <= i_wb_data;\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\trg_insn <= i_wb_shifted >> INSN_WIDTH;\n\t\t\tend else begin\n\t\t\t\trg_insn <= i_wb_shifted << INSN_WIDTH;\n\t\t\tend\n\t\tend else if (o_valid && i_ready)\n\t\tbegin\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\t\trg_insn <= rg_insn >> INSN_WIDTH;\n\t\t\telse\n\t\t\t\trg_insn <= rg_insn << INSN_WIDTH;\n\t\tend\n\t\t// }}}\n\n\t\t// r_count\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || i_new_pc || i_clear_cache)\n\t\t\tr_count <= 0;\n\t\t// Verilator lint_off CMPCONST\n\t\telse if (o_valid && i_ready && r_valid)\n\t\t// Verilator lint_on  CMPCONST\n\t\t\tr_count <= r_count - 1;\n\t\telse if (o_wb_cyc && i_wb_ack)\n\t\tbegin\n\t\t\t// if (OPT_LITTLE_ENDIAN)\n\t\t\tr_count <= { 1'b0, ~r_shift };\n\t\tend\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (!i_reset)\n\t\tbegin\n\t\t\tassert(r_valid == (r_count > 0));\n\t\t\tassert(r_count <= (1<<NSHIFT));\n\t\t\tif (r_valid)\n\t\t\tbegin\n\t\t\t\tassert(!o_wb_cyc);\n\t\t\t\tassert(r_shift == 0);\n\t\t\tend else if (!i_new_pc && !i_clear_cache && !o_illegal)\n\t\t\t\tassert(invalid || o_valid || o_wb_cyc);\n\t\tend\n`endif\n\t\t// }}}\n\n\t\t// r_shift\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_shift <= 0;\n\t\telse if (i_new_pc)\n\t\t\tr_shift <= i_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)];\n\t\telse if (o_wb_cyc && (i_wb_ack || i_wb_err))\n\t\t\tr_shift <= 0;\n\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (!i_reset && r_shift > 0)\n\t\t\tassert(!o_valid && !r_valid);\n`endif\n\t\t// }}}\n\n\t\tassign\tr_valid = rg_valid;\n\n\t\tassign\tr_insn  = rg_insn;\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin : GEN_LIL_ENDIAN_SHIFT\n\t\t\tassign\ti_wb_shifted = i_wb_data >> (r_shift * INSN_WIDTH);\n\t\tend else begin : GEN_BIG_ENDIAN_SHIFT\n\t\t\tassign\ti_wb_shifted = i_wb_data << (r_shift * INSN_WIDTH);\n\t\tend\n\n\t\t// Keep Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_shift;\n\t\tassign\tunused_shift = &{ 1'b0,\n\t\t\t\tr_insn[DATA_WIDTH-1:INSN_WIDTH],\n\t\t\t\ti_wb_shifted[DATA_WIDTH-1:INSN_WIDTH] };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n`ifdef\tFORMAL\n\t\tassign\tf_bus_word = rg_insn << ((r_count-1)* INSN_WIDTH);\n\t\talways @(*)\n\t\tif (!i_reset && r_valid)\n\t\tbegin\n\t\t\tassert(o_valid);\n\t\t\tassert(r_shift == 0);\n\t\t\t// assert((r_count + o_pc[NSHIFT-1:0]) == ((1<<NSHIFT)-1));\n\t\t\tassert((r_count + o_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)])\n\t\t\t\t== ((1<<NSHIFT)-1));\n\t\tend else if (!i_reset && o_wb_cyc && !invalid)\n\t\tbegin\n\t\t\tassert(r_shift == o_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)]);\n\t\tend\n`endif\n\t\t// }}}\n\tend else begin : NO_SUBSHIFT\n\t\t// {{{\n\t\tassign\tr_valid = 1'b0;\n\t\tassign\tr_insn  = {(INSN_WIDTH){1'b0}};\n\t\tassign\ti_wb_shifted = i_wb_data;\n`ifdef\tFORMAL\n\t\tassign\tf_bus_word = 0;\n`endif\n\t\t// Verilator lint_off UNUSED",
            "wire unused_shift;\n\t\tassign\tunused_shift = &{ 1'b0, OPT_LITTLE_ENDIAN };\n\t\t// Verilator lint_on  UNUSED\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// o_insn\n\t// {{{\n\t// The instruction returned is given by the data returned from the bus.\n\talways @(posedge i_clk)\n\tif (i_wb_ack)\n\tbegin\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\to_insn <= i_wb_shifted[INSN_WIDTH-1:0];\n\t\telse\n\t\t\to_insn <= i_wb_shifted[DW-1:DW-INSN_WIDTH];\n\tend else if (i_ready && (DATA_WIDTH != INSN_WIDTH))\n\tbegin\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\to_insn <= r_insn[INSN_WIDTH-1:0];\n\t\telse\n\t\t\to_insn <= r_insn[DW-1:DW-INSN_WIDTH];\n\tend\n`ifdef\tFORMAL\n\talways @(posedge i_clk) if (!i_reset && o_valid) assert(!i_wb_ack);\n`endif\n\t// }}}\n\n\t// o_valid, o_illegal\n\t// {{{\n\t// Finally, the flags associated with the prefetch.  The rule is that\n\t// if the",
            "output represents a return from the bus, then o_valid needs\n\t// to be true.  o_illegal will be true any time the last bus request\n\t// resulted in an error.  o_illegal is only relevant to the CPU when\n\t// o_valid is also true, hence o_valid will be true even in the case\n\t// of a bus error in our request.\n\t//\n\tinitial o_valid   = 1'b0;\n\tinitial o_illegal = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_new_pc || i_clear_cache)\n\tbegin\n\t\t// On any reset, request for a new PC (i.e. a branch),\n\t\t// or a request to clear our cache (i.e. the data\n\t\t// in memory may have changed), we invalidate any\n\t\t//",
            "output .\n\t\to_valid   <= 1'b0;\n\t\to_illegal <= 1'b0;\n\tend else if (o_wb_cyc &&(i_wb_ack || i_wb_err))\n\tbegin\n\t\t// Otherwise, at the end of our bus cycle, the\n\t\t// answer will be valid.  Well, not quite.  If the\n\t\t// user requested something mid-cycle (i_new_pc)\n\t\t// or (i_clear_cache), then we'll have to redo the\n\t\t// bus request, so we aren't valid.\n\t\t//\n\t\to_valid   <= 1'b1;\n\t\to_illegal <= ( i_wb_err);\n\tend else if (i_ready)\n\tbegin\n\t\t// Once the CPU accepts any result we produce, clear\n\t\t// the valid flag, lest we send two identical\n\t\t// instructions to the CPU.\n\t\t//\n\t\to_valid <= r_valid;\n\t\t//\n\t\t// o_illegal doesn't change ... that way we don't\n\t\t// access the bus again until a new address request\n\t\t// is given to us, via i_new_pc, or we are asked\n\t\t//  to check again via i_clear_cache\n\t\t//\n\t\t// o_illegal <= (!i_ready);\n\tend\n\t// }}}\n\n\t// The o_pc",
            "output shares its value with the (last) wishbone address\n\t// {{{\n\tgenerate if (OPT_ALIGNED && (INSN_WIDTH == DATA_WIDTH))\n\tbegin : ALIGNED_PF_PC\n\t\t// {{{\n\t\talways @(*)\n\t\t\to_pc = { o_wb_addr,\n\t\t\t\t{($clog2(DATA_WIDTH/8)){1'b0}} };\n\t\t// }}}\n\tend else begin : GENERATE_PF_PC\n\t\t// {{{\n\t\tinitial\to_pc = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_new_pc)\n\t\t\to_pc <= i_pc;\n\t\telse if (o_valid && i_ready)\n\t\tbegin\n\t\t\to_pc <= 0;\n\t\t\to_pc[AW-1:$clog2(INSN_WIDTH/8)]\n\t\t\t\t<= o_pc[AW-1:$clog2(INSN_WIDTH/8)] + 1;\n\t\tend\n\t\t// }}}\n\tend endgenerate\n`ifdef\tFORMAL\n\talways @(*)\n\tif (!i_reset && !o_illegal && !i_new_pc && !i_clear_cache)\n\t\tassert(o_pc[AW-1:$clog2(DATA_WIDTH/8)] == o_wb_addr);\n`endif\n\t// }}}\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, i_pc[1:0] };\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Declarations\n\t// {{{",
            "localparam F_LGDEPTH=2;",
            "reg f_past_valid;",
            "wire [(F_LGDEPTH-1):0]\tf_nreqs, f_nacks,\n\t\t\t\t\tf_outstanding;",
            "reg [AW-$clog2(DATA_WIDTH/8)-1:0]\tf_req_addr;",
            "wire [AW-$clog2(DATA_WIDTH/8)-1:0]\tf_next_wb_addr;\n\n\t// Keep track of a flag telling us whether or not $past()\n\t// will return valid results\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus interface properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.AW(AW-$clog2(DATA_WIDTH/8)), .DW(DW),.F_LGDEPTH(F_LGDEPTH),\n\t\t.F_MAX_REQUESTS(1), .F_OPT_SOURCE(1),\n\t\t.F_OPT_RMW_BUS_OPTION(0),\n\t\t.F_OPT_DISCONTINUOUS(0)\n\t\t// }}}\n\t) f_wbm(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_wb_cyc(o_wb_cyc), .i_wb_stb(o_wb_stb), .i_wb_we(o_wb_we),\n\t\t.i_wb_addr(o_wb_addr), .i_wb_data(o_wb_data),\n\t\t\t\t.i_wb_sel({($clog2(DW/8)){1'b0}}),\n\t\t.i_wb_ack(i_wb_ack), .i_wb_stall(i_wb_stall),\n\t\t\t.i_wb_idata(i_wb_data), .i_wb_err(i_wb_err),\n\t\t.f_nreqs(f_nreqs), .f_nacks(f_nacks),\n\t\t\t.f_outstanding(f_outstanding)\n\t\t// }}}\n\t);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// CPU interface properties\n\t// {{{\n\t/////////////////////////////////////////////////\n\t//\n\t//",
            "wire f_const_illegal;",
            "wire [AW-1:0]\tf_const_addr;",
            "wire [DW-1:0]\tf_const_insn;",
            "wire [AW-1:0]\tf_address;\n\n\tffetch #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(AW-$clog2(INSN_WIDTH/8)),\n\t\t.OPT_ALIGNED(OPT_ALIGNED),\n\t\t.INSN_WIDTH(INSN_WIDTH)\n\t\t// }}}\n\t) cpu(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.cpu_new_pc(i_new_pc), .cpu_clear_cache(i_clear_cache),\n\t\t.cpu_pc(i_pc), .pf_valid(o_valid), .cpu_ready(i_ready),\n\t\t.pf_pc(o_pc), .pf_insn(o_insn), .pf_illegal(o_illegal),\n\t\t.fc_pc(f_const_addr), .fc_illegal(f_const_illegal),\n\t\t.fc_insn(f_const_insn), .f_address(f_address)\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (!i_reset && !i_new_pc && !i_clear_cache && !o_illegal)\n\t\tassert(f_address == o_pc);\n\n\talways @(*)\n\tif (o_illegal)\n\t\tassert(!o_wb_cyc);\n\n\t//\n\t//\n\t// Let's make some assumptions about how long it takes our\n\t// phantom bus and phantom CPU to respond.\n\t//\n\t// These delays need to be long enough to flush out any potential\n\t// errors, yet still short enough that the formal method doesn't\n\t// take forever to solve.\n\t//",
            "localparam F_CPU_DELAY = 4;",
            "reg [4:0]\tf_cpu_delay;\n\t// First, let's assume that any response from the bus comes back\n\t// within F_WB_DELAY clocks\n\n\t\t// Here's our delay assumption: We'll assume that the\n\t// wishbone will always respond within F_WB_DELAY clock ticks\n\t// of the beginning of any cycle.\n\t//\n\t// This includes both dropping the stall line, as well as\n\t// acknowledging any request.  While this may not be\n\t// a reasonable assumption for a piped master, it should\n\t// work here for us.\n\n\t// Count the number of clocks it takes the CPU to respond to our\n\t// instruction.\n\talways @(posedge i_clk)\n\t// If no instruction is ready, then keep our counter at zero\n\tif ((i_reset)||(!o_valid)||(i_ready))\n\t\tf_cpu_delay <= 0;\n\telse\n\t\t// Otherwise, count the clocks the CPU takes to respond\n\t\tf_cpu_delay <= f_cpu_delay + 1'b1;\n\n`ifdef\tPREFETCH\n\t// Only *assume* that we are less than F_CPU_DELAY if we are not\n\t// integrated into the CPU\n\talways @(posedge i_clk)\n\t\tassume(f_cpu_delay < F_CPU_DELAY);\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about our",
            "output s\n\t// {{{\n\t/////////////////////////////////////////////////\n\t//\n\t// Assertions about our wishbone control",
            "output s first\n\t// Prefetches don't write\n\talways @(*)\n\t\tassert(!o_wb_we);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(f_past_valid))\n\t\t\t&&($past(i_clear_cache,2))\n\t\t\t&&($past(o_wb_cyc,2)))\n\t\t// Make sure any clear-cache transaction is aborted,\n\t\t// *and* that no valid instructions get sent to the\n\t\t// CPU\n\t\tassert((!$past(o_wb_cyc))||(!o_wb_cyc));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_valid && !r_valid))&&(o_valid))\n\t\tassert(o_wb_addr == $past(o_wb_addr));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(!i_reset && !i_clear_cache))&&($past(invalid)))\n\t\tassert(o_wb_cyc);\n\n\t// Any time the CPU accepts an instruction, assert that on the\n\t// valid line will be low on the next clock\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_valid && i_ready && !r_valid)))\n\t\tassert(!o_valid);\n\n\t// Since we only change our",
            "output on a response from the bus, we\n\t// need to insist that the item has been read by the CPU before\n\t// we go looking/asking for a next value.\n\t//\n\t// This routine should never be requesting a new instruction when\n\t// one is valid--lest the CPU never accept the old instruction and we\n\t// have nothing to do with the data when the bus request returns.\n\talways @(*)\n\tif (o_wb_cyc)\n\t\tassert(!o_valid && !r_valid);\n\n\t// If we just got a valid instruction from the wishbone, assert that\n\t// the instruction is listed as valid on the next instruction cycle\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t&&($past(o_wb_cyc))\n\t\t&&($past(!i_clear_cache))\n\t\t&&($past(i_wb_ack))&&(!$past(i_wb_err)))\n\tbegin\n\t\tif (!invalid)\n\t\t\tassert(o_valid);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_clear_cache)))\n\t\tassert(!o_valid);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(f_past_valid))\n\t\t\t&&($past(i_clear_cache,2))\n\t\t\t&&($past(o_wb_cyc,2)))\n\t\t// Make sure any clear-cache transaction is aborted,\n\t\t// *and* that no valid instructions get sent to the\n\t\t// CPU\n\t\tassert(!o_valid);\n\n\t//\n\t// Assertions about our return responses\n\t//\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t\t&&(!$past(i_new_pc))&&(!$past(i_clear_cache))\n\t\t\t&&($past(o_valid))&&(!$past(i_ready)))\n\t\tassert(o_valid == $past(o_valid));\n\n//\talways @(posedge i_clk)\n//\tif ((f_past_valid)&&($past(o_valid))&&(o_valid))\n//\tbegin\n//\t\tassert($stable(o_pc));\n//\t\tassert($stable(o_insn));\n//\t\tassert($stable(o_illegal));\n//\tend\n\n\t//\n\t// The o_illegal line is the one we use to remind us not to go\n\t// back and retry the last value if it returned a bus error.  Hence,\n\t// let's assert that this line stays constant any time o_wb_cyc\n\t// is low, and we haven't received any new requests.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t\t&&(!$past(i_new_pc))&&(!$past(i_clear_cache))\n\t\t\t&&($past(!o_wb_cyc)))\n\t\tassert(o_illegal == $past(o_illegal));\n\n\n\t//\n\t//\n\t// Let's examine whether or not we \"walk\" though PC addresses one\n\t// at a time like we expect.\n\t//\n\n\t// f_req_addr\n\t// {{{\n\tinitial\tf_req_addr = 0;\n\talways @(posedge i_clk)\n\tif (i_new_pc)\n\t\tf_req_addr <= i_pc[AW-1:$clog2(DATA_WIDTH/8)];\n\telse if (!invalid && o_wb_cyc && i_wb_ack && !i_wb_err && !r_valid)\n\t\tf_req_addr <= f_req_addr + 1'b1;\n\n\tassign\tf_next_wb_addr = o_wb_addr + 1;\n\t// }}}\n\n\t// Let's also keep the formal methods on track.  Any time we are\n\t// requesting a value, it should either be from the req_addr, or if\n\t// not a new value should've come in rendering this one invalid.\n\talways @(posedge i_clk)\n\tif (o_wb_cyc)\n\tbegin\n\t\tassert(invalid ||(f_req_addr == o_wb_addr));\n\n\t\t// This isn't good enough for induction, so we'll need to\n\t\t// constrain this further\n\tend else if (!o_valid && !i_new_pc && !i_reset && !i_clear_cache)\n\t\tassert(o_illegal || f_req_addr == o_wb_addr);\n\telse if (!i_reset && r_valid)\n\t\tassert(f_req_addr == f_next_wb_addr);\n\n\t// In this version, invalid should only ever be high for one cycle.\n\t// CYC should be high on the cycle following--if ever.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(invalid)))\n\t\tassert(!invalid);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "wire f_this_addr, f_this_pc, f_this_req, f_this_data;",
            "reg f_addr_pending;",
            "reg f_insn_pending;\n\t(* anyconst *)",
            "reg [DATA_WIDTH-1:0]\tf_const_bus_word;\n\n\tassign\tf_this_addr = (o_wb_addr ==   f_const_addr[AW-1:$clog2(DW/8)]);\n\tassign\tf_this_pc   = (o_pc[AW-1:$clog2(DW/8)]== f_const_addr[AW-1:$clog2(DW/8)]);\n\tassign\tf_this_req  = (i_pc[AW-1:$clog2(DW/8)]== f_const_addr[AW-1:$clog2(DW/8)]);\n\tassign\tf_this_data = (i_wb_data ==   f_const_bus_word);\n\n\tgenerate if (DATA_WIDTH > INSN_WIDTH)\n\tbegin : F_CHECK_SHIFTED_WORD\n\t\t// {{{",
            "wire [DW-1:0]\tf_shifted_insn;",
            "localparam IW = INSN_WIDTH;\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tassign\tf_shifted_insn = f_const_bus_word\n\t\t\t>> (f_const_addr[$clog2(DW/8)-1:$clog2(IW/8)] * IW);\n\t\t\talways @(*)\n\t\t\t\tassume(f_shifted_insn[IW-1:0] == f_const_insn);\n\n\t\tend else begin\n\t\t\tassign\tf_shifted_insn = f_const_bus_word\n\t\t\t<< (f_const_addr[$clog2(DW/8)-1:$clog2(IW/8)] * IW);\n\n\t\t\talways @(*)\n\t\t\t\tassume(f_shifted_insn[DW-1:DW-IW]\n\t\t\t\t\t\t\t== f_const_insn);\n\n\t\tend\n\t\t// }}}\n\tend else begin\n\t\t// {{{\n\t\talways @(*)\n\t\t\tassume(f_const_bus_word == f_const_insn);\n\t\t// }}}\n\tend endgenerate\n\n\t// f_addr_pending\n\t// {{{\n\tinitial\tf_addr_pending = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_addr_pending <= 1'b0;\n\telse if (!o_wb_cyc)\n\t\tf_addr_pending <= 1'b0;\n\telse if ((o_wb_stb)&&(f_this_addr))\n\tbegin\n\t\tif ((!i_wb_ack)&&(!i_wb_err))\n\t\t\tf_addr_pending <= 1'b1;\n\tend\n\t// }}}\n\n\t// 1. Assume the correct response for the given address\n\t// {{{\n\talways @(*)\n\tif ((o_wb_stb)&&(f_this_addr)&&(!i_wb_stall))\n\tbegin\n\t\tif (!f_const_illegal)\n\t\tbegin\n\t\t\tassume(!i_wb_err);\n\t\tend else\n\t\t\tassume(!i_wb_ack);\n\t\tif (i_wb_ack)\n\t\t\tassume(f_this_data);\n\tend else if ((o_wb_cyc)&&(f_addr_pending))\n\tbegin\n\t\tif (!f_const_illegal)\n\t\tbegin\n\t\t\tassume(!i_wb_err);\n\t\tend else\n\t\t\tassume(!i_wb_ack);\n\t\tif (i_wb_ack)\n\t\t\tassume(f_this_data);\n\tend\n\t// }}}\n\n\t// f_insn_pending\n\t// {{{\n\tinitial\tf_insn_pending = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_insn_pending <= 1'b0;\n\telse if (i_clear_cache)\n\t\tf_insn_pending <= 1'b0;\n\telse if (i_new_pc && f_this_req)\n\t\tf_insn_pending <= 1'b1;\n\telse if ((o_valid)||(i_new_pc))\n\t\tf_insn_pending <= 1'b0;\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_wb_cyc))&&(o_wb_cyc)&&(f_insn_pending))\n\t\tassert(f_this_pc);\n\n\talways @(posedge i_clk)\n\tif (((f_past_valid)&&($past(o_wb_cyc))&&($past(f_insn_pending)))\n\t\t&&(!$past(i_reset))&&(!$past(i_clear_cache))\n\t\t&&(!$past(i_new_pc)))\n\tbegin\n\t\tif(!o_wb_cyc)\n\t\t\tassert(o_valid && f_this_pc);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(o_wb_cyc))&&(!o_wb_cyc))\n\t\tassert(!f_insn_pending);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_wb_cyc))&&(o_wb_cyc)&&(f_this_addr))\n\t\tassert(f_addr_pending);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_wb_cyc))&&(f_insn_pending))\n\t\tassert(f_this_addr);\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "wire unused_formal;\n\tassign\tunused_formal = &{ 1'b0, f_nreqs, f_nacks, f_outstanding,\n\t\t\tf_const_addr[1:0] };\n\t// Verilator lint_on  UNUSED\n\t// }}}\n`endif\n// }}}",
            "endmodule //\n// Usage:\t(this)\t(mid)\t(past)\n//    Cells\t167\t230\t175\n//\tFDRE\t 67\t 97\t 69\n//\tLUT1\t  1\t  1\t  1\n//\tLUT2\t  1\t  3\t  3\n//\tLUT3\t 31\t 63\t 33\n//\tLUT4\t  5\t  3\t  3\n//\tLUT5\t  1\t  3\t  3\n//\tLUT6\t  2\t  1\t  3\n//\tMUXCY\t 29\t 29\t 31\n//\tXORCY\t 30\t 30\t 32"
        ]
    },
    {
        "file_name": "dblfetch.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/dblfetch.v",
        "chunks": [
            "module dblfetch #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=30,\t// Byte addr",
            "parameter INSN_WIDTH=32,",
            "parameter DATA_WIDTH = INSN_WIDTH,",
            "localparam AW=ADDRESS_WIDTH,\n\t\t\t\t\tDW=DATA_WIDTH,",
            "parameter [0:0]\tOPT_LITTLE_ENDIAN = 1'b1\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// CPU signals--from the CPU",
            "input ",
            "wire i_new_pc, i_clear_cache,i_ready,",
            "input ",
            "wire [AW-1:0]\ti_pc,\n\t\t// ... and in return",
            "output ",
            "reg o_valid,",
            "output ",
            "reg o_illegal,",
            "output ",
            "reg [INSN_WIDTH-1:0]\to_insn,",
            "output ",
            "reg [AW-1:0]\to_pc,\n\t\t// Wishbone",
            "output s",
            "output ",
            "reg o_wb_cyc, o_wb_stb,\n\t\t// verilator coverage_off",
            "output ",
            "wire o_wb_we,\n\t\t// verilator coverage_on",
            "output ",
            "reg [AW-$clog2(DW/8)-1:0] o_wb_addr,\n\t\t// verilator coverage_off",
            "output ",
            "wire [DW-1:0]\to_wb_data,\n\t\t// verilator coverage_on\n\t\t// And return",
            "input s",
            "input ",
            "wire i_wb_stall, i_wb_ack, i_wb_err,",
            "input ",
            "wire [DW-1:0]\ti_wb_data\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "wire last_stb;",
            "reg invalid_bus_cycle;",
            "reg [(DW-1):0]\tcache_word;",
            "reg cache_valid;",
            "reg [1:0]\t\tinflight;",
            "reg cache_illegal;",
            "wire r_valid;",
            "wire [DATA_WIDTH-1:0]\tr_insn, i_wb_shifted;\n\t// }}}\n\n\tassign\to_wb_we = 1'b0;\n\tassign\to_wb_data = {(DATA_WIDTH){1'b0}};\n\n\t// o_wb_cyc, o_wb_stb\n\t// {{{\n\tinitial\to_wb_cyc = 1'b0;\n\tinitial\to_wb_stb = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_clear_cache || (o_wb_cyc && i_wb_err))\n\tbegin : RESET_ABORT\n\t\t// {{{\n\t\to_wb_cyc <= 1'b0;\n\t\to_wb_stb <= 1'b0;\n\t\t// }}}\n\tend else if (o_wb_cyc)\n\tbegin : END_CYCLE\n\t\t// {{{\n\t\tif (!o_wb_stb || !i_wb_stall)\n\t\t\to_wb_stb <= (!last_stb);\n\n\t\t// Relase the bus on the second ack\n\t\tif ((!o_wb_stb || !i_wb_stall) && last_stb\n\t\t\t&& inflight + (o_wb_stb ? 1:0) == (i_wb_ack ? 1:0))\n\t\tbegin\n\t\t\to_wb_cyc <= 1'b0;\n\t\t\to_wb_stb <= 1'b0;\n\t\tend\n\n\t\tif (i_new_pc) // || i_clear_cache)\n\t\t\t{ o_wb_cyc, o_wb_stb } <= 2'b0;\n\t\t// }}}\n\tend else if ((i_new_pc || invalid_bus_cycle)\n\t\t||(o_valid && i_ready && !r_valid && !cache_illegal))\n\tbegin : START_CYCLE\n\t\t// {{{\n\t\t// Initiate a bus cycle if ... the last bus cycle was\n\t\t// aborted (bus error or new_pc), we've been given a\n\t\t// new PC to go get, or we just exhausted our one\n\t\t// instruction cache\n\t\to_wb_cyc <= 1'b1;\n\t\to_wb_stb <= 1'b1;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// inflight\n\t// {{{\n\tinitial\tinflight = 2'b00;\n\talways @(posedge i_clk)\n\tif (!o_wb_cyc)\n\t\tinflight <= 2'b00;\n\telse begin\n\t\tcase({ (o_wb_stb && !i_wb_stall), i_wb_ack })\n\t\t2'b01:\tinflight <= inflight - 1'b1;\n\t\t2'b10:\tinflight <= inflight + 1'b1;\n\t\t// If neither ack nor request, then no change.  Likewise\n\t\t// if we have both an ack and a request, there's no change\n\t\t// in the number of requests in flight.\n\t\tdefault: begin end\n\t\tendcase\n\tend\n\t// }}}\n\n\t// last_stb\n\t// {{{\n\t// assign last_stb = (inflight != 2'b00)||(o_valid&& (!i_ready||r_valid));\n\tassign\tlast_stb = (!o_wb_stb||!i_wb_stall)&&(inflight\n\t\t+ (o_wb_stb ? 1:0)\n\t\t+ (o_valid&&(!i_ready || r_valid)) >= 2'b10);\n\t// }}}\n\n\t// invalid_bus_cycle\n\t// {{{\n\tinitial\tinvalid_bus_cycle = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tinvalid_bus_cycle <= 1'b0;\n\telse if (o_wb_cyc && i_new_pc)\n\t\tinvalid_bus_cycle <= 1'b1;\n\telse if (!o_wb_cyc)\n\t\tinvalid_bus_cycle <= 1'b0;\n\t// }}}\n\n\t// o_wb_addr\n\t// {{{\n\tinitial\to_wb_addr = {(AW-$clog2(DATA_WIDTH/8)){1'b1}};\n\talways @(posedge i_clk)\n\tif (i_new_pc)\n\t\to_wb_addr <= i_pc[AW-1:$clog2(DATA_WIDTH/8)];\n\t// else if (i_clear_cache)\n\t//\to_wb_addr <= o_pc[AW-1:$clog2(DATA_WIDTH/8)];\n\telse if (o_wb_stb && !i_wb_stall)\n\t\to_wb_addr <= o_wb_addr + 1'b1;\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Now for the immediate",
            "output word to the CPU\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// This only applies when the bus size doesn't match the instruction\n\t// word size.  Here, we only support bus sizes greater than the\n\t// instruction word size.\n`ifdef\tFORMAL",
            "wire [DATA_WIDTH-1:0]\tf_bus_word;\n`endif\n\n\tgenerate if (DATA_WIDTH > INSN_WIDTH)\n\tbegin : GEN_SUBSHIFT\n\t\t// {{{",
            "localparam NSHIFT = $clog2(DATA_WIDTH/INSN_WIDTH);",
            "reg rg_valid;",
            "reg [DATA_WIDTH-1:0]\trg_insn;",
            "reg [NSHIFT:0]\tr_count;",
            "reg [NSHIFT-1:0]\tr_shift;\n\n\t\t// rg_valid\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || i_new_pc) // || i_clear_cache)\n\t\t\trg_valid <= 1'b0;\n\t\telse if (r_valid)\n\t\t\trg_valid <= !i_ready || (r_count > 1);\n\t\telse if (!o_valid || i_ready)\n\t\tbegin\n\t\t\trg_valid <= 1'b0;\n\t\t\tif (cache_valid)\n\t\t\t\trg_valid <= 1'b1;\n\t\t\tif (o_wb_cyc && i_wb_ack && !(&r_shift))\n\t\t\t\trg_valid <= 1'b1;\n\t\tend\n\t\t// }}}\n\n\t\t// rg_insn\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (!o_valid || i_ready)\n\t\tbegin\n\t\t\tif (cache_valid && !r_valid)\n\t\t\tbegin\n\t\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\t\t\trg_insn <= cache_word >> INSN_WIDTH;\n\t\t\t\telse\n\t\t\t\t\trg_insn <= cache_word << INSN_WIDTH;\n\t\t\tend else if (i_wb_ack && !r_valid)\n\t\t\tbegin\n\t\t\t\trg_insn <= i_wb_data;\n\t\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\t\t\trg_insn <= i_wb_shifted >> INSN_WIDTH;\n\t\t\t\telse\n\t\t\t\t\trg_insn <= i_wb_shifted << INSN_WIDTH;\n\t\t\tend else begin\n\t\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\t\t\trg_insn <= rg_insn >> INSN_WIDTH;\n\t\t\t\telse\n\t\t\t\t\trg_insn <= rg_insn << INSN_WIDTH;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\t// r_count\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || i_new_pc) // || i_clear_cache)\n\t\t\tr_count <= 0;\n\t\telse if (o_valid && i_ready && r_valid)\n\t\tbegin\n\t\t\tr_count <= r_count - 1;\n\t\tend else if (!o_valid || (i_ready && !r_valid))\n\t\tbegin\n\t\t\tif (cache_valid)\n\t\t\t\tr_count <= { 1'b0, {(NSHIFT){1'b1}} };\n\t\t\telse if (o_wb_cyc && i_wb_ack)\n\t\t\t\tr_count <= { 1'b0, ~r_shift };\n\t\tend\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (!i_reset && !i_new_pc && !i_clear_cache)\n\t\tbegin\n\t\t\tif (!o_valid)\n\t\t\t\tassert(!r_valid);\n\t\t\tassert(r_valid == (r_count > 0));\n\t\t\tassert(r_count <= (1<<NSHIFT));\n\t\t\tif (r_valid)\n\t\t\tbegin\n\t\t\t\tassert(!cache_valid || !o_wb_cyc);\n\t\t\t\tassert(r_shift == 0);\n\t\t\tend else if (!i_new_pc && !i_clear_cache && !o_illegal)\n\t\t\t\tassert(invalid_bus_cycle || o_valid || o_wb_cyc);\n\t\tend\n`endif\n\t\t// }}}\n\n\t\t// r_shift\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (i_new_pc)\n\t\t\tr_shift <= i_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)];\n\t\t// else if (i_clear_cache)\n\t\t//\tr_shift <= o_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)];\n\t\telse if (o_wb_cyc && (i_wb_ack || i_wb_err))\n\t\t\tr_shift <= 0;\n\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (!i_reset && r_shift > 0)\n\t\t\tassert(!o_valid && !r_valid);\n`endif\n\t\t// }}}\n\n\t\tassign\tr_valid = rg_valid;\n\t\tassign\tr_insn  = rg_insn;\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin : GEN_LITTLE_ENDIAN_SHIFT\n\t\t\tassign\ti_wb_shifted = i_wb_data >> (r_shift * INSN_WIDTH);\n\t\tend else begin : GEN_BIGENDIAN_SHIFT\n\t\t\tassign\ti_wb_shifted = i_wb_data << (r_shift * INSN_WIDTH);\n\t\tend\n\n\t\t// Keep Verilator happy\n\t\t// {{{\n\t\t// Verilator lint_off UNUSED",
            "wire unused_shift;\n\t\tassign\tunused_shift = &{ 1'b0,\n\t\t\t\tr_insn[DATA_WIDTH-1:INSN_WIDTH],\n\t\t\t\ti_wb_shifted[DATA_WIDTH-1:INSN_WIDTH] };\n\t\t// Verilator lint_on  UNUSED\n\t\t// }}}\n`ifdef\tFORMAL\n\t\tassign\tf_bus_word = rg_insn << ((r_count-1)* INSN_WIDTH);\n\t\talways @(*)\n\t\tif (!i_reset && r_valid)\n\t\tbegin\n\t\t\tassert(i_clear_cache || i_new_pc || o_valid);\n\t\t\tassert(r_shift == 0);\n\t\t\tassert((r_count + o_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)])\n\t\t\t\t== ((1<<NSHIFT)-1));\n\t\tend else if (!i_reset && !o_valid && o_wb_cyc && !invalid_bus_cycle)\n\t\tbegin\n\t\t\tassert(r_shift == o_pc[$clog2(DW/8)-1:$clog2(INSN_WIDTH/8)]);\n\t\tend\n`endif\n\t\t// }}}\n\tend else begin : NO_SUBSHIFT\n\t\t// {{{\n\t\tassign\tr_valid = 1'b0;\n\t\tassign\tr_insn  = {(INSN_WIDTH){1'b0}};\n\t\tassign\ti_wb_shifted = i_wb_data;\n\t\t// }}}\n\tend endgenerate\n\n\t// o_valid\n\t// {{{\n\tinitial\to_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_new_pc || i_clear_cache)\n\t\to_valid <= 1'b0;\n\telse if (o_wb_cyc &&(i_wb_ack || i_wb_err))\n\t\to_valid <= 1'b1;\n\telse if (i_ready)\n\t\to_valid <= cache_valid || r_valid;\n\t// }}}\n\n\t// o_insn\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!o_valid || i_ready)\n\tbegin\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tif (r_valid)\n\t\t\t\to_insn <= r_insn[INSN_WIDTH-1:0];\n\t\t\telse if (cache_valid)\n\t\t\t\to_insn <= cache_word[INSN_WIDTH-1:0];\n\t\t\telse\n\t\t\t\to_insn <= i_wb_shifted[INSN_WIDTH-1:0];\n\t\tend else begin\n\t\t\tif (r_valid)\n\t\t\t\to_insn <= r_insn[DW-1:DW-INSN_WIDTH];\n\t\t\telse if (cache_valid)\n\t\t\t\to_insn <= cache_word[DW-1:DW-INSN_WIDTH];\n\t\t\telse\n\t\t\t\to_insn <= i_wb_shifted[DW-1:DW-INSN_WIDTH];\n\t\tend\n\tend\n\t// }}}\n\n\t// o_pc\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_new_pc)\n\t\to_pc <= i_pc;\n\telse if (o_valid && i_ready) // && !i_clear_cache\n\tbegin\n\t\to_pc <= 0;\n\t\to_pc[AW-1:$clog2(INSN_WIDTH/8)]\n\t\t\t<= o_pc[AW-1:$clog2(INSN_WIDTH/8)] + 1'b1;\n\tend\n\t// }}}\n\n\t// o_illegal\n\t// {{{\n\tinitial\to_illegal = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_new_pc || i_clear_cache)\n\t\to_illegal <= 1'b0;\n\telse if (!r_valid && (!o_valid || i_ready) && !o_illegal)\n\tbegin\n\t\tif (cache_valid)\n\t\t\to_illegal <= cache_illegal;\n\t\telse if (o_wb_cyc && i_wb_err)\n\t\t\to_illegal <= 1'b1;\n\tend\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Now for the",
            "output /cached word\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// cache_valid\n\t// {{{\n\tinitial\tcache_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(i_new_pc)||(i_clear_cache))\n\t\tcache_valid <= 1'b0;\n\telse begin\n\t\tif (o_valid && o_wb_cyc &&(i_wb_ack || i_wb_err))\n\t\t\tcache_valid <= !i_ready || r_valid;\n\t\telse if (i_ready && !r_valid)\n\t\t\tcache_valid <= 1'b0;\n\tend\n`ifdef\tFORMAL\n\talways @(*)\n\tif (!i_reset && cache_valid && o_wb_cyc)\n\t\tassert(!i_wb_ack && !i_wb_err);\n`endif\n\t// }}}\n\n\t// cache_word\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_wb_ack)\n\t\tcache_word <= i_wb_data;\n\t// }}}\n\n\t// cache_illegal\n\t// {{{\n\tinitial\tcache_illegal = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_clear_cache || i_new_pc)\n\t\tcache_illegal <= 1'b0;\n\t// Older",
            "logic ...\n\t// else if ((o_wb_cyc)&&(i_wb_err)&&(o_valid)&&(!i_ready))\n\t//\tcache_illegal <= 1'b1;\n\telse if (o_wb_cyc && i_wb_err)\n\t\t\t//  && o_valid && (!i_ready || r_valid))\n\t\tcache_illegal <= 1'b1;\n\t// }}}\n\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal property section\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Local declarations\n\t// {{{\n\t// Keep track of a flag telling us whether or not $past()\n\t// will return valid results",
            "reg f_past_valid;\n\n\t// Keep track of some alternatives to $past that can still be used\n\t// in a VERILATOR environment",
            "reg [AW-1:0]\tf_next_addr, f_dbl_next, f_cache_addr; //bytaddr",
            "localparam F_LGDEPTH=2;",
            "wire [(F_LGDEPTH-1):0]\tf_nreqs, f_nacks, f_outstanding;",
            "wire [AW-1:0]\tf_const_addr;",
            "wire [DW-1:0]\tf_const_insn;",
            "wire f_const_illegal;",
            "wire f_this_pc,\n\t\tf_this_insn, f_this_return;",
            "wire [AW-$clog2(DATA_WIDTH/8)-1:0]\tthis_return_address,\n\t\t\t\tf_const_bus_addr, next_pc_address;",
            "wire [AW-1:0]\tf_address;\n\t(* anyconst *)",
            "wire [DW-1:0]\tf_const_bus_word;",
            "reg [AW-$clog2(DW/8)-1:0]\tpc_bus_addr, pc_bus_addr_next,\n\t\t\t\t\tpc_bus_addr_dbl;\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\t// }}}\n\n\tgenerate if (INSN_WIDTH == 8)\n\tbegin : F_NEXT_BYTE_ADDR\n\t\t// {{{\n\t\t// BUS addresses\n\t\talways @(*)\n\t\t\tf_next_addr = o_pc + (r_valid ? 0:1);\n\t\t// }}}\n\tend else begin : F_NEXT_ADDR\n\t\t// {{{\n\t\t// BUS addresses\n\t\talways @(*)\n\t\tif (r_valid)\n\t\t\tf_next_addr = o_pc;\n\t\telse begin\n\t\t\tf_next_addr = o_pc + (INSN_WIDTH/8);\n\t\t\tf_next_addr[$clog2(INSN_WIDTH/8)-1:0] = 0;\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\talways @(*)\n\tbegin\n\t\t// BUS addresses\n\t\tf_dbl_next = f_next_addr + (DATA_WIDTH/8);\n\t\tif (r_valid)\n\t\t\tf_dbl_next = f_dbl_next + (DATA_WIDTH/8);\n\t\tf_dbl_next[$clog2(DATA_WIDTH/8)-1:0] = 0;\n\n\t\tf_cache_addr = o_pc + (DATA_WIDTH/8);\n\t\tf_cache_addr[$clog2(DATA_WIDTH/8)-1:0] = 0;\n\tend\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions about our",
            "input s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t//\n\n\t//\n\t// Assume that resets, new-pc commands, and clear-cache commands\n\t// are never more than pulses--one clock wide at most.\n\t//\n\t// It may be that the CPU treats us differently.  We'll only restrict\n\t// our solver to this here.\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Wishbone bus properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Add a bunch of wishbone-based asserts\n\tfwb_master #(\n\t\t// {{{\n\t\t.AW(AW-$clog2(DATA_WIDTH/8)), .DW(DW), .F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_MAX_STALL(2),\n\t\t\t.F_MAX_REQUESTS(0), .F_OPT_SOURCE(1),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t\t.F_OPT_DISCONTINUOUS(0)\n\t\t// }}}\n\t) f_wbm(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\t\to_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data,\n\t\t\t\t{(DW/8){1'b1}},\n\t\t\ti_wb_ack, i_wb_stall, i_wb_data, i_wb_err,\n\t\t\tf_nreqs, f_nacks, f_outstanding\n\t\t// }}}\n\t);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions about our interaction with the CPU\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tffetch #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(AW-$clog2(INSN_WIDTH/8)),\n\t\t.INSN_WIDTH(INSN_WIDTH)\n\t\t// }}}\n\t) cpu(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.cpu_new_pc(i_new_pc), .cpu_clear_cache(i_clear_cache),\n\t\t.cpu_pc(i_pc), .pf_valid(o_valid), .cpu_ready(i_ready),\n\t\t.pf_pc(o_pc), .pf_insn(o_insn), .pf_illegal(o_illegal),\n\t\t.fc_illegal(f_const_illegal), .fc_insn(f_const_insn),\n\t\t.fc_pc(f_const_addr), .f_address(f_address)\n\t\t// }}}\n\t);\n\n\tassign\tf_const_bus_addr = f_const_addr[AW-1:$clog2(DATA_WIDTH/8)];\n\n\t//\n\t// Let's make some assumptions about how long it takes our phantom\n\t// (i.e. assumed) CPU to respond.\n\t//\n\t// This delay needs to be long enough to flush out any potential\n\t// errors, yet still short enough that the formal method doesn't\n\t// take forever to solve.\n\t//",
            "localparam F_CPU_DELAY = 4;",
            "reg [4:0]\tf_cpu_delay;\n\n\t// Now, let's look at the delay the CPU takes to accept an instruction.\n\talways @(posedge i_clk)\n\t// If no instruction is ready, then keep our counter at zero\n\tif ((!o_valid)||(i_ready))\n\t\tf_cpu_delay <= 0;\n\telse\n\t\t// Otherwise, count the clocks the CPU takes to respond\n\t\tf_cpu_delay <= f_cpu_delay + 1'b1;\n\n\talways @(posedge i_clk)\n\t\tassume(f_cpu_delay < F_CPU_DELAY);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about our",
            "output s\n\t// {{{\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_wb_stb))&&(!$past(i_wb_stall))\n\t\t\t&&($past(!i_new_pc && !i_clear_cache)))\n\t\tassert(o_wb_addr <= $past(o_wb_addr)+1'b1);\n\n\t//\n\t// The cache doesn't change if we are stalled\n\t//\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t\t&&(!$past(i_new_pc))&&(!$past(i_clear_cache))\n\t\t\t&&($past(o_valid))&&(!$past(i_ready || r_valid))\n\t\t\t&&($past(cache_valid)))\n\tbegin\n\t\tassert($stable(cache_valid));\n\t\tassert($stable(cache_word));\n\t\tassert($stable(cache_illegal));\n\tend\n\n\t// Consider it invalid to present the CPU with the same instruction\n\t// twice in a row.  Any effort to present the CPU with the same\n\t// instruction twice in a row must go through i_new_pc, and thus a\n\t// new bus cycle--hence the assertion below makes sense.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&& $past(!i_new_pc && !i_clear_cache)\n\t\t\t&&($past(o_valid && i_ready)))\n\t\tassert(o_pc == f_address);\n\n\talways @(posedge i_clk)\n\tif (!i_reset && !i_clear_cache && !i_new_pc)\n\t\tassert(o_pc == f_address);\n\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t\t&&(!$past(i_new_pc))\n\t\t\t&&(!$past(i_clear_cache))\n\t\t\t&&($past(o_wb_cyc))&&($past(i_wb_err)))\n\t\tassert( ((o_valid)&&(o_illegal))\n\t\t\t||((cache_valid)&&(cache_illegal)) );\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(o_illegal))&&(o_illegal))\n\t\tassert(o_valid);\n\n\talways @(posedge i_clk)\n\tif (!i_reset && cache_illegal)\n\t\tassert(!o_wb_cyc);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_new_pc)))\n\t\tassert(!o_valid);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&(!$past(i_clear_cache))\n\t\t\t&&($past(o_valid))&&(!o_valid)&&(!o_illegal))\n\t\tassert((o_wb_cyc)||(invalid_bus_cycle));\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// Our \"contract\" with the CPU\n\t// {{{\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// For any particular address, that address is associated with an\n\t// instruction and a flag",
            "reg arding whether or not it is illegal.\n\t//\n\t// Any attempt to return to the CPU a value from this address,\n\t// must return the value and the illegal flag.\n\t//\n\n\t//\n\t// While these",
            "wire s may seem like overkill, and while they make the\n\t// following",
            "logic perhaps a bit more obscure, these predicates make\n\t// it easier to follow the complex",
            "logic on a scope.  They don't\n\t// affect anything synthesized.\n\t//\n\tassign\tf_this_pc   = (o_pc[AW-1:$clog2(INSN_WIDTH/8)]\n\t\t\t\t== f_const_addr[AW-1:$clog2(INSN_WIDTH/8)]);\n\tassign\tf_this_insn = (o_insn    ==   f_const_insn);\n\n\t// Verilator lint_off WIDTH\n\tassign\tf_this_return = (o_wb_addr - f_outstanding == f_const_addr[AW-1:$clog2(DATA_WIDTH/8)]);\n\t// Verilator lint_on  WIDTH\n\n\n\t//\n\t//\n\t// Here's our contract:\n\t//\n\t// Any time we return a value for the address above, it *must* be\n\t// the \"right\" value.\n\t//\n\talways @(*)\n\tif (o_valid && f_this_pc)\n\tbegin\n\t\tif (f_const_illegal)\n\t\t\tassert(o_illegal);\n\t\tif (!o_illegal)\n\t\t\tassert(f_this_insn);\n\tend\n\n\t//\n\t// The contract will only work if we assume the return from the\n\t// bus at this address will be the right return.\n\talways @(*)\n\tif ((o_wb_cyc)&&(f_this_return))\n\tbegin\n\t\tif (i_wb_ack)\n\t\t\tassume(i_wb_data == f_const_bus_word);\n\n\t\tif (f_const_illegal)\n\t\tbegin\n\t\t\tassume(!i_wb_ack);\n\t\tend else\n\t\t\tassume(!i_wb_err);\n\tend\n\n\tgenerate if (INSN_WIDTH == DATA_WIDTH)\n\tbegin : F_SAME_BUS_WORD\n\t\t// {{{\n\t\talways @(*)\n\t\t\tassume(f_const_bus_word == f_const_insn);\n\t\t// }}}\n\tend else begin : F_CHECK_SHIFTED_WORD\n\t\t// {{{",
            "wire [DW-1:0]\tf_shifted_insn;",
            "localparam IW = INSN_WIDTH;\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tassign  f_shifted_insn = f_const_bus_word\n\t\t\t\t>> (f_const_addr[$clog2(DW/8)-1:$clog2(IW/8)] * IW);\n\t\t\talways @(*)\n\t\t\t\tassume(f_shifted_insn[IW-1:0] == f_const_insn);\n\n\t\tend else begin\n\t\t\tassign  f_shifted_insn = f_const_bus_word\n\t\t\t\t<< (f_const_addr[$clog2(DW/8)-1:$clog2(IW/8)] * IW);\n\n\t\t\talways @(*)\n\t\t\t\tassume(f_shifted_insn[DW-1:DW-IW]\n\t\t\t\t\t== f_const_insn);\n\n\t\tend\n                // }}}\n\tend endgenerate\n\n\t//\n\t// Here is a corrollary to our contract.  Anything in the one-word\n\t// cache must also match the contract as well.\n\t//\n\talways @(*)\n\tif ((f_cache_addr[AW-1:$clog2(DATA_WIDTH/8)] == f_const_bus_addr)\n\t\t\t&&(cache_valid))\n\tbegin\n\t\tif (!cache_illegal)\n\t\t\tassert(cache_word == f_const_bus_word);\n\n\t\tif (f_const_illegal)\n\t\t\tassert(cache_illegal);\n\t\telse\n\t\t\tassert(o_illegal || !cache_illegal);\n\tend\n\n\t// always @(posedge i_clk)\n\t// if ((f_past_valid)&&(!$past(cache_illegal))&&(!cache_valid))\n\t//\tassert(!cache_illegal);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Additional assertions necessary to pass induction\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// We have only a one word cache.  Hence, we shouldn't be asking\n\t// for more data any time we have nowhere to put it.\n\talways @(*)\n\tif (o_wb_stb)\n\t\tassert(!cache_valid || i_ready);\n\n\talways @(*)\n\tif (o_valid && cache_valid)\n\t\tassert((f_outstanding == 0)&&(!o_wb_stb));\n\n\talways @(*)\n\tif (o_valid && (r_valid || !i_ready))\n\t\tassert(f_outstanding < 2);\n\n\talways @(*)\n\tif (!o_valid || (i_ready && !r_valid))\n\t\tassert(f_outstanding <= 2);\n\n\t// always @(posedge i_clk)\n\t// if ((f_past_valid)&&($past(o_wb_cyc && !o_wb_stb)) &&(o_wb_cyc))\n\t//\tassert(inflight != 0);\n\n\talways @(*)\n\tif (o_wb_cyc && i_wb_ack)\n\t\tassert(!cache_valid);\n\n\talways @(posedge i_clk)\n\tif (o_wb_cyc)\n\t\tassert(inflight == f_outstanding);\n\n\t// Verilator lint_off WIDTH\n\tassign\tthis_return_address = o_wb_addr - f_outstanding;\n\t// Verilator lint_on  WIDTH\n\tassign\tnext_pc_address = f_next_addr[AW-1:$clog2(DATA_WIDTH/8)];\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Address checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tbegin\n\t\tpc_bus_addr      = o_pc[AW-1:$clog2(DW/8)];\n\t\tpc_bus_addr_next = pc_bus_addr + 1;\n\t\tpc_bus_addr_dbl  = pc_bus_addr + 2;\n\tend\n\n\talways @(*)\n\tif (i_reset || o_illegal || invalid_bus_cycle)\n\tbegin\n\tend else if (!o_valid)\n\tbegin\n\t\tif (o_wb_cyc)\n\t\tbegin\n\t\t\tif (inflight == 0)\n\t\t\t\tassert(o_wb_addr == pc_bus_addr);\n\t\t\tassert(pc_bus_addr == this_return_address);\n\t\tend\n\tend else if (cache_valid || (o_wb_cyc && !o_wb_stb))\n\tbegin\n\t\tassert(o_wb_addr == pc_bus_addr_dbl);\n\tend else if (o_valid)\n\t\tassert(o_wb_addr == pc_bus_addr_next);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid &&($past(!i_reset && !i_new_pc && !i_clear_cache))\n\t\t\t&&(!$past(invalid_bus_cycle)))\n\tbegin\n\t\tif (($past(o_wb_cyc && (i_wb_ack || i_wb_err)))\n\t\t\t&&($past(!o_valid || (i_ready && !r_valid)))\n\t\t\t&&(!$past(cache_valid)))\n\t\tbegin\n\t\t\tassert(o_pc[AW-1:$clog2(DW/8)] == $past(this_return_address));\n\t\tend else if (cache_valid)\n\t\tbegin\n\t\t\tassert(o_wb_addr == pc_bus_addr_dbl);\n\t\t\tassert(f_outstanding == 0);\n\t\tend else if (o_valid)\n\t\tbegin\n\t\t\tif (f_outstanding == 0)\n\t\t\t\tassert(o_illegal || o_wb_addr == pc_bus_addr_next);\n\t\t\telse if (f_outstanding == 1)\n\t\t\t\tassert(o_illegal || o_wb_addr == pc_bus_addr_dbl);\n\t\t\telse if (f_outstanding == 2)\n\t\t\t\tassert(o_wb_addr == pc_bus_addr_dbl);\n\t\tend else if (o_wb_cyc)\n\t\t\tassert(o_pc[AW-1:$clog2(DW/8)] == this_return_address);\n\tend\n\n\talways @(posedge i_clk)\n\tif (!i_reset && o_illegal)\n\tbegin\n\t\tassert(!o_wb_cyc);\n\t\tassert(cache_illegal);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_wb_cyc && !i_new_pc))&&(!o_valid)\n\t\t\t&&(o_wb_cyc))\n\t\tassert(o_pc[AW-1:$clog2(DW/8)] == this_return_address);\n\n\talways @(posedge i_clk)\n\tif (o_valid && !o_wb_cyc && !o_illegal)\n\tbegin\n\t\tif (cache_valid)\n\t\t\tassert(f_dbl_next[AW-1:$clog2(DW/8)] == o_wb_addr);\n\t\telse\n\t\t\tassert(pc_bus_addr_next == o_wb_addr);\n\n\tend\n\n\talways @(*)\n\tif (o_wb_cyc || o_valid)\n\tbegin\n\t\tassert(o_wb_addr == pc_bus_addr\n\t\t\t|| o_wb_addr == pc_bus_addr_next\n\t\t\t|| o_wb_addr == pc_bus_addr_dbl);\n\tend\n\n//\talways @(posedge i_clk)\n//\tif ((f_past_valid)&& $past(o_wb_cyc && !cache_valid) && cache_valid)\n//\t\tassert(next_pc_address == $past(this_return_address));\n\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_wb_cyc))&&(o_wb_cyc))\n\tbegin\n\t\tif (o_valid && !cache_valid)\n\t\tbegin\n\t\t\t// assert(this_return_address == next_pc_address);\n\t\tend else if (!o_valid)\n\t\t\tassert(this_return_address == o_pc[AW-1:$clog2(DW/8)]);\n\tend else if ((f_past_valid)&&(!invalid_bus_cycle)\n\t\t\t&&(!o_wb_cyc)&&(o_valid)&&(!o_illegal)\n\t\t\t&&(!cache_valid))\n\t\tassert(o_wb_addr == next_pc_address);\n\n\n\talways @(*)\n\tif (invalid_bus_cycle)\n\t\tassert(!o_wb_cyc);\n\n\talways @(*)\n\tif (cache_valid)\n\t\tassert(o_valid);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover statements\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg f_cvr_aborted, f_cvr_fourth_ack;\n\n\talways @(posedge i_clk)\n\tcover((f_past_valid)&&($past(f_nacks)==3)\n\t\t&&($past(i_wb_ack))&&($past(o_wb_cyc)));\n\n\tinitial\tf_cvr_aborted = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_cvr_aborted <= 0;\n\telse if (!o_wb_cyc && (f_nreqs != f_nacks))\n\t\tf_cvr_aborted <= 1;\n\n\tinitial\tf_cvr_fourth_ack = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_cvr_fourth_ack <= 0;\n\telse if ((f_nacks == 3)&&(o_wb_cyc && i_wb_ack))\n\t\tf_cvr_fourth_ack <= 1;\n\n\talways @(posedge i_clk)\n\t\tcover(!o_wb_cyc && (f_nreqs == f_nacks)\n\t\t\t&& !f_cvr_aborted && f_cvr_fourth_ack);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Temporary simplifications\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// }}}\n\n\t// Make Verilator happy -- formal section\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "wire unused_formal;\n\tassign\tunused_formal = &{ f_dbl_next[1:0], f_const_addr[1:0] };\n\t// Verilator lint_on  UNUSED\n\t// }}}\n`endif\t// FORMAL\n// }}}",
            "endmodule //\n// Usage:\t\t(this)\t(prior)\t(old)  (S6)\n//    Cells\t\t374\t387\t585\t459\n//\tFDRE\t\t135\t108\t203\t171\n//\tLUT1\t\t  2\t  3\t  2\n//\tLUT2\t\t  9\t  3\t  4\t  5\n//\tLUT3\t\t 98\t 76\t104\t 71\n//\tLUT4\t\t  2\t  0\t  2\t  2\n//\tLUT5\t\t  3\t 35\t 35\t  3\n//\tLUT6\t\t  6\t  5\t 10\t 43\n//\tMUXCY\t\t 58\t 62\t 93\t 62\n//\tMUXF7\t\t  1\t  0\t  2\t  3\n//\tMUXF8\t\t  0\t  1\t  1\n//\tRAM64X1D\t  0\t 32\t 32\t 32\n//\tXORCY\t\t 60\t 64\t 96\t 64\n//"
        ]
    },
    {
        "file_name": "axilfetch.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axilfetch.v",
        "chunks": [
            "module axilfetch #(\n\t\t// {{{",
            "parameter C_AXI_ADDR_WIDTH = 32,",
            "parameter C_AXI_DATA_WIDTH = 64,",
            "parameter INSN_WIDTH=32,",
            "parameter FETCH_LIMIT=16,",
            "parameter [0:0]\tSWAP_ENDIANNESS = 1'b0,",
            "localparam AW=C_AXI_ADDR_WIDTH\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,\n\t\t//\n\t\t// CPU interaction",
            "wire s\n\t\t// {{{",
            "input ",
            "wire i_cpu_reset,",
            "input ",
            "wire i_new_pc,",
            "input ",
            "wire i_clear_cache,",
            "input ",
            "wire i_ready,",
            "input ",
            "wire [AW-1:0]\ti_pc,\t// Ignd unls i_new_pc",
            "output ",
            "wire [INSN_WIDTH-1:0]\to_insn,\t// Insn read from bus",
            "output ",
            "reg [AW-1:0]\to_pc,\t// Addr of that insn",
            "output ",
            "reg o_valid,\t// If valid",
            "output ",
            "reg o_illegal,\t// Bus error\n\t\t// }}}\n\t\t// AXI-lite bus interface\n\t\t// {{{",
            "output ",
            "reg M_AXI_ARVALID,",
            "input ",
            "wire M_AXI_ARREADY,",
            "output ",
            "reg [C_AXI_ADDR_WIDTH-1:0]\tM_AXI_ARADDR,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [2:0]\t\t\tM_AXI_ARPROT,\n\t\t// Verilator coverage_on\n\t\t//",
            "input ",
            "wire M_AXI_RVALID,",
            "output ",
            "wire M_AXI_RREADY,",
            "input ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_AXI_RDATA,",
            "input ",
            "wire [1:0]\t\t\tM_AXI_RRESP\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam AXILLSB = $clog2(C_AXI_DATA_WIDTH/8);",
            "localparam INSNS_PER_WORD = C_AXI_DATA_WIDTH / INSN_WIDTH;",
            "localparam INSN_LSB = $clog2(INSN_WIDTH/8);",
            "localparam LGDEPTH = $clog2(FETCH_LIMIT)+4;",
            "localparam LGFIFO = $clog2(FETCH_LIMIT);",
            "localparam W = LGDEPTH;",
            "localparam FILLBITS = $clog2(INSNS_PER_WORD);\n\t\t\t// ($clog2(INSNS_PER_WORD) > 0)\n\t\t\t//\t\t\t? $clog2(INSNS_PER_WORD) : 1);",
            "reg [W:0]\t\t\tnew_flushcount, outstanding,\n\t\t\t\t\tnext_outstanding, flushcount;",
            "reg flushing, flush_request, full_bus;",
            "wire [((AXILLSB>INSN_LSB) ? (AXILLSB-INSN_LSB-1):0):0]\tshift;",
            "wire fifo_reset, fifo_wr, fifo_rd;",
            "wire ign_fifo_full, fifo_empty;",
            "wire [LGFIFO:0]\t\tign_fifo_fill;",
            "wire [C_AXI_DATA_WIDTH:0]\tfifo_data;",
            "reg pending_new_pc;",
            "reg [C_AXI_ADDR_WIDTH-1:0]\tpending_pc;",
            "reg [W-1:0]\t\t\tfill;",
            "reg [FILLBITS:0]\tout_fill;",
            "reg [C_AXI_DATA_WIDTH-1:0]\tout_data;",
            "reg [C_AXI_DATA_WIDTH-1:0]\tendian_swapped_rdata;\n`ifdef\tFORMAL",
            "wire f_cache_valid;",
            "wire [C_AXI_DATA_WIDTH-1:0]\tf_cache_data;",
            "wire f_cache_illegal;",
            "wire [LGFIFO:0]\t\tf_cache_distance;\n`endif\n\t// }}}\n\n\tassign\tfifo_reset = i_cpu_reset || i_clear_cache || i_new_pc;\n\tassign\tfifo_wr = M_AXI_RVALID && !flushing;\n\n\n\t// ARPROT = 3'b100 for an unprivileged, secure instruction access\n\t// (not sure what unprivileged or secure mean--even after reading the\n\t//  spec)\n\tassign\tM_AXI_ARPROT = 3'b100;\n\n\t// next_outstanding\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tnext_outstanding = outstanding;\n\n\t\tcase({ M_AXI_ARVALID && M_AXI_ARREADY, M_AXI_RVALID })\n\t\t2'b10: next_outstanding = outstanding + 1;\n\t\t2'b01: next_outstanding = outstanding - 1;\n\t\tdefault: begin end\n\t\tendcase\n\tend\n\t// }}}\n\n\t// outstanding, full_bus\n\t// {{{\n\tinitial\toutstanding = 0;\n\tinitial\tfull_bus    = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\tbegin\n\t\toutstanding <= 0;\n\t\tfull_bus <= 0;\n\tend else begin\n\t\toutstanding <= next_outstanding;\n\t\tfull_bus <= (next_outstanding\n\t\t\t// + (((M_AXI_ARVALID && !M_AXI_ARREADY) ? 1:0)\n\t\t\t\t\t\t>= (1<<LGDEPTH)-1);\n\tend\n\t// }}}\n\n\t// fill\n\t// {{{\n\tinitial\tfill = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (fifo_reset)\n\t\tfill <= 0;\n\t// else if (fo_reset || flushing)\n\t//\tfill <= 0;\n\telse case({ M_AXI_ARVALID && M_AXI_ARREADY && !flush_request,\n\t\t\t\tfifo_rd && !fifo_empty })\n\t2'b10: fill <= fill + 1;\n\t2'b01: fill <= fill - 1;\n\tdefault: begin end\n\tendcase\n\t// }}}\n\n\t// new_flushcount\n\t// {{{\n\talways @(*)\n\t\tnew_flushcount = outstanding + (M_AXI_ARVALID ? 1:0)\n\t\t\t\t- (M_AXI_RVALID ? 1:0);\n\t// }}}\n\n\t// flushcount, flushing, flush_request\n\t// {{{\n\tinitial\tflushcount = 0;\n\tinitial\tflushing   = 0;\n\tinitial\tflush_request = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\tbegin\n\t\tflushcount <= 0;\n\t\tflushing   <= 0;\n\t\tflush_request <= 0;\n\tend else if (fifo_reset)\n\tbegin\n\t\tflushcount <= new_flushcount;\n\t\tflushing   <= (new_flushcount > 0);\n\t\tflush_request <= (M_AXI_ARVALID && !M_AXI_ARREADY);\n\tend else begin\n\t\tif (M_AXI_RVALID && flushcount > 0)\n\t\tbegin\n\t\t\tflushcount <= flushcount - 1;\n\t\t\t// Verilator lint_off CMPCONST\n\t\t\tflushing   <= (flushcount > 1);\n\t\t\t// Verilator lint_on  CMPCONST\n\t\tend\n\n\t\tif (M_AXI_ARREADY)\n\t\t\tflush_request <= 0;\n\tend\n\t// }}}\n\n\t// M_AXI_ARVALID\n\t// {{{\n\tinitial\tM_AXI_ARVALID = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tM_AXI_ARVALID <= 1'b0;\n\telse if (!M_AXI_ARVALID || M_AXI_ARREADY)\n\tbegin\n\t\tM_AXI_ARVALID <= 1;\n\t\tif (i_new_pc || pending_new_pc)\n\t\t\tM_AXI_ARVALID <= 1'b1;\n\n\t\t//\n\t\t// Throttle the number of requests we make\n\t\t// Verilator lint_off CMPCONST\n\t\t// Verilator lint_off WIDTH\n\t\t//\tout_fill will only capture 0 or 1 if DATA_WIDTH == 32\n\t\tif (fill + (M_AXI_ARVALID ? 1:0)\n\t\t\t\t+ ((o_valid &&(!i_ready || out_fill > 1)) ? 1:0)\n\t\t\t\t>= FETCH_LIMIT)\n\t\t\tM_AXI_ARVALID <= 1'b0;\n\t\t// Verilator lint_on  WIDTH\n\t\t// Verilator lint_on  CMPCONST\n\t\tif (i_cpu_reset || i_clear_cache || full_bus)\n\t\t\tM_AXI_ARVALID <= 1'b0;\n\tend\n\t// }}}\n\n\tassign\tM_AXI_RREADY = 1'b1;\n\n\t// pending_new_pc\n\t// {{{\n\tinitial\tpending_new_pc = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || i_clear_cache)\n\t\tpending_new_pc <= 1'b0;\n\telse if (!M_AXI_ARVALID || M_AXI_ARREADY)\n\t\tpending_new_pc <= 1'b0;\n\telse if (i_new_pc)\n\t\tpending_new_pc <= 1'b1;\n\t// }}}\n\n\t// pending_pc\n\t// {{{\n\tinitial\tpending_pc = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_new_pc)\n\t\tpending_pc <= i_pc;\n\t// }}}\n\n\t// M_AXI_ARADDR\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!M_AXI_ARVALID || M_AXI_ARREADY)\n\tbegin\n\t\tif (i_new_pc)\n\t\t\tM_AXI_ARADDR <= i_pc;\n\t\telse if (pending_new_pc)\n\t\t\tM_AXI_ARADDR <= pending_pc;\n\t\telse if (M_AXI_ARVALID)\n\t\tbegin\n\t\t\tM_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:AXILLSB]\n\t\t\t\t<= M_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:AXILLSB] +1;\n\t\t\tM_AXI_ARADDR[AXILLSB-1:0] <= 0;\n\t\tend\n\tend\n\t// }}}\n\n\t// o_pc\n\t// {{{\n\tinitial\to_pc = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_new_pc)\n\t\to_pc <= i_pc;\n\telse if (o_valid && i_ready && !o_illegal)\n\tbegin\n\t\to_pc <= 0;\n\t\to_pc[AW-1:INSN_LSB] <= o_pc[AW-1:INSN_LSB] + 1;\n\tend\n\t// }}}\n\n\tgenerate if (AXILLSB > INSN_LSB)\n\tbegin : BIG_WORD\n\t\t// {{{\n\t\tassign\tshift = o_pc[AXILLSB-1:INSN_LSB];\n\t\t// }}}\n\tend else begin : NO_SHIFT\n\t\t// {{{\n\t\tassign\tshift = 0;\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate if (SWAP_ENDIANNESS)\n\tbegin : SWAPPED_ENDIANNESS\n\t\t// {{{\n\t\tgenvar\tgw, gb;\t// Word count, byte count\n\n\t\tfor(gw=0; gw<C_AXI_DATA_WIDTH/INSN_WIDTH; gw=gw+1) // For each bus word\n\t\tbegin : FOR_INSN_WORD\n\t\t\tfor(gb=0; gb<(INSN_WIDTH/8); gb=gb+1) // For each bus byte\n\t\t\tbegin : FOR_INSN_BYTE\n\t\t\t\talways @(*)\n\t\t\t\t\tendian_swapped_rdata[gw*INSN_WIDTH\n\t\t\t\t\t\t+ ((INSN_WIDTH/8)-1-gb)*8 +: 8]\n\t\t\t\t= M_AXI_RDATA[gw*INSN_WIDTH+gb*8 +: 8];\n\t\t\tend\n\t\tend\n\t\t// }}}\n\tend else begin : NO_ENDIAN_SWAP\n\t\t// {{{\n\t\talways @(*)\n\t\t\tendian_swapped_rdata = M_AXI_RDATA;\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate if (FETCH_LIMIT <= 1)\n\tbegin : NOCACHE\n\t\t// {{{\n\t\t// No cache\n\n\t\t// assign\tfifo_rd    = fifo_wr;\n\t\t// Verilator lint_off CMPCONST\n\t\tassign\tfifo_rd = !o_valid || (i_ready && (out_fill <= 1));\n\t\t// Verilator lint_on  CMPCONST\n\t\tassign\tfifo_empty = !fifo_wr; //(out_fill <= (i_aready ? 1:0));\n\t\tassign\tfifo_data  = { M_AXI_RRESP[1], endian_swapped_rdata };\n\n\t\tassign\tign_fifo_fill = 1'b0;\n\t\tassign\tign_fifo_full = 1'b0;\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (M_AXI_RVALID || M_AXI_ARVALID || outstanding > 0)\n\t\t\tassert(!o_valid);\n\n\t\tassign\tf_cache_valid   = 1'b0;\n\t\tassign\tf_cache_data    = 0;\n\t\tassign\tf_cache_illegal = 1'b0;\n\t\tassign\tf_cache_distance= 0;\n`endif\n\t\t// }}}\n\tend else if (FETCH_LIMIT == 2)\n\tbegin : DBLFETCH\n\t\t// {{{\n\t\t// Single word cache",
            "reg cache_valid;",
            "reg [C_AXI_DATA_WIDTH:0]\tcache_data;\n\n\t\t// Verilator lint_off CMPCONST\n\t\tassign\tfifo_rd = !o_valid || (i_ready && (out_fill <= 1));\n\t\t// Verilator lint_on  CMPCONST\n\t\tassign\tfifo_empty =(!M_AXI_RVALID && !cache_valid) || flushing;\n\t\tassign\tfifo_data = cache_valid ? cache_data\n\t\t\t\t\t: ({ M_AXI_RRESP[1], endian_swapped_rdata });\n\n\n\t\tassign\tign_fifo_fill = cache_valid ? 1 : 0;\n\t\tassign\tign_fifo_full = cache_valid;\n\n\t\tinitial\tcache_valid = 1'b0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (fifo_reset)\n\t\t\tcache_valid <= 1'b0;\n\t\telse if (M_AXI_RVALID && o_valid && !fifo_rd)\n\t\t\tcache_valid <= 1;\n\t\telse if (fifo_rd)\n\t\t\tcache_valid <= 1'b0;\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (M_AXI_RVALID)\n\t\t\tcache_data <= { M_AXI_RRESP[1], endian_swapped_rdata };\n\n\t\t// Keep Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_dbl;\n\t\tassign\tunused_dbl = &{ 1'b0, fifo_wr };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n`ifdef\tFORMAL\n\t\tassign\tf_cache_valid = cache_valid;\n\t\tassign\t{ f_cache_illegal, f_cache_data }  = cache_data;\n\t\tassign\tf_cache_distance= 0;\n`endif\n\t\t// }}}\n\tend else begin : FIFO_FETCH\n\t\t// {{{\n\t\t// FIFO cache\n`ifdef\tFORMAL",
            "wire [LGFIFO:0]\tf_first_addr;",
            "wire [LGFIFO:0]\tf_second_addr;",
            "wire [C_AXI_DATA_WIDTH:0]\tf_first_data, f_second_data;",
            "wire f_first_in_fifo,\n\t\t\t\t\tf_second_in_fifo;",
            "wire [LGFIFO:0]\tf_distance_to_first,\n\t\t\t\t\tf_distance_to_second;\n`endif\n\n\n\t\t// Verilator lint_off CMPCONST\n\t\t//\tout_fill will only capture 0 or 1 if DATA_WIDTH == 32\n\t\tassign\tfifo_rd = !o_valid || (i_ready && (out_fill <= 1));\n\t\t// Verilator lint_on  CMPCONST\n\n\t\tsfifo #(\n\t\t\t// {{{\n\t\t\t.BW(1+C_AXI_DATA_WIDTH), .LGFLEN(LGFIFO)\n\t\t\t// }}}\n\t\t) fcache(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(fifo_reset),\n\t\t\t.i_wr(fifo_wr),\n\t\t\t.i_data({M_AXI_RRESP[1], endian_swapped_rdata }),\n\t\t\t.o_full(ign_fifo_full), .o_fill(ign_fifo_fill),\n\t\t\t.i_rd(fifo_rd),.o_data(fifo_data),.o_empty(fifo_empty)\n`ifdef\tFORMAL\n\t\t\t// {{{\n\t\t\t, .f_first_addr(f_first_addr),\n\t\t\t.f_second_addr(f_second_addr),\n\t\t\t.f_first_data(f_first_data),\n\t\t\t.f_second_data(f_second_data),\n\n\t\t\t.f_first_in_fifo(f_first_in_fifo),\n\t\t\t.f_second_in_fifo(f_second_in_fifo),\n\t\t\t.f_distance_to_first(f_distance_to_first),\n\t\t\t.f_distance_to_second(f_distance_to_second)\n\t\t\t// }}}\n`endif\n\t\t\t// }}}\n\t\t);\n\n`ifdef\tFORMAL\n\t\tassign\t{ f_cache_illegal, f_cache_data } = f_first_data;\n\t\tassign\tf_cache_distance = f_distance_to_first;\n\t\tassign\tf_cache_valid = f_first_in_fifo;\n`endif\n\t\t// }}}\n\tend endgenerate\n\n\t// o_valid\n\t// {{{\n\tinitial\to_valid = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (fifo_reset)\n\t\to_valid <= 1'b0;\n\telse if (!o_valid || i_ready)\n\t\to_valid <= (fifo_rd && !fifo_empty)\n\t\t\t|| out_fill > (o_valid ? 1:0);\n\t// }}}\n\n\t// out_fill\n\t// {{{\n\t// == number of instructions in the fifo_data word that have not (yet)\n\t//\tbeen accepted by the CPU.\n\t// == 0 when no data is available\n\t// == INSN_PER_WORD on the first instruction of any word\n\t// == 1 on the last instruction of any word\n\tinitial\tout_fill = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (fifo_reset)\n\t\tout_fill <= 0;\n\telse if (fifo_rd)\n\tbegin\n\t\tif (fifo_empty)\n\t\t\tout_fill <= 0;\n\t\telse if (o_valid)\n\t\t\tout_fill <= INSNS_PER_WORD[FILLBITS:0];\n\t\telse\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tout_fill <= (INSNS_PER_WORD[FILLBITS:0] - shift);\n\t\t\t// Verilator lint_on  WIDTH\n\tend else if (i_ready && out_fill > 0)\n\t\tout_fill <= out_fill - 1;\n\t// }}}\n\n\t// out_data\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (fifo_rd)\n\tbegin\n\t\tif (o_valid || (INSN_WIDTH == C_AXI_DATA_WIDTH))\n\t\t\tout_data <= fifo_data[C_AXI_DATA_WIDTH-1:0];\n\t\telse\n\t\tout_data <= fifo_data[C_AXI_DATA_WIDTH-1:0]>>(INSN_WIDTH*shift);\n\tend else if (i_ready)\n\t\tout_data <= out_data >> INSN_WIDTH;\n\t// }}}\n\n\tassign\to_insn = out_data[INSN_WIDTH-1:0];\n\n\t// o_illegal\n\t// {{{\n\tinitial\to_illegal = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (fifo_reset)\n\t\to_illegal <= 1'b0;\n\telse if (!o_illegal && fifo_rd && !fifo_empty)\n\t\to_illegal <= fifo_data[C_AXI_DATA_WIDTH];\n\t// }}}\n\n\t// Make verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = & { 1'b0, M_AXI_RRESP[0], ign_fifo_full, ign_fifo_fill };\n\t// verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Declarations\n\t// {{{",
            "localparam DW=INSN_WIDTH;",
            "localparam F_LGDEPTH=LGDEPTH+2;",
            "reg f_past_valid;",
            "wire [(F_LGDEPTH-1):0]\tfaxil_outstanding;\n\t// Verilator lint_off UNUSED",
            "wire [(F_LGDEPTH-1):0]\tfaxil_awr_outstanding,\n\t\t\t\t\tfaxil_wr_outstanding;\n\t// Verilator lint_on  UNUSED",
            "reg [(AW-1):0]\tf_last_pc;",
            "reg f_last_pc_valid;\n\t//",
            "reg [AW-1:0]\tfc_pc, f_address;",
            "reg fc_illegal;",
            "reg [INSN_WIDTH-1:0]\tfc_insn;\n\t//}}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Generic setup\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Keep track of a flag telling us whether or not $past()\n\t// will return valid results\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\t\tf_past_valid <= 1'b1;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions about our",
            "input s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Assume we start from a reset condition\n\t// {{{\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(!S_AXI_ARESETN);\n\n\talways @(*)\n\tif (!S_AXI_ARESETN)\n\t\tassume(i_cpu_reset);\n\t// }}}\n\n\t//\n\t//\n\t// Let's make some assumptions about how long it takes our\n\t// phantom bus and phantom CPU to respond.\n\t//\n\t// These delays need to be long enough to flush out any potential\n\t// errors, yet still short enough that the formal method doesn't\n\t// take forever to solve.\n\t//",
            "localparam F_CPU_DELAY = 4;",
            "reg [$clog2(F_CPU_DELAY):0]\tf_cpu_delay;\n\t// First, let's assume that any response from the bus comes back\n\t// within F_WB_DELAY clocks\n\n\t\t// Here's our delay assumption: We'll assume that the\n\t// wishbone will always respond within F_WB_DELAY clock ticks\n\t// of the beginning of any cycle.\n\t//\n\t// This includes both dropping the stall line, as well as\n\t// acknowledging any request.  While this may not be\n\t// a reasonable assumption for a piped master, it should\n\t// work here for us.\n\n\t// Count the number of clocks it takes the CPU to respond to our\n\t// instruction.\n\talways @(posedge S_AXI_ACLK)\n\t// If no instruction is ready, then keep our counter at zero\n\tif (i_cpu_reset|| !o_valid || i_ready)\n\t\tf_cpu_delay <= 0;\n\telse\n\t\t// Otherwise, count the clocks the CPU takes to respond\n\t\tf_cpu_delay <= f_cpu_delay + 1'b1;\n\n`ifdef\tPREFETCH\n\t// Only *assume* that we are less than F_CPU_DELAY if we are not\n\t// integrated into the CPU\n\talways @(posedge S_AXI_ACLK)\n\t\tassume(f_cpu_delay < F_CPU_DELAY);\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tfaxil_master #(\n\t\t// {{{\n\t\t.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),\n\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t.F_OPT_READ_ONLY(1'b1),\n\t\t.F_OPT_COVER_BURST(5),\n\t\t.F_OPT_ASSUME_RESET(1'b1),\n\t\t.F_LGDEPTH(F_LGDEPTH)\n\t\t// }}}\n\t) faxil(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN),\n\t\t// Unused write interface\n\t\t// {{{\n\t\t.i_axi_awvalid(1'b0), .i_axi_awready(1'b1),\n\t\t\t.i_axi_awaddr( {(AW){1'b0}}),\n\t\t\t.i_axi_awprot( 3'h0),\n\t\t.i_axi_wvalid(1'b0), .i_axi_wready(1'b1),\n\t\t\t.i_axi_wdata({(C_AXI_DATA_WIDTH){1'b0}}),\n\t\t\t.i_axi_wstrb({(C_AXI_DATA_WIDTH/8){1'b0}}),\n\t\t.i_axi_bvalid(1'b0), .i_axi_bready(1'b1),\n\t\t\t.i_axi_bresp(2'b00),\n\t\t// }}}\n\t\t// Read address channel\n\t\t// {{{\n\t\t.i_axi_arvalid(M_AXI_ARVALID),\n\t\t.i_axi_arready(M_AXI_ARREADY),\n\t\t.i_axi_araddr( M_AXI_ARADDR),\n\t\t.i_axi_arprot( 3'h0),\n\t\t// }}}\n\t\t// Read return / data interface\n\t\t// {{{\n\t\t.i_axi_rvalid(M_AXI_RVALID),\n\t\t.i_axi_rready(M_AXI_RREADY),\n\t\t.i_axi_rdata(M_AXI_RDATA),\n\t\t.i_axi_rresp(M_AXI_RRESP),\n\t\t// }}}\n\t\t.f_axi_awr_outstanding(faxil_awr_outstanding),\n\t\t.f_axi_wr_outstanding(faxil_wr_outstanding),\n\t\t.f_axi_rd_outstanding(faxil_outstanding)\n\t\t// }}}\n\t);\n\n\n\talways @(*)\n\t\tassert(full_bus == (outstanding >= (1<<LGDEPTH)-1));\n\n\talways @(*)\n\t\tassert(flushing == (flushcount > 0));\n\n\talways @(*)\n\t\tassert(flushcount <= outstanding + (flush_request ? 1:0));\n\n\talways @(posedge S_AXI_ACLK)\n\tif (flush_request && !i_clear_cache && !i_cpu_reset)\n\t\tassert(pending_new_pc || i_new_pc);\n\n\talways @(*)\n\tif (!M_AXI_ARVALID || !flushing)\n\t\tassert(!flush_request);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Subword return\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg [W:0]\t\tf_word_count;",
            "reg [AW-1:0]\tf_return_addr;",
            "reg [AW-1:0]\tf_out_addr, f_subout_addr;",
            "reg [AW-1:0]\tf_req_addr, f_ret_addr;",
            "reg [W:0]\t\tf_req_offset, f_ret_offset;\n\n\n\talways @(*)\n\tbegin\n\t\tf_req_offset = f_word_count;\n\t\tif (flushing)\n\t\t\tf_req_offset = f_req_offset - flushcount;\n\t\tif (M_AXI_ARVALID && f_req_offset > 0)\n\t\t\tf_req_offset = f_req_offset - 1;\n\n\t\t// Verilator lint_off WIDTH\n\t\tf_req_addr = 0;\n\t\tf_req_addr[AW-1:AXILLSB] = f_out_addr[AW-1:AXILLSB]\n\t\t\t\t+ f_req_offset;\n\n\t\t///////////////\n\n\t\tf_ret_offset = o_valid ? 1:0;\n\t\tf_ret_offset = f_ret_offset + ign_fifo_fill;\n\n\t\tf_ret_addr = 0;\n\t\tf_ret_addr[AW-1:AXILLSB] = f_out_addr[AW-1:AXILLSB] + f_ret_offset;\n\tend\n\n\talways @(*)\n\tif (S_AXI_ARESETN)\n\tbegin\n\t\tassert(f_req_offset <= f_word_count);\n\n\t\tassert(f_req_offset == fill + (o_valid ? 1:0));\n\n\t\tassert(f_ret_offset <= f_req_offset);\n\tend\n\n\talways @(*)\n\tif (!i_cpu_reset && !i_new_pc && !i_clear_cache\n\t\t\t&& !pending_new_pc && M_AXI_ARADDR != o_pc)\n\t\tassert(M_AXI_ARADDR[AXILLSB-1:0] == 0);\n\n\talways @(*)\n\tif (S_AXI_ARESETN)\n\tbegin\n\t\tif (!flushing)\n\t\tbegin\n\t\t\tassert(f_word_count <= FETCH_LIMIT);\n\t\tend else\n\t\t\tassert(f_word_count - flushcount <= FETCH_LIMIT);\n\tend\n\n\talways @(*)\n\tif (!i_cpu_reset && !i_new_pc && !i_clear_cache && !flush_request)\n\tbegin\n\t//\tif (!o_illegal)\n\t//\t\tassert(f_req_addr[AXILLSB-1:0] == M_AXI_ARADDR[AXILLSB-1:0]);\n\t\tassert(f_req_addr[AW-1:AXILLSB] == M_AXI_ARADDR[AW-1:AXILLSB]);\n\tend\n\n\talways @(*)\n\tif (S_AXI_ARESETN && !i_cpu_reset && !i_new_pc && !i_clear_cache\n\t\t\t&& !flushing && !o_illegal)\n\t\tassert(f_ret_addr[AW-1:AXILLSB] == f_return_addr[AW-1:AXILLSB]);\n\n\talways @(*)\n\tbegin\n\t\tf_word_count = faxil_outstanding;\n\t\tif (M_AXI_ARVALID)\n\t\t\tf_word_count = f_word_count + 1;\n\t\tf_word_count = f_word_count + ign_fifo_fill;\n\t\tif (o_valid)\n\t\t\tf_word_count = f_word_count + 1;\n\tend\n\n\n\tgenerate if (FETCH_LIMIT <= 1)\n\tbegin : F_NO_CACHE\n\n\tend else if (FETCH_LIMIT == 2)\n\tbegin : F_DBLFETCH\n\n\tend else begin : F_FIFO_CACHE\n\n\tend endgenerate\n\n\talways @(*)\n\tbegin\n\t\tassert(faxil_outstanding + (M_AXI_ARVALID ? 1:0)<=(1<<LGDEPTH));\n\n\t\tassert(faxil_outstanding == { 1'b0, outstanding });\n\t\tassert(flushcount <= outstanding + (M_AXI_ARVALID ? 1:0));\n\n\t\tassert(flushing == (flushcount != 0));\n\tend\n\n\talways @(*)\n\tif (flushing)\n\t\tassert(!o_valid);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// I-Fetch contract w/ CPU\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tffetch #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(C_AXI_ADDR_WIDTH-INSN_LSB),\n\t\t.OPT_ALIGNED(1'b0)\n\t\t// }}}\n\t) ffetchi(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset),\n\t\t.cpu_new_pc(i_new_pc), .cpu_clear_cache(i_clear_cache),\n\t\t.cpu_pc(i_pc), .pf_valid(o_valid),\n\t\t.cpu_ready(i_ready), .pf_pc(o_pc),\n\t\t.pf_insn(o_insn), .pf_illegal(o_illegal),\n\t\t.fc_pc(fc_pc), .fc_illegal(fc_illegal), .fc_insn(fc_insn),\n\t\t\t.f_address(f_address)\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (!i_cpu_reset && !i_new_pc && !i_clear_cache && !o_illegal)\n\t\tassert(o_pc == f_address);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about our",
            "output s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge S_AXI_ACLK)\n\tif ((f_past_valid)&&(!$past(fifo_reset))\n\t\t&&($past(o_valid && !i_ready)))\n\tbegin\n\t\tassert(o_valid);\n\t\tassert($stable(o_illegal));\n\t\tassert($stable(o_insn));\n\t\tassert($stable(o_pc));\n\tend\n\n\talways @(posedge S_AXI_ACLK)\n\tif ((f_past_valid)&&($past(i_clear_cache)))\n\t\tassert(!o_valid);\n\n\talways @(*)\n\t\tassert(out_fill <= INSNS_PER_WORD);\n\n\talways @(*)\n\t\tassert(o_valid == (out_fill >0));\n\n\tgenerate if (AXILLSB != INSN_LSB)\n\tbegin : OUTFILL_CHK\n\t\talways @(*)\n\t\tif (o_valid && !o_illegal)\n\t\t\tassert(out_fill == INSNS_PER_WORD - o_pc[AXILLSB-1:INSN_LSB]);\n\tend else begin\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\t\tassert(out_fill <= 1);\n\tend endgenerate\n\n\t//\n\t// Assertions about our return responses\n\t// {{{\n\t// While the below assertions (currently) appear to just copy the",
            "logic // above, they still have a purpose--they'll help us guarantee that the\n\t//",
            "logic above will never change without also requiring a change here.\n\t//\n\tgenerate if (SWAP_ENDIANNESS)\n\tbegin : CHECK_SWAPPED_ENDIANNESS\n\t\t// {{{\n\t\tgenvar\tgw, gb;\t// Word count, byte count\n\n\t\tfor(gw=0; gw<C_AXI_DATA_WIDTH/INSN_WIDTH; gw=gw+1) // For each bus word\n\t\tbegin : FOR_INSN_WORD\n\t\tfor(gb=0; gb<(INSN_WIDTH/8); gb=gb+1) // For each bus byte\n\t\tbegin : FOR_INSN_BYTE\n\t\talways @(*)\n\t\t\tassert(endian_swapped_rdata[gw*INSN_WIDTH+((INSN_WIDTH/8)-1-gb)*8 +: 8]\n\t\t\t\t== M_AXI_RDATA[gw*INSN_WIDTH+gb*8 +: 8]);\n\t\tend end\n\t\t// }}}\n\tend else begin : CHECK_NO_ENDIAN_SWAP\n\t\t// {{{\n\t\talways @(*)\n\t\t\tassert(endian_swapped_rdata == M_AXI_RDATA);\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n`define\tCHECK_CONTRACT\n`ifdef\tCHECK_CONTRACT\n\t(* anyconst *)",
            "reg [AW:0]\t\tconst_addr;\n\t(* anyconst *)",
            "reg [DW-1:0]\tconst_insn;",
            "wire [INSN_WIDTH-1:0]\tf_bus_word, f_out_data;\n\n\tinitial\tf_out_addr = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_new_pc)\n\t\tf_out_addr <= { i_pc[AW-1:INSN_LSB], {(INSN_LSB){1'b0}} };\n\telse if (o_valid && i_ready && out_fill == 1)\n\tbegin\n\t\tf_out_addr <= 0;\n\t\tf_out_addr[AW-1:AXILLSB] <= f_out_addr[AW-1:AXILLSB] + 1;\n\tend\n\n\talways @(*)\n\tif (out_fill == 0 || out_fill == INSNS_PER_WORD)\n\t\tf_subout_addr = f_out_addr;\n\telse begin\n\t\tf_subout_addr = 0;\n\t\tf_subout_addr[AW-1:AXILLSB] = f_out_addr[AW-1:AXILLSB];\n\t\tf_subout_addr = f_subout_addr\n\t\t\t+ ((INSNS_PER_WORD-out_fill) << INSN_LSB);\n\tend\n\n\talways @(*)\n\t\tassert(f_out_addr[INSN_LSB-1:0] == 0);\n\n\talways @(*)\n\tif (S_AXI_ARESETN && pending_new_pc)\n\t\tassert(f_out_addr[AW-1:INSN_LSB] == pending_pc[AW-1:INSN_LSB]);\n\n\talways @(*)\n\tif (o_valid && !o_illegal)\n\tbegin\n\t\tassert(f_out_addr[AW-1:AXILLSB] == o_pc[AW-1:AXILLSB]);\n\t\tassert(f_subout_addr[AW-1:INSN_LSB] == o_pc[AW-1:INSN_LSB]);\n\tend else if (!i_cpu_reset && !i_clear_cache\n\t\t\t\t&& !pending_new_pc && !i_new_pc && !o_illegal)\n\tbegin\n\t\tassert(f_out_addr[AW-1:INSN_LSB] == o_pc[AW-1:INSN_LSB]);\n\tend\n\n\talways @(*)\n\tbegin\n\t\tf_return_addr={ M_AXI_ARADDR[AW-1:AXILLSB], {(AXILLSB){1'b0}} };\n\t\tf_return_addr = f_return_addr\n\t\t\t\t- ((outstanding - flushcount)<<AXILLSB);\n\tend\n\n\t//\n\t//\n\t// Step 1. Assume any return matches the contract\n\t//\n\t//\n\n\tgenerate if (INSN_WIDTH == C_AXI_DATA_WIDTH)\n\tbegin : F_BUSWORD\n\t\t// {{{\n\t\tassign\tf_bus_word = endian_swapped_rdata;\n\t\t// }}}\n\tend else begin : BUSWORD_SHIFT\n\t\t// {{{",
            "reg [$clog2(INSNS_PER_WORD)-1:0]\tbshift;\n\n\t\t// Verilator lint_off WIDTH\n\t\talways @(*)\n\t\t\tbshift = fc_pc[AXILLSB-1:INSN_LSB];\n\n\t\tassign\tf_bus_word = endian_swapped_rdata >> (bshift * INSN_WIDTH);\n\t\t// Verilator lint_on  WIDTH\n\t\t// }}}\n\tend endgenerate\n\n\talways @(*)\n\tif (M_AXI_RVALID && f_return_addr[AW-1:AXILLSB] == fc_pc[AW-1:AXILLSB])\n\tbegin\n\t\tassume(M_AXI_RRESP[1] == fc_illegal);\n\t\tassume(f_bus_word == fc_insn);\n\tend\n\n\t//\n\t//\n\t// Step 2: Assert that any value in our cache meets the contract\n\t//\n\t//\n\tgenerate if (INSN_WIDTH == C_AXI_DATA_WIDTH)\n\tbegin : F_OUTDATA\n\t\t// {{{\n\t\tassign\tf_out_data = out_data;\n\t\t// }}}\n\tend else begin : F_OUTDATA_SHIFT\n\t\t// {{{",
            "reg [$clog2(INSNS_PER_WORD)-1:0]\tashift;\n\n\t\t// Verilator lint_off WIDTH\n\t\talways @(*)\n\t\t\tashift = (fc_pc - f_subout_addr) >> INSN_LSB;\n\n\t\tassign\tf_out_data = out_data >> (ashift * INSN_WIDTH);\n\t\t// Verilator lint_on  WIDTH\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate if (FETCH_LIMIT == 1)\n\tbegin : F_SINGLE\n\tend else if (FETCH_LIMIT == 2)\n\tbegin : F_CACHE_CHECK\n\t\t// {{{",
            "reg [AW-1:0]\t\tf_cache_addr;",
            "wire [C_AXI_DATA_WIDTH-1:0]\tf_cache_insn;\n\t\t//",
            "wire f_cache_illegal;",
            "reg f_cache_check;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_cache_addr = 0;\n\t\t\tf_cache_addr[AW-1:AXILLSB] = f_out_addr[AW-1:AXILLSB]+1;\n\n\t\t\tf_cache_check = (fc_pc[AW-1:AXILLSB]\n\t\t\t\t\t\t== f_cache_addr[AW-1:AXILLSB]);\n\t\t\tif (!f_cache_valid)\n\t\t\t\tf_cache_check = 1'b0;\n\t\tend\n\n\t\tif (INSN_WIDTH == C_AXI_DATA_WIDTH)\n\t\tbegin : F_CACHEDATA\n\n\t\t\tassign\tf_cache_insn = f_cache_data;\n\n\t\tend else begin : F_CACHEDATA_SHIFT",
            "reg [$clog2(INSNS_PER_WORD)-1:0]\tashift;\n\n\t\t\talways @(*)\n\t\t\t\tashift = (fc_pc - f_cache_addr) >> INSN_LSB;\n\n\t\t\tassign\tf_cache_insn = f_cache_data >> (ashift * INSN_WIDTH);\n\t\tend\n\n\t\talways @(*)\n\t\tif (f_cache_check && !o_illegal)\n\t\tbegin\n\t\t\tassert(f_cache_insn[INSN_WIDTH-1:0] == fc_insn);\n\t\t\tassert(f_cache_illegal == fc_illegal);\n\t\tend\n\t\t// }}}\n\tend else begin : F_FIFO_CHECK\n\t\t// {{{",
            "reg [AW-1:0]\t\tf_cache_addr, f_fifo_addr;",
            "reg [C_AXI_DATA_WIDTH-1:0]\tf_cache_subdata,\n\t\t\t\t\t\tf_fifo_subdata;",
            "reg f_cache_check;\n\t\t//",
            "reg [LGFIFO:0]\t\tf_cache_distance;",
            "reg f_cache_assume;\n\n\n\t\t/*\n\t\talways @(*)\n\t\t\t{ f_cache_illegal, f_cache_data }\n\t\t\t\t\t\t= { FIFO_FETCH.fcache.f_first_data };\n\n\t\talways @(*)\n\t\t\tf_cache_distance = FIFO_FETCH.fcache.f_distance_to_first;\n\n\t\talways @(*)\n\t\t\tf_cache_valid = FIFO_FETCH.fcache.f_first_in_fifo;\n\t\t*/\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_cache_addr = 0;\n\t\t\tf_cache_addr[AW-1:AXILLSB] = f_out_addr[AW-1:AXILLSB]\n\t\t\t\t\t+ (o_valid ? 1:0)\n\t\t\t\t\t+ f_cache_distance;\n\n\t\t\tf_cache_check = (fc_pc[AW-1:AXILLSB]\n\t\t\t\t\t\t== f_cache_addr[AW-1:AXILLSB]);\n\t\t\tif (!f_cache_valid)\n\t\t\t\tf_cache_check = 1'b0;\n\t\tend\n\n\t\tif (INSN_WIDTH == C_AXI_DATA_WIDTH)\n\t\tbegin : F_CACHEDATA\n\n\t\t\talways @(*)\n\t\t\t\tf_cache_subdata = f_cache_data;\n\n\t\t\talways @(*)\n\t\t\t\tf_fifo_subdata = fifo_data[INSN_WIDTH-1:0];\n\n\t\tend else begin : F_CACHEDATA_SHIFT",
            "reg [$clog2(INSNS_PER_WORD)-1:0]\tashift;\n\n\t\t\t// Verilator lint_off WIDTH\n\t\t\talways @(*)\n\t\t\t\tashift = (fc_pc - f_cache_addr) >> INSN_LSB;\n\t\t\t// Verilator lint_on  WIDTH\n\n\t\t\talways @(*)\n\t\t\t\tf_cache_subdata = f_cache_data >> (ashift * INSN_WIDTH);\n\t\t\talways @(*)\n\t\t\t\tf_fifo_subdata = fifo_data >> (ashift * INSN_WIDTH);\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_fifo_addr = 0;\n\t\t\tf_fifo_addr[AW-1:AXILLSB] = f_out_addr[AW-1:AXILLSB]\n\t\t\t\t+ (o_valid ? 1:0);\n\t\tend\n\n\t\talways @(*)\n\t\tif (f_cache_check && !o_illegal)\n\t\tbegin\n\t\t\tassert(f_cache_subdata[INSN_WIDTH-1:0] == fc_insn);\n\t\t\tassert(f_cache_illegal == fc_illegal);\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_cache_assume = 0;\n\t\t\tif (ign_fifo_fill != 0 && (f_fifo_addr[AW-1:AXILLSB]\n\t\t\t\t\t\t== fc_pc[AW-1:AXILLSB]))\n\t\t\tbegin\n\t\t\t\tif (!f_cache_check || o_illegal)\n\t\t\t\t\tf_cache_assume = 1;\n\t\t\t\tif (f_cache_addr[AW-1:AXILLSB]\n\t\t\t\t\t\t!= f_fifo_addr[AW-1:AXILLSB])\n\t\t\t\t\tf_cache_assume = 1;\n\t\t\tend\n\t\tend\n\n\t\talways @(*)\n\t\tif (f_cache_assume)\n\t\tbegin\n\t\t\tassume(f_fifo_subdata[INSN_WIDTH-1:0] == fc_insn);\n\t\t\tassume(fifo_data[C_AXI_DATA_WIDTH] == fc_illegal);\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\t//\n\t// Check the final",
            "output word\n\t// This checks all instruction positions within that word\n\talways @(*)\n\tif ((out_fill > 0)\n\t\t&& (fc_pc[AW-1:AXILLSB] == f_out_addr[AW-1:AXILLSB]))\n\tbegin\n\t\tif (fc_illegal)\n\t\tbegin\n\t\t\tassert(o_illegal);\n\t\tend else if (!o_illegal && fc_pc >= f_subout_addr)\n\t\t\tassert(f_out_data == fc_insn);\n\tend\n\n\talways @(*)\n\tif (pending_new_pc)\n\t\tassert(i_new_pc || flush_request);\n\n\talways @(*)\n\tif (pending_new_pc)\n\t\tassert(o_pc == pending_pc);\n\n\t// Verilator lint_off WIDTH\n\talways @(*)\n\tif (flush_request)\n\t\tassert(flushcount == faxil_outstanding + 1);\n\t// Verilator lint_on  WIDTH\n\n\talways @(*)\n\tif (flushing)\n\t\tassert(!o_illegal);\n\n\talways @(*)\n\tif (flush_request && !i_cpu_reset && !i_new_pc && !i_clear_cache)\n\tbegin\n\t\tassert(f_out_addr[AW-1:AXILLSB] == pending_pc[AW-1:AXILLSB]);\n\t\tassert(o_pc == pending_pc);\n\tend\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// Verilator lint_off UNDRIVEN\n\t(* anyconst *)",
            "reg cvr_always_ready;\n\t// Verilator lint_on  UNDRIVEN",
            "reg [3:0]\tcvr_returns;\n\n\talways @(*)\n\tif (cvr_always_ready)\n\t\tassume(M_AXI_ARREADY);\n\n\tinitial\tcvr_returns = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_cpu_reset || i_new_pc || i_clear_cache || o_illegal)\n\t\tcvr_returns <= 0;\n\telse if (o_valid && i_ready && !cvr_returns[3])\n\t\tcvr_returns <= cvr_returns + 1;\n\n\talways @(*)\n\tbegin\n\t\tcover(cvr_returns == 4'b0100);\n\t\tcover(cvr_returns == 4'b0101);\n\t\tcover(cvr_returns == 4'b0110 && cvr_always_ready);\n\tend\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "wire unused_formal;\n\tassign\tunused_formal = &{ 1'b0, f_ret_addr[AXILLSB-1:0] };\n\t// Verilator lint_on  UNUSED\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "iscachable.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/iscachable.v",
        "chunks": [
            "module must be built of entirely combinatorial",
            "logic and nothing more.\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2018-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module iscachable #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=32,",
            "localparam AW = ADDRESS_WIDTH, // Just for ease of notation below",
            "parameter [AW-1:0] \tSDRAM_ADDR  = 0, SDRAM_MASK = 0,",
            "parameter [AW-1:0] \tBKRAM_ADDR = 32'h10000000,\n\t\t\t\t\tBKRAM_MASK = 32'h10000000,",
            "parameter [AW-1:0] \tFLASH_ADDR  = 0, FLASH_MASK  = 0\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire [AW-1:0]\ti_addr,",
            "output ",
            "reg o_cachable\n\t\t// }}}\n\t);\n\n\n\talways @(*)\n\tbegin\n\t\to_cachable = 1'b0;\n\t\tif ((SDRAM_ADDR !=0)&&((i_addr & SDRAM_MASK)== SDRAM_ADDR))\n\t\t\to_cachable = 1'b1;\n\t\telse if ((FLASH_ADDR !=0)&&((i_addr & FLASH_MASK)== FLASH_ADDR))\n\t\t\to_cachable = 1'b1;\n\t\telse if ((BKRAM_ADDR !=0)&&((i_addr & BKRAM_MASK)== BKRAM_ADDR))\n\t\t\to_cachable = 1'b1;\n\tend",
            "endmodule "
        ]
    },
    {
        "file_name": "idecode.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/idecode.v",
        "chunks": [
            "module idecode #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=24,",
            "parameter [0:0]\tOPT_MPY = 1'b1,",
            "parameter [0:0]\tOPT_SHIFTS = 1'b1,",
            "parameter [0:0]\tOPT_EARLY_BRANCHING = 1'b1,",
            "parameter [0:0]\tOPT_PIPELINED = 1'b1,",
            "parameter [0:0]\tOPT_DIVIDE = (OPT_PIPELINED),",
            "parameter [0:0]\tOPT_FPU    = 1'b0,",
            "parameter [0:0]\tOPT_CIS    = 1'b1,",
            "parameter [0:0]\tOPT_LOCK   = (OPT_PIPELINED),",
            "parameter [0:0]\tOPT_OPIPE  = (OPT_PIPELINED),",
            "parameter [0:0]\tOPT_SIM    = 1'b0,",
            "parameter [0:0]\tOPT_SUPPRESS_NULL_BRANCHES = 1'b0,",
            "parameter [0:0]\tOPT_USERMODE = 1'b1,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,",
            "localparam AW = ADDRESS_WIDTH\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset, i_ce, i_stalled,",
            "input ",
            "wire [31:0]\ti_instruction,",
            "input ",
            "wire i_gie,",
            "input ",
            "wire [(AW+1):0]\ti_pc,",
            "input ",
            "wire i_pf_valid, i_illegal,",
            "output ",
            "wire o_valid, o_phase,",
            "output ",
            "reg o_illegal,",
            "output ",
            "reg [(AW+1):0]\to_pc,",
            "output ",
            "reg [6:0]\to_dcdR, o_dcdA, o_dcdB,",
            "output ",
            "wire [4:0]\to_preA, o_preB,",
            "output ",
            "wire [31:0]\to_I,",
            "output ",
            "reg o_zI,",
            "output ",
            "reg [3:0]\to_cond,",
            "output ",
            "reg o_wF,",
            "output ",
            "reg [3:0]\to_op,",
            "output ",
            "reg o_ALU, o_M, o_DV, o_FP, o_break,",
            "output ",
            "reg o_lock,",
            "output ",
            "reg o_wR, o_rA, o_rB,",
            "output ",
            "wire o_early_branch, o_early_branch_stb,",
            "output ",
            "wire [(AW+1):0]\to_branch_pc,",
            "output ",
            "wire o_ljmp,",
            "output ",
            "wire o_pipe,",
            "output ",
            "reg o_sim,",
            "output ",
            "reg [22:0]\to_sim_immv\n`ifdef\tFORMAL\n\t\t,",
            "output ",
            "reg [31:0]\tf_insn_word,",
            "output ",
            "reg f_insn_gie,",
            "output ",
            "wire f_insn_is_pipeable\n`endif\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam [3:0]\tCPU_SP_REG = 4'hd,\n\t\t\t\tCPU_CC_REG = 4'he,\n\t\t\t\tCPU_PC_REG = 4'hf;",
            "localparam CISBIT    = 31,\n\t\t\t\tCISIMMSEL = 23,\n\t\t\t\tIMMSEL    = 18;",
            "wire [4:0]\tw_op;",
            "wire w_ldi, w_mov, w_cmptst, w_ldilo, w_ALU, w_brev,\n\t\t\tw_noop, w_lock, w_sim, w_break, w_special, w_add, w_mpy;",
            "wire [4:0]\tw_dcdR, w_dcdB, w_dcdA;",
            "wire w_dcdR_pc, w_dcdR_cc;",
            "wire w_dcdA_pc, w_dcdA_cc;",
            "wire w_dcdB_pc, w_dcdB_cc;",
            "wire [3:0]\tw_cond;",
            "wire w_wF, w_mem, w_sto, w_div, w_fpu;",
            "wire w_wR, w_rA, w_rB, w_wR_n;",
            "wire w_ljmp, w_ljmp_dly, w_cis_ljmp;",
            "wire [31:0]\tiword;",
            "wire pf_valid;",
            "reg [14:0]\tr_nxt_half;",
            "reg [4:0]\tw_cis_op;",
            "reg [22:0]\tr_I, w_fullI;",
            "wire [22:0]\tw_I;",
            "wire w_Iz;",
            "reg [1:0]\tw_immsrc;",
            "reg r_valid;",
            "wire insn_is_pipeable, illegal_shift;\n\t// }}}\n\n\tassign\tpf_valid = (i_pf_valid)&&(!o_early_branch_stb);\n\n\t// iword\n\t// {{{\n\tgenerate if (OPT_CIS)\n\tbegin : SET_IWORD\n\n\t\tassign\tiword = (o_phase)\n\t\t\t\t// set second half as a NOOP ... but really\n\t\t\t\t// shouldn't matter\n\t\t\t? { 1'b1, r_nxt_half[14:0], i_instruction[15:0] }\n\t\t\t: i_instruction;\n\tend else begin : CLR_IWORD\n\t\tassign\tiword = { 1'b0, i_instruction[30:0] };\n\n\t\t// verilator coverage_off\n\t\t// verilator lint_off UNUSED",
            "wire unused_nxt_half;\n\t\tassign\t\tunused_nxt_half = &{ 1'b0, r_nxt_half };\n\t\t// verilator lint_on  UNUSED\n\t\t// verilator coverage_on\n\tend endgenerate\n\t// }}}\n\n\t// w_ljmp, w_cis_ljmp : Long jump early branching\n\t// {{{\n\tgenerate\n\tif (OPT_EARLY_BRANCHING)\n\tbegin : GEN_CIS_LONGJUMP\n\t\tif (OPT_CIS)\n\t\tbegin : CIS_EARLY_BRANCHING\n\n\t\t\tassign\tw_cis_ljmp = (o_phase)&&(iword[31:16] == 16'hfcf8);\n\n\t\tend else begin : NOCIS_EARLY_BRANCH\n\n\t\t\tassign\tw_cis_ljmp = 1'b0;\n\n\t\tend\n\n\t\tassign\tw_ljmp = (iword == 32'h7c87c000);\n\n\tend else begin : NO_CIS_JUMPING\n\n\t\tassign\tw_cis_ljmp = 1'b0;\n\t\tassign\tw_ljmp = 1'b0;\n\tend endgenerate\n\t// }}}\n\n\t// w_cis_op : Get the opcode\n\t// {{{\n\tgenerate if (OPT_CIS)\n\tbegin : GEN_CIS_OP\n\n\t\talways @(*)\n\t\tif (!iword[CISBIT])\n\t\t\tw_cis_op = iword[26:22];\n\t\telse case(iword[26:24])\n\t\t3'h0: w_cis_op = 5'h00;\t// SUB\n\t\t3'h1: w_cis_op = 5'h01;\t// AND\n\t\t3'h2: w_cis_op = 5'h02;\t// ADD\n\t\t3'h3: w_cis_op = 5'h10;\t// CMP\n\t\t3'h4: w_cis_op = 5'h12;\t// LW\n\t\t3'h5: w_cis_op = 5'h13;\t// SW\n\t\t3'h6: w_cis_op = 5'h18;\t// LDI\n\t\t3'h7: w_cis_op = 5'h0d;\t// MOV\n\t\tendcase\n\n\tend else begin : GEN_NOCIS_OP\n\n\t\talways @(*)\n\t\t\tw_cis_op = w_op;\n\n\tend endgenerate\n\t// }}}\n\n\t// Decode instructions\n\t// {{{\n\tassign\tw_op= iword[26:22];\n\tassign\tw_mov    = (w_cis_op      == 5'h0d);\n\tassign\tw_ldi    = (w_cis_op[4:1] == 4'hc);\n\tassign\tw_brev   = (w_cis_op      == 5'h08);\n\tassign\tw_mpy    = (w_cis_op[4:1] == 4'h5)||(w_cis_op[4:0]==5'h0c);\n\tassign\tw_cmptst = (w_cis_op[4:1] == 4'h8);\n\tassign\tw_ldilo  = (w_cis_op[4:0] == 5'h09);\n\tassign\tw_ALU    = (!w_cis_op[4]) // anything with [4]==0, but ...\n\t\t\t\t&&(w_cis_op[3:1] != 3'h7); // not the divide\n\tassign\tw_add    = (w_cis_op[4:0] == 5'h02);\n\tassign\tw_mem    = (w_cis_op[4:3] == 2'b10)&&(w_cis_op[2:1] !=2'b00);\n\tassign\tw_sto    = (w_mem)&&( w_cis_op[0]);\n\tassign\tw_div    = (!iword[CISBIT])&&(w_op[4:1] == 4'h7);\n\tassign\tw_fpu    = (!iword[CISBIT])&&(w_op[4:3] == 2'b11)\n\t\t\t\t&&(w_dcdR[3:1] != 3'h7)\n\t\t\t\t&&(w_op[2:1] != 2'b00);\n\t// If the result",
            "reg ister is either CC or PC, and this would otherwise\n\t// be a floating point instruction with floating point opcode of 0,\n\t// then this is a NOOP.\n\tassign\tw_special= (!iword[CISBIT])&&(w_dcdR[3:1]==3'h7)\n\t\t\t&&(w_op[4:2] == 3'b111);\n\tassign\tw_break = (w_special)&&(w_op[4:0]==5'h1c);\n\tassign\tw_lock  = (w_special)&&(w_op[4:0]==5'h1d);\n\tassign\tw_sim   = (w_special)&&(w_op[4:0]==5'h1e);\n\tassign\tw_noop  = (w_special)&&(w_op[4:1]==4'hf); // Must include w_sim\n`ifdef\tFORMAL\n\talways @(*)\n\t\tassert(!w_special || !w_fpu);\n`endif\n\t// }}}\n\n\t// w_dcdR, w_dcdA\n\t// {{{\n\t// What",
            "reg ister will we be placing results into (if at all)?\n\t//\n\t// Two parts to the result",
            "reg ister: the",
            "reg ister set, given for\n\t// moves in iword[18] but only for the supervisor, and the other\n\t// four bits encoded in the instruction.\n\t//\n\tassign\tw_dcdR = { ((!iword[CISBIT])&&(OPT_USERMODE)&&(w_mov)&&(!i_gie))?iword[IMMSEL]:i_gie,\n\t\t\t\tiword[30:27] };\n\n\t// 0 LUTs\n\tassign\tw_dcdA = w_dcdR;\t// on ZipCPU, A is always result",
            "reg // 0 LUTs\n\tassign\tw_dcdA_pc = w_dcdR_pc;\n\tassign\tw_dcdA_cc = w_dcdR_cc;\n\t// 2 LUTs, 1 delay each\n\tassign\tw_dcdR_pc = (w_dcdR == {i_gie, CPU_PC_REG});\n\tassign\tw_dcdR_cc = (w_dcdR == {i_gie, CPU_CC_REG});\n\t// }}}\n\n\t// dcdB - What",
            "reg ister is used in the opB?\n\t// {{{\n\tassign w_dcdB[4] = ((!iword[CISBIT])&&(w_mov)&&(OPT_USERMODE)&&(!i_gie))?iword[13]:i_gie;\n\tassign w_dcdB[3:0]= (iword[CISBIT])\n\t\t\t\t? (((!iword[CISIMMSEL])&&(iword[26:25]==2'b10))\n\t\t\t\t\t? CPU_SP_REG : iword[22:19])\n\t\t\t\t: iword[17:14];\n\n\t// 2 LUTs, 1 delays each\n\tassign\tw_dcdB_pc = (w_rB)&&(w_dcdB[3:0] == CPU_PC_REG);\n\tassign\tw_dcdB_cc = (w_rB)&&(w_dcdB[3:0] == CPU_CC_REG);\n\t// }}}\n\n\t// w_cond\n\t// {{{\n\t// Under what condition will we execute this instruction?  Only the\n\t// load immediate instruction and the CIS instructions are completely\n\t// unconditional.  Well ... not quite.  The BREAK, LOCK, and SIM/NOOP\n\t// instructions are also unconditional.\n\t//\n\tassign\tw_cond = ((w_ldi)||(w_special)||(iword[CISBIT])) ? 4'h8 :\n\t\t\t{ (iword[21:19]==3'h0), iword[21:19] };\n\t// }}}\n\n\t// rA - do we need to read",
            "reg ister A?\n\t// {{{\n\tassign\tw_rA = // Floating point reads",
            "reg A\n\t\t\t(w_fpu)\n\t\t\t// Divide's read A\n\t\t\t||(w_div)\n\t\t\t// ALU ops read A,\n\t\t\t//\texcept for MOV's and BREV's which don't\n\t\t\t||((w_ALU)&&(!w_brev)&&(!w_mov))\n\t\t\t// STO's read A\n\t\t\t||(w_sto)\n\t\t\t// Test/compares\n\t\t\t||(w_cmptst);\n\t// }}}\n\n\t// rB -- do we read a",
            "reg ister for operand B?\n\t// {{{\n\t// Specifically, do we add the",
            "reg isters value to the immediate to\n\t// create opB?\n\tassign\tw_rB     = (w_mov)\n\t\t\t\t||((!iword[CISBIT])&&(iword[IMMSEL])&&(!w_ldi)&&(!w_special))\n\t\t\t\t||(( iword[CISBIT])&&(iword[CISIMMSEL])&&(!w_ldi))\n\t\t\t\t// If using compressed instruction sets,\n\t\t\t\t// we *always* read on memory operands.\n\t\t\t\t||(( iword[CISBIT])&&(w_mem));\n\t// }}}\n\n\t// wR -- will we be writing our result back?\n\t// {{{\n\t// wR_n = !wR\n\t// All but STO, NOOP/BREAK/LOCK, and CMP/TST write back to w_dcdR\n\tassign\tw_wR_n   = (w_sto)\n\t\t\t\t||(w_special)\n\t\t\t\t||(w_cmptst);\n\tassign\tw_wR     = !w_wR_n;\n\t// }}}\n\t//\n\t// wF -- do we write flags when we are done?\n\t// {{{\n\tassign\tw_wF     = (w_cmptst)\n\t\t\t||((w_cond[3])&&(w_fpu||w_div\n\t\t\t\t||((w_ALU)&&(!w_mov)&&(!w_ldilo)&&(!w_brev)\n\t\t\t\t\t&&(w_dcdR[3:1] != 3'h7))));\n\t// }}}\n\n\t// w_immsrc - where does the immediate value come from\n\t// {{{\n\t// Bottom 13 bits: no LUT's\n\t// w_dcd[12: 0] -- no LUTs\n\t// w_dcd[   13] -- 2 LUTs\n\t// w_dcd[17:14] -- (5+i0+i1) = 3 LUTs, 1 delay\n\t// w_dcd[22:18] : 5 LUTs, 1 delay (assuming high bit is o/w determined)\n\talways @(*)\n\tif (w_ldi)\n\t\tw_immsrc = 0;\n\telse if (w_mov)\n\t\tw_immsrc = 1;\n\telse if (!iword[IMMSEL])\n\t\tw_immsrc = 2;\n\telse // if (!iword[IMMSEL])\n\t\tw_immsrc = 3;\n\t// }}}\n\n\t// w_fullI -- extracting the immediate value from the insn word\n\t// {{{\n\talways @(*)\n\tcase(w_immsrc)\n\t2'b00: w_fullI = { iword[22:0] }; // LDI\n\t2'b01: w_fullI = { {(23-13){iword[12]}}, iword[12:0] }; // MOV\n\t2'b10: w_fullI = { {(23-18){iword[17]}}, iword[17:0] }; // Immediate\n\t2'b11: w_fullI = { {(23-14){iword[13]}}, iword[13:0] }; // Reg + Imm\n\tendcase\n\t/*\n\tassign\tw_fullI = (w_ldi) ? { iword[22:0] } // LDI\n\t\t\t// MOVE immediates have one less bit\n\t\t\t:((w_mov) ?{ {(23-13){iword[12]}}, iword[12:0] }\n\t\t\t// Normal Op-B immediate ... 18 or 14 bits\n\t\t\t:((!iword[IMMSEL]) ? { {(23-18){iword[17]}}, iword[17:0] }\n\t\t\t: { {(23-14){iword[13]}}, iword[13:0] }\n\t\t\t));\n\t*/\n\t// }}}\n\n\t// w_I and w_Iz: Immediate value decoding\n\t// {{{\n\tgenerate if (OPT_CIS)\n\tbegin : GEN_CIS_IMMEDIATE",
            "wire [7:0]\tw_halfI, w_halfbits;\n\n\t\tassign\tw_halfbits = iword[CISIMMSEL:16];\n\t\tassign\tw_halfI = (iword[26:24]==3'h6) ? w_halfbits[7:0] // 8'b for LDI\n\t\t\t\t:(w_halfbits[7])?\n\t\t\t\t\t{ {(6){w_halfbits[2]}}, w_halfbits[1:0]}\n\t\t\t\t\t:{ w_halfbits[6], w_halfbits[6:0] };\n\t\tassign\tw_I  = (iword[CISBIT])\n\t\t\t\t? {{(23-8){w_halfI[7]}}, w_halfI }\n\t\t\t\t: w_fullI;\n\n\tend else begin : GEN_NOCIS_IMMEDIATE\n\n\t\tassign\tw_I  = w_fullI;\n\n\tend endgenerate\n\n\tassign\tw_Iz = (w_I == 0);\n\t// }}}\n\n\t// o_phase\n\t// {{{\n\t// The o_phase",
            "parameter is special.  It needs to let the software\n\t// following know that it cannot break/interrupt on an o_phase asserted\n\t// instruction, lest the break take place between the first and second\n\t// half of a CIS instruction.  To do this, o_phase must be asserted\n\t// when the first instruction half is valid, but not asserted on either\n\t// a 32-bit instruction or the second half of a 2x16-bit instruction.\n\tgenerate if (OPT_CIS)\n\tbegin : GEN_CIS_PHASE\n\t\t// {{{",
            "reg r_phase;\n\n\t\t// Phase is '1' on the first instruction of a two-part set\n\t\t// But, due to the delay in processing, it's '1' when our\n\t\t//",
            "output is valid for that first part, but that'll be the\n\t\t// same time we are processing the second part ... so it may\n\t\t// look to us like a '1' on the second half of processing.\n\n\t\t// When no instruction is in the pipe, phase is zero\n\t\tinitial\tr_phase = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || w_ljmp_dly)\n\t\t\tr_phase <= 1'b0;\n\t\telse if ((i_ce)&&(pf_valid))\n\t\tbegin\n\t\t\tif (o_phase)\n\t\t\t\t// CIS instructions only have two parts.  On\n\t\t\t\t// the second part (o_phase is true), return\n\t\t\t\t// back to the first\n\t\t\t\tr_phase <= 0;\n\t\t\telse\n\t\t\t\tr_phase <= (i_instruction[CISBIT])&&(!i_illegal);\n\t\tend else if (i_ce)\n\t\t\tr_phase <= 1'b0;\n\n\t\tassign\to_phase = r_phase;\n\t\t// }}}\n\tend else begin : NO_CIS\n\t\t// {{{\n\t\tassign\to_phase = 1'b0;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// illegal_shift\n\t// {{{\n\tgenerate if (OPT_SHIFTS)\n\tbegin : LEGAL_SHIFTS\n\t\tassign\tillegal_shift = 1'b0;\n\tend else begin : GEN_ILLEGAL_SHIFT",
            "reg r_illegal_shift;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tr_illegal_shift = 1'b1;\n\t\t\tif (i_instruction[CISBIT])\n\t\t\t\tr_illegal_shift = 1'b0;\n\t\t\telse if ((i_instruction[26:22] != 5'h5)\n\t\t\t\t&&(i_instruction[26:22] != 5'h6)\n\t\t\t\t&&(i_instruction[26:22] != 5'h7))\n\t\t\t\tr_illegal_shift = 1'b0;\n\t\t\telse if (!i_instruction[18]\n\t\t\t\t\t&& (i_instruction[17:0] == 18'h1))\n\t\t\t\tr_illegal_shift = 1'b0;\n\t\tend\n\n\t\tassign\tillegal_shift = r_illegal_shift;\n\tend endgenerate\n\t// }}}\n\n\t// o_illegal\n\t// {{{\n\tinitial\to_illegal = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_illegal <= 1'b0;\n\telse if (i_ce && o_phase)\n\tbegin\n\t\t// {{{\n\t\to_illegal <= o_illegal;\n\t\t//  Cannot happen in compressed word ...\n\t\t// 1. multiply op-codes\n\t\t// 2. divide opcodes\n\t\t// 3. FPU opcodes\n\t\t// 4. special opcodes\n\t\t// }}}\n\tend else if (i_ce && i_pf_valid)\n\tbegin\n\t\t// {{{\n\t\to_illegal <= 1'b0;\n\n\t\tif (illegal_shift)\n\t\t\to_illegal <= 1'b1;\n\n\t\tif ((!OPT_CIS)&&(i_instruction[CISBIT]))\n\t\t\to_illegal <= 1'b1;\n\t\tif ((!OPT_MPY)&&(w_mpy))\n\t\t\to_illegal <= 1'b1;\n\n\t\tif ((!OPT_DIVIDE)&&(w_div))\n\t\t\to_illegal <= 1'b1;\n\t\telse if ((OPT_DIVIDE)&&(w_div)&&(w_dcdR[3:1]==3'h7))\n\t\t\to_illegal <= 1'b1;\n\n\n\t\tif ((!OPT_FPU)&&(w_fpu))\n\t\t\to_illegal <= 1'b1;\n\n\t\tif ((!OPT_SIM)&&(w_sim))\n\t\t// Simulation instructions on real hardware should\n\t\t// always cause an illegal instruction error\n\t\t\to_illegal <= 1'b1;\n\n\t\t// There are two (missing) special instructions, after\n\t\t// BREAK, LOCK, SIM, and NOOP.  These are special if their\n\t\t// (unused-result)",
            "reg ister is either the PC or CC",
            "reg ister.\n\t\t//\n\t\t// These should cause an illegal instruction error\n\t\tif ((w_dcdR[3:1]==3'h7)&&(w_cis_op[4:1]==4'b1101))\n\t\t\to_illegal <= 1'b1;\n\n\t\t// If the lock function isn't implemented, this should\n\t\t// also cause an illegal instruction error\n\t\tif ((!OPT_LOCK)&&(w_lock))\n\t\t\to_illegal <= 1'b1;\n\n\t\t// Bus errors always create illegal instructions\n\t\tif (i_illegal)\n\t\t\to_illegal <= 1'b1;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// o_pc\n\t// {{{\n\tinitial\to_pc = 0;\n\talways @(posedge i_clk)\n\tif ((i_ce)&&((o_phase)||(i_pf_valid)))\n\tbegin\n\t\to_pc[0] <= 1'b0;\n\n\t\tif (OPT_CIS)\n\t\tbegin\n\t\t\tif (iword[CISBIT])\n\t\t\tbegin\n\t\t\t\tif (o_phase)\n\t\t\t\t\to_pc[AW+1:1] <= o_pc[AW+1:1] + 1'b1;\n\t\t\t\telse\n\t\t\t\t\to_pc <= { i_pc[AW+1:2], 1'b1, 1'b0 };\n\t\t\tend else begin\n\t\t\t\t// The normal, non-CIS case\n\t\t\t\to_pc <= { i_pc[AW+1:2] + 1'b1, 2'b00 };\n\t\t\tend\n\t\tend else begin\n\t\t\t// The normal, non-CIS case\n\t\t\to_pc <= { i_pc[AW+1:2] + 1'b1, 2'b00 };\n\t\tend\n\tend\n\t// }}}\n\n\t// Generate",
            "output products\n\t// {{{\n\tinitial\to_dcdR = 0;\n\tinitial\to_dcdA = 0;\n\tinitial\to_dcdB = 0;\n\tinitial\to_DV   = 0;\n\tinitial\to_FP   = 0;\n\tinitial\to_lock = 0;\n\tinitial\to_sim = 1'b0;\n\tinitial\to_sim_immv = 0;\n\t// r_I, o_zI, o_wR, o_rA, o_rB, o_dcdR, o_dcdA, o_dcdB\n\talways @(posedge i_clk)\n\tif (i_ce)\n\tbegin\n\t\t// {{{\n\t\t// o_cond, o_wF\n\t\t// {{{\n\t\t// Under what condition will we execute this\n\t\t// instruction?  Only the load immediate instruction\n\t\t// is completely unconditional.\n\t\to_cond <= w_cond;\n\t\t// Don't change the flags on conditional instructions,\n\t\t// UNLESS: the conditional instruction was a CMP\n\t\t// or TST instruction.\n\t\to_wF <= w_wF;\n\t\t// }}}\n\n\t\t// o_op\n\t\t// {{{\n\t\t// Record what operation/op-code (4-bits) we are doing\n\t\t//\tNote that LDI magically becomes a MOV\n\t\t// \tinstruction here.  That way it's a pass through\n\t\t//\tthe ALU.  Likewise, the two compare instructions\n\t\t//\tCMP and TST becomes SUB and AND here as well.\n\t\t// We keep only the bottom four bits, since we've\n\t\t// already done the rest of the decode necessary to\n\t\t// settle between the other instructions.  For example,\n\t\t// o_FP plus these four bits uniquely defines the FP\n\t\t// instruction, o_DV plus the bottom of these defines\n\t\t// the divide, etc.\n\t\to_op <= w_cis_op[3:0];\n\t\tif ((w_ldi)||(w_noop)||(w_lock))\n\t\t\to_op <= 4'hd;\n\t\t// }}}\n\n\t\to_dcdR <= { w_dcdR_cc, w_dcdR_pc, w_dcdR};\n\t\to_dcdA <= { w_dcdA_cc, w_dcdA_pc, w_dcdA};\n\t\to_dcdB <= { w_dcdB_cc, w_dcdB_pc, w_dcdB};\n\t\to_wR  <= w_wR;\n\t\to_rA  <= w_rA;\n\t\to_rB  <= w_rB;\n\t\tr_I    <= w_I;\n\t\to_zI   <= w_Iz;\n\n\t\t// o_ALU, o_M, o_DV, o_FP\n\t\t// {{{\n\t\t// Turn a NOOP into an ALU operation--subtract in\n\t\t// particular, although it doesn't really matter as long\n\t\t// as it doesn't take longer than one clock.  Note\n\t\t// also that this depends upon not setting any",
            "reg isters\n\t\t// or flags, which should already be true.\n\t\to_ALU  <=  (w_ALU)||(w_ldi)||(w_cmptst)||(w_noop)\n\t\t\t\t||((!OPT_LOCK)&&(w_lock));\n\t\to_M    <=  w_mem;\n\t\to_DV   <=  (OPT_DIVIDE)&&(w_div);\n\t\to_FP   <=  (OPT_FPU)&&(w_fpu);\n\t\t// }}}\n\n\t\t// o_break, o_lock\n\t\t// {{{\n\t\to_break <= w_break;\n\t\to_lock  <= (OPT_LOCK)&&(w_lock);\n\t\t// }}}\n\n\t\tif (OPT_CIS)\n\t\t\tr_nxt_half <= { iword[14:0] };\n\t\telse\n\t\t\tr_nxt_half <= 0;\n\n\t\t// o_sim, o_sim_immv -- simulation instructions vs NOOPs\n\t\t// {{{\n\t\tif (OPT_SIM)\n\t\tbegin\n\t\t\t// Support the SIM instruction(s)\n\t\t\to_sim <= (w_sim)||(w_noop);\n\t\t\to_sim_immv <= iword[22:0];\n\t\t\tif (OPT_LOWPOWER && !w_sim && !w_noop)\n\t\t\t\to_sim_immv <= 0;\n\t\tend else begin\n\t\t\to_sim <= 1'b0;\n\t\t\to_sim_immv <= 0;\n\t\tend\n\t\t// }}}\n\t\t// }}}\n\tend\n\t// }}}\n\n\tassign\to_preA = w_dcdA;\n\tassign\to_preB = w_dcdB;\n\n\t// o_early_branch, o_early_branch_stb, o_branch_pc\n\t// {{{\n\tgenerate if (OPT_EARLY_BRANCHING)\n\tbegin : GEN_EARLY_BRANCH_LOGIC\n\t\t// {{{",
            "reg r_early_branch, r_early_branch_stb,\n\t\t\t\t\tr_ljmp;",
            "reg [(AW+1):0]\tr_branch_pc;",
            "wire w_add_to_pc;\n\n\t\tinitial r_ljmp = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_ljmp <= 1'b0;\n\t\telse if (i_ce)\n\t\tbegin\n\t\t\tif ((r_ljmp)&&(pf_valid))\n\t\t\t\tr_ljmp <= 1'b0;\n\t\t\telse if (o_early_branch_stb)\n\t\t\t\tr_ljmp <= 1'b0;\n\t\t\telse if (pf_valid)\n\t\t\tbegin\n\t\t\t\tif ((OPT_CIS)&&(iword[CISBIT]))\n\t\t\t\t\tr_ljmp <= w_cis_ljmp;\n\t\t\t\telse\n\t\t\t\t\tr_ljmp <= (w_ljmp);\n\t\t\tend else if ((OPT_CIS)&&(o_phase)&&(iword[CISBIT]))\n\t\t\t\tr_ljmp <= w_cis_ljmp;\n\t\tend\n\t\tassign\to_ljmp = r_ljmp;\n\n\t\tassign\tw_add_to_pc = (!o_phase\n\t\t\t\t&& (!OPT_CIS || !i_instruction[CISBIT])\n\t\t\t\t&& (i_instruction[30:27]==CPU_PC_REG)\t// Rd=PC\n\t\t\t\t&& (i_instruction[26:22] == 5'h02)\t// ADD\n\t\t\t\t&& (i_instruction[21:19]==3'h0)\t\t// NONE\n\t\t\t\t&& !i_instruction[IMMSEL]);\n\n\t\tinitial\tr_early_branch     = 1'b0;\n\t\tinitial\tr_early_branch_stb = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\tbegin\n\t\t\tr_early_branch     <= 1'b0;\n\t\t\tr_early_branch_stb <= 1'b0;\n\t\tend else if (i_ce && pf_valid)\n\t\tbegin\n\t\t\tif (r_ljmp)\n\t\t\tbegin\n\t\t\t\t// LW (PC),PC\n\t\t\t\tr_early_branch     <= 1'b1;\n\t\t\t\tr_early_branch_stb <= 1'b1;\n\t\t\tend else if (w_add_to_pc)\n\t\t\tbegin\n\t\t\t\t// Add x,PC\n\t\t\t\tr_early_branch     <= 1'b1;\n\t\t\t\tr_early_branch_stb <= (!OPT_SUPPRESS_NULL_BRANCHES)\n\t\t\t\t\t|| (i_instruction[IMMSEL-1:0] != 0);\n\t\t\t// LDI #x,PC is no longer supported\n\t\t\tend else begin\n\t\t\t\tr_early_branch <= 1'b0;\n\t\t\t\tr_early_branch_stb <= 1'b0;\n\t\t\tend\n\t\tend else begin\n\t\t\tr_early_branch_stb <= 1'b0;\n\t\t\tif (i_ce)\n\t\t\t\tr_early_branch     <= 1'b0;\n\t\tend\n\n\t\tinitial\tr_branch_pc = 0;\n\t\talways @(posedge i_clk)\n\t\tif (OPT_LOWPOWER && i_reset)\n\t\t\tr_branch_pc <= 0;\n\t\telse if (i_ce)\n\t\tbegin\n\t\t\tif (r_ljmp)\n\t\t\t\tr_branch_pc <= { iword[(AW+1):2],\n\t\t\t\t\t\t2'b00 };\n\t\t\telse if (!OPT_LOWPOWER || w_add_to_pc)\n\t\t\tbegin\n\t\t\t\t// Add x,PC\n\t\t\t\tr_branch_pc[AW+1:2] <= i_pc[AW+1:2]\n\t\t\t\t\t+ {{(AW-15){i_instruction[17]}},\n\t\t\t\t\t\t\ti_instruction[16:2]}\n\t\t\t\t\t+ {{(AW-1){1'b0}},1'b1};\n\t\t\t\tr_branch_pc[1:0] <= 2'b00;\n\t\t\tend else if (OPT_LOWPOWER)\n\t\t\t\tr_branch_pc <= 0;\n\n\t\t\tif (OPT_LOWPOWER && !pf_valid)\n\t\t\t\tr_branch_pc <= 0;\n\t\tend\n\n\t\tassign\tw_ljmp_dly         = r_ljmp;\n\t\tassign\to_early_branch     = r_early_branch;\n\t\tassign\to_early_branch_stb = r_early_branch_stb;\n\t\tassign\to_branch_pc        = r_branch_pc;\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (OPT_LOWPOWER && !r_early_branch)\n\t\t\tassert(r_branch_pc == 0);\n`endif\n\t\t// }}}\n\tend else begin : NO_EARLY_BRANCHING\n\t\t// {{{\n\t\tassign\tw_ljmp_dly         = 1'b0;\n\t\tassign\to_early_branch     = 1'b0;\n\t\tassign\to_early_branch_stb = 1'b0;\n\t\tassign\to_branch_pc = {(AW+2){1'b0}};\n\t\tassign\to_ljmp = 1'b0;\n\n\t\t// verilator coverage_off\n\t\t// verilator lint_off UNUSED",
            "wire early_branch_unused;\n\t\tassign\tearly_branch_unused = &{ 1'b0, w_add };\n\t\t// verilator lint_on  UNUSED\n\t\t// verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// o_pipe\n\t// {{{\n\t// To be a pipeable operation there must be ...\n\t//\t1. Two valid adjacent instructions\n\t//\t2. Both must be memory operations, of the same time (both lods\n\t//\t\tor both stos)\n\t//\t3. Both must use the same",
            "reg ister base address\n\t//\t4. Both must be to the same address, or the address incremented\n\t//\t\tby one\n\t// Note that we're not using iword here ... there's a lot of",
            "logic // taking place, and it's only valid if the new word is not compressed.\n\t//\n\tgenerate if (OPT_OPIPE)\n\tbegin : GEN_OPIPE\n\t\t// {{{",
            "reg r_pipe, r_insn_is_pipeable;\n\n\t\t// Pipeline",
            "logic is too extreme for a single clock.\n\t\t// Let's break it into two clocks, using r_insn_is_pipeable\n\t\t// If this function is true, then the instruction associated\n\t\t// with the current",
            "output *may* have a pipeable instruction\n\t\t// following it.\n\t\t//\n\t\tinitial\tr_insn_is_pipeable = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_insn_is_pipeable <= 1'b0;\n\t\telse if ((i_ce)&&((!pf_valid)||(i_illegal))&&(!o_phase))\n\t\t\t// Pipeline bubble, can't pipe through it\n\t\t\tr_insn_is_pipeable <= 1'b0;\n\t\telse if (o_ljmp)\n\t\t\tr_insn_is_pipeable <= 1'b0;\n\t\telse if ((i_ce)&&((!OPT_CIS)&&(i_instruction[CISBIT])))\n\t\t\tr_insn_is_pipeable <= 1'b0;\n\t\telse if (i_ce)\n\t\tbegin\t// This is a valid instruction\n\t\t\tr_insn_is_pipeable <= (w_mem)&&(w_rB)\n\t\t\t\t// PC (and CC)",
            "reg isters can change\n\t\t\t\t// underneath us.  Therefore they cannot\n\t\t\t\t// be used as a base",
            "reg ister for piped\n\t\t\t\t// memory ops\n\t\t\t\t&&(w_dcdB[3:1] != 3'h7)\n\t\t\t\t// Writes to PC or CC will destroy any\n\t\t\t\t// possibility of pipeing--since they\n\t\t\t\t// could create a jump\n\t\t\t\t&&(w_dcdR[3:1] != 3'h7)\n\t\t\t\t//\n\t\t\t\t// Loads landing in the current address\n\t\t\t\t// pointer",
            "reg ister are not allowed,\n\t\t\t\t// as they could then be used to violate\n\t\t\t\t// our rule(s)\n\t\t\t\t&&((w_cis_op[0])||(w_dcdB != w_dcdA));\n\t\tend // else\n\t\t\t// The pipeline is stalled\n\n\t\tassign\tinsn_is_pipeable = r_insn_is_pipeable;\n\n\t\tinitial\tr_pipe = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_pipe <= 1'b0;\n\t\telse if (i_ce)\n\t\t\tr_pipe <= ((pf_valid)||(o_phase))\n\t\t\t\t// The last operation must be capable of\n\t\t\t\t// being followed by a pipeable memory op\n\t\t\t\t&&(r_insn_is_pipeable)\n\t\t\t\t// Both must be memory operations\n\t\t\t\t&&(w_mem)\n\t\t\t\t// Both must be writes, or both stores\n\t\t\t\t&&(o_op[0] == w_cis_op[0])\n\t\t\t\t// Both must be",
            "reg ister ops\n\t\t\t\t&&(w_rB)\n\t\t\t\t// Both must use the same",
            "reg ister for B\n\t\t\t\t&&(w_dcdB[3:0] == o_dcdB[3:0]);\n\t\t//\t\t// CC or PC",
            "reg isters are not valid addresses\n\t\t//\t\t//   Captured above\n\t\t//\t\t// But ... the result can never be B\n\t\t//\t\t//   Captured above\n\t\t//\t\t//\n\t\t//\t\t// Reads to CC or PC not allowed\n\t\t//\t\t// &&((o_op[0])||(w_dcdR[3:1] != 3'h7))\n\t\t//\t\t// Prior-reads to CC or PC not allowed\n\t\t//\t\t//   Captured above\n\t\t//\t\t// Same condition, or no condition now\n\t\t//\t\t&&((w_cond[2:0]==o_cond[2:0])\n\t\t//\t\t\t||(w_cond[2:0] == 3'h0));\n\t\t//\t\t// Same or incrementing immediate\n\t\t//\t\t&&(w_I[22]==r_I[22]);\n\t\tassign o_pipe = r_pipe;\n\t\t// }}}\n\tend else begin : GEN_NO_PIPE\n\t\t// {{{\n\t\tassign\to_pipe = 1'b0;\n\t\tassign\tinsn_is_pipeable = 1'b0;\n\n\t\t// verilator coverage_off\n\t\t// verilator lint_off UNUSED",
            "wire unused_pipable;\n\t\tassign\tunused_pipable = &{ 1'b0, insn_is_pipeable };\n\t\t// verilator lint_on  UNUSED\n\t\t// verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// o_valid\n\t// {{{\n\tinitial\tr_valid = 1'b0;\n\tgenerate if (OPT_PIPELINED)\n\tbegin : GEN_DCD_VALID\n\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_valid <= 1'b0;\n\t\telse if (i_ce)\n\t\t\tr_valid <= ((pf_valid)||(o_phase))&&(!o_ljmp);\n\t\telse if (!i_stalled)\n\t\t\tr_valid <= 1'b0;\n\n\tend else begin : GEN_DCD_VALID\n\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_valid <= 1'b0;\n\t\telse if (!i_stalled)\n\t\t\tr_valid <= ((pf_valid)||(o_phase))&&(!o_ljmp);\n\t\telse\n\t\t\tr_valid <= 1'b0;\n\n\tend endgenerate\n\n\tassign\to_valid = r_valid;\n\t// }}}\n\n\tassign\to_I = { {(32-22){r_I[22]}}, r_I[21:0] };\n\n\t// Make Verilator happy across all our various options\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off  UNUSED",
            "wire possibly_unused;\n\tassign\tpossibly_unused = &{ 1'b0, w_lock, w_ljmp, w_ljmp_dly,\n\t\t\tinsn_is_pipeable, w_cis_ljmp, i_pc[1:0], w_add };\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "reg f_past_valid;\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n`define\tASSERT\tassert\n`ifdef\tIDECODE\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif\n\talways @(posedge i_clk)\n\tif ((i_ce)&&(i_pf_valid)&&(!o_phase))\n\t\tf_insn_word <= i_instruction;\n\n\tassign\tf_insn_is_pipeable = insn_is_pipeable;\n\n\talways @(posedge i_clk)\n\tif ((i_ce)&&(i_pf_valid)&&(!o_phase))\n\t\tf_insn_gie <= i_gie;\n\n\talways @(posedge i_clk)\n\tif (!i_reset && o_valid)\n\t\t`ASSUME(f_insn_gie == i_gie);\n\n\talways @(*)\n\tif (o_phase)\n\t\tassert(r_nxt_half == f_insn_word[14:0]);\n\n\t////////////////////////////\n\t//\n\t//\n\t// Assumptions about our",
            "input s\n\t//\n\t//\n\t///////////////////////////\n\talways @(*)\n\tif (OPT_PIPELINED)\n\tbegin\n\t\t`ASSUME(i_ce == ((!o_valid)||(!i_stalled)));\n\tend else\n\t\t`ASSUME(i_ce == !i_stalled);\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset))\n\tbegin\n\t\t`ASSERT(!o_valid);\n\t\t// `ASSERT(!o_illegal);\n\t\t`ASSERT(!o_phase);\n\t\t`ASSERT(!o_ljmp);\n\t\t`ASSERT(!o_pipe);\n\n\t\t// `ASSUME(!i_pf_valid);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!i_reset))\n\t\t`ASSUME(i_gie == $past(i_gie));\n\n`ifdef\tIDECODE\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&(!$past(i_ce))\n\t\t&&($past(f_past_valid))&&(!$past(i_reset,2))&&(!$past(i_ce,2)))\n\t\tassume(i_ce);\n`endif",
            "reg f_new_insn, f_last_insn;\n\n\tinitial\tf_new_insn = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_new_insn <= 1'b0;\n\telse\n\t\tf_new_insn <= ((pf_valid)&&(!i_stalled));\n\n\tinitial\tf_last_insn = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_last_insn <= 1'b0;\n\telse\n\t\tf_last_insn <= (o_valid)&&(i_stalled);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(f_last_insn)&&(!i_reset))\n\tbegin\n\t\tif (($past(pf_valid))&&(pf_valid))\n\t\tbegin\n\t\t\t`ASSUME(i_illegal || i_instruction == $past(i_instruction));\n\t\t\t`ASSUME(i_gie == $past(i_gie));\n\t\t\t`ASSUME(i_pc  == $past(i_pc));\n\t\t\t`ASSUME(i_illegal == $past(i_illegal));\n\t\tend\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(o_early_branch_stb))\n\t\t`ASSUME(!pf_valid);\n\n\talways @(*)\n\tif (i_pf_valid)\n\t\t`ASSUME(i_pc[1:0] == 2'b00);\n\n\talways @(*)\n\tif ((o_valid)&&(!o_early_branch))\n\t\t`ASSERT((o_illegal)||(o_pc[1] == o_phase));",
            "wire [3+7+7+7+32+1+4+1+4+10+(AW+2)+3+23+(AW+2)-1:0]\tf_result;\n\tassign\tf_result = { o_phase, o_illegal, i_gie,\n\t\t\to_dcdR, o_dcdA, o_dcdB,\n\t\t\to_I, o_zI, o_cond, o_wF, o_op,\n\t\t\to_ALU, o_M, o_DV, o_FP, o_break, o_lock,\n\t\t\to_wR, o_rA, o_rB, o_early_branch,\n\t\t\to_branch_pc, o_ljmp, o_pipe, o_sim,\n\t\t\to_sim_immv, o_pc };\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($stable(i_gie))&&(f_last_insn))\n\tbegin\n\t\t`ASSERT($stable(f_result));\n\t\tif (OPT_PIPELINED)\n\t\t\t// All but valid will be stable\n\t\t\t`ASSERT($stable(o_valid));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(pf_valid))\n\t\t\t&&(!$past(o_ljmp)))\n\t\t`ASSERT((!OPT_PIPELINED)||(o_valid));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(f_new_insn)\n\t\t\t&&($past(pf_valid))&&($past(i_illegal))&&(!$past(o_phase)))\n\t\t`ASSERT(o_illegal);\n\n`ifdef\tIDECODE\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Let's walk through some basic instructions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// First 8-instructions, SUB - ASR\n\t// {{{\n\talways @(*)\n\tif ((!iword[CISBIT])&&(iword[26:25]==2'b00))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_mov);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT(!w_mpy);\n\t\t`ASSERT((w_rA)&&(w_wR)&&(w_ALU));\n\t\t`ASSERT(w_rB == iword[IMMSEL]);\n\t\t`ASSERT(w_dcdA[4] == i_gie);\n\t\t`ASSERT(w_dcdB[4] == i_gie);\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\t`ASSERT(w_dcdB[3:0] == iword[17:14]);\n\n\t\t`ASSERT(w_cis_op == w_op);\n\n\t\t`ASSERT(w_cond[3] == (iword[21:19] == 3'b000));\n\t\t`ASSERT(w_cond[2:0] == iword[21:19]);\n\t\t`ASSERT((w_wF == w_cond[3])||(w_dcdA[3:1]==3'b111));\n\t\t// }}}\n\tend else if ((iword[CISBIT])&&(iword[26:24]<3'b011))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_mov);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT(!w_mpy);\n\t\t`ASSERT((w_rA)&&(w_wR)&&(w_ALU));\n\t\t`ASSERT(w_rB == iword[CISIMMSEL]);\n\t\t`ASSERT(w_dcdA[4] == i_gie);\n\t\t`ASSERT(w_dcdB[4] == i_gie);\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\t`ASSERT(w_dcdB[3:0] == iword[22:19]);\n\n\t\tif (iword[26:24] == 3'b000)\n\t\tbegin\n\t\t\t`ASSERT(w_cis_op == 5'h0);\n\t\tend else if (iword[26:24] == 5'h01)\n\t\tbegin\n\t\t\t`ASSERT(w_cis_op == 5'h01);\n\t\tend else // if (iword[26:24] == 3'b010)\n\t\t\t`ASSERT(w_cis_op == 5'h02);\n\n\t\t`ASSERT(w_cond == 4'h8);\n\n\t\tif (iword[CISIMMSEL])\n\t\tbegin\n\t\t\t`ASSERT(w_I == { {(23-3){iword[18]}}, iword[18:16] });\n\t\tend else\n\t\t\t`ASSERT(w_I == { {(23-7){iword[22]}}, iword[22:16] });\n\t\t// }}}\n\tend else\n\t\t`ASSERT(!w_add);\n\t// }}}\n\n\t// BREV and LDILO\n\t// {{{\n\talways @(*)\n\tif ((!iword[CISBIT])&&((w_cis_op == 5'h8)\n\t\t\t||(w_cis_op == 5'h09)))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(!w_mpy);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_mov);\n\t\tif (w_cis_op == 5'h8)\n\t\tbegin\n\t\t\t`ASSERT(w_brev);\n\t\t\t`ASSERT(!w_ldilo);\n\t\t\t`ASSERT((!w_rA)&&(w_wR)&&(w_ALU));\n\t\tend else begin// if (w_cis_op == 5'h9)\n\t\t\t`ASSERT(w_ldilo);\n\t\t\t`ASSERT(!w_brev);\n\t\t\t`ASSERT((w_rA)&&(w_wR)&&(w_ALU));\n\t\tend\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT(w_rB == iword[IMMSEL]);\n\t\t`ASSERT(w_dcdA[4] == i_gie);\n\t\t`ASSERT(w_dcdB[4] == i_gie);\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\t`ASSERT(w_dcdB[3:0] == iword[17:14]);\n\n\t\t`ASSERT(w_cis_op == w_op);\n\n\t\t`ASSERT(w_cond[3] == (iword[21:19] == 3'b000));\n\t\t`ASSERT(w_cond[2:0] == iword[21:19]);\n\t\t`ASSERT(!w_wF);\n\t\t// }}}\n\tend else begin\n\t\t// {{{\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// Multiply instructions\n\t// {{{\n\talways @(*)\n\tif ((!iword[CISBIT])&&((w_cis_op == 5'ha)\n\t\t\t||(w_cis_op == 5'h0b)\n\t\t\t||(w_cis_op == 5'h0c)))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(w_mpy);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_mov);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT((w_rA)&&(w_wR)&&(w_ALU));\n\t\t`ASSERT(w_rB == iword[IMMSEL]);\n\t\t`ASSERT(w_dcdA[4] == i_gie);\n\t\t`ASSERT(w_dcdB[4] == i_gie);\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\t`ASSERT(w_dcdB[3:0] == iword[17:14]);\n\n\t\t`ASSERT(w_cis_op == w_op);\n\n\t\t`ASSERT(w_cond[3] == (iword[21:19] == 3'b000));\n\t\t`ASSERT(w_cond[2:0] == iword[21:19]);\n\t\t`ASSERT((w_wF == w_cond[3])||(w_dcdA[3:1]==3'b111));\n\t\t// }}}\n\tend else\n\t\t`ASSERT(!w_mpy);\n\t// }}}\n\n\t// Move instruction\n\t// {{{\n\talways @(*)\n\tif ((!iword[CISBIT])&&((w_cis_op == 5'hd)))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(w_mov);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_mpy);\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT((!w_rA)&&(w_wR)&&(w_ALU));\n\t\t`ASSERT(w_rB);\n\t\t`ASSERT(w_dcdA[4] == ((i_gie)||(iword[IMMSEL])));\n\t\t`ASSERT(w_dcdB[4] == ((i_gie)||(iword[13])));\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\t`ASSERT(w_dcdB[3:0] == iword[17:14]);\n\n\t\t`ASSERT(w_cis_op == w_op);\n\n\t\t`ASSERT(w_cond[3] == (iword[21:19] == 3'b000));\n\t\t`ASSERT(w_cond[2:0] == iword[21:19]);\n\t\t`ASSERT(!w_wF);\n\t\t// }}}\n\tend else if ((iword[CISBIT])&&(iword[26:24]==3'b111))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(w_mov);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_mpy);\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT((!w_rA)&&(w_wR)&&(w_ALU));\n\t\t`ASSERT(w_rB);\n\t\t`ASSERT(w_dcdA[4] == (i_gie));\n\t\t`ASSERT(w_dcdB[4] == (i_gie));\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\t`ASSERT(w_dcdB[3:0] == iword[22:19]);\n\n\t\t`ASSERT(w_cis_op == 5'h0d);\n\n\t\t`ASSERT(w_cond == 4'h8);\n\t\t`ASSERT(!w_wF);\n\t\t// }}}\n\tend else\n\t\t`ASSERT(!w_mov);\n\t// }}}\n\n\t// Divide instruction\n\t// {{{\n\talways @(*)\n\tif ((!iword[CISBIT])&&(iword[26:23]==4'b0111))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(w_div);\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_mov);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT(!w_mpy);\n\t\t`ASSERT((w_rA)&&(w_wR));\n\t\t`ASSERT(w_rB == iword[IMMSEL]);\n\t\t`ASSERT(w_dcdA[4] == i_gie);\n\t\t`ASSERT(w_dcdB[4] == i_gie);\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\t`ASSERT(w_dcdB[3:0] == iword[17:14]);\n\n\t\t`ASSERT(w_cis_op == w_op);\n\n\t\t`ASSERT(w_cond[3] == (iword[21:19] == 3'b000));\n\t\t`ASSERT(w_cond[2:0] == iword[21:19]);\n\t\t`ASSERT((w_wF == w_cond[3])||(w_dcdA[3:1]==3'b111));\n\t\t// }}}\n\tend else\n\t\t`ASSERT(!w_div);\n\t// }}}\n\n\t// Comparison instructions\n\t// {{{\n\talways @(*)\n\tif ((!iword[CISBIT])&&(iword[26:23]==4'b1000))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(w_cmptst);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_mov);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT(!w_mpy);\n\t\t`ASSERT((w_rA)&&(!w_wR)&&(!w_ALU));\n\t\t`ASSERT(w_rB == iword[IMMSEL]);\n\t\t`ASSERT(w_dcdA[4] == i_gie);\n\t\t`ASSERT(w_dcdB[4] == i_gie);\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\t`ASSERT(w_dcdB[3:0] == iword[17:14]);\n\n\t\t`ASSERT(w_cis_op == w_op);\n\n\t\t`ASSERT(w_cond[3] == (iword[21:19] == 3'b000));\n\t\t`ASSERT(w_cond[2:0] == iword[21:19]);\n\t\t`ASSERT(w_wF);\n\t\t// }}}\n\tend else if ((iword[CISBIT])&&(iword[26:24]==3'b011))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(w_cmptst);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_mov);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT(!w_mpy);\n\t\t`ASSERT((w_rA)&&(!w_wR)&&(!w_ALU));\n\t\t`ASSERT(w_rB == iword[CISIMMSEL]);\n\t\t`ASSERT(w_dcdA[4] == i_gie);\n\t\t`ASSERT(w_dcdB[4] == i_gie);\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\t`ASSERT(w_dcdB[3:0] == iword[22:19]);\n\n\t\t`ASSERT(w_cis_op == 5'h10);\n\n\t\t`ASSERT(w_cond == 4'h8);\n\t\tif (iword[CISIMMSEL])\n\t\tbegin\n\t\t\t`ASSERT(w_I == { {(23-3){iword[18]}}, iword[18:16] });\n\t\tend else\n\t\t\t`ASSERT(w_I == { {(23-7){iword[22]}}, iword[22:16] });\n\t\t`ASSERT(w_wF);\n\t\t// }}}\n\tend else\n\t\t`ASSERT(!w_cmptst);\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((f_new_insn)&&($past(w_cmptst)))\n\t\t`ASSERT(o_ALU);\n\n\t// Memory instructions\n\t// {{{\n\talways @(*)\n\tif ((!iword[CISBIT])&&(\n\t\t(iword[26:23]==4'b1001)\t\t// Word\n\t\t||(iword[26:23]==4'b1010)\t// Half-word, or short\n\t\t||(iword[26:23]==4'b1011)))\t// Byte ops\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(w_mem);\n\t\t`ASSERT(w_sto == iword[22]);\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_mov);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT(!w_mpy);\n\t\tif (w_sto)\n\t\tbegin\n\t\t\t`ASSERT((w_rA)&&(!w_wR));\n\t\tend else\n\t\t\t`ASSERT((!w_rA)&&(w_wR));\n\t\t`ASSERT(!w_ALU);\n\t\t`ASSERT(w_rB == iword[IMMSEL]);\n\t\t`ASSERT(w_dcdA[4] == i_gie);\n\t\t`ASSERT(w_dcdB[4] == i_gie);\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\t`ASSERT(w_dcdB[3:0] == iword[17:14]);\n\n\t\t`ASSERT(w_cis_op == w_op);\n\n\t\t`ASSERT(w_cond[3] == (iword[21:19] == 3'b000));\n\t\t`ASSERT(w_cond[2:0] == iword[21:19]);\n\t\t`ASSERT(!w_wF);\n\t\t// }}}\n\tend else if ((iword[CISBIT])&&(iword[26:25]==2'b10))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(w_mem);\n\t\t`ASSERT(w_sto == iword[24]);\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_mov);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT(!w_mpy);\n\t\tif (w_sto)\n\t\tbegin\n\t\t\t`ASSERT((w_rA)&&(!w_wR));\n\t\tend else\n\t\t\t`ASSERT((!w_rA)&&(w_wR));\n\t\t`ASSERT(!w_ALU);\n\t\t`ASSERT(w_rB);\n\t\t`ASSERT(w_dcdA[4] == i_gie);\n\t\t`ASSERT(w_dcdB[4] == i_gie);\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\tif (iword[CISIMMSEL])\n\t\tbegin\n\t\t\t`ASSERT(w_dcdB[3:0] == iword[22:19]);\n\t\tend else\n\t\t\t`ASSERT(w_dcdB[3:0] == CPU_SP_REG);\n\n\t\tif (w_sto)\n\t\tbegin\n\t\t\t`ASSERT(w_cis_op == 5'h13);\n\t\tend else\n\t\t\t`ASSERT(w_cis_op == 5'h12);\n\n\t\t`ASSERT(w_cond == 4'h8);\n\t\t`ASSERT(!w_wF);\n\t\t// }}}\n\tend else begin\n\t\t// {{{\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_mem);\n\t\t// }}}\n\tend\n\n\talways @(*)\n\tif (w_sto)\n\t\t`ASSERT(w_mem);\n\t// }}}\n\n\t// LDI -- Load immediate\n\t// {{{\n\talways @(*)\n\tif ((!iword[CISBIT])&&(w_op[4:1] == 4'hc))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(w_ldi);\n\t\t`ASSERT(!w_mpy);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_mov);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT((!w_rA)&&(w_wR)&&(!w_ALU));\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT(w_rB == 1'b0);\n\t\t`ASSERT(w_dcdA[4] == i_gie);\n\t\t`ASSERT(w_dcdB[4] == i_gie);\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\t`ASSERT(w_dcdB[3:0] == iword[17:14]);\n\n\t\t`ASSERT(w_cis_op == w_op);\n\n\t\t`ASSERT(w_cond == 4'h8);\n\t\t`ASSERT(!w_wF);\n\n\t\t`ASSERT(w_Iz == (iword[22:0] == 0));\n\t\t`ASSERT(w_I[22:0] == iword[22:0]);\n\t\t// }}}\n\tend else if ((iword[CISBIT])&&(iword[26:24] == 3'b110))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(w_ldi);\n\t\t`ASSERT(!w_mpy);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_mov);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT((!w_rA)&&(w_wR)&&(!w_ALU));\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_fpu);\n\t\t`ASSERT(w_rB == 1'b0);\n\t\t`ASSERT(w_dcdA[4] == i_gie);\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\n\t\t`ASSERT(w_cis_op[4:1] == 4'hc);\n\n\t\t`ASSERT(w_cond == 4'h8);\n\t\t`ASSERT(!w_wF);\n\n\t\t`ASSERT(w_Iz == (iword[23:16] == 0));\n\t\t`ASSERT(w_I[22:0] == { {(23-8){iword[23]}}, iword[23:16] });\n\t\t// }}}\n\tend else\n\t\t`ASSERT(!w_ldi);\n\t// }}}\n\n`endif\t// IDECODE\n\n\talways @(posedge i_clk)\n\tif ((f_new_insn)&&($past(w_ldi)))\n\t\t`ASSERT(o_ALU);\n\n\talways @(*)\n\tif (!OPT_LOCK)\n\t\t`ASSERT(!o_lock);\n\n`ifdef\tIDECODE\n\talways @(*)\n\tif ((w_break)||(w_lock)||(w_sim)||(w_noop))\n\t\t`ASSERT(w_special);\n\n\t// FPU -- Floating point instructions\n\t// {{{\n\talways @(*)\n\tif ((!iword[CISBIT])&&(\n\t\t\t(w_cis_op[4:1] == 4'hd)\n\t\t\t||(w_cis_op[4:1] == 4'he)\n\t\t\t||(w_cis_op[4:1] == 4'hf))\n\t\t\t&&(iword[30:28] != 3'h7))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(w_fpu);\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_mpy);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_mov);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\t\t`ASSERT((w_wR)&&(!w_ALU));\n\t\tif ((w_cis_op == 5'he)||(w_cis_op == 5'hf))\n\t\tbegin\n\t\t\t`ASSERT(!w_rA);\n\t\tend else begin\n\t\t\t`ASSERT(w_rA);\n\t\tend\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(w_rB == iword[IMMSEL]);\n\t\t`ASSERT(w_dcdA[4] == i_gie);\n\t\t`ASSERT(w_dcdB[4] == i_gie);\n\t\t`ASSERT(w_dcdA[3:0] == iword[30:27]);\n\t\t`ASSERT(w_dcdB[3:0] == iword[17:14]);\n\n\t\t`ASSERT(w_cis_op == w_op);\n\n\t\t`ASSERT(w_cond[3] == (iword[21:19] == 3'b000));\n\t\t`ASSERT(w_cond[2:0] == iword[21:19]);\n\t\t`ASSERT((w_wF == w_cond[3])||(w_dcdA[3:1]==3'b111));\n\t\t// }}}\n\tend else\n\t\t`ASSERT(!w_fpu);\n\t// }}}\n\n\t// Special instructions\n\t// {{{\n\talways @(*)\n\tif ((!iword[CISBIT])&&(\n\t\t\t(w_cis_op == 5'h1c)\n\t\t\t||(w_cis_op == 5'h1d)\n\t\t\t||(w_cis_op == 5'h1e)\n\t\t\t||(w_cis_op == 5'h1f))\n\t\t\t&&(iword[30:28] == 3'h7))\n\tbegin\n\t\t// {{{\n\t\t`ASSERT(w_special);\n\t\tif (w_cis_op == 5'h1c)\n\t\tbegin // Break instruction\n\t\t\t`ASSERT(w_break);\n\t\t\t`ASSERT(!w_lock);\n\t\t\t`ASSERT(!w_sim);\n\t\t\t`ASSERT(!w_noop);\n\t\tend else if (w_cis_op == 5'h1d)\n\t\tbegin // Lock instruction\n\t\t\t`ASSERT(!w_break);\n\t\t\t`ASSERT( w_lock);\n\t\t\t`ASSERT(!w_sim);\n\t\t\t`ASSERT(!w_noop);\n\t\tend else if (w_cis_op == 5'h1e)\n\t\tbegin // Sim instruction\n\t\t\t`ASSERT(!w_break);\n\t\t\t`ASSERT(!w_lock);\n\t\t\t`ASSERT( w_sim);\n\t\t\t`ASSERT( w_noop);\n\t\tend else begin // NOOP instruction\n\t\t\t`ASSERT(!w_break);\n\t\t\t`ASSERT(!w_lock);\n\t\t\t`ASSERT(!w_sim);\n\t\t\t`ASSERT( w_noop);\n\t\tend\n\t\t`ASSERT((!w_fpu)||(!OPT_FPU));\n\t\t`ASSERT(!w_ldi);\n\t\t`ASSERT(!w_mpy);\n\t\t`ASSERT(!w_div);\n\t\t`ASSERT(!w_cmptst);\n\t\t`ASSERT(!w_mem);\n\t\t`ASSERT(!w_sto);\n\t\t`ASSERT(!w_mov);\n\t\t`ASSERT(!w_brev);\n\t\t`ASSERT(!w_ldilo);\n\n\t\t`ASSERT((!w_rA)&&(!w_rB)&&(!w_wR)&&(!w_ALU));\n\n\t\t`ASSERT(w_cis_op == w_op);\n\n\t\t`ASSERT(w_cond == 4'h8);\n\t\t`ASSERT(!w_wF);\n\t\t// }}}\n\tend else begin\n\t\t// {{{\n\t\t`ASSERT(!w_special);\n\t\t`ASSERT(!w_break);\n\t\t`ASSERT(!w_lock);\n\t\t`ASSERT(!w_sim);\n\t\t`ASSERT(!w_noop);\n\t\t// }}}\n\tend\n\t// }}}\n\t// }}}\n`endif\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Early branching checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_EARLY_BRANCHING)\n\tbegin\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&($past(i_ce))&&(!$past(i_reset))&&(!i_reset))\n\t\tbegin\n\t\t\tif ($past(pf_valid))\n\t\t\tbegin\n\t\t\t\tif ($past(o_ljmp))\n\t\t\t\tbegin\n\t\t\t\t\t// 2nd half of LW (PC),PC\n\t\t\t\t\t`ASSERT(o_early_branch);\n\t\t\t\t\t`ASSERT(o_early_branch_stb);\n\t\t\t\tend else if ((!$past(iword[CISBIT]))&&($past(w_add))\n\t\t\t\t\t&&(!$past(w_rB))\n\t\t\t\t\t&&($past(w_cond[3]))\n\t\t\t\t\t&&(o_dcdR[4:0]=={ i_gie, 4'hf }))\n\t\t\t\tbegin\n\t\t\t\t\t// ADD #x,PC\n\t\t\t\t\t`ASSERT(o_early_branch);\n\t\t\t\t\t`ASSERT(o_early_branch_stb);\n\t\t\t\tend else if ((!$past(iword[CISBIT]))\n\t\t\t\t\t&&($past(w_cis_op == 5'h12))\n\t\t\t\t\t&&($past(w_rB))\n\t\t\t\t\t&&($past(w_cond[3]))\n\t\t\t\t\t&&(o_zI)\n\t\t\t\t\t&&(o_dcdB[4:0]=={ i_gie, 4'hf })\n\t\t\t\t\t&&(o_dcdR[4:0]=={ i_gie, 4'hf }))\n\t\t\t\tbegin\n\t\t\t\t\t// LW (PC),PC\n\t\t\t\t\t`ASSERT(!o_early_branch);\n\t\t\t\t\t`ASSERT(!o_early_branch_stb);\n\t\t\t\tend else if ((OPT_CIS)&&($past(o_phase))\n\t\t\t\t\t&&($past(w_cis_op == 5'h12))\n\t\t\t\t\t&&($past(w_rB))\n\t\t\t\t\t&&($past(w_cond[3]))\n\t\t\t\t\t&&($past(w_Iz))\n\t\t\t\t\t&&($past(w_dcdB_pc))\n\t\t\t\t\t&&($past(w_dcdR_pc))\n\t\t\t\t\t&&(o_dcdR[4:0]=={ i_gie, 4'hf }))\n\t\t\t\tbegin\n\t\t\t\t\t// (CIS) LW (PC),PC\n\t\t\t\t\t`ASSERT(!o_early_branch);\n\t\t\t\t\t`ASSERT(!o_early_branch_stb);\n\t\t\t\tend else begin\n\t\t\t\t\t`ASSERT(!o_early_branch);\n\t\t\t\tend\n\t\t\tend else if ((OPT_CIS)&&($past(o_phase)))\n\t\t\tbegin\n\t\t\t\tif (($past(w_cis_op == 5'h12))\n\t\t\t\t\t&&($past(w_rB))\n\t\t\t\t\t&&($past(w_cond[3]))\n\t\t\t\t\t&&($past(w_Iz))\n\t\t\t\t\t&&($past(w_dcdB_pc))\n\t\t\t\t\t&&($past(w_dcdR_pc)))\n\t\t\t\tbegin\n\t\t\t\t// (CIS) LW (PC),PC\n\t\t\t\t\t`ASSERT(!o_early_branch);\n\t\t\t\t\t`ASSERT(!o_early_branch_stb);\n\t\t\t\tend else begin\n\t\t\t\t\t`ASSERT(!o_early_branch);\n\t\t\t\t\t`ASSERT(!o_early_branch_stb);\n\t\t\t\tend\n\t\t\tend\n\t\tend else if (!i_reset)\n\t\t\t`ASSERT(!o_early_branch_stb);\n\n//\t\t// CIS instruction 16'hfcf8 decodes into:\n//\t\t// 1.1111.100.1.1111.0000\n//\t\t// = LW (PC),PC\n//\t\talways @(*)\n//\t\t\tassume(i_instruction[31:16] != 16'hfcf8);\n\n\tend else begin\n\t\talways @(*)\n\t\t\t`ASSERT(!o_early_branch_stb);\n\t\talways @(*)\n\t\t\t`ASSERT(!o_early_branch);\n\tend endgenerate\n\n\talways @(*)\n\t\tif (o_early_branch_stb)\n\t\t\t`ASSERT(o_early_branch);\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_early_branch_stb))&&(!$past(pf_valid)))\n\t\t\t`ASSERT(!o_early_branch_stb);\n\t// }}}\n\n\t// CIS specific checks\n\t// {{{\n\tgenerate if (OPT_CIS)\n\tbegin : F_OPT_CIS\n\t\t// {{{\n\t\talways @(*)\n\t\tif (OPT_PIPELINED && !o_valid)\n\t\t\t`ASSERT(!o_phase);\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(!$past(i_reset)))\n\t\tbegin\n\t\t\tif ((o_phase)&&($past(i_ce)))\n\t\t\tbegin\n\t\t\t\t`ASSERT((iword[30:16] == $past(i_instruction[14:0]))\n\t\t\t\t\t&&(iword[CISBIT]));\n\t\t\tend else if (!o_phase)\n\t\t\t\t`ASSERT(iword == i_instruction);\n\n\t\t\tif ((!$past(o_phase))&&($past(i_ce))\n\t\t\t\t\t&&($past(pf_valid))\n\t\t\t\t\t&&(!$past(i_illegal))\n\t\t\t\t\t&&(!$past(w_ljmp_dly))\n\t\t\t\t\t&&($past(i_instruction[CISBIT]))\n\t\t\t\t\t&&((!$past(w_dcdR_pc))\n\t\t\t\t\t\t||(!$past(w_wR))))\n\t\t\tbegin\n\t\t\t\t`ASSERT(o_phase);\n\t\t\tend else if (($past(o_phase))&&($past(i_ce)))\n\t\t\t\t`ASSERT(!o_phase);\n\t\t\tif (($past(i_ce))&&(!$past(o_phase))\n\t\t\t\t&&($past(i_illegal))&&($past(i_pf_valid)))\n\t\t\t\t`ASSERT((o_illegal)&&(!o_phase));\n\n\t\t\t`ASSERT((!o_phase)||(!o_ljmp));\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(!$past(i_stalled))&&($past(pf_valid))\n\t\t\t\t&&($past(i_ce)))\n\t\tbegin\n\t\t\t`ASSERT(o_pc[0] == 1'b0);\n\t\t\tif (!$past(iword[CISBIT]))\n\t\t\tbegin\n\t\t\t\t`ASSERT(o_pc[1:0]==2'b00);\n\t\t\t\t`ASSERT(o_pc[AW+1:2] == $past(i_pc[AW+1:2])+1'b1);\n\t\t\tend else if ($past(iword[CISBIT])&&($past(o_phase)))\n\t\t\tbegin\n\t\t\t\t`ASSERT(o_pc[(AW+1):1] == $past(o_pc[(AW+1):1]) + 1'b1);\n\t\t\tend else if ($past(iword[CISBIT]))\n\t\t\tbegin\n\t\t\t\t`ASSERT(o_pc[(AW+1):1] == { $past(i_pc[(AW+1):2]), 1'b1});\n\t\t\t\tif (o_valid)\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(o_pc[1]);\n\t\t\t\t\t`ASSERT((o_illegal)||(o_phase));\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\n\t\talways @(*)\n\t\tif (iword[CISBIT])\n\t\tbegin\n\t\t\t`ASSERT((!w_ldi)||(w_I == { {(23-8){iword[23]}}, iword[23:16] }));\n\t\t\t`ASSERT((w_ldi)||(iword[CISIMMSEL])\n\t\t\t\t||(w_I == { {(23-7){iword[22]}}, iword[22:16] }));\n\t\t\t`ASSERT((w_ldi)||(!iword[CISIMMSEL])\n\t\t\t\t||(w_I == { {(23-3){iword[18]}}, iword[18:16] }));\n\t\tend else begin\n\t\t\t`ASSERT((!w_ldi)||(w_I == iword[22:0]));\n\t\t\t`ASSERT((!w_mov)||(w_I == { {(23-13){iword[12]}}, iword[12:0] }));\n\t\t\t`ASSERT((w_ldi)||(w_mov)||(iword[IMMSEL])\n\t\t\t\t\t||(w_I == { {(23-18){iword[17]}}, iword[17:0] }));\n\t\t\t`ASSERT((w_ldi)||(w_mov)||(!iword[IMMSEL])\n\t\t\t\t\t||(w_I == { {(23-14){iword[13]}}, iword[13:0] }));\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(o_phase)&&($past(i_ce)))\n\t\t\t`ASSERT(($past(i_instruction[CISBIT]))\n\t\t\t\t&&(r_nxt_half[14:0]==$past(i_instruction[14:0])));\n\t\t// }}}\n\tend else begin\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\t`ASSERT((o_phase)||(iword[30:0] == i_instruction[30:0]));\n\t\t\t`ASSERT(o_phase == 1'b0);\n\t\t\t`ASSERT(o_pc[0] == 1'b0);\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&($past(i_ce))&&($past(i_pf_valid)))\n\t\tbegin\n\t\t\t`ASSERT(o_pc[AW+1:2] == $past(i_pc[AW+1:2]) + 1'b1);\n\t\tend else if (f_past_valid)\n\t\t\t`ASSERT(o_pc == $past(o_pc));\n\n\t\talways @(*)\n\t\t\t`ASSERT(o_pc[1:0] == 2'b00);\n\n\t\talways @(*)\n\t\t\t`ASSERT((!w_ldi)||(w_I == iword[22:0]));\n\t\talways @(*)\n\t\t\t`ASSERT((!w_mov)||(w_I == { {(23-13){iword[12]}}, iword[12:0] }));\n\t\talways @(*)\n\t\t\t`ASSERT((w_ldi)||(w_mov)||(iword[IMMSEL])\n\t\t\t\t\t||(w_I == { {(23-18){iword[17]}}, iword[17:0] }));\n\t\talways @(*)\n\t\t\t`ASSERT((w_ldi)||(w_mov)||(!iword[IMMSEL])\n\t\t\t\t\t||(w_I == { {(23-14){iword[13]}}, iword[13:0] }));\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&($past(i_ce))&&(!$past(i_reset)))\n\t\t\t`ASSERT((!$past(i_instruction[CISBIT]))\n\t\t\t\t||(!$past(pf_valid))||(o_illegal));\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_ce && pf_valid))\n\t\t&&($past(w_fpu)))\n\tbegin\n\t\tif (OPT_FPU)\n\t\tbegin\n\t\t\t`ASSERT(o_FP);\n\t\tend else if (!$past(w_special))\n\t\t\t`ASSERT(o_illegal);\n\tend\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_ce && pf_valid))&&($past(w_lock)))\n\tbegin\n\t\tif (OPT_LOCK)\n\t\tbegin\n\t\t\t`ASSERT(o_lock);\n\t\tend else\n\t\t\t`ASSERT(o_illegal);\n\tend\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Check pipelined memory instructions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//",
            "wire [20:0]\tf_next_pipe_I, f_this_pipe_I;\n\n\t// assign\tf_this_pipe_I = r_I[22:2];\n\t// assign\tf_next_pipe_I = r_I[22:2]+1'b1;\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset)))\n\tbegin\n\t\tif (OPT_OPIPE)\n\t\tbegin\n\t\t\tif (($past(i_ce))\n\t\t\t\t&&(($past(pf_valid))||($past(o_phase))))\n\t\t\tbegin\n\t\t\t\tif ((!$past(o_M))||(!o_M))\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!o_pipe);\n\t\t\t\tend else if ($past(o_op[0])!=o_op[0])\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!o_pipe);\n\t\t\t\tend else if ($past(o_rB)!=o_rB)\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!o_pipe);\n\t\t\t\tend else if ((o_rB)&&($past(o_dcdB) != o_dcdB))\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!o_pipe);\n\t\t\t\tend else if (($past(o_wR))\n\t\t\t\t\t\t&&($past(o_dcdR[3:1]) == 3'h7))\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!o_pipe);\n\t\t\t\tend else if (o_wR != $past(o_wR))\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!o_pipe);\n\t\t\t\tend else if ((o_wR)&&($past(o_dcdR) == o_dcdB))\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!o_pipe);\n\t\t\t\tend else if ((o_wR)&&(o_dcdB[3:1] == 3'h7))\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!o_pipe);\n\t\t//\n\t\t// Allow reading into the PC",
            "reg ister as a form of jumping\n\t\t//\t\t// else if ((o_wR)&&(o_dcdR[3:1] == 3'h7))\n\t\t//\t\t//\t`ASSERT(!o_pipe);\n\t\t// Allow discontinuous reads -- since our crossbar can now\n\t\t// handle them\n\t\t//\t\telse if (($past(o_cond) != 4'h8)\n\t\t//\t\t\t&&($past(o_cond) != o_cond))\n\t\t//\t\t\t`ASSERT(!o_pipe);\n\t\t// This never really guaranteed that addresses would only\n\t\t// increment, nor does it guarantee that addresses won't\n\t\t// wrap around, so ... we'll just ignore this and (instead)\n\t\t// generate a bus error in the memory controller on bad\n\t\t// addresses\n\t\t//\t\telse if ($past(r_I[22])!=r_I[22])\n\t\t//\t\t\t`ASSERT(!o_pipe);\n\t\t//\t\telse if (r_I[22:0] - $past(r_I[22:0])>23'h4)\n\t\t//\t\t\t`ASSERT(!o_pipe);\n\t\t\t\tend else if (!$past(o_valid))\n\t\t\t\t\t`ASSERT(!o_pipe);\n\t\t\t\t// else\n\t\t\t\t\t// assert(o_pipe);\n\t\t\tend else if ($past(i_stalled))\n\t\t\t\t`ASSERT(o_pipe == $past(o_pipe));\n\t\tend\n\tend\n\n\talways @(*)\n\t\t`ASSERT((OPT_OPIPE)||(!o_pipe));\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_ce))\n\t\t\t&&($past(i_pf_valid))&&($past(w_mpy)))\n\t\t`ASSERT((OPT_MPY)||(o_illegal));\n\n\talways @(*)\n\tif (o_valid)\n\t\t`ASSERT((!o_phase)||(!o_early_branch));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_valid))&&($past(o_ljmp))&&($past(!i_stalled)))\n\t\t`ASSERT(!o_valid);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_early_branch_stb)))\n\tbegin\n\t\t`ASSERT(!o_phase);\n\t\tif (!$past(i_stalled))\n\t\t\t`ASSERT(!o_valid);\n\t\t\t`ASSERT(!o_ljmp);\n\tend\n\n\t// Unless another valid instruction comes along, once o_ljmp is asserted\n\t// it should stay asserted until either a reset or an early branch\n\t// strobe.\n\talways @(posedge i_clk)\n\tif ((OPT_EARLY_BRANCHING)&&(f_past_valid)\n\t\t\t&&($past(o_ljmp))&&(!$past(pf_valid))\n\t\t\t&&(!$past(i_reset))&&(!$past(o_early_branch_stb)))\n\t\t`ASSERT(o_ljmp);\n\n\t// o_ljmp should only ever be asserted following a valid prefetch\n\t//",
            "input .  Hence, if the prefetch",
            "input isn't valid, then o_ljmp\n\t// should be left low\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(o_ljmp))\n\t\t\t&&( (!$past(pf_valid)) || (!$past(i_ce)) )\n\t\t\t&&( !$past(o_phase) )\n\t\t\t&&(!$past(i_reset))&&(!$past(o_early_branch_stb)))\n\t\t`ASSERT(!o_ljmp);\n\n\talways @(posedge i_clk)\n\tif ((OPT_EARLY_BRANCHING)&&(f_past_valid)&&($past(o_ljmp))&&(!o_ljmp)\n\t\t\t&&(!$past(i_reset)))\n\t\t`ASSERT((o_early_branch_stb)&&(!o_valid));\n\n\talways @(posedge i_clk)\n\t\t`ASSERT((!o_early_branch_stb)||(!o_ljmp));\n\n\talways @(posedge i_clk)\n\t\t`ASSERT((!o_valid)||(!o_ljmp)||(o_phase == o_pc[1]));\n\n\talways @(posedge i_clk)\n\tif (!OPT_CIS)\n\tbegin\n\t\t`ASSERT(!o_phase);\n\tend else if (!f_insn_word[31])\n\tbegin\n\t\t`ASSERT(!o_phase);\n\tend else if (o_phase)\n\t\t`ASSERT(o_pc[1]);\n\n\talways @(*)\n\tif ((o_early_branch)&&(!o_early_branch_stb))\n\t\t`ASSERT(!o_pipe);\n\n\talways @(*)\n\tif (o_ljmp)\n\t\t`ASSERT(!o_pipe);\n\n\talways @(*)\n\t`ASSERT(o_dcdR == o_dcdA);\n\n\talways @(*)\n\tif ((o_valid)&&(o_phase))\n\tbegin\n\t\t`ASSERT(!o_illegal);\n\t\t`ASSERT(o_pc[1]);\n\t\t`ASSERT(f_insn_word[31]);\n\tend\n\n\talways @(posedge i_clk)\n\tif ($rose(o_illegal))\n\t\t`ASSERT(o_valid || $past(o_early_branch || o_ljmp));\n\n\talways @(*)\n\t\t`ASSERT(o_branch_pc[1:0] == 2'b00);\n\talways @(*)\n\t\t`ASSERT(o_pc[0] == 1'b0);\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_pf_valid))&&(i_pf_valid))\n\t\t`ASSUME((i_reset)||($stable(i_gie)));\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "wire fc_illegal, fc_wF, fc_ALU, fc_M, fc_DV, fc_FP, fc_break,\n\t\tfc_lock, fc_wR, fc_rA, fc_rB, fc_prepipe, fc_sim;",
            "wire [6:0]\tfc_dcdR, fc_dcdA, fc_dcdB;",
            "wire [31:0]\tfc_I;",
            "wire [3:0]\tfc_cond;",
            "wire [3:0]\tfc_op;",
            "wire [22:0]\tfc_sim_immv;\n\n\tf_idecode #(\n\t\t// {{{\n\t\t.OPT_MPY(OPT_MPY),\n\t\t.OPT_DIVIDE(OPT_DIVIDE),\n\t\t.OPT_FPU(OPT_FPU),\n\t\t.OPT_CIS(OPT_CIS),\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_OPIPE(OPT_OPIPE),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t.OPT_SIM(OPT_SIM)\n\t\t// }}}\n\t) formal_decoder(\n\t\t// {{{\n\t\t.i_instruction(f_insn_word), .i_phase(o_phase),\n\t\t\t.i_gie(f_insn_gie),\n\t\t.o_illegal(fc_illegal),\n\t\t.o_dcdR(fc_dcdR), .o_dcdA(fc_dcdA), .o_dcdB(fc_dcdB),\n\t\t.o_I(fc_I), .o_cond(fc_cond), .o_wF(fc_wF), .o_op(fc_op),\n\t\t.o_ALU(fc_ALU), .o_M(fc_M), .o_DV(fc_DV), .o_FP(fc_FP),\n\t\t.o_break(fc_break), .o_lock(fc_lock),\n\t\t.o_wR(fc_wR), .o_rA(fc_rA), .o_rB(fc_rB),\n\t\t.o_prepipe(fc_prepipe), .o_sim(fc_sim), .o_sim_immv(fc_sim_immv)\n\t\t// }}}\n\t);\n\n\talways @(posedge i_clk)\n\tif (o_valid && fc_illegal)\n\t\tassert(o_illegal);\n\n\talways @(posedge i_clk)\n\tif (o_valid && !o_illegal)\n\tbegin\n\t\tif (i_reset)\n\t\tbegin\n\t\t\t`ASSERT(fc_dcdR[3:0]== o_dcdR[3:0]);\t//\n\t\t\t`ASSERT(fc_dcdA[3:0]== o_dcdA[3:0]);\t//\n\t\t\t`ASSERT(fc_dcdB[3:0]== o_dcdB[3:0]);\t//\n\t\tend else begin\n\t\t\t`ASSERT(fc_dcdR== o_dcdR);\t//\n\t\t\t`ASSERT(fc_dcdA== o_dcdA);\t//\n\t\t\t`ASSERT(fc_dcdB== o_dcdB);\t//\n\t\tend\n\t\t`ASSERT(fc_I   == o_I);\n\t\t`ASSERT(o_zI == (fc_I  == 0));\n\t\t`ASSERT(fc_cond== o_cond);\n\t\t`ASSERT(fc_wF  == o_wF);\n\t\t`ASSERT(fc_op  == o_op);\n\t\t`ASSERT(fc_ALU == o_ALU);\n\t\t`ASSERT(fc_M   == o_M);\n\t\t`ASSERT(fc_DV  == o_DV);\n\t\t`ASSERT(fc_FP  == o_FP);\n\t\t`ASSERT(fc_break== o_break);\n\t\t`ASSERT(fc_lock == o_lock);\n\t\t`ASSERT(fc_wR  == o_wR);\n\t\t`ASSERT(fc_rA  == o_rA);\n\t\t`ASSERT(fc_rB  == o_rB);\n\t\t`ASSERT(fc_sim  == o_sim);\n\t\t`ASSERT(fc_sim_immv  == o_sim_immv);\n\t\t`ASSERT(fc_prepipe == insn_is_pipeable);\n\tend else\n\t\t`ASSERT((i_reset)||(!insn_is_pipeable));\n\n\talways @(*)\n\tif (o_phase)\n\t\t`ASSERT(r_nxt_half[14:0] == f_insn_word[14:0]);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&(!i_reset)\n\t\t&&($past(i_ce))&&(o_valid))\n\tbegin\n\t\t`ASSERT(((fc_illegal)\n\t\t\t||$past((i_illegal)&&(!o_phase))\n\t\t\t||$past((o_illegal)&&( o_phase)))== o_illegal);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((!o_valid)||(o_illegal))\n\t\t`ASSERT(!insn_is_pipeable);\n\n\tgenerate if ((OPT_CIS)&&(OPT_EARLY_BRANCHING))\n\tbegin\n\n\t\talways @(*)\n\t\tif ((o_valid)\n\t\t\t\t// LW\n\t\t\t\t&&(o_M)&&(o_op[2:0]==3'b010)\n\t\t\t\t// Zero immediate\n\t\t\t\t&&(o_zI)\n\t\t\t\t// Unconditional\n\t\t\t\t&&(o_cond[3])\n\t\t\t\t// From PC to PC\n\t\t\t\t&&(o_dcdR[5])&&(o_dcdB[5]))\n\t\tbegin\n\t\t\t`ASSERT((o_ljmp)\n\t\t\t\t||((f_insn_word[31])&&(o_phase || o_illegal)));\n\t\tend else if (o_valid)\n\t\t\t`ASSERT(!o_ljmp);\n\n\tend endgenerate\n\t// }}}\n`endif // FORMAL\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "mpyop.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/mpyop.v",
        "chunks": [
            "module mpyop #(\n\t\t// {{{\n\t\t// The following",
            "parameter selects which multiply algorithm we\n\t\t// use.  Timing performance is strictly dependent upon it.\n\t\t//\tOPY_MPY\n\t\t//\t------\n\t\t//\t   0\tNo multiply\n\t\t//\t   1\tSingle op multiply, same timing as an ADD\n\t\t//\t   2\tTwo clock multiply\n\t\t//\t   3\tThree clock multiply, standard Xlnx DSP timing\n\t\t//\t   4\tThree clock multiply, Xilinx Spartan DSP timing\n\t\t//\t(Anything else)\t-- low",
            "logic slow multiply\n\t\t//\t  36\tRequired setting for the TB to work on the low\n\t\t//",
            "logic slow multiply",
            "parameter OPT_MPY = 1,",
            "parameter [0:0]\tOPT_LOWPOWER  = 1'b0\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset, i_stb,\n\t\t//\n\t\t// Three types of multiply operations.\n\t\t// 2'b00: 32x32 multiply, returning the low order 32 bits\n\t\t// 2'b10: 32x32 unsigned multiply, returning upper 32 bits\n\t\t// 2'b11: 32x32   signed multiply, returning upper 32 bits",
            "input ",
            "wire [1:0]\ti_op,",
            "input ",
            "wire [31:0]\ti_a, i_b,",
            "output ",
            "wire o_valid, // True if the result is valid",
            "output ",
            "wire o_busy,\t//",
            "output ",
            "wire [63:0]\to_result, // multiply result",
            "output ",
            "wire o_hi\t// Return the high half of mpy\n\t\t// }}}\n\t);\n\n\n\t// A 4-way multiplexer can be done in one 6-LUT.\n\t// A 16-way multiplexer can therefore be done in 4x 6-LUT's with\n\t//\tthe Xilinx multiplexer fabric that follows.\n\t// Given that we wish to apply this multiplexer approach to 33-bits,\n\t// this will cost a minimum of 132 6-LUTs.\n\n// i_stb instead of this_is_a_multiply_op\n// o_result\n// o_busy\n// o_done\n\tgenerate\n\tif (OPT_MPY == 0)\n\tbegin : MPYNONE // No multiply support.\n\t\t// {{{\n\t\tassign\to_result   = 64'h00;\n\t\tassign\to_busy     = 1'b0;\n\t\tassign\to_valid    = i_stb;\n\t\tassign\to_hi = 1'b0; // Not needed\n\n`ifdef\tVERILATOR\n\t\t// verilator coverage_off\n\t\t// verilator lint_off UNUSED",
            "wire mpy_unused;\n\t\tassign\tmpy_unused = &{ 1'b0, i_clk, i_reset, i_stb, i_op, i_a, i_b };\n\t\t// verilator lint_on  UNUSED\n\t\t// verilator coverage_on\n`endif\n\t\t// }}}\n\tend else begin : IMPY\n\tif (OPT_MPY == 1)\n\tbegin : MPY1CK // Our single clock option (no extra clocks)\n\t\t// {{{",
            "wire signed\t[63:0]\tw_mpy_a_",
            "input , w_mpy_b_",
            "input ;\n\n\t\tassign\tw_mpy_a_",
            "input = {{(32){(i_a[31])&(i_op[0])}},i_a[31:0]};\n\t\tassign\tw_mpy_b_",
            "input = {{(32){(i_b[31])&(i_op[0])}},i_b[31:0]};\n\n\t\tassign\to_result = (OPT_LOWPOWER && !i_stb) ? 0 : (w_mpy_a_",
            "input * w_mpy_b_",
            "input );\n\n\t\tassign\to_busy  = 1'b0;\n\t\tassign\to_valid = i_stb;\n\t\tassign\to_hi = i_op[1];\n\n`ifdef\tVERILATOR\n\t\t// verilator coverage_off\n\t\t// verilator lint_off UNUSED",
            "wire mpy_unused;\n\t\tassign\tmpy_unused = &{ 1'b0, i_clk, i_reset, i_stb, i_op[1] };\n\t\t// verilator lint_on  UNUSED\n\t\t// verilator coverage_on\n`endif\n\t\t// }}}\n\tend else begin: MPN1\n\tif (OPT_MPY == 2)\n\tbegin : MPY2CK // Our two clock option (ALU must pause for 1 clock)\n\t\t// {{{\n\n\t\t// Declarations\n\t\t// {{{",
            "reg signed\t[63:0]\tr_mpy_a_",
            "input , r_mpy_b_",
            "input ;",
            "reg mpypipe, r_hi;\n\t\t// }}}\n\n\t\t// r_mpy_?_",
            "input : Register the",
            "input s\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (!OPT_LOWPOWER || i_stb)\n\t\tbegin\n\t\t\tr_mpy_a_",
            "input <={{(32){(i_a[31])&(i_op[0])}},i_a[31:0]};\n\t\t\tr_mpy_b_",
            "input <={{(32){(i_b[31])&(i_op[0])}},i_b[31:0]};\n\t\tend else begin\n\t\t\tr_mpy_a_",
            "input <= 0;\n\t\t\tr_mpy_b_",
            "input <= 0;\n\t\tend\n\t\t// }}}\n\n\t\tassign\to_result = r_mpy_a_",
            "input * r_mpy_b_",
            "input ;\n\t\tassign\to_busy  = 1'b0;\n\n\t\t// mpypipe\n\t\t// {{{\n\t\tinitial\tmpypipe = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tmpypipe <= 1'b0;\n\t\telse\n\t\t\tmpypipe <= (i_stb);\n\t\t// }}}\n\n\t\tassign\to_valid = mpypipe; // this_is_a_multiply_op;\n\n\t\t// o_hi\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (i_stb)\n\t\t\tr_hi  <= i_op[1];\n\n\t\tassign\to_hi = r_hi;\n\t\t// }}}\n\t\t// }}}\n\tend else begin : MPN2\n\tif (OPT_MPY == 3)\n\tbegin : MPY3CK // Our three clock option (ALU pauses for 2 clocks)\n\t\t// {{{\n\n\t\t// Declarations\n\t\t// {{{",
            "reg signed\t[63:0]\tr_smpy_result;",
            "reg [63:0]\tr_umpy_result;",
            "reg signed\t[31:0]\tr_mpy_a_",
            "input , r_mpy_b_",
            "input ;",
            "reg [1:0]\tmpypipe;",
            "reg [1:0]\tr_sgn;",
            "reg r_hi;\n\t\t// }}}\n\n\t\t// mpypipe (FSM state)\n\t\t// {{{\n\t\tinitial\tmpypipe = 2'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tmpypipe <= 2'b0;\n\t\telse\n\t\t\tmpypipe <= { mpypipe[0], i_stb };\n\t\t// }}}\n\n\t\t// First clock :",
            "reg ister r_mpy_?_",
            "input , r_sgn\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\t\tr_sgn <= { r_sgn[0],\n\t\t\t\t(i_op[0] && (!OPT_LOWPOWER || i_stb)) };\n\n\t\talways @(posedge i_clk)\n\t\tif (!OPT_LOWPOWER || i_stb)\n\t\tbegin\n\t\t\tr_mpy_a_",
            "input <= i_a[31:0];\n\t\t\tr_mpy_b_",
            "input <= i_b[31:0];\n\t\tend else begin\n\t\t\tr_mpy_a_",
            "input <= 0;\n\t\t\tr_mpy_b_",
            "input <= 0;\n\t\tend\n\t\t// }}}\n\n\t\t// Second clock : perform the multiply\n\t\t// {{{\n`ifdef\tVERILATOR\n\t\t// Veri1ator only implementation\n\t\t// {{{",
            "wire signed\t[63:0]\ts_mpy_a_",
            "input , s_mpy_b_",
            "input ;",
            "wire [63:0]\tu_mpy_a_",
            "input , u_mpy_b_",
            "input ;\n\n\t\tassign\ts_mpy_a_",
            "input = {{(32){r_mpy_a_",
            "input [31]}},r_mpy_a_",
            "input };\n\t\tassign\ts_mpy_b_",
            "input = {{(32){r_mpy_b_",
            "input [31]}},r_mpy_b_",
            "input };\n\t\tassign\tu_mpy_a_",
            "input = {32'h00,r_mpy_a_",
            "input };\n\t\tassign\tu_mpy_b_",
            "input = {32'h00,r_mpy_b_",
            "input };\n\t\talways @(posedge i_clk)\n\t\tif (!OPT_LOWPOWER || mpypipe[0])\n\t\t\tr_smpy_result <= s_mpy_a_",
            "input * s_mpy_b_",
            "input ;\n\t\talways @(posedge i_clk)\n\t\tif (!OPT_LOWPOWER || mpypipe[0])\n\t\t\tr_umpy_result <= u_mpy_a_",
            "input * u_mpy_b_",
            "input ;\n\t\t// }}}\n`else\n\t\t// Synthesis implementation\n\t\t// {{{",
            "wire [31:0]\tu_mpy_a_",
            "input , u_mpy_b_",
            "input ;\n\n\t\tassign\tu_mpy_a_",
            "input = r_mpy_a_",
            "input ;\n\t\tassign\tu_mpy_b_",
            "input = r_mpy_b_",
            "input ;\n\n\t\talways @(posedge i_clk)\n\t\tif (!OPT_LOWPOWER || mpypipe[0])\n\t\t\tr_smpy_result <= r_mpy_a_",
            "input * r_mpy_b_",
            "input ;\n\t\talways @(posedge i_clk)\n\t\tif (!OPT_LOWPOWER || mpypipe[0])\n\t\t\tr_umpy_result <= u_mpy_a_",
            "input * u_mpy_b_",
            "input ;\n\t\t// }}}\n`endif\n\n\t\talways @(posedge i_clk)\n\t\tif (i_stb)\n\t\t\tr_hi  <= i_op[1];\n\n\t\tassign\to_hi    = r_hi;\n\t\tassign\to_busy  = mpypipe[0];\n\t\tassign\to_result = (r_sgn[1])?r_smpy_result:r_umpy_result;\n\t\tassign\to_valid = mpypipe[1];\n\t\t// }}}\n\n\t\t// Results are then available and",
            "reg istered on the third clock\n\t\t// }}}\n\tend else begin : MPN3\n\tif (OPT_MPY == 4)\n\tbegin : MPY4CK // The four clock option, polynomial multiplication\n\t\t// {{{\n\t\t// Declarations\n\t\t// {{{",
            "reg [63:0]\tr_mpy_result;",
            "reg [31:0]\tr_mpy_a_",
            "input , r_mpy_b_",
            "input ;",
            "reg r_mpy_signed, r_hi;",
            "reg [2:0]\tmpypipe;",
            "reg [31:0]\tpp_f, pp_l; // F and L from FOIL",
            "reg [32:0]\tpp_oi; // The O and I from FOIL",
            "reg [32:0]\tpp_s;\n\t\t// }}}\n\n\t\t// First clock, latch in the",
            "input s : mpypipe, r_mpy_?_",
            "input // {{{\n\t\tinitial\tmpypipe = 3'b0;\n\t\talways @(posedge i_clk)\n\t\tbegin\n\t\t\t// mpypipe indicates we have a multiply in the\n\t\t\t// pipeline.  In this case, the multiply\n\t\t\t// pipeline is a two stage pipeline, so we need\n\t\t\t// two bits in the pipe.\n\t\t\tif (i_reset)\n\t\t\t\tmpypipe <= 3'h0;\n\t\t\telse begin\n\t\t\t\tmpypipe[0] <= i_stb;\n\t\t\t\tmpypipe[1] <= mpypipe[0];\n\t\t\t\tmpypipe[2] <= mpypipe[1];\n\t\t\tend\n\n\t\t\tif (i_op[0]) // i.e. if signed multiply\n\t\t\tbegin\n\t\t\t\tr_mpy_a_",
            "input <= {(~i_a[31]),i_a[30:0]};\n\t\t\t\tr_mpy_b_",
            "input <= {(~i_b[31]),i_b[30:0]};\n\t\t\tend else begin\n\t\t\t\tr_mpy_a_",
            "input <= i_a[31:0];\n\t\t\t\tr_mpy_b_",
            "input <= i_b[31:0];\n\t\t\tend\n\t\t\t// The signed bit really only matters in the\n\t\t\t// case of 64 bit multiply.  We'll keep track\n\t\t\t// of it, though, and pretend in all other\n\t\t\t// cases.\n\t\t\tr_mpy_signed  <= i_op[0];\n\n\t\t\tif (i_stb)\n\t\t\t\tr_hi  <= i_op[1];\n\t\t\telse if (OPT_LOWPOWER)\n\t\t\tbegin\n\t\t\t\tr_mpy_a_",
            "input <= 0;\n\t\t\t\tr_mpy_b_",
            "input <= 0;\n\t\t\t\tr_mpy_signed  <= 0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\tassign\to_hi    = r_hi;\n\t\tassign\to_busy  = |mpypipe[1:0];\n\t\tassign\to_valid = mpypipe[2];\n\n\t\t// Second clock, do the multiplies, get the \"partial products\".\n\t\t// {{{\n\t\t// Here, we break our",
            "input up into two halves,\n\t\t//\n\t\t//   A  = (2^16 ah + al)\n\t\t//   B  = (2^16 bh + bl)\n\t\t//\n\t\t// and use these to compute partial products.\n\t\t//\n\t\t//   AB = (2^32 ah*bh + 2^16 (ah*bl + al*bh) + (al*bl)\n\t\t//\n\t\t// Since we're following the FOIL algorithm to get here,\n\t\t// we'll name these partial products according to FOIL.\n\t\t//\n\t\t// The trick is what happens if A or B is signed.  In\n\t\t// those cases, the real value of A will not be given by\n\t\t//\tA = (2^16 ah + al)\n\t\t// but rather\n\t\t//\tA = (2^16 ah[31^] + al) - 2^31\n\t\t//  (where we have flipped the sign bit of A)\n\t\t// and so ...\n\t\t//\n\t\t// AB= (2^16 ah + al - 2^31) * (2^16 bh + bl - 2^31)\n\t\t//\t= 2^32(ah*bh)\n\t\t//\t\t+2^16 (ah*bl+al*bh)\n\t\t//\t\t+(al*bl)\n\t\t//\t\t- 2^31 (2^16 bh+bl + 2^16 ah+al)\n\t\t//\t\t- 2^62\n\t\t//\t= 2^32(ah*bh)\n\t\t//\t\t+2^16 (ah*bl+al*bh)\n\t\t//\t\t+(al*bl)\n\t\t//\t\t- 2^31 (2^16 bh+bl + 2^16 ah+al + 2^31)\n\t\t//\n\t\talways @(posedge i_clk)\n\t\tif (!OPT_LOWPOWER || mpypipe[0])\n\t\tbegin\n\t\t\tpp_f<=r_mpy_a_",
            "input [31:16]*r_mpy_b_",
            "input [31:16];\n\t\t\tpp_oi<=r_mpy_a_",
            "input [31:16]*r_mpy_b_",
            "input [15: 0]\n\t\t\t\t+ r_mpy_a_",
            "input [15: 0]*r_mpy_b_",
            "input [31:16];\n\t\t\tpp_l<=r_mpy_a_",
            "input [15: 0]*r_mpy_b_",
            "input [15: 0];\n\t\t\t\n\t\t\tpp_s <= 32'h8000_0000-(\n\t\t\t\t  \tr_mpy_a_",
            "input [31:0]\n\t\t\t\t\t+ r_mpy_b_",
            "input [31:0]);\t\t\t\n\t\tend\n\t\t// }}}\n\n\t\t// Third clock, add the results and get a product: r_mpy_result\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (!OPT_LOWPOWER || mpypipe[1])\n\t\tbegin\n\t\t\tr_mpy_result[15:0] <= pp_l[15:0];\n\t\t\tr_mpy_result[63:16] <=\n\t\t\t  \t{ 32'h00, pp_l[31:16] }\n\t\t\t\t+ { 15'h00, pp_oi }\n\t\t\t\t+ { pp_s, 15'h00 }\n\t\t\t\t+ { pp_f, 16'h00 };\n\t\tend\n\t\t// }}}\n\n\t\tassign\to_result = r_mpy_result;\n\t\t// Fourth clock -- results are clocked into writeback\n\t\t// }}}\n\tend else begin : MPYSLOW\n\t\t// {{{\n\t\t// Use an external multiply implementation, for when DSPs aren't\n\t\t// available.\n\t\t//\n\n\t\t// Declarations\n\t\t// {{{",
            "reg r_hi;\n\t\t// verilator coverage_off\n\t\t// verilator lint_off UNUSED",
            "wire unused_aux;",
            "wire [65:0]\tfull_result;\n\t\t// verilator lint_on  UNUSED\n\t\t// verilator coverage_on\n\t\t// }}}\n\n\t\tslowmpy #(.LGNA(6), .NA(33)\n\t\t) slowmpyi(\n\t\t\ti_clk, i_reset, i_stb,\n\t\t\t{ (i_op[0])&(i_a[31]), i_a },\n\t\t\t{ (i_op[0])&(i_b[31]), i_b }, 1'b0, o_busy,\n\t\t\t\to_valid, full_result, unused_aux\n\t\t);\n\n\t\tassign\to_result = full_result[63:0];\n\n\t\talways @(posedge i_clk)\n\t\tif (i_stb)\n\t\t\tr_hi  <= i_op[1];\n\n\t\tassign\to_hi = r_hi;\n\t\t// }}}\n\tend end end end end\n\tendgenerate // All possible multiply results have been determined",
            "endmodule "
        ]
    },
    {
        "file_name": "pipemem.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/pipemem.v",
        "chunks": [
            "module pipemem #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=28,",
            "parameter BUS_WIDTH=32,",
            "parameter [0:0]\tOPT_LOCK=1'b1,\n\t\t\t\tWITH_LOCAL_BUS=1'b1,\n\t\t\t\tOPT_ZERO_ON_IDLE=1'b0,\n\t\t\t\t// OPT_ALIGNMENT_ERR\n\t\t\t\tOPT_ALIGNMENT_ERR=1'b0,",
            "localparam AW=ADDRESS_WIDTH,\n\t\t\t\tFLN=4,",
            "parameter [(FLN-1):0]\tOPT_MAXDEPTH=4'hd\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// CPU interface\n\t\t// {{{",
            "input ",
            "wire i_pipe_stb, i_lock,",
            "input ",
            "wire [2:0]\ti_op,",
            "input ",
            "wire [31:0]\ti_addr,",
            "input ",
            "wire [31:0]\ti_data,",
            "input ",
            "wire [4:0]\ti_o",
            "reg ,\n\t\t// CPU",
            "output s",
            "output ",
            "wire o_busy, o_rdbusy,",
            "output ",
            "wire o_pipe_stalled,",
            "output ",
            "reg o_valid,",
            "output ",
            "reg o_err,",
            "output ",
            "reg [4:0]\to_w",
            "reg ,",
            "output ",
            "reg [31:0]\to_result,\n\t\t// }}}\n\t\t// Wishbone",
            "output s\n\t\t// {{{",
            "output ",
            "wire o_wb_cyc_gbl,",
            "output ",
            "wire o_wb_cyc_lcl,",
            "output ",
            "reg o_wb_stb_gbl,",
            "output ",
            "reg o_wb_stb_lcl, o_wb_we,",
            "output ",
            "reg [(AW-1):0]\to_wb_addr,",
            "output ",
            "reg [BUS_WIDTH-1:0]\to_wb_data,",
            "output ",
            "reg [BUS_WIDTH/8-1:0]\to_wb_sel,\n\t\t// Wishbone",
            "input s",
            "input ",
            "wire i_wb_stall, i_wb_ack, i_wb_err,",
            "input ",
            "wire [BUS_WIDTH-1:0]\ti_wb_data\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam WBLSB = $clog2(BUS_WIDTH/8);\n\t// Verilator lint_off UNUSED",
            "localparam F_LGDEPTH=FLN+1;\n\t// Verilator lint_on  UNUSED\n`ifdef\tFORMAL",
            "wire [(F_LGDEPTH-1):0]\tf_nreqs, f_nacks, f_outstanding;",
            "reg f_pc;\n`endif",
            "reg cyc, r_wb_cyc_gbl, r_wb_cyc_lcl,\n\t\t\t\t\tfifo_full;",
            "wire gbl_stb, lcl_stb, lcl_bus;",
            "reg [(FLN-1):0]\t\trdaddr, wraddr;",
            "wire [(FLN-1):0]\t\tnxt_rdaddr, fifo_fill;",
            "reg [4+2+WBLSB-1:0]\tfifo_mem [0:15];",
            "reg fifo_gie;",
            "wire [4+2+WBLSB-1:0]\tw_w",
            "reg ;",
            "wire misaligned;",
            "reg [BUS_WIDTH/8-1:0]\toword_sel;",
            "wire [BUS_WIDTH/8-1:0]\tpre_wb_sel;",
            "reg [31:0]\t\t\toword_data;",
            "wire [BUS_WIDTH-1:0]\t\tpre_wb_data, pre_result;\n\t// }}}\n\n\t// misaligned\n\t// {{{\n\tgenerate if (OPT_ALIGNMENT_ERR)\n\tbegin : GEN_ALIGNMENT_ERR",
            "reg r_mis;\n\n\t\talways\t@(*)\n\t\tcasez({ i_op[2:1], i_addr[1:0] })\n\t\t4'b01?1: r_mis = i_pipe_stb;\n\t\t4'b0110: r_mis = i_pipe_stb;\n\t\t4'b10?1: r_mis = i_pipe_stb;\n\t\tdefault: r_mis = i_pipe_stb;\n\t\tendcase\n\n\t\tassign\tmisaligned = r_mis;\n\n\tend else begin : NO_MISALIGNMENT_ERRS\n\n\t\tassign\tmisaligned = 1'b0;\n\n\tend endgenerate\n\t// }}}\n\n\t// fifo_mem\n\t// {{{\n\talways @(posedge i_clk)\n\t\tfifo_mem[wraddr] <= { i_o",
            "reg [3:0], i_op[2:1], i_addr[WBLSB-1:0] };\n\t// }}}\n\n\t// fifo_gie\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_pipe_stb)\n\t\tfifo_gie <= i_o",
            "reg [4];\n\t// }}}\n\n\t// wraddr\n\t// {{{\n\tinitial\twraddr = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\twraddr <= 0;\n\telse if (((i_wb_err)&&(cyc))||((i_pipe_stb)&&(misaligned)))\n\t\t\twraddr <= 0;\n\telse if (i_pipe_stb)\n\t\twraddr <= wraddr + 1'b1;\n\t// }}}\n\n\t// rdaddr\n\t// {{{\n\tinitial\trdaddr = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\trdaddr <= 0;\n\telse if (((i_wb_err)&&(cyc))||((i_pipe_stb)&&(misaligned)))\n\t\trdaddr <= 0;\n\telse if ((i_wb_ack)&&(cyc))\n\t\trdaddr <= rdaddr + 1'b1;\n\t// }}}\n\n\tassign\tfifo_fill = wraddr - rdaddr;\n\n\t// fifo_full\n\t// {{{\n\tinitial\tfifo_full = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || !cyc)\n\t\tfifo_full <= 0;\n\telse if (((i_wb_err)&&(cyc))||((i_pipe_stb)&&(misaligned)))\n\t\tfifo_full <= 0;\n\telse case({ i_pipe_stb, i_wb_ack })\n\t2'b10: fifo_full <= (fifo_fill >= OPT_MAXDEPTH-1);\n\t2'b01: fifo_full <= 1'b0;\n\tdefault: begin end\n\tendcase\n`ifdef\tFORMAL\n\talways @(*)\n\tif (!cyc)\n\tbegin\n\t\tassert(fifo_full == 0);\n\tend else\n\t\tassert(fifo_full == (fifo_fill >= OPT_MAXDEPTH));\n\n\talways @(*)\n\tif (fifo_full)\n\t\tassert(fifo_fill == OPT_MAXDEPTH);\n`endif\n\t// }}}\n\n\tassign\tnxt_rdaddr = rdaddr + 1'b1;\n\n\t// lcl_bus, lcl_stb, gbl_stb\n\t// {{{\n\tassign\tlcl_bus = (i_addr[31:24]==8'hff)&&(WITH_LOCAL_BUS);\n\tassign\tlcl_stb = (lcl_bus)&&(!misaligned);\n\tassign\tgbl_stb = ((!lcl_bus)||(!WITH_LOCAL_BUS))&&(!misaligned);\n\t\t\t//= ((i_addr[31:8]!=24'hc00000)||(i_addr[7:5]!=3'h0));\n\t// }}}\n\n\t// cyc, [or]_wb_[cyc|stb]_[lcl|gbl]\n\t// {{{\n\tinitial\tcyc = 0;\n\tinitial\tr_wb_cyc_lcl = 0;\n\tinitial\tr_wb_cyc_gbl = 0;\n\tinitial\to_wb_stb_lcl = 0;\n\tinitial\to_wb_stb_gbl = 0;\n\talways @(posedge i_clk)\n\tbegin\n\t\tif (cyc)\n\t\tbegin\n\t\t\tif (((!i_wb_stall)&&(!i_pipe_stb)&&(!misaligned))\n\t\t\t\t||(i_wb_err))\n\t\t\tbegin\n\t\t\t\to_wb_stb_gbl <= 1'b0;\n\t\t\t\to_wb_stb_lcl <= 1'b0;\n\t\t\tend\n\n\t\t\tif (((i_wb_ack)&&(nxt_rdaddr == wraddr)\n\t\t\t\t\t&&((!i_pipe_stb)||(misaligned)))\n\t\t\t\t||(i_wb_err))\n\t\t\tbegin\n\t\t\t\tr_wb_cyc_gbl <= 1'b0;\n\t\t\t\tr_wb_cyc_lcl <= 1'b0;\n\t\t\t\to_wb_stb_gbl <= 1'b0;\n\t\t\t\to_wb_stb_lcl <= 1'b0;\n\t\t\t\tcyc <= 1'b0;\n\t\t\tend\n\t\tend else if (i_pipe_stb) // New memory operation\n\t\tbegin // Grab the wishbone\n\t\t\tr_wb_cyc_lcl <= lcl_stb;\n\t\t\tr_wb_cyc_gbl <= gbl_stb;\n\t\t\to_wb_stb_lcl <= lcl_stb;\n\t\t\to_wb_stb_gbl <= gbl_stb;\n\t\t\tcyc <= (!misaligned);\n\t\tend\n\n\t\tif (i_reset)\n\t\tbegin\n\t\t\tr_wb_cyc_gbl <= 1'b0;\n\t\t\tr_wb_cyc_lcl <= 1'b0;\n\t\t\to_wb_stb_gbl <= 1'b0;\n\t\t\to_wb_stb_lcl <= 1'b0;\n\t\t\tcyc <= 1'b0;\n\t\tend\n\n\t\tif (!WITH_LOCAL_BUS)\n\t\tbegin\n\t\t\tr_wb_cyc_lcl <= 1'b0;\n\t\t\to_wb_stb_lcl <= 1'b0;\n\t\tend\n\tend\n\t// }}}\n\n\t// pre_wb_sel\n\t// {{{\n\talways @(*)\n\tbegin\n\t\toword_sel = 0;\n\t\tcasez({ i_op[2:1], i_addr[1:0] })\n\t\t4'b100?: oword_sel[3:0] = 4'b1100;\t// Op = 5\n\t\t4'b101?: oword_sel[3:0] = 4'b0011;\t// Op = 5\n\t\t4'b1100: oword_sel[3:0] = 4'b1000;\t// Op = 5\n\t\t4'b1101: oword_sel[3:0] = 4'b0100;\t// Op = 7\n\t\t4'b1110: oword_sel[3:0] = 4'b0010;\t// Op = 7\n\t\t4'b1111: oword_sel[3:0] = 4'b0001;\t// Op = 7\n\t\tdefault: oword_sel[3:0] = 4'b1111;\t// Op = 7\n\t\tendcase\n\tend\n\n\tgenerate if (BUS_WIDTH == 32)\n\tbegin : GEN_SEL32\n\n\t\tassign\tpre_wb_sel = oword_sel;\n\n\tend else begin : GEN_WIDESEL32\n\n\t\t// If we were little endian, we'd do ...\n\t\t// assign\tpre_wb_sel = (oword_sel << (4* i_addr[WBLSB-1:2]));\n\t\tassign\tpre_wb_sel = {oword_sel[3:0], {(BUS_WIDTH/8-4){1'b0}} }\n\t\t\t\t>> (4* i_addr[WBLSB-1:2]);\n\n\tend endgenerate\n\t// }}}\n\n\t// pre_wb_data\n\t// {{{\n\n\talways @(*)\n\tcasez({ i_op[2:1], i_addr[1:0] })\n\t4'b100?: oword_data = { i_data[15:0], 16'h00 };\n\t4'b101?: oword_data = { 16'h00, i_data[15:0] };\n\t4'b1100: oword_data = {         i_data[7:0], 24'h00 };\n\t4'b1101: oword_data = {  8'h00, i_data[7:0], 16'h00 };\n\t4'b1110: oword_data = { 16'h00, i_data[7:0],  8'h00 };\n\t4'b1111: oword_data = { 24'h00, i_data[7:0] };\n\tdefault: oword_data = i_data;\n\tendcase\n\n\tgenerate if (BUS_WIDTH == 32)\n\tbegin : GEN_DATA32\n\n\t\tassign\tpre_wb_data = oword_data;\n\n\tend else begin : GEN_WIDEDATA32\n\n\t\t// If we were little endian, we'd do ...\n\t\t// assign\tpre_wb_sel = (word_sel << (4* i_addr[WBLSB-1:2]));\n\t\tassign\tpre_wb_data = {oword_data, {(BUS_WIDTH-32){1'b0}} }\n\t\t\t\t>> (32* i_addr[WBLSB-1:2]);\n\n\tend endgenerate\n\t// }}}\n\n\t// o_wb_addr, o_wb_sel, and o_wb_data\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((!cyc)||(!i_wb_stall))\n\tbegin\n\t\t// o_wb_add\n\t\t// {{{\n\t\tif ((OPT_ZERO_ON_IDLE)&&(!i_pipe_stb))\n\t\t\to_wb_addr <= 0;\n\t\telse if (lcl_bus)\n\t\t\to_wb_addr <= i_addr[2 +: AW];\n\t\telse\n\t\t\to_wb_addr <= i_addr[WBLSB +: AW];\n\t\t// }}}\n\n\t\t// o_wb_sel\n\t\t// {{{\n\t\tif ((OPT_ZERO_ON_IDLE)&&(!i_pipe_stb))\n\t\t\to_wb_sel <= {(BUS_WIDTH/8){1'b0}};\n\t\telse if (lcl_bus)\n\t\t\to_wb_sel <= oword_sel;\n\t\telse\n\t\t\to_wb_sel <= pre_wb_sel;\n\t\t// }}}\n\n\t\t// o_wb_data\n\t\t// {{{\n\t\to_wb_data <= 0;\n\t\tif ((OPT_ZERO_ON_IDLE)&&(!i_pipe_stb))\n\t\t\to_wb_data <= 0;\n\t\telse if (lcl_bus)\n\t\t\to_wb_data[31:0] <= oword_data;\n\t\telse\n\t\t\to_wb_data <= pre_wb_data;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// o_wb_we\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((i_pipe_stb)&&(!cyc))\n\t\to_wb_we   <= i_op[0];\n\telse if ((OPT_ZERO_ON_IDLE)&&(!cyc))\n\t\to_wb_we   <= 1'b0;\n\t// }}}\n\n\t// o_valid\n\t// {{{\n\tinitial\to_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_valid <= 1'b0;\n\telse\n\t\to_valid <= (cyc)&&(i_wb_ack)&&(!o_wb_we);\n\t// }}}\n\n\t// o_err\n\t// {{{\n\tinitial\to_err = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_err <= 1'b0;\n\telse\n\t\to_err <= ((cyc)&&(i_wb_err))||((i_pipe_stb)&&(misaligned));\n\t// }}}\n\n\tassign\to_busy = cyc;\n\tassign\to_rdbusy = o_busy && !o_wb_we;\n\n\tassign\tw_w",
            "reg = fifo_mem[rdaddr];\n\n\t// o_w",
            "reg // {{{\n\talways @(posedge i_clk)\n\t\to_w",
            "reg <= { fifo_gie, w_w",
            "reg [2 + WBLSB +: 4] };\n\t// }}}\n\n\t// o_result\n\t// {{{\n\tgenerate if (BUS_WIDTH == 32)\n\tbegin : COPY_IDATA\n\n\t\tassign\tpre_result = i_wb_data;\n\n\tend else begin : GEN_PRERESULT\n\n\t\tassign\tpre_result = i_wb_data << (8*w_w",
            "reg [WBLSB-1:0]);\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_preresult;\n\t\tassign\tunused_preresult = &{1'b0, pre_result[BUS_WIDTH-33:0] };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\tend endgenerate\n\n\talways @(posedge i_clk)\n\tif ((OPT_ZERO_ON_IDLE)&&((!cyc)||((!i_wb_ack)&&(!i_wb_err))))\n\t\to_result <= 0;\n\telse if ((o_wb_cyc_lcl && WITH_LOCAL_BUS) || (BUS_WIDTH == 32))\n\tbegin\n\t\tcasez({ w_w",
            "reg [WBLSB +: 2], w_w",
            "reg [1:0] })\n\t\t4'b1100: o_result <= { 24'h00, i_wb_data[31:24] };\n\t\t4'b1101: o_result <= { 24'h00, i_wb_data[23:16] };\n\t\t4'b1110: o_result <= { 24'h00, i_wb_data[15: 8] };\n\t\t4'b1111: o_result <= { 24'h00, i_wb_data[ 7: 0] };\n\t\t4'b100?: o_result <= { 16'h00, i_wb_data[31:16] };\n\t\t4'b101?: o_result <= { 16'h00, i_wb_data[15: 0] };\n\t\tdefault: o_result <= i_wb_data[31:0];\n\t\tendcase\n\tend else begin\n\t\tcasez(w_w",
            "reg [WBLSB +: 2])\n\t\t2'b11: o_result <= { 24'h00, pre_result[BUS_WIDTH-1:BUS_WIDTH-8] };\n\t\t2'b10: o_result <= { 16'h00, pre_result[BUS_WIDTH-1:BUS_WIDTH-16] };\n\t\tdefault: o_result <= pre_result[BUS_WIDTH-1:BUS_WIDTH-32];\n\t\tendcase\n\tend\n\t// }}}\n\n\t// o_pipe_stalled\n\t// {{{\n\tassign\to_pipe_stalled = ((cyc)&&(fifo_full))||((cyc)\n\t\t\t&&((i_wb_stall)||((!o_wb_stb_lcl)&&(!o_wb_stb_gbl))));\n\t// }}}\n\n\t// lock_gbl, lock_lcl\n\t// {{{\n\tgenerate\n\tif (OPT_LOCK)\n\tbegin : LOCK_REGISTER\n\t\t// {{{",
            "reg lock_gbl, lock_lcl;\n\n\t\tinitial\tlock_gbl = 1'b0;\n\t\tinitial\tlock_lcl = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tbegin\n\t\t\tlock_gbl <= r_wb_cyc_gbl || lock_gbl;\n\t\t\tlock_lcl <= r_wb_cyc_lcl || lock_lcl;\n\n\t\t\tif (i_reset || (i_wb_err && cyc)\n\t\t\t\t|| (i_pipe_stb && misaligned)\n\t\t\t\t|| !i_lock)\n\t\t\tbegin\n\t\t\t\tlock_gbl <= 1'b0;\n\t\t\t\tlock_lcl <= 1'b0;\n\t\t\tend\n\n\t\t\tif (!WITH_LOCAL_BUS)\n\t\t\t\tlock_lcl <= 1'b0;\n\t\tend\n\n\t\tassign\to_wb_cyc_gbl = (r_wb_cyc_gbl)||(lock_gbl);\n\t\tassign\to_wb_cyc_lcl = (r_wb_cyc_lcl)||(lock_lcl);\n\t\t// }}}\n\tend else begin : NO_LOCK\n\t\t// {{{\n\t\tassign\to_wb_cyc_gbl = (r_wb_cyc_gbl);\n\t\tassign\to_wb_cyc_lcl = (r_wb_cyc_lcl);\n\n\t\t// Verilator coverage_off\n\t\t// verilator lint_off UNUSED",
            "wire unused_lock;\n\t\tassign\tunused_lock = &{ 1'b0, i_lock };\n\t\t// verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// Make verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = { 1'b0 };\n\t// verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal property section\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Declarations\n\t// {{{\n`define\tASSERT\tassert\n`ifdef\tPIPEMEM\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "wire [(F_LGDEPTH-1):0]\tfcpu_outstanding;",
            "wire f_cyc, f_stb;",
            "reg f_done;",
            "wire [3:0]\t\t\tf_pipe_used;",
            "reg [(1<<FLN)-1:0]\t\tf_mem_used;",
            "reg f_past_valid;",
            "wire f_pc_check, f_gie, f_read_cycle;",
            "wire [4:0]\t\t\tf_last_",
            "reg , f_addr_",
            "reg ;\n\t// Verilator lint_off UNDRIVEN\n\t(* anyseq *)",
            "reg [4:0]\tf_a",
            "reg ;\n\t// Verilator lint_on  UNDRIVEN\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Reset properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\tinitial\t`ASSUME( i_reset);\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(i_reset);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tassign\tf_cyc = cyc;\n\tassign\tf_stb = (o_wb_stb_gbl)||(o_wb_stb_lcl);\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.AW(AW), .DW(BUS_WIDTH), .F_LGDEPTH(F_LGDEPTH),\n\t\t// .F_MAX_REQUESTS(14), // Not quite true, can do more\n\t\t.F_OPT_RMW_BUS_OPTION(OPT_LOCK),\n\t\t.F_OPT_DISCONTINUOUS(OPT_LOCK)\n\t\t// }}}\n\t) fwb(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\tcyc, f_stb, o_wb_we, o_wb_addr, o_wb_data, o_wb_sel,\n\t\t\ti_wb_ack, i_wb_stall, i_wb_data, i_wb_err,\n\t\tf_nreqs, f_nacks, f_outstanding\n\t\t// }}}\n\t);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// CPU interface properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tinitial\tf_done = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_done <= 1'b0;\n\telse if (cyc)\n\tbegin\n\t\tf_done <= 0;\n\t\tif (i_wb_err || i_wb_ack)\n\t\t\tf_done <= 1;\n\t\tif (i_pipe_stb && misaligned)\n\t\t\tf_done <= 1;\n\tend else\n\t\tf_done <= 1'b0;\n\n\tfmem #(\n\t\t// {{{\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t.OPT_MAXDEPTH(OPT_MAXDEPTH)\n\t\t// }}}\n\t) iface(\n\t\t// {{{\n\t\t.i_clk(i_clk),\n\t\t.i_sys_reset(i_reset),\n\t\t.i_cpu_reset(i_reset),\n\t\t.i_stb(i_pipe_stb),\n\t\t.i_pipe_stalled(o_pipe_stalled),\n\t\t.i_clear_cache(1'b0),\n\t\t.i_lock(i_lock),\n\t\t.i_op(i_op), .i_addr(i_addr), .i_data(i_data), .i_o",
            "reg (i_o",
            "reg ),\n\t\t.i_a",
            "reg (f_a",
            "reg ),\n\t\t.i_busy(o_busy), .i_rdbusy(o_busy && !o_wb_we),\n\t\t.i_valid(o_valid), .i_done(f_done),\n\t\t\t.i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_result),\n\t\t\t.f_outstanding(fcpu_outstanding),\n\t\t\t.f_pc(f_pc_check), .f_gie(f_gie),\n\t\t\t.f_read_cycle(f_read_cycle),\n\t\t\t.f_last_",
            "reg (f_last_",
            "reg ), .f_addr_",
            "reg (f_addr_",
            "reg )\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (!o_err || !OPT_ALIGNMENT_ERR)\n\t\tassert(f_pc == f_pc_check);\n\n\talways @(*)\n\tif (o_busy)\n\t\tassert(f_gie == fifo_gie);\n\n\talways @(*)\n\tif (cyc)\n\t\tassert(f_read_cycle == !o_wb_we);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Other (induction) properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Assumptions about",
            "input s\n\t//\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\t\t`ASSERT(!o_pipe_stalled);\n\n\t// Assume we won't cross from GBL to LCL in a given string\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((r_wb_cyc_gbl)&&(i_pipe_stb))\n\t\t`ASSUME(gbl_stb);\n\n\talways @(posedge i_clk)\n\tif ((r_wb_cyc_lcl)&&(i_pipe_stb))\n\t\t`ASSUME(lcl_stb);\n\t// }}}\n\n\tassign\tf_pipe_used = wraddr - rdaddr;\n\n\talways @(*)\n\t\t`ASSERT(f_pipe_used == fifo_fill);\n\n\talways @(*)\n\tif (!o_err)\n\t\t`ASSERT(f_pipe_used + (f_done ? 1:0) == fcpu_outstanding);\n\n\talways @(posedge i_clk)\n\tif (f_pipe_used == OPT_MAXDEPTH)\n\tbegin\n\t\t// `ASSUME(!i_pipe_stb);\n\t\t`ASSERT((o_busy)&&(o_pipe_stalled));\n\tend\n\n\talways @(*)\n\t\t`ASSERT(fifo_fill <= OPT_MAXDEPTH);\n\n`ifndef\tVERILATOR\n\talways @(*)\n\tif ((WITH_LOCAL_BUS)&&(o_wb_cyc_gbl|o_wb_cyc_lcl)\n\t\t&&(i_pipe_stb))\n\tbegin\n\t\tif (o_wb_cyc_lcl)\n\t\tbegin\n\t\t\t// `ASSUME(i_addr[31:24] == 8'hff);\n\t\t\tassume(i_addr[31:24] == 8'hff);\n\t\tend else\n\t\t\tassume(i_addr[31:24] != 8'hff);\n\tend\n`endif\n\n\talways @(*)\n\tif (!WITH_LOCAL_BUS)\n\tbegin\n\t\tassert(!r_wb_cyc_lcl);\n\t\tassert(!o_wb_cyc_lcl);\n\t\tassert(!o_wb_stb_lcl);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(f_cyc))&&(!$past(i_pipe_stb)))\n\t\t`ASSERT(f_pipe_used == 0);\n\n\talways @(*)\n\tif (!f_cyc)\n\t\t`ASSERT(f_pipe_used == 0);\n\n\talways @(posedge i_clk)\n\tif (f_pipe_used >= 13)\n\t\t`ASSUME(!i_pipe_stb);\n\n\talways @(posedge i_clk)\n\tif ((f_cyc)&&(f_pipe_used >= 13))\n\t\t`ASSERT((o_busy)&&(o_pipe_stalled));\n\n\n\talways @(posedge i_clk)\n\t\t`ASSERT((!r_wb_cyc_gbl)||(!r_wb_cyc_lcl));\n\n\talways @(posedge i_clk)\n\t\t`ASSERT((!o_wb_cyc_gbl)||(!o_wb_cyc_lcl));\n\n\talways @(posedge i_clk)\n\t\t`ASSERT((!o_wb_stb_gbl)||(!o_wb_stb_lcl));\n\n\talways @(*)\n\tif (!WITH_LOCAL_BUS)\n\tbegin\n\t\tassert(!o_wb_cyc_lcl);\n\t\tassert(!o_wb_stb_lcl);\n\t\tif (o_wb_stb_lcl)\n\t\t\tassert(o_wb_addr[(AW-1):22] == {(8-(30-AW)){1'b1}});\n\tend\n\n\talways @(posedge i_clk)\n\tif (o_wb_stb_gbl)\n\t\t`ASSERT(o_wb_cyc_gbl);\n\n\talways @(posedge i_clk)\n\tif (o_wb_stb_lcl)\n\t\t`ASSERT(o_wb_cyc_lcl);\n\n\talways @(posedge i_clk)\n\t\t`ASSERT(cyc == (r_wb_cyc_gbl|r_wb_cyc_lcl));\n\n\talways @(posedge i_clk)\n\t\t`ASSERT(cyc == (r_wb_cyc_lcl)|(r_wb_cyc_gbl));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!i_reset)&&(!$past(misaligned)))\n\tbegin\n\t\tif (f_stb)\n\t\tbegin\n\t\t\t`ASSERT(f_pipe_used == f_outstanding + 4'h1);\n\t\tend else\n\t\t\t`ASSERT(f_pipe_used == f_outstanding);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(r_wb_cyc_gbl||r_wb_cyc_lcl))\n\t\t\t&&(!$past(f_stb)))\n\t\t`ASSERT(!f_stb);\n\n\talways @(*)\n\t\t`ASSERT((!lcl_stb)||(!gbl_stb));\n\n\t//\n\t// insist that we only ever accept memory requests for the same GIE\n\t// (i.e. 4th bit of",
            "reg ister)\n\t//\n\talways @(*)\n\tif ((i_pipe_stb)&&(wraddr != rdaddr))\n\t\t`ASSUME(i_o",
            "reg [4] == fifo_gie);\n\n\tinitial\tf_pc = 1'b0;\n\talways @(posedge i_clk)\n\tif(i_reset)\n\t\tf_pc <= 1'b0;\n\telse if (i_pipe_stb && !misaligned)\n\t\tf_pc <= (((f_pc)&&(f_cyc))\n\t\t\t\t||((!i_op[0])&&(i_o",
            "reg [3:1] == 3'h7)));\n\telse if (!f_cyc)\n\t\tf_pc <= 1'b0;\n\n\talways @(posedge i_clk)\n\tif ((f_cyc)&&(o_wb_we))\n\t\t`ASSERT(!f_pc);\n\n//\talways @(*)\n//\tif ((f_pc)&&(f_cyc))\n//\t\t`ASSUME(!i_pipe_stb);\n\n\talways @(*)\n\tif (wraddr == rdaddr)\n\tbegin\n\t\t`ASSERT(!r_wb_cyc_gbl);\n\t\t`ASSERT(!r_wb_cyc_lcl);\n\tend else if (f_cyc)\n\tbegin\n\t\t`ASSERT(fifo_fill == f_outstanding + ((f_stb)?1:0));\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The FIFO check\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\n`define\tFIFOCHECK\n`ifdef\tFIFOCHECK",
            "reg [4+2+WBLSB-1:0]\tfc_mem, frd_mem;\n\t// Verilator lint_off UNDRIVEN\n\t(* anyconst *)",
            "reg [3:0]\tfc_addr;\n\t// Verilator lint_on  UNDRIVEN",
            "wire [3:0]\tlastaddr = wraddr - 1'b1;\n\n\tinteger\tk;\n\talways @(*)\n\tbegin\n\t\tf_mem_used = 0;\n\t\tfor(k = 0 ; k < (1<<FLN); k=k+1)\n\t\tbegin\n\t\t\tif (wraddr == rdaddr)\n\t\t\t\tf_mem_used[k] = 1'b0;\n\t\t\telse if (wraddr > rdaddr)\n\t\t\tbegin\n\t\t\t\tif ((k < wraddr)&&(k >= rdaddr))\n\t\t\t\t\tf_mem_used[k] = 1'b1;\n\t\t\tend else if (k < wraddr)\n\t\t\t\tf_mem_used[k] = 1'b1;\n\t\t\telse if (k >= rdaddr)\n\t\t\t\tf_mem_used[k] = 1'b1;\n\t\tend\n\tend\n\n\talways @(*)\n\t\tfc_mem = fifo_mem[fc_addr];\n\talways @(*)\n\t\tfrd_mem = fifo_mem[rdaddr];\n\n\talways @(*)\n\tif (cyc && !o_wb_we)\n\tbegin\n\t\tif (f_mem_used[rdaddr] && fc_addr != rdaddr)\n\t\tbegin\n\t\t\tassume((frd_mem[1+2+WBLSB +: 3] == 3'h7)\n\t\t\t\t== (f_pc && rdaddr == lastaddr));\n\t\t\tassume(({ fifo_gie, frd_mem[2+WBLSB +: 4] } != f_addr_",
            "reg )\n\t\t\t\t|| (rdaddr == lastaddr));\n\t\tend\n\n\t\tif (f_mem_used[fc_addr])\n\t\tbegin\n\t\t\t`ASSERT((fc_mem[1+2+WBLSB +: 3] == 3'h7)\n\t\t\t\t== (f_pc && fc_addr == lastaddr));\n\t\t\t`ASSERT(({ fifo_gie, fc_mem[2+WBLSB +: 4] } != f_addr_",
            "reg )\n\t\t\t\t|| fc_addr == lastaddr);\n\t\tend\n\tend\n\n\talways @(*)\n\tif (fifo_fill > 0)\n\t\tassert({ fifo_gie, fifo_mem[lastaddr][2+WBLSB +: 4] } == f_last_",
            "reg );\n\n\tinitial\tassert(!fifo_full);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(posedge i_clk)\n\t\tcover(cyc && !fifo_full);\n\n\talways @(posedge i_clk)\n\t\tcover((f_cyc)&&(f_stb)&&(!i_wb_stall)&&(!i_wb_ack)\n\t\t\t&&(!o_pipe_stalled));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(f_stb))&&($past(f_cyc)))\n\t\tcover((f_cyc)&&(i_wb_ack));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(f_stb))&&($past(f_cyc)))\n\t\tcover($past(i_wb_ack)&&(i_wb_ack));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_valid)))\n\t\tcover(o_valid);\n\n`endif // FIFOCHECK\n\t// }}}\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(f_past_valid))&&($past(f_cyc))&&($past(f_cyc,2)))\n\t\t`ASSERT($stable(o_w",
            "reg [4]));\n\n\talways @(*)\n\t\t`ASSERT((!f_cyc)||(!o_valid)||(o_w",
            "reg [3:1]!=3'h7));\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, f_nreqs, f_nacks };\n\t// Verilator lint_off UNUSED\n\t// }}}\n`endif // FORMAL\n// }}}",
            "endmodule //\n//\n// Usage (from yosys): (Before)\t(A,!OPTZ)\t(A,OPTZ)\n//\tCells:\t\t302\t314\t\t391\n//\t  FDRE\t\t138\t140\t\t140\n//\t  LUT1\t\t  2\t  2\t\t  2\n//\t  LUT2\t\t 38\t 41\t\t 61\n//\t  LUT3\t\t 13\t 16\t\t 33\n//\t  LUT4\t\t  3\t  8\t\t 12\n//\t  LUT5\t\t 22\t 10\t\t  8\n//\t  LUT6\t\t 52\t 59\t\t 81\n//\t  MUXCY\t\t  6\t  6\t\t  6\n//\t  MUXF7\t\t 10\t 13\t\t 21\n//\t  MUXF8\t\t  1\t  2\t\t 10\n//\t  RAM64X1D\t  9\t  9\t\t  9\n//\t  XORCY\t\t  8\t  8\t\t  8\n//\n//"
        ]
    },
    {
        "file_name": "zipwb.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/zipwb.v",
        "chunks": [
            "module holding the core of the Zip CPU\n//\t\ttogether.  The Zip CPU is designed to be as simple as possible.\n//\t(actual implementation aside ...)  The instruction set is about as\n//\tRISC as you can get, with only 26 instruction types currently supported.\n//\t(There are still 8-instruction Op-Codes reserved for floating point,\n//\tand 5 which can be used for transactions not requiring",
            "reg isters.)\n//\tPlease see the accompanying spec.pdf file for a description of these\n//\tinstructions.\n//\n//\tAll instructions are 32-bits wide.  All bus accesses, both address and\n//\tdata, are 32-bits over a wishbone bus.\n//\n//\tThe Zip CPU is fully pipelined with the following pipeline stages:\n//\n//\t\t1. Prefetch, returns the instruction from memory.\n//\n//\t\t2. Instruction Decode\n//\n//\t\t3. Read Operands\n//\n//\t\t4. Apply Instruction\n//\n//\t\t4. Write-back Results\n//\n//\tFurther information about the inner workings of this CPU, such as\n//\twhat causes pipeline stalls, may be found in the spec.pdf file.  (The\n//\tdocumentation within this file had become out of date and out of sync\n//\twith the spec.pdf, so look to the spec.pdf for accurate and up to date\n//\tinformation.)\n//\n//\n//\tIn general, the pipelining is controlled by three pieces of",
            "logic //\tper stage: _ce, _stall, and _valid.  _valid means that the stage\n//\tholds a valid instruction.  _ce means that the instruction from the\n//\tprevious stage is to move into this one, and _stall means that the\n//\tinstruction from the previous stage may not move into this one.\n//\tThe difference between these control signals allows individual stages\n//\tto propagate instructions independently.  In general, the",
            "logic works\n//\tas:\n//\n//\n//\tassign\t(n)_ce = (n-1)_valid && (!(n)_stall)\n//\n//\n//\talways @(posedge i_clk)\n//\t\tif ((i_reset)||(clear_pipeline))\n//\t\t\t(n)_valid = 0\n//\t\telse if (n)_ce\n//\t\t\t(n)_valid = 1\n//\t\telse if (n+1)_ce\n//\t\t\t(n)_valid = 0\n//\n//\tassign (n)_stall = (  (n-1)_valid && ( pipeline hazard detection )  )\n//\t\t\t|| (  (n)_valid && (n+1)_stall );\n//\n//\tand ...\n//\n//\talways @(posedge i_clk)\n//\t\tif (n)_ce\n//\t\t\t(n)_variable = ... whatever",
            "logic for this stage\n//\n//\tNote that a stage can stall even if no instruction is loaded into\n//\tit.\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module zipwb #(\n\t\t// {{{",
            "parameter [31:0] RESET_ADDRESS=32'h010_0000,",
            "parameter ADDRESS_WIDTH=30,\n\t\t\t\tBUS_WIDTH = 32,\t\t// Bus width\n\t\t\t\tOPT_LGICACHE=12,",
            "localparam DATA_WIDTH = 32,\t// CPU data width",
            "parameter OPT_MPY = 3,",
            "parameter [0:0]\tOPT_DIV = 1,",
            "parameter [0:0]\tOPT_SHIFTS = 1,",
            "parameter [0:0]\tIMPLEMENT_FPU = 0,",
            "parameter [0:0]\tOPT_EARLY_BRANCHING = 1,",
            "parameter [0:0]\tOPT_CIS = 1'b1,",
            "parameter [0:0]\tOPT_DISTRIBUTED_REGS = 1'b1,",
            "parameter [0:0]\tOPT_PIPELINED = 1'b1,",
            "parameter [0:0]\tOPT_START_HALTED=1,",
            "parameter [0:0]\tOPT_LOCK=1,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,",
            "parameter OPT_LGDCACHE = 10,",
            "parameter [0:0]\tOPT_SIM = 1'b1,",
            "parameter [0:0]\tOPT_CLKGATE = 1'b0,",
            "parameter [0:0]\tWITH_LOCAL_BUS = 1'b1,",
            "parameter [0:0]\tOPT_DBGPORT = 1'b1,",
            "parameter [0:0]\tOPT_TRACE_PORT = 1'b0,",
            "parameter [0:0]\tOPT_PROFILER = 1'b0,",
            "parameter [0:0]\tOPT_USERMODE = 1'b1,",
            "localparam AW=ADDRESS_WIDTH,",
            "localparam WBLSB = $clog2(BUS_WIDTH/8)\n`ifdef\tFORMAL\n\t\t,",
            "parameter F_LGDEPTH=8\n`endif\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset, i_interrupt,",
            "input ",
            "wire i_cpu_clken,\n\t\t// Debug interface --",
            "input s",
            "input ",
            "wire i_halt, i_clear_cache,",
            "input ",
            "wire [4:0]\t\ti_dbg_w",
            "reg ,",
            "input ",
            "wire i_dbg_we,",
            "input ",
            "wire [DATA_WIDTH-1:0]\ti_dbg_data,",
            "input ",
            "wire [4:0]\t\ti_dbg_r",
            "reg ,\n\t\t// Debug interface --",
            "output s",
            "output ",
            "wire o_dbg_stall,",
            "output ",
            "wire o_halted,",
            "output ",
            "wire [DATA_WIDTH-1:0]\to_dbg_",
            "reg ,",
            "output ",
            "wire [2:0]\t\to_dbg_cc,",
            "output ",
            "wire o_break,\n\t\t// CPU interface to the wishbone bus\n\t\t// Wishbone interface --",
            "output s",
            "output ",
            "wire o_wb_gbl_cyc, o_wb_gbl_stb,",
            "output ",
            "wire o_wb_lcl_cyc, o_wb_lcl_stb,\n\t\t\t\t\t\to_wb_we,",
            "output ",
            "wire [AW-1:0]\to_wb_addr,",
            "output ",
            "wire [BUS_WIDTH-1:0]\to_wb_data,",
            "output ",
            "wire [BUS_WIDTH/8-1:0]\to_wb_sel,\n\t\t// Wishbone interface --",
            "input s",
            "input ",
            "wire i_wb_stall, i_wb_ack,",
            "input ",
            "wire [BUS_WIDTH-1:0]\ti_wb_data,",
            "input ",
            "wire i_wb_err,\n\t\t// Accounting",
            "output s ... to help us count stalls and usage",
            "output ",
            "wire o_op_stall,",
            "output ",
            "wire o_pf_stall,",
            "output ",
            "wire o_i_count,\n\t\t//",
            "output ",
            "wire [31:0]\t\to_debug,",
            "output ",
            "wire o_prof_stb,",
            "output ",
            "wire [AW+WBLSB-1:0]\to_prof_addr,",
            "output ",
            "wire [31:0]\t\to_prof_ticks\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam [0:0]\tOPT_DCACHE = (OPT_LGDCACHE > 2);",
            "localparam [0:0]\tOPT_PIPELINED_BUS_ACCESS = (OPT_PIPELINED);",
            "localparam [0:0]\tOPT_MEMPIPE = OPT_PIPELINED_BUS_ACCESS;",
            "localparam INSN_WIDTH = 32;",
            "wire cpu_clken, cpu_clock, clk_gate;",
            "wire [31:0]\tcpu_debug;\n\n\t// Fetch\n\t// {{{",
            "wire pf_new_pc, clear_icache, pf_ready;",
            "wire [AW+WBLSB-1:0]\tpf_request_address;",
            "wire [INSN_WIDTH-1:0]\tpf_instruction;",
            "wire [AW+WBLSB-1:0]\tpf_instruction_pc;",
            "wire pf_valid, pf_illegal;\n\t//",
            "wire pf_cyc, pf_stb, pf_stall, pf_ack, pf_err;",
            "wire [AW-1:0]\t\tpf_addr;",
            "wire [BUS_WIDTH/8-1:0]\tpf_sel;\n\t// verilator coverage_off\n\t// Since we aren't writing, these values will be constants",
            "wire pf_we;",
            "wire [BUS_WIDTH-1:0]\tpf_data;\n\t// verilator coverage_on\n\t// }}}\n\t// Memory\n\t// {{{",
            "wire clear_dcache, mem_ce, bus_lock;",
            "wire [2:0]\tmem_op;",
            "wire [31:0]\tmem_cpu_addr;",
            "wire [AW+WBLSB-1:0]\tmem_lock_pc;\t// Byte address",
            "wire [DATA_WIDTH-1:0]\tmem_wdata;",
            "wire [BUS_WIDTH-1:0]\tmem_data;",
            "wire [4:0]\tmem_",
            "reg ;",
            "wire mem_busy, mem_rdbusy, mem_pipe_stalled, mem_valid,\n\t\t\tmem_bus_err;",
            "wire [4:0]\tmem_w",
            "reg ;",
            "wire [DATA_WIDTH-1:0]\tmem_result;\n\t//",
            "wire mem_stb_lcl, mem_stb_gbl, mem_cyc_lcl, mem_cyc_gbl;",
            "wire [AW-1:0]\tmem_bus_addr;",
            "wire mem_we, mem_stall, mem_ack, mem_err;",
            "wire [BUS_WIDTH/8-1:0]\tmem_sel;\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The ZipCPU Core\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "wire w_dbg_stall;\n\n\tzipcore #(\n\t\t// {{{\n\t\t.RESET_ADDRESS(RESET_ADDRESS),\n\t\t.ADDRESS_WIDTH(AW+WBLSB-$clog2(DATA_WIDTH/8)),\n\t\t.OPT_MPY(OPT_MPY),\n\t\t.OPT_DIV(OPT_DIV),\n\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t.IMPLEMENT_FPU(IMPLEMENT_FPU),\n\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t.OPT_START_HALTED(OPT_START_HALTED),\n\t\t.OPT_CIS(OPT_CIS),\n\t\t.OPT_SIM(OPT_SIM),\n\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t.OPT_PIPELINED_BUS_ACCESS(OPT_MEMPIPE),\n\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.OPT_DBGPORT(OPT_DBGPORT),\n\t\t.OPT_TRACE_PORT(OPT_TRACE_PORT),\n\t\t.OPT_PROFILER(OPT_PROFILER)\n`ifdef\tFORMAL\n\t\t, .F_LGDEPTH(F_LGDEPTH)\n`endif\n\t\t// }}}\n\t) core (\n\t\t// {{{\n\t\t.i_clk(cpu_clock), .i_reset(i_reset), .i_interrupt(i_interrupt),\n\t\t.o_clken(cpu_clken),\n\t\t// Debug interface\n\t\t// {{{\n\t\t.i_halt(i_halt), .i_clear_cache(i_clear_cache),\n\t\t\t.i_dbg_w",
            "reg (i_dbg_w",
            "reg ), .i_dbg_we(i_dbg_we),\n\t\t\t.i_dbg_data(i_dbg_data),\n\t\t\t.i_dbg_r",
            "reg (i_dbg_r",
            "reg ), .o_dbg_stall(w_dbg_stall),\n\t\t\t.o_dbg_",
            "reg (o_dbg_",
            "reg ), .o_dbg_cc(o_dbg_cc),\n\t\t\t.o_break(o_break),\n\t\t// }}}\n\t\t// Instruction fetch interface\n\t\t// {{{\n\t\t.o_pf_new_pc(pf_new_pc), .o_clear_icache(clear_icache),\n\t\t\t.o_pf_ready(pf_ready),\n\t\t\t.o_pf_request_address(pf_request_address),\n\t\t\t.i_pf_valid(pf_valid), .i_pf_illegal(pf_illegal),\n\t\t\t\t.i_pf_instruction(pf_instruction),\n\t\t\t\t.i_pf_instruction_pc(pf_instruction_pc),\n\t\t// }}}\n\t\t// Memory unit interface\n\t\t// {{{\n\t\t.o_clear_dcache(clear_dcache), .o_mem_ce(mem_ce),\n\t\t\t.o_bus_lock(bus_lock),\n\t\t\t.o_mem_op(mem_op), .o_mem_addr(mem_cpu_addr),\n\t\t\t\t.o_mem_data(mem_wdata),\n\t\t\t\t.o_mem_lock_pc(mem_lock_pc),\n\t\t\t\t.o_mem_",
            "reg (mem_",
            "reg ),\n\t\t\t.i_mem_busy(mem_busy), .i_mem_rdbusy(mem_rdbusy),\n\t\t\t\t.i_mem_pipe_stalled(mem_pipe_stalled),\n\t\t\t\t.i_mem_valid(mem_valid),\n\t\t\t\t.i_bus_err(mem_bus_err),\n\t\t\t\t.i_mem_w",
            "reg (mem_w",
            "reg ),\n\t\t\t\t.i_mem_result(mem_result),\n\t\t// }}}\n\t\t// Accounting/CPU usage interface\n\t\t// {{{\n\t\t.o_op_stall(o_op_stall), .o_pf_stall(o_pf_stall),\n\t\t\t.o_i_count(o_i_count),\n\t\t// }}}\n\t\t.o_debug(cpu_debug),\n\t\t.o_prof_stb(o_prof_stb),\n\t\t.o_prof_addr(o_prof_addr),\n\t\t.o_prof_ticks(o_prof_ticks)\n\t\t// }}}\n\t);\n\n\tassign\to_dbg_stall = w_dbg_stall || !clk_gate;\n\tassign\to_halted    = !w_dbg_stall;\n\t// }}}\n\t// o_debug -- the debugging bus",
            "input // {{{\n\tassign\to_debug = cpu_debug;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Instruction Fetch\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_LGICACHE <= 1)\n\tbegin : SINGLE_FETCH\n\t\tassign\tpf_sel = {(BUS_WIDTH/8){1'b1}};\n\n\t\tprefetch\t#(\n\t\t\t// {{{\n\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH+WBLSB),\n\t\t\t.INSN_WIDTH(INSN_WIDTH),\n\t\t\t.DATA_WIDTH(BUS_WIDTH),\n\t\t\t// .OPT_LOWPOWER(OPT_LOWPOWER),\t\t(Unused)\n\t\t\t.OPT_LITTLE_ENDIAN(1'b0)\n\t\t\t// }}}\n\t\t) pf (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t// CPU signals\n\t\t\t// {{{\n\t\t\t.i_new_pc(pf_new_pc), .i_clear_cache(clear_icache),\n\t\t\t\t.i_ready(pf_ready && clk_gate),\n\t\t\t\t.i_pc(pf_request_address),\n\t\t\t.o_valid(pf_valid), .o_illegal(pf_illegal),\n\t\t\t\t.o_insn(pf_instruction),\n\t\t\t\t.o_pc(pf_instruction_pc),\n\t\t\t// }}}\n\t\t\t// Wishbone signals\n\t\t\t// {{{\n\t\t\t.o_wb_cyc(pf_cyc), .o_wb_stb(pf_stb),\n\t\t\t\t.o_wb_we(pf_we), .o_wb_addr(pf_addr),\n\t\t\t\t.o_wb_data(pf_data),\n\t\t\t.i_wb_stall(pf_stall), .i_wb_ack(pf_ack),\n\t\t\t\t.i_wb_err(pf_err), .i_wb_data(i_wb_data)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\tend else if (OPT_LGICACHE <= 2)\n\tbegin : DBLFETCH\n\t\tassign\tpf_sel = {(BUS_WIDTH/8){1'b1}};\n\n\t\tdblfetch #(\n\t\t\t// {{{\n\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH+WBLSB),\n\t\t\t.DATA_WIDTH(BUS_WIDTH),\n\t\t\t.INSN_WIDTH(INSN_WIDTH),\n\t\t\t// .OPT_LOWPOWER(OPT_LOWPOWER),\t\t(Unused)\n\t\t\t.OPT_LITTLE_ENDIAN(1'b0)\n\t\t\t// }}}\n\t\t) pf (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t// CPU signals\n\t\t\t// {{{\n\t\t\t.i_new_pc(pf_new_pc),\n\t\t\t.i_clear_cache(clear_icache),\n\t\t\t.i_ready(pf_ready && clk_gate),\n\t\t\t.i_pc(pf_request_address),\n\t\t\t.o_valid(pf_valid), .o_illegal(pf_illegal),\n\t\t\t\t.o_insn(pf_instruction),\n\t\t\t\t.o_pc(pf_instruction_pc),\n\t\t\t// }}}\n\t\t\t// Wishbone signals\n\t\t\t// {{{\n\t\t\t.o_wb_cyc(pf_cyc), .o_wb_stb(pf_stb), .o_wb_we(pf_we),\n\t\t\t\t.o_wb_addr(pf_addr), .o_wb_data(pf_data),\n\t\t\t.i_wb_stall(pf_stall), .i_wb_ack(pf_ack),\n\t\t\t\t.i_wb_err(pf_err), .i_wb_data(i_wb_data)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\tend else if (OPT_LGICACHE <= 6)\n\tbegin : PFFIFO\n\n\t\tpffifo #(\n\t\t\t// {{{\n\t\t\t.AW(ADDRESS_WIDTH),\n\t\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t\t.INSN_WIDTH(INSN_WIDTH),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_LITTLE_ENDIAN(1'b0)\n\t\t\t// }}}\n\t\t) pf (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t// CPU signals\n\t\t\t// {{{\n\t\t\t.i_new_pc(pf_new_pc),\n\t\t\t.i_clear_cache(clear_icache),\n\t\t\t.i_ready(pf_ready && clk_gate),\n\t\t\t.i_pc(pf_request_address),\n\t\t\t.o_valid(pf_valid), .o_illegal(pf_illegal),\n\t\t\t\t.o_insn(pf_instruction),\n\t\t\t\t.o_pc(pf_instruction_pc),\n\t\t\t// }}}\n\t\t\t// Wishbone signals\n\t\t\t// {{{\n\t\t\t.o_wb_cyc(pf_cyc), .o_wb_stb(pf_stb), .o_wb_we(pf_we),\n\t\t\t\t.o_wb_addr(pf_addr), .o_wb_data(pf_data),\n\t\t\t\t.o_wb_sel(pf_sel),\n\t\t\t.i_wb_stall(pf_stall), .i_wb_ack(pf_ack),\n\t\t\t\t.i_wb_err(pf_err), .i_wb_data(i_wb_data)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\tend else begin : PFCACHE\n\t\tassign\tpf_sel = {(BUS_WIDTH/8){1'b1}};\n\n\t\tpfcache #(\n\t\t\t// {{{\n\t\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t\t// .INSN_WIDTH(INSN_WIDTH),\n\t\t\t.LGCACHELEN(OPT_LGICACHE-WBLSB),\n\t\t\t// .OPT_LOWPOWER(OPT_LOWPOWER),\t\t(Unused)\n\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH)\n\t\t\t// }}}\n\t\t) pf(\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t// CPU signals\n\t\t\t.i_new_pc(pf_new_pc), .i_clear_cache(clear_icache),\n\t\t\t\t.i_ready(pf_ready && clk_gate), .i_pc(pf_request_address),\n\t\t\t.o_valid(pf_valid), .o_illegal(pf_illegal),\n\t\t\t\t.o_insn(pf_instruction),\n\t\t\t\t.o_pc(pf_instruction_pc),\n\t\t\t// Wishbone signals\n\t\t\t.o_wb_cyc(pf_cyc), .o_wb_stb(pf_stb),\n\t\t\t\t.o_wb_we(pf_we), .o_wb_addr(pf_addr),\n\t\t\t\t.o_wb_data(pf_data),\n\t\t\t.i_wb_stall(pf_stall), .i_wb_ack(pf_ack),\n\t\t\t\t.i_wb_err(pf_err), .i_wb_data(i_wb_data)\n\t\t\t// }}}\n\t\t);\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Memory Unit\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\tgenerate if (OPT_DCACHE)\n\tbegin : DATA_CACHE\n\n\t\tdcache #(\n\t\t\t// {{{\n\t\t\t.LGCACHELEN(OPT_LGDCACHE-WBLSB),\n\t\t\t.ADDRESS_WIDTH(AW),\n\t\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t\t.LGNLINES(OPT_LGDCACHE-WBLSB-3),\n\t\t\t.OPT_LOCAL_BUS(WITH_LOCAL_BUS),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_PIPE(OPT_MEMPIPE),\n\t\t\t.OPT_LOCK(OPT_LOCK)\n`ifdef\tFORMAL\n\t\t\t, .OPT_FIFO_DEPTH(2)\n\t\t\t, .F_LGDEPTH(F_LGDEPTH)\n`endif\n\t\t\t// }}}\n\t\t) mem(\n\t\t\t// {{{\n\t\t\t.i_clk(cpu_clock), .i_reset(i_reset),.i_clear(clear_dcache),\n\t\t\t// CPU interface\n\t\t\t.i_pipe_stb(mem_ce), .i_lock(bus_lock && OPT_PIPELINED),\n\t\t\t.i_op(mem_op), .i_addr(mem_cpu_addr),.i_data(mem_wdata),\n\t\t\t\t.i_o",
            "reg (mem_",
            "reg ),\n\t\t\t.o_busy(mem_busy), .o_rdbusy(mem_rdbusy),\n\t\t\t\t.o_pipe_stalled(mem_pipe_stalled),\n\t\t\t.o_valid(mem_valid), .o_err(mem_bus_err),\n\t\t\t\t.o_w",
            "reg (mem_w",
            "reg ), .o_data(mem_result),\n\t\t\t// Wishbone interface\n\t\t\t.o_wb_cyc_gbl(mem_cyc_gbl), .o_wb_cyc_lcl(mem_cyc_lcl),\n\t\t\t\t.o_wb_stb_gbl(mem_stb_gbl), .o_wb_stb_lcl(mem_stb_lcl),\n\t\t\t\t.o_wb_we(mem_we), .o_wb_addr(mem_bus_addr),\n\t\t\t\t\t.o_wb_data(mem_data),.o_wb_sel(mem_sel),\n\t\t\t\t.i_wb_stall(mem_stall), .i_wb_ack(mem_ack),\n\t\t\t\t\t.i_wb_err(mem_err),.i_wb_data(i_wb_data)\n\t\t\t// }}}\n\t\t);\n\n\tend else if (OPT_MEMPIPE)\n\tbegin : PIPELINED_MEM\n\n\t\tpipemem\t#(\n\t\t\t// {{{\n\t\t\t.ADDRESS_WIDTH(AW),\n\t\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t\t.OPT_LOCK(OPT_LOCK),\n\t\t\t// .OPT_LOWPOWER(OPT_LOWPOWER),\t\t(Unused)\n\t\t\t.WITH_LOCAL_BUS(WITH_LOCAL_BUS)\n`ifdef\tFORMAL\n\t\t\t, .OPT_MAXDEPTH(4'h3),\n\t\t\t.F_LGDEPTH(F_LGDEPTH)\n`endif\n\t\t\t// }}}\n\t\t) domem(\n\t\t\t// {{{\n\t\t\t.i_clk(cpu_clock), .i_reset(i_reset),\n\t\t\t// CPU interface\n\t\t\t.i_pipe_stb(mem_ce), .i_lock(bus_lock && OPT_PIPELINED),\n\t\t\t.i_op(mem_op), .i_addr(mem_cpu_addr),\n\t\t\t\t.i_data(mem_wdata), .i_o",
            "reg (mem_",
            "reg ),\n\t\t\t.o_busy(mem_busy), .o_rdbusy(mem_rdbusy),\n\t\t\t\t.o_pipe_stalled(mem_pipe_stalled),\n\t\t\t.o_valid(mem_valid), .o_err(mem_bus_err),\n\t\t\t\t.o_w",
            "reg (mem_w",
            "reg ), .o_result(mem_result),\n\t\t\t// Wishbone interface\n\t\t\t.o_wb_cyc_gbl(mem_cyc_gbl), .o_wb_cyc_lcl(mem_cyc_lcl),\n\t\t\t\t.o_wb_stb_gbl(mem_stb_gbl),\n\t\t\t\t.o_wb_stb_lcl(mem_stb_lcl),\n\t\t\t\t.o_wb_we(mem_we), .o_wb_addr(mem_bus_addr),\n\t\t\t\t\t.o_wb_data(mem_data),.o_wb_sel(mem_sel),\n\t\t\t\t.i_wb_stall(mem_stall), .i_wb_ack(mem_ack),\n\t\t\t\t\t.i_wb_err(mem_err),.i_wb_data(i_wb_data)\n\t\t\t// }}}\n\t\t);\n\n\tend else begin : BARE_MEM\n\n\t\tmemops\t#(\n\t\t\t// {{{\n\t\t\t.ADDRESS_WIDTH(AW),\n\t\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_LOCK(OPT_LOCK),\n\t\t\t.WITH_LOCAL_BUS(WITH_LOCAL_BUS)\n`ifdef\tFORMAL\n\t\t\t, .F_LGDEPTH(F_LGDEPTH)\n`endif\t// F_LGDEPTH\n\t\t\t// }}}\n\t\t) domem(\n\t\t\t// {{{\n\t\t\t.i_clk(cpu_clock), .i_reset(i_reset),\n\t\t\t// CPU interface\n\t\t\t.i_stb(mem_ce), .i_lock(bus_lock && OPT_PIPELINED),\n\t\t\t.i_op(mem_op), .i_addr(mem_cpu_addr),\n\t\t\t\t.i_data(mem_wdata), .i_o",
            "reg (mem_",
            "reg ),\n\t\t\t.o_busy(mem_busy), .o_rdbusy(mem_rdbusy),\n\t\t\t.o_valid(mem_valid), .o_err(mem_bus_err),\n\t\t\t\t.o_w",
            "reg (mem_w",
            "reg ), .o_result(mem_result),\n\t\t\t// Wishbone interface\n\t\t\t.o_wb_cyc_gbl(mem_cyc_gbl), .o_wb_cyc_lcl(mem_cyc_lcl),\n\t\t\t\t.o_wb_stb_gbl(mem_stb_gbl), .o_wb_stb_lcl(mem_stb_lcl),\n\t\t\t\t.o_wb_we(mem_we), .o_wb_addr(mem_bus_addr),\n\t\t\t\t.o_wb_data(mem_data), .o_wb_sel(mem_sel),\n\t\t\t\t.i_wb_stall(mem_stall), .i_wb_ack(mem_ack),\n\t\t\t\t.i_wb_err(mem_err), .i_wb_data(i_wb_data)\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\tmem_pipe_stalled = mem_busy;\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus arbiter\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Either the prefetch or the instruction gets the memory bus, but\n\t// never both under this arbitration scheme.\n\tgenerate if (OPT_PIPELINED)\n\tbegin : PRIORITY_DATA\n\n\t\twbdblpriarb\t#(\n\t\t\t// {{{\n\t\t\t.AW(AW),\n\t\t\t.DW(BUS_WIDTH),\n\t\t\t.OPT_ZERO_ON_IDLE(OPT_LOWPOWER)\n\t\t\t// }}}\n\t\t) pformem(\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t// Memory access to the arbiter, priority position\n\t\t\t.i_a_cyc_a(mem_cyc_gbl), .i_a_cyc_b(mem_cyc_lcl),\n\t\t\t\t.i_a_stb_a(mem_stb_gbl), .i_a_stb_b(mem_stb_lcl),\n\t\t\t\t.i_a_we(mem_we), .i_a_adr(mem_bus_addr),\n\t\t\t\t.i_a_dat(mem_data), .i_a_sel(mem_sel),\n\t\t\t\t.o_a_stall(mem_stall), .o_a_ack(mem_ack),\n\t\t\t\t.o_a_err(mem_err),\n\t\t\t// Prefetch access to the arbiter\n\t\t\t//\n\t\t\t// At a first glance, we might want something like:\n\t\t\t//\n\t\t\t// pf_cyc, 1'b0, pf_stb, 1'b0, pf_we, pf_addr, pf_data, 4'hf,\n\t\t\t//\n\t\t\t// However, we know that the prefetch will not generate\n\t\t\t// any writes.  Therefore, the write specific lines\n\t\t\t// (mem_data) can be shared with the memory in order to\n\t\t\t// ease timing and LUT usage.  This is not true of\n\t\t\t// mem_sel, which may be used to know which bytes we are\n\t\t\t// reading from.\n\t\t\t.i_b_cyc_a(pf_cyc), .i_b_cyc_b(1'b0),\n\t\t\t\t.i_b_stb_a(pf_stb), .i_b_stb_b(1'b0),\n\t\t\t\t.i_b_we(pf_we), .i_b_adr(pf_addr),\n\t\t\t\t.i_b_dat(mem_data),\n\t\t\t\t.i_b_sel(pf_sel),\n\t\t\t\t.o_b_stall(pf_stall), .o_b_ack(pf_ack),\n\t\t\t\t.o_b_err(pf_err),\n\t\t\t// Common",
            "wire s, in and out, of the arbiter\n\t\t\t.o_cyc_a(o_wb_gbl_cyc), .o_cyc_b(o_wb_lcl_cyc),\n\t\t\t\t.o_stb_a(o_wb_gbl_stb), .o_stb_b(o_wb_lcl_stb),\n\t\t\t\t.o_we(o_wb_we), .o_adr(o_wb_addr),\n\t\t\t\t.o_dat(o_wb_data), .o_sel(o_wb_sel),\n\t\t\t\t.i_stall(i_wb_stall), .i_ack(i_wb_ack),\n\t\t\t\t.i_err(i_wb_err)\n\t\t\t// }}}\n\t\t);\n\n\tend else begin : PRIORITY_PREFETCH\n\n\t\twbdblpriarb\t#(\n\t\t\t// {{{\n\t\t\t.DW(BUS_WIDTH), .AW(AW),\n\t\t\t.OPT_ZERO_ON_IDLE(OPT_LOWPOWER)\n\t\t\t// }}}\n\t\t) pformem(\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t// Prefetch access to the arbiter, priority position\n\t\t\t//\n\t\t\t.i_a_cyc_a(pf_cyc), .i_a_cyc_b(1'b0),\n\t\t\t\t.i_a_stb_a(pf_stb), .i_a_stb_b(1'b0),\n\t\t\t\t.i_a_we(pf_we), .i_a_adr(pf_addr),\n\t\t\t\t.i_a_dat(mem_data),\n\t\t\t\t.i_a_sel(pf_sel),\n\t\t\t\t.o_a_stall(pf_stall), .o_a_ack(pf_ack),\n\t\t\t\t.o_a_err(pf_err),\n\t\t\t// Memory access to the arbiter\n\t\t\t.i_b_cyc_a(mem_cyc_gbl), .i_b_cyc_b(mem_cyc_lcl),\n\t\t\t\t.i_b_stb_a(mem_stb_gbl),.i_b_stb_b(mem_stb_lcl),\n\t\t\t\t.i_b_we(mem_we), .i_b_adr(mem_bus_addr),\n\t\t\t\t.i_b_dat(mem_data), .i_b_sel(mem_sel),\n\t\t\t\t.o_b_stall(mem_stall), .o_b_ack(mem_ack),\n\t\t\t\t.o_b_err(mem_err),\n\t\t\t// Common",
            "wire s, in and out, of the arbiter\n\t\t\t.o_cyc_a(o_wb_gbl_cyc), .o_cyc_b(o_wb_lcl_cyc),\n\t\t\t\t.o_stb_a(o_wb_gbl_stb), .o_stb_b(o_wb_lcl_stb),\n\t\t\t\t.o_we(o_wb_we), .o_adr(o_wb_addr),\n\t\t\t\t.o_dat(o_wb_data), .o_sel(o_wb_sel),\n\t\t\t\t.i_stall(i_wb_stall), .i_ack(i_wb_ack),\n\t\t\t\t.i_err(i_wb_err)\n\t\t\t// }}}\n\t\t);\n\n\tend endgenerate\n\t//}}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Optional) Clock Gate\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_CLKGATE)\n\tbegin : GATE_CPU_CLOCK\n\t\t// {{{",
            "reg gatep;",
            "reg gaten /* verilator clock_enable */;\n\n\t\tinitial\tgatep = 1'b1;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tgatep <= 1'b1;\n\t\telse\n\t\t\tgatep <= cpu_clken || i_dbg_we || i_cpu_clken;\n\n\t\tinitial\tgaten = 1'b1;\n\t\talways @(negedge i_clk)\n\t\tif (i_reset)\n\t\t\tgaten <= 1'b1;\n\t\telse\n\t\t\tgaten <= gatep;\n\n\t\tassign\tcpu_clock = i_clk && gaten;\n\t\tassign\tclk_gate  = gatep;\n\t\t// }}}\n\tend else begin : NO_CLOCK_GATE\n\n\t\tassign\tcpu_clock = i_clk;\n\t\tassign\tclk_gate = 1'b1;\n\n\t\t// Verilattor lint_off UNUSED",
            "wire unused_clk;\n\t\tassign\tunused_clk = &{ 1'b0, i_cpu_clken, cpu_clken };\n\t\t// Verilator lint_on  UNUSED\n\tend endgenerate\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, pf_data, mem_lock_pc, clear_dcache };\n\t// Verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "axipipe.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/axipipe.v",
        "chunks": [
            "module axipipe #(\n\t\t// {{{",
            "parameter C_AXI_ADDR_WIDTH = 30,",
            "parameter C_AXI_DATA_WIDTH = 32,",
            "parameter C_AXI_ID_WIDTH = 1,",
            "parameter [((C_AXI_ID_WIDTH>0)? C_AXI_ID_WIDTH:1)-1:0]\n\t\t\t\tAXI_ID = 0,",
            "localparam AW = C_AXI_ADDR_WIDTH,",
            "localparam DW = C_AXI_DATA_WIDTH,",
            "localparam IW =(C_AXI_ID_WIDTH > 0) ? C_AXI_ID_WIDTH : 1,\n\t\t//\n\t\t//",
            "parameter [0:0]\tSWAP_ENDIANNESS = 1'b0,",
            "parameter [0:0]\tSWAP_WSTRB = 1'b0,",
            "parameter [0:0]\tOPT_SIGN_EXTEND = 1'b0,\n\t\t// AXI locks are a challenge, and require support from the\n\t\t// CPU.  Specifically, we have to be able to unroll and re-do\n\t\t// the load instruction on any atomic access failure.  For that\n\t\t// reason, we'll ignore the lock request initially.",
            "parameter [0:0]\tOPT_LOCK=1'b1,",
            "parameter [0:0]\tOPT_ALIGNMENT_ERR = 1'b0,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b1,",
            "parameter [3:0]\tOPT_QOS = 0\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,",
            "input ",
            "wire i_cpu_reset,\n\t\t//\n\t\t// CPU interface\n\t\t// {{{",
            "input ",
            "wire i_stb,",
            "input ",
            "wire i_lock,",
            "input ",
            "wire [2:0]\t\t\ti_op,",
            "input ",
            "wire [AW-1:0]\t\ti_addr,",
            "input ",
            "wire [AW-1:0]\t\ti_restart_pc,",
            "input ",
            "wire [31:0]\t\t\ti_data,",
            "input ",
            "wire [4:0]\t\t\ti_o",
            "reg ,",
            "output ",
            "reg o_busy,",
            "output ",
            "reg o_pipe_stalled,",
            "output ",
            "reg o_rdbusy,",
            "output ",
            "reg o_valid,",
            "output ",
            "reg o_err,",
            "output ",
            "reg [4:0]\t\t\to_w",
            "reg ,",
            "output ",
            "reg [31:0]\t\t\to_result,\n\t\t// }}}\n\t\t//\n\t\t// AXI4 bus interface\n\t\t// {{{\n\t\t// Writes\n\t\t// {{{",
            "output ",
            "reg M_AXI_AWVALID,",
            "input ",
            "wire M_AXI_AWREADY,\n\t\t// verilator coverage_off",
            "output ",
            "wire [IW-1:0]\tM_AXI_AWID,\n\t\t// verilator coverage_on",
            "output ",
            "reg [AW-1:0]\tM_AXI_AWADDR,\n\t\t// verilator coverage_off",
            "output ",
            "wire [7:0]\t\tM_AXI_AWLEN,\t// == 0\n\t\t// verilator coverage_on",
            "output ",
            "wire [2:0]\t\tM_AXI_AWSIZE,",
            "output ",
            "wire [1:0]\t\tM_AXI_AWBURST,",
            "output ",
            "wire M_AXI_AWLOCK,",
            "output ",
            "wire [3:0]\t\tM_AXI_AWCACHE,\n\t\t// verilator coverage_off",
            "output ",
            "wire [2:0]\t\tM_AXI_AWPROT,",
            "output ",
            "wire [3:0]\t\tM_AXI_AWQOS,\n\t\t// verilator coverage_on\n\t\t//",
            "output ",
            "reg M_AXI_WVALID,",
            "input ",
            "wire M_AXI_WREADY,",
            "output ",
            "reg [DW-1:0]\tM_AXI_WDATA,",
            "output ",
            "reg [DW/8-1:0]\tM_AXI_WSTRB,",
            "output ",
            "wire M_AXI_WLAST,\n\t\t//",
            "input ",
            "wire M_AXI_BVALID,\n\t\t// verilator coverage_off",
            "input ",
            "wire [IW-1:0]\tM_AXI_BID,\n\t\t// verilator coverage_on",
            "output ",
            "wire M_AXI_BREADY,",
            "input ",
            "wire [1:0]\t\tM_AXI_BRESP,\n\t\t// }}}\n\t\t// Reads\n\t\t// {{{",
            "output ",
            "reg M_AXI_ARVALID,",
            "input ",
            "wire M_AXI_ARREADY,\n\t\t// verilator coverage_off",
            "output ",
            "wire [IW-1:0]\tM_AXI_ARID,\n\t\t// verilator coverage_on",
            "output ",
            "reg [AW-1:0]\tM_AXI_ARADDR,\n\t\t// verilator coverage_off",
            "output ",
            "wire [7:0]\t\tM_AXI_ARLEN,\t// == 0\n\t\t// verilator coverage_on",
            "output ",
            "wire [2:0]\t\tM_AXI_ARSIZE,",
            "output ",
            "wire [1:0]\t\tM_AXI_ARBURST,",
            "output ",
            "wire M_AXI_ARLOCK,",
            "output ",
            "wire [3:0]\t\tM_AXI_ARCACHE,\n\t\t// verilator coverage_off",
            "output ",
            "wire [2:0]\t\tM_AXI_ARPROT,",
            "output ",
            "wire [3:0]\t\tM_AXI_ARQOS,\n\t\t// verilator coverage_on\n\t\t//",
            "input ",
            "wire M_AXI_RVALID,",
            "output ",
            "wire M_AXI_RREADY,\n\t\t// verilator coverage_off",
            "input ",
            "wire [IW-1:0]\tM_AXI_RID,\n\t\t// verilator coverage_on",
            "input ",
            "wire [DW-1:0]\tM_AXI_RDATA,",
            "input ",
            "wire M_AXI_RLAST,",
            "input ",
            "wire [1:0]\t\tM_AXI_RRESP\n\t\t// }}}\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam AXILSB = $clog2(C_AXI_DATA_WIDTH/8);",
            "localparam [2:0] DSZ = AXILSB[2:0];",
            "localparam LGPIPE = 4;",
            "localparam FIFO_WIDTH = AXILSB+1+2+4 + 1;",
            "localparam [1:0]\tAXI_INCR = 2'b01,\n\t\t\t\tOKAY = 2'b00,\n\t\t\t\tEXOKAY = 2'b01;\n\t\t\t//\tSLVERR\n\t\t\t//\tDECERR",
            "wire i_clk = S_AXI_ACLK;",
            "reg w_misaligned;",
            "wire misaligned_request, misaligned_aw_request, pending_err;",
            "reg w_misalignment_err;",
            "reg [C_AXI_DATA_WIDTH-1:0]\tnext_wdata;",
            "reg [C_AXI_DATA_WIDTH/8-1:0]\tnext_wstrb;",
            "reg [AW-1:0]\t\tr_pc;",
            "reg r_lock;",
            "reg [2:0]\t\t\taxi_size;",
            "reg none_outstanding, bus_abort,\n\t\t\t\t\tread_abort, write_abort;",
            "reg [LGPIPE:0]\t\tbeats_outstanding;",
            "reg r_flushing, flush_request,\n\t\t\t\t\tr_pipe_stalled;",
            "reg [LGPIPE:0]\t\tflushcount, new_flushcount;",
            "reg [LGPIPE:0]\t\twraddr, rdaddr;",
            "reg [3:0]\t\t\tar_o",
            "reg ;",
            "reg [1:0]\t\t\tar_op;",
            "reg [AXILSB-1:0]\t\tadr_lsb;",
            "reg [FIFO_WIDTH-1:0]\tfifo_data\t[0:((1<<LGPIPE)-1)];",
            "reg [FIFO_WIDTH-1:0]\tfifo_read_data;",
            "wire fifo_read_op, fifo_misaligned;",
            "reg fifo_gie;",
            "wire [1:0]\t\t\tfifo_op;",
            "wire [3:0]\t\t\tfifo_return_",
            "reg ;",
            "wire [AXILSB-1:0]\t\tfifo_lsb;",
            "reg [2*C_AXI_DATA_WIDTH-1:0]\twide_return, wide_wdata;",
            "reg [31:0]\t\t\tpre_result;",
            "reg [2*C_AXI_DATA_WIDTH/8-1:0]\twide_wstrb;",
            "reg [C_AXI_DATA_WIDTH-1:0]\tmisdata;\n\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Transaction issue\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// AWVALID\n\t// {{{\n\tinitial\tM_AXI_AWVALID = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tM_AXI_AWVALID <= 0;\n\telse if (!M_AXI_AWVALID || M_AXI_AWREADY)\n\tbegin\n\t\tif (i_stb && i_op[0])\n\t\t\tM_AXI_AWVALID <= !w_misalignment_err;\n\t\telse\n\t\t\tM_AXI_AWVALID <= M_AXI_AWVALID && misaligned_aw_request;\n\n\t\tif (write_abort && !misaligned_aw_request)\n\t\t\tM_AXI_AWVALID <= 0;\n\tend\n\t// }}}\n\n\t// WVALID\n\t// {{{\n\tinitial\tM_AXI_WVALID = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tM_AXI_WVALID <= 0;\n\telse if (!M_AXI_WVALID || M_AXI_WREADY)\n\tbegin\n\t\tif (i_stb && i_op[0])\n\t\t\tM_AXI_WVALID <= !w_misalignment_err;\n\t\telse\n\t\t\tM_AXI_WVALID <= M_AXI_WVALID && misaligned_request;\n\n\t\tif (write_abort && !misaligned_request)\n\t\t\tM_AXI_WVALID <= 0;\n\tend\n\t// }}}\n\n\t// ARVALID\n\t// {{{\n\tinitial\tM_AXI_ARVALID = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tM_AXI_ARVALID <= 0;\n\telse if (!M_AXI_ARVALID || M_AXI_ARREADY)\n\tbegin\n\t\tif (i_stb && !i_op[0])\n\t\t\tM_AXI_ARVALID <= !w_misalignment_err;\n\t\telse\n\t\t\tM_AXI_ARVALID <= M_AXI_ARVALID && misaligned_request;\n\n\t\tif (read_abort && !misaligned_request)\n\t\t\tM_AXI_ARVALID <= 0;\n\tend\n\t// }}}\n\n\t// r_lock, M_AXI_AxLOCK\n\t// {{{\n\tinitial\tr_lock = 1'b0;\n\talways @(posedge i_clk)\n\tif (!OPT_LOCK || !S_AXI_ARESETN)\n\t\tr_lock <= 1'b0;\n\telse if ((!M_AXI_ARVALID || M_AXI_ARREADY)\n\t\t\t&&(!M_AXI_AWVALID || M_AXI_AWREADY))\n\tbegin\n\t\tif (!M_AXI_AWVALID && !M_AXI_ARVALID && !M_AXI_WVALID\n\t\t\t\t&& beats_outstanding <= ((M_AXI_RVALID||M_AXI_BVALID)? 1:0))\n\t\t\tr_lock <= 1'b0;\n\t\tif (i_stb)\n\t\t\tr_lock <= i_lock && !w_misalignment_err;\n\t\tif (i_cpu_reset || r_flushing)\n\t\t\tr_lock <= 1'b0;\n\tend\n\n\tassign\tM_AXI_AWLOCK = r_lock;\n\tassign\tM_AXI_ARLOCK = r_lock;\n\t// }}}\n\n\t// axi_size, M_AXI_AxSIZE\n\t// {{{\n\tinitial\taxi_size = DSZ;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_size <= DSZ;\n\telse if (i_stb)\n\tbegin\n\t\tif (SWAP_WSTRB)\n\t\t\taxi_size <= AXILSB[2:0];\n\t\telse begin\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b0?: begin\n\t\t\t\taxi_size <= 3'b010;\n\t\t\t\tif ((|i_addr[1:0]) && !w_misaligned)\n\t\t\t\t\taxi_size <= AXILSB[2:0];\n\t\t\t\tend\n\t\t\t2'b10: begin\n\t\t\t\taxi_size <= 3'b001;\n\t\t\t\tif (i_addr[0] && !w_misaligned)\n\t\t\t\t\taxi_size <= AXILSB[2:0];\n\t\t\t\tend\n\t\t\t2'b11: axi_size <= 3'b000;\n\t\t\t// default: begin end\n\t\t\tendcase\n\t\tend\n\tend\n\n\tassign\tM_AXI_AWSIZE = axi_size;\n\tassign\tM_AXI_ARSIZE = axi_size;\n\t// }}}\n\n\t// o_busy,\n\t// {{{\n\t// True if the bus is busy doing ... something, whatever it might be.\n\t// If the bus is busy, the CPU will avoid issuing further interactions\n\t// to the bus other than pipelined interactions.\n\tinitial\to_busy = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\to_busy <= 0;\n\telse if (i_stb && !w_misalignment_err && !bus_abort)\n\t\to_busy <= 1;\n\telse if (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID)\n\t\to_busy <= 1;\n\telse if (beats_outstanding > ((M_AXI_RVALID || M_AXI_BVALID) ? 1:0))\n\t\to_busy <= 1;\n\telse\n\t\to_busy <= 0;\n`ifdef\tFORMAL\n\talways @(*)\n\t\tassert(o_busy == (!none_outstanding || M_AXI_ARVALID\n\t\t\t\t|| M_AXI_AWVALID || M_AXI_WVALID));\n`endif\n\t// }}}\n\n\t// Read busy\n\t// {{{\n\t// True if the CPU should expect some kind of pending response from a\n\t// read, and so should stall for that purpose.  False otherwise.\n\tinitial\to_rdbusy = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_cpu_reset || r_flushing)\n\t\to_rdbusy <= 0;\n\telse if ((i_stb && w_misalignment_err) || bus_abort)\n\t\to_rdbusy <= 0;\n\telse if (i_stb && (!i_op[0] || (OPT_LOCK && i_lock)))\n\t\to_rdbusy <= 1;\n\telse if (OPT_LOCK)\n\tbegin\n\t\tif (M_AXI_AWVALID || M_AXI_ARVALID || M_AXI_WVALID)\n\t\t\to_rdbusy <= o_rdbusy;\n\t\telse if (o_rdbusy)\n\t\t\to_rdbusy <= (beats_outstanding > ((M_AXI_RVALID||M_AXI_BVALID) ? 1:0));\n\tend else if (o_rdbusy && !M_AXI_ARVALID)\n\t\to_rdbusy <= (beats_outstanding > (M_AXI_RVALID ? 1:0));\n\n`ifdef\tFORMAL",
            "reg writing;\n\n\talways @(posedge S_AXI_ACLK)\n\tif (i_stb && !o_busy)\n\t\twriting <= i_op[0];\n\n\talways @(*)\n\tif (r_flushing)\n\tbegin\n\t\tassert(!o_rdbusy);\n\tend else begin\n\t\tif (writing && r_lock && (M_AXI_AWVALID || M_AXI_WVALID || (beats_outstanding > 0)))\n\t\tbegin\n\t\t\tassert(o_rdbusy);\n\t\tend else if (writing)\n\t\tbegin\n\t\t\tassert(!o_rdbusy);\n\t\tend\n\n\t\tif (!o_busy)\n\t\t\tassert(!o_rdbusy);\n\tend\n`endif\n\t// }}}\n\n\t// o_pipe_stalled, r_pipe_stalled\n\t// {{{\n\t// True if the CPU should expect some kind of pending response from a\n\t// read, and so should stall for that purpose.  False otherwise.\n\tgenerate if (OPT_ALIGNMENT_ERR)\n\tbegin : FULL_PIPE_STALL\n\t\t// {{{\n\t\t// Here, we stall if the FIFO is ever full.  In this case,\n\t\t// any new beat will count as only one item to the FIFO, and\n\t\t// so we can run all the way to full.",
            "reg [LGPIPE:0]\t\tbeats_committed;\n\n\t\talways @(*)\n\t\t\tbeats_committed = beats_outstanding\n\t\t\t\t+ ((i_stb && !w_misalignment_err) ? 1:0)\n\t\t\t\t+ ((M_AXI_AWVALID || M_AXI_WVALID\n\t\t\t\t\t\t|| M_AXI_ARVALID) ? 1:0);\n\n\t\tinitial\tr_pipe_stalled = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (i_cpu_reset)\n\t\t\tr_pipe_stalled <= 0;\n\t\telse if (M_AXI_RVALID || M_AXI_BVALID)\n\t\t\tr_pipe_stalled <= 0;\n\t\telse if (i_stb && i_lock && !w_misalignment_err)\n\t\t\tr_pipe_stalled <= 1;\n\t\telse if (OPT_LOCK && r_lock)\n\t\t\tr_pipe_stalled <= (beats_committed > 0);\n\t\telse\n\t\t\tr_pipe_stalled <= (beats_committed >= (1<<LGPIPE));\n\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (r_flushing)\n\t\tbegin\n\t\t\tassert(o_pipe_stalled);\n\t\tend else if (beats_outstanding + ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0) >= (1<<LGPIPE))\n\t\tbegin\n\t\t\tassert(r_pipe_stalled);\n\t\tend else if (beats_outstanding + (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) < (1<<LGPIPE)-1)\n\t\t\tassert(r_lock || !r_pipe_stalled);\n\n\t\talways @(*)\n\t\tif (r_lock && !r_flushing)\n\t\tbegin\n\t\t\tif (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID)\n\t\t\tbegin\n\t\t\t\tassert(r_pipe_stalled);\n\t\t\tend else if (beats_outstanding >= 1)\n\t\t\tbegin\n\t\t\t\tassert(r_pipe_stalled);\n\t\t\tend else\n\t\t\t\tassert(!r_pipe_stalled && !OPT_LOWPOWER);\n\t\tend\n`endif\n\t\t// }}}\n\tend else begin : PENULTIMATE_FULL_STALL\n\t\t// {{{\n\t\t// If we allow for misaligned reads and writes, than we have\n\t\t// to stall the CPU just before the FIFO is full, lest the\n\t\t// CPU send us a value that needs two items to be placed into\n\t\t// the FIO.",
            "reg [LGPIPE:0]\t\tbeats_committed;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tbeats_committed = beats_outstanding + (i_stb ? 1:0)\n\t\t\t\t+ ((M_AXI_AWVALID || M_AXI_WVALID\n\t\t\t\t\t\t|| M_AXI_ARVALID) ? 1:0)\n\t\t\t\t- ((M_AXI_BVALID || M_AXI_RVALID) ? 1:0);\n\t\tend\n\n\t\tinitial\tr_pipe_stalled = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (i_cpu_reset || bus_abort)\n\t\t\tr_pipe_stalled <= 0;\n\t\telse begin\n\t\t\tr_pipe_stalled <= 0;\n\t\t\tif (r_lock && (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID))\n\t\t\t\tr_pipe_stalled <= 1;\n\t\t\tif (r_lock && (beats_outstanding > ((M_AXI_RVALID || M_AXI_BVALID) ? 1:0)))\n\t\t\t\tr_pipe_stalled <= 1;\n\t\t\tif (i_stb && (w_misaligned && !w_misalignment_err) && !o_pipe_stalled)\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\tif (misaligned_request && (M_AXI_WVALID && !M_AXI_WREADY))\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\tif (misaligned_request && (M_AXI_ARVALID && !M_AXI_ARREADY))\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\tif (misaligned_aw_request && (M_AXI_AWVALID && !M_AXI_AWREADY))\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\tif (beats_committed >= (1<<LGPIPE)-2)\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\t\tif (i_stb && i_lock && !w_misalignment_err)\n\t\t\t\tr_pipe_stalled <= 1'b1;\n\t\tend\n\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (!r_flushing && (beats_outstanding\n\t\t\t\t+ ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0)\n\t\t\t\t+ ((misaligned_aw_request || misaligned_request) ? 1:0)\n\t\t\t\t>= (1<<LGPIPE)))\n\t\tbegin\n\t\t\tassert(r_pipe_stalled);\n\t\tend else if (r_lock && !r_flushing)\n\t\tbegin\n\t\t\tassert(r_pipe_stalled == o_busy);\n\t\tend else if (!r_flushing && !o_err\n\t\t\t\t&& !M_AXI_AWVALID && !M_AXI_WVALID\n\t\t\t\t&& !M_AXI_ARVALID\n\t\t\t\t&& beats_outstanding <= ((1<<LGPIPE)-4))\n\t\t\tassert(!r_pipe_stalled);\n\n\t\talways @(*)\n\t\t\tassert(beats_committed\n\t\t\t\t+ ((i_stb && w_misaligned && !r_pipe_stalled) ? 1:0)\n\t\t\t\t<= (1<<LGPIPE));\n`endif\n\t\t// }}}\n\tend endgenerate\n\n\talways @(*)\n\tbegin\n\t\to_pipe_stalled = r_pipe_stalled || r_flushing;\n\t\t// if (r_lock && o_busy) o_pipe_stalled = 1;\n\t\tif (M_AXI_AWVALID && (!M_AXI_AWREADY || misaligned_aw_request))\n\t\t\to_pipe_stalled = 1;\n\t\tif (M_AXI_WVALID && (!M_AXI_WREADY || misaligned_request))\n\t\t\to_pipe_stalled = 1;\n\t\tif (M_AXI_ARVALID && (!M_AXI_ARREADY || misaligned_request))\n\t\t\to_pipe_stalled = 1;\n\tend\n`ifdef\tFORMAL\n\talways @(*)\n\tif (misaligned_request)\n\t\tassert(M_AXI_WVALID || M_AXI_ARVALID);\n\n\talways @(*)\n\tif (misaligned_aw_request)\n\t\tassert(M_AXI_AWVALID);\n\n\talways @(*)\n\tif (r_lock && o_busy)\n\t\tassert(o_pipe_stalled);\n`endif\n\t// }}}\n\n\t// Count the number of outstanding beats\n\t// {{{\n\t// This is the true count.  It is not affected by the number of\n\t// items the CPU believes is on the bus or not.\n\tinitial\tbeats_outstanding = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tbeats_outstanding <= 0;\n\telse casez({M_AXI_AWVALID && M_AXI_AWREADY,\n\t\tM_AXI_WVALID && M_AXI_WREADY,\n\t\tM_AXI_ARVALID && M_AXI_ARREADY,\n\t\tM_AXI_RVALID || M_AXI_BVALID})\n\t4'b0001: beats_outstanding <= beats_outstanding - 1;\n\t4'b??10: beats_outstanding <= beats_outstanding + 1;\n\t4'b1100: beats_outstanding <= beats_outstanding + 1;\n\t4'b1000: if (!M_AXI_WVALID || (misaligned_aw_request && !misaligned_request))\n\t\t\tbeats_outstanding <= beats_outstanding + 1;\n\t4'b0100: if (!M_AXI_AWVALID || (misaligned_request && !misaligned_aw_request))\n\t\t\tbeats_outstanding <= beats_outstanding + 1;\n\t4'b10?1: if ((M_AXI_WVALID && (OPT_ALIGNMENT_ERR\n\t\t\t\t|| (misaligned_request == misaligned_aw_request)))\n\t\t\t|| (!misaligned_aw_request && misaligned_request))\n\t\t\tbeats_outstanding <= beats_outstanding - 1;\n\t4'b0101: if ((M_AXI_AWVALID && (OPT_ALIGNMENT_ERR\n\t\t\t\t|| (misaligned_request == misaligned_aw_request)))\n\t\t\t|| (!misaligned_request && misaligned_aw_request))\n\t\t\tbeats_outstanding <= beats_outstanding - 1;\n\tdefault: begin end\n\tendcase\n\n\tinitial\tnone_outstanding = 1;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tnone_outstanding <= 1;\n\telse casez({M_AXI_AWVALID && M_AXI_AWREADY,\n\t\tM_AXI_WVALID && M_AXI_WREADY,\n\t\tM_AXI_ARVALID && M_AXI_ARREADY,\n\t\tM_AXI_RVALID || M_AXI_BVALID})\n\t4'b0001: none_outstanding <= (beats_outstanding <= 1);\n\t4'b??10: none_outstanding <= 0;\n\t4'b1100: none_outstanding <= 0;\n\t4'b1000: if (!M_AXI_WVALID || (misaligned_aw_request && !misaligned_request))\n\t\t\tnone_outstanding <= 0;\n\t4'b0100: if (!M_AXI_AWVALID || (misaligned_request && !misaligned_aw_request))\n\t\t\tnone_outstanding <= 0;\n\t4'b10?1: if ((M_AXI_WVALID && (OPT_ALIGNMENT_ERR\n\t\t\t\t|| (misaligned_request == misaligned_aw_request)))\n\t\t\t|| (!misaligned_aw_request && misaligned_request))\n\t\t\tnone_outstanding <= (beats_outstanding <= 1);\n\t4'b0101: if ((M_AXI_AWVALID && (OPT_ALIGNMENT_ERR\n\t\t\t\t|| (misaligned_request == misaligned_aw_request)))\n\t\t\t|| (!misaligned_request && misaligned_aw_request))\n\t\t\tnone_outstanding <= (beats_outstanding <= 1);\n\tdefault: begin end\n\tendcase\n`ifdef\tFORMAL\n\talways @(*)\n\t\tassert(none_outstanding == (beats_outstanding == 0));\n`endif\n\t// }}}\n\n\t// bus_abort\n\t// {{{\n\t// When do we abandon everything and start aborting bus transactions?\n\talways @(*)\n\tbegin\n\t\tbus_abort = 0;\n\t\tif (i_cpu_reset || o_err)\n\t\t\tbus_abort = 1;\n\t\tif (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\tbus_abort = 1;\n\t\tif (M_AXI_RVALID && M_AXI_RRESP[1])\n\t\t\tbus_abort = 1;\n\n\t\twrite_abort = 0;\n\t\tif (i_cpu_reset || o_err)\n\t\t\twrite_abort = 1;\n\t\tif (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\twrite_abort = 1;\n\n\t\tread_abort = 0;\n\t\tif (i_cpu_reset || o_err)\n\t\t\tread_abort = 1;\n\t\tif (M_AXI_RVALID && M_AXI_RRESP[1])\n\t\t\tread_abort = 1;\n\tend\n\t// }}}\n\n\t// Flushing\n\t// {{{\n\n\t// new_flushcount\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tcase({((M_AXI_AWVALID || M_AXI_WVALID) || M_AXI_ARVALID),\n\t\t\t(M_AXI_BVALID || M_AXI_RVALID) })\n\t\t2'b01: new_flushcount = beats_outstanding - 1;\n\t\t2'b10: new_flushcount = beats_outstanding + 1;\n\t\tdefault: new_flushcount = beats_outstanding;\n\t\tendcase\n\n\t\tif (!OPT_ALIGNMENT_ERR && (misaligned_request || misaligned_aw_request))\n\t\t\tnew_flushcount = new_flushcount + 1;\n\tend\n\t// }}}\n\n\tinitial\tr_flushing    = 1'b0;\n\tinitial\tflushcount    = 0;\n\tinitial\tflush_request = 0;\n\talways @(posedge i_clk)\n\tif (!S_AXI_ARESETN)\n\tbegin\n\t\t// {{{\n\t\tr_flushing <= 1'b0;\n\t\tflush_request <= 0;\n\t\tflushcount    <= 0;\n\t\t// }}}\n\tend else if (i_cpu_reset || bus_abort || (i_stb && w_misalignment_err))\n\tbegin\n\t\t// {{{\n\t\tr_flushing <= (new_flushcount != 0);\n\t\tflushcount <= new_flushcount;\n\t\tflush_request <= (M_AXI_ARVALID && (!M_AXI_ARREADY || misaligned_request))\n\t\t\t|| (M_AXI_AWVALID && (!M_AXI_AWREADY || misaligned_aw_request))\n\t\t\t|| (M_AXI_WVALID && (!M_AXI_WREADY || misaligned_request));\n\t\t// }}}\n\tend else if (r_flushing)\n\tbegin\n\t\t// {{{\n\t\tif (M_AXI_BVALID || M_AXI_RVALID)\n\t\tbegin\n\t\t\tflushcount <= flushcount - 1;\n\t\t\tr_flushing <= (flushcount > 1);\n\t\tend\n\n\t\tcasez({M_AXI_AWVALID && (M_AXI_AWREADY && !misaligned_aw_request),\n\t\t\t\t(M_AXI_WVALID && M_AXI_WREADY && !misaligned_request),\n\t\t\t\t(M_AXI_ARVALID && M_AXI_ARREADY && !misaligned_request) })\n\t\t3'b001: flush_request <= 0;\n\t\t3'b10?: flush_request <= M_AXI_WVALID;\n\t\t3'b01?: flush_request <= M_AXI_AWVALID;\n\t\t3'b11?: flush_request <= 0;\n\t\tdefault: begin end\n\t\tendcase\n\t\t// }}}\n\tend\n`ifdef\tFORMAL\n\talways @(*)\n\tbegin\n\t\tassert(r_flushing == (flushcount > 0));\n\t\tif (!r_flushing)\n\t\tbegin\n\t\t\tassert(!flush_request);\n\t\tend else\n\t\t\tassert(flush_request == (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID));\n\t\tif (r_flushing && !flush_request)\n\t\tbegin\n\t\t\tassert(!misaligned_request);\n\t\t\tassert(!misaligned_aw_request);\n\t\tend\n\n\t\tif (flush_request)\n\t\tbegin\n\t\t\tassert(flushcount == beats_outstanding + 1\n\t\t\t\t+ ((misaligned_request\n\t\t\t\t|| misaligned_aw_request) ? 1:0));\n\t\t// else if (faxil_rd_outstanding > 0 || M_AXI_ARVALID)\n\t\tend else if (r_flushing)\n\t\tbegin\n\t\t\tassert(beats_outstanding == flushcount);\n\t\tend else\n\t\t\tassert(beats_outstanding >= flushcount);\n\tend\n`endif\n\t// }}}\n\n\t// Bus addressing\n\t// {{{\n\tinitial\tM_AXI_AWADDR = 0;\n\talways @(posedge i_clk)\n\tif (i_stb)\n\tbegin\n\t\tM_AXI_AWADDR <= i_addr[AW-1:0];\n\t\tif (SWAP_WSTRB)\n\t\t\tM_AXI_AWADDR[AXILSB-1:0] <= 0;\n\tend else if (!OPT_ALIGNMENT_ERR\n\t\t&& ((M_AXI_AWVALID && M_AXI_AWREADY) // && misaligned_aw_request\n\t\t|| (M_AXI_ARVALID && M_AXI_ARREADY))) // && misaligned_request))\n\tbegin\n\t\tM_AXI_AWADDR[AW-1:AXILSB] <= M_AXI_AWADDR[AW-1:AXILSB] + 1;\n\t\tM_AXI_AWADDR[AXILSB-1:0] <= 0;\n\tend\n\n\talways @(*)\n\t\tM_AXI_ARADDR = M_AXI_AWADDR;\n\t// }}}\n\n\t// Is this request misaligned?\n\t// {{{\n\talways @(*)\n\tcasez(i_op[2:1])\n\t// Full word\n\t2'b0?: w_misaligned = (i_addr[AXILSB-1:0]+3) >= (1<<AXILSB);\n\t// Half word\n\t2'b10: w_misaligned = (i_addr[AXILSB-1:0]+1) >= (1<<AXILSB);\n\t// Bytes are always aligned\n\t2'b11: w_misaligned = 1'b0;\n\tendcase\n\n\talways @(*)\n\tbegin\n\t\tw_misalignment_err = w_misaligned && OPT_ALIGNMENT_ERR;\n\t\tif (OPT_LOCK && i_lock)\n\t\tbegin\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b0?: w_misalignment_err = (|i_addr[1:0]);\n\t\t\t2'b10: w_misalignment_err = i_addr[0];\n\t\t\tdefault:\n\t\t\t\tw_misalignment_err = 1'b0;\n\t\t\tendcase\n\t\tend\n\tend\n\t// }}}\n\n\t// wide_wdata, wide_wstrb\n\t// {{{\n\talways @(*)\n\tif (SWAP_WSTRB)\n\tbegin : BACKWARDS_ORDER\n\t\t// {{{\n\t\tcasez(i_op[2:1])\n\t\t2'b10: wide_wdata\n\t\t\t= { i_data[15:0], {(2*C_AXI_DATA_WIDTH-16){1'b0}} }\n\t\t\t\t>> (i_addr[AXILSB-1:0] * 8);\n\t\t2'b11: wide_wdata\n\t\t\t= { i_data[7:0], {(2*C_AXI_DATA_WIDTH-8){1'b0}} }\n\t\t\t\t>> (i_addr[AXILSB-1:0] * 8);\n\t\tdefault: wide_wdata\n\t\t\t= ({ i_data, {(2*C_AXI_DATA_WIDTH-32){ 1'b0 }} }\n\t\t\t\t>> (i_addr[AXILSB-1:0] * 8));\n\t\tendcase\n\n\t\tcasez(i_op[2:1])\n\t\t2'b0?: wide_wstrb\n\t\t\t= { 4'b1111, {(2*C_AXI_DATA_WIDTH/8-4){1'b0}} } >> i_addr[AXILSB-1:0];\n\t\t2'b10: wide_wstrb\n\t\t\t= { 2'b11, {(2*C_AXI_DATA_WIDTH/8-2){1'b0}} } >> i_addr[AXILSB-1:0];\n\t\t2'b11: wide_wstrb\n\t\t\t= { 1'b1, {(2*C_AXI_DATA_WIDTH/8-1){1'b0}} } >> i_addr[AXILSB-1:0];\n\t\tendcase\n\t\t// }}}\n\tend else begin : LITTLE_ENDIAN_DATA\n\t\t// {{{\n\t\tcasez(i_op[2:1])\n\t\t2'b10: wide_wdata\n\t\t\t= { {(2*C_AXI_DATA_WIDTH-16){1'b0}}, i_data[15:0] }\n\t\t\t\t\t<< (8*i_addr[AXILSB-1:0]);\n\t\t2'b11: wide_wdata\n\t\t\t= { {(2*C_AXI_DATA_WIDTH-8){1'b0}}, i_data[7:0] }\n\t\t\t\t\t<< (8*i_addr[AXILSB-1:0]);\n\t\tdefault: wide_wdata\n\t\t\t= { {(2*C_AXI_DATA_WIDTH-32){1'b0}}, i_data }\n\t\t\t\t\t<< (8*i_addr[AXILSB-1:0]);\n\t\tendcase\n\n\t\tcasez(i_op[2:1])\n\t\t2'b0?: wide_wstrb\n\t\t\t= { {(2*C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b1111} << i_addr[AXILSB-1:0];\n\t\t2'b10: wide_wstrb\n\t\t\t= { {(2*C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b0011} << i_addr[AXILSB-1:0];\n\t\t2'b11: wide_wstrb\n\t\t\t= { {(2*C_AXI_DATA_WIDTH/8-4){1'b0}}, 4'b0001} << i_addr[AXILSB-1:0];\n\t\tendcase\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// WDATA and WSTRB\n\t// {{{\n\tinitial\tM_AXI_WDATA = 0;\n\tinitial\tM_AXI_WSTRB = 0;\n\tinitial\tnext_wdata  = 0;\n\tinitial\tnext_wstrb  = 0;\n\talways @(posedge i_clk)\n\tif (i_stb)\n\tbegin\n\t\tif (SWAP_WSTRB)\n\t\tbegin : BACKWARDS_ORDER_REG\n\t\t\t// {{{\n\t\t\t{ M_AXI_WDATA, next_wdata } <= wide_wdata;\n\t\t\t{ M_AXI_WSTRB, next_wstrb } <= wide_wstrb;\n\t\t\t// }}}\n\t\tend else begin\n\t\t\t// {{{\n\t\t\t{ next_wdata, M_AXI_WDATA } <= wide_wdata;\n\t\t\t{ next_wstrb, M_AXI_WSTRB } <= wide_wstrb;\n\t\t\t// }}}\n\t\tend\n\n\t\tif (OPT_ALIGNMENT_ERR)\n\t\t\t{ next_wstrb, next_wdata } <= 0;\n\n\tend else if ((OPT_LOWPOWER || !OPT_ALIGNMENT_ERR) && M_AXI_WREADY)\n\tbegin\n\t\tM_AXI_WDATA <= next_wdata;\n\t\tM_AXI_WSTRB <= next_wstrb;\n\t\tif (OPT_LOWPOWER)\n\t\t\t{ next_wdata, next_wstrb } <= 0;\n\tend\n\t// }}}\n\n\tgenerate if (OPT_ALIGNMENT_ERR)\n\tbegin : GEN_ALIGNMENT_ERR\n\t\t// {{{\n\t\t// Generate an error on any misaligned request\n\t\tassign\tmisaligned_request = 1'b0;\n\n\t\tassign\tmisaligned_aw_request = 1'b0;\n\t\tassign\tpending_err = 1'b0;\n\t\t// }}}\n\tend else begin : GEN_REALIGNMENT\n\t\t// {{{",
            "reg r_misaligned_request, r_misaligned_aw_request,\n\t\t\tr_pending_err;\n\n\t\t// misaligned_request\n\t\t// {{{\n\t\tinitial\tr_misaligned_request = 0;\n\t\talways @(posedge i_clk)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_misaligned_request <= 0;\n\t\telse if (i_stb && !o_err && !i_cpu_reset && !bus_abort)\n\t\t\tr_misaligned_request <= w_misaligned && !w_misalignment_err;\n\t\telse if ((M_AXI_WVALID && M_AXI_WREADY)\n\t\t\t\t\t|| (M_AXI_ARVALID && M_AXI_ARREADY))\n\t\t\tr_misaligned_request <= 1'b0;\n\n\t\tassign\tmisaligned_request = r_misaligned_request;\n\t\t// }}}\n\n\t\t// misaligned_aw_request\n\t\t// {{{\n\t\tinitial\tr_misaligned_aw_request = 0;\n\t\talways @(posedge i_clk)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_misaligned_aw_request <= 0;\n\t\telse if (i_stb && !o_err && !i_cpu_reset && !write_abort)\n\t\t\tr_misaligned_aw_request <= w_misaligned && i_op[0] && !w_misalignment_err;\n\t\telse if (M_AXI_AWREADY)\n\t\t\tr_misaligned_aw_request <= 1'b0;\n\n\t\tassign\tmisaligned_aw_request = r_misaligned_aw_request;\n\t\t// }}}\n\n\t\t// pending_err\n\t\t// {{{\n\t\tinitial\tr_pending_err = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_cpu_reset || i_stb || o_err || r_flushing)\n\t\t\tr_pending_err <= 1'b0;\n\t\telse if ((M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t\t|| (M_AXI_RVALID && M_AXI_RRESP[1]))\n\t\t\tr_pending_err <= 1'b1;\n\n\t\tassign\tpending_err = r_pending_err;\n\t\t// }}}\n\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (pending_err)\n\t\t\tassert(r_flushing || o_err);\n`endif\n\t\t// }}}\n\tend endgenerate\n\n\t// AxOTHER\n\t// {{{",
            "localparam [3:0]\tAXI_NON_CACHABLE_BUFFERABLE = 4'h3;",
            "localparam [3:0]\tOPT_CACHE = AXI_NON_CACHABLE_BUFFERABLE;",
            "localparam [2:0]\tAXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS = 3'h0;",
            "localparam [2:0]\tOPT_PROT=AXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS;\n\n\tassign\tM_AXI_AWID    = AXI_ID;\n\tassign\tM_AXI_AWLEN   = 0;\n\tassign\tM_AXI_AWBURST = AXI_INCR;\n\tassign\tM_AXI_AWCACHE = M_AXI_AWLOCK ? 0:OPT_CACHE;\n\tassign\tM_AXI_AWPROT  = OPT_PROT;\n\tassign\tM_AXI_AWQOS   = OPT_QOS;\n\tassign\tM_AXI_WLAST   = 1;\n\n\tassign\tM_AXI_ARID    = AXI_ID;\n\tassign\tM_AXI_ARLEN   = 0;\n\tassign\tM_AXI_ARBURST = AXI_INCR;\n\tassign\tM_AXI_ARCACHE = M_AXI_ARLOCK ? 0:OPT_CACHE;\n\tassign\tM_AXI_ARPROT  = OPT_PROT;\n\tassign\tM_AXI_ARQOS   = OPT_QOS;\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read transaction FIFO\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// wraddr\n\t// {{{\n\tinitial\twraddr = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (bus_abort || flush_request)\t// bus_abort includes i_cpu_reset\n\t\twraddr <= 0;\n\telse if ((M_AXI_ARVALID && M_AXI_ARREADY) || (M_AXI_WVALID && M_AXI_WREADY))\n\t\twraddr <= wraddr + 1;\n\t// }}}\n\n\t// rdaddr\n\t// {{{\n\tinitial\trdaddr = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (bus_abort || r_flushing)\n\t\trdaddr <= 0;\n\telse if (M_AXI_RVALID||M_AXI_BVALID)\n\t\trdaddr <= rdaddr + 1;\n\t// }}}\n\n\t// ar_o",
            "reg , ar_op, adr_lsb\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (i_stb)\n\t\t{ fifo_gie, ar_o",
            "reg , ar_op, adr_lsb } <= { i_o",
            "reg , i_op[2:1], i_addr[AXILSB-1:0] };\n\telse if ((M_AXI_ARVALID && M_AXI_ARREADY)||(M_AXI_WVALID && M_AXI_WREADY))\n\t\tadr_lsb <= 0;\n\t// }}}\n\n\t// fifo_data\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif ((M_AXI_ARVALID && M_AXI_ARREADY) || (M_AXI_WVALID && M_AXI_WREADY))\n\t\tfifo_data[wraddr[LGPIPE-1:0]] <= { M_AXI_ARVALID, ar_o",
            "reg ,ar_op,\n\t\t\t\tmisaligned_request, adr_lsb };\n\n\talways @(*)\n\t\tfifo_read_data = fifo_data[rdaddr[LGPIPE-1:0]];\n\n\tassign\t{ fifo_read_op, fifo_return_",
            "reg , fifo_op,\n\t\t\tfifo_misaligned, fifo_lsb } = fifo_read_data;\n\t// }}}\n\n\t// r_pc\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!OPT_LOCK)\n\t\tr_pc <= 0;\n\telse if (i_stb && i_lock && !i_op[0])\n\t\tr_pc <= i_restart_pc;\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read return generation\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// o_valid\n\t// {{{\n\tinitial\to_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || r_flushing)\n\t\to_valid <= 1'b0;\n\telse if (OPT_LOCK && r_lock)\n\t\to_valid <= (M_AXI_RVALID && M_AXI_RRESP == EXOKAY)\n\t\t\t||(M_AXI_BVALID && M_AXI_BRESP == OKAY);\n\telse if (OPT_ALIGNMENT_ERR && i_stb && w_misaligned)\n\t\to_valid <= 1'b0;\n\telse\n\t\to_valid <= M_AXI_RVALID && !M_AXI_RRESP[1] // && !pending_err\n\t\t\t\t&& !fifo_misaligned;\n\t// }}}\n\n\t// o_w",
            "reg // {{{\n\talways @(posedge i_clk)\n\tbegin\n\t\to_w",
            "reg <= { fifo_gie, fifo_return_",
            "reg };\n\t\tif (OPT_LOCK && r_lock && M_AXI_BVALID)\n\t\t\to_w",
            "reg [3:0] <= 4'hf;\n\tend\n\t// }}}\n\n\t// o_result, misdata\n\t// {{{\n\t// Need to realign any returning data\n\t// wide_return\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tif (fifo_misaligned && !OPT_ALIGNMENT_ERR)\n\t\t\t\twide_return = { misdata, M_AXI_RDATA }\n\t\t\t\t\t\t\t<< (8*fifo_lsb);\n\t\t\telse\n\t\t\t\twide_return = { M_AXI_RDATA, {(DW){1'b0}} }\n\t\t\t\t\t\t\t<< (8*fifo_lsb);\n\n\t\tend else begin\n\t\t\tif (fifo_misaligned && !OPT_ALIGNMENT_ERR)\n\t\t\t\twide_return = { M_AXI_RDATA, misdata } >> (8*fifo_lsb);\n\t\t\telse\n\t\t\t\twide_return = { {(C_AXI_DATA_WIDTH){1'b0}}, M_AXI_RDATA }\n\t\t\t\t\t>> (8*fifo_lsb);\n\t\tend\n\n\t\tif (OPT_LOWPOWER && (!M_AXI_RVALID || M_AXI_RRESP[1]))\n\t\t\twide_return = 0;\n\tend\n\n\talways @(*)\n\tbegin\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\n\t\t\tpre_result = 32'h0;\n\t\t\tcasez(fifo_op)\n\t\t\t2'b10: pre_result[15:0] = {\n\t\t\t\t\twide_return[(2*DW)-1:(2*DW)-16] };\n\t\t\t2'b11: pre_result[7:0] = {\n\t\t\t\t\twide_return[(2*DW)-1:(2*DW)-8] };\n\t\t\tdefault: pre_result[31:0] = wide_return[(2*DW-1):(2*DW-32)];\n\t\t\tendcase\n\n\t\tend else\n\t\t\tpre_result = wide_return[31:0];\n\tend\n\t// }}}\n\n\t// misdata\n\t// {{{\n\talways @(posedge i_clk)\n\tif (OPT_ALIGNMENT_ERR)\n\t\tmisdata <= 0;\n\telse if (M_AXI_RVALID)\n\tbegin\n\t\tif (fifo_misaligned)\n\t\t\tmisdata <= M_AXI_RDATA;\n\t\telse\n\t\t\tmisdata <= 0;\n\tend\n\t// }}}\n\n\t// o_result\n\t// {{{\n\talways @(posedge i_clk)\n\tif (OPT_LOWPOWER && (!S_AXI_ARESETN || r_flushing || i_cpu_reset))\n\tbegin\n\t\to_result <= 0;\n\tend else if (OPT_LOCK && M_AXI_BVALID && (!OPT_LOWPOWER || (r_lock && M_AXI_BRESP == OKAY)))\n\tbegin\n\t\to_result <= 0;\n\t\to_result[AW-1:0] <= r_pc;\n\tend else if (!OPT_LOWPOWER || M_AXI_RVALID)\n\tbegin\n\n\t\to_result <= pre_result[31:0];\n\n\t\tif (OPT_SIGN_EXTEND)\n\t\tbegin\n\t\t\t// {{{\n\t\t\t// verilator coverage_off\n\t\t\t// Optionally sign extend the return result.\n\t\t\t//   This would be contrary to the ZipCPU ISA\n\t\t\tcase(fifo_op)\n\t\t\t2'b10: o_result[31:16] <= {(16){pre_result[15]}};\n\t\t\t2'b11: o_result[31: 8] <= {(24){pre_result[7]}};\n\t\t\tdefault: begin end\n\t\t\tendcase\n\t\t\t// verilator coverage_on\n\t\t\t// }}}\n\t\tend else if (fifo_op[1])\n\t\tbegin\n\t\t\t// {{{\n\t\t\tif (fifo_op[0])\n\t\t\t\to_result[31: 8] <= 0;\n\t\t\telse\n\t\t\t\to_result[31:16] <= 0;\n\t\t\t// }}}\n\t\tend\n\n\tend\n\t// }}}\n\t// }}}\n\n\t// o_err - report bus errors back to the CPU\n\t// {{{\n\tinitial\to_err = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || r_flushing || o_err)\n\t\to_err <= 1'b0;\n\telse if (i_stb && w_misalignment_err)\n\t\to_err <= 1'b1;\n\telse if (OPT_LOCK && r_lock)\n\t\to_err <= (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t||(M_AXI_RVALID && M_AXI_RRESP != EXOKAY);\n\telse if (M_AXI_BVALID || M_AXI_RVALID)\n\t\to_err <= (M_AXI_BVALID && M_AXI_BRESP[1])\n\t\t\t|| (M_AXI_RVALID && M_AXI_RRESP[1]);\n\telse\n\t\to_err <= 1'b0;\n\t// }}}\n\n\t// Return xREADY -- always ready\n\t// {{{\n\tassign\tM_AXI_RREADY = 1;\n\tassign\tM_AXI_BREADY = 1;\n\t// }}}\n\n\t// }}}\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, M_AXI_RRESP[0], M_AXI_BRESP[0],\n\t\t\tM_AXI_BID, M_AXI_RID, M_AXI_RLAST,\n\t\t\t// i_addr[31:C_AXI_ADDR_WIDTH],\n\t\t\t(&i_addr),\n\t\t\t// wide_return[2*C_AXI_DATA_WIDTH-1:32],\n\t\t\tpending_err, fifo_read_op,\n\t\t\tnone_outstanding };\n\n\tgenerate if (SWAP_WSTRB)\n\tbegin : GEN_UNUSED",
            "wire wide_unused;\n\n\t\tif (SWAP_WSTRB)\n\t\tbegin : GEN_UNUSED_SWAP\n\t\t\tassign\twide_unused = &{ 1'b0,\n\t\t\t\t\twide_return[2*DW-32-1:0] };\n\t\tend else begin : GEN_UNUSED_WIDE\n\t\t\tassign\twide_unused = &{ 1'b0, wide_return[2*DW-1:32] };\n\t\tend\n\tend endgenerate\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal property section\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Declarations\n\t// {{{\n`define\tASSERT\t\tassert\n`ifndef\tBMC_ASSERT\n`define\tBMC_ASSERT\tassume\n`endif\n`ifdef\tAXILPIPE\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "localparam F_LGDEPTH = (LGPIPE > 9) ? (LGPIPE+1) : 10;\n\t// Verilator lint_off UNDRIVEN\n\t(* anyseq *)",
            "wire f_active_lock;\n\t(* anyconst *)",
            "reg [LGPIPE:0]\t\tf_first_addr;\n\t(* anyseq *)",
            "reg [4:0]\tf_a",
            "reg ;\n\t// Verilator lint_on  UNDRIVEN",
            "wire [F_LGDEPTH-1:0]\tfaxi_awr_nbursts,\n\t\t\t\tfaxi_rd_nbursts, faxi_rd_outstanding;",
            "wire [8:0]\t\tfaxi_wr_pending;",
            "wire [IW-1:0]\tfaxi_wr_checkid;",
            "wire faxi_wr_ckvalid;",
            "wire [F_LGDEPTH-1:0]\tfaxi_wrid_nbursts;",
            "wire [AW-1:0]\tfaxi_wr_addr;",
            "wire [7:0]\t\tfaxi_wr_incr;",
            "wire [1:0]\t\tfaxi_wr_burst;",
            "wire [2:0]\t\tfaxi_wr_size;",
            "wire [7:0]\t\tfaxi_wr_len;",
            "wire faxi_wr_lockd;\n\t//",
            "wire [IW-1:0]\tfaxi_rd_checkid;",
            "wire faxi_rd_ckvalid;",
            "wire [8:0]\t\tfaxi_rd_cklen;",
            "wire [AW-1:0]\tfaxi_rd_ckaddr;",
            "wire [7:0]\t\tfaxi_rd_ckincr;",
            "wire [1:0]\t\tfaxi_rd_ckburst;",
            "wire [2:0]\t\tfaxi_rd_cksize;",
            "wire [7:0]\t\tfaxi_rd_ckarlen;",
            "wire faxi_rd_cklockd;",
            "wire [F_LGDEPTH-1:0]\tfaxi_rdid_nbursts, faxi_rdid_outstanding;",
            "wire [F_LGDEPTH-1:0]\tfaxi_rdid_ckign_nbursts, faxi_rdid_ckign_outstanding;",
            "wire [1:0]\t\tfaxi_ex_state;",
            "wire faxi_ex_checklock;",
            "wire [F_LGDEPTH-1:0]\tfaxi_rdid_bursts_to_lock;",
            "wire [F_LGDEPTH-1:0]\tfaxi_wrid_bursts_to_exwrite;",
            "reg [AW-1:0]\tf_exlock_addr;",
            "wire [AW-1:0]\tfaxi_exreq_addr;",
            "wire [7:0]\t\tf_exlock_len, faxi_exreq_len;",
            "wire [1:0]\t\tf_exlock_burst, faxi_exreq_burst;",
            "wire [2:0]\t\tfaxi_exreq_size;",
            "reg [2:0]\t\tf_exlock_size;\n\t// Verilator lint_off UNUSED",
            "wire faxi_exlock_return;\n\t// Verilator lint_on  UNUSED",
            "reg [LGPIPE:0]\tf_fifo_fill;",
            "reg f_clrfifo, f_wrfifo, f_rdfifo;",
            "wire misaligned_response_pending;",
            "reg [1:0]\tf_fsmfifo;",
            "reg [LGPIPE:0]\t\tf_next_addr,\n\t\t\t\tf_penu_addr, f_last_written,\n\t\t\t\tf_distance_to_first, f_distance_to_next;",
            "reg [FIFO_WIDTH-1:0]\tf_first_data, f_next_data, f_penu_data;",
            "reg [4:0]\tf_first_return_",
            "reg , f_next_return_",
            "reg , f_return_",
            "reg ,\n\t\t\tf_penu_return_",
            "reg ;",
            "reg f_first_in_fifo,\tf_next_in_fifo,\n\t\t\tf_first_misaligned,\tf_next_misaligned,\n\t\t\tf_this_misaligned,\tf_penu_misaligned,\n\t\t\tf_first_read_cycle,\tf_next_read_cycle,\n\t\t\tf_this_read_cycle,\tf_penu_read_cycle;",
            "wire [LGPIPE:0]\tcpu_outstanding;",
            "wire cpu_gie, cpu_pc, cpu_read_cycle;",
            "wire [4:0]\t\tcpu_last_",
            "reg , cpu_addr_",
            "reg ;",
            "reg [4:0]\t\tf_ar_a",
            "reg ;",
            "reg f_done;",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(!S_AXI_ARESETN);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus property checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tfaxi_master #(\n\t\t// {{{\n\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),\n\t\t.C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),\n\t\t.OPT_MAXBURST(8'h0),\n\t\t.OPT_EXCLUSIVE(OPT_LOCK),\n\t\t.F_OPT_ASSUME_RESET(1'b1),\n\t\t.F_LGDEPTH(F_LGDEPTH)\n\t\t// }}}\n\t) faxi (\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN),\n\t\t// Write interface\n\t\t// {{{\n\t\t.i_axi_awvalid(M_AXI_AWVALID),\n\t\t.i_axi_awready(M_AXI_AWREADY),\n\t\t.i_axi_awid(   M_AXI_AWID),\n\t\t.i_axi_awaddr( M_AXI_AWADDR),\n\t\t.i_axi_awlen(  M_AXI_AWLEN),\n\t\t.i_axi_awsize( M_AXI_AWSIZE),\n\t\t.i_axi_awburst(M_AXI_AWBURST),\n\t\t.i_axi_awlock( M_AXI_AWLOCK),\n\t\t.i_axi_awcache(M_AXI_AWCACHE),\n\t\t.i_axi_awprot( M_AXI_AWPROT),\n\t\t.i_axi_awqos(  M_AXI_AWQOS),\n\t\t//\n\t\t.i_axi_wvalid(M_AXI_WVALID),\n\t\t.i_axi_wready(M_AXI_WREADY),\n\t\t.i_axi_wdata( M_AXI_WDATA),\n\t\t.i_axi_wstrb( M_AXI_WSTRB),\n\t\t.i_axi_wlast( M_AXI_WLAST),\n\t\t//\n\t\t.i_axi_bvalid(M_AXI_BVALID),\n\t\t.i_axi_bready(M_AXI_BREADY),\n\t\t.i_axi_bid(   M_AXI_BID),\n\t\t.i_axi_bresp( M_AXI_BRESP),\n\t\t// }}}\n\t\t// Read interface\n\t\t// {{{\n\t\t.i_axi_arvalid(M_AXI_ARVALID),\n\t\t.i_axi_arready(M_AXI_ARREADY),\n\t\t.i_axi_arid(   M_AXI_ARID),\n\t\t.i_axi_araddr( M_AXI_ARADDR),\n\t\t.i_axi_arlen(  M_AXI_ARLEN),\n\t\t.i_axi_arsize( M_AXI_ARSIZE),\n\t\t.i_axi_arburst(M_AXI_ARBURST),\n\t\t.i_axi_arlock( M_AXI_ARLOCK),\n\t\t.i_axi_arcache(M_AXI_ARCACHE),\n\t\t.i_axi_arprot( M_AXI_ARPROT),\n\t\t.i_axi_arqos(  M_AXI_ARQOS),\n\t\t//\n\t\t.i_axi_rvalid(M_AXI_RVALID),\n\t\t.i_axi_rready(M_AXI_RREADY),\n\t\t.i_axi_rid(   M_AXI_RID),\n\t\t.i_axi_rdata( M_AXI_RDATA),\n\t\t.i_axi_rresp( M_AXI_RRESP),\n\t\t.i_axi_rlast( M_AXI_RLAST),\n\t\t// }}}\n\t\t// Induction information\n\t\t//\n\t\t.f_axi_awr_nbursts(faxi_awr_nbursts),\n\t\t.f_axi_wr_pending(faxi_wr_pending),\n\t\t.f_axi_rd_nbursts(faxi_rd_nbursts),\n\t\t.f_axi_rd_outstanding(faxi_rd_outstanding),\n\t\t// WR_COUNT\n\t\t// {{{\n\t\t.f_axi_wr_checkid(  faxi_wr_checkid),\n\t\t.f_axi_wr_ckvalid(  faxi_wr_ckvalid),\n\t\t.f_axi_wrid_nbursts(faxi_wrid_nbursts),\n\t\t.f_axi_wr_addr(     faxi_wr_addr),\n\t\t.f_axi_wr_incr(     faxi_wr_incr),\n\t\t.f_axi_wr_burst(    faxi_wr_burst),\n\t\t.f_axi_wr_size(     faxi_wr_size),\n\t\t.f_axi_wr_len(      faxi_wr_len),\n\t\t.f_axi_wr_lockd(    faxi_wr_lockd),\n\t\t// }}}\n\t\t// RD_COUNT\n\t\t// {{{\n\t\t.f_axi_rd_checkid(faxi_rd_checkid),\n\t\t.f_axi_rd_ckvalid(faxi_rd_ckvalid),\n\t\t.f_axi_rd_cklen(  faxi_rd_cklen),\n\t\t.f_axi_rd_ckaddr( faxi_rd_ckaddr),\n\t\t.f_axi_rd_ckincr( faxi_rd_ckincr),\n\t\t.f_axi_rd_ckburst(faxi_rd_ckburst),\n\t\t.f_axi_rd_cksize( faxi_rd_cksize),\n\t\t.f_axi_rd_ckarlen(faxi_rd_ckarlen),\n\t\t.f_axi_rd_cklockd(faxi_rd_cklockd),\n\t\t//\n\t\t.f_axi_rdid_nbursts(faxi_rdid_nbursts),\n\t\t.f_axi_rdid_outstanding(faxi_rdid_outstanding),\n\t\t.f_axi_rdid_ckign_nbursts(faxi_rdid_ckign_nbursts),\n\t\t.f_axi_rdid_ckign_outstanding(faxi_rdid_ckign_outstanding),\n\t\t// }}}\n\t\t// Exclusive access handling\n\t\t// {{{\n\t\t.f_axi_ex_state(faxi_ex_state),\n\t\t.f_axi_ex_checklock(faxi_ex_checklock),\n\t\t.f_axi_rdid_bursts_to_lock(faxi_rdid_bursts_to_lock),\n\t\t.f_axi_wrid_bursts_to_exwrite(faxi_wrid_bursts_to_exwrite),\n\t\t.i_active_lock( f_active_lock),\n\t\t.i_exlock_addr( f_exlock_addr),\n\t\t.i_exlock_len(  f_exlock_len),\n\t\t.i_exlock_burst(f_exlock_burst),\n\t\t.i_exlock_size( f_exlock_size),\n\t\t.f_axi_exreq_addr( faxi_exreq_addr),\n\t\t.f_axi_exreq_len(  faxi_exreq_len),\n\t\t.f_axi_exreq_burst(faxi_exreq_burst),\n\t\t.f_axi_exreq_size( faxi_exreq_size),\n\t\t.f_axi_exreq_return( faxi_exlock_return)\n\t\t// }}}\n\t\t//\n\t\t// }}}\n\t);\n\n\n\talways @(*)\n\t\tf_fifo_fill = wraddr - rdaddr;\n\n\talways @(*)\n\tbegin\n\t\tif (misaligned_request)\n\t\t\t`ASSERT(M_AXI_WVALID || M_AXI_ARVALID);\n\t\tif (misaligned_aw_request)\n\t\t\t`ASSERT(M_AXI_AWVALID);\n\n\t\tif (M_AXI_ARVALID || faxi_rd_outstanding > 0)\n\t\tbegin\n\t\t\tassert(faxi_awr_nbursts == 0);\n\t\t\tassert(!M_AXI_AWVALID);\n\t\t\tassert(!M_AXI_WVALID);\n\t\tend\n\n\t\tif (faxi_awr_nbursts > 0 || M_AXI_AWVALID || M_AXI_WVALID)\n\t\tbegin\n\t\t\tassert(faxi_rd_outstanding == 0);\n\t\t\tassert(!M_AXI_ARVALID);\n\t\tend\n\n\t\t// Rule: Only one of the two VALID's may be valid, never both\n\t\t`ASSERT(!M_AXI_RVALID || (!M_AXI_AWVALID && !M_AXI_WVALID));\n\n\t\tassert({ 5'h0, beats_outstanding }\n\t\t\t+ ((misaligned_request && !misaligned_aw_request && M_AXI_WVALID) ? 1:0)\n\t\t\t+ ((M_AXI_WVALID && !M_AXI_AWVALID) ? 1:0)\n\t\t\t== faxi_rd_outstanding + faxi_awr_nbursts);\n\n\t\t/*\n\t\tassert(beats_outstanding\n\t\t\t+ ((misaligned_aw_request && !misaligned_request) ? 1:0)\n\t\t\t+ ((M_AXI_AWVALID && !M_AXI_WVALID) ? 1:0)\n\t\t\t== faxi_rd_outstanding + faxi_awr_nbursts);\n\t\t*/\n\n\t\tif (OPT_ALIGNMENT_ERR && !r_flushing\n\t\t\t\t&& (faxi_rd_outstanding > 0 || M_AXI_ARVALID))\n\t\tbegin\n\t\t\tassert({ 5'h0, f_fifo_fill } == faxi_rd_outstanding);\n\t\tend else if (OPT_ALIGNMENT_ERR && !r_flushing\n\t\t\t\t&& (faxi_awr_nbursts > 0))\n\t\tbegin\n\t\t\tif (M_AXI_WVALID == M_AXI_AWVALID)\n\t\t\tbegin\n\t\t\t\tassert({ 5'h0, f_fifo_fill } == faxi_awr_nbursts);\n\t\t\tend else if (M_AXI_WVALID)\n\t\t\t\tassert({ 5'h0, f_fifo_fill } == faxi_awr_nbursts-1);\n\t\tend\n\n\t\tif (faxi_rd_outstanding == 0 && faxi_awr_nbursts == 0)\n\t\t\tassert(f_fifo_fill == 0);\n\tend\n\n\t// Internal write checks\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tif (faxi_wr_checkid == AXI_ID)\n\t\tbegin\n\t\t\tassert(faxi_wrid_nbursts == faxi_awr_nbursts);\n\t\tend else\n\t\t\tassert(faxi_wrid_nbursts == 0);\n\n\t\tif (M_AXI_AWVALID)\n\t\tbegin\n\t\t\tassert(M_AXI_WVALID);\n\t\t\tif (!misaligned_aw_request && misaligned_request)\n\t\t\tbegin\n\t\t\t\tassert(faxi_wr_pending == 1);\n\t\t\tend else\n\t\t\t\tassert(faxi_wr_pending == 0);\n\t\tend\n\n\t\tif (faxi_wr_ckvalid)\n\t\tbegin\n\t\t\tassert(faxi_wr_pending == (M_AXI_WVALID ? 1:0));\n\t\t\t// assert(faxi_wr_addr == );\n\t\t\t// assert(faxi_wr_incr == );\n\t\t\tassert(faxi_wr_burst == AXI_INCR);\n\t\t\t// assert(faxi_wr_size  == AXI_INCR);\n\t\t\tassert(faxi_wr_len  == 0);\n\t\t\tassert(r_flushing || faxi_wr_lockd == r_lock);\n\t\tend\n\tend\n\t// }}}\n\n\t// Internal read checks\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tif (faxi_rd_ckvalid)\n\t\tbegin\n\t\t\tassert(faxi_rd_checkid == AXI_ID);\n\t\t\t// assert(faxi_rd_cklen == AXI_ID);\n\t\t\t// assert(faxi_rd_ckaddr == AXI_ID);\n\t\t\t// assert(faxi_rd_ckincr == AXI_INCR);\n\t\t\tassert(faxi_rd_ckburst == AXI_INCR);\n\t\t\t// assert(faxi_rd_cksize  == AXI_INCR);\n\t\t\tassert(faxi_rd_ckarlen == 8'h00);\n\t\t\tassert(r_flushing || faxi_rd_cklockd == r_lock);\n\t\tend\n\n\t\tif (faxi_rd_checkid == AXI_ID)\n\t\tbegin\n\t\t\tassert(faxi_rd_nbursts == faxi_rdid_nbursts);\n\t\tend else\n\t\t\tassert(faxi_rdid_nbursts == 0);\n\n\t\tassert(faxi_rd_nbursts == faxi_rd_outstanding);\n\t\tassert(faxi_rdid_nbursts == faxi_rdid_outstanding);\n\n\t\tif (faxi_rd_nbursts > 1)\n\t\t\tassert(!r_lock);\n\tend\n\t// }}}\n\n\talways @(*)\n\tif (!o_busy)\n\t\t`ASSERT(!r_flushing);\n\n\t// Following any i_stb request, assuming we are idle, immediately\n\t// begin a bus transaction\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_stb && !o_err))\n\t\t&&(!$past(o_busy))&&($past(!i_cpu_reset)))\n\tbegin\n\t\tif (OPT_LOCK && $past(w_misalignment_err))\n\t\tbegin\n\t\t\t`ASSERT(o_err && !o_busy);\n\t\tend else\n\t\t\t`ASSERT(o_busy || (OPT_ALIGNMENT_ERR && o_err));\n\tend\n\n\talways @(*)\n\tif (o_busy && !misaligned_request && OPT_LOWPOWER)\n\tbegin\n\t\tassert(next_wdata == 0);\n\t\tassert(next_wstrb == 0);\n\tend\n\n\t// o_err checking\n\t// {{{\n\t// If a transaction ends in an error, send o_err on the",
            "output port.\n\talways @(posedge i_clk)\n\tif (f_past_valid)\n\tbegin\n\t\tif ($past(i_cpu_reset || r_flushing || o_err))\n\t\tbegin\n\t\t\t`ASSERT(!o_err);\n\t\tend else if ($past(M_AXI_BVALID && M_AXI_BRESP[1]))\n\t\tbegin\n\t\t\t`ASSERT(o_err);\n\t\tend else if ($past(M_AXI_RVALID && M_AXI_RRESP[1]))\n\t\tbegin\n\t\t\t`ASSERT(o_err);\n\t\tend else if ($past(r_lock && M_AXI_RVALID && M_AXI_RRESP != EXOKAY))\n\t\tbegin\n\t\t\t`ASSERT(o_err);\n\t\tend else if ($past(i_stb && w_misalignment_err))\n\t\tbegin\n\t\t\t`ASSERT(o_err);\n\t\tend else if (!$past(pending_err))\n\t\t\t`ASSERT(!o_err);\n\tend\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(!i_cpu_reset))&&($past(i_stb)))\n\tbegin\n\t\t// On a write, assert o_wb_we should be true\n\t\tassert($past(i_op[0] && !o_err\n\t\t\t&& (!M_AXI_BVALID || !M_AXI_BRESP[1])\n\t\t\t&& (!w_misalignment_err))\n\t\t\t\t== (M_AXI_AWVALID && M_AXI_WVALID));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_cpu_reset)))\n\t\t`ASSUME(!i_stb);\n\n\talways @(*)\n\tif (!S_AXI_ARESETN)\n\t\t`ASSUME(i_cpu_reset);\n\n\t// misaligned_response_pending\n\t// {{{\n\tgenerate if (OPT_ALIGNMENT_ERR)\n\tbegin : NO_MISALIGNED_RESPONSES\n\n\t\tassign\tmisaligned_response_pending = 0;\n\n\tend else begin : MISALIGNED_RESPONSE_PENDING",
            "reg r_misaligned_response_pending;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tr_misaligned_response_pending = fifo_misaligned;\n\t\t\tif (wraddr == rdaddr)\n\t\t\t\tr_misaligned_response_pending = 0;\n\t\tend\n\n\t\tassign\tmisaligned_response_pending\n\t\t\t\t= r_misaligned_response_pending;\n\tend endgenerate\n\t// }}}\n\n\n\talways @(*)\n\tif (o_busy)\n\tbegin\n\t\tcover(i_stb);\n\t\tcover(o_valid);\n\t\tcover(o_err);\n\tend else begin\n\t\tcover(o_valid);\n\t\tcover(o_err);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Zero on idle checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (OPT_LOWPOWER)\n\tbegin\n\t\talways @(*)\n\t\tif (!M_AXI_AWVALID && !M_AXI_ARVALID)\n\t\t\t`ASSERT(M_AXI_AWADDR == 0);\n\n\t\talways @(*)\n\t\tif (!M_AXI_WVALID)\n\t\tbegin\n\t\t\t`ASSERT(M_AXI_WDATA == 0);\n\t\t\t`ASSERT(M_AXI_WSTRB == 0);\n\n\t\t\t`ASSERT(next_wdata == 0);\n\t\t\t`ASSERT(next_wstrb == 0);\n\t\tend\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// FIFO property checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tbegin\n\t\t// {{{\n\t\tf_next_addr = f_first_addr + 1;\n\t\tf_last_written = wraddr - 1;\n\n\t\tf_penu_addr = rdaddr + 1;\n\t\tf_penu_data = fifo_data[f_penu_addr[LGPIPE-1:0]];\n\n\t\tf_clrfifo = (!S_AXI_ARESETN || bus_abort || flush_request);\n\t\tf_wrfifo = (!f_clrfifo) && ((M_AXI_ARVALID && M_AXI_ARREADY)\n\t\t\t\t|| (M_AXI_WVALID && M_AXI_WREADY));\n\t\tf_rdfifo = (!f_clrfifo) && ((M_AXI_RVALID && M_AXI_RREADY)\n\t\t\t\t|| (M_AXI_BVALID && M_AXI_BREADY));\n\n\t\tf_distance_to_first = f_first_addr - rdaddr;\n\t\tf_distance_to_next  = f_next_addr  - rdaddr;\n\n\t\tf_first_in_fifo = (f_distance_to_first < f_fifo_fill) && (f_fifo_fill > 0);\n\t\tf_next_in_fifo  = (f_distance_to_next < f_fifo_fill) && (f_fifo_fill > 0);\n\n\t\tf_return_",
            "reg = { fifo_gie, fifo_return_",
            "reg };\n\n\t\tf_first_return_",
            "reg = { fifo_gie, f_first_data[AXILSB+3 +: 4] };\n\t\tf_next_return_",
            "reg = { fifo_gie, f_next_data[AXILSB+3 +: 4] };\n\t\tf_penu_return_",
            "reg = { fifo_gie, f_penu_data[AXILSB+3 +: 4] };\n\n\t\tf_first_misaligned = f_first_data[AXILSB];\n\t\tf_next_misaligned = f_next_data[AXILSB];\n\t\tf_this_misaligned = fifo_read_data[AXILSB];\n\t\tf_penu_misaligned = f_penu_data[AXILSB];\n\n\t\tf_first_read_cycle = f_first_data[FIFO_WIDTH-1];\n\t\tf_next_read_cycle = f_next_data[FIFO_WIDTH-1];\n\t\tf_this_read_cycle = fifo_read_data[FIFO_WIDTH-1];\n\t\tf_penu_read_cycle = f_penu_data[FIFO_WIDTH-1];\n\t\t// }}}\n\tend\n\n\talways @(*)\n\tif (r_flushing && !f_clrfifo)\n\t\tassert(rdaddr == wraddr);\n\n\talways @(*)\n\tif (!f_clrfifo)\n\tbegin\n\t\tif (f_first_in_fifo)\n\t\t\t`ASSERT(f_first_data == fifo_data[f_first_addr[LGPIPE-1:0]]);\n\t\tif (f_next_in_fifo)\n\t\t\t`ASSERT(f_next_data == fifo_data[f_next_addr[LGPIPE-1:0]]);\n\tend\n\n\talways @(posedge S_AXI_ACLK)\n\tif (f_wrfifo && wraddr == f_first_addr)\n\t\tf_first_data <= { M_AXI_ARVALID, ar_o",
            "reg , ar_op, misaligned_request, adr_lsb };\n\n\talways @(posedge S_AXI_ACLK)\n\tif (f_wrfifo && wraddr == f_next_addr)\n\t\tf_next_data <= { M_AXI_ARVALID, ar_o",
            "reg , ar_op, misaligned_request, adr_lsb };\n\n\t// f_fsmfifo\n\t// {{{\n\tinitial\tf_fsmfifo = 2'b00;\n\talways @(posedge S_AXI_ACLK)\n\tif (f_clrfifo)\n\t\tf_fsmfifo <= 2'b00;\n\telse case(f_fsmfifo)\n\t2'b00: if (f_wrfifo && wraddr == f_first_addr)\n\t\tf_fsmfifo <= 2'b01;\n\t2'b01: if (f_rdfifo && rdaddr == f_first_addr)\n\t\tf_fsmfifo <= 2'b00;\n\t\telse if (f_wrfifo && wraddr == f_next_addr)\n\t\tf_fsmfifo <= 2'b10;\n\t2'b10: if (f_rdfifo && rdaddr == f_first_addr)\n\t\tf_fsmfifo <= 2'b11;\n\t2'b11: if (f_rdfifo)\n\t\tf_fsmfifo <= 2'b00;\n\tendcase\n\n\talways @(*)\n\tif (!f_clrfifo)\n\tcase(f_fsmfifo)\n\t2'b00: begin\n\t\t// {{{\n\t\t`ASSERT(!f_first_in_fifo);\n\t\tend\n\t\t// }}}\n\t2'b01: begin\n\t\t// {{{\n\t\t`ASSERT(f_fifo_fill >= 1);\n\t\t`ASSERT(f_first_in_fifo);\n\t\tend\n\t\t// }}}\n\t2'b10: begin\n\t\t// {{{\n\t\t`ASSERT(f_fifo_fill >= 2);\n\t\t`ASSERT(f_first_in_fifo);\n\t\t`ASSERT(f_next_in_fifo);\n\t\tend\n\t\t// }}}\n\t2'b11: begin\n\t\t// {{{\n\t\t`ASSERT(f_fifo_fill >= 1);\n\t\t`ASSERT(f_next_in_fifo);\n\t\t`ASSERT(rdaddr == f_next_addr);\n\t\tend\n\t\t// }}}\n\tendcase\n\t// }}}\n\n\t// { ar_o",
            "reg , ar_op, misaligned_request, M_AXI_ARADDR[AXILSB-1:0] };\n\n\t// cpu_gie checks\n\t// {{{\n\talways @(*)\n\tif (M_AXI_ARVALID)\n\t\t`ASSERT(cpu_gie == fifo_gie);\n\n\talways @(*)\n\tif (!f_clrfifo && f_fifo_fill != 0)\n\tbegin\n\t\tif (M_AXI_ARVALID || M_AXI_WVALID || M_AXI_AWVALID)\n\t\t\t`ASSERT(cpu_gie == fifo_gie);\n\n\t\tif ((!f_first_in_fifo || rdaddr != f_first_addr)\n\t\t\t\t&& (!f_next_in_fifo || rdaddr != f_next_addr)\n\t\t\t\t&& (f_fifo_fill > 0))\n\t\t\t`ASSUME(cpu_gie == f_return_",
            "reg [4]);\n\n\t\tif (f_first_in_fifo)\n\t\t\t`ASSERT(cpu_gie == f_first_return_",
            "reg [4]);\n\t\tif (f_next_in_fifo)\n\t\t\t`ASSERT(cpu_gie == f_next_return_",
            "reg [4]);\n\tend\n\t// }}}\n\n\t// cpu_pc checks\n\t// {{{\n\talways @(*)\n\tif (M_AXI_ARVALID)\n\t\t`ASSERT(cpu_pc == ((&ar_o",
            "reg [3:1]) && (o_err || !flush_request)));\n\n\talways @(*)\n\tif (!f_clrfifo && f_fifo_fill != 0)\n\tbegin\n\t\tif ((M_AXI_ARVALID || (rdaddr != f_last_written)))\n\t\tbegin\n\t\t\t`ASSERT(f_this_misaligned || !cpu_read_cycle || !(&f_return_",
            "reg [3:1]));\n\t\tend else if (f_fifo_fill > 0 && !M_AXI_ARVALID)\n\t\t\t`ASSERT(f_this_misaligned || !cpu_read_cycle || cpu_pc == (&f_return_",
            "reg [3:1]));\n\n\t\tif ((!f_first_in_fifo || rdaddr != f_first_addr)\n\t\t\t&& (!f_next_in_fifo || rdaddr != f_next_addr)\n\t\t\t&& cpu_read_cycle)\n\t\tbegin\n\t\t\tif (M_AXI_ARVALID) // && (&ar_o",
            "reg [3:1]))\n\t\t\tbegin\n\t\t\t\t`ASSUME(!(&f_return_",
            "reg [3:1]));\n\t\t\tend else if (rdaddr != f_last_written)\n\t\t\tbegin\n\t\t\t\t`ASSUME(!(&f_return_",
            "reg [3:1]));\n\t\t\tend else if (!M_AXI_ARVALID && !o_err)\n\t\t\t\t`ASSUME(cpu_pc == (&f_return_",
            "reg [3:1])); // Not last written\n\t\tend\n\n\t\tif (f_first_in_fifo && cpu_read_cycle)\n\t\tbegin\n\t\t\tif (!cpu_pc || M_AXI_ARVALID\n\t\t\t\t\t|| (f_last_written != f_first_addr))\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_first_misaligned || !cpu_read_cycle || !(&f_first_return_",
            "reg [3:1]));\n\t\t\tend else if (!M_AXI_ARVALID && !o_err)\n\t\t\t\t`ASSERT(&f_first_return_",
            "reg [3:1]);\n\t\tend\n\n\t\tif (f_next_in_fifo && cpu_read_cycle)\n\t\tbegin\n\t\t\tif (!cpu_pc || M_AXI_ARVALID\n\t\t\t\t\t|| (f_last_written != f_next_addr))\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_next_misaligned || !(&f_next_return_",
            "reg [3:1]));\n\t\t\tend else if (!M_AXI_ARVALID && !o_err)\n\t\t\t\t`ASSERT(&f_next_return_",
            "reg [3:1]);\n\t\tend\n\n\t\tif (M_AXI_ARVALID)\n\t\t\t`ASSERT(cpu_pc == (&ar_o",
            "reg [3:1]));\n\tend\n\t// }}}\n\n\talways @(*)\n\tif (cpu_read_cycle && !r_flushing)\n\t\tassert(o_rdbusy==((rdaddr != wraddr)||(M_AXI_ARVALID)));\n\n\talways @(*)\n\tif (cpu_read_cycle)\n\t\tassert(!M_AXI_AWVALID && !M_AXI_WVALID&& faxi_awr_nbursts == 0);\n\n\t// Verifying the alignment flags\n\t// {{{\n\talways @(*)\n\tif (M_AXI_ARVALID && OPT_ALIGNMENT_ERR)\n\t\tassert(!misaligned_request);\n\n\talways @(*)\n\tif (!f_clrfifo && f_fifo_fill != 0)\n\tbegin\n\t\tif (OPT_ALIGNMENT_ERR)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tif (f_first_in_fifo)\n\t\t\t\t`ASSERT(!f_first_misaligned);\n\t\t\tif (f_next_in_fifo)\n\t\t\t\t`ASSERT(!f_next_misaligned);\n\t\t\tif ((!f_first_in_fifo || rdaddr != f_first_addr)\n\t\t\t\t&& (!f_next_in_fifo || rdaddr != f_next_addr))\n\t\t\t\t`ASSUME(!f_this_misaligned);\n\t\t\t// }}}\n\t\tend else begin\n\t\t\t// {{{\n\t\t\tif (f_first_in_fifo && f_first_misaligned)\n\t\t\tbegin\n\t\t\t\tif (f_next_in_fifo)\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(!f_next_misaligned);\n\t\t\t\tend else begin\n\t\t\t\t\t`ASSERT(!misaligned_request);\n\t\t\t\t\t`ASSERT(M_AXI_ARVALID || M_AXI_WVALID);\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif (misaligned_response_pending\n\t\t\t\t&& (!f_first_in_fifo || rdaddr != f_first_addr))\n\t\t\tbegin\n\t\t\t\tif (f_fifo_fill > 1)\n\t\t\t\tbegin\n\t\t\t\t\t`BMC_ASSERT(!f_penu_misaligned);\n\t\t\t\tend else if (f_fifo_fill == 1)\n\t\t\t\tbegin\n\t\t\t\t\t`BMC_ASSERT(!misaligned_request);\n\t\t\t\tend\n\t\t\tend\n\t\t\t// }}}\n\t\tend\n\tend\n\t// }}}\n\n\t// Verifying unaligned",
            "reg isters remain the same\n\t// {{{\n\talways @(*)\n\tif (!f_clrfifo && f_fifo_fill != 0 && !OPT_ALIGNMENT_ERR)\n\tbegin\n\t\tif (f_first_in_fifo && f_first_misaligned)\n\t\tbegin\n\t\t\tif (f_next_in_fifo)\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_first_return_",
            "reg == f_next_return_",
            "reg );\n\t\t\tend else begin\n\t\t\t\t`ASSERT(M_AXI_ARVALID || M_AXI_WVALID);\n\t\t\t\t`ASSERT(!misaligned_request);\n\t\t\t\t`ASSERT(f_first_return_",
            "reg == { fifo_gie, ar_o",
            "reg });\n\t\t\tend\n\t\tend\n\n\t\tif (misaligned_response_pending\n\t\t\t&& (!f_first_in_fifo || rdaddr != f_first_addr))\n\t\tbegin\n\t\t\tif (f_fifo_fill == 1)\n\t\t\tbegin\n\t\t\t\t`BMC_ASSERT(M_AXI_ARVALID || M_AXI_WVALID);\n\t\t\t\t`BMC_ASSERT(!misaligned_request);\n\t\t\t\t`BMC_ASSERT(f_first_return_",
            "reg == { fifo_gie, ar_o",
            "reg });\n\t\t\tend else\n\t\t\t\t`BMC_ASSERT({ fifo_gie, fifo_return_",
            "reg } == f_penu_return_",
            "reg );\n\t\tend\n\tend\n\t// }}}\n\n\talways @(*)\n\t\tassert(f_fifo_fill <= (1<<LGPIPE));\n\n\talways @(*)\n\t\tassert(beats_outstanding <= (1<<LGPIPE));\n\n\t// Verifying the cpu_read_cycle flags\n\t// {{{\n\talways @(*)\n\tif (!r_flushing && f_fifo_fill > 0)\n\tbegin\n\t\tif (f_first_in_fifo)\n\t\t\t`ASSERT(cpu_read_cycle == f_first_read_cycle);\n\t\tif (f_next_in_fifo)\n\t\t\t`ASSERT(cpu_read_cycle == f_next_read_cycle);\n\n\t\tif (// f_fifo_fill > 0 && // Redundant\n\t\t\t   (!f_first_in_fifo || rdaddr != f_first_addr)\n\t\t\t&& (!f_next_in_fifo  || rdaddr != f_next_addr))\n\t\tbegin\n\t\t\t`BMC_ASSERT(cpu_read_cycle == f_this_read_cycle);\n\t\tend\n\n\t\tif (f_fifo_fill > 1\n\t\t\t&& (!f_first_in_fifo || f_penu_addr != f_first_addr)\n\t\t\t&& (!f_next_in_fifo  || f_penu_addr != f_next_addr))\n\t\tbegin\n\t\t\t`BMC_ASSERT(cpu_read_cycle == f_penu_read_cycle);\n\t\tend\n\n\t\tif (cpu_read_cycle)\n\t\tbegin\n\t\t\t`ASSERT(!M_AXI_AWVALID && !M_AXI_WVALID);\n\t\t\t`ASSERT(faxi_awr_nbursts == 0);\n\t\tend\n\tend\n\t// }}}\n\n\t// Verifying the cpu_last_",
            "reg // {{{\n\talways @(*)\n\tif (M_AXI_WVALID || M_AXI_ARVALID)\n\tbegin\n\t\tif (cpu_axi_write_cycle)\n\t\tbegin\n\t\t\tassert(cpu_last_",
            "reg == { fifo_gie, 4'hf });\n\t\tend else if (!r_flushing)\n\t\t\tassert(cpu_last_",
            "reg == { fifo_gie, ar_o",
            "reg });\n\tend else if (!f_clrfifo && f_fifo_fill > 0)\n\tbegin\n\t\tif (cpu_axi_write_cycle)\n\t\tbegin\n\t\t\tassert(cpu_last_",
            "reg == { fifo_gie, 4'hf });\n\t\tend else if (f_first_in_fifo && f_first_addr == f_last_written)\n\t\tbegin\n\t\t\tassert(f_first_return_",
            "reg == cpu_last_",
            "reg );\n\t\tend\n\n\t\tif (!cpu_axi_write_cycle && f_next_in_fifo\n\t\t\t\t\t&& f_next_addr == f_last_written)\n\t\tbegin\n\t\t\tassert(f_next_return_",
            "reg == cpu_last_",
            "reg );\n\t\tend\n\n\t\tif (rdaddr == f_last_written\n\t\t\t\t&& (rdaddr != f_first_addr)\n\t\t\t\t&& (rdaddr != f_next_addr))\n\t\t\t`BMC_ASSERT({ fifo_gie, fifo_return_",
            "reg } == cpu_last_",
            "reg );\n\tend\n\t// }}}\n\n\t// Verifying the cpu_addr_",
            "reg // {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (i_stb)\n\t\tf_ar_a",
            "reg <= f_a",
            "reg ;\n\n\talways @(*)\n\tif (o_rdbusy)\n\t\t`ASSERT(f_ar_a",
            "reg == cpu_addr_",
            "reg );\n\n\talways @(*)\n\tif (!f_clrfifo && o_rdbusy && f_fifo_fill > 0)\n\tbegin\n\t\tif (f_first_in_fifo && f_first_addr != f_last_written)\n\t\t\tassert(f_first_return_",
            "reg != cpu_addr_",
            "reg || f_first_misaligned);\n\t\tif (f_next_in_fifo && f_next_addr != f_last_written)\n\t\t\tassert(f_next_return_",
            "reg != cpu_addr_",
            "reg || f_next_misaligned);\n\n\t\t// If the base address",
            "reg ister exists in the FIFO, then it\n\t\t// can't be part of any current requests.\n\t\tif ((f_first_in_fifo && (f_first_return_",
            "reg == cpu_addr_",
            "reg ) && !f_first_misaligned)\n\t\t\t||(f_next_in_fifo && (f_next_return_",
            "reg == cpu_addr_",
            "reg ) && !f_next_misaligned))\n\t\t\tassert(!M_AXI_WVALID && !M_AXI_ARVALID);\n\n\t\tif ((rdaddr != f_last_written || M_AXI_WVALID || M_AXI_ARVALID)\n\t\t\t\t&& !misaligned_response_pending\n\t\t\t\t&& (cpu_outstanding > (o_valid ? 1:0))\n\t\t\t\t&& (rdaddr != f_first_addr)\n\t\t\t\t&& (rdaddr != f_next_addr))\n\t\t\t`BMC_ASSERT({ fifo_gie, fifo_return_",
            "reg } != cpu_addr_",
            "reg );\n\tend\n\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Exclusive access properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge S_AXI_ACLK)\n\tif (M_AXI_ARVALID && M_AXI_ARREADY && M_AXI_ARLOCK)\n\tbegin\n\t\tf_exlock_addr <= M_AXI_ARADDR;\n\t\tf_exlock_size <= M_AXI_ARSIZE;\n\tend\n\n\tassign\tf_exlock_len = 0;\n\tassign\tf_exlock_burst = M_AXI_AWBURST;\n\n\talways @(*)\n\tif (faxi_ex_state != 2'b00)\n\tbegin\n\t\tassert(f_exlock_addr  == faxi_exreq_addr);\n\t\tassert(f_exlock_len   == faxi_exreq_len);\n\t\tassert(f_exlock_size  == faxi_exreq_size);\n\t\tassert(f_exlock_burst == faxi_exreq_burst);\n\tend\n\n\talways @(*)\n\tif (r_lock)\n\tbegin\n\t\tif (M_AXI_ARVALID)\n\t\tbegin\n\t\t\tassert(M_AXI_ARLOCK);\n\t\t\tassert(!M_AXI_AWVALID);\n\t\t\tassert(faxi_rdid_bursts_to_lock == 0);\n\t\tend else if (M_AXI_AWVALID)\n\t\tbegin\n\t\t\tassert(!M_AXI_ARVALID);\n\t\t\tassert(M_AXI_AWLOCK);\n\t\t\tassert(faxi_rdid_bursts_to_lock == 0);\n\t\tend else if (faxi_ex_checklock&&(M_AXI_ARID == faxi_rd_checkid))\n\t\tbegin\n\t\t\tassert(faxi_rdid_bursts_to_lock == faxi_rd_nbursts);\n\t\tend else\n\t\t\tassert(faxi_rdid_bursts_to_lock == 0);\n\n\t\tif (faxi_rd_nbursts > 1)\n\t\t\tassume(!M_AXI_RVALID || M_AXI_RRESP != EXOKAY);\n\n\t\tassert(faxi_rdid_bursts_to_lock    <= 1);\n\t\tassert(faxi_wrid_bursts_to_exwrite <= 1);\n\tend else begin\n\t\tassume(r_flushing || !M_AXI_RVALID || M_AXI_RRESP != EXOKAY);\n\t\tassert(r_flushing || faxi_rdid_bursts_to_lock    == 0);\n\t\tassert(r_flushing || faxi_wrid_bursts_to_exwrite == 0);\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "wire cpu_axi_write_cycle;\n\n\tinitial\tf_done = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || r_flushing)\n\t\tf_done <= 1'b0;\n\telse\n\t\tf_done <= (M_AXI_RVALID && !M_AXI_RRESP[1]\n\t\t\t|| M_AXI_BVALID && !M_AXI_BRESP[1]) && !pending_err\n\t\t\t\t&& !misaligned_response_pending;",
            "localparam FMEM_OPT_MAXDEPTH = (1<<LGPIPE);\n\tfmem #(\n\t\t// {{{\n\t\t.F_LGDEPTH(LGPIPE+1),\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_AXI_LOCK(OPT_LOCK),\n\t\t.OPT_MAXDEPTH(FMEM_OPT_MAXDEPTH[LGPIPE:0])\n\t\t// }}}\n\t) fcheck(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK),\n\t\t.i_sys_reset(!S_AXI_ARESETN),\n\t\t.i_cpu_reset(i_cpu_reset),\n\t\t.i_stb(i_stb),\n\t\t.i_pipe_stalled(o_pipe_stalled),\n\t\t.i_clear_cache(1'b0),\n\t\t.i_lock(i_lock), .i_op(i_op), .i_addr({ {(32-AW){1'b0}}, i_addr }),\n\t\t.i_data(i_data), .i_o",
            "reg (i_o",
            "reg ), .i_busy(o_busy),\n\t\t\t.i_a",
            "reg (f_a",
            "reg ),\n\t\t.i_rdbusy(o_rdbusy), .i_valid(o_valid), .i_done(f_done),\n\t\t.i_err(o_err), .i_w",
            "reg (o_w",
            "reg ), .i_result(o_result),\n\t\t.f_outstanding(cpu_outstanding),\n\t\t.f_pc(cpu_pc), .f_gie(cpu_gie), .f_read_cycle(cpu_read_cycle),\n\t\t.f_axi_write_cycle(cpu_axi_write_cycle),\n\t\t.f_last_",
            "reg (cpu_last_",
            "reg ), .f_addr_",
            "reg (cpu_addr_",
            "reg )\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (flush_request)\n\tbegin\n\t\t`ASSERT(cpu_outstanding == 0 || o_err);\n\tend else if (r_flushing)\n\tbegin\n\t\t`ASSERT(o_err || cpu_outstanding == 0);\n\tend else if (OPT_ALIGNMENT_ERR)\n\tbegin\n\t\tif (!o_err)\n\t\t`ASSERT(cpu_outstanding == (beats_outstanding - flushcount)\n\t\t\t+ ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0)\n\t\t\t+ ((o_valid || f_done) ? 1:0));\n\t\t// else `ASSERT(cpu_outstanding == flushcount);\n\tend\n\n\talways @(*)\n\tif (o_err && beats_outstanding > 0)\n\t\t`ASSERT(r_flushing);\n\n\talways @(*)\n\tif (!o_err && cpu_outstanding > 0)\n\tbegin\n\t\tif (cpu_axi_write_cycle)\n\t\tbegin\n\t\t\tassert(faxi_rd_outstanding == 0);\n\t\t\tassert(!M_AXI_ARVALID);\n\t\t\tif (f_done)\n\t\t\tbegin\n\t\t\t\tassert(!M_AXI_AWVALID && !M_AXI_WVALID\n\t\t\t\t\t&& faxi_awr_nbursts == 0);\n\t\t\t\tassert(!o_rdbusy);\n\t\t\tend else begin\n\t\t\t\tassert(faxi_awr_nbursts == (M_AXI_AWVALID ? 0:1));\n\t\t\t\tassert(o_rdbusy);\n\t\t\tend\n\t\tend else if (faxi_rd_outstanding > 0 || M_AXI_ARVALID\n\t\t\t\t\t\t|| o_rdbusy)\n\t\tbegin\n\t\t\tassert(cpu_read_cycle);\n\t\tend else if (faxi_awr_nbursts > 0 || M_AXI_AWVALID || M_AXI_WVALID)\n\t\t\tassert(!cpu_read_cycle);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg [LGPIPE:0]\tcvr_writes, cvr_reads, cvr_valids;",
            "reg cvr_idle;\n\n\talways @(*)\n\tbegin\n\t\tcvr_idle = 1;\n\t\tif (i_cpu_reset || o_err || f_done)\n\t\t\tcvr_idle = 1'b0;\n\t\tif (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID)\n\t\t\tcvr_idle = 1'b0;\n\t\tif (faxi_awr_nbursts > 0)\n\t\t\tcvr_idle = 1'b0;\n\t\tif (faxi_rd_outstanding > 0)\n\t\t\tcvr_idle = 1'b0;\n\tend\n\n\tinitial\tcvr_writes = 0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || o_err)\n\t\tcvr_writes <= 0;\n\telse if (M_AXI_BVALID&& !misaligned_response_pending  && !(&cvr_writes))\n\t\tcvr_writes <= cvr_writes + 1;\n\n\tinitial\tcvr_reads = 0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || o_err)\n\t\tcvr_reads <= 0;\n\telse if (M_AXI_RVALID && !misaligned_response_pending && !(&cvr_reads))\n\t\tcvr_reads <= cvr_reads + 1;\n\n\tinitial\tcvr_valids = 0;\n\talways @(posedge i_clk)\n\tif (i_cpu_reset || o_err)\n\t\tcvr_valids <= 0;\n\telse if (o_valid)\n\t\tcvr_valids <= cvr_valids + 1;\n\n\t// Cover a write response\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_BVALID && !M_AXI_BRESP[1]);\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_BVALID &&  M_AXI_BRESP[1]);\n\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_RVALID && !M_AXI_RRESP[1]);\n\talways @(posedge i_clk)\n\t\tcover(M_AXI_RVALID &&  M_AXI_RRESP[1]);\n\n\n\talways @(posedge i_clk)\n\tif (cvr_idle)\n\tbegin\n\t\tcover(cvr_writes >  3);\n\t\tcover(cvr_reads  >  3);\n\t\tcover(cvr_valids >  3);\n\n\t\tcover(cvr_writes > (1<<LGPIPE));\n\t\tcover(cvr_reads  > (1<<LGPIPE));\n\t\tcover(cvr_valids > (1<<LGPIPE));\n\n\t\tcover(cvr_writes > (1<<LGPIPE)+2);\n\t\tcover(cvr_reads  > (1<<LGPIPE)+2);\n\t\tcover(cvr_valids > (1<<LGPIPE)+2);\n\tend\n\n\tgenerate if (!OPT_ALIGNMENT_ERR)\n\tbegin",
            "reg [LGPIPE:0]\tcvr_unaligned_writes,\n\t\t\t\t\tcvr_unaligned_reads;\n\n\t\tinitial\tcvr_writes = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_cpu_reset || o_err)\n\t\t\tcvr_unaligned_writes <= 0;\n\t\telse if (i_stb && i_op[0] && w_misaligned)\n\t\t\tcvr_unaligned_writes <= cvr_unaligned_writes + 1;\n\n\t\tinitial\tcvr_reads = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_cpu_reset || o_err)\n\t\t\tcvr_unaligned_reads <= 0;\n\t\telse if (i_stb && !i_op[0] && w_misaligned)\n\t\t\tcvr_unaligned_reads <= cvr_unaligned_reads + 1;\n\n\t\talways @(posedge i_clk)\n\t\tif (cvr_idle)\n\t\tbegin\n\t\t\tcover(cvr_unaligned_writes >  3);\n\t\t\tcover(cvr_unaligned_reads  >  3);\n\n\t\t\tcover(cvr_unaligned_writes > (1<<LGPIPE));\n\t\t\tcover(cvr_unaligned_reads  > (1<<LGPIPE));\n\t\tend\n\tend endgenerate\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Careless assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (!OPT_ALIGNMENT_ERR)\n\tbegin\n\t\tif (!r_flushing && !o_err)\n\t\t`BMC_ASSERT(cpu_outstanding <= beats_outstanding\n\t\t\t+ ((M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID) ? 1:0)\n\t\t\t+ ((o_valid || f_done) ? 1:0));\n\n\t\tif (!r_flushing && cpu_read_cycle)\n\t\tbegin\n\t\t`BMC_ASSERT({ 4'h0, cpu_outstanding } >= (f_done ? 1:0)\n\t\t\t\t\t+ faxi_rd_outstanding[F_LGDEPTH-1:1]);\n\t\tend else if (!r_flushing)\n\t\t`BMC_ASSERT({ 4'h0, cpu_outstanding } >= (f_done ? 1:0)\n\t\t\t\t\t+ faxi_awr_nbursts[F_LGDEPTH-1:1]);\n\n\t\tif (!r_flushing && !o_err)\n\t\tassert(f_fifo_fill == beats_outstanding\n\t\t\t+ ((misaligned_aw_request && !misaligned_request) ? 1:0)\n\t\t\t\t+ ((M_AXI_AWVALID && !M_AXI_WVALID) ? 1:0));\n\n\t\tif (!r_flushing && !o_err)\n\t\tbegin\n\t\t\t`BMC_ASSERT((cpu_outstanding == 0) == (!M_AXI_AWVALID\n\t\t\t\t&& !M_AXI_WVALID && !M_AXI_ARVALID\n\t\t\t\t&& (beats_outstanding + (f_done ? 1:0) == 0)));\n\t\tend else if (o_err)\n\t\t\t`BMC_ASSERT(cpu_outstanding > 0);\n\n\n\t\tif (!r_flushing && !o_err && cpu_outstanding == (f_done ? 1:0))\n\t\t\t`BMC_ASSERT(beats_outstanding == 0\n\t\t\t\t&& !M_AXI_AWVALID && !M_AXI_WVALID\n\t\t\t\t&& !M_AXI_ARVALID);\n\tend\n\n\t// Lock assumptions\n\talways @(*)\n\tif (SWAP_WSTRB)\n\tbegin\n\t\tif (M_AXI_AWVALID) //  && M_AXI_AWLOCK)\n\t\tbegin\n\t\t\tassert(M_AXI_AWADDR[AXILSB-1:0] == 0);\n\t\t\tassert(M_AXI_AWSIZE == AXILSB[2:0]);\n\t\tend\n\n\t\tif (M_AXI_ARVALID) //  && M_AXI_AWLOCK)\n\t\tbegin\n\t\t\tassert(M_AXI_ARADDR[AXILSB-1:0] == 0);\n\t\t\tassert(M_AXI_ARSIZE == AXILSB[2:0]);\n\t\tend\n\tend\n\n\talways @(*)\n\tif (i_stb && i_op[0] && i_lock)\n\tbegin\n\t\tassume(i_addr == f_exlock_addr);\n\t\tassume(faxi_ex_state == 2'b10);\n\n\t\tif (SWAP_WSTRB)\n\t\tbegin\n\t\t\tassume(f_exlock_size == AXILSB[2:0]);\n\t\t\tassume(f_exlock_addr[AXILSB-1:0] == 0);\n\t\tend else\n\t\tcasez(i_op[2:1])\n\t\t2'b0?: assume(f_exlock_size == 3'b010);\n\t\t2'b10: assume(f_exlock_size == 3'b001);\n\t\t2'b11: assume(f_exlock_size == 3'b000);\n\t\tendcase\n\tend\n\n\talways @(*)\n\t\tassume(faxi_wr_checkid == AXI_ID);\n\talways @(*)\n\t\tassume(faxi_rd_checkid == AXI_ID);\n\n\talways @(*)\n\tif (M_AXI_AWVALID || M_AXI_WVALID || M_AXI_ARVALID\n\t\t\t|| (beats_outstanding > 0))\n\t\tassume(!i_stb || !i_lock);\n\t// }}}\n\n\t// Make Verilator happy w/ formal\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "wire unused_formal;\n\tassign\tunused_formal = &{ 1'b0, faxi_exlock_return, f_return_",
            "reg ,\n\t\t\tfaxi_rdid_ckign_outstanding, faxi_rdid_ckign_nbursts,\n\t\t\tfaxi_wr_incr, faxi_wr_size, faxi_rd_cklen,\n\t\t\tfaxi_rd_ckaddr, faxi_rd_cksize, faxi_rd_ckincr,\n\t\t\tfaxi_wr_addr\n\t\t\t};\n\t// Verilator lint_on  UNUSED\n\t// }}}\n`endif\n// }}}",
            "endmodule // yosys -p 'read -sv axipipe.v; synth_xilinx -flatten -top axipipe'\n//\n//\t\t\t(!LOWPOWER)\t(LOWPOWER)\n//\tCells:\t\t 932\t\t1099\n//\t  FDRE,FDSE\t 234\t\t 234\n//\t  LUT1\t\t   0\t\t  32\n//\t  LUT2\t\t  62\t\t  73\n//\t  LUT3\t\t  46\t\t  58\n//\t  LUT4\t\t  25\t\t  36\n//\t  LUT5\t\t  75\t\t  62\n//\t  LUT6\t\t 116\t\t 130\n//\t  MUXF7\t\t  14\t\t  55\n//\t  MUXF8\t\t   6\t\t  12\n//\t  RAM32X1D\t   9\t\t   9\n//\tEstimated LCs:\t 262\t\t 286\n//"
        ]
    },
    {
        "file_name": "pipefetch.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/pipefetch.v",
        "chunks": [
            "module : 1) Pipeline\n//\t\twishbone accesses, and 2) an instruction cache.\n//\n//\t20150919 -- Fixed a nasty race condition whereby the pipefetch routine\n//\t\twould produce either the same instruction twice, or skip\n//\t\tan instruction.  This condition was dependent on the CPU stall\n//\t\tcondition, and would only take place if the pipeline wasn't\n//\t\tcompletely full throughout the stall.\n//\n//\t\tInterface support was also added for trapping on illegal\n//\t\tinstructions (i.e., instruction fetches that cause bus errors),\n//\t\thowever the internal interface has not caught up to supporting\n//\t\tthese exceptions yet.\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024 Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype\tnone\n// }}}",
            "module pipefetch(i_clk, i_reset, i_new_pc, i_clear_cache, i_stall_n, i_pc,\n\t// {{{\n\t\t\to_i, o_pc, o_v,\n\t\to_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data,\n\t\t\ti_wb_stall, i_wb_ack, i_wb_err, i_wb_data, i_wb_request,\n\t\t\to_illegal);",
            "parameter RESET_ADDRESS=32'h0010_0000,\n\t\t\tLGCACHELEN = 6, ADDRESS_WIDTH=24,\n\t\t\tCACHELEN=(1<<LGCACHELEN), BUSW=32, AW=ADDRESS_WIDTH;",
            "input ",
            "wire i_clk, i_reset, i_new_pc,\n\t\t\t\t\ti_clear_cache, i_stall_n;",
            "input ",
            "wire [AW+1:0]\ti_pc;",
            "output ",
            "reg [BUSW-1:0]\to_i;",
            "output ",
            "reg [AW+1:0]\to_pc;",
            "output ",
            "reg o_v;\n\t//",
            "output ",
            "reg o_wb_cyc, o_wb_stb;",
            "output ",
            "wire o_wb_we;",
            "output ",
            "reg [(AW-1):0]\to_wb_addr;",
            "output ",
            "wire [(BUSW-1):0]\to_wb_data;\n\t//",
            "input ",
            "wire i_wb_stall, i_wb_ack, i_wb_err;",
            "input ",
            "wire [(BUSW-1):0]\ti_wb_data;\n\t//\n\t// Is the (data) memory unit also requesting access to the bus?",
            "input ",
            "wire i_wb_request;",
            "output ",
            "wire o_illegal;\n\t// }}}\n\n\t// Declarations\n\t// {{{",
            "reg [(AW-1):0]\t\tr_cache_base;",
            "reg [(LGCACHELEN):0]\tr_nvalid, r_acks_waiting;",
            "reg [(BUSW-1):0]\t\tcache[0:(CACHELEN-1)];",
            "wire [(LGCACHELEN-1):0]\tw_cache_offset;",
            "reg [1:0]\t\t\tr_cache_offset;",
            "reg r_addr_set;",
            "reg [AW+1:0]\tr_addr;",
            "wire [(AW-1):0]\tbus_nvalid;",
            "wire w_pc_out_of_bounds;",
            "wire w_ran_off_end_of_cache;",
            "wire w_running_out_of_cache;",
            "wire w_cv;\t// Cache valid, address is in the cache",
            "reg r_cv;",
            "wire [(LGCACHELEN-1):0]\tc_rdaddr, c_cache_base;",
            "reg [(AW-1):0]\till_address;\n\t// }}}\n\n\t// Fixed bus",
            "output s: we read from the bus only, never write.\n\t// {{{\n\t// Thus the",
            "output data is ... irrelevant and don't care.  We set it\n\t// to zero just to set it to something.\n\tassign\to_wb_we = 1'b0;\n\tassign\to_wb_data = 0;\n\t// }}}\n\n\n\tassign\tbus_nvalid = { {(AW-LGCACHELEN-1){1'b0}}, r_nvalid };\n\n\t// What are some of the conditions for which we need to restart the\n\t// cache?\n\tassign\tw_pc_out_of_bounds = ((i_new_pc)&&((r_nvalid == 0)\n\t\t\t\t||(i_pc[AW+1:2] < r_cache_base)\n\t\t\t\t||(i_pc[AW+1:2] >= r_cache_base + CACHELEN)\n\t\t\t\t||(i_pc[AW+1:2] >= r_cache_base + bus_nvalid+5)));\n\tassign\tw_ran_off_end_of_cache =((r_addr_set)&&((r_addr[AW+1:2] < r_cache_base)\n\t\t\t\t||(r_addr[AW+1:2] >= r_cache_base + CACHELEN)\n\t\t\t\t||(r_addr[AW+1:2] >= r_cache_base + bus_nvalid+5)));\n\tassign\tw_running_out_of_cache = (r_addr_set)\n\t\t\t&&(r_addr[AW+1:2] >= r_cache_base +\n\t\t\t\t// {{(AW-LGCACHELEN-1),{1'b0}},2'b11,\n\t\t\t\t// \t\t{(LGCACHELEN-1){1'b0}}})\n\t\t\t\t// (1<<(LGCACHELEN-2)) + (1<<(LGCACHELEN-1)))\n\t\t\t\t+(3<<(LGCACHELEN-2)))\n\t\t\t&&(|r_nvalid[(LGCACHELEN):(LGCACHELEN-1)]);\n\n\t// o_wb_[cyc|stb]\n\t// {{{\n\tinitial\t{ o_wb_cyc, o_wb_stb } = 2'b00;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(i_clear_cache)||((o_wb_cyc)&&(i_wb_err)))\n\tbegin\n\t\to_wb_cyc <= 1'b0;\n\t\to_wb_stb <= 1'b0;\n\tend else if ((o_wb_cyc)&&(w_pc_out_of_bounds))\n\tbegin\n\t\t// {{{\n\t\t// We need to abandon our bus action to start over in\n\t\t// a new",
            "reg ion, setting up a new cache.  This may\n\t\t// happen mid cycle while waiting for a result.  By\n\t\t// dropping o_wb_cyc, we state that we are no longer\n\t\t// interested in that result--whatever it might be.\n\t\to_wb_cyc <= 1'b0;\n\t\to_wb_stb <= 1'b0;\n\t\t// }}}\n\tend else if ((!o_wb_cyc)&&(!r_nvalid[LGCACHELEN])&&(!i_wb_request)&&(r_addr_set))\n\tbegin // Restart a bus cycle that was interrupted when the\n\t\t// {{{\n\t\t// data section wanted access to our bus.\n\t\to_wb_cyc <= 1'b1;\n\t\to_wb_stb <= 1'b1;\n\t\t// o_wb_addr <= r_cache_base + bus_nvalid;\n\t\t// }}}\n\tend else if ((!o_wb_cyc)&&(\n\t\t\t(w_pc_out_of_bounds)||(w_ran_off_end_of_cache)))\n\tbegin // Start a bus transaction\n\t\t// {{{\n\t\to_wb_cyc <= 1'b1;\n\t\to_wb_stb <= 1'b1;\n\t\t// }}}\n\tend else if ((!o_wb_cyc)&&(w_running_out_of_cache))\n\tbegin\n\t\t// {{{\n\t\t// If we're using the last quarter of the cache, then\n\t\t// let's start a bus transaction to extend the cache.\n\t\to_wb_cyc <= 1'b1;\n\t\to_wb_stb <= 1'b1;\n\t\t// o_wb_addr <= r_cache_base + (1<<(LGCACHELEN));\n\t\t// r_nvalid <= r_nvalid - (1<<(LGCACHELEN-2));\n\t\t// r_cache_base <= r_cache_base + (1<<(LGCACHELEN-2));\n\t\t// w_cache_offset <= w_cache_offset + (1<<(LGCACHELEN-2));\n\t\t// }}}\n\tend else if (o_wb_cyc)\n\tbegin\n\t\t// {{{\n\t\t// This handles everything ... but the case where\n\t\t// while reading we need to extend our cache.\n\t\tif ((o_wb_stb)&&(!i_wb_stall))\n\t\tbegin\n\t\t\t// o_wb_addr <= o_wb_addr + 1;\n\t\t\tif ((o_wb_addr - r_cache_base >= CACHELEN-1)\n\t\t\t\t||(i_wb_request))\n\t\t\t\to_wb_stb <= 1'b0;\n\t\tend\n\n\t\tif (i_wb_ack)\n\t\tbegin\n\t\t\t// r_nvalid <= r_nvalid + 1;\n\t\t\tif ((r_acks_waiting == 1)&&(!o_wb_stb))\n\t\t\t\to_wb_cyc <= 1'b0;\n\t\tend else if ((r_acks_waiting == 0)&&(!o_wb_stb))\n\t\t\to_wb_cyc <= 1'b0;\n\t\t// }}}\n\tend\n\t// }}}}\n\n\t// r_nvalid\n\t// {{{\n\tinitial\tr_nvalid = 0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(i_clear_cache)) // Required, so we can reload memoy and then reset\n\t\tr_nvalid <= 0;\n\telse if ((!o_wb_cyc)&&(\n\t\t\t(w_pc_out_of_bounds)||(w_ran_off_end_of_cache)))\n\t\tr_nvalid <= 0;\n\telse if ((!o_wb_cyc)&&(w_running_out_of_cache))\n\t\tr_nvalid[LGCACHELEN:(LGCACHELEN-2)]\n\t\t\t<= r_nvalid[LGCACHELEN:(LGCACHELEN-2)] +3'b111;\n\t\t\t\t// i.e.  - (1<<(LGCACHELEN-2));\n\telse if ((o_wb_cyc)&&(i_wb_ack))\n\t\tr_nvalid <= r_nvalid + {{(LGCACHELEN){1'b0}},1'b1}; // +1;\n\t// }}}\n\n\t// r_cache_base\n\t// {{{\n\tinitial\tr_cache_base = RESET_ADDRESS[(AW+1):2];\n\talways @(posedge i_clk)\n\tif (i_clear_cache)\n\t\tr_cache_base <= i_pc[AW+1:2];\n\telse if ((!o_wb_cyc)&&(\n\t\t\t(w_pc_out_of_bounds)\n\t\t\t||(w_ran_off_end_of_cache)))\n\t\tr_cache_base <= (i_new_pc) ? i_pc[AW+1:2] : r_addr[AW+1:2];\n\telse if ((!o_wb_cyc)&&(w_running_out_of_cache))\n\t\tr_cache_base[(AW-1):(LGCACHELEN-2)]\n\t\t\t<= r_cache_base[(AW-1):(LGCACHELEN-2)]\n\t\t\t\t+ {{(AW-LGCACHELEN+1){1'b0}},1'b1};\n\t\t\t\t// i.e.  + (1<<(LGCACHELEN-2));\n\t// }}}\n\n\t// [w|r]_cache_offset\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_clear_cache)\n\t\tr_cache_offset <= 0;\n\telse if ((!o_wb_cyc)&&(\n\t\t\t(w_pc_out_of_bounds)\n\t\t\t||(w_ran_off_end_of_cache)))\n\t\tr_cache_offset <= 0;\n\telse if ((!o_wb_cyc)&&(w_running_out_of_cache))\n\t\tr_cache_offset[1:0] <= r_cache_offset[1:0] + 2'b01;\n\n\tassign\tw_cache_offset = { r_cache_offset, {(LGCACHELEN-2){1'b0}} };\n\t// }}}\n\n\t// o_wb_addr\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_clear_cache)\n\t\to_wb_addr <= i_pc[AW+1:2];\n\telse if ((o_wb_cyc)&&(w_pc_out_of_bounds))\n\tbegin\n\t\tif (i_wb_ack)\n\t\t\to_wb_addr <= r_cache_base + bus_nvalid+1;\n\t\telse\n\t\t\to_wb_addr <= r_cache_base + bus_nvalid;\n\tend else if ((!o_wb_cyc)&&((w_pc_out_of_bounds)\n\t\t\t\t||(w_ran_off_end_of_cache)))\n\t\to_wb_addr <= (i_new_pc) ? i_pc[AW+1:2] : r_addr[AW+1:2];\n\telse if ((o_wb_stb)&&(!i_wb_stall))\t// && o_wb_cyc\n\t\to_wb_addr <= o_wb_addr + 1;\n\t// }}}\n\n\t// r_acks_waiting\n\t// {{{\n\tinitial\tr_acks_waiting = 0;\n\talways @(posedge i_clk)\n\tif (!o_wb_cyc)\n\t\tr_acks_waiting <= 0;\n\t// o_wb_cyc *must* be true for all following\n\telse if ((o_wb_stb)&&(!i_wb_stall)&&(!i_wb_ack)) //&&(o_wb_cyc)\n\t\tr_acks_waiting <= r_acks_waiting + {{(LGCACHELEN){1'b0}},1'b1};\n\telse if ((i_wb_ack)&&((!o_wb_stb)||(i_wb_stall))) //&&(o_wb_cyc)\n\t\tr_acks_waiting <= r_acks_waiting + {(LGCACHELEN+1){1'b1}}; // - 1;\n\t// }}}\n\n\t// cache\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((o_wb_cyc)&&(i_wb_ack))\n\t\tcache[r_nvalid[(LGCACHELEN-1):0]+w_cache_offset] <= i_wb_data;\n\t// }}}\n\n\t// r_addr_set\n\t// {{{\n\tinitial\tr_addr_set = 1'b0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(i_new_pc))\n\t\tr_addr_set <= 1'b1;\n\telse if (i_clear_cache)\n\t\tr_addr_set <= 1'b0;\n\t// }}}\n\n\t// Now, read from the cache\n\tassign\tw_cv = ((r_nvalid != 0)&&(r_addr[AW+1:2]>=r_cache_base)\n\t\t\t&&(r_addr[AW+1:2]-r_cache_base < bus_nvalid));\n\n\t// o_v\n\t// {{{\n\tinitial\to_v = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_new_pc || i_clear_cache)\n\t\to_v <= 0;\n\telse\n\t\to_v <= ((w_cv)||((!i_stall_n)&&(r_cv)));\n\t// }}}\n\n\t// r_addr\n\t// {{{\n\tinitial\tr_addr = 0;\n\talways @(posedge i_clk)\n\tif (i_new_pc)\n\t\tr_addr <= i_pc;\n\telse if (o_v && i_stall_n)\n\tbegin\n\t\tr_addr[AW+1:2] <= r_addr[AW+1:2] + {{(AW-1){1'b0}},1'b1};\n\t\tr_addr[1:0] <= 0;\n\tend\n\t// }}}\n\n\tassign\tc_cache_base   = r_cache_base[(LGCACHELEN-1):0];\n\tassign\tc_rdaddr = r_addr[(LGCACHELEN-1):0]-c_cache_base+w_cache_offset;\n\n\t// o_i\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((!o_v)||((i_stall_n)&&(o_v)))\n\t\to_i <= cache[c_rdaddr];\n\t// }}}\n\n\t// o_pc\n\t// {{{\n\talways @(*)\n\t\to_pc = r_addr;\n\t// }}}\n\n\t// ill_valid\n\t// {{{",
            "reg ill_valid;\n\tinitial\till_valid = 0;\n\tinitial\till_address = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\till_valid <= 0;\n\telse if ((o_wb_cyc)&&(i_wb_err))\n\t\till_valid <= 1;\n\t// }}}\n\n\t// ill_address\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((o_wb_cyc)&&(i_wb_err))\n\t\till_address <= o_wb_addr - {{(AW-LGCACHELEN-1){1'b0}}, r_acks_waiting};\n\t// }}}\n\n\t// o_illegal\n\t// {{{\n\tassign\to_illegal = (ill_valid) && (o_pc == ill_address)&&(o_v);\n\t// }}}\n\n`ifdef\tFORMAL\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Wishbone properties\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "localparam F_LGDEPTH = LGCACHELEN+1;",
            "wire [F_LGDEPTH-1:0]\tf_nreqs, f_nacks, f_outstanding;\n\n\tfwb_master #(\n\t\t.AW(ADDRESS_WIDTH),\n\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t.F_OPT_SOURCE(1)\n\t) fwb(\n\t\ti_clk, i_reset,\n\t\to_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, 4'h0,\n\t\t\ti_wb_ack, i_wb_stall, i_wb_data, i_wb_err,\n\t\tf_nreqs, f_nacks, f_outstanding);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// CPU interface properties\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "wire [AW+1:0]\tfc_pc, f_address;",
            "wire [31:0]\t\tfc_insn;",
            "wire fc_illegal;\n\n\tffetch #(.ADDRESS_WIDTH(ADDRESS_WIDTH), .OPT_CONTRACT(1'b0))\n\tcpu(\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.cpu_new_pc(i_new_pc), .cpu_clear_cache(i_clear_cache),\n\t\t.cpu_ready(i_stall_n), .cpu_pc(i_pc),\n\t\t.pf_insn(o_i), .pf_valid(o_v), .pf_pc(o_pc),\n\t\t.pf_illegal(o_illegal),\n\t\t.fc_pc(fc_pc), .fc_illegal(fc_illegal), .fc_insn(fc_insn),\n\t\t.f_address(f_address));\n\n\talways @(*)\n\t\tassume(!o_v || o_pc != fc_pc);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Constraining assumptions\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(*)\n\t\tassume(!i_wb_err);\n\n\talways @(*)\n\t\tassert(!ill_valid);\n\n`endif",
            "endmodule "
        ]
    },
    {
        "file_name": "pfcache.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/pfcache.v",
        "chunks": [
            "logic is driven by a couple realities:\n//\t1. It takes a clock to read from a block RAM address, and hence a clock\n//\t\tto read from the cache.\n//\t2. It takes another clock to check that the tag matches\n//\n//\t\tOur goal will be to avoid this second check if at all possible.\n//\t\tHence, we'll test on the clock of any given request whether\n//\t\tor not the request matches the last tag value, and on the next\n//\t\tclock whether it new tag value (if it has changed).  Hence,\n//\t\tfor anything found within the cache, there will be a one\n//\t\tcycle delay on any branch.\n//\n//\n//\tAddress Words are separated into three components:\n//\t[ Tag bits ] [ Cache line number ] [ Cache position w/in the line ]\n//\n//\tOn any read from the cache, only the second two components are required.\n//\tOn any read from memory, the first two components will be fixed across\n//\tthe bus, and the third component will be adjusted from zero to its\n//\tmaximum value.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module pfcache #(\n\t\t// {{{\n`ifdef\tFORMAL",
            "parameter LGCACHELEN = 4, ADDRESS_WIDTH=30,\n\t\t\t\tLGLINES=2, // Log of # of separate cache lines\n`else",
            "parameter LGCACHELEN = 12, ADDRESS_WIDTH=30,\n\t\t\t\tLGLINES=LGCACHELEN-3, // Log of # of separate cache lines\n`endif",
            "parameter BUS_WIDTH = 32, // Num data bits on the bus",
            "parameter [0:0]\tOPT_LITTLE_ENDIAN = 1'b0,",
            "localparam CACHELEN=(1<<LGCACHELEN), //Wrd Size of cach mem",
            "localparam CW=LGCACHELEN,\t// Short hand for LGCACHELEN",
            "localparam LS=LGCACHELEN-LGLINES, // Size of a cache line",
            "localparam BUSW = BUS_WIDTH,",
            "localparam INSN_WIDTH = 32,",
            "localparam WBLSB = $clog2(BUS_WIDTH/8),",
            "localparam AW=ADDRESS_WIDTH // Shorthand for ADDRESS_WIDTH\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t//\n\t\t// The interface with the rest of the CPU\n\t\t// {{{",
            "input ",
            "wire i_new_pc,",
            "input ",
            "wire i_clear_cache,",
            "input ",
            "wire i_ready,",
            "input ",
            "wire [AW+WBLSB-1:0]\ti_pc,",
            "output ",
            "reg o_valid,",
            "output ",
            "reg o_illegal,",
            "output ",
            "wire [INSN_WIDTH-1:0]\to_insn,",
            "output ",
            "wire [AW+WBLSB-1:0]\to_pc,\n\t\t// }}}\n\t\t// The wishbone bus interface\n\t\t// {{{",
            "output ",
            "reg o_wb_cyc, o_wb_stb,\n\t\t// verilator coverage_off",
            "output ",
            "wire o_wb_we,\n\t\t// verilator coverage_on",
            "output ",
            "reg [AW-1:0]\to_wb_addr,\n\t\t// verilator coverage_off",
            "output ",
            "wire [BUSW-1:0]\to_wb_data,\n\t\t// verilator coverage_on\n\t\t//",
            "input ",
            "wire i_wb_stall, i_wb_ack, i_wb_err,",
            "input ",
            "wire [BUSW-1:0]\ti_wb_data\n\t\t// }}}\n`ifdef\tFORMAL\n\t\t,",
            "output ",
            "wire [AW-1:0]\tf_pc_wb\n`endif\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam INLSB = $clog2(INSN_WIDTH/8);\n\n\t//\n\t// o_illegal will be true if this instruction was the result of a\n\t// bus error (This is also part of the CPU interface)\n\t//\n\n\t// Fixed bus",
            "output s: we read from the bus only, never write.\n\t// Thus the",
            "output data is ... irrelevant and don't care.  We set it\n\t// to zero just to set it to something.\n\tassign\to_wb_we = 1'b0;\n\tassign\to_wb_data = 0;\n\n`ifdef\tFORMAL\n\tassign\tf_pc_wb = i_pc[AW+1:2];\n`endif",
            "wire r_v;",
            "reg [BUSW-1:0]\tcache\t[0:CACHELEN-1];",
            "wire [BUSW-1:0]\tcache_word;",
            "reg [AW-CW-1:0]\tcache_tags\t[0:((1<<(LGLINES))-1)];",
            "reg [((1<<(LGLINES))-1):0]\tvalid_mask;",
            "reg r_v_from_pc, r_v_from_last;",
            "reg rvsrc;",
            "wire w_v_from_pc, w_v_from_last;",
            "reg [AW+WBLSB-1:0]\tlastpc;",
            "reg [(CW-1):0]\twraddr;",
            "reg [AW-1:LS]\tpc_tag_lookup, last_tag_lookup;",
            "wire [AW-1:LS]\ttag_lookup;",
            "wire [AW-1:LS]\tpc_tag, lasttag;",
            "reg illegal_valid;",
            "reg [AW-1:LS]\tillegal_cache;\n\n\t// initial\to_i = 32'h76_00_00_00;\t// A NOOP instruction\n\t// initial\to_pc = 0;",
            "reg [BUSW-1:0]\tr_pc_cache, r_last_cache;",
            "reg [AW+WBLSB-1:0]\tr_pc;",
            "reg isrc;",
            "reg [1:0]\t\tdelay;",
            "reg svmask, last_ack, needload, last_addr,\n\t\t\t\tbus_abort;",
            "reg [LGLINES-1:0]\tsaddr;",
            "wire w_advance;",
            "wire w_invalidate_result;",
            "wire [CW-LS-1:0]\tpc_line, last_line;\n\t// }}}\n\n\tassign\tw_advance = (i_new_pc)||((r_v)&&(i_ready));\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read the instruction from the cache\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// We'll read two values from the cache, the first is the value if\n\t// i_pc contains the address we want, the second is the value we'd read\n\t// if lastpc (i.e. $past(i_pc)) was the address we wanted.\n\tinitial\tr_pc = 0;\n\talways @(posedge i_clk)\n\tbegin\n\t\t// We don't have the",
            "logic to select what to read, we must\n\t\t// read both the value at i_pc and lastpc.  cache[i_pc] is\n\t\t// the value we return if the last cache request was in the\n\t\t// cache on the last clock, cacne[lastpc] is the value we\n\t\t// return if we've been stalled, weren't valid, or had to wait\n\t\t// a clock or two.\n\t\t//\n\t\t// Part of the issue here is that i_pc is going to increment\n\t\t// on this clock before we know whether or not the cache entry\n\t\t// we've just read is valid.  We can't stop this.  Hence, we\n\t\t// need to read from the lastpc entry.\n\t\t//\n\t\t//\n\t\t// Here we keep track of which answer we want/need.\n\t\t// If we reported a valid value to the CPU on the last clock,\n\t\t// and the CPU wasn't stalled, then we want to use i_pc.\n\t\t// Likewise if the CPU gave us an i_new_pc request, then we'll\n\t\t// want to return the value associated with reading the cache\n\t\t// at i_pc.\n\t\tisrc <= w_advance;\n\n\t\t// Here we read both cache entries, at i_pc and lastpc.\n\t\t// We'll select from among these cache possibilities on the\n\t\t// next clock\n\t\tr_pc_cache <= cache[i_pc[WBLSB +: CW]];\n\t\tr_last_cache <= cache[lastpc[WBLSB +: CW]];\n\t\t//\n\t\t// Let's also",
            "reg ister(delay) the r_pc value for the next\n\t\t// clock, so we can accurately report the address of the cache\n\t\t// value we just looked up.\n\t\tif (w_advance)\n\t\t\tr_pc <= i_pc;\n\t\telse\n\t\t\tr_pc <= lastpc;\n\tend\n\n\t// On our next clock, our result with either be the",
            "reg istered i_pc\n\t// value from the last clock (if isrc), otherwise r_lastpc\n\tassign\to_pc  = r_pc;\n\t// The same applies for determining what the next",
            "output instruction\n\t// will be.  We just read it in the last clock, now we just need to\n\t// select between the two possibilities we just read.\n\tassign\tcache_word = (isrc) ? r_pc_cache : r_last_cache;\n\tgenerate if (BUS_WIDTH == INSN_WIDTH)\n\tbegin : GEN_INSN\n\n\t\tassign\to_insn = cache_word;\n\n\tend else begin : SHIFT_INSN",
            "wire [BUS_WIDTH-1:0]\t\tshifted;",
            "wire [WBLSB-INLSB-1:0]\tshift;\n\n\t\tassign\tshift = r_pc[WBLSB-1:INLSB];\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin : GEN_LIL_ENDIAN_SHIFT\n\t\t\tassign\tshifted = cache_word >> (INSN_WIDTH*shift);\n\t\t\tassign\to_insn= shifted[INSN_WIDTH-1:0];\n\n\t\tend else begin : BIG_ENDIAN_SHIFT\n\n\t\t\tassign\tshifted = cache_word << (INSN_WIDTH*shift);\n\t\t\tassign o_insn=shifted[BUS_WIDTH-1:BUS_WIDTH-INSN_WIDTH];\n\n\t\tend\n\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_shift;\n\t\tassign\tunused_shift = &{ 1'b0, shifted };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read the tag value associated with this cache line\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tassign\tpc_tag    =   i_pc[WBLSB+LS +: (AW-LS)];\n\tassign\tpc_line   =   i_pc[WBLSB+LS +: (CW-LS)];\n\tassign\tlast_line = lastpc[WBLSB+LS +: (CW-LS)];\n\n\t//\n\t// Read the tag value associated with this i_pc value\n\talways @(posedge i_clk)\n\t\tpc_tag_lookup <= { cache_tags[pc_line], pc_line };\n\t\t// tagvalipc <= cache_tags[i_pc[WBLSB + LS +: (CW-LS)]];\n\n\n\t//\n\t// Read the tag value associated with the lastpc value, from what\n\t// i_pc was when we could not tell if this value was in our cache or\n\t// not, or perhaps from when we determined that i was not in the cache.\n\t// initial\ttagvallst = 0;\n\talways @(posedge i_clk)\n\t\tlast_tag_lookup <= { cache_tags[last_line], last_line };\n\t\t// tagvallst <= cache_tags[lastpc[WBLSB + LS +: (CW-LS)]];\n\n\t// Select from between these two values on the next clock\n\tassign\ttag_lookup = (isrc)? pc_tag_lookup : last_tag_lookup;\n\n\t// i_pc will only increment when everything else isn't stalled, thus\n\t// we can set it without worrying about that.   Doing this enables\n\t// us to work in spite of stalls.  For example, if the next address\n\t// isn't valid, but the decoder is stalled, get the next address\n\t// anyway.\n\tinitial\tlastpc = 0;\n\talways @(posedge i_clk)\n\tif (w_advance)\n\t\tlastpc <= i_pc;\n\n\tassign\tlasttag = lastpc[WBLSB + LS +: (AW-LS)];\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Use the tag value to determine if our",
            "output instruction will be\n\t// valid.\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tassign\tw_v_from_pc = ((pc_tag == lasttag) &&(tag_lookup == pc_tag)\n\t\t\t\t&& valid_mask[pc_line]);\n\tassign\tw_v_from_last = ((tag_lookup == lasttag)\n\t\t\t\t&&(valid_mask[last_line]));\n\n\tinitial\tdelay = 2'h3;\n\talways @(posedge i_clk)\n\tif (i_reset || i_clear_cache || w_advance)\n\tbegin\n\t\t// Source our valid signal from i_pc\n\t\trvsrc <= 1'b1;\n\t\t// Delay at least two clocks before declaring that\n\t\t// we have an invalid result.  This will give us time\n\t\t// to check the tag value of what's in the cache.\n\t\tdelay <= 2'h2;\n\tend else if (!r_v && !o_illegal)\n\tbegin\n\t\t// If we aren't sourcing our valid signal from the\n\t\t// i_pc clock, then we are sourcing it from the\n\t\t// lastpc clock (one clock later).  If r_v still\n\t\t// isn't valid, we may need to make a bus request.\n\t\t// Apply our timer and timeout.\n\t\trvsrc <= 1'b0;\n\n\t\t// Delay is two once the bus starts, in case the\n\t\t// bus transaction needs to be restarted upon completion\n\t\t// This might happen if, after we start loading the\n\t\t// cache, we discover a branch.  The cache load will\n\t\t// still complete, but the branches address needs to be\n\t\t// the onen we jump to.  This may mean we need to load\n\t\t// the cache twice.\n\t\tif (o_wb_cyc)\n\t\t\tdelay <= 2'h2;\n\t\telse if (delay != 0)\n\t\t\tdelay <= delay + 2'b11; // i.e. delay -= 1;\n\tend else begin\n\t\t// After sourcing our",
            "output from i_pc, if it wasn't\n\t\t// accepted, source the instruction from the lastpc valid\n\t\t// determination instead\n\t\trvsrc <= 1'b0;\n\t\tif (o_illegal)\n\t\t\tdelay <= 2'h2;\n\tend\n\n\tassign\tw_invalidate_result = (i_reset)||(i_clear_cache);\n\n\tinitial\tr_v_from_pc = 0;\n\tinitial\tr_v_from_last = 0;\n\talways @(posedge i_clk)\n\tbegin\n\t\tr_v_from_pc   <= (w_v_from_pc)&&(!w_invalidate_result)\n\t\t\t\t\t&&(!o_illegal);\n\t\tr_v_from_last <= (w_v_from_last)&&(!w_invalidate_result);\n\tend\n\n\t// Now use rvsrc to determine which of the two valid flags we'll be\n\t// using: r_v_from_pc (the i_pc address), or r_v_from_last (the lastpc\n\t// address)\n\tassign\tr_v = ((rvsrc)?(r_v_from_pc):(r_v_from_last));\n\n\talways @(*)\n\t\to_valid = r_v || o_illegal;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// If the instruction isn't in our cache, then we need to load\n\t// a new cache line from memory.\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tinitial\tneedload = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_clear_cache || o_wb_cyc)\n\t\tneedload <= 1'b0;\n\telse if ((w_advance)&&(!o_illegal))\n\t\tneedload <= 1'b0;\n\telse\n\t\tneedload <= (delay==0)&&(!w_v_from_last)\n\t\t\t// Prevent us from reloading an illegal address\n\t\t\t// (i.e. one that produced a bus error) over and over\n\t\t\t// and over again\n\t\t\t&&(!illegal_valid ||(lasttag != illegal_cache));\n\n\t//\n\t// Working from the rule that you want to keep complex",
            "logic out of\n\t// a state machine if possible, we calculate a \"last_stb\" value one\n\t// clock ahead of time.  Hence, any time a request is accepted, if\n\t// last_stb is also true we'll know we need to drop the strobe line,\n\t// having finished requesting a complete cache  line.\n\tinitial\tlast_addr = 1'b0;\n\talways @(posedge i_clk)\n\tif (!o_wb_cyc)\n\t\tlast_addr <= 1'b0;\n\telse if ((o_wb_addr[(LS-1):1] == {(LS-1){1'b1}})\n\t\t\t&&((!i_wb_stall)|(o_wb_addr[0])))\n\t\tlast_addr <= 1'b1;\n\n\t//\n\t// \"last_ack\" is almost identical to last_addr, save that this\n\t// will be true on the same clock as the last acknowledgment from the\n\t// bus.  The state machine",
            "logic will use this to determine when to\n\t// get off the bus and end the wishbone bus cycle.\n\tinitial\tlast_ack = 1'b0;\n\talways @(posedge i_clk)\n\t\tlast_ack <= (o_wb_cyc)&&(\n\t\t\t\t(wraddr[(LS-1):1]=={(LS-1){1'b1}})\n\t\t\t\t&&((wraddr[0])||(i_wb_ack)));\n\n\tinitial\tbus_abort = 1'b0;\n\talways @(posedge i_clk)\n\tif (!o_wb_cyc)\n\t\tbus_abort <= 1'b0;\n\telse if (i_clear_cache || i_new_pc)\n\t\tbus_abort <= 1'b1;\n\n\t//\n\t// Here's the difficult piece of state machine",
            "logic --the part that\n\t// determines o_wb_cyc and o_wb_stb.  We've already moved most of the\n\t// complicated",
            "logic off of this statemachine, calculating it one cycle\n\t// early.  As a result, this is a fairly easy piece of",
            "logic .\n\tinitial\to_wb_cyc  = 1'b0;\n\tinitial\to_wb_stb  = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_clear_cache)\n\tbegin\n\t\to_wb_cyc <= 1'b0;\n\t\to_wb_stb <= 1'b0;\n\tend else if (o_wb_cyc)\n\tbegin\n\t\tif (i_wb_err)\n\t\t\to_wb_stb <= 1'b0;\n\t\telse if (o_wb_stb && !i_wb_stall && last_addr)\n\t\t\to_wb_stb <= 1'b0;\n\n\t\tif ((i_wb_ack && last_ack )|| i_wb_err)\n\t\t\to_wb_cyc <= 1'b0;\n\n\tend else if (needload && !i_new_pc)\n\tbegin\n\t\to_wb_cyc  <= 1'b1;\n\t\to_wb_stb  <= 1'b1;\n\tend\n\n\t// If we are reading from this cache line, then once we get the first\n\t// acknowledgement, this cache line has the new tag value\n\talways @(posedge i_clk)\n\tif (o_wb_cyc && i_wb_ack)\n\t\tcache_tags[o_wb_addr[(CW-1):LS]] <= o_wb_addr[(AW-1):CW];\n\n\n\t// On each acknowledgment, increment the address we use to write into\n\t// our cache.  Hence, this is the write address into our cache block\n\t// RAM.\n\tinitial\twraddr    = 0;\n\talways @(posedge i_clk)\n\tif (o_wb_cyc && i_wb_ack && !last_ack)\n\t\twraddr[LS-1:0] <= wraddr[LS-1:0] + 1'b1;\n\telse if (!o_wb_cyc)\n\t\twraddr <= { last_line, {(LS){1'b0}} };\n\n\t//\n\t// The wishbone request address.  This has meaning anytime o_wb_stb\n\t// is active, and needs to be incremented any time an address is\n\t// accepted--WITH THE EXCEPTION OF THE LAST ADDRESS.  We need to keep\n\t// this steady for that last address, unless the last address returns\n\t// a bus error.  In that case, the whole cache line will be marked as\n\t// invalid--but we'll need the value of this",
            "reg ister to know how\n\t// to do that propertly.\n\tinitial\to_wb_addr = {(AW){1'b0}};\n\talways @(posedge i_clk)\n\tif ((o_wb_stb)&&(!i_wb_stall)&&(!last_addr))\n\t\to_wb_addr[(LS-1):0] <= o_wb_addr[(LS-1):0]+1'b1;\n\telse if (!o_wb_cyc)\n\t\to_wb_addr <= { lasttag, {(LS){1'b0}} };\n\n\t// Since it is impossible to initialize an array, our cache will start\n\t// up cache uninitialized.  We'll also never get a valid ack without\n\t// cyc being active, although we might get one on the clock after\n\t// cyc was active--so we need to test and gate on whether o_wb_cyc\n\t// is true.\n\t//\n\t// wraddr will advance forward on every clock cycle where ack is true,\n\t// hence we don't need to check i_wb_ack here.  This will work because\n\t// multiple writes to the same address, ending with a valid write,\n\t// will always yield the valid write's value only after our bus cycle\n\t// is over.\n\talways @(posedge i_clk)\n\tif (o_wb_cyc)\n\t\tcache[wraddr] <= i_wb_data;\n\n\t// VMask ... is a section loaded?\n\t// Note \"svmask\".  It's purpose is to delay the valid_mask setting by\n\t// one clock, so that we can insure the right value of the cache is\n\t// loaded before declaring that the cache line is valid.  Without\n\t// this, the cache line would get read, and the instruction would\n\t// read from the last cache line.\n\tinitial\tvalid_mask = 0;\n\tinitial\tsvmask = 1'b0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(i_clear_cache))\n\tbegin\n\t\tvalid_mask <= 0;\n\t\tsvmask<= 1'b0;\n\tend else begin\n\t\tsvmask <= (o_wb_cyc && i_wb_ack && last_ack && !bus_abort);\n\n\t\tif (svmask)\n\t\t\tvalid_mask[saddr] <= !bus_abort;\n\t\tif (!o_wb_cyc && needload)\n\t\t\tvalid_mask[last_line] <= 1'b0;\n\tend\n\n\talways @(posedge i_clk)\n\tif ((o_wb_cyc)&&(i_wb_ack))\n\t\tsaddr <= wraddr[(CW-1):LS];\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Handle bus errors here.  If a bus read request\n\t// returns an error, then we'll mark the entire\n\t// line as having a (valid) illegal value.\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t//\n\tinitial\tillegal_cache = 0;\n\tinitial\tillegal_valid = 0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(i_clear_cache))\n\tbegin\n\t\tillegal_cache <= 0;\n\t\tillegal_valid <= 0;\n\tend else if ((o_wb_cyc)&&(i_wb_err))\n\tbegin\n\t\tillegal_cache <= o_wb_addr[(AW-1):LS];\n\t\tillegal_valid <= 1'b1;\n\tend else if ((o_wb_cyc)&&(i_wb_ack)&&(last_ack)&&(!bus_abort)\n\t\t\t&&(wraddr[(CW-1):LS] == illegal_cache[CW-1:LS]))\n\t\tillegal_valid <= 1'b0;\n\n\tinitial o_illegal = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset || i_clear_cache || i_new_pc)\n\t\to_illegal <= 1'b0;\n\t// else if ((o_illegal)||((o_valid)&&(i_ready)))\n\t//\to_illegal <= 1'b0;\n\telse if (!o_illegal)\n\tbegin\n\t\to_illegal <= (!i_wb_err)&&(illegal_valid)&&(!isrc)\n\t\t\t&&(illegal_cache == lasttag);\n\tend\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal property section\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Declarations, reset, and f_past_valid\n\t// {{{",
            "localparam F_LGDEPTH=LS+1;",
            "reg f_past_valid;",
            "reg [4:0]\t\tf_cpu_delay;",
            "reg [((1<<(LGLINES))-1):0]\tf_past_valid_mask;",
            "reg [AW+WBLSB-1:0]\tf_next_pc;",
            "reg [AW+WBLSB-1:0]\tf_next_lastpc;",
            "wire [WBLSB+AW-1:0]\tf_const_addr, f_address;",
            "wire f_const_illegal;",
            "wire [BUSW-1:0]\tf_const_insn;",
            "wire [(F_LGDEPTH-1):0]\tf_nreqs, f_nacks, f_outstanding;",
            "wire [INSN_WIDTH-1:0]\tf_insn;\n\n\t(* anyconst *)",
            "reg [BUS_WIDTH-1:0]\t\tf_const_word;\n\n\n\t// Keep track of a flag telling us whether or not $past()\n\t// will return valid results\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\t//\n\t// Assume we start from a reset condition\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions about our",
            "input s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tffetch #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(AW + WBLSB-INLSB), .OPT_CONTRACT(1'b1)\n\t\t// }}}\n\t) fcpu(\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.cpu_new_pc(i_new_pc),\n\t\t.cpu_clear_cache(i_clear_cache),\n\t\t.cpu_pc(i_pc), .cpu_ready(i_ready), .pf_valid(o_valid),\n\t\t.pf_insn(o_insn), .pf_pc(o_pc), .pf_illegal(o_illegal),\n\t\t.fc_pc(f_const_addr), .fc_illegal(f_const_illegal),\n\t\t.fc_insn(f_const_insn), .f_address(f_address)\n\t\t// }}}\n\t);\n\n\tgenerate if (INSN_WIDTH == BUS_WIDTH)\n\tbegin : F_CONST_NOSHIFT\n\t\talways @(*)\n\t\t\tassume(f_const_word == f_const_insn);\n\tend else begin : F_CONST_SHIFT",
            "wire [WBLSB-INLSB-1:0]\tf_shift;",
            "wire [BUS_WIDTH-1:0]\t\tf_shifted;",
            "wire [INSN_WIDTH-1:0]\tf_insn_check;\n\n\t\tassign\tf_shift = f_const_addr[WBLSB-1:INLSB];\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tassign\tf_shifted = f_const_word >> (INSN_WIDTH * f_shift);\n\t\t\tassign\tf_insn_check = f_shifted[INSN_WIDTH-1:0];\n\t\tend else begin\n\t\t\tassign\tf_shifted = f_const_word << (INSN_WIDTH * f_shift);\n\t\t\tassign\tf_insn_check = f_shifted[BUS_WIDTH-1:BUS_WIDTH-INSN_WIDTH];\n\t\tend\n\n\t\talways @(*)\n\t\t\tassume(f_insn_check == f_const_insn);\n\n\tend endgenerate\n\n\t//\n\t// Let's make some assumptions about how long it takes our\n\t// phantom bus and phantom CPU to respond.\n\t//\n\t// These delays need to be long enough to flush out any potential\n\t// errors, yet still short enough that the formal method doesn't\n\t// take forever to solve.\n\t//",
            "localparam F_CPU_DELAY = 4;\n\n\n\t// Now, let's repeat this bit but now looking at the delay the CPU\n\t// takes to accept an instruction.\n\talways @(posedge i_clk)\n\t// If no instruction is ready, then keep our counter at zero\n\tif ((!o_valid)||(i_ready))\n\t\tf_cpu_delay <= 0;\n\telse\n\t\t// Otherwise, count the clocks the CPU takes to respond\n\t\tf_cpu_delay <= f_cpu_delay + 1'b1;\n\n`ifdef\tPFCACHE\n\talways @(posedge i_clk)\n\t\tassume(f_cpu_delay < F_CPU_DELAY);\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(*)\n\tif (o_wb_cyc && !bus_abort)\n\t\tassert(!o_valid);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about our",
            "output s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.AW(AW), .DW(BUSW), .F_LGDEPTH(F_LGDEPTH),\n\t\t.F_MAX_STALL(2), .F_MAX_ACK_DELAY(3),\n\t\t.F_MAX_REQUESTS(1<<LS), .F_OPT_SOURCE(1),\n\t\t.F_OPT_RMW_BUS_OPTION(0),\n\t\t.F_OPT_DISCONTINUOUS(0)\n\t\t// }}}\n\t) f_wbm(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\to_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr,\n\t\t\to_wb_data, {(BUSW/8){1'b1}},\n\t\ti_wb_ack, i_wb_stall, i_wb_data, i_wb_err,\n\t\tf_nreqs, f_nacks, f_outstanding\n\t\t// }}}\n\t);\n\n\t// writes are also illegal for a prefetch.\n\talways @(posedge i_clk)\n\tif (o_wb_stb)\n\t\tassert(!o_wb_we);\n\n\talways @(posedge i_clk)\n\tbegin\n\t\tassert(f_nreqs <= (1<<LS));\n\t\tif ((o_wb_cyc)&&(o_wb_stb))\n\t\t\tassert(f_nreqs == o_wb_addr[(LS-1):0]);\n\t\tif ((f_past_valid)&&($past(o_wb_cyc))\n\t\t\t&&(!o_wb_stb)&&(!$past(i_wb_err || i_reset || i_clear_cache)))\n\t\t\tassert(f_nreqs == (1<<LS));\n\tend\n\n\talways @(posedge i_clk)\n\tif (f_past_valid)\n\tbegin\n\t\tif ((!o_wb_cyc)&&($past(o_wb_cyc))&&(!$past(i_reset))\n\t\t\t\t&&(!$past(i_clear_cache)) &&(!$past(i_wb_err)))\n\t\tbegin\n\t\t\tassert(f_nacks == (1<<LS));\n\t\tend else if (o_wb_cyc)\n\t\t\tassert(f_nacks[(LS-1):0] == wraddr[(LS-1):0]);\n\tend\n\n\t// The last-ack line\n\talways @(posedge i_clk)\n\tif (o_wb_cyc)\n\t\tassert(last_ack == (f_nacks == ((1<<LS)-1)));\n\n\t// The valid line for whats being read\n\talways @(posedge i_clk)\n\tif (o_wb_cyc)\n\t\tassert(!valid_mask[o_wb_addr[CW-1:LS]]);\n\n\talways @(posedge i_clk)\n\tif ((illegal_valid)&&(o_wb_cyc))\n\t\tassert(o_wb_addr[AW-1:LS] != illegal_cache);\n\n\tinitial\tf_past_valid_mask = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid_mask <= valid_mask;\n\n\talways @(posedge i_clk)\n\tif ((o_valid)&&($past(!o_valid || !o_illegal)))\n\t\tassert((!o_wb_cyc)\n\t\t\t||(o_wb_addr[AW-1:LS] != o_pc[WBLSB+LS +: (AW-LS)]));\n\n\talways @(posedge i_clk)\n\tif (illegal_valid)\n\tbegin\n\t\tassert((!o_wb_cyc)\n\t\t\t||(o_wb_addr[AW-1:LS] != illegal_cache));\n\n\t\t// The illegal cache line should never be valid within our\n\t\t// cache\n\t\tassert((!valid_mask[illegal_cache[CW-1:LS]])\n\t\t\t||(cache_tags[illegal_cache[CW-1:LS]]\n\t\t\t\t\t!= illegal_cache[AW-1:CW]));\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about our return responses to the CPU\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\n\tgenerate if (INSN_WIDTH == BUS_WIDTH)\n\tbegin : F_OWORD_NOSHIFT\n\n\t\tassign\tf_insn = cache[o_pc[WBLSB +: CW]];\n\n\tend else begin : F_OWORD_SHIFT",
            "wire [WBLSB-INLSB-1:0]\tf_shift;",
            "wire [BUS_WIDTH-1:0]\t\tf_shifted;\n\n\t\tassign\tf_shift = o_pc[WBLSB-1:INLSB];\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\tassign\tf_shifted = cache[o_pc[WBLSB +: CW]] >> (INSN_WIDTH * f_shift);\n\t\t\tassign\tf_insn = f_shifted[INSN_WIDTH-1:0];\n\t\tend else begin\n\t\t\tassign\tf_shifted = cache[o_pc[WBLSB +: CW]] << (INSN_WIDTH * f_shift);\n\t\t\tassign\tf_insn = f_shifted[BUS_WIDTH-1:BUS_WIDTH-INSN_WIDTH];\n\t\tend\n\n\tend endgenerate\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_wb_cyc)))\n\t\tassert(o_wb_addr[(AW-1):LS] == $past(o_wb_addr[(AW-1):LS]));\n\n\talways @(posedge i_clk)\n\tif (o_valid && !i_new_pc)\n\tbegin\n\t\tif (!o_illegal)\n\t\tbegin\n\t\t\tassert(valid_mask[o_pc[WBLSB+LS +: (CW-LS)]]);\n\t\t\tassert(cache_tags[o_pc[WBLSB+LS +: (CW-LS)]] == o_pc[WBLSB+CW +: (AW-CW)]);\n\t\t\tassert(o_insn == f_insn);\n\t\t\tassert((!illegal_valid)\n\t\t\t\t||(illegal_cache != o_pc[WBLSB+LS +: (AW-LS)]));\n\t\tend\n\n\t\tif ($rose(o_illegal))\n\t\t\tassert(o_illegal == ($past(illegal_valid)\n\t\t\t\t&&($past(illegal_cache)== o_pc[WBLSB+LS +: (AW-LS)])));\n\tend else if (!i_reset && !i_new_pc && !i_clear_cache)\n\t\tassert(o_pc == f_address);\n\n\talways @(*)\n\tif (!i_reset && !i_new_pc && !i_clear_cache)\n\t\tassert(o_illegal || o_pc == f_address);\n\n\talways @(*)\n\tbegin\n\t\tf_next_lastpc = lastpc + 4;\n\t\tf_next_lastpc[1:0] = 2'b00;\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&& !$past(i_reset || i_clear_cache)\n\t\t\t\t\t&& !o_illegal && !i_new_pc\n\t\t\t&& !i_clear_cache)\n\tbegin\n\t\tassert(lastpc == r_pc);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(o_valid)&&($past(o_valid))\n\t\t&&(!$past(i_reset))\n\t\t&&(!$past(i_new_pc))\n\t\t&&(!$past(i_ready))\n\t\t&&(!o_illegal))\n\tbegin\n\t\tassert(cache_tags[o_pc[WBLSB+LS +: (CW-LS)]] == o_pc[WBLSB+CW +: (AW-CW)]);\n\tend\n\n\t//\n\t// If an instruction is accepted, we should *always* move on to another\n\t// instruction.  The only exception is following an i_new_pc (or\n\t// other invalidator), at which point the next instruction should\n\t// be invalid.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&& $past(o_valid && i_ready && !o_illegal && !i_new_pc))\n\tbegin\n\t\t// Should always advance the instruction\n\t\tassert((!o_valid)||(o_pc != $past(o_pc)));\n\tend\n\n\t//\n\t// Once an instruction becomes valid, it should never become invalid\n\t// unless there's been a request for a new instruction.\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset || i_clear_cache))\n\tbegin\n\t\tassert(!o_valid);\n\t\tassert(!o_illegal);\n\tend else if ($past(o_valid && !i_ready && !i_new_pc))\n\tbegin\n\t\tif (!$past(o_illegal))\n\t\tbegin\n\t\t\tassert(o_valid);\n\t\t\tassert(!o_illegal);\n\t\t\tassert($stable(o_insn));\n\t\tend else\n\t\t\tassert(o_illegal);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Assertions associated with a response to a known address request\n\t// That is, if you assume a value exists at an arbitrary address,\n\t// prove that this value is returned whenever that arbitrary address's\n\t// value gets returned.\n\t//",
            "wire f_this_pc, f_this_insn, f_this_data, f_this_line,\n\t\t\tf_this_ack, f_this_tag; // f_this_addr;",
            "wire [LS-1:0]\tf_const_line;",
            "wire [AW-LS-1:0]\tf_const_tag;\n\n\tassign\tf_const_line = f_const_addr[WBLSB+LS +: (CW-LS)];\n\tassign\tf_const_tag  = f_const_addr[WBLSB+LS +: (AW-LS)];\n\n\tassign\tf_this_pc   = (o_pc == f_const_addr);\n\t// assign\tf_this_addr = (o_wb_addr == f_const_addr[AW-1:0] );\n\tassign\tf_this_insn = (o_insn == f_const_insn);\n\tassign\tf_this_data = (i_wb_data == f_const_word);\n\tassign\tf_this_line = (o_wb_addr[AW-1:LS] == f_const_tag);\n\tassign\tf_this_ack  = (f_this_line)&&(f_nacks == f_const_addr[WBLSB +: LS]);\n\tassign\tf_this_tag  = (tag_lookup == f_const_tag);\n\n\talways @(posedge i_clk)\n\tif ((o_valid)&&(f_this_pc)&&(!$past(o_illegal)))\n\tbegin\n\t\tassert(o_illegal == f_const_illegal);\n\t\tif (!o_illegal)\n\t\tbegin\n\t\t\tassert(f_this_insn);\n\t\t\tassert(f_this_tag);\n\t\tend\n\tend\n\n\talways @(*)\n\tif ((valid_mask[f_const_line])\n\t\t\t&&(cache_tags[f_const_line]==f_const_addr[WBLSB+CW +: (AW-CW)]))\n\tbegin\n\t\tassert(f_const_word == cache[f_const_addr[WBLSB +: CW]]);\n\tend else if ((o_wb_cyc)&&(o_wb_addr[AW-1:LS] == f_const_addr[WBLSB+LS +: (AW-LS)])\n\t\t\t\t&&(f_nacks > f_const_addr[WBLSB +: LS]))\n\tbegin\n\t\tassert(f_const_word == cache[f_const_addr[WBLSB +: CW]]);\n\tend\n\n\talways @(*)\n\tif (o_wb_cyc)\n\t\tassert(wraddr[CW-1:LS] == o_wb_addr[CW-1:LS]);\n\n\talways @(*)\n\tif (!f_const_illegal)\n\t\tassert((!illegal_valid) ||(illegal_cache != f_const_tag));\n\telse\n\t\tassert(cache_tags[f_const_line] != f_const_addr[WBLSB+CW +: (AW-CW)]\n\t\t\t|| !valid_mask[f_const_line]);\n\n\talways @(*)\n\tif ((f_this_line)&&(o_wb_cyc))\n\tbegin\n\t\tif (f_const_illegal)\n\t\tbegin\n\t\t\tassume(!i_wb_ack);\n\t\tend else\n\t\t\tassume(!i_wb_err);\n\n\t\tif ((f_this_ack)&&(i_wb_ack))\n\t\t\tassume(f_this_data);\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg f_valid_legal;\n\talways @(*)\n\t\tf_valid_legal = o_valid && (!o_illegal);\n\talways @(posedge i_clk)\t\t// Trace 0\n\t\tcover((o_valid)&&( o_illegal));\n\talways @(posedge i_clk)\t\t// Trace 1\n\t\tcover(f_valid_legal);\n\talways @(posedge i_clk)\t\t// Trace 2\n\t\tcover((f_valid_legal)\n\t\t\t&&($past(!o_valid && !i_new_pc))\n\t\t\t&&($past(i_new_pc,2)));\n\talways @(posedge i_clk)\t\t// Trace 3\n\t\tcover((f_valid_legal)&&($past(i_ready))&&($past(i_new_pc)));\n\talways @(posedge i_clk)\t\t// Trace 4\n\t\tcover((f_valid_legal)&&($past(f_valid_legal && i_ready)));\n\talways @(posedge i_clk)\t\t// Trace 5\n\t\tcover((f_valid_legal)\n\t\t\t&&($past(f_valid_legal && i_ready))\n\t\t\t&&($past(f_valid_legal && i_ready,2))\n\t\t\t&&($past(f_valid_legal && i_ready,3)));\n\talways @(posedge i_clk)\t\t// Trace 6\n\t\tcover((f_valid_legal)\n\t\t\t&&($past(f_valid_legal && i_ready))\n\t\t\t&&($past(f_valid_legal && i_ready,2))\n\t\t\t&&($past(!o_illegal && i_ready && i_new_pc,3))\n\t\t\t&&($past(f_valid_legal && i_ready,4))\n\t\t\t&&($past(f_valid_legal && i_ready,5))\n\t\t\t&&($past(f_valid_legal && i_ready,6)));\n\t// }}}\n`endif\t// FORMAL\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "dcache.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/dcache.v",
        "chunks": [
            "module dcache #(\n\t\t// {{{",
            "parameter LGCACHELEN = 8,\n\t\t\t\tBUS_WIDTH=32,\n\t\t\t\tADDRESS_WIDTH=32-$clog2(BUS_WIDTH/8),\n\t\t\t\tLGNLINES=(LGCACHELEN-3), // Log of the number of separate cache lines\n\t\t\t\tNAUX=5,\t// # of aux d-",
            "wire s to keep aligned w/memops",
            "parameter DATA_WIDTH=32, // CPU's",
            "reg ister width",
            "parameter [0:0]\tOPT_LOCAL_BUS=1'b1,",
            "parameter [0:0]\tOPT_PIPE=1'b1,",
            "parameter [0:0]\tOPT_LOCK=1'b1,",
            "parameter [0:0]\tOPT_DUAL_READ_PORT=1'b1,",
            "parameter OPT_FIFO_DEPTH = 4,",
            "localparam AW = ADDRESS_WIDTH, // Just for ease of notation below",
            "localparam CS = LGCACHELEN, // Number of bits in a cache address",
            "localparam LS = CS-LGNLINES, // Bits to spec position w/in cline\n`ifdef\tFORMAL",
            "parameter F_LGDEPTH=1 + (((!OPT_PIPE)||(LS > OPT_FIFO_DEPTH))\n\t\t\t\t\t\t? LS : OPT_FIFO_DEPTH),\n`endif",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,\n\t\t//",
            "localparam DW = 32, // Bus data width",
            "localparam DP = OPT_FIFO_DEPTH,",
            "localparam WBLSB = $clog2(BUS_WIDTH/8),\n\t\t//",
            "localparam DLSB = $clog2(DATA_WIDTH/8),\n\t\t//",
            "localparam [1:0]\tDC_IDLE  = 2'b00, // Bus is idle",
            "localparam [1:0]\tDC_WRITE = 2'b01, // Write",
            "localparam [1:0]\tDC_READS = 2'b10, // Read a single value(!cachd)",
            "localparam [1:0]\tDC_READC = 2'b11 // Read a whole cache line\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset, i_clear,\n\t\t// Interface from the CPU\n\t\t// {{{",
            "input ",
            "wire i_pipe_stb, i_lock,",
            "input ",
            "wire [2:0]\ti_op,",
            "input ",
            "wire [DATA_WIDTH-1:0]\ti_addr,",
            "input ",
            "wire [DATA_WIDTH-1:0]\ti_data,",
            "input ",
            "wire [(NAUX-1):0] i_o",
            "reg , // Aux data, such as",
            "reg to write to\n\t\t// Outputs, going back to the CPU",
            "output ",
            "reg o_busy, o_rdbusy,",
            "output ",
            "reg o_pipe_stalled,",
            "output ",
            "reg o_valid, o_err,",
            "output ",
            "reg [(NAUX-1):0]\to_w",
            "reg ,",
            "output ",
            "reg [DATA_WIDTH-1:0]\to_data,\n\t\t// }}}\n\t\t// Wishbone bus master",
            "output s\n\t\t// {{{",
            "output ",
            "wire o_wb_cyc_gbl, o_wb_cyc_lcl,",
            "output ",
            "reg o_wb_stb_gbl, o_wb_stb_lcl,",
            "output ",
            "reg o_wb_we,",
            "output ",
            "reg [(AW-1):0]\to_wb_addr,",
            "output ",
            "reg [BUS_WIDTH-1:0]\to_wb_data,",
            "output ",
            "wire [BUS_WIDTH/8-1:0]\to_wb_sel,\n\t\t// Wishbone bus slave response",
            "input s",
            "input ",
            "wire i_wb_stall, i_wb_ack, i_wb_err,",
            "input ",
            "wire [BUS_WIDTH-1:0]\ti_wb_data\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam FIF_WIDTH = (NAUX-1)+2+WBLSB;\n\tinteger\t\t\tik;\n\n`ifdef FORMAL",
            "wire [(F_LGDEPTH-1):0]\tf_nreqs, f_nacks, f_outstanding;",
            "wire f_pc, f_gie, f_read_cycle;",
            "reg f_past_valid;\n`endif\n\t//\n\t//",
            "output ",
            "reg [31:0]\t\to_debug;",
            "reg cyc, stb, last_ack, end_of_line, last_line_stb;",
            "reg r_wb_cyc_gbl, r_wb_cyc_lcl;\n\t// npending is the number of pending non-cached operations, counted\n\t// from the i_pipe_stb to the o_wb_ack",
            "reg [DP:0]\tnpending;",
            "reg [((1<<LGNLINES)-1):0] c_v;\t// One bit per cache line, is it valid?",
            "reg [(AW-LS-1):0]\tc_vtags\t[0:((1<<LGNLINES)-1)];",
            "reg [BUS_WIDTH-1:0]\tc_mem\t[0:((1<<CS)-1)];",
            "reg set_vflag;",
            "reg [1:0]\t\tstate;",
            "reg [(CS-1):0]\twr_addr;",
            "reg [BUS_WIDTH-1:0]\t\tcached_iword, cached_rword;",
            "reg lock_gbl, lock_lcl;\n\n\n\t// To simplify writing to the cache, and the job of the synthesizer to\n\t// recognize that a cache write needs to take place, we'll take an extra\n\t// clock to get there, and use these c_w...",
            "reg isters to capture the\n\t// data in the meantime.",
            "reg c_wr;",
            "reg [BUS_WIDTH-1:0]\tc_wdata;",
            "reg [BUS_WIDTH/8-1:0]\tc_wsel;",
            "reg [(CS-1):0]\tc_waddr;",
            "reg [(AW-LS-1):0]\tlast_tag;",
            "reg last_tag_valid;",
            "wire [(LGNLINES-1):0]\ti_cline;",
            "wire [(CS-1):0]\ti_caddr;\n\n`ifdef\tFORMAL",
            "reg [F_LGDEPTH-1:0]\tf_fill;",
            "reg [AW:0]\t\tf_return_address;",
            "reg [AW:0]\t\tf_pending_addr;",
            "reg f_pc_pending;",
            "wire [4:0]\t\tf_last_",
            "reg , f_addr_",
            "reg ;\n\t// Verilator lint_off UNDRIVEN\n\t(* anyseq *)",
            "reg [4:0]\tf_a",
            "reg ;\n\t// Verilator lint_on  UNDRIVEN\n`endif",
            "wire cache_miss_inow, w_cachable;",
            "wire raw_cachable_address;",
            "reg r_cachable, r_svalid, r_dvalid, r_rd, r_cache_miss,\n\t\tr_rd_pending;",
            "reg [AW-1:0]\t\tr_addr;",
            "wire [(LGNLINES-1):0]\tr_cline;",
            "wire [(CS-1):0]\t\tr_caddr;",
            "wire [(AW-LS-1):0]\t\tr_ctag;",
            "reg wr_cstb, r_iv, in_cache;",
            "reg [(AW-LS-1):0]\tr_itag;",
            "reg [FIF_WIDTH:0]\treq_data;",
            "reg gie;",
            "reg [BUS_WIDTH-1:0]\tpre_data, pre_shifted;\n\t// }}}\n\n\t// Convenience assignments\n\t// {{{\n\tassign\ti_cline = i_addr[WBLSB +LS +: (CS-LS)];\n\tassign\ti_caddr = i_addr[WBLSB +: CS];\n\n\tassign\tcache_miss_inow = (!last_tag_valid)\n\t\t\t\t||(last_tag != i_addr[WBLSB+LS +: (AW-LS)])\n\t\t\t\t||(!c_v[i_cline]);\n\n\tassign\tw_cachable = ((!OPT_LOCAL_BUS)\n\t\t\t\t||(i_addr[DATA_WIDTH-1:DATA_WIDTH-8]!=8'hff))\n\t\t&&((!i_lock)||(!OPT_LOCK))&&(raw_cachable_address);\n\n\tassign\tr_cline = r_addr[(CS-1):LS];\n\tassign\tr_caddr = r_addr[(CS-1):0];\n\tassign\tr_ctag  = r_addr[(AW-1):LS];\n\t// }}}\n\n\t// Cachability checking\n\t// {{{\n\tiscachable chkaddress(i_addr[0 +: AW+WBLSB], raw_cachable_address);\n\t// }}}\n\n\t// r_* values\n\t// {{{\n\t// The one-clock delayed read values from the cache.\n\t//\n\tinitial\tr_rd = 1'b0;\n\tinitial\tr_cachable = 1'b0;\n\tinitial\tr_svalid = 1'b0;\n\tinitial\tr_dvalid = 1'b0;\n\tinitial\tr_cache_miss = 1'b0;\n\tinitial\tr_addr = 0;\n\tinitial\tlast_tag_valid = 0;\n\tinitial\tr_rd_pending = 0;\n\talways @(posedge i_clk)\n\tbegin\n\t\t// The single clock path\n\t\t// The valid for the single clock path\n\t\t//\tOnly ... we need to wait if we are currently writing\n\t\t//\tto our cache.\n\t\tr_svalid<= (i_pipe_stb)&&(!i_op[0])&&(w_cachable)\n\t\t\t\t&&(!cache_miss_inow)&&(!c_wr)&&(!wr_cstb);\n\n\t\t//\n\t\t// The two clock in-cache path\n\t\t//\n\t\t// Some preliminaries that needed to be calculated on the first\n\t\t// clock\n\t\tif ((!o_pipe_stalled)&&(!r_rd_pending))\n\t\t\tr_addr <= i_addr[WBLSB +: AW];\n\t\tif ((!o_pipe_stalled)&&(!r_rd_pending))\n\t\tbegin\n\t\t\tr_iv   <= c_v[i_cline];\n\t\t\t// r_itag <= c_vtags[i_cline];\n\t\t\tr_cachable <= (!i_op[0])&&(w_cachable)&&(i_pipe_stb);\n\t\t\tr_rd_pending <= (i_pipe_stb)&&(!i_op[0])&&(w_cachable)\n\t\t\t\t&&((cache_miss_inow)||(c_wr)||(wr_cstb));\n\t\t\t\t// &&((!c_wr)||(!wr_cstb));\n\t\tend else begin\n\t\t\tr_iv   <= c_v[r_cline];\n\t\t\t// r_itag <= c_vtags[r_cline];\n\t\t\tr_rd_pending <= (r_rd_pending)\n\t\t\t\t&&((!cyc)||(!i_wb_err))\n\t\t\t\t&&((r_itag != r_ctag)||(!r_iv));\n\t\tend\n\t\tr_rd <= (i_pipe_stb)&&(!i_op[0]);\n\t\t// r_itag contains the tag we didn't have available to us on the\n\t\t// last clock, r_ctag is a bit select from r_addr containing a\n\t\t// one clock delayed address.\n\t\tr_dvalid <= (!r_svalid)&&(!r_dvalid)&&(r_itag == r_ctag)&&(r_iv)\n\t\t\t\t\t\t&&(r_cachable)&&(r_rd_pending);\n\t\tif ((r_itag == r_ctag)&&(r_iv)&&(r_cachable)&&(r_rd_pending))\n\t\tbegin\n\t\t\tlast_tag_valid <= 1'b1;\n\t\t\tlast_tag <= r_ctag;\n\t\tend else if ((state == DC_READC)\n\t\t\t\t&&(last_tag[CS-LS-1:0]==r_addr[CS-1:LS])\n\t\t\t\t&&((i_wb_ack)||(i_wb_err)))\n\t\t\tlast_tag_valid <= 1'b0;\n\n\t\t// r_cache miss takes a clock cycle.  It is only ever true for\n\t\t// something that should be cachable, but isn't in the cache.\n\t\t// A cache miss is only true _if_\n\t\t// 1. A read was requested\n\t\t// 2. It is for a cachable address, AND\n\t\t// 3. It isn't in the cache on the first read\n\t\t//\tor the second read\n\t\t// 4. The read hasn't yet started to get this address\n\t\tr_cache_miss <= ((!cyc)||(o_wb_we))&&(r_cachable)\n\t\t\t\t// One clock path -- miss\n\t\t\t\t&&(!r_svalid)\n\t\t\t\t// Two clock path -- misses as well\n\t\t\t\t&&(r_rd)&&(!r_svalid)\n\t\t\t\t&&((r_itag != r_ctag)||(!r_iv));\n\n\t\tif (i_clear)\n\t\t\tlast_tag_valid <= 0;\n\t\tif (i_reset)\n\t\tbegin\n\t\t\t// r_rd <= 1'b0;\n\t\t\tr_cachable <= 1'b0;\n\t\t\tr_svalid <= 1'b0;\n\t\t\tr_dvalid <= 1'b0;\n\t\t\tr_cache_miss <= 1'b0;\n\t\t\t// r_addr <= 0;\n\t\t\tr_rd_pending <= 0;\n\t\t\tlast_tag_valid <= 0;\n\t\tend\n\tend\n\n\talways @(posedge i_clk)\n\t\tr_itag <= c_vtags[(!o_pipe_stalled && !r_rd_pending) ? i_cline : r_cline];\n\t// }}}\n\n\t// o_wb_sel, r_sel\n\t// {{{\n\tgenerate if (DATA_WIDTH == BUS_WIDTH)\n\tbegin : COPY_SEL\n\t\t// {{{",
            "reg [BUS_WIDTH/8-1:0]\tr_sel;\n\n\t\tinitial\tr_sel = 4'hf;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_sel <= 4'hf;\n\t\telse if (!o_pipe_stalled && (!OPT_LOWPOWER  || i_pipe_stb))\n\t\tbegin\n\t\t\tcasez({i_op[2:1], i_addr[1:0]})\n\t\t\t4'b0???: r_sel <= 4'b1111;\n\t\t\t4'b100?: r_sel <= 4'b1100;\n\t\t\t4'b101?: r_sel <= 4'b0011;\n\t\t\t4'b1100: r_sel <= 4'b1000;\n\t\t\t4'b1101: r_sel <= 4'b0100;\n\t\t\t4'b1110: r_sel <= 4'b0010;\n\t\t\t4'b1111: r_sel <= 4'b0001;\n\t\t\tendcase\n\t\tend else if (OPT_LOWPOWER && !i_wb_stall)\n\t\t\tr_sel <= 4'h0;\n\n\t\tassign\to_wb_sel = (state == DC_READC) ? 4'hf : r_sel;\n\t\t// }}}\n\tend else begin : GEN_SEL\n\t\t// {{{",
            "reg [DATA_WIDTH/8-1:0]\tpre_sel;",
            "reg [BUS_WIDTH/8-1:0]\tfull_sel, r_wb_sel;\n\n\t\talways @(*)\n\t\tcasez(i_op[2:1])\n\t\t2'b0?: pre_sel = {(DATA_WIDTH/8){1'b1}};\n\t\t2'b10: pre_sel = { 2'b11, {(DATA_WIDTH/8-2){1'b0}} };\n\t\t2'b11: pre_sel = { 1'b1,  {(DATA_WIDTH/8-1){1'b0}} };\n\t\tendcase\n\n\t\talways @(*)\n\t\tif (OPT_LOCAL_BUS && (&i_addr[31:24]))\n\t\t\tfull_sel = { {(BUS_WIDTH/8-4){1'b0}}, pre_sel }\n\t\t\t\t\t>> (i_addr[1:0]);\n\t\telse\n\t\t\tfull_sel = { pre_sel, {(BUS_WIDTH/8-4){1'b0}} }\n\t\t\t\t\t\t>> (i_addr[WBLSB-1:0]);\n\n\t\tinitial\tr_wb_sel = -1;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_wb_sel <= -1;\n\t\telse if (i_pipe_stb && (i_op[0] || !w_cachable))\n\t\t\tr_wb_sel <= full_sel;\n\t\telse if (!i_wb_stall)\n\t\t\tr_wb_sel <= -1;\n\n\t\tassign\to_wb_sel = r_wb_sel;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// o_wb_data\n\t// {{{\n\tgenerate if (DATA_WIDTH == BUS_WIDTH)\n\tbegin : GEN_SAME_BUSWIDTH\n\t\t// {{{\n\t\tinitial\to_wb_data = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\to_wb_data <= 0;\n\t\telse if ((!o_busy || !i_wb_stall) && (!OPT_LOWPOWER || i_pipe_stb))\n\t\tbegin\n\t\t\tif (DATA_WIDTH == 32)\n\t\t\tbegin\n\t\t\t\tif (OPT_LOWPOWER)\n\t\t\t\tbegin : ZERO_UNUSED_DATA_BITS\n\t\t\t\t\tcasez({ i_op[2:1], i_addr[1:0] })\n\t\t\t\t\t4'b0???: o_wb_data <= i_data;\n\t\t\t\t\t4'b100?: o_wb_data <= { i_data[15:0], 16'h0 };\n\t\t\t\t\t4'b101?: o_wb_data <= { 16'h0, i_data[15:0] };\n\t\t\t\t\t4'b1100: o_wb_data <= { i_data[7:0], 24'h0 };\n\t\t\t\t\t4'b1101: o_wb_data <= {  8'h0, i_data[7:0], 16'h0 };\n\t\t\t\t\t4'b1110: o_wb_data <= { 16'h0, i_data[7:0],  8'h0 };\n\t\t\t\t\t4'b1111: o_wb_data <= { 24'h0, i_data[7:0] };\n\t\t\t\t\tendcase\n\t\t\t\tend else begin : DUPLICATE_UNUSED_DATA_BITS\n\t\t\t\t\tcasez(i_op[2:1])\n\t\t\t\t\t2'b0?: o_wb_data <= i_data;\n\t\t\t\t\t2'b10: o_wb_data <= { (2){i_data[15:0]} };\n\t\t\t\t\t2'b11: o_wb_data <= { (4){i_data[ 7:0]} };\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\t// Verilator coverage_off\n\t\t\t\tcasez(i_op[2:1])\n\t\t\t\t2'b0?: o_wb_data <= i_data << (8*i_addr[$clog2(DATA_WIDTH)-1:0]);\n\t\t\t\t2'b10: o_wb_data <= { 16'h0, i_data[15:0] } << (8*i_addr[$clog2(DATA_WIDTH)-1:0]);\n\t\t\t\t2'b11: o_wb_data <= { 24'h0, i_data[7:0] } << (8*i_addr[$clog2(DATA_WIDTH)-1:0]);\n\t\t\t\tendcase\n\t\t\t\t// Verilator coverage_on\n\t\t\tend\n\t\tend else if (OPT_LOWPOWER && !i_wb_stall)\n\t\t\to_wb_data <= 0;\n\t\t// }}}\n\tend else begin : GEN_WIDE_BUS\n\t\t// {{{",
            "reg [DATA_WIDTH-1:0]\tpre_shift;",
            "reg [BUS_WIDTH-1:0]\t\twide_preshift, shifted_data;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tcasez(i_op[2:1])\n\t\t\t2'b0?: pre_shift = i_data;\n\t\t\t2'b10: pre_shift = { i_data[15:0],\n\t\t\t\t\t\t{(DATA_WIDTH-16){1'b0}} };\n\t\t\t2'b11: pre_shift = { i_data[ 7:0],\n\t\t\t\t\t\t{(DATA_WIDTH- 8){1'b0}} };\n\t\t\tendcase\n\n\t\t\tif (OPT_LOCAL_BUS && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]))\n\t\t\tbegin\n\t\t\t\twide_preshift = { {(BUS_WIDTH-DATA_WIDTH){1'b0}}, pre_shift };\n\n\t\t\t\tshifted_data = wide_preshift >> (8*i_addr[2-1:0]);\n\t\t\tend else begin\n\t\t\t\twide_preshift = { pre_shift,\n\t\t\t\t\t\t{(BUS_WIDTH-DATA_WIDTH){1'b0}} };\n\n\t\t\t\tshifted_data = wide_preshift >> (8*i_addr[WBLSB-1:0]);\n\t\t\tend\n\t\tend\n\n\t\tinitial\to_wb_data = 0;\n\t\talways @(posedge i_clk)\n\t\tif (OPT_LOWPOWER && i_reset)\n\t\t\to_wb_data <= 0;\n\t\telse if ((!o_busy || !i_wb_stall)\n\t\t\t&& (!OPT_LOWPOWER || (i_pipe_stb && i_op[0])))\n\t\tbegin\n\t\t\tif (!OPT_LOWPOWER)\n\t\t\tbegin\n\t\t\t\tcasez(i_op[2:1])\n\t\t\t\t2'b0?: o_wb_data <= {(BUS_WIDTH/DATA_WIDTH){i_data}};\n\t\t\t\t2'b10: o_wb_data <= {(BUS_WIDTH/16){i_data[15:0]}};\n\t\t\t\t2'b11: o_wb_data <= {(BUS_WIDTH/ 8){i_data[ 7:0]}};\n\t\t\t\tendcase\n\t\t\tend else begin\n\t\t\t\to_wb_data <= shifted_data;\n\t\t\tend\n\t\tend else if (OPT_LOWPOWER && !i_wb_stall)\n\t\t\to_wb_data <= 0;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// Register return FIFO\n\t// {{{\n\tgenerate if (OPT_PIPE)\n\tbegin : OPT_PIPE_FIFO\n\t\t// {{{",
            "reg [FIF_WIDTH-1:0]\tfifo_data [0:((1<<OPT_FIFO_DEPTH)-1)];",
            "reg [DP:0]\t\twraddr, rdaddr;\n\n\t\talways @(posedge i_clk)\n\t\tif (i_pipe_stb)\n\t\t\tfifo_data[wraddr[DP-1:0]]\n\t\t\t\t<= { i_o",
            "reg [NAUX-2:0], i_op[2:1], i_addr[WBLSB-1:0] };\n\n\t\talways @(posedge i_clk)\n\t\tif (i_pipe_stb)\n\t\t\tgie <= i_o",
            "reg [NAUX-1];\n\n`ifdef\tNO_BKRAM",
            "reg [FIF_WIDTH-1:0]\tr_req_data, r_last_data;",
            "reg single_write;\n\n\t\talways @(posedge i_clk)\n\t\t\tr_req_data <= fifo_data[rdaddr[DP-1:0]];\n\n\t\talways @(posedge i_clk)\n\t\t\tsingle_write <= (rdaddr == wraddr)&&(i_pipe_stb);\n\n\t\talways @(posedge i_clk)\n\t\tif (i_pipe_stb)\n\t\t\tr_last_data <= { i_o",
            "reg [NAUX-2:0],\n\t\t\t\t\t\ti_op[2:1], i_addr[WBLSB-1:0] };\n\n\t\talways @(*)\n\t\tbegin\n\t\t\treq_data[NAUX+4-1] = gie;\n\t\t\t// if ((r_svalid)||(state == DC_READ))\n\t\t\tif (single_write)\n\t\t\t\treq_data[FIF_WIDTH-1:0] = r_last_data;\n\t\t\telse\n\t\t\t\treq_data[FIF_WIDTH-1:0] = r_req_data;\n\t\tend\n\n\t\talways @(*)\n\t\t\t`ASSERT(req_data == fifo_data[rdaddr[DP-1:0]]);\n`else\n\t\talways @(*)\n\t\t\treq_data[FIF_WIDTH-1:0] = fifo_data[rdaddr[DP-1:0]];\n\t\talways @(*)\n\t\t\treq_data[FIF_WIDTH] = gie;\n`endif\n\n\t\tinitial\twraddr = 0;\n\t\talways @(posedge i_clk)\n\t\tif ((i_reset)||((cyc)&&(i_wb_err)))\n\t\t\twraddr <= 0;\n\t\telse if (i_pipe_stb)\n\t\t\twraddr <= wraddr + 1'b1;\n\n\t\tinitial\trdaddr = 0;\n\t\talways @(posedge i_clk)\n\t\tif ((i_reset)||((cyc)&&(i_wb_err)))\n\t\t\trdaddr <= 0;\n\t\telse if ((r_dvalid)||(r_svalid))\n\t\t\trdaddr <= rdaddr + 1'b1;\n\t\telse if ((state == DC_WRITE)&&(i_wb_ack))\n\t\t\trdaddr <= rdaddr + 1'b1;\n\t\telse if ((state == DC_READS)&&(i_wb_ack))\n\t\t\trdaddr <= rdaddr + 1'b1;\n\n`ifdef\tFORMAL",
            "reg [AW-1:0]\tf_fifo_addr [0:((1<<OPT_FIFO_DEPTH)-1)];",
            "reg [F_LGDEPTH-1:0]\tf_last_wraddr;",
            "reg [FIF_WIDTH:0]\tf_last_data;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_fill = 0;\n\t\t\tf_fill[DP:0] = wraddr - rdaddr;\n\t\tend\n\n\t\talways @(*)\n\t\t\t`ASSERT(f_fill <= { 1'b1, {(DP){1'b0}} });\n\n\t\talways @(*)\n\t\tif ((r_dvalid)||(r_svalid))\n\t\tbegin\n\t\t\tif (r_svalid)\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_fill == 1);\n\t\t\tend else if (r_dvalid)\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_fill == 1);\n\t\t\tend else\n\t\t\t\t`ASSERT(f_fill == 0);\n\t\tend else if (r_rd_pending)\n\t\tbegin\n\t\t\t`ASSERT(f_fill == 1);\n\t\tend else\n\t\t\t`ASSERT(f_fill == npending);\n\n\n\t\tinitial\tf_pc_pending = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tf_pc_pending <= 1'b0;\n\t\telse if (i_pipe_stb)\n\t\t\tf_pc_pending <= (!i_op[0])&&(i_o",
            "reg [3:1] == 3'h7);\n\t\telse if (f_fill == 0)\n\t\t\tf_pc_pending <= 1'b0;\n\t\t//else if ((o_valid)&&(o_w",
            "reg [3:1] == 3'h7)&&(f_fill == 0))\n\t\t//\tf_pc_pending <= 1'b0;\n\n\t\talways @(posedge i_clk)\n\t\tif (f_pc_pending)\n\t\tbegin\n\t\t\t`ASSUME(!i_pipe_stb);\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tif (state == DC_WRITE)\n\t\tbegin\n\t\t\t`ASSERT(!f_pc_pending);\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_last_wraddr = 0;\n\t\t\tf_last_wraddr[DP:0] = wraddr - 1'b1;\n\t\tend\n\n\t\tassign\tf_last_data = fifo_data[f_last_wraddr];\n\n\t\talways @(posedge i_clk)\n\t\tif (r_rd_pending)\n\t\tbegin\n\t\t\t`ASSERT(f_pc_pending == (f_last_data[1+WBLSB+2 +: 3] == 3'h7));\n\t\t\t`ASSERT({ gie, f_last_data[2+WBLSB +: 4] } == f_last_",
            "reg );\n\t\tend\n\n`define\tINSPECT_FIFO",
            "reg [((1<<(DP+1))-1):0]\tf_valid_fifo_entry;\n\n\t\tgenvar\tgk;\n\t\tfor(gk=0; gk<(1<<(DP+1)); gk=gk+1)\n\t\tbegin\n\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\tf_valid_fifo_entry[gk] = 1'b0;\n\t\t\t/*\n\t\t\tif ((rdaddr[DP] != wraddr[DP])\n\t\t\t\t\t&&(rdaddr[DP-1:0] == wraddr[DP-1:0]))\n\t\t\t\tf_valid_fifo_entry[k] = 1'b1;\n\t\t\telse */\n\t\t\tif ((rdaddr < wraddr)&&(gk < wraddr)\n\t\t\t\t\t&&(gk >= rdaddr))\n\t\t\t\tf_valid_fifo_entry[gk] = 1'b1;\n\t\t\telse if ((rdaddr > wraddr)&&(gk >= rdaddr))\n\t\t\t\tf_valid_fifo_entry[gk] = 1'b1;\n\t\t\telse if ((rdaddr > wraddr)&&(gk <  wraddr))\n\t\t\t\tf_valid_fifo_entry[gk] = 1'b1;\n\t\t\tend\n\n`ifdef\tINSPECT_FIFO",
            "wire [FIF_WIDTH-1:0]\tfifo_data_k;\n\n\t\t\tassign\tfifo_data_k = fifo_data[gk[DP-1:0]];\n\n\t\t\talways @(*)\n\t\t\tif (f_valid_fifo_entry[gk])\n\t\t\tbegin\n\t\t\t\tif (!f_pc_pending)\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT((o_wb_we)||(fifo_data_k[1+2+WBLSB +: 3] != 3'h7));\n\t\t\t\tend else if (gk != f_last_wraddr)\n\t\t\t\t\t`ASSERT(fifo_data_k[1+2+WBLSB +: 3] != 3'h7);\n\t\t\tend\n`endif // INSPECT_FIFO\n\n\t\tend\n\n`ifndef\tINSPECT_FIFO\n\t\talways @(posedge i_clk)\n\t\tif ((r_rd_pending)&&(rdaddr[DP:0] != f_last_wraddr[DP-1]))\n\t\t\tassume(req_data[1+2+WBLSB +: 3] != 3'h7);\n`endif // INSPECT_FIFO\n\n\t\t//\n\t\t//\n\t\t//\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_pending_addr[AW-1:0] = f_fifo_addr[rdaddr];\n\t\t\tf_pending_addr[AW] = r_wb_cyc_lcl;\n\t\tend\n\n\t\t//\n\t\t//\n\t\t//\n\t\talways @(posedge i_clk)\n\t\tif (i_pipe_stb)\n\t\tbegin\n\t\t\tif (OPT_LOCAL_BUS && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]))\n\t\t\t\tf_fifo_addr[wraddr[DP-1:0]] <= { 1'b1, i_addr[2 +: AW] };\n\t\t\telse\n\t\t\t\tf_fifo_addr[wraddr[DP-1:0]] <= { 1'b0, i_addr[WBLSB +: AW] };\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_return_address[AW] = (o_wb_cyc_lcl);\n\t\t\tf_return_address[AW-1:0] = f_fifo_addr[rdaddr];\n\t\t\tif (state == DC_READC)\n\t\t\t\tf_return_address[LS-1:0]\n\t\t\t\t= (o_wb_addr[LS-1:0] - f_outstanding[LS-1:0]);\n\t\tend\n\n`define\tTWIN_WRITE_TEST\n`ifdef\tTWIN_WRITE_TEST",
            "reg [DP:0]\t\tf_twin_next;\n\t\t// Verilator lint_off UNDRIVEN\n\t\t(* anyconst *)",
            "reg [DP:0]\t\tf_twin_base;\n\t\t(* anyconst *)",
            "reg [AW+FIF_WIDTH-1:0]\tf_twin_first,\n\t\t\t\t\t\t\tf_twin_second;\n\t\t// Verilator lint_on  UNDRIVEN",
            "reg f_twin_none, f_twin_single, f_twin_double, f_twin_last;",
            "reg f_twin_valid_one, f_twin_valid_two;\n\n\t\talways @(*)\n\t\t\tf_twin_next = f_twin_base+1;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_twin_valid_one = ((f_valid_fifo_entry[f_twin_base])\n\t\t\t\t&&(f_twin_first == { f_fifo_addr[f_twin_base[DP-1:0]],\n\t\t\t\t\t\tfifo_data[f_twin_base[DP-1:0]] }));\n\t\t\tf_twin_valid_two = ((f_valid_fifo_entry[f_twin_next])\n\t\t\t\t&&(f_twin_second == { f_fifo_addr[f_twin_next[DP-1:0]],\n\t\t\t\t\t\tfifo_data[f_twin_next[DP-1:0]] }));\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_twin_none   =(!f_twin_valid_one)&&(!f_twin_valid_two);\n\t\t\tf_twin_single =( f_twin_valid_one)&&(!f_twin_valid_two);\n\t\t\tf_twin_double =( f_twin_valid_one)&&( f_twin_valid_two);\n\t\t\tf_twin_last   =(!f_twin_valid_one)&&( f_twin_valid_two);\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tif ((!f_past_valid)||($past(i_reset))||($past(cyc && i_wb_err)))\n\t\tbegin\n\t\t\t`ASSERT(f_twin_none);\n\t\tend else if ($past(f_twin_none))\n\t\tbegin\n\t\t\t`ASSERT(f_twin_none || f_twin_single || f_twin_last);\n\t\tend else if ($past(f_twin_single))\n\t\tbegin\n\t\t\t`ASSERT(f_twin_none || f_twin_single || f_twin_double || f_twin_last);\n\t\tend else if ($past(f_twin_double))\n\t\tbegin\n\t\t\t`ASSERT(f_twin_double || f_twin_last);\n\t\tend else if ($past(f_twin_last))\n\t\t\t`ASSERT(f_twin_none || f_twin_single || f_twin_last);\n\n\t\t// f_addr_",
            "reg test\n\t\t// {{{\n\t\talways @(*)\n\t\tif (o_rdbusy)\n\t\tbegin\n\t\tif (f_twin_valid_one && f_twin_base != f_last_wraddr)\n\t\t\t`ASSERT({ gie, f_twin_first[2+WBLSB +: 4] } != f_addr_",
            "reg );\n\t\tif (f_twin_valid_two && f_twin_next != f_last_wraddr)\n\t\t\t`ASSERT({ gie, f_twin_second[2+WBLSB +: 4] } != f_addr_",
            "reg );\n\t\tif ((rdaddr != f_last_wraddr)&&(rdaddr != f_twin_base)\n\t\t\t\t&&(rdaddr != f_twin_next))\n\t\t\tassume({ gie, req_data[2+WBLSB +: 4] } != f_addr_",
            "reg );\n\t\tend\n\t\t// }}}\n\n`endif // TWIN_WRITE_TEST\n\n\t\talways @(*)\n\t\t\t`ASSERT(req_data == { gie, fifo_data[rdaddr[DP-1:0]] });\n\n\t\talways @(posedge i_clk)\n\t\tif (r_svalid||r_dvalid || r_rd_pending)\n\t\tbegin\n\t\t\t`ASSERT(f_fill == 1);\n\t\tend else if (f_fill > 0)\n\t\tbegin\n\t\t\t`ASSERT(cyc);\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tif (state != 0)\n\t\tbegin\n\t\t\t`ASSERT(f_fill > 0);\n\t\tend else if (!r_svalid && !r_dvalid && !r_rd_pending)\n\t\t\t`ASSERT(f_fill == 0);\n\n`endif // FORMAL\n\n\t\talways @(posedge i_clk)\n\t\t\to_w",
            "reg <= req_data[2+WBLSB +: NAUX];\n\t// }}}\n\tend else begin : NO_FIFO\n\t// {{{",
            "reg [AW-1:0]\tfr_last_addr;\n\n\t\talways @(posedge i_clk)\n\t\tif (i_pipe_stb)\n\t\t\treq_data <= { i_o",
            "reg , i_op[2:1], i_addr[WBLSB-1:0] };\n\n\t\talways @(*)\n\t\t\to_w",
            "reg = req_data[2+WBLSB +: NAUX];\n\n\t\talways @(*)\n\t\t\tgie = o_w",
            "reg [NAUX-1];\n\n`ifdef\tFORMAL\n\t\t// f_pc_pending\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_pc_pending = 0;\n\t\t\tif ((r_rd_pending || state == DC_READS)||(o_valid))\n\t\t\t\tf_pc_pending = (o_w",
            "reg [3:1] == 3'h7);\n\t\tend\n\t\t// }}}\n\n\t\t// f_pending_addr\n\t\t// {{{\n\t\tinitial\tf_pending_addr = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tf_pending_addr <= 0;\n\t\telse if (i_pipe_stb)\n\t\tbegin\n\t\t\tif ((OPT_LOCAL_BUS)&&(&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]))\n\t\t\t\tf_pending_addr <= { 1'b1, i_addr[2 +: AW] };\n\t\t\telse\n\t\t\t\tf_pending_addr <= { 1'b0, i_addr[WBLSB +: AW] };\n\t\tend\n\t\t// }}}\n\n\t\t// f_return_address\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (stb)\n\t\t\tfr_last_addr <= o_wb_addr;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_return_address[AW]      = o_wb_cyc_lcl;\n\t\t\tf_return_address[AW-1:LS] = o_wb_addr[AW-1:LS];\n\t\t\tif (OPT_LOWPOWER && !stb)\n\t\t\t\tf_return_address[AW-1:LS] = fr_last_addr[AW-1:LS];\n\t\tend\n\t\talways @(*)\n\t\tif (state == DC_READS)\n\t\tbegin\n\t\t\tf_return_address[LS-1:0] = o_wb_addr[LS-1:0];\n\t\t\tif (OPT_LOWPOWER && !stb)\n\t\t\t\tf_return_address[LS-1:0] = fr_last_addr[LS-1:0];\n\t\tend else begin\n\t\t\tf_return_address[LS-1:0]\n\t\t\t\t= (o_wb_addr[LS-1:0] - f_outstanding[LS-1:0]);\n\t\t\tif (OPT_LOWPOWER && !stb)\n\t\t\t\tf_return_address[LS-1:0] = (fr_last_addr[LS-1:0] - f_outstanding[LS-1:0]);\n\t\tend\n\t\t// }}}\n\n\t\t// f_last_",
            "reg // {{{\n\t\talways @(*)\n\t\tif (o_rdbusy)\n\t\t\tassert(o_w",
            "reg == f_last_",
            "reg );\n\t\t// }}}\n\t\t// verilator lint_off UNUSED\n\t\tinitial\tf_fill = 0;",
            "wire unused_no_fifo_formal;\n\t\tassign\tunused_no_fifo_formal = &{ 1'b0, f_return_address,\n\t\t\t\tf_addr_",
            "reg , f_fill };\n`endif",
            "wire unused_no_fifo;\n\t\tassign\tunused_no_fifo = &{ 1'b0, gie };\n\t\t// verilator lint_on  UNUSED\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// BIG STATE machine: CYC, STB, c_v, state, etc\n\t// {{{\n\tinitial\to_wb_addr    = 0;\n\tinitial\tr_wb_cyc_gbl = 0;\n\tinitial\tr_wb_cyc_lcl = 0;\n\tinitial\to_wb_stb_gbl = 0;\n\tinitial\to_wb_stb_lcl = 0;\n\tinitial\tc_v = 0;\n\tinitial\tcyc = 0;\n\tinitial\tstb = 0;\n\tinitial\tc_wr = 0;\n\tinitial\twr_cstb = 0;\n\tinitial\tstate = DC_IDLE;\n\tinitial\tset_vflag = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\t// {{{\n\t\tc_v <= 0;\n\t\tc_wr   <= 1'b0;\n\t\tc_wsel  <= {(BUS_WIDTH/8){1'b1}};\n\t\tr_wb_cyc_gbl <= 1'b0;\n\t\tr_wb_cyc_lcl <= 1'b0;\n\t\to_wb_stb_gbl <= 0;\n\t\to_wb_stb_lcl <= 0;\n\t\to_wb_addr    <= 0;\n\t\twr_cstb <= 1'b0;\n\t\tlast_line_stb <= 1'b0;\n\t\tend_of_line <= 1'b0;\n\t\tstate <= DC_IDLE;\n\t\tcyc <= 1'b0;\n\t\tstb <= 1'b0;\n\t\tstate <= DC_IDLE;\n\t\tset_vflag <= 1'b0;\n\t\t// }}}\n\tend else begin\n\t\t// By default, update the cache from the write 1-clock ago\n\t\t// c_wr <= (wr_cstb)&&(wr_wtag == wr_vtag);\n\t\t// c_waddr <= wr_addr[(CS-1):0];\n\t\tc_wr <= 0;\n\n\t\tset_vflag <= 1'b0;\n\t\tif (!cyc && set_vflag)\n\t\t\tc_v[c_waddr[(CS-1):LS]] <= 1'b1;\n\n\t\twr_cstb <= 1'b0;\n\n\t\t// end_of_line\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\tif (LS <= 0)\n\t\t\tend_of_line <= 1'b1;\n\t\t// Verilator coverage_on\n\t\telse if (!cyc)\n\t\t\tend_of_line <= 1'b0;\n\t\telse if (!end_of_line)\n\t\tbegin\n\t\t\tif (i_wb_ack)\n\t\t\t\tend_of_line\n\t\t\t\t<= (c_waddr[(LS-1):0] == {{(LS-2){1'b1}},2'b01});\n\t\t\telse\n\t\t\t\tend_of_line\n\t\t\t\t<= (c_waddr[(LS-1):0]=={{(LS-1){1'b1}}, 1'b0});\n\t\tend\n\t\t// }}}\n\n\t\t// last_line_stb\n\t\t// {{{\n\t\tif (!cyc || !stb || (OPT_LOWPOWER && state != DC_READC))\n\t\t\tlast_line_stb <= (LS <= 0);\n\t\t// Verilator coverage_off\n\t\telse if (!i_wb_stall && (LS <= 1))\n\t\t\tlast_line_stb <= 1'b1;\n\t\t// Verilator coverage_on\n\t\telse if (!i_wb_stall)\n\t\t\tlast_line_stb <= (o_wb_addr[(LS-1):1]=={(LS-1){1'b1}});\n\t\telse\n\t\t\tlast_line_stb <= (o_wb_addr[(LS-1):0]=={(LS){1'b1}});\n\t\t// }}}\n\n\t\t//\n\t\t//\n\t\tcase(state)\n\t\tDC_IDLE: begin\n\t\t\t// {{{\n\t\t\to_wb_we <= 1'b0;\n\n\t\t\tcyc <= 1'b0;\n\t\t\tstb <= 1'b0;\n\n\t\t\tr_wb_cyc_gbl <= 1'b0;\n\t\t\tr_wb_cyc_lcl <= 1'b0;\n\t\t\to_wb_stb_gbl <= 1'b0;\n\t\t\to_wb_stb_lcl <= 1'b0;\n\n\t\t\tin_cache <= (i_op[0])&&(w_cachable);\n\t\t\tif ((i_pipe_stb)&&(i_op[0]))\n\t\t\tbegin // Write  operation\n\t\t\t\t// {{{\n\t\t\t\tstate <= DC_WRITE;\n\t\t\t\tif (OPT_LOCAL_BUS && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]))\n\t\t\t\t\to_wb_addr <= i_addr[2 +: AW];\n\t\t\t\telse\n\t\t\t\t\to_wb_addr <= i_addr[WBLSB +: AW];\n\n\t\t\t\to_wb_we <= 1'b1;\n\n\t\t\t\tcyc <= 1'b1;\n\t\t\t\tstb <= 1'b1;\n\n\t\t\t\tif (OPT_LOCAL_BUS)\n\t\t\t\tbegin\n\t\t\t\tr_wb_cyc_gbl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]!=8'hff);\n\t\t\t\tr_wb_cyc_lcl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]==8'hff);\n\t\t\t\to_wb_stb_gbl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]!=8'hff);\n\t\t\t\to_wb_stb_lcl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]==8'hff);\n\t\t\t\tend else begin\n\t\t\t\t\tr_wb_cyc_gbl <= 1'b1;\n\t\t\t\t\to_wb_stb_gbl <= 1'b1;\n\t\t\t\tend\n\t\t\t\t// }}}\n\t\t\tend else if (r_cache_miss)\n\t\t\tbegin // Cache miss\n\t\t\t\tstate <= DC_READC;\n\t\t\t\to_wb_addr <= { r_ctag, {(LS){1'b0}} };\n\n\t\t\t\tc_waddr <= { r_ctag[CS-LS-1:0], {(LS){1'b0}} }-1'b1;\n\t\t\t\tcyc <= 1'b1;\n\t\t\t\tstb <= 1'b1;\n\t\t\t\tr_wb_cyc_gbl <= 1'b1;\n\t\t\t\to_wb_stb_gbl <= 1'b1;\n\t\t\tend else if ((i_pipe_stb)&&(!w_cachable))\n\t\t\tbegin // Read non-cachable memory area\n\t\t\t\tstate <= DC_READS;\n\n\t\t\t\tif (OPT_LOCAL_BUS && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]))\n\t\t\t\t\to_wb_addr <= i_addr[2 +: AW];\n\t\t\t\telse\n\t\t\t\t\to_wb_addr <= i_addr[WBLSB +: AW];\n\n\t\t\t\tcyc <= 1'b1;\n\t\t\t\tstb <= 1'b1;\n\t\t\t\tif (OPT_LOCAL_BUS)\n\t\t\t\tbegin\n\t\t\t\tr_wb_cyc_gbl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]!=8'hff);\n\t\t\t\tr_wb_cyc_lcl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]==8'hff);\n\t\t\t\to_wb_stb_gbl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]!=8'hff);\n\t\t\t\to_wb_stb_lcl <= (i_addr[DATA_WIDTH-1:DATA_WIDTH-8]==8'hff);\n\t\t\t\tend else begin\n\t\t\t\tr_wb_cyc_gbl <= 1'b1;\n\t\t\t\to_wb_stb_gbl <= 1'b1;\n\t\t\t\tend\n\t\t\tend // else we stay idle\n\t\t\tend\n\t\t\t// }}}\n\t\tDC_READC: begin\n\t\t\t// {{{\n\t\t\t// We enter here once we have committed to reading\n\t\t\t// data into a cache line.\n\t\t\tif (stb && !i_wb_stall)\n\t\t\tbegin\n\t\t\t\tstb <= (!last_line_stb);\n\t\t\t\to_wb_stb_gbl <= (!last_line_stb);\n\t\t\t\to_wb_addr[(LS-1):0] <= o_wb_addr[(LS-1):0]+1'b1;\n\n\t\t\t\tif (OPT_LOWPOWER && last_line_stb)\n\t\t\t\t\to_wb_addr <= 0;\n\t\t\tend\n\n\t\t\tif (i_wb_ack)\n\t\t\t\tc_v[r_cline] <= 1'b0;\n\n\t\t\tc_wr    <= (i_wb_ack);\n\t\t\tc_wdata <= i_wb_data;\n\t\t\tc_waddr <= c_waddr+(i_wb_ack ? 1:0);\n\t\t\tc_wsel  <= {(BUS_WIDTH/8){1'b1}};\n\n\t\t\tset_vflag <= !i_wb_err;\n\t\t\t// if (i_wb_ack)\n\t\t\t//\tc_vtags[r_addr[(CS-1):LS]]\n\t\t\t//\t\t\t<= r_addr[(AW-1):LS];\n\n\t\t\tif ((i_wb_ack && end_of_line)|| i_wb_err)\n\t\t\tbegin\n\t\t\t\tstate          <= DC_IDLE;\n\t\t\t\tcyc <= 1'b0;\n\t\t\t\tstb <= 1'b0;\n\t\t\t\tr_wb_cyc_gbl <= 1'b0;\n\t\t\t\tr_wb_cyc_lcl <= 1'b0;\n\t\t\t\to_wb_stb_gbl <= 1'b0;\n\t\t\t\to_wb_stb_lcl <= 1'b0;\n\t\t\t\t//\n\t\t\t\tif (OPT_LOWPOWER)\n\t\t\t\t\to_wb_addr <= 0;\n\t\t\tend end\n\t\t\t// }}}\n\t\tDC_READS: begin\n\t\t\t// {{{\n\t\t\t// We enter here once we have committed to reading\n\t\t\t// data that cannot go into a cache line\n\t\t\tif ((!i_wb_stall)&&(!i_pipe_stb))\n\t\t\tbegin\n\t\t\t\tstb <= 1'b0;\n\t\t\t\to_wb_stb_gbl <= 1'b0;\n\t\t\t\to_wb_stb_lcl <= 1'b0;\n\t\t\t\tif (OPT_LOWPOWER)\n\t\t\t\t\to_wb_addr <= 0;\n\t\t\tend\n\n\t\t\tif ((!i_wb_stall)&&(i_pipe_stb))\n\t\t\tbegin\n\t\t\t\tif (OPT_LOCAL_BUS && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]))\n\t\t\t\t\to_wb_addr <= i_addr[2 +: AW];\n\t\t\t\telse\n\t\t\t\t\to_wb_addr <= i_addr[WBLSB +: AW];\n\t\t\tend\n\n\t\t\tc_wr <= 1'b0;\n\n\t\t\tif (((i_wb_ack)&&(last_ack))||(i_wb_err))\n\t\t\tbegin\n\t\t\t\tstate        <= DC_IDLE;\n\t\t\t\tcyc          <= 1'b0;\n\t\t\t\tstb          <= 1'b0;\n\t\t\t\tr_wb_cyc_gbl <= 1'b0;\n\t\t\t\tr_wb_cyc_lcl <= 1'b0;\n\t\t\t\to_wb_stb_gbl <= 1'b0;\n\t\t\t\to_wb_stb_lcl <= 1'b0;\n\t\t\t\tif (OPT_LOWPOWER)\n\t\t\t\t\to_wb_addr <= 0;\n\t\t\tend end\n\t\t\t// }}}\n\t\tDC_WRITE: begin\n\t\t\t// {{{\n\t\t\tc_wr    <= o_wb_stb_gbl && (c_v[o_wb_addr[CS-1:LS]])\n\t\t\t\t// &&(c_vtags[o_wb_addr[CS-1:LS]]==o_wb_addr[AW-1:LS]);\n\t\t\t\t&&(r_itag==o_wb_addr[AW-1:LS]);\n\t\t\tc_wdata <= o_wb_data;\n\t\t\tc_waddr <= r_addr[CS-1:0];\n\t\t\tc_wsel  <= o_wb_sel;\n\n\t\t\tif ((!i_wb_stall)&&(!i_pipe_stb))\n\t\t\tbegin\n\t\t\t\tstb          <= 1'b0;\n\t\t\t\to_wb_stb_gbl <= 1'b0;\n\t\t\t\to_wb_stb_lcl <= 1'b0;\n\t\t\t\tif (OPT_LOWPOWER)\n\t\t\t\t\to_wb_addr <= 0;\n\t\t\tend\n\n\t\t\twr_cstb  <= (stb)&&(!i_wb_stall)&&(in_cache);\n\n\t\t\tif (i_pipe_stb && !i_wb_stall)\n\t\t\tbegin\n\t\t\t\tif (OPT_LOCAL_BUS && (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]))\n\t\t\t\t\to_wb_addr <= i_addr[2 +: AW];\n\t\t\t\telse\n\t\t\t\t\to_wb_addr <= i_addr[WBLSB +: AW];\n\t\t\tend\n\n\t\t\tif (((i_wb_ack)&&(last_ack)\n\t\t\t\t\t\t&&((!OPT_PIPE)||(!i_pipe_stb)))\n\t\t\t\t||(i_wb_err))\n\t\t\tbegin\n\t\t\t\tstate        <= DC_IDLE;\n\t\t\t\tcyc          <= 1'b0;\n\t\t\t\tstb          <= 1'b0;\n\t\t\t\tr_wb_cyc_gbl <= 1'b0;\n\t\t\t\tr_wb_cyc_lcl <= 1'b0;\n\t\t\t\to_wb_stb_gbl <= 1'b0;\n\t\t\t\to_wb_stb_lcl <= 1'b0;\n\t\t\t\tif (OPT_LOWPOWER)\n\t\t\t\t\to_wb_addr <= 0;\n\t\t\tend end\n\t\t\t// }}}\n\t\tendcase\n\n\t\tif (i_clear)\n\t\t\tc_v <= 0;\n\tend\n\n\talways @(posedge i_clk)\n\tif (state == DC_READC && i_wb_ack)\n\t\tc_vtags[r_addr[(CS-1):LS]] <= r_addr[(AW-1):LS];\n\t// }}}\n\n\t// wr_addr\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!cyc)\n\tbegin\n\t\twr_addr <= r_addr[(CS-1):0];\n\t\tif ((!i_pipe_stb || !i_op[0])&&(r_cache_miss))\n\t\t\twr_addr[LS-1:0] <= 0;\n\tend else if (i_wb_ack)\n\t\twr_addr <= wr_addr + 1'b1;\n\telse\n\t\twr_addr <= wr_addr;\n\t// }}}\n\n\n\t// npending\n\t// {{{\n\t// npending is the number of outstanding (non-cached) read or write\n\t// requests.  We only keep track of npending if we are running in a\n\t// piped fashion, i.e. if OPT_PIPE, and so need to keep track of\n\t// possibly multiple outstanding transactions\n\tinitial\tnpending = 0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(!OPT_PIPE)\n\t\t\t||((cyc)&&(i_wb_err))\n\t\t\t||((!cyc)&&(!i_pipe_stb))\n\t\t\t||(state == DC_READC))\n\t\tnpending <= 0;\n\telse if (r_svalid)\n\t\tnpending <= (i_pipe_stb) ? 1:0;\n\telse case({ (i_pipe_stb), (cyc)&&(i_wb_ack) })\n\t2'b01: npending <= npending - 1'b1;\n\t2'b10: npending <= npending + 1'b1;\n\tdefault: begin end\n\tendcase\n\n`ifdef\tFORMAL\n\talways @(*)\n\t\t`ASSERT(npending <= { 1'b1, {(DP){1'b0}} });\n`endif\n\t// }}}\n\n\t// last_ack\n\t// {{{\n\tinitial\tlast_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tlast_ack <= 1'b0;\n\telse if (state == DC_IDLE)\n\tbegin\n\t\tlast_ack <= 1'b0;\n\t\tif ((i_pipe_stb)&&(i_op[0]))\n\t\t\tlast_ack <= 1'b1;\n\t\telse if (r_cache_miss)\n\t\t\tlast_ack <= (LS == 0);\n\t\telse if ((i_pipe_stb)&&(!w_cachable))\n\t\t\tlast_ack <= 1'b1;\n\tend else if (state == DC_READC)\n\tbegin\n\t\tif (i_wb_ack)\n\t\t\tlast_ack <= last_ack || (&wr_addr[LS-1:1]);\n\t\telse\n\t\t\tlast_ack <= last_ack || (&wr_addr[LS-1:0]);\n\tend else case({ (i_pipe_stb), (i_wb_ack) })\n\t2'b01: last_ack <= (npending <= 2);\n\t2'b10: last_ack <= (!cyc)||(npending == 0);\n\tdefault: begin end\n\tendcase\n\t// }}}\n\n\t//\n\t// Writes to the cache\n\t// {{{\n\t// These have been made as simple as possible.  Note that the c_wr\n\t// line has already been determined, as have the write value and address\n\t// on the last clock.  Further, this structure is defined to match the\n\t// block RAM design of as many architectures as possible.\n\t//\n\talways @(posedge i_clk)\n\tif (c_wr)\n\tbegin\n\t\tfor(ik=0; ik<BUS_WIDTH/8; ik=ik+1)\n\t\tif (c_wsel[ik])\n\t\t\tc_mem[c_waddr][ik *8 +: 8] <= c_wdata[ik * 8 +: 8];\n\tend\n\t// }}}\n\n\t//\n\t// Reads from the cache\n\t// {{{\n\t// Some architectures require that all reads be",
            "reg istered.  We\n\t// accomplish that here.  Whether or not the result of this read is\n\t// going to be our",
            "output will need to be determined with combinatorial\n\t//",
            "logic on the",
            "output .\n\t//\n\tgenerate if (OPT_DUAL_READ_PORT)\n\tbegin : GEN_DUAL_READ_PORT\n\n\t\talways @(posedge i_clk)\n\t\t\tcached_iword <= c_mem[i_caddr];\n\n\t\talways @(posedge i_clk)\n\t\t\tcached_rword <= c_mem[r_caddr];\n\n\tend else begin : GEN_SHARED_READ_PORT\n\n\t\talways @(posedge i_clk)\n\t\t\tcached_rword <= c_mem[(o_busy) ? r_caddr : i_caddr];\n\n\t\talways @(*)\n\t\t\tcached_iword = cached_rword;\n\n\tend endgenerate\n\t// }}}\n\n\t// o_data, pre_data\n\t// {{{\n\t// o_data can come from one of three places:\n\t// 1. The cache, assuming the data was in the last cache line\n\t// 2. The cache, second clock, assuming the data was in the cache at all\n\t// 3. The cache, after filling the cache\n\t// 4. The wishbone state machine, upon reading the value desired.\n\n\talways @(*)\n\tif (r_svalid)\n\t\tpre_data = cached_iword;\n\telse if (state == DC_READS)\n\t\tpre_data = i_wb_data;\n\telse\n\t\tpre_data = cached_rword;\n\n\talways @(*)\n\tif (o_wb_cyc_lcl)\n\t\tpre_shifted = { i_wb_data[31:0], {(BUS_WIDTH-32){1'b0}} } << (8*req_data[2-1:0]);\n\telse\n\t\tpre_shifted = pre_data << (8*req_data[WBLSB-1:0]);\n\n\t// o_data\n\tinitial\to_data = 0;\n\talways @(posedge i_clk)\n\tif (OPT_LOWPOWER && (i_reset\n\t\t||(!r_svalid && (!i_wb_ack || state != DC_READS) && !r_dvalid)))\n\t\to_data <= 0;\n\telse casez(req_data[WBLSB +: 2])\n\t2'b10: o_data <= { 16'h0, pre_shifted[BUS_WIDTH-1:BUS_WIDTH-16] };\n\t2'b11: o_data <= { 24'h0, pre_shifted[BUS_WIDTH-1:BUS_WIDTH- 8] };\n\tdefault\to_data <= pre_shifted[BUS_WIDTH-1:BUS_WIDTH-32];\n\tendcase\n\t// }}}\n\n\t// o_valid\n\t// {{{\n\tinitial\to_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_valid <= 1'b0;\n\telse if (state == DC_READS)\n\t\to_valid <= i_wb_ack;\n\telse\n\t\to_valid <= (r_svalid)||(r_dvalid);\n\t// }}}\n\n\t// o_err\n\t// {{{\n\tinitial\to_err = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_err <= 1'b0;\n\telse\n\t\to_err <= (cyc)&&(i_wb_err);\n\t// }}}\n\n\t// o_busy\n\t// {{{\n\tinitial\to_busy = 0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||((cyc)&&(i_wb_err)))\n\t\to_busy <= 1'b0;\n\telse if (i_pipe_stb)\n\t\to_busy <= 1'b1;\n\telse if ((state == DC_READS)&&(i_wb_ack))\n\t\to_busy <= 1'b0;\n\telse if ((r_rd_pending)&&(!r_dvalid))\n\t\to_busy <= 1'b1;\n\telse if ((state == DC_WRITE)\n\t\t\t&&(i_wb_ack)&&(last_ack)&&(!i_pipe_stb))\n\t\to_busy <= 1'b0;\n\telse if (cyc)\n\t\to_busy <= 1'b1;\n\telse // if ((r_dvalid)||(r_svalid))\n\t\to_busy <= 1'b0;\n\t// }}}\n\n\t// o_rdbusy\n\t// {{{\n\tinitial\to_rdbusy = 0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||((cyc)&&(i_wb_err)))\n\t\to_rdbusy <= 1'b0;\n\telse if (i_pipe_stb && !i_op[0])\n\t\to_rdbusy <= 1'b1;\n\telse if ((state == DC_READS)&&(i_wb_ack))\n\t\to_rdbusy <= 1'b0;\n\telse if ((r_rd_pending)&&(!r_dvalid))\n\t\to_rdbusy <= 1'b1;\n\telse if (cyc && !o_wb_we)\n\t\to_rdbusy <= 1'b1;\n\telse // if ((r_dvalid)||(r_svalid))\n\t\to_rdbusy <= 1'b0;\n\t// }}}\n\n\t//\n\t// We can use our FIFO addresses to pre-calculate when an ACK is going\n\t// to be the last_noncachable_ack.\n\n\n\talways @(*)\n\tif (OPT_PIPE)\n\t\to_pipe_stalled = (cyc)&&((!o_wb_we)||(i_wb_stall)||(!stb))\n\t\t\t\t||(r_rd_pending)||(npending[DP]);\n\telse\n\t\to_pipe_stalled = o_busy;\n\n\tinitial\tlock_gbl = 0;\n\tinitial\tlock_lcl = 0;\n\talways @(posedge i_clk)\n\tif (i_reset || !OPT_LOCK)\n\tbegin\n\t\tlock_gbl <= 1'b0;\n\t\tlock_lcl<= 1'b0;\n\tend else begin\n\t\t// lock_gbl <= (r_wb_cyc_gbl)||(lock_gbl);\n\t\t// lock_lcl <= (r_wb_cyc_lcl)||(lock_lcl);\n\t\tif (i_pipe_stb)\n\t\tbegin\n\t\t\tlock_gbl <= (!OPT_LOCAL_BUS\n\t\t\t\t|| i_addr[DATA_WIDTH-1:DATA_WIDTH-8] != 8'hff);\n\t\t\tlock_lcl <=(i_addr[DATA_WIDTH-1:DATA_WIDTH-8] == 8'hff);\n\t\tend\n\n\t\tif (r_wb_cyc_gbl && i_wb_err)\n\t\t\tlock_gbl <= 1'b0;\n\t\tif (r_wb_cyc_lcl && i_wb_err)\n\t\t\tlock_lcl <= 1'b0;\n\n\t\tif (!i_lock)\n\t\t\t{ lock_gbl, lock_lcl } <= 2'b00;\n\t\tif (!OPT_LOCAL_BUS)\n\t\t\tlock_lcl <= 1'b0;\n\tend\n\n\tassign\to_wb_cyc_gbl = (r_wb_cyc_gbl)||(lock_gbl);\n\tassign\to_wb_cyc_lcl = (r_wb_cyc_lcl)||(lock_lcl);\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, pre_shifted };\n\tgenerate if (AW+WBLSB < DATA_WIDTH)\n\tbegin : UNUSED_BITS",
            "wire unused_aw;\n\t\tassign\tunused = &{ 1'b0, i_addr[DATA_WIDTH-1:AW+WBLSB] };\n\tend endgenerate\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties for verification\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Reset properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(*)\n\tif(!f_past_valid)\n\t\t`ASSUME(i_reset);\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\tbegin\n\t\t// Insist on initial statements matching reset values\n\t\t// `ASSERT(r_rd == 1'b0);\n\t\t`ASSERT(r_cachable == 1'b0);\n\t\t`ASSERT(r_svalid == 1'b0);\n\t\t`ASSERT(r_dvalid == 1'b0);\n\t\t`ASSERT(r_cache_miss == 1'b0);\n\t\t// `ASSERT(r_addr == 0);\n\t\t//\n\t\t`ASSERT(c_wr == 0);\n\t\t`ASSERT(c_v  == 0);\n\t\t//\n\t\t// assert(aux_head == 0);\n\t\t// assert(aux_tail == 0);\n\t\t//\n\t\t`ASSERT(lock_gbl == 0);\n\t\t`ASSERT(lock_lcl == 0);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions about our",
            "input s (the CPU interface)\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg f_rdbusy, f_done;",
            "reg [F_LGDEPTH-1:0]\tf_cpu_outstanding;",
            "wire faxi_write;\n\n\tfmem #(\n\t\t// {{{\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t.OPT_MAXDEPTH(1<<(F_LGDEPTH-1)),\n\t\t.OPT_AXI_LOCK(1'b0)\n\t\t// }}}\n\t) f_cpu(\n\t\t// {{{\n\t\t.i_clk(i_clk),\n\t\t\t.i_sys_reset(i_reset),\n\t\t\t.i_cpu_reset(i_reset),\n\t\t// The CPU interface\n\t\t.i_stb(i_pipe_stb),\n\t\t\t.i_pipe_stalled(o_pipe_stalled),\n\t\t.i_clear_cache(i_clear),\n\t\t\t.i_lock(i_lock),\n\t\t.i_op(i_op),\n\t\t\t.i_addr(i_addr),\n\t\t\t.i_data(i_data),\n\t\t\t.i_o",
            "reg (i_o",
            "reg ),\n\t\t\t.i_a",
            "reg (f_a",
            "reg ),\n\t\t\t.i_busy(o_busy),\n\t\t\t.i_rdbusy(o_rdbusy),\n\t\t.i_valid(o_valid),\n\t\t.i_done(f_done),\n\t\t.i_err(o_err),\n\t\t.i_w",
            "reg (o_w",
            "reg ),\n\t\t.i_result(o_data),\n\t\t.f_outstanding(f_cpu_outstanding),\n\t\t.f_pc(f_pc),\n\t\t.f_gie(f_gie),\n\t\t.f_read_cycle(f_read_cycle),\n\t\t.f_axi_write_cycle(faxi_write),\n\t\t.f_last_",
            "reg (f_last_",
            "reg ),\n\t\t.f_addr_",
            "reg (f_addr_",
            "reg )\n\t\t// }}}\n\t);\n\n\talways @(*)\n\t\tassert(faxi_write == 0);\n\n\talways @(*)\n\tif (OPT_PIPE || (!o_err && !r_svalid && !r_dvalid))\n\t\tassert(f_pc_pending == f_pc);\n\n\t// f_rdbusy\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tf_rdbusy = 0;\n\t\tif (state == DC_READC)\n\t\t\tf_rdbusy = 1'b1;\n\t\tif (state == DC_READS)\n\t\t\tf_rdbusy = 1'b1;\n\t\tif (r_svalid || r_dvalid)\n\t\t\tf_rdbusy = 1'b1;\n\t\tif ((r_rd_pending)||(r_dvalid)||(r_svalid))\n\t\t\tf_rdbusy = 1'b1;\n\n\t\tassert(f_rdbusy == o_rdbusy);\n\tend\n\t// }}}\n\n\t// f_done\n\t// {{{\n\tinitial\tf_done = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_done <= 1'b0;\n\telse begin\n\t\tf_done <= 1'b0;\n\n\t\tif ((cyc)&&(i_wb_err))\n\t\t\tf_done <= 1'b1;\n\t\tif ((state == DC_READS || state  == DC_WRITE)&&(i_wb_ack))\n\t\t\tf_done <= 1'b1;\n\t\tif ((r_dvalid)||(r_svalid))\n\t\t\tf_done <= 1'b1;\n\tend\n\t// }}}\n\n\t// f_gie\n\t//  {{{\n\talways @(*)\n\tif (o_busy)\n\t\tassert(gie == f_gie);\n\t// }}}\n\n\t// f_read_cycle\n\t//  {{{\n\talways @(*)\n\tif (state == DC_READS || state == DC_READC || r_svalid || r_dvalid)\n\tbegin\n\t\tassert(f_read_cycle);\n\tend else if (state == DC_WRITE)\n\t\tassert(!f_read_cycle);\n\t// }}}\n\n\t// The CPU is not allowed to write to the CC",
            "reg ister while a\n\t// memory operation is pending, lest any resulting bus error\n\t// get returned to the wrong mode--i.e. user bus error halting\n\t// the supervisor.  What this means, though, is that the CPU\n\t// will *never* attempt to clear the data cache while the cache\n\t// is busy.\n\t// always @(*)\n\t// if (o_busy || i_pipe_stb) // f_outstanding)\n\t\t// `ASSUME(!i_clear);\n\n\talways @(*)\n\tif (cyc && !o_wb_we)\n\tbegin\n\t\tif (state == DC_READC)\n\t\tbegin\n\t\t\tassert(f_cpu_outstanding == 1);\n\t\tend else\n\t\t\tassert(f_cpu_outstanding == f_outstanding\n\t\t\t\t+ (r_svalid ? 1:0) + (r_dvalid ? 1:0)\n\t\t\t\t+ (o_valid  ? 1:0) + (stb ? 1:0));\n\tend else if (cyc) // Writing\n\tbegin\n\t\tassume(f_cpu_outstanding <= (1<<OPT_FIFO_DEPTH));\n\t\tif (!o_err)\n\t\t\tassert(f_cpu_outstanding == f_outstanding + (stb ? 1:0)\n\t\t\t\t+ (f_done ? 1:0));\n\tend\n\n\talways @(*)\n\tif (!cyc && (!OPT_PIPE || !o_err))\n\t\tassert(f_cpu_outstanding ==\n\t\t\t((r_svalid || r_dvalid || r_rd_pending) ? 1:0)\n\t\t\t\t+ ((f_done || o_valid || o_err) ? 1:0));\n\n/*\n\talways @(*)\n\tif (o_pipe_stalled)\n\t\t`ASSUME(!i_pipe_stb);\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(!i_pipe_stb);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t&&($past(i_pipe_stb))&&($past(o_pipe_stalled)))\n\tbegin\n\t\t`ASSUME($stable(i_pipe_stb));\n\t\t`ASSUME($stable(i_op[0]));\n\t\t`ASSUME($stable(i_addr));\n\t\tif (i_op[0])\n\t\t\t`ASSUME($stable(i_data));\n\tend\n\n\talways @(posedge i_clk)\n\tif (o_err)\n\t\t`ASSUME(!i_pipe_stb);\n*/\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Wishbone properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "wire f_cyc, f_stb;\n\n\tassign\tf_cyc = (o_wb_cyc_gbl)|(o_wb_cyc_lcl);\n\tassign\tf_stb = (o_wb_stb_gbl)|(o_wb_stb_lcl);\n\n\talways @(*)\n\tbegin\n\t\t// Only one interface can be active at once\n\t\t`ASSERT((!o_wb_cyc_gbl)||(!o_wb_cyc_lcl));\n\t\t// Strobe may only be active on the active interface\n\t\t`ASSERT((r_wb_cyc_gbl)||(!o_wb_stb_gbl));\n\t\t`ASSERT((r_wb_cyc_lcl)||(!o_wb_stb_lcl));\n\t\tif (o_wb_stb_lcl)\n\t\tbegin\n\t\t\tif (o_wb_we)\n\t\t\tbegin\n\t\t\t\tassert(state == DC_WRITE);\n\t\t\tend else\n\t\t\t\tassert(state == DC_READS);\n\t\tend\n\n\t\tif (cyc)\n\t\t\tassert(o_wb_we == (state == DC_WRITE));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(cyc)&&($past(cyc)))\n\tbegin\n\t\t`ASSERT($stable(r_wb_cyc_gbl));\n\t\t`ASSERT($stable(r_wb_cyc_lcl));\n\tend\n\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.AW(AW), .DW(BUS_WIDTH),\n\t\t.F_MAX_STALL(2),\n\t\t.F_MAX_ACK_DELAY(3),\n\t\t// If you need the proof to run faster, use these\n\t\t// lines instead of the two that follow\n\t\t// .F_MAX_STALL(1),\n\t\t// .F_MAX_ACK_DELAY(1),\n\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t// Verilator lint_off WIDTH\n\t\t.F_MAX_REQUESTS((OPT_PIPE) ? 0 : (1<<LS)),\n\t\t// Verilator lint_on  WIDTH\n`ifdef\tDCACHE\n\t\t.F_OPT_SOURCE(1'b1),\n`endif\n\t\t.F_OPT_DISCONTINUOUS(0)\n\t\t// }}}\n\t) fwb(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\tcyc, f_stb, o_wb_we, o_wb_addr, o_wb_data, o_wb_sel,\n\t\t\ti_wb_ack, i_wb_stall, i_wb_data, i_wb_err,\n\t\tf_nreqs, f_nacks, f_outstanding\n\t\t// }}}\n\t);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract checking -- Arbitrary address (contract) properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n`ifdef\tDCACHE\n\t// Arbitrary access is specific to local dcache implementation\n\t//\n\t//\n\t(* anyconst *)",
            "reg [AW:0]\t\tf_const_addr;\n\t(* anyconst *)",
            "reg f_const_buserr;",
            "wire [AW-LS-1:0]\tf_const_tag, f_ctag_here, f_wb_tag;",
            "wire [CS-LS-1:0]\tf_const_tag_addr;",
            "reg [BUS_WIDTH-1:0]\tf_const_data;",
            "wire [BUS_WIDTH-1:0]\tf_cmem_here;",
            "reg f_pending_rd;",
            "wire f_cval_in_cache;",
            "wire [AW-1:0]\twb_start;",
            "reg [AW-1:0]\tf_cache_waddr;",
            "wire f_this_cache_waddr;",
            "wire f_this_return;\n\n\n\tassign\tf_const_tag    = f_const_addr[AW-1:LS];\n\tassign\tf_const_tag_addr = f_const_addr[CS-1:LS];\n\tassign\tf_cmem_here    = c_mem[f_const_addr[CS-1:0]];\n\tassign\tf_ctag_here    = c_vtags[f_const_addr[CS-1:LS]];\n\tassign\tf_wb_tag       = (OPT_LOWPOWER ? r_addr[AW-1:LS]\n\t\t\t\t\t\t: o_wb_addr[AW-1:LS]);\n\n\tassign\tf_cval_in_cache= (c_v[f_const_addr[CS-1:LS]])\n\t\t\t\t\t&&(f_ctag_here == f_const_tag);\n\tassign\tf_this_cache_waddr = (!f_const_addr[AW])\n\t\t\t\t&&(f_cache_waddr == f_const_addr[AW-1:0]);\n\tassign\tf_this_return = (f_return_address == f_const_addr);\n\n\tassign\twb_start = (f_stb) ? (o_wb_addr - f_nreqs)\n\t\t\t\t\t: { r_addr[AW-1:LS], {(LS){1'b0}} };\n\n\t// Assume f_const_addr[AW] consistent with the local bus declaration\n\t// {{{\n\tgenerate if ((AW > BUS_WIDTH - 8)&&(OPT_LOCAL_BUS))\n\tbegin : UPPER_CONST_ADDR_BITS\n\n\t\talways @(*)\n\t\tif (f_const_addr[AW])\n\t\tbegin\n\t\t\tassume(&f_const_addr[AW-1:DATA_WIDTH-8-2]);\n\t\tend else\n\t\t\tassume(!(&f_const_addr[AW-1:DATA_WIDTH-8-WBLSB]));\n\n\tend endgenerate\n\t// }}}\n\n\t// f_const_data -- Adjust our special data word upon request\n\t// {{{",
            "reg [BUS_WIDTH-1:0]\tf_shifted_data;",
            "reg [BUS_WIDTH/8-1:0]\tf_shifted_sel;\n\n\talways @(*)\n\tbegin\n\t\tcasez(i_op[2:1])\n\t\t2'b0?: begin\n\t\t\tf_shifted_data = { i_data, {(BUS_WIDTH-DATA_WIDTH){1'b0}} } >> (8*i_addr[WBLSB-1:0]);\n\t\t\tf_shifted_sel  = { 4'b1111, {(BUS_WIDTH/8-4){1'b0}} } >> i_addr[WBLSB-1:0];\n\t\t\tend\n\t\t2'b10: begin\n\t\t\tf_shifted_data = { i_data[15:0], {(BUS_WIDTH-16){1'b0}} } >> (8*i_addr[WBLSB-1:0]);\n\t\t\tf_shifted_sel  = { 2'b11, {(BUS_WIDTH/8-2){1'b0}} } >> i_addr[WBLSB-1:0];\n\t\t\tend\n\t\t2'b11: begin\n\t\t\tf_shifted_data = { i_data[ 7:0], {(BUS_WIDTH-8){1'b0}} } >> (8*i_addr[WBLSB-1:0]);\n\t\t\tf_shifted_sel  = { 1'b1, {(BUS_WIDTH/8-1){1'b0}} } >> i_addr[WBLSB-1:0];\n\t\t\tend\n\t\tendcase\n\tend\n\n\talways @(posedge i_clk)\n\t// Upon a request for our special address ...\n\tif (i_pipe_stb && (!cyc || !i_wb_err)\n\t\t// That matches the local or global bus address....\n\t\t&& f_const_addr[AW] == ((OPT_LOCAL_BUS)\n\t\t\t\t\t&&(&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]))\n\t\t// and it is a write request\n\t\t&& i_op[0])\n\tbegin\n\t\t// Then update the chosen data word at that address\n\t\tif (f_const_addr[AW]\n\t\t\t&& (&i_addr[DATA_WIDTH-1:DATA_WIDTH-8])\n\t\t\t&& (i_addr[2 +: AW] == f_const_addr[AW-1:0]))\n\t\tbegin // Local bus word\n\t\t\t// {{{\n\t\t\tcasez({ i_op[2:1], i_addr[1:0] })\n\t\t\t4'b0???: f_const_data[31: 0] <= i_data;\n\t\t\t4'b100?: f_const_data[31:16] <= i_data[15:0];\n\t\t\t4'b101?: f_const_data[15: 0] <= i_data[15:0];\n\t\t\t4'b1100: f_const_data[31:24] <= i_data[ 7:0];\n\t\t\t4'b1101: f_const_data[23:16] <= i_data[ 7:0];\n\t\t\t4'b1110: f_const_data[15: 8] <= i_data[ 7:0];\n\t\t\t4'b1111: f_const_data[ 7: 0] <= i_data[ 7:0];\n\t\t\tendcase\n\t\t\t// }}}\n\t\tend else if (!f_const_addr[AW]\n\t\t\t&& (!OPT_LOCAL_BUS\n\t\t\t\t|| !(&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]))\n\t\t\t&& (i_addr[WBLSB +: AW] == f_const_addr[AW-1:0]))\n\t\tbegin // Global bus word\n\t\t\tfor(ik=0; ik<BUS_WIDTH/8; ik=ik+1)\n\t\t\tif (f_shifted_sel[ik])\n\t\t\t\tf_const_data[8*ik +: 8] <= f_shifted_data[8*ik +: 8];\n\t\tend\n\tend\n\t// }}}\n\n\n\t// Insure the cache and bus both have an accurate/valid copy of the data\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!i_reset)&&(!f_const_buserr))\n\tbegin\n\t\t// Is this a write to our special address?\n\t\tif (cyc && o_wb_we && f_stb\n\t\t\t\t&&(o_wb_addr[AW-1:0] == f_const_addr[AW-1:0])\n\t\t\t\t&&( o_wb_stb_lcl == f_const_addr[AW]))\n\t\tbegin\n\t\t\t// Only the updated data value should be written to the\n\t\t\t// bus\n\t\t\t// {{{\n\t\t\tif (f_const_addr[AW])\n\t\t\tbegin\n\t\t\t\tfor(ik=0; ik<DATA_WIDTH/8; ik=ik+1)\n\t\t\t\tif (f_stb && o_wb_sel[ik])\n\t\t\t\t\t`ASSERT(o_wb_data[ik*8 +: 8]==f_const_data[ik*8 +: 8]);\n\t\t\tend else begin\n\t\t\t\tfor(ik=0; ik<BUS_WIDTH/8; ik=ik+1)\n\t\t\t\tif (f_stb && o_wb_sel[ik])\n\t\t\t\t\t`ASSERT(o_wb_data[ik*8 +: 8]==f_const_data[ik*8 +: 8]);\n\t\t\tend\n\t\t\t// }}}\n\n\t\t\t// Check the data written into the cache for validity\n\t\t\t// {{{\n\t\t\tif (!f_const_addr[AW] && c_v[f_const_tag_addr]\n\t\t\t\t&& (f_ctag_here == o_wb_addr[AW-1:LS]))\n\t\t\tbegin\n\t\t\t\tfor(ik=0; ik<BUS_WIDTH/8; ik=ik+1)\n\t\t\t\tif (!o_wb_sel[ik] && !c_wsel[ik])\n\t\t\t\t\t`ASSERT(f_cmem_here[8*ik +: 8]==f_const_data[8*ik +: 8]);\n\t\t\t// }}}\n\n\t\t\tend\n\t\t// Otherwise, if this is a valid address, *and* it is in the\n\t\t// cache ...\n\t\tend else if (!f_const_addr[AW] && c_v[f_const_tag_addr]\n\t\t\t&&(f_ctag_here ==f_const_addr[AW-1:LS]))\n\t\tbegin\n\t\t\t// If ...\n\t\t\t//   1. Our magic address is cachable\n\t\t\t//   2. Our magic address is associated with a valid\n\t\t\t//\t\tcache line\n\t\t\t//   3. The cache tag matches our magic address\n\t\t\t// {{{\n\n\t\t\t// if ($past(cyc && i_wb_err))\n\t\t\t// begin\n\t\t\t\t// Ignore what happens on an error, the result\n\t\t\t\t// becomes undefined anyway\n\t\t\t// end else\n\t\t\tif (c_wr &&(c_waddr[CS-1:0] == f_const_addr[CS-1:0]))\n\t\t\tbegin\n\t\t\t\t//\n\t\t\t\t// If we are writing to this valid cache line\n\t\t\t\t// {{{\n\t\t\t\tfor(ik=0; ik<BUS_WIDTH/8; ik=ik+1)\n\t\t\t\tif (c_wsel[ik] && $past(o_wb_cyc_gbl))\n\t\t\t\tbegin\n\t\t\t\t\t`ASSERT(c_wdata[8*ik +: 8]\n\t\t\t\t\t\t\t== f_const_data[8*ik +: 8]);\n\t\t\t\tend else\n\t\t\t\t\t`ASSERT(f_cmem_here[8*ik +: 8]\n\t\t\t\t\t\t\t== f_const_data[8*ik +: 8]);\n\t\t\t\t// }}}\n\t\t\tend else\n\t\t\t\t// Else, we assert the correct value is already\n\t\t\t\t// in the cache\n\t\t\t\t`ASSERT(f_cmem_here == f_const_data);\n\t\t\t// }}}\n\t\tend\n\tend\n\t// }}}\n\n\t// When reading a cache line, assert the correct value has been read\n\t// if we've passed that aprt of our read\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(state == DC_READC))\n\tbegin\n\t\t`ASSERT(f_return_address[AW-1:LS] == r_ctag);\n\t\t`ASSERT(f_wb_tag == r_ctag);\n\t\tif ((r_ctag == f_const_tag)\n\t\t\t&&(!c_v[f_const_tag_addr])\n\t\t\t&&(f_const_addr[AW] == r_wb_cyc_lcl)\n\t\t\t&&(f_nacks > f_const_addr[LS-1:0]))\n\t\tbegin\n\t\t\t// We are reading the cache line containing our\n\t\t\t// constant address f_const_addr.  Make sure the data\n\t\t\t// is correct.\n\t\t\tif ((c_wr)&&(c_waddr[CS-1:0] == f_const_addr[CS-1:0]))\n\t\t\tbegin\n\t\t\t\t`ASSERT(c_wdata == f_const_data);\n\t\t\tend else\n\t\t\t\t`ASSERT(f_cmem_here == f_const_data);\n\t\tend\n\n\t\tif (!i_reset && f_nacks > 0)\n\t\t\t`ASSERT(!c_v[r_cline]);\n\tend\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((state == DC_READC)&&(f_nacks > 0))\n\tbegin\n\t\t`ASSERT(c_vtags[wb_start[(CS-1):LS]] <= wb_start[(AW-1):LS]);\n\t\t`ASSERT(c_vtags[wb_start[(CS-1):LS]] <= r_addr[AW-1:LS]);\n\tend\n\n\talways @(*)\n\tbegin\n\t\t// f_cache_waddr[AW-1:LS] = c_vtags[c_waddr[CS-1:CS-LS]];\n\t\tf_cache_waddr[AW-1:LS] = wb_start[AW-1:LS];\n\t\tf_cache_waddr[CS-1: 0] = c_waddr[CS-1:0];\n\tend\n\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(state == DC_READC))\n\tbegin\n\t\tif ((c_wr)&&(c_waddr[LS-1:0] != 0)&&(f_this_cache_waddr))\n\t\t\t`ASSERT(c_wdata == f_const_data);\n\tend\n\n//\talways @(posedge i_clk)\n//\tif ((OPT_PIPE)&&(o_busy)&&(i_pipe_stb))\n//\t\t`ASSUME(i_op[0] == o_wb_we);\n\n\tinitial\tf_pending_rd = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_pending_rd <= 0;\n\telse if (i_pipe_stb)\n\t\tf_pending_rd <= (!i_op[0]);\n\telse if ((o_valid)&&((!OPT_PIPE)\n\t\t||((state != DC_READS)&&(!r_svalid)&&(!$past(i_pipe_stb)))))\n\t\tf_pending_rd <= 1'b0;\n\n\talways @(*)\n\tif ((state == DC_READC)&&(!f_stb))\n\t\t`ASSERT(f_nreqs == (1<<LS));\n\n\talways @(*)\n\tif ((state == DC_READC)&&(f_stb))\n\t\t`ASSERT(f_nreqs == { 1'b0, o_wb_addr[LS-1:0] });\n\n\talways @(posedge i_clk)\n\tif (state == DC_READC)\n\tbegin\n\t\tif (f_stb)\n\t\t\tassert(r_addr[AW-1:LS] == o_wb_addr[AW-1:LS]);\n\t\tif (($past(i_wb_ack))&&(!$past(f_stb)))\n\t\tbegin\n\t\t\t`ASSERT(f_nacks-1 == { 1'b0, c_waddr[LS-1:0] });\n\t\tend else if (f_nacks > 0)\n\t\tbegin\n\t\t\t`ASSERT(f_nacks-1 == { 1'b0, c_waddr[LS-1:0] });\n\t\t\t`ASSERT(c_waddr[CS-1:LS] == r_addr[CS-1:LS]);\n\t\tend else begin\n\t\t\t`ASSERT(c_waddr[CS-1:LS] == r_addr[CS-1:LS]-1'b1);\n\t\t\t`ASSERT(&c_waddr[LS-1:0]);\n\t\tend\n\tend\n\n\talways @(*)\n\tif (r_rd_pending)\n\t\t`ASSERT(r_addr == f_pending_addr[AW-1:0]);\n\n\talways @(*)\n\tif (f_pending_addr[AW])\n\tbegin\n\t\t`ASSERT(state != DC_READC);\n\t\t`ASSERT((!o_wb_we)||(!o_wb_cyc_gbl));\n\tend",
            "reg [BUS_WIDTH-1:0]\tf_shift_const_data;\n\n\talways @(posedge i_clk)\n\tbegin\n\t\tif (f_const_addr[AW])\n\t\t\tf_shift_const_data = { f_const_data[31:0], {(BUS_WIDTH-DATA_WIDTH){1'b0}} } << (8*req_data[2-1:0]);\n\t\telse\n\t\t\tf_shift_const_data = f_const_data << (8*req_data[WBLSB-1:0]);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(o_valid)&&($past(f_pending_addr) == f_const_addr))\n\tbegin\n\t\tif (f_const_buserr)\n\t\tbegin\n\t\t\t`ASSERT(o_err);\n\t\tend else if (f_pending_rd)\n\t\tbegin\n\t\t\tcasez($past(req_data[WBLSB +: 2]))\n\t\t\t4'b0?: `ASSERT(o_data ==f_shift_const_data[BUS_WIDTH-1:BUS_WIDTH-32]);\n\t\t\t4'b10: `ASSERT(o_data =={16'h00,f_shift_const_data[BUS_WIDTH-1:BUS_WIDTH-16]});\n\t\t\t4'b11: `ASSERT(o_data =={24'h00,f_shift_const_data[BUS_WIDTH-1:BUS_WIDTH- 8]});\n\t\t\tendcase\n\t\tend\n\tend\n\n\t// #1. Assume this return matches our chosen data\n\t// {{{\n\talways @(*)\n\tif ((f_cyc)&&(\n\t\t((state == DC_READC)\n\t\t\t&&(f_return_address[AW-1:LS] == f_const_addr[AW-1:LS]))\n\t\t||(f_this_return)))\n\tbegin\n\t\tif (f_const_buserr)\n\t\tbegin\n\t\t\tassume(!i_wb_ack);\n\t\tend else begin\n\t\t\tassume(!i_wb_err);\n\t\t\tassume(i_wb_data == f_const_data);\n\t\tend\n\tend\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(last_tag == f_const_tag)&&(f_const_buserr)\n\t\t\t&&(!f_const_addr[AW]))\n\t\t`ASSERT(!last_tag_valid);\n\n\t// Chosen address is invalid: bus error properties\n\t// {{{\n\talways @(*)\n\tif (f_const_buserr)\n\tbegin\n\t\t`ASSERT((!c_v[f_const_tag_addr])||(f_const_addr[AW])\n\t\t\t||(f_ctag_here != f_const_tag));\n\n\t\tif ((state == DC_READC)&&(wb_start[AW-1:LS] == f_const_tag))\n\t\tbegin\n\t\t\t`ASSERT(f_nacks <= f_const_tag[LS-1:0]);\n\t\t\tif (f_nacks == f_const_tag[LS-1:0])\n\t\t\t\tassume(!i_wb_ack);\n\t\tend\n\tend\n\t// }}}\n\n\t/*\n\t// ?? why was I assuming this again?\n\talways @(*)\n\tif (f_cval_in_cache)\n\tbegin\n\t\tassume((!i_wb_err)\n\t\t\t||(!i_pipe_stb)\n\t\t\t||(f_const_addr[AW-1:0] != i_addr[WBLSB +: AW]));\n\tend\n\t*/\n\n`endif\t// DCACHE\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Checking the lock\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(*)\n\t\t`ASSERT((!lock_gbl)||(!lock_lcl));\n\talways @(*)\n\tif (!OPT_LOCK)\n\t\t`ASSERT((!lock_gbl)&&(!lock_lcl));\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// State based properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg [F_LGDEPTH-1:0]\tf_rdpending;",
            "wire f_wb_cachable;\n\n\t// f_rdpending\n\t// {{{\n\tinitial\tf_rdpending = 0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(o_err))\n\t\tf_rdpending <= 0;\n\telse case({ (i_pipe_stb)&&(!i_op[0]), o_valid })\n\t2'b01: f_rdpending <= f_rdpending - 1'b1;\n\t2'b10: f_rdpending <= f_rdpending + 1'b1;\n\tdefault: begin end\n\tendcase\n\t// }}}\n\n\tiscachable #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(AW+WBLSB)\n\t\t// }}}\n\t) f_chkwb_addr({ r_addr, {(WBLSB){1'b0}} }, f_wb_cachable);\n\n\n\talways @(*)\n\tif (state == DC_IDLE)\n\tbegin\n\t\t`ASSERT(!r_wb_cyc_gbl);\n\t\t`ASSERT(!r_wb_cyc_lcl);\n\n\t\t`ASSERT(!cyc);\n\n\t\tif ((r_rd_pending)||(r_dvalid)||(r_svalid))\n\t\t\t`ASSERT(o_busy);\n\n\t\tif (!OPT_PIPE)\n\t\tbegin\n\t\t\tif (r_rd_pending)\n\t\t\tbegin\n\t\t\t\t`ASSERT(o_busy);\n\t\t\tend else if (r_svalid)\n\t\t\tbegin\n\t\t\t\t`ASSERT(o_busy);\n\t\t\tend else if (o_valid)\n\t\t\tbegin\n\t\t\t\t`ASSERT(!o_busy);\n\t\t\tend else if (o_err)\n\t\t\tbegin\n\t\t\t\t`ASSERT(!o_busy);\n\t\t\tend\n\t\tend\n\tend else begin\n\t\t`ASSERT(o_busy);\n\t\t`ASSERT(cyc);\n\tend\n\n\n\n\talways @(posedge i_clk)\n\tif (state == DC_IDLE)\n\tbegin\n\t\tif (r_svalid)\n\t\tbegin\n\t\t\t`ASSERT(!r_dvalid);\n\t\t\t`ASSERT(!r_rd_pending);\n\t\t\tif (!OPT_PIPE)\n\t\t\tbegin\n\t\t\t\t`ASSERT(!o_valid);\n\t\t\tend else if (o_valid)\n\t\t\t\t`ASSERT(f_rdpending == 2);\n\t\tend\n\n\t\tif (r_dvalid)\n\t\tbegin\n\t\t\t`ASSERT(!r_rd_pending);\n\t\t\t`ASSERT(npending == 0);\n\t\t\t`ASSERT(f_rdpending == 1);\n\t\tend\n\n\t\tif (r_rd_pending)\n\t\tbegin\n\t\t\tif ((OPT_PIPE)&&(o_valid))\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_rdpending <= 2);\n\t\t\tend else\n\t\t\t\t`ASSERT(f_rdpending == 1);\n\n\t\tend else if ((OPT_PIPE)&&(o_valid)&&($past(r_dvalid|r_svalid)))\n\t\tbegin\n\t\t\t`ASSERT(f_rdpending <= 2);\n\t\tend else\n\t\t\t`ASSERT(f_rdpending <= 1);\n\tend\n\n\talways @(posedge i_clk)\n\tif (state == DC_READC)\n\tbegin\n\t\t`ASSERT( o_wb_cyc_gbl);\n\t\t`ASSERT(!o_wb_cyc_lcl);\n\t\t`ASSERT(!o_wb_we);\n\t\t`ASSERT(f_wb_cachable);\n\t\t`ASSERT(!lock_gbl);\n\t\t`ASSERT(!lock_lcl);\n\n\t\t`ASSERT(r_rd_pending);\n\t\t`ASSERT(r_cachable);\n\t\tif (($past(cyc))&&(!$past(o_wb_stb_gbl)))\n\t\tbegin\n\t\t\t`ASSERT(!o_wb_stb_gbl);\n\t\tend\n\n\t\tif ((OPT_PIPE)&&(o_valid))\n\t\tbegin\n\t\t\t`ASSERT(f_rdpending == 2);\n\t\tend else\n\t\t\t`ASSERT(f_rdpending == 1);\n\tend\n\n\talways @(*)\n\tif (state == DC_READS)\n\tbegin\n\t\t`ASSERT(!o_wb_we);\n\n\t\tif (OPT_PIPE)\n\t\tbegin\n\t\t\tif (o_valid)\n\t\t\tbegin\n\t\t\t\t`ASSERT(({ 1'b0, f_rdpending } == npending + 1)\n\t\t\t\t\t||({ 1'b0, f_rdpending } == npending));\n\t\t\tend else\n\t\t\t\t`ASSERT({ 1'b0, f_rdpending } == npending);\n\t\tend\n\tend else if (state == DC_WRITE)\n\t\t`ASSERT(o_wb_we);\n\n\talways @(posedge i_clk)\n\tif ((state == DC_READS)||(state == DC_WRITE))\n\tbegin\n\t\t`ASSERT(o_wb_we == (state == DC_WRITE));\n\t\t`ASSERT(!r_rd_pending);\n\t\tif (o_wb_we)\n\t\t\t`ASSERT(f_rdpending == 0);\n\n\t\tif (OPT_PIPE)\n\t\tbegin\n\t\t\tcasez({ $past(i_pipe_stb), f_stb })\n\t\t\t2'b00: `ASSERT(npending == { 1'b0, f_outstanding});\n\t\t\t2'b1?: `ASSERT(npending == { 1'b0, f_outstanding} + 1);\n\t\t\t2'b01: `ASSERT(npending == { 1'b0, f_outstanding} + 1);\n\t\t\tendcase\n\n\t\t\tif (state == DC_WRITE)\n\t\t\t\t`ASSERT(!o_valid);\n\t\tend else\n\t\t\t`ASSERT(f_outstanding <= 1);\n\tend\n\n\talways @(*)\n\tif (OPT_PIPE)\n\tbegin\n\t\t`ASSERT(f_rdpending <= 2);\n\tend else\n\t\t`ASSERT(f_rdpending <= 1);\n\n\talways @(posedge i_clk)\n\tif ((!OPT_PIPE)&&(o_valid))\n\tbegin\n\t\t`ASSERT(f_rdpending == 1);\n\tend else if (o_valid)\n\t\t`ASSERT(f_rdpending >= 1);\n\n\n\talways @(*)\n\tif ((!o_busy)&&(!o_err)&&(!o_valid))\n\t\t`ASSERT(f_rdpending == 0);\n\n\talways @(*)\n\t\t`ASSERT(cyc == ((r_wb_cyc_gbl)||(r_wb_cyc_lcl)));\n\n\talways @(*)\n\tif ((!i_reset)&&(f_nreqs == f_nacks)&&(!f_stb))\n\t\t`ASSERT(!cyc);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_err)))\n\tbegin\n\t\t`ASSUME(!i_lock);\n\tend else if ((f_past_valid)&&(OPT_LOCK)&&($past(i_lock))\n\t\t\t&&((!$past(o_valid)) || ($past(i_pipe_stb))))\n\t\t`ASSUME($stable(i_lock));\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Ad-hoc properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif ((OPT_PIPE)&&(state == DC_WRITE)&&(!i_wb_stall)&&(stb)\n\t\t\t&&(!npending[DP]))\n\t\t`ASSERT(!o_pipe_stalled);\n\n\talways @(posedge i_clk)\n\tif (state == DC_WRITE)\n\tbegin\n\t\t`ASSERT(o_wb_we);\n\tend else if ((state == DC_READS)||(state == DC_READC))\n\t\t`ASSERT(!o_wb_we);\n\n\talways @(*)\n\tif (cyc)\n\t\t`ASSERT(f_cyc);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(cyc))&&(!c_wr)&&(last_tag_valid)\n\t\t\t&&(!r_rd_pending))\n\t\t`ASSERT((c_v[last_tag[(CS-LS-1):0]])\n\t\t\t&&(c_vtags[last_tag[(CS-LS-1):0]] == last_tag));\n\n\talways @(*)\n\tif (!OPT_LOCAL_BUS)\n\tbegin\n\t\t`ASSERT(r_wb_cyc_lcl == 1'b0);\n\t\t`ASSERT(o_wb_stb_lcl == 1'b0);\n\t\t`ASSERT(lock_lcl == 1'b0);\n\tend\n\n\talways @(posedge i_clk)\n\tif (state == DC_READC && !stb)\n\tbegin\n\t\tif (OPT_LOWPOWER)\n\t\tbegin\n\t\t\t`ASSERT(o_wb_addr == 0);\n\t\tend else begin\n\t\t\t`ASSERT(o_wb_addr[LS-1:0] == 0);\n\t\t\t`ASSERT(o_wb_addr[AW-1:CS] == r_addr[AW-1:CS]);\n\t\tend\n\tend else if ((state == DC_READC)&&(stb))\n\tbegin\n\t\t`ASSERT(o_wb_addr[AW-1:CS] == r_addr[AW-1:CS]);\n\t\t`ASSERT(o_wb_addr[LS-1:0] == f_nreqs[LS-1:0]);\n\tend",
            "wire [CS-1:0]\tf_expected_caddr;\n\tassign\tf_expected_caddr = { r_ctag[CS-LS-1:0], {(LS){1'b0}} }-1\n\t\t\t\t\t+ { {(CS-F_LGDEPTH){1'b0}}, f_nacks };\n\talways @(posedge i_clk)\n\tif (state == DC_READC)\n\tbegin\n\t\tif (LS == 0)\n\t\tbegin\n\t\t\t`ASSERT(end_of_line);\n\t\tend else if (f_nacks < (1<<LS)-1)\n\t\tbegin\n\t\t\t`ASSERT(!end_of_line);\n\t\tend else if (f_nacks == (1<<LS)-1)\n\t\tbegin\n\t\t\t`ASSERT(end_of_line);\n\t\tend\n\t\t`ASSERT(f_nacks <= (1<<LS));\n\t\t`ASSERT(f_nreqs <= (1<<LS));\n\t\tif (f_nreqs < (1<<LS))\n\t\tbegin\n\t\t\t`ASSERT(o_wb_stb_gbl);\n\t\t\t`ASSERT(o_wb_addr[(LS-1):0] == f_nreqs[LS-1:0]);\n\t\tend else\n\t\t\t`ASSERT(!f_stb);\n\t\t`ASSERT((f_nreqs == 0)||(f_nacks <= f_nreqs));\n\t\t`ASSERT(c_waddr == f_expected_caddr);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(r_rd)&&(!$past(i_reset)))\n\tbegin\n\t\t`ASSERT((o_busy)||(r_svalid));\n\tend\n\n\talways @(posedge i_clk)\n\tif (!$past(o_busy))\n\t\t`ASSERT(!r_dvalid);\n\n\talways @(posedge i_clk)\n\tif ((state == DC_READC)&&(c_wr))\n\t\t`ASSERT(&c_wsel);\n\n\talways @(*)\n\tif (c_wr && !(&c_wsel))\n\t\t`ASSERT($countones(c_wsel) == 1\n\t\t\t|| $countones(c_wsel) == 2\n\t\t\t|| $countones(c_wsel) == 4);\n\n\talways @(*)\n\tif (!OPT_PIPE)\n\tbegin\n\t\t`ASSERT(o_pipe_stalled == o_busy);\n\tend else if (o_pipe_stalled)\n\t\t`ASSERT(o_busy);\n\n\t//\n\t// Only ever abort on reset\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(cyc))&&(!$past(i_wb_err)))\n\tbegin\n\t\tif (($past(i_pipe_stb))&&(!$past(o_pipe_stalled)))\n\t\tbegin\n\t\t\t`ASSERT(cyc);\n\t\tend else if ($past(f_outstanding > 1))\n\t\tbegin\n\t\t\t`ASSERT(cyc);\n\t\tend else if (($past(f_outstanding == 1))\n\t\t\t\t&&((!$past(i_wb_ack))\n\t\t\t\t\t||(($past(f_stb))\n\t\t\t\t\t\t&&(!$past(i_wb_stall)))))\n\t\tbegin\n\t\t\t`ASSERT(cyc);\n\t\tend else if (($past(f_outstanding == 0))\n\t\t\t\t&&($past(f_stb)&&(!$past(i_wb_ack))))\n\t\t\t`ASSERT(cyc);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((OPT_PIPE)&&(f_past_valid)&&(!$past(i_reset))&&(state != DC_READC))\n\tbegin\n\t\tif ($past(cyc && i_wb_err))\n\t\tbegin\n\t\t\t`ASSERT(npending == 0);\n\t\tend else if (($past(i_pipe_stb))||($past(i_wb_stall && stb)))\n\t\tbegin\n\t\t\t`ASSERT((npending == f_outstanding+1)\n\t\t\t\t||(npending == f_outstanding+2));\n\t\tend else\n\t\t\t`ASSERT(npending == { 1'b0, f_outstanding });\n\tend\n\n\talways @(posedge i_clk)\n\tif ((OPT_PIPE)&&(state != DC_READC)&&(state != DC_IDLE))\n\t\t`ASSERT(last_ack == (npending <= 1));\n\n\talways @(*)\n\t`ASSERT(stb == f_stb);\n\n\talways @(*)\n\tif (r_rd_pending)\n\t\t`ASSERT(!r_svalid);\n\n\talways @(*)\n\tif (o_err)\n\t\t`ASSUME(!i_pipe_stb);\n\n\talways @(*)\n\tif (last_tag_valid)\n\t\t`ASSERT(|c_v);\n\n\talways @(posedge i_clk)\n\tif (cyc &&(state == DC_READC)&&($past(f_nacks > 0)))\n\t\t`ASSERT(!c_v[r_cline]);\n\n\talways @(*)\n\tif (last_tag_valid)\n\tbegin\n\t\t`ASSERT((!cyc)||(o_wb_we)||(state == DC_READS)\n\t\t\t\t\t||(o_wb_addr[AW-1:LS] != last_tag));\n\tend",
            "wire f_cachable_last_tag, f_cachable_r_addr;\n\n\tiscachable #(.ADDRESS_WIDTH(AW+WBLSB))\n\t\tfccheck_last_tag({last_tag, {(LS+WBLSB){1'b0}} },\n\t\t\t\tf_cachable_last_tag);\n\n\tiscachable #(\n\t\t.ADDRESS_WIDTH(AW+WBLSB)\n\t) fccheck_r_cachable({ r_addr, {(WBLSB){1'b0}} }, f_cachable_r_addr);\n\n\talways @(*)\n\tif ((r_cachable)&&(r_rd_pending))\n\tbegin\n\t\t`ASSERT(state != DC_WRITE);\n\t\t// `ASSERT(state != DC_READS);\n\t\t`ASSERT(f_cachable_r_addr);\n\t\tif (cyc && (stb || !OPT_LOWPOWER))\n\t\t\t`ASSERT(o_wb_addr[AW-1:LS] == r_addr[AW-1:LS]);\n\tend\n\n\talways @(*)\n\tif (last_tag_valid)\n\tbegin\n\t\t`ASSERT(f_cachable_last_tag);\n\t\t`ASSERT(c_v[last_tag[CS-LS-1:0]]);\n\t\t`ASSERT(c_vtags[last_tag[CS-LS-1:0]]==last_tag);\n\t\t`ASSERT((state != DC_READC)||(last_tag != o_wb_addr[AW-1:LS]));\n\tend\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Low power checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (OPT_LOWPOWER)\n\tbegin : CHECK_LOWPOWER\n\t\talways @(posedge i_clk)\n\t\tif (!o_wb_stb_gbl && !o_wb_stb_lcl)\n\t\tbegin\n\t\t\tassert($stable(o_wb_addr) || (o_wb_addr == 0));\n\t\t\tassert($stable(o_wb_data) || (o_wb_data == 0));\n\t\t\tassert($stable(o_wb_sel)  || (o_wb_sel  == 0)\n\t\t\t\t|| (&o_wb_sel));\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tif (!o_valid && !o_err)\n\t\tbegin\n\t\t\tassert($stable(o_data) || (o_data == 0));\n\t\tend\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover statements\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\t\tcover(o_valid);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid)\n\t\tcover($past(r_svalid));\n\n\tgenerate if (OPT_PIPE)\n\tbegin : PIPE_COVER",
            "wire recent_reset;",
            "reg [2:0]\trecent_reset_s",
            "reg ;\n\t\tinitial\trecent_reset_s",
            "reg = -1;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\trecent_reset_s",
            "reg <= -1;\n\t\telse\n\t\t\trecent_reset_s",
            "reg <= { recent_reset_s",
            "reg [1:0], 1'b0 };\n\n\t\tassign recent_reset = (i_reset)||(|recent_reset_s",
            "reg );\n\n\t\t//\n\t\t//",
            "wire f_cvr_cread = (!recent_reset)&&(i_pipe_stb)&&(!i_op[0])\n\t\t\t\t\t&&(w_cachable);",
            "wire f_cvr_cwrite = (!recent_reset)&&(i_pipe_stb)&&(i_op[0])\n\t\t\t\t&&(!cache_miss_inow);",
            "wire f_cvr_writes = (!recent_reset)&&(i_pipe_stb)&&(i_op[0])\n\t\t\t\t\t&&(!w_cachable);",
            "wire f_cvr_reads  = (!recent_reset)&&(i_pipe_stb)&&(!i_op[0])\n\t\t\t\t\t&&(!w_cachable);\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&($past(o_valid)))\n\t\t\tcover(o_valid);\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_pipe_stb)))\n\t\t\tcover(i_pipe_stb);\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&($past(o_valid))&&($past(o_valid,2)))\n\t\t\tcover(o_valid);\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(f_cvr_cread))&&(f_cvr_cread));\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(f_cvr_cwrite))&&(f_cvr_cwrite));\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(f_cvr_writes))&&(f_cvr_writes));\n\n\t\t/*\n\t\t* This cover statement will never pass.  Why not?  Because\n\t\t* cache reads must be separated from non-cache reads.  Hence,\n\t\t* we can only allow a single non-cache read at a time, otherwise\n\t\t* we'd bypass the cache read",
            "logic .\n\t\t*\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(f_cvr_reads))&&(f_cvr_reads));\n\t\t*/\n\n\t\t//\n\t\t// This is unrealistic, as it depends upon the Wishbone\n\t\t// acknoledging the request on the same cycle\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(f_cvr_reads,2))&&(f_cvr_reads));\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(r_dvalid))&&(r_svalid));\n\n\t\t//\n\t\t// A minimum of one clock must separate two dvalid's.\n\t\t// This option is rather difficult to cover, since it means\n\t\t// we must first load two separate cache lines before\n\t\t// this can even be tried.\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(r_dvalid,2))&&(r_dvalid));\n\n\t\t//\n\t\t// This is the optimal configuration we want:\n\t\t//\ti_pipe_stb\n\t\t// \t##1 i_pipe_stb && r_svalid\n\t\t//\t##1 r_svalid && o_valid\n\t\t//\t##1 o_valid\n\t\t// It proves that we can handle a 2 clock delay, but that\n\t\t// we can also pipelin these cache accesses, so this\n\t\t// 2-clock delay becomes a 1-clock delay between pipelined\n\t\t// memory reads.\n\t\t//\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(r_svalid))&&(r_svalid));\n\n\t\t//\n\t\t// While we'd never do this (it breaks the ZipCPU's pipeline\n\t\t// rules), it's nice to know we could.\n\t\t//\ti_pipe_stb && (!i_op[0]) // a read\n\t\t//\t##1 i_pipe_stb && (i_op[0]) && r_svalid // a write\n\t\t//\t##1 o_valid\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(r_svalid))&&(f_cvr_writes));\n\n\t\t/* Unreachable\n\t\t*\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(f_cvr_writes))&&(o_valid));\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(f_cvr_writes,2))&&(o_valid));\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(f_cvr_writes,3))&&(o_valid));\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(r_dvalid,3))&&(r_dvalid));\n\n\t\t*/\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(($past(f_cvr_writes,4))&&(o_valid));\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Carelesss assumption section\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Can't jump from local to global mid lock\n\talways @(*)\n\tif((OPT_LOCK)&&(OPT_LOCAL_BUS))\n\tbegin\n\t\tif ((i_lock)&&(o_wb_cyc_gbl)&&(i_pipe_stb))\n\t\tbegin\n\t\t\tassume(!(&i_addr[(DATA_WIDTH-1):(DATA_WIDTH-8)]));\n\t\tend else if ((i_lock)&&(o_wb_cyc_lcl)&&(i_pipe_stb))\n\t\t\tassume(&i_addr[(DATA_WIDTH-1):(DATA_WIDTH-8)]);\n\tend\n\n\talways @(*)\n\tif ((OPT_PIPE)&&(o_busy || i_lock)&&(!o_pipe_stalled))\n\tbegin\n\t\tif (i_pipe_stb)\n\t\t\tassume((!OPT_LOCAL_BUS)\n\t\t\t\t||(f_pending_addr[AW]==(&i_addr[DATA_WIDTH-1:DATA_WIDTH-8])));\n\tend\n\n\t// If the bus is active, but we allow a second item in anyway 'cause\n\t// we are piped, then assume that we don't cross from local to global\n\t// buses\n\talways @(posedge i_clk)\n\tif ((OPT_PIPE)&&(o_busy)&&(i_pipe_stb))\n\tbegin\n\t\t`ASSUME(i_op[0] == o_wb_we);\n\t\tif (o_wb_cyc_lcl)\n\t\tbegin\n\t\t\tassume(&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]);\n\t\tend else\n\t\t\tassume(!(&i_addr[DATA_WIDTH-1:DATA_WIDTH-8]));\n\tend\n\n\t// Assume aligned accesses\n\talways @(*)\n\tif (i_pipe_stb)\n\tcasez(i_op[2:1])\n\t2'b0?: assume(i_addr[1:0] == 2'b00);\n\t2'b10: assume(i_addr[  0] == 1'b0);\n\t2'b11: begin end\n\tendcase\n\n\t// always @(posedge i_clk)\n\t// if ((f_past_valid)&&(!$past(cyc))&&(!cyc))\n\t//\tassume((!i_wb_err)&&(!i_wb_ack));\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "memops.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/core/memops.v",
        "chunks": [
            "module memops #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=28,",
            "parameter DATA_WIDTH=32,\t// CPU's",
            "reg ister width",
            "parameter BUS_WIDTH=32,",
            "parameter [0:0]\tOPT_LOCK=1'b1,\n\t\t\t\tWITH_LOCAL_BUS=1'b1,\n\t\t\t\tOPT_ALIGNMENT_ERR=1'b1,\n\t\t\t\tOPT_LOWPOWER=1'b0,\n\t\t\t\tOPT_LITTLE_ENDIAN = 1'b0,",
            "localparam AW=ADDRESS_WIDTH\n`ifdef\tFORMAL\n\t\t,",
            "parameter F_LGDEPTH = 2\n`endif\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// CPU interface\n\t\t// {{{",
            "input ",
            "wire i_stb, i_lock,",
            "input ",
            "wire [2:0]\t\ti_op,",
            "input ",
            "wire [31:0]\t\ti_addr,",
            "input ",
            "wire [DATA_WIDTH-1:0]\ti_data,",
            "input ",
            "wire [4:0]\t\ti_o",
            "reg ,\n\t\t// CPU",
            "output s",
            "output ",
            "wire o_busy,",
            "output ",
            "reg o_rdbusy,",
            "output ",
            "reg o_valid,",
            "output ",
            "reg o_err,",
            "output ",
            "reg [4:0]\t\to_w",
            "reg ,",
            "output ",
            "reg [DATA_WIDTH-1:0]\to_result,\n\t\t// }}}\n\t\t// Wishbone\n\t\t// {{{",
            "output ",
            "wire o_wb_cyc_gbl,",
            "output ",
            "wire o_wb_cyc_lcl,",
            "output ",
            "reg o_wb_stb_gbl,",
            "output ",
            "reg o_wb_stb_lcl,",
            "output ",
            "reg o_wb_we,",
            "output ",
            "reg [AW-1:0]\to_wb_addr,",
            "output ",
            "reg [BUS_WIDTH-1:0]\to_wb_data,",
            "output ",
            "reg [BUS_WIDTH/8-1:0]\to_wb_sel,\n\t\t// Wishbone",
            "input s",
            "input ",
            "wire i_wb_stall, i_wb_ack, i_wb_err,",
            "input ",
            "wire [BUS_WIDTH-1:0]\ti_wb_data\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Declarations\n\t// {{{",
            "localparam WBLSB = $clog2(BUS_WIDTH/8);\n`ifdef\tFORMAL",
            "wire [(F_LGDEPTH-1):0]\tf_nreqs, f_nacks, f_outstanding;\n`endif",
            "wire misaligned;",
            "reg r_wb_cyc_gbl, r_wb_cyc_lcl;",
            "reg [2+WBLSB-1:0]\tr_op;",
            "wire lock_gbl, lock_lcl;",
            "wire lcl_bus, gbl_stb, lcl_stb;",
            "reg [BUS_WIDTH/8-1:0]\toword_sel;",
            "wire [BUS_WIDTH/8-1:0]\tpre_sel;",
            "wire [BUS_WIDTH-1:0]\t\tpre_result;",
            "wire [1:0]\t\toshift2;",
            "wire [WBLSB-1:0]\toshift;\n\n\t// }}}\n\n\t// misaligned\n\t// {{{\n\tgenerate if (OPT_ALIGNMENT_ERR)\n\tbegin : GENERATE_ALIGNMENT_ERR",
            "reg r_misaligned;\n\n\t\talways @(*)\n\t\tcasez({ i_op[2:1], i_addr[1:0] })\n\t\t4'b01?1: r_misaligned = i_stb; // Words must be halfword aligned\n\t\t4'b0110: r_misaligned = i_stb; // Words must be word aligned\n\t\t4'b10?1: r_misaligned = i_stb; // Halfwords must be aligned\n\t\t// 4'b11??: r_misaligned <= 1'b0; Byte access are never misaligned\n\t\tdefault: r_misaligned = 1'b0;\n\t\tendcase\n\n\t\tassign\tmisaligned = r_misaligned;\n\tend else begin : NO_MISALIGNMENT_ERR\n\t\tassign\tmisaligned = 1'b0;\n\tend endgenerate\n\t// }}}\n\n\t// lcl_stb, gbl_stb\n\t// {{{\n\tassign\tlcl_bus = (WITH_LOCAL_BUS)&&(i_addr[31:24]==8'hff);\n\tassign\tlcl_stb = (i_stb)&&( lcl_bus)&&(!misaligned);\n\tassign\tgbl_stb = (i_stb)&&(!lcl_bus)&&(!misaligned);\n\t// }}}\n\n\t// r_wb_cyc_gbl, r_wb_cyc_lcl\n\t// {{{\n\tinitial\tr_wb_cyc_gbl = 1'b0;\n\tinitial\tr_wb_cyc_lcl = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\tr_wb_cyc_gbl <= 1'b0;\n\t\tr_wb_cyc_lcl <= 1'b0;\n\tend else if ((r_wb_cyc_gbl)||(r_wb_cyc_lcl))\n\tbegin\n\t\tif ((i_wb_ack)||(i_wb_err))\n\t\tbegin\n\t\t\tr_wb_cyc_gbl <= 1'b0;\n\t\t\tr_wb_cyc_lcl <= 1'b0;\n\t\tend\n\tend else begin // New memory operation\n\t\t// Grab the wishbone\n\t\tr_wb_cyc_lcl <= (lcl_stb);\n\t\tr_wb_cyc_gbl <= (gbl_stb);\n\tend\n\t// }}}\n\n\t// o_wb_stb_gbl\n\t// {{{\n\tinitial\to_wb_stb_gbl = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_wb_stb_gbl <= 1'b0;\n\telse if ((i_wb_err)&&(r_wb_cyc_gbl))\n\t\to_wb_stb_gbl <= 1'b0;\n\telse if (gbl_stb)\n\t\to_wb_stb_gbl <= 1'b1;\n\telse if (o_wb_cyc_gbl)\n\t\to_wb_stb_gbl <= (o_wb_stb_gbl)&&(i_wb_stall);\n\t//  }}}\n\n\t// o_wb_stb_lcl\n\t// {{{\n\tinitial\to_wb_stb_lcl = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_wb_stb_lcl <= 1'b0;\n\telse if ((i_wb_err)&&(r_wb_cyc_lcl))\n\t\to_wb_stb_lcl <= 1'b0;\n\telse if (lcl_stb)\n\t\to_wb_stb_lcl <= 1'b1;\n\telse if (o_wb_cyc_lcl)\n\t\to_wb_stb_lcl <= (o_wb_stb_lcl)&&(i_wb_stall);\n\t// }}}\n\n\t// o_wb_we, o_wb_data, o_wb_sel\n\t// {{{\n\talways @(*)\n\tbegin\n\t\toword_sel = 0;\n\n\t\tcasez({ OPT_LITTLE_ENDIAN, i_op[2:1], i_addr[1:0] })\n\t\t5'b00???: oword_sel[3:0] = 4'b1111;\n\t\t5'b0100?: oword_sel[3:0] = 4'b1100;\n\t\t5'b0101?: oword_sel[3:0] = 4'b0011;\n\t\t5'b01100: oword_sel[3:0] = 4'b1000;\n\t\t5'b01101: oword_sel[3:0] = 4'b0100;\n\t\t5'b01110: oword_sel[3:0] = 4'b0010;\n\t\t5'b01111: oword_sel[3:0] = 4'b0001;\n\t\t//\n\t\t// verilator coverage_off\n\t\t5'b10???: oword_sel[3:0] = 4'b1111;\n\t\t5'b1100?: oword_sel[3:0] = 4'b0011;\n\t\t5'b1101?: oword_sel[3:0] = 4'b1100;\n\t\t5'b11100: oword_sel[3:0] = 4'b0001;\n\t\t5'b11101: oword_sel[3:0] = 4'b0010;\n\t\t5'b11110: oword_sel[3:0] = 4'b0100;\n\t\t5'b11111: oword_sel[3:0] = 4'b1000;\n\t\t// verilator coverage_on\n\t\t//\n\t\tdefault: oword_sel[3:0] = 4'b1111;\n\t\tendcase\n\tend\n\n\t// pre_sel\n\t// {{{\n\tgenerate if (BUS_WIDTH == 32)\n\tbegin : COPY_PRESEL\n\t\tassign\tpre_sel = oword_sel;\n\tend else if (OPT_LITTLE_ENDIAN)\n\tbegin : GEN_LILPRESEL",
            "wire [WBLSB-3:0]\tshift;\n\n\t\tassign\tshift = i_addr[WBLSB-1:2];\n\t\tassign\tpre_sel = oword_sel << (4 * i_addr[WBLSB-1:2]);\n\tend else begin : GEN_PRESEL",
            "wire [WBLSB-3:0]\tshift;\n\n\t\tassign\tshift = {(WBLSB-2){1'b1}} ^ i_addr[WBLSB-1:2];\n\t\tassign\tpre_sel = oword_sel << (4 * shift);\n\tend endgenerate\n\t// }}}\n\n\tassign\toshift  = i_addr[WBLSB-1:0];\n\tassign\toshift2 = i_addr[1:0];\n\n\tinitial\to_wb_we   = 1'b0;\n\tinitial\to_wb_data = 0;\n\tinitial\to_wb_sel  = 0;\n\talways @(posedge i_clk)\n\tif (i_stb)\n\tbegin\n\t\to_wb_we   <= i_op[0];\n\t\tif (OPT_LOWPOWER)\n\t\tbegin\n\t\t\tif (lcl_bus)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\to_wb_data <= 0;\n\t\t\t\tcasez({ OPT_LITTLE_ENDIAN, i_op[2:1] })\n\t\t\t\t3'b010: o_wb_data[31:0] <= { i_data[15:0], {(16){1'b0}} } >> (8*oshift2);\n\t\t\t\t3'b011: o_wb_data[31:0] <= { i_data[ 7:0], {(24){1'b0}} } >> (8*oshift2);\n\t\t\t\t3'b00?: o_wb_data[31:0] <= i_data[31:0];\n\t\t\t\t//\n\t\t\t\t// verilator coverage_off\n\t\t\t\t3'b110: o_wb_data <= { {(BUS_WIDTH-16){1'b0}}, i_data[15:0] } << (8*oshift2);\n\t\t\t\t3'b111: o_wb_data <= { {(BUS_WIDTH-8){1'b0}},  i_data[ 7:0] } << (8*oshift2);\n\t\t\t\t3'b10?: o_wb_data <= { {(BUS_WIDTH-32){1'b0}}, i_data[31:0] } << (8*oshift2);\n\t\t\t\t// verilator coverage_on\n\t\t\t\t//\n\t\t\t\tendcase\n\t\t\t\t// }}}\n\t\t\tend else begin\n\t\t\t\t// {{{\n\t\t\t\tcasez({ OPT_LITTLE_ENDIAN, i_op[2:1] })\n\t\t\t\t3'b010: o_wb_data <= { i_data[15:0], {(BUS_WIDTH-16){1'b0}} } >> (8*oshift);\n\t\t\t\t3'b011: o_wb_data <= { i_data[ 7:0], {(BUS_WIDTH- 8){1'b0}} } >> (8*oshift);\n\t\t\t\t3'b00?: o_wb_data <= { i_data[31:0], {(BUS_WIDTH-32){1'b0}} } >> (8*oshift);\n\t\t\t\t//\n\t\t\t\t3'b110: o_wb_data <= { {(BUS_WIDTH-16){1'b0}}, i_data[15:0] } << (8*oshift);\n\t\t\t\t3'b111: o_wb_data <= { {(BUS_WIDTH-8){1'b0}},  i_data[ 7:0] } << (8*oshift);\n\t\t\t\t3'b10?: o_wb_data <= { {(BUS_WIDTH-32){1'b0}}, i_data[31:0] } << (8*oshift);\n\t\t\t\t//\n\t\t\t\tendcase\n\t\t\t\t// }}}\n\t\t\tend\n\t\tend else\n\t\t\tcasez({ i_op[2:1] })\n\t\t\t2'b10: o_wb_data <= { (BUS_WIDTH/16){ i_data[15:0] } };\n\t\t\t2'b11: o_wb_data <= { (BUS_WIDTH/ 8){ i_data[7:0] } };\n\t\t\tdefault: o_wb_data <= {(BUS_WIDTH/32){i_data}};\n\t\t\tendcase\n\n\t\tif (lcl_bus)\n\t\tbegin\n\t\t\to_wb_addr <= i_addr[2 +: (AW+2>32 ? (32-2) : AW)];\n\t\t\to_wb_sel <= oword_sel;\n\t\tend else begin\n\t\t\to_wb_addr <= i_addr[WBLSB +: (AW+WBLSB>32 ? (32-WBLSB) : AW)];\n\t\t\to_wb_sel <= pre_sel;\n\t\tend\n\n\t\tr_op <= { i_op[2:1] , i_addr[WBLSB-1:0] };\n\tend else if ((OPT_LOWPOWER)&&(!o_wb_cyc_gbl)&&(!o_wb_cyc_lcl))\n\tbegin\n\t\to_wb_we   <= 1'b0;\n\t\to_wb_addr <= 0;\n\t\to_wb_data <= {(BUS_WIDTH){1'b0}};\n\t\to_wb_sel  <= {(BUS_WIDTH/8){1'b0}};\n\tend\n\t// }}}\n\n\t// o_valid\n\t// {{{\n\tinitial\to_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_valid <= 1'b0;\n\telse\n\t\to_valid <= (((o_wb_cyc_gbl)||(o_wb_cyc_lcl))\n\t\t\t\t&&(i_wb_ack)&&(!o_wb_we));\n\t// }}}\n\n\t// o_err\n\t// {{{\n\tinitial\to_err = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_err <= 1'b0;\n\telse if ((r_wb_cyc_gbl)||(r_wb_cyc_lcl))\n\t\to_err <= i_wb_err;\n\telse if ((i_stb)&&(!o_busy))\n\t\to_err <= misaligned;\n\telse\n\t\to_err <= 1'b0;\n\t// }}}\n\n\tassign\to_busy = (r_wb_cyc_gbl)||(r_wb_cyc_lcl);\n\n\t// o_rdbusy\n\t// {{{\n\tinitial\to_rdbusy = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset|| ((o_wb_cyc_gbl || o_wb_cyc_lcl)&&(i_wb_err || i_wb_ack)))\n\t\to_rdbusy <= 1'b0;\n\telse if (i_stb && !i_op[0] && !misaligned)\n\t\to_rdbusy <= 1'b1;\n\telse if (o_valid)\n\t\to_rdbusy <= 1'b0;\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif (i_stb)\n\t\to_w",
            "reg <= i_o",
            "reg ;\n\n\t// o_result\n\t// {{{\n\tgenerate if (OPT_LITTLE_ENDIAN)\n\tbegin : LILEND_RESULT\n\n\t\tassign\tpre_result = i_wb_data >> (8*r_op[$clog2(BUS_WIDTH/8)-1:0]);\n\n\tend else begin : BIGEND_RESULT\n\n\t\tassign\tpre_result = i_wb_data << (8*r_op[$clog2(BUS_WIDTH/8)-1:0]);\n\n\tend endgenerate\n\n\talways @(posedge i_clk)\n\tif ((OPT_LOWPOWER)&&(!i_wb_ack))\n\t\to_result <= 32'h0;\n\telse if (o_wb_cyc_lcl && (BUS_WIDTH != 32))\n\tbegin\n\t\t// The Local bus is naturally (and only) a 32-bit bus\n\t\tcasez({ OPT_LITTLE_ENDIAN, r_op[WBLSB +: 2], r_op[1:0] })\n\t\t5'b?01??: o_result <= i_wb_data[31:0];\n\t\t//\n\t\t// Big endian\n\t\t5'b0100?: o_result <= { 16'h00, i_wb_data[31:16] };\n\t\t5'b0101?: o_result <= { 16'h00, i_wb_data[15: 0] };\n\t\t5'b01100: o_result <= { 24'h00, i_wb_data[31:24] };\n\t\t5'b01101: o_result <= { 24'h00, i_wb_data[23:16] };\n\t\t5'b01110: o_result <= { 24'h00, i_wb_data[15: 8] };\n\t\t5'b01111: o_result <= { 24'h00, i_wb_data[ 7: 0] };\n\t\t//\n\t\t// Little endian : Same bus result, just grab a different bits\n\t\t//   from the bus return to send back to the CPU.\n\t\t// verilator coverage_off\n\t\t5'b1100?: o_result <= { 16'h00, i_wb_data[15: 0] };\n\t\t5'b1101?: o_result <= { 16'h00, i_wb_data[31:16] };\n\t\t5'b11100: o_result <= { 24'h00, i_wb_data[ 7: 0] };\n\t\t5'b11101: o_result <= { 24'h00, i_wb_data[15: 8] };\n\t\t5'b11110: o_result <= { 24'h00, i_wb_data[23:16] };\n\t\t5'b11111: o_result <= { 24'h00, i_wb_data[31:24] };\n\t\t// verilator coverage_on\n\t\tdefault: o_result <= i_wb_data[31:0];\n\t\tendcase\n\tend else begin\n\t\tcasez({ OPT_LITTLE_ENDIAN, r_op[$clog2(BUS_WIDTH/8) +: 2] })\n\t\t// Word\n\t\t//\n\t\t// Big endian\n\t\t3'b00?: o_result <= pre_result[BUS_WIDTH-1:BUS_WIDTH-32];\n\t\t3'b010: o_result <= { 16'h00, pre_result[BUS_WIDTH-1:BUS_WIDTH-16] };\n\t\t3'b011: o_result <= { 24'h00, pre_result[BUS_WIDTH-1:BUS_WIDTH-8] };\n\t\t//\n\t\t// Little endian : Same bus result, just grab a different bits\n\t\t//   from the bus return to send back to the CPU.\n\t\t// verilator coverage_off\n\t\t3'b10?: o_result <= pre_result[31: 0];\n\t\t3'b110: o_result <= { 16'h00, pre_result[15: 0] };\n\t\t3'b111: o_result <= { 24'h00, pre_result[ 7: 0] };\n\t\t// verilator coverage_on\n\t\t//\n\t\t// Just to have an (unused) default\n\t\t// default: o_result <= pre_result[31:0]; (Messes w/ coverage)\n\t\tendcase\n\tend\n\t// }}}\n\n\t// lock_gbl and lock_lcl\n\t// {{{\n\tgenerate\n\tif (OPT_LOCK)\n\tbegin : GEN_LOCK\n\t\t// {{{",
            "reg r_lock_gbl, r_lock_lcl;\n\n\t\tinitial\tr_lock_gbl = 1'b0;\n\t\tinitial\tr_lock_lcl = 1'b0;\n\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\tbegin\n\t\t\tr_lock_gbl <= 1'b0;\n\t\t\tr_lock_lcl <= 1'b0;\n\t\tend else if (((i_wb_err)&&((r_wb_cyc_gbl)||(r_wb_cyc_lcl)))\n\t\t\t\t||(misaligned))\n\t\tbegin\n\t\t\t// Kill the lock if\n\t\t\t//\tthere's a bus error, or\n\t\t\t//\tUser requests a misaligned memory op\n\t\t\tr_lock_gbl <= 1'b0;\n\t\t\tr_lock_lcl <= 1'b0;\n\t\tend else begin\n\t\t\t// Kill the lock if\n\t\t\t//\ti_lock goes down\n\t\t\t//\tUser starts on the global bus, then switches\n\t\t\t//\t  to local or vice versa\n\t\t\tr_lock_gbl <= (i_lock)&&((r_wb_cyc_gbl)||(lock_gbl))\n\t\t\t\t\t&&(!lcl_stb);\n\t\t\tr_lock_lcl <= (i_lock)&&((r_wb_cyc_lcl)||(lock_lcl))\n\t\t\t\t\t&&(!gbl_stb);\n\t\tend\n\n\t\tassign\tlock_gbl = r_lock_gbl;\n\t\tassign\tlock_lcl = r_lock_lcl;\n\n\t\tassign\to_wb_cyc_gbl = (r_wb_cyc_gbl)||(lock_gbl);\n\t\tassign\to_wb_cyc_lcl = (r_wb_cyc_lcl)||(lock_lcl);\n\t\t// }}}\n\tend else begin : NO_LOCK\n\t\t// {{{\n\t\tassign\to_wb_cyc_gbl = (r_wb_cyc_gbl);\n\t\tassign\to_wb_cyc_lcl = (r_wb_cyc_lcl);\n\n\t\tassign\t{ lock_gbl, lock_lcl } = 2'b00;\n\n\t\t// Make verilator happy\n\t\t// verilator lint_off UNUSED",
            "wire [2:0]\tlock_unused;\n\t\tassign\tlock_unused = { i_lock, lock_gbl, lock_lcl };\n\t\t// verilator lint_on  UNUSED\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n`ifdef\tVERILATOR\n\talways @(posedge i_clk)\n\tif ((r_wb_cyc_gbl)||(r_wb_cyc_lcl))\n\t\tassert(!i_stb);\n`endif\n\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, pre_result };\n\tgenerate if (AW < 22)\n\tbegin : TOO_MANY_ADDRESS_BITS",
            "wire [(21-AW):0] unused_addr;\n\t\tassign\tunused_addr = i_addr[23:(AW+2)];\n\n\tend endgenerate\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n`define\tASSERT\tassert\n`ifdef\tMEMOPS\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "reg f_past_valid;",
            "reg [2:0]\t\tfcpu_op;",
            "reg [31:0]\t\tfcpu_addr, fcpu_data;;",
            "reg [BUS_WIDTH-1:0]\tfbus_data, fpre_data;",
            "reg [$clog2(BUS_WIDTH/8)-1:0] fcpu_shift;",
            "reg fcpu_local, fcpu_misaligned;",
            "reg [BUS_WIDTH/8-1:0]\tfbus_sel, fpre_sel;\n\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(i_reset);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tinitial\t`ASSUME(!i_stb);",
            "wire f_cyc, f_stb;\n\tassign\tf_cyc = (o_wb_cyc_gbl)||(o_wb_cyc_lcl);\n\tassign\tf_stb = (o_wb_stb_gbl)||(o_wb_stb_lcl);\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.AW(AW), .F_LGDEPTH(F_LGDEPTH), .DW(BUS_WIDTH),\n\t\t.F_OPT_RMW_BUS_OPTION(OPT_LOCK),\n\t\t.F_OPT_DISCONTINUOUS(OPT_LOCK)\n\t\t// }}}\n\t) f_wb(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\tf_cyc, f_stb, o_wb_we, o_wb_addr, o_wb_data, o_wb_sel,\n\t\ti_wb_ack, i_wb_stall, i_wb_data, i_wb_err,\n\t\tf_nreqs, f_nacks, f_outstanding\n\t\t// }}}\n\t);\n\n\n\t// Rule: Only one of the two CYC's may be valid, never both\n\talways @(posedge i_clk)\n\t\t`ASSERT((!o_wb_cyc_gbl)||(!o_wb_cyc_lcl));\n\n\t// Rule: Only one of the two STB's may be valid, never both\n\talways @(posedge i_clk)\n\t\t`ASSERT((!o_wb_stb_gbl)||(!o_wb_stb_lcl));\n\n\t// Rule: if WITH_LOCAL_BUS is ever false, neither the local STB nor CYC\n\t// may be valid\n\talways @(*)\n\tif (!WITH_LOCAL_BUS)\n\tbegin\n\t\t`ASSERT(!o_wb_cyc_lcl);\n\t\t`ASSERT(!o_wb_stb_lcl);\n\tend\n\n\t// Rule: If the global CYC is ever true, the LCL one cannot be true\n\t// on the next clock without an intervening idle of both\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(r_wb_cyc_gbl)))\n\t\t`ASSERT(!r_wb_cyc_lcl);\n\n\t// Same for if the LCL CYC is true\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(r_wb_cyc_lcl)))\n\t\t`ASSERT(!r_wb_cyc_gbl);\n\n\t// STB can never be true unless CYC is also true\n\talways @(posedge i_clk)\n\tif (o_wb_stb_gbl)\n\t\t`ASSERT(r_wb_cyc_gbl);\n\n\talways @(posedge i_clk)\n\tif (o_wb_stb_lcl)\n\t\t`ASSERT(r_wb_cyc_lcl);\n\n\t// This core only ever has zero or one outstanding transaction(s)\n\talways @(posedge i_clk)\n\tif ((o_wb_stb_gbl)||(o_wb_stb_lcl))\n\tbegin\n\t\t`ASSERT(f_outstanding == 0);\n\tend else\n\t\t`ASSERT((f_outstanding == 0)||(f_outstanding == 1));\n\n\t// The LOCK function only allows up to two transactions (at most)\n\t// before CYC must be dropped.\n\talways @(posedge i_clk)\n\tif ((o_wb_stb_gbl)||(o_wb_stb_lcl))\n\tbegin\n\t\tif (OPT_LOCK)\n\t\tbegin\n\t\t\t`ASSERT((f_outstanding == 0)||(f_outstanding == 1));\n\t\tend else\n\t\t\t`ASSERT(f_nreqs <= 1);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// CPU properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg f_done;",
            "wire [(F_LGDEPTH-1):0]\tcpu_outstanding;",
            "wire f_pc, f_rdbusy, f_gie, f_read_cycle;",
            "wire [4:0]\t\t\tf_last_",
            "reg ;",
            "wire [4:0]\t\t\tf_addr_",
            "reg ;\n\t// Verilator lint_off UNDRIVEN\n\t(* anyseq *)",
            "reg [4:0]\tf_a",
            "reg ;\n\t// Verilator lint_on  UNDRIVEN\n\n\tassign\tf_rdbusy = f_cyc && (f_stb || f_outstanding > 0) && !o_wb_we;\n\n\tinitial\tf_done = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_done <= 1'b0;\n\telse\n\t\tf_done <= ((o_wb_cyc_gbl)||(o_wb_cyc_lcl))&&(i_wb_ack);\n\n\tfmem #(\n\t\t// {{{\n\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t.OPT_LOCK(OPT_LOCK),\n\t\t.OPT_MAXDEPTH(1)\n\t\t// }}}\n\t) fmemi(\n\t\t// {{{\n\t\t.i_clk(i_clk),\n\t\t.i_sys_reset(i_reset),\n\t\t.i_cpu_reset(i_reset),\n\t\t.i_stb(i_stb),\n\t\t.i_pipe_stalled(o_busy),\n\t\t.i_clear_cache(1'b0),\n\t\t.i_lock(i_lock),\n\t\t.i_op(i_op), .i_addr(i_addr), .i_data(i_data), .i_o",
            "reg (i_o",
            "reg ),\n\t\t.i_a",
            "reg (f_a",
            "reg ),\n\t\t.i_busy(o_busy),\n\t\t.i_rdbusy(f_rdbusy),\n\t\t.i_valid(o_valid), .i_done(f_done), .i_err(o_err),\n\t\t.i_w",
            "reg (o_w",
            "reg ), .i_result(o_result),\n\t\t.f_outstanding(cpu_outstanding),\n\t\t.f_pc(f_pc),\n\t\t.f_gie(f_gie),\n\t\t.f_read_cycle(f_read_cycle),\n\t\t.f_last_",
            "reg (f_last_",
            "reg ), .f_addr_",
            "reg (f_addr_",
            "reg )\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif (!o_err)\n\t\tassert(cpu_outstanding == f_outstanding + (f_stb ? 1:0)\n\t\t\t\t\t+ ((f_done || o_err) ? 1:0));\n\n\talways @(*)\n\t\tassert(cpu_outstanding <= 1);\n\n\talways @(*)\n\tif (f_pc)\n\tbegin\n\t\tassert(o_w",
            "reg [3:1] == 3'h7);\n\tend else if (f_rdbusy)\n\t\tassert(o_w",
            "reg [3:1] != 3'h7);\n\n\talways @(*)\n\tif (o_busy)\n\t\tassert(o_w",
            "reg [4] == f_gie);\n\n\talways @(*)\n\tif (!o_err)\n\t\tassert(f_rdbusy == o_rdbusy);\n\n\talways @(*)\n\tif (o_busy)\n\t\tassert(o_wb_we == !f_read_cycle);\n\n\talways @(*)\n\tif (cpu_outstanding > 0)\n\t\tassert(f_last_",
            "reg == o_w",
            "reg );\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Tying the two together\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Following any i_stb request, assuming we are idle, immediately\n\t// begin a bus transaction\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_stb))\n\t\t&&(!$past(f_cyc))&&(!$past(i_reset)))\n\tbegin\n\t\tif ($past(misaligned))\n\t\tbegin\n\t\t\t`ASSERT(!f_cyc);\n\t\t\t`ASSERT(!o_busy);\n\t\t\t`ASSERT(o_err);\n\t\t\t`ASSERT(!o_valid);\n\t\tend else begin\n\t\t\t`ASSERT(f_cyc);\n\t\t\t`ASSERT(o_busy);\n\t\tend\n\tend\n\n//\talways @(posedge i_clk)\n//\tif (o_busy)\n//\t\t`ASSUME(!i_stb);\n\n\talways @(*)\n\tif (o_err || o_valid)\n\t\t`ASSERT(!o_busy);\n\n\talways @(posedge i_clk)\n\tif (o_wb_cyc_gbl)\n\t\t`ASSERT((o_busy)||(lock_gbl));\n\n\talways @(posedge i_clk)\n\tif (o_wb_cyc_lcl)\n\t\t`ASSERT((o_busy)||(lock_lcl));\n\n\talways @(posedge i_clk)\n\tif (f_outstanding > 0)\n\t\t`ASSERT(o_busy);\n\n\t// If a transaction ends in an error, send o_err on the",
            "output port.\n\talways @(posedge i_clk)\n\tif (f_past_valid && !$past(i_reset))\n\tbegin\n\t\tif (($past(f_cyc))&&($past(i_wb_err)))\n\t\tbegin\n\t\t\t`ASSERT(o_err);\n\t\tend else if ($past(misaligned))\n\t\t\t`ASSERT(o_err);\n\tend\n\n\t// Always following a successful ACK, return an O_VALID value.\n\talways @(posedge i_clk)\n\tif (f_past_valid && !$past(i_reset))\n\tbegin\n\t\tif(($past(f_cyc))&&($past(i_wb_ack))\n\t\t\t\t&&(!$past(o_wb_we)))\n\t\tbegin\n\t\t\t`ASSERT(o_valid);\n\t\tend else if ($past(misaligned))\n\t\tbegin\n\t\t\t`ASSERT((!o_valid)&&(o_err));\n\t\tend else\n\t\t\t`ASSERT(!o_valid);\n\tend\n\n\talways @(posedge i_clk)\n\tif (i_stb)\n\tbegin\n\t\tfcpu_op   <= i_op;\n\t\tfcpu_addr <= i_addr;\n\t\tfcpu_data <= i_data;\n\tend\n\n\talways @(*)\n\tbegin\n\t\tfcpu_local = (&fcpu_addr[31:24]) && WITH_LOCAL_BUS;\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tcasez(fcpu_op[2:1])\n\t\t\t2'b11: fpre_sel = { {(BUS_WIDTH/8-1){1'b0}}, 1'b1 };\n\t\t\t2'b10: fpre_sel = { {(BUS_WIDTH/8-2){1'b0}}, 2'b11 };\n\t\t\t2'b0?: fpre_sel = { {(BUS_WIDTH/8-4){1'b0}}, 4'b1111 };\n\t\t\tendcase\n\n\t\t\tcasez(fcpu_op[2:1])\n\t\t\t2'b11: fpre_data = { {(BUS_WIDTH- 8){1'b0}}, fcpu_data[ 7:0] };\n\t\t\t2'b10: fpre_data = { {(BUS_WIDTH-16){1'b0}}, fcpu_data[15:0] };\n\t\t\t2'b0?: fpre_data = { {(BUS_WIDTH-32){1'b0}}, fcpu_data[31:0] };\n\t\t\tendcase\n\t\t\t// }}}\n\t\tend else if (fcpu_local)\n\t\tbegin\n\t\t\t// {{{\n\t\t\tfpre_sel = 0;\n\t\t\tcasez(fcpu_op[2:1])\n\t\t\t2'b11: fpre_sel[3:0] = 4'b1000;\n\t\t\t2'b10: fpre_sel[3:0] = 4'b1100;\n\t\t\t2'b0?: fpre_sel[3:0] = 4'b1111;\n\t\t\tendcase\n\n\t\t\tfpre_data = 0;\n\t\t\tcasez(fcpu_op[2:1])\n\t\t\t2'b11: fpre_data[31:0] = { fcpu_data[ 7:0], {(24){1'b0}} };\n\t\t\t2'b10: fpre_data[31:0] = { fcpu_data[15:0], {(16){1'b0}} };\n\t\t\t2'b0?: fpre_data[31:0] = fcpu_data[31:0];\n\t\t\tendcase\n\t\t\t// }}}\n\t\tend else begin\n\t\t\t// {{{\n\t\t\tcasez(fcpu_op[2:1])\n\t\t\t2'b11: fpre_sel = { 1'b1,    {(BUS_WIDTH/8-1){1'b0}} };\n\t\t\t2'b10: fpre_sel = { 2'b11,   {(BUS_WIDTH/8-2){1'b0}} };\n\t\t\t2'b0?: fpre_sel = { 4'b1111, {(BUS_WIDTH/8-4){1'b0}} };\n\t\t\tendcase\n\n\t\t\tcasez(fcpu_op[2:1])\n\t\t\t2'b11: fpre_data = { fcpu_data[ 7:0], {(BUS_WIDTH- 8){1'b0}} };\n\t\t\t2'b10: fpre_data = { fcpu_data[15:0], {(BUS_WIDTH-16){1'b0}} };\n\t\t\t2'b0?: fpre_data = { fcpu_data[31:0], {(BUS_WIDTH-32){1'b0}} };\n\t\t\tendcase\n\t\t\t// }}}\n\t\tend\n\n\n\t\tcasez({ fcpu_op[2:1], fcpu_addr[1:0] })\n\t\t4'b01?1: fcpu_misaligned = 1'b1; // Words must be halfword aligned\n\t\t4'b0110: fcpu_misaligned = 1'b1; // Words must be word aligned\n\t\t4'b10?1: fcpu_misaligned = 1'b1; // Halfwords must be aligned\n\t\t// 4'b11??: fcpu_misaligned <= 1'b0; Byte access are never misaligned\n\t\tdefault: fcpu_misaligned = 1'b0;\n\t\tendcase\n\n\t\tif (fcpu_local)\n\t\tbegin\n\t\t\tfcpu_shift = fcpu_addr[1:0];\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\tfbus_sel   = fpre_sel  << fcpu_shift;\n\t\t\t\tfbus_data  = fpre_data << (8*fcpu_shift);\n\t\t\tend else begin\n\t\t\t\tfbus_sel   = fpre_sel  >> (fcpu_shift + (DATA_WIDTH/8-4));\n\t\t\t\tfbus_data  = fpre_data >> (8*(fcpu_shift + (DATA_WIDTH/8-4)));\n\t\t\tend\n\t\tend else begin\n\t\t\tfcpu_shift = fcpu_addr[WBLSB-1:0];\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\tfbus_sel  = fpre_sel  << fcpu_shift;\n\t\t\t\tfbus_data = fpre_data << (8*fcpu_shift);\n\t\t\tend else begin\n\t\t\t\tfbus_sel  = fpre_sel  >> fcpu_shift;\n\t\t\t\tfbus_data = fpre_data >> (8*fcpu_shift);\n\t\t\tend\n\t\tend\n\n\t\tif (!OPT_LOWPOWER)\n\t\tcasez(fcpu_op[2:1])\n\t\t2'b11: fbus_data = {(BUS_WIDTH/ 8){fcpu_data[ 7:0] } };\n\t\t2'b10: fbus_data = {(BUS_WIDTH/16){fcpu_data[15:0] } };\n\t\t2'b0?: fbus_data = {(BUS_WIDTH/32){fcpu_data[31:0] } };\n\t\tendcase\n\tend\n\n\talways @(*)\n\tif (OPT_ALIGNMENT_ERR && fcpu_misaligned)\n\t\tassert(!o_valid && !f_cyc);\n\n\talways @(*)\n\tif (f_stb)\n\tbegin\n\t\tif (fcpu_local)\n\t\tbegin\n\t\t\tassert(o_wb_stb_lcl);\n\t\t\tassert(o_wb_addr == fcpu_addr[AW+1:2]);\n\t\tend else begin\n\t\t\tassert(o_wb_stb_gbl);\n\t\t\tassert(o_wb_addr == fcpu_addr[WBLSB +: AW]);\n\t\tend\n\n\t\tif (fcpu_op[0])\n\t\tbegin\n\t\t\t`ASSERT(o_wb_we);\n\t\t\t`ASSERT(fcpu_misaligned || o_wb_sel  == fbus_sel);\n\t\t\t`ASSERT(fcpu_misaligned || o_wb_data == fbus_data);\n\t\tend else begin\n\t\t\t`ASSERT(!o_wb_we);\n\t\tend\n\tend\n\n\talways @(*)\n\tif (f_cyc)\n\t\tassert(o_wb_cyc_lcl == fcpu_local);\n\n\tinitial\to_wb_we = 1'b0;\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_stb)))\n\tbegin\n\t\t// On a write, assert o_wb_we should be true\n\t\tassert( $past(i_op[0]) == o_wb_we);\n\tend\n\n\talways @(posedge i_clk)\n\tif (o_wb_stb_lcl)\n\t\t`ASSERT(fcpu_local);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(misaligned)))\n\tbegin\n\t\t`ASSERT(!o_wb_cyc_gbl);\n\t\t`ASSERT(!o_wb_cyc_lcl);\n\t\t`ASSERT(!o_wb_stb_gbl);\n\t\t`ASSERT(!o_wb_stb_lcl);\n\t\t`ASSERT(o_err);\n\tend\n\n//\talways @(posedge i_clk)\n//\tif ((!f_past_valid)||($past(i_reset)))\n//\t\t`ASSUME(!i_stb);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(OPT_LOCK)\n\t\t\t&&(!$past(i_reset))&&(!$past(i_wb_err))\n\t\t\t&&(!$past(misaligned))\n\t\t\t&&(!$past(lcl_stb))\n\t\t\t&&($past(i_lock))&&($past(lock_gbl)))\n\t\tassert(lock_gbl);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(OPT_LOCK)\n\t\t\t&&(!$past(i_reset))&&(!$past(i_wb_err))\n\t\t\t&&(!$past(misaligned))\n\t\t\t&&(!$past(lcl_stb))\n\t\t\t&&($past(o_wb_cyc_gbl))&&($past(i_lock))\n\t\t\t&&($past(lock_gbl)))\n\t\tassert(o_wb_cyc_gbl);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(OPT_LOCK)\n\t\t\t&&(!$past(i_reset))&&(!$past(i_wb_err))\n\t\t\t&&(!$past(misaligned))\n\t\t\t&&(!$past(gbl_stb))\n\t\t\t&&($past(o_wb_cyc_lcl))&&($past(i_lock))\n\t\t\t&&($past(lock_lcl)))\n\t\tassert(o_wb_cyc_lcl);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(posedge i_clk)\n\t\tcover(i_wb_ack);\n\n\t// Cover a response on the same clock it is made\n\talways @(posedge i_clk)\n\t\tcover((o_wb_stb_gbl)&&(i_wb_ack));\n\n\t// Cover a response a clock later\n\talways @(posedge i_clk)\n\t\tcover((o_wb_stb_gbl)&&(i_wb_ack));\n\n\talways @(posedge i_clk)\n\t\tcover(f_done);\n\n\talways @(posedge i_clk)\n\t\tcover(f_done && !o_busy);\n\n\tgenerate if (WITH_LOCAL_BUS)\n\tbegin\n\n\t\t// Same things on the local bus\n\t\talways @(posedge i_clk)\n\t\t\tcover((o_wb_cyc_lcl)&&(!o_wb_stb_lcl)&&(i_wb_ack));\n\t\talways @(posedge i_clk)\n\t\t\tcover((o_wb_stb_lcl)&&(i_wb_ack));\n\n\tend endgenerate\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, f_nacks, f_addr_",
            "reg };\n\t// Verilator lint_on  UNUSED\n\t// }}}\n`endif\n// }}}",
            "endmodule //\n//\n// Usage (from yosys):\n//\t\t(BFOR)\t(!ZOI,ALIGN)\t(ZOI,ALIGN)\t(!ZOI,!ALIGN)\n//\tCells\t 230\t\t226\t\t281\t\t225\n//\t  FDRE\t 114\t\t116\t\t116\t\t116\n//\t  LUT2\t  17\t\t 23\t\t 76\t\t 19\n//\t  LUT3\t   9\t\t 23\t\t 17\t\t 20\n//\t  LUT4\t  15\t\t  4\t\t 11\t\t 14\n//\t  LUT5\t  18\t\t 18\t\t  7\t\t 15\n//\t  LUT6\t  33\t\t 18\t\t 54\t\t 38\n//\t  MUX7\t  16\t\t 12\t\t  \t\t  2\n//\t  MUX8\t   8\t\t  1\t\t\t\t  1\n//\n//"
        ]
    },
    {
        "file_name": "wbpriarbiter.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/wbpriarbiter.v",
        "chunks": [
            "logic required in the other wishbone arbiter, while still guarateeing\n//\taccess time for the priority channel.\n//\n//\tThe core",
            "logic works like this:\n//\n//\t1. When no one requests the bus, 'A' is granted the bus and guaranteed\n//\t\tthat any access will go right through.\n//\t2. If 'B' requests the bus (asserts cyc), and the bus is idle, then\n//\t\t'B' will be granted the bus.\n//\t3. Bus grants last as long as the 'cyc' line is high.\n//\t4. Once 'cyc' is dropped, the bus returns to 'A' as the owner.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module wbpriarbiter #(\n\t\t// {{{",
            "parameter DW=32, AW=32,\n\t\t// OPT_ZERO_ON_IDLE\n\t\t// {{{\n\t\t// ZERO_ON_IDLE uses more",
            "logic than the alternative.  It should\n\t\t// be useful for reducing power, as these circuits tend to drive\n\t\t//",
            "wire s all the way across the design, but it may also slow\n\t\t// down the master clock.  I've used it as an option when using\n\t\t// VER1LATOR, 'cause zeroing things on idle can make them stand\n\t\t// out all the more when staring at",
            "wire s and dumps and such.",
            "parameter [0:0]\t\tOPT_ZERO_ON_IDLE = 1'b0\n\t\t// }}}\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk,\n\t\t// Bus A\n\t\t// {{{",
            "input ",
            "wire i_a_cyc, i_a_stb, i_a_we,",
            "input ",
            "wire [(AW-1):0]\ti_a_adr,",
            "input ",
            "wire [(DW-1):0]\ti_a_dat,",
            "input ",
            "wire [(DW/8-1):0]\ti_a_sel,",
            "output ",
            "wire o_a_stall, o_a_ack, o_a_err,\n\t\t// }}}\n\t\t// Bus B\n\t\t// {{{",
            "input ",
            "wire i_b_cyc, i_b_stb, i_b_we,",
            "input ",
            "wire [(AW-1):0]\ti_b_adr,",
            "input ",
            "wire [(DW-1):0]\ti_b_dat,",
            "input ",
            "wire [(DW/8-1):0]\ti_b_sel,",
            "output ",
            "wire o_b_stall, o_b_ack, o_b_err,\n\t\t// }}}\n\t\t// Outgoing combined bus\n\t\t// {{{",
            "output ",
            "wire o_cyc, o_stb, o_we,",
            "output ",
            "wire [(AW-1):0]\to_adr,",
            "output ",
            "wire [(DW-1):0]\to_dat,",
            "output ",
            "wire [(DW/8-1):0]\to_sel,",
            "input ",
            "wire i_stall, i_ack, i_err\n\t\t// }}}\n\t\t// }}}\n\t);",
            "reg r_a_owner;\n\n\t// r_a_owner\n\t// {{{\n\t// Go high immediately (new cycle) if ...\n\t//\tPrevious cycle was low and *someone* is requesting a bus cycle\n\t// Go low immadiately if ...\n\t//\tWe were just high and the owner no longer wants the bus\n\t// WISHBONE Spec recommends no",
            "logic between a FF and the o_cyc\n\t//\tThis violates that spec.  (Rec 3.15, p35)\n\tinitial\tr_a_owner = 1'b1;\n\talways @(posedge i_clk)\n\tif (!i_b_cyc)\n\t\tr_a_owner <= 1'b1;\n\t// Allow B to set its CYC line w/o activating this interface\n\telse if ((i_b_cyc)&&(i_b_stb)&&(!i_a_cyc))\n\t\tr_a_owner <= 1'b0;\n\t// }}}\n\n\t// CYC, STB, and WE\n\t// {{{\n\t// Realistically, if neither master owns the bus, the",
            "output is a\n\t// don't care.  Thus we trigger off whether or not 'A' owns the bus.\n\t// If 'B' owns it all we care is that 'A' does not.  Likewise, if\n\t// neither owns the bus than the values on these various lines are\n\t// irrelevant.\n\n\tassign o_cyc = (r_a_owner) ? i_a_cyc : i_b_cyc;\n\tassign o_we  = (r_a_owner) ? i_a_we  : i_b_we;\n\tassign o_stb   = (r_a_owner) ? i_a_stb   : i_b_stb;\n\t// }}}\n\n\t// Everything else\n\t// {{{\n\tgenerate if (OPT_ZERO_ON_IDLE)\n\tbegin : OPT_LOWPOWER\n\t\t// {{{\n\t\tassign\to_adr     = (o_stb)?((r_a_owner) ? i_a_adr  : i_b_adr):0;\n\t\tassign\to_dat     = (o_stb)?((r_a_owner) ? i_a_dat  : i_b_dat):0;\n\t\tassign\to_sel     = (o_stb)?((r_a_owner) ? i_a_sel  : i_b_sel):0;\n\t\tassign\to_a_ack   = (o_cyc)&&( r_a_owner) ? i_ack   : 1'b0;\n\t\tassign\to_b_ack   = (o_cyc)&&(!r_a_owner) ? i_ack   : 1'b0;\n\t\tassign\to_a_stall = (o_cyc)&&( r_a_owner) ? i_stall : 1'b1;\n\t\tassign\to_b_stall = (o_cyc)&&(!r_a_owner) ? i_stall : 1'b1;\n\t\tassign\to_a_err   = (o_cyc)&&( r_a_owner) ? i_err : 1'b0;\n\t\tassign\to_b_err   = (o_cyc)&&(!r_a_owner) ? i_err : 1'b0;\n\t\t// }}}\n\tend else begin : OPT_LOWLOGIC\n\t\t// {{{\n\t\tassign o_adr   = (r_a_owner) ? i_a_adr   : i_b_adr;\n\t\tassign o_dat   = (r_a_owner) ? i_a_dat   : i_b_dat;\n\t\tassign o_sel   = (r_a_owner) ? i_a_sel   : i_b_sel;\n\n\t\t// We cannot allow the return acknowledgement to ever go high if\n\t\t// the master in question does not own the bus.  Hence we force it\n\t\t// low if the particular master doesn't own the bus.\n\t\tassign\to_a_ack   = ( r_a_owner) ? i_ack   : 1'b0;\n\t\tassign\to_b_ack   = (!r_a_owner) ? i_ack   : 1'b0;\n\n\t\t// Stall must be asserted on the same cycle the",
            "input master asserts\n\t\t// the bus, if the bus isn't granted to him.\n\t\tassign\to_a_stall = ( r_a_owner) ? i_stall : 1'b1;\n\t\tassign\to_b_stall = (!r_a_owner) ? i_stall : 1'b1;\n\n\t\t//\n\t\t//\n\t\tassign\to_a_err = ( r_a_owner) ? i_err : 1'b0;\n\t\tassign\to_b_err = (!r_a_owner) ? i_err : 1'b0;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n`ifdef\tWBPRIARBITER\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\tinitial\tassume(!i_a_cyc);\n\tinitial\tassume(!i_a_stb);\n\n\tinitial\tassume(!i_b_cyc);\n\tinitial\tassume(!i_b_stb);\n\n\tinitial\tassume(!i_ack);\n\tinitial\tassume(!i_err);\n\n\talways @(posedge i_clk)\n\tbegin\n\t\tif (o_cyc)\n\t\t\tassert((i_a_cyc)||(i_b_cyc));\n\t\tif ((f_past_valid)&&($past(o_cyc))&&(o_cyc))\n\t\t\tassert($past(r_a_owner) == r_a_owner);\n\t\tif ((f_past_valid)&&($past(!o_cyc))&&($past(i_a_stb)))\n\t\t\tassert(r_a_owner);\n\t\tif ((f_past_valid)&&($past(!o_cyc))&&($past(i_b_stb)))\n\t\t\tassert(!r_a_owner);\n\tend",
            "reg f_reset;\n\tinitial\tf_reset = 1'b1;\n\talways @(posedge i_clk)\n\t\tf_reset <= 1'b0;\n\talways @(*)\n\t\tif (!f_past_valid)\n\t\t\tassert(f_reset);",
            "parameter F_LGDEPTH=3;",
            "wire [(F_LGDEPTH-1):0]\tf_nreqs, f_nacks, f_outstanding,\n\t\t\tf_a_nreqs, f_a_nacks, f_a_outstanding,\n\t\t\tf_b_nreqs, f_b_nacks, f_b_outstanding;\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.F_MAX_STALL(0),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_MAX_ACK_DELAY(0),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t\t.F_OPT_DISCONTINUOUS(1)\n\t\t// }}}\n\t) f_wbm(\n\t\t// {{{\n\t\ti_clk, f_reset,\n\t\t\to_cyc, o_stb, o_we, o_adr, o_dat, o_sel,\n\t\t\ti_ack, i_stall, 32'h0, i_err,\n\t\t\tf_nreqs, f_nacks, f_outstanding\n\t\t// }}}\n\t);\n\n\tfwb_slave  #(\n\t\t// {{{\n\t\t.F_MAX_STALL(0),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_MAX_ACK_DELAY(0),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t\t.F_OPT_DISCONTINUOUS(1)\n\t\t// }}}\n\t) f_wba(\n\t\t// {{{\n\t\ti_clk, f_reset,\n\t\t\ti_a_cyc, i_a_stb, i_a_we, i_a_adr, i_a_dat, i_a_sel,\n\t\t\to_a_ack, o_a_stall, 32'h0, o_a_err,\n\t\t\tf_a_nreqs, f_a_nacks, f_a_outstanding\n\t\t// }}}\n\t);\n\n\tfwb_slave  #(\n\t\t// {{{\n\t\t.F_MAX_STALL(0),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_MAX_ACK_DELAY(0),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t\t.F_OPT_DISCONTINUOUS(1)\n\t\t// }}}\n\t) f_wbb(\n\t\t// {{{\n\t\ti_clk, f_reset,\n\t\ti_b_cyc, i_b_stb, i_b_we, i_b_adr, i_b_dat, i_b_sel,\n\t\to_b_ack, o_b_stall, 32'h0, o_b_err,\n\t\tf_b_nreqs, f_b_nacks, f_b_outstanding\n\t\t// }}}\n\t);\n\n\t// Induction, relate number of requests and acks to r_a_owner\n\t// {{{\n\talways @(posedge i_clk)\n\tif (r_a_owner)\n\tbegin\n\t\tassert(f_b_nreqs == 0);\n\t\tassert(f_b_nacks == 0);\n\t\tassert(f_a_outstanding == f_outstanding);\n\tend else begin\n\t\tassert(f_a_nreqs == 0);\n\t\tassert(f_a_nacks == 0);\n\t\tassert(f_b_outstanding == f_outstanding);\n\tend\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((r_a_owner)&&(i_b_cyc))\n\t\t\tassume(i_b_stb);\n\n\talways @(posedge i_clk)\n\tif ((r_a_owner)&&(i_a_cyc))\n\t\tassume(i_a_stb);\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "busdelay.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/busdelay.v",
        "chunks": [
            "logic has been merged in with the old,\n//\tand the DELAY_STALL line can be set to non-zero to use it instead\n//\tof the original",
            "logic .  Don't use it if you don't need it: it will\n//\tconsume resources and slow your bus down more, but if you do need\n//\tit--don't be afraid to use it.\n//\n//\tBoth versions of the bus delay will maintain a single access per\n//\tclock when pipelined, they only delay the time between the strobe\n//\tgoing high and the actual command being accomplished.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module busdelay #(\n\t\t// {{{",
            "parameter AW=32, DW=32,\n`ifdef\tFORMAL",
            "localparam F_LGDEPTH=4,\n`endif",
            "parameter [0:0]\tDELAY_STALL  = 1,",
            "parameter [0:0]\tOPT_LOWPOWER = 0\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Input/master bus\n\t\t// {{{",
            "input ",
            "wire i_wb_cyc, i_wb_stb, i_wb_we,",
            "input ",
            "wire [(AW-1):0]\ti_wb_addr,",
            "input ",
            "wire [(DW-1):0]\ti_wb_data,",
            "input ",
            "wire [(DW/8-1):0]\ti_wb_sel,",
            "output ",
            "wire o_wb_stall,",
            "output ",
            "reg o_wb_ack,",
            "output ",
            "reg [(DW-1):0]\to_wb_data,",
            "output ",
            "reg o_wb_err,\n\t\t// }}}\n\t\t// Delayed bus\n\t\t// {{{",
            "output ",
            "reg o_dly_cyc, o_dly_stb, o_dly_we,",
            "output ",
            "reg [(AW-1):0]\to_dly_addr,",
            "output ",
            "reg [(DW-1):0]\to_dly_data,",
            "output ",
            "reg [(DW/8-1):0]\to_dly_sel,",
            "input ",
            "wire i_dly_stall,",
            "input ",
            "wire i_dly_ack,",
            "input ",
            "wire [(DW-1):0]\ti_dly_data,",
            "input ",
            "wire i_dly_err\n\t\t// }}}\n\t\t// }}}\n\t);\n\n`ifdef\tFORMAL",
            "wire [2+AW+DW+DW/8-1:0]\tf_wpending;\n`endif\n\n\tgenerate if (DELAY_STALL)\n\tbegin : SKIDBUFFER\n\t\t// {{{",
            "reg r_stb, r_we;",
            "reg [(AW-1):0]\tr_addr;",
            "reg [(DW-1):0]\tr_data;",
            "reg [(DW/8-1):0]\tr_sel;\n\n\t\t// o_dly_cyc\n\t\t// {{{\n\t\tinitial\to_dly_cyc  = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wb_cyc)\n\t\t\to_dly_cyc <= 1'b0;\n\t\telse\n\t\t\to_dly_cyc <= (!o_wb_err)&&((!i_dly_err)||(!o_dly_cyc));\n\t\t// }}}\n\n\t\t// o_dly_stb\n\t\t// {{{\n\t\tinitial\to_dly_stb  = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wb_cyc || o_wb_err || (o_dly_cyc && i_dly_err))\n\t\t\to_dly_stb <= 1'b0;\n\t\telse if (!o_dly_stb || !i_dly_stall)\n\t\t\to_dly_stb <= i_wb_stb || r_stb;\n\t\t// }}}\n\n\t\t// r_stb\n\t\t// {{{\n\t\tinitial\tr_stb      = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wb_cyc || o_wb_err || i_dly_err\n\t\t\t\t\t|| !i_dly_stall || !o_dly_stb)\n\t\t\tr_stb <= 1'b0;\n\t\telse if (i_wb_stb && !o_wb_stall) // && (o_dly_stb&&i_dly_stall)\n\t\t\tr_stb <= 1'b1;\n\t\t// }}}\n\n\t\t// r_*\n\t\t// {{{\n\t\tinitial { r_we, r_addr, r_data, r_sel } = 0;\n\t\talways @(posedge i_clk)\n\t\tif (OPT_LOWPOWER && (i_reset || !i_wb_cyc || i_dly_err\n\t\t\t\t\t|| !o_dly_stb || !i_dly_stall))\n\t\t\t{ r_we, r_addr, r_data, r_sel } <= 0;\n\t\telse if (i_wb_stb && !o_wb_stall) // && (o_dly_stb&&i_dly_stall)\n\t\t\t{ r_we, r_addr, r_data, r_sel }\n\t\t\t\t<= { i_wb_we, i_wb_addr, i_wb_data, i_wb_sel };\n\t\t// }}}\n\n\t\tinitial\to_dly_we   = 1'b0;\n\t\tinitial\to_dly_addr = 0;\n\t\tinitial\to_dly_data = 0;\n\t\tinitial\to_dly_sel  = 0;\n\t\talways @(posedge i_clk)\n\t\tif (OPT_LOWPOWER && (i_reset || (!i_wb_cyc || o_wb_err || (o_dly_cyc && i_dly_err))))\n\t\t\t{ o_dly_we, o_dly_addr, o_dly_data, o_dly_sel } <= 0;\n\t\telse if (!o_dly_stb || !i_dly_stall)\n\t\tbegin\n\t\t\tif (r_stb)\n\t\t\t\t{ o_dly_we, o_dly_addr, o_dly_data, o_dly_sel } <= { r_we, r_addr, r_data, r_sel };\n\t\t\telse if (!OPT_LOWPOWER || i_wb_stb)\n\t\t\t\t{ o_dly_we, o_dly_addr, o_dly_data, o_dly_sel } <= { i_wb_we, i_wb_addr, i_wb_data, i_wb_sel };\n\t\t\telse\n\t\t\t\t{ o_dly_addr, o_dly_data, o_dly_sel } <= 0;\n\n\t\tend\n\n\t\tassign\to_wb_stall = r_stb;\n\n\t\t// o_wb_ack\n\t\t// {{{\n\t\tinitial\to_wb_ack = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wb_cyc || o_wb_err || !o_dly_cyc)\n\t\t\to_wb_ack <= 1'b0;\n\t\telse\n\t\t\to_wb_ack  <= (i_dly_ack);\n\t\t// }}}\n\n\t\t// o_wb_data\n\t\t// {{{\n\t\tinitial\to_wb_data = 0;\n\t\talways @(posedge i_clk)\n\t\tif (OPT_LOWPOWER && (i_reset || !i_wb_cyc || !o_dly_cyc\n\t\t\t\t|| o_wb_err || !i_dly_ack))\n\t\t\to_wb_data <= 0;\n\t\telse\n\t\t\to_wb_data <= i_dly_data;\n\t\t// }}}\n\n\t\t// o_wb_err\n\t\t// {{{\n\t\tinitial\to_wb_err   = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wb_cyc || !o_dly_cyc)\n\t\t\to_wb_err <= 1'b0;\n\t\telse\n\t\t\to_wb_err  <= i_dly_err;\n\t\t// }}}\n\n\n`ifdef\tFORMAL\n\t// {{{\n\t\tassign\tf_wpending = { r_stb, r_we, r_addr, r_data, r_sel };\n\n\t\talways @(*)\n\t\tif (OPT_LOWPOWER && !r_stb)\n\t\tbegin\n\t\t\tassert(r_we   == 0);\n\t\t\tassert(r_addr == 0);\n\t\t\tassert(r_data == 0);\n\t\t\tassert(r_sel  == 0);\n\t\tend else if (r_stb)\n\t\t\tassert(r_we == o_dly_we);\n\t\t// }}}\n`endif\n\t\t// }}}\n\tend else begin : NO_SKIDBUFFER\n\t\t// {{{\n\t\tinitial\to_dly_cyc   = 1'b0;\n\t\tinitial\to_dly_stb   = 1'b0;\n\t\tinitial\to_dly_we    = 1'b0;\n\t\tinitial\to_dly_addr  = 0;\n\t\tinitial\to_dly_data  = 0;\n\t\tinitial\to_dly_sel   = 0;\n\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\to_dly_cyc <= 1'b0;\n\t\telse if ((i_dly_err)&&(o_dly_cyc))\n\t\t\to_dly_cyc <= 1'b0;\n\t\telse if ((o_wb_err)&&(i_wb_cyc))\n\t\t\to_dly_cyc <= 1'b0;\n\t\telse\n\t\t\to_dly_cyc <= i_wb_cyc;\n\n\t\t// Add the i_wb_cyc criteria here, so we can simplify the\n\t\t// o_wb_stall criteria below, which would otherwise *and*\n\t\t// these two.\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\to_dly_stb <= 1'b0;\n\t\telse if ((i_dly_err)&&(o_dly_cyc))\n\t\t\to_dly_stb <= 1'b0;\n\t\telse if ((o_wb_err)&&(i_wb_cyc))\n\t\t\to_dly_stb <= 1'b0;\n\t\telse if (!i_wb_cyc)\n\t\t\to_dly_stb <= 1'b0;\n\t\telse if (!o_wb_stall)\n\t\t\to_dly_stb <= (i_wb_stb);\n\n\t\talways @(posedge i_clk)\n\t\tif (!o_wb_stall)\n\t\t\to_dly_we  <= i_wb_we;\n\n\t\tinitial\to_dly_addr = 0;\n\t\talways @(posedge i_clk)\n\t\tif (OPT_LOWPOWER && (i_reset || !i_wb_cyc || o_wb_err\n\t\t\t\t\t\t|| (o_dly_cyc && i_dly_err)))\n\t\t\t{ o_dly_addr, o_dly_data, o_dly_sel } <= 0;\n\t\telse if (!o_dly_stb || !i_dly_stall)\n\t\tbegin\n\t\t\t{ o_dly_addr, o_dly_data, o_dly_sel }\n\t\t\t\t<= { i_wb_addr, i_wb_data, i_wb_sel };\n\t\t\tif (OPT_LOWPOWER && !i_wb_stb)\n\t\t\t\t{ o_dly_addr, o_dly_data, o_dly_sel } <= 0;\n\t\tend\n\n\t\tinitial\to_wb_ack    = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\to_wb_ack <= 1'b0;\n\t\telse\n\t\t\to_wb_ack  <= ((i_dly_ack)&&(!i_dly_err)\n\t\t\t\t&&(o_dly_cyc)&&(i_wb_cyc))\n\t\t\t\t&&(!o_wb_err);\n\n\t\tinitial\to_wb_err    = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\to_wb_err <= 1'b0;\n\t\telse if (!o_dly_cyc)\n\t\t\to_wb_err <= 1'b0;\n\t\telse\n\t\t\to_wb_err  <= (o_wb_err)||(i_dly_err)&&(i_wb_cyc);\n\n\t\tinitial\to_wb_data   = 0;\n\t\talways @(posedge i_clk)\n\t\tif (OPT_LOWPOWER && (i_reset || !i_wb_cyc || !o_dly_cyc || o_wb_err || !i_dly_ack))\n\t\t\to_wb_data <= 0;\n\t\telse\n\t\t\to_wb_data <= i_dly_data;\n\n\t\t// Our only non-delayed line, yet still really delayed.  Perhaps\n\t\t// there's a way to",
            "reg ister this?\n\t\t// o_wb_stall <= (i_wb_cyc)&&(i_wb_stb) ... or some such?\n\t\t// assign o_wb_stall=((i_wb_cyc)&&(i_dly_stall)&&(o_dly_stb));//&&o_cyc\n\t\tassign\to_wb_stall = (i_dly_stall)&&(o_dly_stb);\n\n`ifdef\tFORMAL\n\t\t// f_wpending isn't used if DELAY_STALL is zero, but we'll give\n\t\t// it a seemingly useful value anyway--if for no other reason\n\t\t// than to be sure we set it to the right number of bits\n\t\tassign\tf_wpending = { i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel };\n`endif\n\t\t// }}}\n\tend endgenerate\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Declarations\n\t// {{{\n`ifdef\tBUSDELAY\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "localparam ACK_DELAY = 5,\n\t\t\tSTALL_DELAY = 4;",
            "localparam STB_BIT = 2+AW+DW+DW/8-1;",
            "wire [(F_LGDEPTH-1):0]\tf_wb_nreqs,f_wb_nacks, f_wb_outstanding,\n\t\t\t\tf_dly_nreqs, f_dly_nacks, f_dly_outstanding;",
            "wire f_wb_busy, f_dly_busy, f_wb_req, f_dly_req;",
            "wire [STB_BIT:0]\t\tf_wb_request, f_dly_request;",
            "reg [STB_BIT:0]\t\tf_pending;",
            "reg [(F_LGDEPTH-1):0]\tf_pending_acks;",
            "reg [(F_LGDEPTH-1):0]\tf_pending_reqs;",
            "reg [(F_LGDEPTH-1):0]\tf_expected, f_exp_nreqs, f_exp_nacks;",
            "reg f_past_valid;\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\t// }}}\n\n\tinitial\t`ASSUME(i_reset);\n\talways @(*)\n\t\tif (!f_past_valid)\n\t\t\t`ASSUME(i_reset);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tfwb_slave #(.AW(AW), .DW(DW),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_MAX_STALL(STALL_DELAY+1),\n\t\t\t.F_MAX_ACK_DELAY(ACK_DELAY+1+2*STALL_DELAY),\n\t\t\t.F_MAX_REQUESTS((1<<F_LGDEPTH)-2),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t\t.F_OPT_DISCONTINUOUS(1))\n\t\tf_wbs(i_clk, i_reset,\n\t\t\ti_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr, i_wb_data,\n\t\t\t\ti_wb_sel,\n\t\t\to_wb_ack, o_wb_stall, o_wb_data, o_wb_err,\n\t\t\tf_wb_nreqs, f_wb_nacks, f_wb_outstanding);\n\n\tfwb_master #(.AW(AW), .DW(DW),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_MAX_STALL(STALL_DELAY),\n\t\t\t.F_MAX_ACK_DELAY(ACK_DELAY),\n\t\t\t.F_MAX_REQUESTS(0),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t\t.F_OPT_DISCONTINUOUS(1))\n\t\tf_wbm(i_clk, i_reset,\n\t\t\to_dly_cyc, o_dly_stb, o_dly_we, o_dly_addr, o_dly_data,\n\t\t\t\to_dly_sel,\n\t\t\ti_dly_ack, i_dly_stall, i_dly_data, i_dly_err,\n\t\t\tf_dly_nreqs, f_dly_nacks, f_dly_outstanding);\n\n\t// }}}\n\n\t// WB and DLY request packets\n\t// {{{\n\tassign\tf_wb_request = { i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel };\n\tassign\tf_dly_request={ o_dly_stb,o_dly_we,o_dly_addr,o_dly_data,o_dly_sel };\n\t// }}}\n\n\t// f_pending",
            "reg ister\n\t// {{{\n\tinitial\tf_pending = 0;\n\talways @(posedge i_clk)\n\tif (!DELAY_STALL)\n\t\tf_pending = 0;\n\telse if ((i_reset)||(!i_wb_cyc)||(i_dly_err))\n\t\tf_pending[STB_BIT] <= 1'b0;\n\telse if ((i_wb_stb)&&(!o_wb_stall))\n\tbegin\n\t\tf_pending <= f_wb_request;\n\n\t\tif ((!i_dly_stall)||(!o_dly_stb))\n\t\t\tf_pending[STB_BIT] <= 1'b0;\n\n\tend else if ((!i_dly_stall)&&(f_pending[STB_BIT]))\n\t\tf_pending[STB_BIT] <= 1'b0;\n\t// }}}\n\n\tassign\tf_wb_busy  = (i_wb_stb )&&( o_wb_stall);\n\tassign\tf_dly_busy = (o_dly_stb)&&( i_dly_stall);\n\tassign\tf_wb_req   = (i_wb_stb )&&(!o_wb_stall);\n\tassign\tf_dly_req  = (o_dly_stb)&&(!i_dly_stall);\n\n\talways @(posedge i_clk)\n\tif (!DELAY_STALL)\n\tbegin\n\t\tif ((f_past_valid)&&($past(f_wb_req))&&(!$past(i_reset))\n\t\t\t\t&&(!$past(o_wb_err))&&(!o_wb_err))\n\t\t\tassert(($past(f_wb_request) == f_dly_request));\n\t\tif ((f_past_valid)&&($past(i_reset)))\n\t\t\tassert(!o_dly_stb);\n\t\tif ((f_past_valid)&&(!$past(i_wb_cyc)))\n\t\t\tassert(!o_dly_stb);\n\t\tif ((o_dly_stb)&&(i_dly_stall))\n\t\t\tassert(o_wb_stall);\n\tend else if ((DELAY_STALL)&&(f_past_valid))\n\tbegin\n\t\tif ($past(i_reset))\n\t\t\tassert(!f_pending[STB_BIT]);\n\t\tif (!$past(f_dly_busy))\n\t\t\tassert(!f_pending[STB_BIT]);\n\t\t//\n\t\tif (($past(i_reset))||($past(i_dly_err)))\n\t\tbegin\n\t\t\tassert(!f_pending[STB_BIT]);\n\t\tend else if ($past(f_wb_req))\n\t\tbegin\n\t\t\tif ($past(f_dly_busy))\n\t\t\t\tassert($past(f_wb_request) == f_pending);\n\t\tend else if ((!$past(i_dly_stall))&&($past(f_pending[STB_BIT]))\n\t\t\t\t&&($past(i_wb_cyc)))\n\t\tbegin\n\t\t\tassert(f_dly_request == $past(f_pending));\n\t\tend\n\tend\n\n\t// Constrain the induction solver: whatever's in our f_pending\n\t// hold",
            "reg ister should be identical to whatever is in the f_wpending\n\t//",
            "wire s above.\n\talways @(posedge i_clk)\n\tif ((DELAY_STALL)&&(f_past_valid)&&(!$past(i_reset) && i_wb_cyc && !o_wb_err))\n\tbegin\n\t\tif (!$past(i_wb_cyc))\n\t\tbegin\n\t\t\tassert((!f_pending[STB_BIT])\n\t\t\t\t&&(!f_wpending[STB_BIT]));\n\t\tend else if (($past(f_dly_busy))&&($past(f_wb_busy)))\n\t\tbegin\n\t\t\tassert(f_pending == f_wpending);\n\t\tend else if(($past(f_dly_busy))&&($past(f_pending[STB_BIT])))\n\t\t\tassert(f_pending == f_wpending);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((!DELAY_STALL)&&(f_past_valid)&&(!$past(i_reset))\n\t\t\t&&($past(i_wb_stb))&&(!$past(o_wb_stall))\n\t\t\t&&(!$past(o_wb_err))&&(!o_wb_err))\n\t\tassert(f_dly_request == $past(f_wb_request));\n\n\talways @(posedge i_clk)\n\tif ((DELAY_STALL)&&(!i_reset)&&(!o_wb_err))\n\t\tassert(f_pending[STB_BIT] == f_wpending[STB_BIT]);\n\n\t// Upon any request at the",
            "input , there should always be a request\n\t// on the",
            "output at the very next clock\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_wb_stb))&&(i_wb_cyc))\n\t\tassert((o_dly_stb)||(o_wb_err));\n\t// }}}\n\n\t// Following any dropping of CYC or raising of RESET, STB should\n\t// go down as well\n\t// {{{\n\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(($past(!i_wb_cyc))||($past(i_reset))))\n\t\t\tassert(!o_dly_stb);\n\n\talways @(posedge i_clk)\n\tif ((DELAY_STALL)&&(f_past_valid)\n\t\t\t&&(!$past(i_reset))\n\t\t\t&&($past(i_wb_cyc))\n\t\t\t&&($past(f_pending[STB_BIT])))\n\tbegin\n\t\tif ($past(i_dly_err))\n\t\tbegin\n\t\t\tassert(!o_dly_stb);\n\t\tend else\n\t\t\tassert(o_dly_stb);\n\tend\n\t// }}}\n\n\n\t// Make sure we get no more than one ack per request\n\t// {{{\n\talways @(*)\n\tif (DELAY_STALL)\n\tbegin\n\t\tf_pending_acks <= 0;\n\t\tif ((f_past_valid)\n\t\t\t&&((o_wb_err)||(o_wb_ack))\n\t\t\t&&(o_dly_cyc))\n\t\t\tf_pending_acks <= 1;\n\tend else\n\t\tf_pending_acks <= (((o_wb_ack)||(o_wb_err)) ? 1:0);\n\n\talways @(*)\n\tif (DELAY_STALL)\n\tbegin\n\t\tf_pending_reqs <= ((o_dly_stb) ? 1:0)\n\t\t\t+ ((f_pending[STB_BIT]) ? 1:0);\n\tend else begin\n\t\tf_pending_reqs <= (!f_past_valid) ? 0 :\n\t\t\t((o_dly_stb) ? 1:0);\n\tend\n\n\talways @(*)\n\t\tf_expected <= f_dly_outstanding + f_pending_reqs+f_pending_acks;\n\talways @(*)\n\t\tf_exp_nreqs<= f_dly_nreqs + f_pending_reqs;\n\talways @(*)\n\t\tf_exp_nacks<= f_dly_nacks - f_pending_acks;\n\talways @(*)\n\tif (i_wb_cyc)\n\t\tassert(f_dly_outstanding <= f_wb_outstanding);\n\n\talways @(posedge i_clk)\n\t\tif ((!i_reset)&&(i_wb_cyc)&&(o_dly_cyc)&&(!i_dly_err))\n\t\t\tassert(f_expected == f_wb_outstanding);\n\n\talways @(posedge i_clk)\n\tif ((i_wb_cyc)&&(o_dly_cyc)&&(!i_reset)&&(!i_dly_err))\n\tbegin\n\t\tassert(f_exp_nreqs == f_wb_nreqs);\n\t\tassert(f_exp_nacks == f_wb_nacks);\n\tend\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif (i_wb_cyc && o_dly_stb || (f_wb_outstanding > 0 && f_dly_outstanding > 0))\n\t\tassert(i_wb_we == o_dly_we);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The \"never\" property\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n`ifdef\tBUSDELAY\n\n\t(* anyconst *)",
            "reg f_never;\n\t(* anyconst *)",
            "reg [STB_BIT:0]\tf_nvr_request;\n\n\talways @(*)\n\tif (f_never && i_wb_stb)\n\t\t`ASSUME(f_wb_request != f_nvr_request);\n\n\talways @(*)\n\tif (f_never && f_pending[STB_BIT])\n\t\tassert(f_pending != f_nvr_request);\n\n\talways @(*)\n\tif (f_never && o_dly_stb)\n\t\tassert(f_dly_request != f_nvr_request);\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Low power properties (if invoked)\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_LOWPOWER)\n\tbegin\n\n\t\talways @(*)\n\t\tif (!o_dly_stb)\n\t\tbegin\n\t\t\tassert(o_dly_addr == 0);\n\t\t\tassert(o_dly_data == 0);\n\t\t\tassert(o_dly_sel  == 0);\n\t\tend\n\n\t\talways @(*)\n\t\tif (!o_wb_ack)\n\t\t\tassert(o_wb_data == 0);\n\tend endgenerate\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "fwb_master.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/fwb_master.v",
        "chunks": [
            "module contains no functional",
            "logic .  It is intended for formal\n//\tverification only.  The",
            "output s returned, the number of requests that\n//\thave been made, the number of acknowledgements received, and the number\n//\tof outstanding requests, are designed for further formal verification\n//\tpurposes *only*.\n//\n//\tThis file is different from a companion formal_slave.v file in that the\n//\tassertions are made on the",
            "output s of the wishbone master: o_wb_cyc,\n//\to_wb_stb, o_wb_we, o_wb_addr, o_wb_data, and o_wb_sel, while only\n//\tassumptions are made about the",
            "input s: i_wb_stall, i_wb_ack, i_wb_data,\n//\ti_wb_err.  In the formal_slave.v, assumptions are made about the\n//\tslave",
            "input s (the master",
            "output s), and assertions are made about the\n//\tslave",
            "output s (the master",
            "input s).\n//\n//\tIn order to make it easier to compare the slave against the master,\n//\tassumptions with respect to the slave have been marked with the\n//\t`SLAVE_ASSUME macro.  Similarly, assertions the slave would make have\n//\tbeen marked with `SLAVE_ASSERT.  This allows the master to redefine\n//\tthese two macros to be from his perspective, and therefore the\n//\tdiffs between the two files actually show true differences, rather\n//\tthan just these differences in perspective.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2017-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype none\n// }}}",
            "module fwb_master #(\n\t\t// {{{",
            "parameter AW=32, DW=32,",
            "parameter F_MAX_STALL = 0,\n\t\t\t\t\tF_MAX_ACK_DELAY = 0,",
            "parameter F_LGDEPTH = 4,",
            "parameter [(F_LGDEPTH-1):0] F_MAX_REQUESTS = 0,\n\t\t// OPT_BUS_ABORT: If true, the master can drop CYC at any time\n\t\t// and must drop CYC following any bus error",
            "parameter [0:0]\t\tOPT_BUS_ABORT = 1'b1,\n\t\t//\n\t\t// If true, allow the bus to be kept open when there are no\n\t\t// outstanding requests.  This is useful for any master that\n\t\t// might execute a read modify write cycle, such as an atomic\n\t\t// add.",
            "parameter [0:0]\t\tF_OPT_RMW_BUS_OPTION = 1,\n\t\t//\n\t\t//\n\t\t// If true, allow the bus to issue multiple discontinuous\n\t\t// requests.\n\t\t// Unlike F_OPT_RMW_BUS_OPTION, these requests may be issued\n\t\t// while other requests are outstanding",
            "parameter [0:0]\tF_OPT_DISCONTINUOUS = 1,\n\t\t//\n\t\t//\n\t\t// If true, insist that there be a minimum of a single clock\n\t\t// delay between request and response.  This defaults to off\n\t\t// since the wishbone specification specifically doesn't\n\t\t// require this.  However, some interfaces do, so we allow it\n\t\t// as an option here.",
            "parameter [0:0]\tF_OPT_MINCLOCK_DELAY = 0,\n\t\t//\n\t\t//\n\t\t//",
            "localparam [(F_LGDEPTH-1):0] MAX_OUTSTANDING\n\t\t\t\t\t\t= {(F_LGDEPTH){1'b1}},",
            "localparam MAX_DELAY = (F_MAX_STALL > F_MAX_ACK_DELAY)\n\t\t\t\t? F_MAX_STALL : F_MAX_ACK_DELAY,",
            "localparam DLYBITS= (MAX_DELAY < 4) ? 2\n\t\t\t\t: (MAX_DELAY >= 65536) ? 32\n\t\t\t\t: $clog2(MAX_DELAY+1),\n\t\t//",
            "parameter [0:0]\t\tF_OPT_SHORT_CIRCUIT_PROOF = 0,\n\t\t//\n\t\t// If this is the source of a request, then we can assume STB and CYC\n\t\t// will initially start out high.  Master interfaces following the\n\t\t// source on the way to the slave may not have this property",
            "parameter [0:0]\t\tF_OPT_SOURCE = 0\n\t\t//\n\t\t//\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// The Wishbone bus",
            "input ",
            "wire i_wb_cyc, i_wb_stb, i_wb_we,",
            "input ",
            "wire [(AW-1):0]\ti_wb_addr,",
            "input ",
            "wire [(DW-1):0]\ti_wb_data,",
            "input ",
            "wire [(DW/8-1):0]\ti_wb_sel,\n\t\t//",
            "input ",
            "wire i_wb_ack,",
            "input ",
            "wire i_wb_stall,",
            "input ",
            "wire [(DW-1):0]\ti_wb_idata,",
            "input ",
            "wire i_wb_err,\n\t\t// Some convenience",
            "output ",
            "parameter s",
            "output ",
            "reg [(F_LGDEPTH-1):0]\tf_nreqs, f_nacks,",
            "output ",
            "wire [(F_LGDEPTH-1):0]\tf_outstanding\n\t\t// }}}\n\t);\n\n`define\tSLAVE_ASSUME\tassert\n`define\tSLAVE_ASSERT\tassume\n\t//\n\t// Let's just make sure our",
            "parameter s are set up right\n\t// {{{\n\tinitial\tassert(F_MAX_REQUESTS < {(F_LGDEPTH){1'b1}});\n\t// }}}\n\n\t// f_request\n\t// {{{\n\t// Wrap the request line in a bundle.  The top bit, named STB_BIT,\n\t// is the bit indicating whether the request described by this vector\n\t// is a valid request or not.\n\t//",
            "localparam STB_BIT = 2+AW+DW+DW/8-1;",
            "wire [STB_BIT:0]\tf_request;\n\tassign\tf_request = { i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel };\n\t// }}}\n\n\t// f_past_valid and i_reset\n\t// {{{\n\t// A quick",
            "reg ister to be used later to know if the $past() operator\n\t// will yield valid result",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`SLAVE_ASSUME(i_reset);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions",
            "reg arding the initial (and reset) state\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Assume we start from a reset condition\n\tinitial assert(i_reset);\n\tinitial `SLAVE_ASSUME(!i_wb_cyc);\n\tinitial `SLAVE_ASSUME(!i_wb_stb);\n\t//\n\tinitial\t`SLAVE_ASSERT(!i_wb_ack);\n\tinitial\t`SLAVE_ASSERT(!i_wb_err);\n\n`ifdef\tVERIFIC\n\talways @(*)\n\tif (!f_past_valid)\n\tbegin\n\t\t`SLAVE_ASSUME(!i_wb_cyc);\n\t\t`SLAVE_ASSUME(!i_wb_stb);\n\t\t//\n\t\t`SLAVE_ASSERT(!i_wb_ack);\n\t\t`SLAVE_ASSERT(!i_wb_err);\n\tend\n`endif\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\tbegin\n\t\t`SLAVE_ASSUME(!i_wb_cyc);\n\t\t`SLAVE_ASSUME(!i_wb_stb);\n\t\t//\n\t\t`SLAVE_ASSERT(!i_wb_ack);\n\t\t`SLAVE_ASSERT(!i_wb_err);\n\tend\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`SLAVE_ASSUME(!i_wb_cyc);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus requests\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Following any bus error, the CYC line should be dropped to abort\n\t// the transaction\n\talways @(posedge i_clk)\n\tif (f_past_valid && OPT_BUS_ABORT && $past(i_wb_err)&& $past(i_wb_cyc))\n\t\t`SLAVE_ASSUME(!i_wb_cyc);\n\n\talways @(*)\n\tif (!OPT_BUS_ABORT && !i_reset && (f_nreqs != f_nacks))\n\t\t`SLAVE_ASSUME(i_wb_cyc);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && !OPT_BUS_ABORT\n\t\t\t&& $past(!i_reset && i_wb_stb && i_wb_stall))\n\t\t`SLAVE_ASSUME(i_wb_cyc);\n\n\t// STB can only be true if CYC is also true\n\talways @(*)\n\tif (i_wb_stb)\n\t\t`SLAVE_ASSUME(i_wb_cyc);\n\n\t// If a request was both outstanding and stalled on the last clock,\n\t// then nothing should change on this clock",
            "reg arding it.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_stb))\n\t\t\t&&($past(i_wb_stall))&&(i_wb_cyc))\n\tbegin\n\t\t`SLAVE_ASSUME(i_wb_stb);\n\t\t`SLAVE_ASSUME(i_wb_we   == $past(i_wb_we));\n\t\t`SLAVE_ASSUME(i_wb_addr == $past(i_wb_addr));\n\t\t`SLAVE_ASSUME(i_wb_sel  == $past(i_wb_sel));\n\t\tif (i_wb_we)\n\t\t\t`SLAVE_ASSUME(i_wb_data == $past(i_wb_data));\n\tend\n\n\t// Within any series of STB/requests, the direction of the request\n\t// may not change.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_wb_stb))&&(i_wb_stb))\n\t\t`SLAVE_ASSUME(i_wb_we == $past(i_wb_we));\n\n\n\t// Within any given bus cycle, the direction may *only* change when\n\t// there are no further outstanding requests.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(f_outstanding > 0))\n\t\t`SLAVE_ASSUME(i_wb_we == $past(i_wb_we));\n\n\t// Write requests must also set one (or more) of i_wb_sel\n\t//\n\t// This test has been removed since down-sizers (taking bus from width\n\t// DW to width dw < DW) might actually create empty requests that this\n\t// would prevent.  Re-enabling it would also complicate AXI to WB\n\t// transfers, since AXI explicitly allows WSTRB == 0.  Finally, this\n\t// criteria isn't found in the WB spec--so while it might be a good\n\t// idea to check, in hind sight there are too many exceptions to be\n\t// dogmatic about it.\n\t//\n\t// always @(*)\n\t// if ((i_wb_stb)&&(i_wb_we))\n\t//\t`SLAVE_ASSUME(|i_wb_sel);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus responses\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// If CYC was low on the last clock, then both ACK and ERR should be\n\t// low on this clock.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_wb_cyc))&&(!i_wb_cyc))\n\tbegin\n\t\t`SLAVE_ASSERT(!i_wb_ack);\n\t\t`SLAVE_ASSERT(!i_wb_err);\n\t\t// Stall may still be true--such as when we are not\n\t\t// selected at some arbiter between us and the slave\n\tend\n\n\t//\n\t// Any time the CYC line drops, it is possible that there may be a\n\t// remaining (",
            "reg istered) ACK or ERR that hasn't yet been returned.\n\t// Restrict such out of band returns so that they are *only* returned\n\t// if there is an outstanding operation.\n\t//\n\t// Update: As per spec, WB-classic to WB-pipeline conversions require\n\t// that the ACK|ERR might come back on the same cycle that STB\n\t// is low, yet also be",
            "reg istered.  Hence, if STB & STALL are true on\n\t// one cycle, then CYC is dropped, ACK|ERR might still be true on the\n\t// cycle when CYC is dropped\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_cyc))&&(!i_wb_cyc))\n\tbegin\n\t\t// Note that, unlike f_outstanding, f_nreqs and f_nacks are both\n\t\t//",
            "reg istered.  Hence, we can check here if a response is still\n\t\t// pending.  If not, no response should be returned.\n\t\tif (f_nreqs == f_nacks)\n\t\tbegin\n\t\t\t`SLAVE_ASSERT(!i_wb_ack);\n\t\t\t`SLAVE_ASSERT(!i_wb_err);\n\t\tend\n\tend\n\n\t// ACK and ERR may never both be true at the same time\n\talways @(*)\n\t\t`SLAVE_ASSERT((!i_wb_ack)||(!i_wb_err));\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Stall checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (F_MAX_STALL > 0)\n\tbegin : MXSTALL\n\t\t//\n\t\t// Assume the slave cannnot stall for more than F_MAX_STALL\n\t\t// counts.  We'll count this forward any time STB and STALL\n\t\t// are both true.\n\t\t//",
            "reg [(DLYBITS-1):0]\t\tf_stall_count;\n\n\t\tinitial\tf_stall_count = 0;\n\t\talways @(posedge i_clk)\n\t\tif ((!i_reset)&&(i_wb_stb)&&(i_wb_stall))\n\t\t\tf_stall_count <= f_stall_count + 1'b1;\n\t\telse\n\t\t\tf_stall_count <= 0;\n\n\t\talways @(*)\n\t\tif (i_wb_cyc)\n\t\t\t`SLAVE_ASSERT(f_stall_count < F_MAX_STALL);\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Maximum delay in any response\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (F_MAX_ACK_DELAY > 0)\n\tbegin : MXWAIT\n\t\t//\n\t\t// Assume the slave will respond within F_MAX_ACK_DELAY cycles,\n\t\t// counted either from the end of the last request, or from the\n\t\t// last ACK received\n\t\t//",
            "reg [(DLYBITS-1):0]\t\tf_ackwait_count;\n\n\t\tinitial\tf_ackwait_count = 0;\n\t\talways @(posedge i_clk)\n\t\tif ((!i_reset)&&(i_wb_cyc)&&(!i_wb_stb)\n\t\t\t\t&&(!i_wb_ack)&&(!i_wb_err)\n\t\t\t\t&&(f_outstanding > 0))\n\t\t\tf_ackwait_count <= f_ackwait_count + 1'b1;\n\t\telse\n\t\t\tf_ackwait_count <= 0;\n\n\t\talways @(*)\n\t\tif ((!i_reset)&&(i_wb_cyc)&&(!i_wb_stb)\n\t\t\t\t\t&&(!i_wb_ack)&&(!i_wb_err)\n\t\t\t\t\t&&(f_outstanding > 0))\n\t\t\t`SLAVE_ASSERT(f_ackwait_count < F_MAX_ACK_DELAY);\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Count outstanding requests vs acknowledgments\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Count the number of requests that have been received\n\t//\n\tinitial\tf_nreqs = 0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(!i_wb_cyc))\n\t\tf_nreqs <= 0;\n\telse if ((i_wb_stb)&&(!i_wb_stall))\n\t\tf_nreqs <= f_nreqs + 1'b1;\n\n\n\t//\n\t// Count the number of acknowledgements that have been returned\n\t//\n\tinitial\tf_nacks = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_nacks <= 0;\n\telse if (!i_wb_cyc)\n\t\tf_nacks <= 0;\n\telse if ((i_wb_ack)||(i_wb_err))\n\t\tf_nacks <= f_nacks + 1'b1;\n\n\t//\n\t// The number of outstanding requests is the difference between\n\t// the number of requests and the number of acknowledgements\n\t//\n\tassign\tf_outstanding = (i_wb_cyc) ? (f_nreqs - f_nacks):0;\n\n\talways @(*)\n\tif ((i_wb_cyc)&&(F_MAX_REQUESTS > 0))\n\tbegin\n\t\tif (i_wb_stb)\n\t\tbegin\n\t\t\t`SLAVE_ASSUME(f_nreqs < F_MAX_REQUESTS);\n\t\tend else\n\t\t\t`SLAVE_ASSUME(f_nreqs <= F_MAX_REQUESTS);\n\t\t`SLAVE_ASSERT(f_nacks <= f_nreqs);\n\t\tassert(f_outstanding < MAX_OUTSTANDING);\n\tend else\n\t\tassume(f_outstanding < MAX_OUTSTANDING);\n\n\talways @(*)\n\tif ((i_wb_cyc)&&(f_outstanding == 0))\n\tbegin\n\t\t// If nothing is outstanding, then there should be\n\t\t// no acknowledgements ... however, an acknowledgement\n\t\t// *can* come back on the same clock as the stb is\n\t\t// going out.\n\t\tif (F_OPT_MINCLOCK_DELAY)\n\t\tbegin\n\t\t\t`SLAVE_ASSERT(!i_wb_ack);\n\t\t\t`SLAVE_ASSERT(!i_wb_err);\n\t\tend else begin\n\t\t\t`SLAVE_ASSERT((!i_wb_ack)||((i_wb_stb)&&(!i_wb_stall)));\n\t\t\t// The same is true of errors.  They may not be\n\t\t\t// created before the request gets through\n\t\t\t`SLAVE_ASSERT((!i_wb_err)||((i_wb_stb)&&(!i_wb_stall)));\n\t\tend\n\tend else if (!i_wb_cyc && f_nacks == f_nreqs)\n\tbegin\n\t\t`SLAVE_ASSERT(!i_wb_ack);\n\t\t`SLAVE_ASSERT(!i_wb_err);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus direction\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (!F_OPT_RMW_BUS_OPTION)\n\tbegin\n\t\t// If we aren't waiting for anything, and we aren't issuing\n\t\t// any requests, then then our transaction is over and we\n\t\t// should be dropping the CYC line.\n\t\talways @(*)\n\t\tif (f_outstanding == 0)\n\t\t\t`SLAVE_ASSUME((i_wb_stb)||(!i_wb_cyc));\n\t\t// Not all masters will abide by this restriction.  Some\n\t\t// masters may wish to implement read-modify-write bus\n\t\t// interactions.  These masters need to keep CYC high between\n\t\t// transactions, even though nothing is outstanding.  For\n\t\t// these busses, turn F_OPT_RMW_BUS_OPTION on.\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Discontinuous request checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if ((!F_OPT_DISCONTINUOUS)&&(!F_OPT_RMW_BUS_OPTION))\n\tbegin : INSIST_ON_NO_DISCONTINUOUS_STBS\n\t\t// Within my own code, once a request begins it goes to\n\t\t// completion and the CYC line is dropped.  The master\n\t\t// is not allowed to raise STB again after dropping it.\n\t\t// Doing so would be a *discontinuous* request.\n\t\t//\n\t\t// However, in any RMW scheme, discontinuous requests are\n\t\t// necessary, and the spec doesn't disallow them.  Hence we\n\t\t// make this check optional.\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&($past(i_wb_cyc))&&(!$past(i_wb_stb)))\n\t\t\t`SLAVE_ASSUME(!i_wb_stb);\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Master only checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (F_OPT_SHORT_CIRCUIT_PROOF)\n\tbegin\n\t\t// In many ways, we don't care what happens on the bus return\n\t\t// lines if the cycle line is low, so restricting them to a\n\t\t// known value makes a lot of sense.\n\t\t//\n\t\t// On the other hand, if something above *does* depend upon\n\t\t// these values (when it shouldn't), then we might want to know\n\t\t// about it.\n\t\t//\n\t\t//\n\t\talways @(posedge i_clk)\n\t\tbegin\n\t\t\tif (!i_wb_cyc)\n\t\t\tbegin\n\t\t\t\tassume(!i_wb_stall);\n\t\t\t\tassume($stable(i_wb_idata));\n\t\t\tend else if ((!$past(i_wb_ack))&&(!i_wb_ack))\n\t\t\t\tassume($stable(i_wb_idata));\n\t\tend\n\tend endgenerate\n\n\tgenerate if (F_OPT_SOURCE)\n\tbegin : SRC\n\t\t// Any opening bus request starts with both CYC and STB high\n\t\t// This is true for the master only, and more specifically\n\t\t// only for those masters that are the initial source of any\n\t\t// transaction.  By the time an interaction gets to the slave,\n\t\t// the CYC line may go high or low without actually affecting\n\t\t// the STB line of the slave.\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(!$past(i_wb_cyc))&&(i_wb_cyc))\n\t\t\t`SLAVE_ASSUME(i_wb_stb);\n\tend endgenerate\n\t// }}}\n\n\t// Keep Verilator happy\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, f_request };\n\t// Verilator lint_on  UNUSED\n\t// }}}",
            "endmodule `undef\tSLAVE_ASSUME\n`undef\tSLAVE_ASSERT"
        ]
    },
    {
        "file_name": "fwb_slave.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/fwb_slave.v",
        "chunks": [
            "module contains no functional",
            "logic .  It is intended for formal\n//\tverification only.  The",
            "output s returned, the number of requests that\n//\thave been made, the number of acknowledgements received, and the number\n//\tof outstanding requests, are designed for further formal verification\n//\tpurposes *only*.\n//\n//\tThis file is different from a companion formal_master.v file in that\n//\tassumptions are made about the",
            "input s to the slave: i_wb_cyc,\n//\ti_wb_stb, i_wb_we, i_wb_addr, i_wb_data, and i_wb_sel, while full\n//\tassertions are made about the",
            "output s: o_wb_stall, o_wb_ack, o_wb_data,\n//\to_wb_err.  In the formal_master.v, assertions are made about the\n//\tmaster",
            "output s (slave",
            "input s)), and assumptions are made about the\n//\tmaster",
            "input s (the slave",
            "output s).\n//\n//\tIn order to make it easier to compare the slave against the master,\n//\tassumptions with respect to the slave have been marked with the\n//\t`SLAVE_ASSUME macro.  Similarly, assertions the slave would make have\n//\tbeen marked with `SLAVE_ASSERT.  This allows the master to redefine\n//\tthese two macros to be from his perspective, and therefore the\n//\tdiffs between the two files actually show true differences, rather\n//\tthan just these differences in perspective.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2017-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype none\n// }}}",
            "module fwb_slave #(\n\t\t// {{{",
            "parameter AW=32, DW=32,",
            "parameter F_MAX_STALL = 0,\n\t\t\t\t\tF_MAX_ACK_DELAY = 0,",
            "parameter F_LGDEPTH = 4,",
            "parameter [(F_LGDEPTH-1):0] F_MAX_REQUESTS = 0,\n\t\t// OPT_BUS_ABORT: If true, the master can drop CYC at any time\n\t\t// and must drop CYC following any bus error",
            "parameter [0:0]\t\tOPT_BUS_ABORT = 1'b1,\n\t\t//\n\t\t// If true, allow the bus to be kept open when there are no\n\t\t// outstanding requests.  This is useful for any master that\n\t\t// might execute a read modify write cycle, such as an atomic\n\t\t// add.",
            "parameter [0:0]\t\tF_OPT_RMW_BUS_OPTION = 1,\n\t\t//\n\t\t//\n\t\t// If true, allow the bus to issue multiple discontinuous\n\t\t// requests.\n\t\t// Unlike F_OPT_RMW_BUS_OPTION, these requests may be issued\n\t\t// while other requests are outstanding",
            "parameter [0:0]\tF_OPT_DISCONTINUOUS = 1,\n\t\t//\n\t\t//\n\t\t// If true, insist that there be a minimum of a single clock\n\t\t// delay between request and response.  This defaults to off\n\t\t// since the wishbone specification specifically doesn't\n\t\t// require this.  However, some interfaces do, so we allow it\n\t\t// as an option here.",
            "parameter [0:0]\tF_OPT_MINCLOCK_DELAY = 0,\n\t\t//\n\t\t//\n\t\t//",
            "localparam [(F_LGDEPTH-1):0] MAX_OUTSTANDING\n\t\t\t\t\t\t= {(F_LGDEPTH){1'b1}},",
            "localparam MAX_DELAY = (F_MAX_STALL > F_MAX_ACK_DELAY)\n\t\t\t\t? F_MAX_STALL : F_MAX_ACK_DELAY,",
            "localparam DLYBITS= (MAX_DELAY < 4) ? 2\n\t\t\t\t: (MAX_DELAY >= 65536) ? 32\n\t\t\t\t: $clog2(MAX_DELAY+1)\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// The Wishbone bus",
            "input ",
            "wire i_wb_cyc, i_wb_stb, i_wb_we,",
            "input ",
            "wire [(AW-1):0]\ti_wb_addr,",
            "input ",
            "wire [(DW-1):0]\ti_wb_data,",
            "input ",
            "wire [(DW/8-1):0]\ti_wb_sel,\n\t\t//",
            "input ",
            "wire i_wb_ack,",
            "input ",
            "wire i_wb_stall,",
            "input ",
            "wire [(DW-1):0]\ti_wb_idata,",
            "input ",
            "wire i_wb_err,\n\t\t// Some convenience",
            "output ",
            "parameter s",
            "output ",
            "reg [(F_LGDEPTH-1):0]\tf_nreqs, f_nacks,",
            "output ",
            "wire [(F_LGDEPTH-1):0]\tf_outstanding\n\t\t// }}}\n\t);\n\n`define\tSLAVE_ASSUME\tassume\n`define\tSLAVE_ASSERT\tassert\n\t//\n\t// Let's just make sure our",
            "parameter s are set up right\n\t// {{{\n\tinitial\tassert(F_MAX_REQUESTS < {(F_LGDEPTH){1'b1}});\n\t// }}}\n\n\t// f_request\n\t// {{{\n\t// Wrap the request line in a bundle.  The top bit, named STB_BIT,\n\t// is the bit indicating whether the request described by this vector\n\t// is a valid request or not.\n\t//",
            "localparam STB_BIT = 2+AW+DW+DW/8-1;",
            "wire [STB_BIT:0]\tf_request;\n\tassign\tf_request = { i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel };\n\t// }}}\n\n\t// f_past_valid and i_reset\n\t// {{{\n\t// A quick",
            "reg ister to be used later to know if the $past() operator\n\t// will yield valid result",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`SLAVE_ASSUME(i_reset);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions",
            "reg arding the initial (and reset) state\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Assume we start from a reset condition\n\tinitial assert(i_reset);\n\tinitial `SLAVE_ASSUME(!i_wb_cyc);\n\tinitial `SLAVE_ASSUME(!i_wb_stb);\n\t//\n\tinitial\t`SLAVE_ASSERT(!i_wb_ack);\n\tinitial\t`SLAVE_ASSERT(!i_wb_err);\n\n`ifdef\tVERIFIC\n\talways @(*)\n\tif (!f_past_valid)\n\tbegin\n\t\t`SLAVE_ASSUME(!i_wb_cyc);\n\t\t`SLAVE_ASSUME(!i_wb_stb);\n\t\t//\n\t\t`SLAVE_ASSERT(!i_wb_ack);\n\t\t`SLAVE_ASSERT(!i_wb_err);\n\tend\n`endif\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\tbegin\n\t\t`SLAVE_ASSUME(!i_wb_cyc);\n\t\t`SLAVE_ASSUME(!i_wb_stb);\n\t\t//\n\t\t`SLAVE_ASSERT(!i_wb_ack);\n\t\t`SLAVE_ASSERT(!i_wb_err);\n\tend\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`SLAVE_ASSUME(!i_wb_cyc);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus requests\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Following any bus error, the CYC line should be dropped to abort\n\t// the transaction\n\talways @(posedge i_clk)\n\tif (f_past_valid && OPT_BUS_ABORT && $past(i_wb_err)&& $past(i_wb_cyc))\n\t\t`SLAVE_ASSUME(!i_wb_cyc);\n\n\talways @(*)\n\tif (!OPT_BUS_ABORT && !i_reset && (f_nreqs != f_nacks))\n\t\t`SLAVE_ASSUME(i_wb_cyc);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && !OPT_BUS_ABORT\n\t\t\t&& $past(!i_reset && i_wb_stb && i_wb_stall))\n\t\t`SLAVE_ASSUME(i_wb_cyc);\n\n\t// STB can only be true if CYC is also true\n\talways @(*)\n\tif (i_wb_stb)\n\t\t`SLAVE_ASSUME(i_wb_cyc);\n\n\t// If a request was both outstanding and stalled on the last clock,\n\t// then nothing should change on this clock",
            "reg arding it.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_stb))\n\t\t\t&&($past(i_wb_stall))&&(i_wb_cyc))\n\tbegin\n\t\t`SLAVE_ASSUME(i_wb_stb);\n\t\t`SLAVE_ASSUME(i_wb_we   == $past(i_wb_we));\n\t\t`SLAVE_ASSUME(i_wb_addr == $past(i_wb_addr));\n\t\t`SLAVE_ASSUME(i_wb_sel  == $past(i_wb_sel));\n\t\tif (i_wb_we)\n\t\t\t`SLAVE_ASSUME(i_wb_data == $past(i_wb_data));\n\tend\n\n\t// Within any series of STB/requests, the direction of the request\n\t// may not change.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_wb_stb))&&(i_wb_stb))\n\t\t`SLAVE_ASSUME(i_wb_we == $past(i_wb_we));\n\n\n\t// Within any given bus cycle, the direction may *only* change when\n\t// there are no further outstanding requests.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(f_outstanding > 0))\n\t\t`SLAVE_ASSUME(i_wb_we == $past(i_wb_we));\n\n\t// Write requests must also set one (or more) of i_wb_sel\n\t//\n\t// This test has been removed since down-sizers (taking bus from width\n\t// DW to width dw < DW) might actually create empty requests that this\n\t// would prevent.  Re-enabling it would also complicate AXI to WB\n\t// transfers, since AXI explicitly allows WSTRB == 0.  Finally, this\n\t// criteria isn't found in the WB spec--so while it might be a good\n\t// idea to check, in hind sight there are too many exceptions to be\n\t// dogmatic about it.\n\t//\n\t// always @(*)\n\t// if ((i_wb_stb)&&(i_wb_we))\n\t//\t`SLAVE_ASSUME(|i_wb_sel);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus responses\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// If CYC was low on the last clock, then both ACK and ERR should be\n\t// low on this clock.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_wb_cyc))&&(!i_wb_cyc))\n\tbegin\n\t\t`SLAVE_ASSERT(!i_wb_ack);\n\t\t`SLAVE_ASSERT(!i_wb_err);\n\t\t// Stall may still be true--such as when we are not\n\t\t// selected at some arbiter between us and the slave\n\tend\n\n\t//\n\t// Any time the CYC line drops, it is possible that there may be a\n\t// remaining (",
            "reg istered) ACK or ERR that hasn't yet been returned.\n\t// Restrict such out of band returns so that they are *only* returned\n\t// if there is an outstanding operation.\n\t//\n\t// Update: As per spec, WB-classic to WB-pipeline conversions require\n\t// that the ACK|ERR might come back on the same cycle that STB\n\t// is low, yet also be",
            "reg istered.  Hence, if STB & STALL are true on\n\t// one cycle, then CYC is dropped, ACK|ERR might still be true on the\n\t// cycle when CYC is dropped\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_cyc))&&(!i_wb_cyc))\n\tbegin\n\t\t// Note that, unlike f_outstanding, f_nreqs and f_nacks are both\n\t\t//",
            "reg istered.  Hence, we can check here if a response is still\n\t\t// pending.  If not, no response should be returned.\n\t\tif (f_nreqs == f_nacks)\n\t\tbegin\n\t\t\t`SLAVE_ASSERT(!i_wb_ack);\n\t\t\t`SLAVE_ASSERT(!i_wb_err);\n\t\tend\n\tend\n\n\t// ACK and ERR may never both be true at the same time\n\talways @(*)\n\t\t`SLAVE_ASSERT((!i_wb_ack)||(!i_wb_err));\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Stall checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (F_MAX_STALL > 0)\n\tbegin : MXSTALL\n\t\t//\n\t\t// Assume the slave cannnot stall for more than F_MAX_STALL\n\t\t// counts.  We'll count this forward any time STB and STALL\n\t\t// are both true.\n\t\t//",
            "reg [(DLYBITS-1):0]\t\tf_stall_count;\n\n\t\tinitial\tf_stall_count = 0;\n\t\talways @(posedge i_clk)\n\t\tif ((!i_reset)&&(i_wb_stb)&&(i_wb_stall))\n\t\t\tf_stall_count <= f_stall_count + 1'b1;\n\t\telse\n\t\t\tf_stall_count <= 0;\n\n\t\talways @(*)\n\t\tif (i_wb_cyc)\n\t\t\t`SLAVE_ASSERT(f_stall_count < F_MAX_STALL);\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Maximum delay in any response\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (F_MAX_ACK_DELAY > 0)\n\tbegin : MXWAIT\n\t\t//\n\t\t// Assume the slave will respond within F_MAX_ACK_DELAY cycles,\n\t\t// counted either from the end of the last request, or from the\n\t\t// last ACK received\n\t\t//",
            "reg [(DLYBITS-1):0]\t\tf_ackwait_count;\n\n\t\tinitial\tf_ackwait_count = 0;\n\t\talways @(posedge i_clk)\n\t\tif ((!i_reset)&&(i_wb_cyc)&&(!i_wb_stb)\n\t\t\t\t&&(!i_wb_ack)&&(!i_wb_err)\n\t\t\t\t&&(f_outstanding > 0))\n\t\t\tf_ackwait_count <= f_ackwait_count + 1'b1;\n\t\telse\n\t\t\tf_ackwait_count <= 0;\n\n\t\talways @(*)\n\t\tif ((!i_reset)&&(i_wb_cyc)&&(!i_wb_stb)\n\t\t\t\t\t&&(!i_wb_ack)&&(!i_wb_err)\n\t\t\t\t\t&&(f_outstanding > 0))\n\t\t\t`SLAVE_ASSERT(f_ackwait_count < F_MAX_ACK_DELAY);\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Count outstanding requests vs acknowledgments\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Count the number of requests that have been received\n\t//\n\tinitial\tf_nreqs = 0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(!i_wb_cyc))\n\t\tf_nreqs <= 0;\n\telse if ((i_wb_stb)&&(!i_wb_stall))\n\t\tf_nreqs <= f_nreqs + 1'b1;\n\n\n\t//\n\t// Count the number of acknowledgements that have been returned\n\t//\n\tinitial\tf_nacks = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_nacks <= 0;\n\telse if (!i_wb_cyc)\n\t\tf_nacks <= 0;\n\telse if ((i_wb_ack)||(i_wb_err))\n\t\tf_nacks <= f_nacks + 1'b1;\n\n\t//\n\t// The number of outstanding requests is the difference between\n\t// the number of requests and the number of acknowledgements\n\t//\n\tassign\tf_outstanding = (i_wb_cyc) ? (f_nreqs - f_nacks):0;\n\n\talways @(*)\n\tif ((i_wb_cyc)&&(F_MAX_REQUESTS > 0))\n\tbegin\n\t\tif (i_wb_stb)\n\t\tbegin\n\t\t\t`SLAVE_ASSUME(f_nreqs < F_MAX_REQUESTS);\n\t\tend else\n\t\t\t`SLAVE_ASSUME(f_nreqs <= F_MAX_REQUESTS);\n\t\t`SLAVE_ASSERT(f_nacks <= f_nreqs);\n\t\tassert(f_outstanding < (1<<F_LGDEPTH)-1);\n\tend else\n\t\tassume(f_outstanding < (1<<F_LGDEPTH)-1);\n\n\talways @(*)\n\tif ((i_wb_cyc)&&(f_outstanding == 0))\n\tbegin\n\t\t// If nothing is outstanding, then there should be\n\t\t// no acknowledgements ... however, an acknowledgement\n\t\t// *can* come back on the same clock as the stb is\n\t\t// going out.\n\t\tif (F_OPT_MINCLOCK_DELAY)\n\t\tbegin\n\t\t\t`SLAVE_ASSERT(!i_wb_ack);\n\t\t\t`SLAVE_ASSERT(!i_wb_err);\n\t\tend else begin\n\t\t\t`SLAVE_ASSERT((!i_wb_ack)||((i_wb_stb)&&(!i_wb_stall)));\n\t\t\t// The same is true of errors.  They may not be\n\t\t\t// created before the request gets through\n\t\t\t`SLAVE_ASSERT((!i_wb_err)||((i_wb_stb)&&(!i_wb_stall)));\n\t\tend\n\tend else if (!i_wb_cyc && f_nacks == f_nreqs)\n\tbegin\n\t\t`SLAVE_ASSERT(!i_wb_ack);\n\t\t`SLAVE_ASSERT(!i_wb_err);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus direction\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (!F_OPT_RMW_BUS_OPTION)\n\tbegin\n\t\t// If we aren't waiting for anything, and we aren't issuing\n\t\t// any requests, then then our transaction is over and we\n\t\t// should be dropping the CYC line.\n\t\talways @(*)\n\t\tif (f_outstanding == 0)\n\t\t\t`SLAVE_ASSUME((i_wb_stb)||(!i_wb_cyc));\n\t\t// Not all masters will abide by this restriction.  Some\n\t\t// masters may wish to implement read-modify-write bus\n\t\t// interactions.  These masters need to keep CYC high between\n\t\t// transactions, even though nothing is outstanding.  For\n\t\t// these busses, turn F_OPT_RMW_BUS_OPTION on.\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Discontinuous request checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if ((!F_OPT_DISCONTINUOUS)&&(!F_OPT_RMW_BUS_OPTION))\n\tbegin : INSIST_ON_NO_DISCONTINUOUS_STBS\n\t\t// Within my own code, once a request begins it goes to\n\t\t// completion and the CYC line is dropped.  The master\n\t\t// is not allowed to raise STB again after dropping it.\n\t\t// Doing so would be a *discontinuous* request.\n\t\t//\n\t\t// However, in any RMW scheme, discontinuous requests are\n\t\t// necessary, and the spec doesn't disallow them.  Hence we\n\t\t// make this check optional.\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&($past(i_wb_cyc))&&(!$past(i_wb_stb)))\n\t\t\t`SLAVE_ASSUME(!i_wb_stb);\n\tend endgenerate\n\t// }}}",
            "endmodule `undef\tSLAVE_ASSUME\n`undef\tSLAVE_ASSERT"
        ]
    },
    {
        "file_name": "skidbuffer.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/skidbuffer.v",
        "chunks": [
            "output s be",
            "reg istered.  This means\n//\tthat, if there are any stall conditions calculated, it will take a clock\n//\tcycle before the stall can be propagated up stream.  This means that\n//\tthe data will need to be buffered for a cycle until the stall signal\n//\tcan make it to the",
            "output .\n//\n//\tHandling that buffer is the purpose of this core.\n//\n//\tOn one end of this core, you have the i_valid and i_data",
            "input s to\n//\tconnect to your bus interface.  There's also a",
            "reg istered o_ready\n//\tsignal to signal stalls for the bus interface.\n//\n//\tThe other end of the core has the same basic interface, but it isn't\n//",
            "reg istered.  This allows you to interact with the bus interfaces\n//\tas though they were combinatorial",
            "logic , by interacting with this half\n//\tof the core.\n//\n//\tIf at any time the incoming !stall signal, i_ready, signals a stall,\n//\tthe incoming data is placed into a buffer.  Internally, that buffer\n//\tis held in r_data with the r_valid flag used to indicate that valid\n//\tdata is within it.\n// }}}\n// Parameters:\n// {{{\n//\tDW or data width\n//\t\tIn order to make this core generic, the width of the data in the\n//\t\tskid buffer is",
            "parameter ized\n//\n//\tOPT_LOWPOWER\n//\t\tForces both o_data and r_data to zero if the respective *VALID\n//\t\tsignal is also low.  While this costs extra",
            "logic , it can also\n//\t\tbe used to guarantee that any unused values aren't toggling and\n//\t\ttherefore unnecessarily using power.\n//\n//\t\tThis excess toggling can be particularly problematic if the\n//\t\tbus signals have a high fanout rate, or a long signal path\n//\t\tacross an FPGA.\n//\n//\tOPT_OUTREG\n//\t\tCauses the",
            "output s to be",
            "reg istered\n//\n//\tOPT_PASSTHROUGH\n//\t\tTurns the skid buffer into a passthrough.  Used for formal\n//\t\tverification only.\n// }}}\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2019-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype none\n// }}}",
            "module skidbuffer #(\n\t\t// {{{",
            "parameter [0:0]\tOPT_LOWPOWER = 0,",
            "parameter [0:0]\tOPT_OUTREG = 1,\n\t\t//",
            "parameter [0:0]\tOPT_PASSTHROUGH = 0,",
            "parameter DW = 8,",
            "parameter [0:0]\tOPT_INITIAL = 1'b1\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,",
            "input ",
            "wire i_valid,",
            "output ",
            "wire o_ready,",
            "input ",
            "wire [DW-1:0]\ti_data,",
            "output ",
            "wire o_valid,",
            "input ",
            "wire i_ready,",
            "output ",
            "reg [DW-1:0]\to_data\n\t\t// }}}\n\t);",
            "wire [DW-1:0]\tw_data;\n\n\tgenerate if (OPT_PASSTHROUGH)\n\tbegin : PASSTHROUGH\n\t\t// {{{\n\t\tassign\t{ o_valid, o_ready } = { i_valid, i_ready };\n\n\t\talways @(*)\n\t\tif (!i_valid && OPT_LOWPOWER)\n\t\t\to_data = 0;\n\t\telse\n\t\t\to_data = i_data;\n\n\t\tassign\tw_data = 0;\n\n\t\t// Keep Verilator happy\n\t\t// Verilator lint_off UNUSED\n\t\t// {{{",
            "wire unused_passthrough;\n\t\tassign\tunused_passthrough = &{ 1'b0, i_clk, i_reset };\n\t\t// }}}\n\t\t// Verilator lint_on  UNUSED\n\t\t// }}}\n\tend else begin : LOGIC\n\t\t// We'll start with skid buffer itself\n\t\t// {{{",
            "reg r_valid;",
            "reg [DW-1:0]\tr_data;\n\n\t\t// r_valid\n\t\t// {{{\n\t\tinitial if (OPT_INITIAL) r_valid = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_valid <= 0;\n\t\telse if ((i_valid && o_ready) && (o_valid && !i_ready))\n\t\t\t// We have incoming data, but the",
            "output is stalled\n\t\t\tr_valid <= 1;\n\t\telse if (i_ready)\n\t\t\tr_valid <= 0;\n\t\t// }}}\n\n\t\t// r_data\n\t\t// {{{\n\t\tinitial if (OPT_INITIAL) r_data = 0;\n\t\talways @(posedge i_clk)\n\t\tif (OPT_LOWPOWER && i_reset)\n\t\t\tr_data <= 0;\n\t\telse if (OPT_LOWPOWER && (!o_valid || i_ready))\n\t\t\tr_data <= 0;\n\t\telse if ((!OPT_LOWPOWER || !OPT_OUTREG || i_valid) && o_ready)\n\t\t\tr_data <= i_data;\n\n\t\tassign\tw_data = r_data;\n\t\t// }}}\n\n\t\t// o_ready\n\t\t// {{{\n\t\tassign o_ready = !r_valid;\n\t\t// }}}\n\n\t\t//\n\t\t// And then move on to the",
            "output port\n\t\t//\n\t\tif (!OPT_OUTREG)\n\t\tbegin : NET_OUTPUT\n\t\t\t// Outputs are combinatorially determined from",
            "input s\n\t\t\t// {{{\n\t\t\t// o_valid\n\t\t\t// {{{\n\t\t\tassign\to_valid = !i_reset && (i_valid || r_valid);\n\t\t\t// }}}\n\n\t\t\t// o_data\n\t\t\t// {{{\n\t\t\talways @(*)\n\t\t\tif (r_valid)\n\t\t\t\to_data = r_data;\n\t\t\telse if (!OPT_LOWPOWER || i_valid)\n\t\t\t\to_data = i_data;\n\t\t\telse\n\t\t\t\to_data = 0;\n\t\t\t// }}}\n\t\t\t// }}}\n\t\tend else begin : REG_OUTPUT\n\t\t\t// Register our",
            "output s\n\t\t\t// {{{\n\t\t\t// o_valid\n\t\t\t// {{{",
            "reg ro_valid;\n\n\t\t\tinitial if (OPT_INITIAL) ro_valid = 0;\n\t\t\talways @(posedge i_clk)\n\t\t\tif (i_reset)\n\t\t\t\tro_valid <= 0;\n\t\t\telse if (!o_valid || i_ready)\n\t\t\t\tro_valid <= (i_valid || r_valid);\n\n\t\t\tassign\to_valid = ro_valid;\n\t\t\t// }}}\n\n\t\t\t// o_data\n\t\t\t// {{{\n\t\t\tinitial if (OPT_INITIAL) o_data = 0;\n\t\t\talways @(posedge i_clk)\n\t\t\tif (OPT_LOWPOWER && i_reset)\n\t\t\t\to_data <= 0;\n\t\t\telse if (!o_valid || i_ready)\n\t\t\tbegin\n\n\t\t\t\tif (r_valid)\n\t\t\t\t\to_data <= r_data;\n\t\t\t\telse if (!OPT_LOWPOWER || i_valid)\n\t\t\t\t\to_data <= i_data;\n\t\t\t\telse\n\t\t\t\t\to_data <= 0;\n\t\t\tend\n\t\t\t// }}}\n\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\t// Keep Verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, w_data };\n\t// Verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n`ifdef\tSKIDBUFFER\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "reg f_past_valid;\n\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Incoming stream properties / assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\talways @(posedge i_clk)\n\tif (!f_past_valid)\n\tbegin\n\t\t`ASSUME(!i_valid || !OPT_INITIAL);\n\tend else if ($past(i_valid && !o_ready && !i_reset) && !i_reset)\n\t\t`ASSUME(i_valid && $stable(i_data));\n\n`ifdef\tVERIFIC\n`define\tFORMAL_VERIFIC\n\t// Reset properties\n\tproperty RESET_CLEARS_IVALID;\n\t\t@(posedge i_clk) i_reset |=> !i_valid;\n\tendproperty\n\n\tproperty IDATA_HELD_WHEN_NOT_READY;\n\t\t@(posedge i_clk) disable iff (i_reset)\n\t\ti_valid && !o_ready |=> i_valid && $stable(i_data);\n\tendproperty\n\n`ifdef\tSKIDBUFFER\n\tassume\tproperty (IDATA_HELD_WHEN_NOT_READY);\n`else\n\tassert\tproperty (IDATA_HELD_WHEN_NOT_READY);\n`endif\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Outgoing stream properties / assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\n\tgenerate if (!OPT_PASSTHROUGH)\n\tbegin\n\n\t\talways @(posedge i_clk)\n\t\tif (!f_past_valid) // || $past(i_reset))\n\t\tbegin\n\t\t\t// Following any reset, valid must be deasserted\n\t\t\tassert(!o_valid || !OPT_INITIAL);\n\t\tend else if ($past(o_valid && !i_ready && !i_reset) && !i_reset)\n\t\t\t// Following any stall, valid must remain high and\n\t\t\t// data must be preserved\n\t\t\tassert(o_valid && $stable(o_data));\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Other properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (!OPT_PASSTHROUGH)\n\tbegin\n\t\t// Rule #1:\n\t\t//\tIf",
            "reg istered, then following any reset we should be\n\t\t//\tready for a new request\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && $past(OPT_OUTREG && i_reset))\n\t\t\tassert(o_ready);\n\t\t// }}}\n\n\t\t// Rule #2:\n\t\t//\tAll incoming data must either go directly to the\n\t\t//",
            "output port, or into the skid buffer\n\t\t// {{{\n`ifndef\tVERIFIC\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && !$past(i_reset) && $past(i_valid && o_ready\n\t\t\t&& (!OPT_OUTREG || o_valid) && !i_ready))\n\t\t\tassert(!o_ready && w_data == $past(i_data));\n`else\n\t\tassert property (@(posedge i_clk)\n\t\t\tdisable iff (i_reset)\n\t\t\t(i_valid && o_ready\n\t\t\t\t&& (!OPT_OUTREG || o_valid) && !i_ready)\n\t\t\t\t|=> (!o_ready && w_data == $past(i_data)));\n`endif\n\t\t// }}}\n\n\t\t// Rule #3:\n\t\t//\tAfter the last transaction, o_valid should become idle\n\t\t// {{{\n\t\tif (!OPT_OUTREG)\n\t\tbegin\n\t\t\t// {{{\n\t\t\talways @(posedge i_clk)\n\t\t\tif (f_past_valid && !$past(i_reset) && !i_reset\n\t\t\t\t\t&& $past(i_ready))\n\t\t\tbegin\n\t\t\t\tassert(o_valid == i_valid);\n\t\t\t\tassert(!i_valid || (o_data == i_data));\n\t\t\tend\n\t\t\t// }}}\n\t\tend else begin\n\t\t\t// {{{\n\t\t\talways @(posedge i_clk)\n\t\t\tif (f_past_valid && !$past(i_reset))\n\t\t\tbegin\n\t\t\t\tif ($past(i_valid && o_ready))\n\t\t\t\t\tassert(o_valid);\n\n\t\t\t\tif ($past(!i_valid && o_ready && i_ready))\n\t\t\t\t\tassert(!o_valid);\n\t\t\tend\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\n\t\t// Rule #4\n\t\t//\tSame thing, but this time for o_ready\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && $past(!o_ready && i_ready))\n\t\t\tassert(o_ready);\n\t\t// }}}\n\n\t\t// If OPT_LOWPOWER is set, o_data and w_data both need to be\n\t\t// zero any time !o_valid or !r_valid respectively\n\t\t// {{{\n\t\tif (OPT_LOWPOWER)\n\t\tbegin\n\t\t\talways @(*)\n\t\t\tif ((OPT_OUTREG || !i_reset) && !o_valid)\n\t\t\t\tassert(o_data == 0);\n\n\t\t\talways @(*)\n\t\t\tif (o_ready)\n\t\t\t\tassert(w_data == 0);\n\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n`ifdef\tSKIDBUFFER\n\tgenerate if (!OPT_PASSTHROUGH)\n\tbegin",
            "reg f_changed_data;\n\n\t\tinitial\tf_changed_data = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tf_changed_data <= 1;\n\t\telse if (i_valid && $past(!i_valid || o_ready))\n\t\tbegin\n\t\t\tif (i_data != $past(i_data + 1))\n\t\t\t\tf_changed_data <= 0;\n\t\tend else if (!i_valid && i_data != 0)\n\t\t\tf_changed_data <= 0;\n\n\n`ifndef\tVERIFIC",
            "reg [3:0]\tcvr_steps, cvr_hold;\n\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\tbegin\n\t\t\tcvr_steps <= 0;\n\t\t\tcvr_hold  <= 0;\n\t\tend else begin\n\t\t\tcvr_steps <= cvr_steps + 1;\n\t\t\tcvr_hold  <= cvr_hold  + 1;\n\t\t\tcase(cvr_steps)\n\t\t\t 0: if (o_valid || i_valid)\n\t\t\t\tcvr_steps <= 0;\n\t\t\t 1: if (!i_valid || !i_ready)\n\t\t\t\tcvr_steps <= 0;\n\t\t\t 2: if (!i_valid || !i_ready)\n\t\t\t\tcvr_steps <= 0;\n\t\t\t 3: if (!i_valid || !i_ready)\n\t\t\t\tcvr_steps <= 0;\n\t\t\t 4: if (!i_valid ||  i_ready)\n\t\t\t\tcvr_steps <= 0;\n\t\t\t 5: if (!i_valid || !i_ready)\n\t\t\t\tcvr_steps <= 0;\n\t\t\t 6: if (!i_valid || !i_ready)\n\t\t\t\tcvr_steps <= 0;\n\t\t\t 7: if (!i_valid ||  i_ready)\n\t\t\t\tcvr_steps <= 0;\n\t\t\t 8: if (!i_valid ||  i_ready)\n\t\t\t\tcvr_steps <= 0;\n\t\t\t 9: if (!i_valid || !i_ready)\n\t\t\t\tcvr_steps <= 0;\n\t\t\t10: if (!i_valid || !i_ready)\n\t\t\t\tcvr_steps <= 0;\n\t\t\t11: if (!i_valid || !i_ready)\n\t\t\t\tcvr_steps <= 0;\n\t\t\t12: begin\n\t\t\t\tcvr_steps <= cvr_steps;\n\t\t\t\tcover(!o_valid && !i_valid && f_changed_data);\n\t\t\t\tif (!o_valid || !i_ready)\n\t\t\t\t\tcvr_steps <= 0;\n\t\t\t\telse\n\t\t\t\t\tcvr_hold <= cvr_hold + 1;\n\t\t\t\tend\n\t\t\tdefault: assert(0);\n\t\t\tendcase\n\t\tend\n\n`else\n\t\t// Cover test\n\t\tcover property (@(posedge i_clk)\n\t\t\tdisable iff (i_reset)\n\t\t\t(!o_valid && !i_valid)\n\t\t\t##1 i_valid &&  i_ready [*3]\n\t\t\t##1 i_valid && !i_ready\n\t\t\t##1 i_valid &&  i_ready [*2]\n\t\t\t##1 i_valid && !i_ready [*2]\n\t\t\t##1 i_valid &&  i_ready [*3]\n\t\t\t// Wait for the design to clear\n\t\t\t##1 o_valid && i_ready [*0:5]\n\t\t\t##1 (!o_valid && !i_valid && f_changed_data));\n`endif\n\tend endgenerate\n`endif\t// SKIDBUFFER\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "fwb_counter.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/fwb_counter.v",
        "chunks": [
            "module fwb_counter(i_clk, i_reset,\n\t\t// The Wishbone bus\n\t\ti_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel,\n\t\t\ti_wb_ack, i_wb_stall, i_wb_idata, i_wb_err,\n\t\t// Some convenience",
            "output ",
            "parameter s\n\t\tf_nreqs, f_nacks, f_outstanding);",
            "parameter AW=32, DW=32;",
            "parameter F_MAX_STALL = 0,\n\t\t\t\tF_MAX_ACK_DELAY = 0;",
            "parameter F_LGDEPTH = 4;",
            "parameter [(F_LGDEPTH-1):0] F_MAX_REQUESTS = 0;\n\t//\n\t// If true, allow the bus to be kept open when there are no outstanding\n\t// requests.  This is useful for any master that might execute a\n\t// read modify write cycle, such as an atomic add.",
            "parameter [0:0]\t\tF_OPT_RMW_BUS_OPTION = 1;\n\t//\n\t//\n\t// If true, allow the bus to issue multiple discontinuous requests.\n\t// Unlike F_OPT_RMW_BUS_OPTION, these requests may be issued while other\n\t// requests are outstanding",
            "parameter [0:0]\tF_OPT_DISCONTINUOUS = 0;\n\t//\n\t//\n\t// If true, insist that there be a minimum of a single clock delay\n\t// between request and response.  This defaults to off since the\n\t// wishbone specification specifically doesn't require this.  However,\n\t// some interfaces do, so we allow it as an option here.",
            "parameter [0:0]\tF_OPT_MINCLOCK_DELAY = 0;\n\t//\n\t//",
            "localparam [(F_LGDEPTH-1):0] MAX_OUTSTANDING = {(F_LGDEPTH){1'b1}};",
            "localparam MAX_DELAY = (F_MAX_STALL > F_MAX_ACK_DELAY)\n\t\t\t\t? F_MAX_STALL : F_MAX_ACK_DELAY;",
            "localparam DLYBITS= (MAX_DELAY < 4) ? 2\n\t\t\t\t: ((MAX_DELAY <    16) ? 4\n\t\t\t\t: ((MAX_DELAY <    64) ? 6\n\t\t\t\t: ((MAX_DELAY <   256) ? 8\n\t\t\t\t: ((MAX_DELAY <  1024) ? 10\n\t\t\t\t: ((MAX_DELAY <  4096) ? 12\n\t\t\t\t: ((MAX_DELAY < 16384) ? 14\n\t\t\t\t: ((MAX_DELAY < 65536) ? 16\n\t\t\t\t: 32)))))));\n\t//",
            "input ",
            "wire i_clk, i_reset;\n\t// Input/master bus",
            "input ",
            "wire i_wb_cyc, i_wb_stb, i_wb_we;",
            "input ",
            "wire [(AW-1):0]\ti_wb_addr;",
            "input ",
            "wire [(DW-1):0]\ti_wb_data;",
            "input ",
            "wire [(DW/8-1):0]\ti_wb_sel;\n\t//",
            "input ",
            "wire i_wb_ack;",
            "input ",
            "wire i_wb_stall;",
            "input ",
            "wire [(DW-1):0]\ti_wb_idata;",
            "input ",
            "wire i_wb_err;\n\t//",
            "output ",
            "reg [(F_LGDEPTH-1):0]\tf_nreqs, f_nacks;",
            "output ",
            "wire [(F_LGDEPTH-1):0]\tf_outstanding;\n\n\t//\n\t// Let's just make sure our",
            "parameter s are set up right\n\t//\n\talways @(*)\n\t\tassert(F_MAX_REQUESTS < {(F_LGDEPTH){1'b1}});\n\n\t//\n\t//\n\t// Bus requests\n\t//\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Count outstanding requests vs acknowledgments\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Count the number of requests that have been received\n\t//\n\tinitial\tf_nreqs = 0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(!i_wb_cyc))\n\t\tf_nreqs <= 0;\n\telse if ((i_wb_stb)&&(!i_wb_stall))\n\t\tf_nreqs <= f_nreqs + 1'b1;\n\n\n\t//\n\t// Count the number of acknowledgements that have been returned\n\t//\n\tinitial\tf_nacks = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_nacks <= 0;\n\telse if (!i_wb_cyc)\n\t\tf_nacks <= 0;\n\telse if ((i_wb_ack)||(i_wb_err))\n\t\tf_nacks <= f_nacks + 1'b1;\n\n\t//\n\t// The number of outstanding requests is the difference between\n\t// the number of requests and the number of acknowledgements\n\t//\n\tassign\tf_outstanding = (i_wb_cyc) ? (f_nreqs - f_nacks):0;\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "sfifo.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/sfifo.v",
        "chunks": [
            "module sfifo #(\n\t\t// {{{",
            "parameter BW=8,\t// Byte/data width",
            "parameter LGFLEN=4,",
            "parameter [0:0]\tOPT_ASYNC_READ = 1'b1,",
            "parameter [0:0]\tOPT_WRITE_ON_FULL = 1'b0,",
            "parameter [0:0]\tOPT_READ_ON_EMPTY = 1'b0\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk,",
            "input ",
            "wire i_reset,\n\t\t//\n\t\t// Write interface",
            "input ",
            "wire i_wr,",
            "input ",
            "wire [(BW-1):0]\ti_data,",
            "output ",
            "wire o_full,",
            "output ",
            "reg [LGFLEN:0]\to_fill,\n\t\t//\n\t\t// Read interface",
            "input ",
            "wire i_rd,",
            "output ",
            "reg [(BW-1):0]\to_data,",
            "output ",
            "wire o_empty\t// True if FIFO is empty\n`ifdef\tFORMAL\n`ifdef\tF_PEEK\n\t\t,",
            "output ",
            "wire [LGFLEN:0]\tf_first_addr,",
            "output ",
            "wire [LGFLEN:0]\tf_second_addr,",
            "output ",
            "reg [BW-1:0]\tf_first_data, f_second_data,",
            "output ",
            "reg f_first_in_fifo,\n\t\t\t\t\t\tf_second_in_fifo,",
            "output ",
            "reg [LGFLEN:0]\tf_distance_to_first,\n\t\t\t\t\t\tf_distance_to_second\n`endif\n`endif\n\t\t// }}}\n\t);\n\n\t// Register/net declarations\n\t// {{{",
            "localparam FLEN=(1<<LGFLEN);",
            "reg r_full, r_empty;",
            "reg [(BW-1):0]\tmem[0:(FLEN-1)];",
            "reg [LGFLEN:0]\twr_addr, rd_addr;",
            "wire w_wr = (i_wr && !o_full);",
            "wire w_rd = (i_rd && !o_empty);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Write half\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// o_fill\n\t// {{{\n\tinitial\to_fill = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_fill <= 0;\n\telse case({ w_wr, w_rd })\n\t2'b01: o_fill <= o_fill - 1;\n\t2'b10: o_fill <= o_fill + 1;\n\tdefault: o_fill <= wr_addr - rd_addr;\n\tendcase\n\t// }}}\n\n\t// r_full, o_full\n\t// {{{\n\tinitial\tr_full = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_full <= 0;\n\telse case({ w_wr, w_rd})\n\t2'b01: r_full <= 1'b0;\n\t2'b10: r_full <= (o_fill == { 1'b0, {(LGFLEN){1'b1}} });\n\tdefault: r_full <= (o_fill == { 1'b1, {(LGFLEN){1'b0}} });\n\tendcase\n\n\tassign\to_full = (i_rd && OPT_WRITE_ON_FULL) ? 1'b0 : r_full;\n\t// }}}\n\n\t// wr_addr, the write address pointer\n\t// {{{\n\tinitial\twr_addr = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\twr_addr <= 0;\n\telse if (w_wr)\n\t\twr_addr <= wr_addr + 1'b1;\n\t// }}}\n\n\t// Write to memory\n\t// {{{\n\talways @(posedge i_clk)\n\tif (w_wr)\n\t\tmem[wr_addr[(LGFLEN-1):0]] <= i_data;\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read half\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// rd_addr, the read address pointer\n\t// {{{\n\tinitial\trd_addr = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\trd_addr <= 0;\n\telse if (w_rd)\n\t\trd_addr <= rd_addr + 1;\n\t// }}}\n\n\t// r_empty, o_empty\n\t// {{{\n\tinitial\tr_empty = 1'b1;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_empty <= 1'b1;\n\telse case ({ w_wr, w_rd })\n\t2'b01: r_empty <= (o_fill <= 1);\n\t2'b10: r_empty <= 1'b0;\n\tdefault: begin end\n\tendcase\n\n\tassign\to_empty = (OPT_READ_ON_EMPTY && i_wr) ? 1'b0 : r_empty;\n\t// }}}\n\n\t// Read from the FIFO\n\t// {{{\n\tgenerate if (OPT_ASYNC_READ && OPT_READ_ON_EMPTY)\n\tbegin : ASYNCHRONOUS_READ_ON_EMPTY\n\t\t// o_data\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\to_data = mem[rd_addr[LGFLEN-1:0]];\n\t\t\tif (r_empty)\n\t\t\t\to_data = i_data;\n\t\tend\n\t\t// }}}\n\tend else if (OPT_ASYNC_READ)\n\tbegin : ASYNCHRONOUS_READ\n\t\t// o_data\n\t\t// {{{\n\t\talways @(*)\n\t\t\to_data = mem[rd_addr[LGFLEN-1:0]];\n\t\t// }}}\n\tend else begin : REGISTERED_READ\n\t\t// {{{",
            "reg bypass_valid;",
            "reg [BW-1:0]\tbypass_data, rd_data;",
            "reg [LGFLEN-1:0]\trd_next;\n\n\t\talways @(*)\n\t\t\trd_next = rd_addr[LGFLEN-1:0] + 1;\n\n\t\t// Memory read, bypassing it if we must\n\t\t// {{{\n\t\tinitial bypass_valid = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tbypass_valid <= 0;\n\t\telse if (r_empty || i_rd)\n\t\tbegin\n\t\t\tif (!i_wr)\n\t\t\t\tbypass_valid <= 1'b0;\n\t\t\telse if (r_empty || (i_rd && (o_fill == 1)))\n\t\t\t\tbypass_valid <= 1'b1;\n\t\t\telse\n\t\t\t\tbypass_valid <= 1'b0;\n\t\tend\n\n\t\talways @(posedge i_clk)\n\t\tif (r_empty || i_rd)\n\t\t\tbypass_data <= i_data;\n\n\t\tinitial mem[0] = 0;\n\t\tinitial rd_data = 0;\n\t\talways @(posedge i_clk)\n\t\tif (w_rd)\n\t\t\trd_data <= mem[rd_next];\n\n\t\talways @(*)\n\t\tif (OPT_READ_ON_EMPTY && r_empty)\n\t\t\to_data = i_data;\n\t\telse if (bypass_valid)\n\t\t\to_data = bypass_data;\n\t\telse\n\t\t\to_data = rd_data;\n\t\t// }}}\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// FORMAL METHODS\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\n//\n// Assumptions about our",
            "input (s)\n//\n//\n`ifdef\tSFIFO\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "reg f_past_valid;",
            "wire [LGFLEN:0]\tf_fill, f_next;",
            "wire f_empty;\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about our flags and counters\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tassign\tf_fill = wr_addr - rd_addr;\n\tassign\tf_empty = (wr_addr == rd_addr);\n\tassign\tf_next = rd_addr + 1'b1;\n\n\talways @(*)\n\tbegin\n\t\tassert(f_fill <= { 1'b1, {(LGFLEN){1'b0}} });\n\t\tassert(o_fill == f_fill);\n\n\t\tassert(r_full  == (f_fill == {1'b1, {(LGFLEN){1'b0}} }));\n\t\tassert(r_empty == (f_fill == 0));\n\n\t\tif (!OPT_WRITE_ON_FULL)\n\t\tbegin\n\t\t\tassert(o_full == r_full);\n\t\tend else begin\n\t\t\tassert(o_full == (r_full && !i_rd));\n\t\tend\n\n\t\tif (!OPT_READ_ON_EMPTY)\n\t\tbegin\n\t\t\tassert(o_empty == r_empty);\n\t\tend else begin\n\t\t\tassert(o_empty == (r_empty && !i_wr));\n\t\tend\n\tend\n\n\talways @(posedge i_clk)\n\tif (!OPT_ASYNC_READ && f_past_valid)\n\tbegin\n\t\tif (f_fill == 0)\n\t\tbegin\n\t\t\tassert(r_empty);\n\t\t\tassert(o_empty || (OPT_READ_ON_EMPTY && i_wr));\n\t\tend else if ($past(f_fill)>1)\n\t\tbegin\n\t\t\tassert(!r_empty);\n\t\tend else if ($past(!i_rd && f_fill > 0))\n\t\t\tassert(!r_empty);\n\tend\n\n\talways @(*)\n\tif (!r_empty)\n\tbegin\n\t\t// This also applies for the",
            "reg istered read case\n\t\tassert(mem[rd_addr[LGFLEN-1:0]] == o_data);\n\tend else if (OPT_READ_ON_EMPTY)\n\t\tassert(o_data == i_data);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Formal contract: (Twin write test)\n\t// {{{\n\t// If you write two values in succession, you should be able to read\n\t// those same two values in succession some time later.\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Verilator lint_off UNDRIVEN\n\t(* anyconst *)",
            "reg [LGFLEN:0]\tfw_first_addr;\n\t// Verilator lint_on  UNDRIVEN\n`ifndef\tF_PEEK",
            "wire [LGFLEN:0]\tf_first_addr;",
            "wire [LGFLEN:0]\tf_second_addr;",
            "reg [BW-1:0]\tf_first_data, f_second_data;",
            "reg f_first_in_fifo, f_second_in_fifo;",
            "reg [LGFLEN:0]\tf_distance_to_first, f_distance_to_second;\n`endif",
            "reg f_first_addr_in_fifo, f_second_addr_in_fifo;\n\n\tassign f_first_addr  = fw_first_addr;\n\tassign f_second_addr = f_first_addr + 1;\n\n\talways @(*)\n\tbegin\n\t\tf_distance_to_first = (f_first_addr - rd_addr);\n\t\tf_first_addr_in_fifo = 0;\n\t\tif ((f_fill != 0) && (f_distance_to_first < f_fill))\n\t\t\tf_first_addr_in_fifo = 1;\n\tend\n\n\talways @(*)\n\tbegin\n\t\tf_distance_to_second = (f_second_addr - rd_addr);\n\t\tf_second_addr_in_fifo = 0;\n\t\tif ((f_fill != 0) && (f_distance_to_second < f_fill))\n\t\t\tf_second_addr_in_fifo = 1;\n\tend\n\n\talways @(posedge i_clk)\n\tif (w_wr && wr_addr == f_first_addr)\n\t\tf_first_data <= i_data;\n\n\talways @(posedge i_clk)\n\tif (w_wr && wr_addr == f_second_addr)\n\t\tf_second_data <= i_data;\n\n\talways @(*)\n\tif (f_first_addr_in_fifo)\n\t\tassert(mem[f_first_addr[LGFLEN-1:0]] == f_first_data);\n\talways @(*)\n\t\tf_first_in_fifo = (f_first_addr_in_fifo && (mem[f_first_addr[LGFLEN-1:0]] == f_first_data));\n\n\talways @(*)\n\tif (f_second_addr_in_fifo)\n\t\tassert(mem[f_second_addr[LGFLEN-1:0]] == f_second_data);\n\n\talways @(*)\n\t\tf_second_in_fifo = (f_second_addr_in_fifo && (mem[f_second_addr[LGFLEN-1:0]] == f_second_data));\n\n\talways @(*)\n\tif (f_first_in_fifo && (o_fill == 1 || f_distance_to_first == 0))\n\t\tassert(o_data == f_first_data);\n\n\talways @(*)\n\tif (f_second_in_fifo && (o_fill == 1 || f_distance_to_second == 0))\n\t\tassert(o_data == f_second_data);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid && !$past(i_reset))\n\tbegin\n\t\tcase({$past(f_first_in_fifo), $past(f_second_in_fifo)})\n\t\t2'b00: begin\n\t\t\t\tif ($past(w_wr && (!w_rd || !r_empty))\n\t\t\t\t\t&&($past(wr_addr == f_first_addr)))\n\t\t\t\tbegin\n\t\t\t\t\tassert(f_first_in_fifo);\n\t\t\t\tend else begin\n\t\t\t\t\tassert(!f_first_in_fifo);\n\t\t\t\tend\n\t\t\t\t//\n\t\t\t\t// The second could be in the FIFO, since\n\t\t\t\t// one might write other data than f_first_data\n\t\t\t\t//\n\t\t\t\t// assert(!f_second_in_fifo);\n\t\t\tend\n\t\t2'b01: begin\n\t\t\t\tassert(!f_first_in_fifo);\n\t\t\t\tif ($past(w_rd && (rd_addr==f_second_addr)))\n\t\t\t\tbegin\n\t\t\t\t\tassert((o_empty&&!OPT_ASYNC_READ)||!f_second_in_fifo);\n\t\t\t\tend else begin\n\t\t\t\t\tassert(f_second_in_fifo);\n\t\t\t\tend\n\t\t\tend\n\t\t2'b10: begin\n\t\t\t\tif ($past(w_wr)\n\t\t\t\t\t&&($past(wr_addr == f_second_addr)))\n\t\t\t\tbegin\n\t\t\t\t\tassert(f_second_in_fifo);\n\t\t\t\tend else begin\n\t\t\t\t\tassert(!f_second_in_fifo);\n\t\t\t\tend\n\t\t\t\tif ($past(!w_rd ||(rd_addr != f_first_addr)))\n\t\t\t\t\tassert(f_first_in_fifo);\n\t\t\tend\n\t\t2'b11: begin\n\t\t\t\tassert(f_second_in_fifo);\n\t\t\t\tif ($past(!w_rd ||(rd_addr != f_first_addr)))\n\t\t\t\tbegin\n\t\t\t\t\tassert(f_first_in_fifo);\n\t\t\t\t\tif (rd_addr == f_first_addr)\n\t\t\t\t\t\tassert(o_data == f_first_data);\n\t\t\t\tend else begin\n\t\t\t\t\tassert(!f_first_in_fifo);\n\t\t\t\t\tassert(o_data == f_second_data);\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\tCover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n`ifdef\tSFIFO",
            "reg f_was_full;\n\tinitial\tf_was_full = 0;\n\talways @(posedge i_clk)\n\tif (o_full)\n\t\tf_was_full <= 1;\n\n\talways @(posedge i_clk)\n\t\tcover($fell(f_empty));\n\n\talways @(posedge i_clk)\n\t\tcover($fell(o_empty));\n\n\talways @(posedge i_clk)\n\t\tcover(f_was_full && f_empty);\n\n\talways @(posedge i_clk)\n\t\tcover($past(o_full,2)&&(!$past(o_full))&&(o_full));\n\n\talways @(posedge i_clk)\n\tif (f_past_valid)\n\t\tcover($past(o_empty,2)&&(!$past(o_empty))&& o_empty);\n`endif\n\t// }}}\n\n\t// Make Verilator happy\n\t// Verilator lint_off UNUSED",
            "wire unused_formal;\n\tassign\tunused_formal = &{ 1'b0, f_next[LGFLEN], f_empty };\n\t// Verilator lint_on  UNUSED\n`endif // FORMAL\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "wbarbiter.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/wbarbiter.v",
        "chunks": [
            "logic required in this\n//\tprocess, while still minimizing access time.\n//\n//\tThe core",
            "logic works like this:\n//\n//\t\t1. If 'A' or 'B' asserts the o_cyc line, a bus cycle will begin,\n//\t\t\twith acccess granted to whomever requested it.\n//\t\t2. If both 'A' and 'B' assert o_cyc at the same time, only 'A'\n//\t\t\twill be granted the bus.  (If the alternating",
            "parameter //\t\t\tis set, A and B will alternate who gets the bus in\n//\t\t\tthis case.)\n//\t\t3. The bus will remain owned by whomever the bus was granted to\n//\t\t\tuntil they deassert the o_cyc line.\n//\t\t4. At the end of a bus cycle, o_cyc is guaranteed to be\n//\t\t\tdeasserted (low) for one clock.\n//\t\t5. On the next clock, bus arbitration takes place again.  If\n//\t\t\t'A' requests the bus, no matter how long 'B' was\n//\t\t\twaiting, 'A' will then be granted the bus.  (Unless\n//\t\t\tagain the alternating",
            "parameter is set, then the\n//\t\t\taccess is guaranteed to switch to B.)\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n//\n`define\tWBA_ALTERNATING\n// }}}",
            "module wbarbiter #(\n\t\t// {{{",
            "parameter DW=32, AW=32,",
            "parameter SCHEME=\"ALTERNATING\",",
            "parameter [0:0]\t\tOPT_ZERO_ON_IDLE = 1'b0\n`ifdef\tFORMAL\n\t\t,",
            "parameter F_MAX_STALL = 3,",
            "parameter F_MAX_ACK_DELAY = 3,",
            "parameter F_LGDEPTH=3\n`endif\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Bus A -- the priority bus\n\t\t// {{{",
            "input ",
            "wire i_a_cyc, i_a_stb, i_a_we,",
            "input ",
            "wire [(AW-1):0]\ti_a_adr,",
            "input ",
            "wire [(DW-1):0]\ti_a_dat,",
            "input ",
            "wire [(DW/8-1):0]\ti_a_sel,",
            "output ",
            "wire o_a_stall, o_a_ack, o_a_err,\n\t\t// }}}\n\t\t// Bus B\n\t\t// {{{",
            "input ",
            "wire i_b_cyc, i_b_stb, i_b_we,",
            "input ",
            "wire [(AW-1):0]\ti_b_adr,",
            "input ",
            "wire [(DW-1):0]\ti_b_dat,",
            "input ",
            "wire [(DW/8-1):0]\ti_b_sel,",
            "output ",
            "wire o_b_stall, o_b_ack, o_b_err,\n\t\t// }}}\n\t\t// Combined/arbitrated bus\n\t\t// {{{",
            "output ",
            "wire o_cyc, o_stb, o_we,",
            "output ",
            "wire [(AW-1):0]\to_adr,",
            "output ",
            "wire [(DW-1):0]\to_dat,",
            "output ",
            "wire [(DW/8-1):0]\to_sel,",
            "input ",
            "wire i_stall, i_ack, i_err\n\t\t// }}}\n`ifdef\tFORMAL\n\t\t,",
            "output ",
            "wire [(F_LGDEPTH-1):0]\n\t\t\tf_nreqs, f_nacks, f_outstanding,\n\t\t\tf_a_nreqs, f_a_nacks, f_a_outstanding,\n\t\t\tf_b_nreqs, f_b_nacks, f_b_outstanding\n`endif\n\t\t// }}}\n\t);\n\n\t// {{{\n\t// Go high immediately (new cycle) if ...\n\t//\tPrevious cycle was low and *someone* is requesting a bus cycle\n\t// Go low immadiately if ...\n\t//\tWe were just high and the owner no longer wants the bus\n\t// WISHBONE Spec recommends no",
            "logic between a FF and the o_cyc\n\t//\tThis violates that spec.  (Rec 3.15, p35)\n\t// }}}\n\n\t// Local declarations\n\t// {{{",
            "reg r_a_owner;\n\t// }}}\n\n\tassign o_cyc = (r_a_owner) ? i_a_cyc : i_b_cyc;\n\tinitial\tr_a_owner = 1'b1;\n\n\t// r_a_owner -- determined through arbitration\n\t// {{{\n\tgenerate if (SCHEME == \"PRIORITY\")\n\tbegin : PRI\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (!i_b_cyc)\n\t\t\tr_a_owner <= 1'b1;\n\t\t// Allow B to set its CYC line w/o activating this\n\t\t// interface\n\t\telse if ((i_b_stb)&&(!i_a_cyc))\n\t\t\tr_a_owner <= 1'b0;\n\t\t// }}}\n\tend else if (SCHEME == \"ALTERNATING\")\n\tbegin : ALT\n\t\t// {{{",
            "reg last_owner;\n\n\t\tinitial\tlast_owner = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif ((i_a_cyc)&&(r_a_owner))\n\t\t\tlast_owner <= 1'b1;\n\t\telse if ((i_b_cyc)&&(!r_a_owner))\n\t\t\tlast_owner <= 1'b0;\n\n\t\talways @(posedge i_clk)\n\t\tif ((!i_a_cyc)&&(!i_b_cyc))\n\t\t\tr_a_owner <= !last_owner;\n\t\telse if ((r_a_owner)&&(!i_a_cyc))\n\t\tbegin\n\n\t\t\tif (i_b_stb)\n\t\t\t\tr_a_owner <= 1'b0;\n\n\t\tend else if ((!r_a_owner)&&(!i_b_cyc))\n\t\tbegin\n\n\t\t\tif (i_a_stb)\n\t\t\t\tr_a_owner <= 1'b1;\n\n\t\tend\n\t\t// }}}\n\tend else // if (SCHEME == \"LAST\")\n\tbegin : LST\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif ((!i_a_cyc)&&(i_b_stb))\n\t\t\tr_a_owner <= 1'b0;\n\t\telse if ((!i_b_cyc)&&(i_a_stb))\n\t\t\tr_a_owner <= 1'b1;\n\t\t// ?}}}\n\tend endgenerate\n\t// }}}\n\n\t// o_we\n\t// {{{\n\t// Realistically, if neither master owns the bus, the",
            "output is a\n\t// don't care.  Thus we trigger off whether or not 'A' owns the bus.\n\t// If 'B' owns it all we care is that 'A' does not.  Likewise, if\n\t// neither owns the bus than the values on the various lines are\n\t// irrelevant.\n\tassign o_we  = (r_a_owner) ? i_a_we  : i_b_we;\n\t// }}}\n\n\t// Other bus",
            "output s\n\t// {{{\n\tgenerate if (OPT_ZERO_ON_IDLE)\n\tbegin : LOW_POWER\n\t\t// {{{\n\t\t// OPT_ZERO_ON_IDLE will use up more",
            "logic and may even slow\n\t\t// down the master clock if set.  However, it may also reduce\n\t\t// the power used by the FPGA by preventing things from toggling\n\t\t// when the bus isn't in use.  The option is here because it\n\t\t// also makes it a lot easier to look for when things happen\n\t\t// on the bus via VERILATOR when timing and",
            "logic counts\n\t\t// don't matter.\n\t\t//\n\t\tassign o_stb     = (o_cyc)? ((r_a_owner) ? i_a_stb : i_b_stb):0;\n\t\tassign o_adr     = (o_stb)? ((r_a_owner) ? i_a_adr : i_b_adr):0;\n\t\tassign o_dat     = (o_stb)? ((r_a_owner) ? i_a_dat : i_b_dat):0;\n\t\tassign o_sel     = (o_stb)? ((r_a_owner) ? i_a_sel : i_b_sel):0;\n\t\tassign o_a_ack   = (o_cyc)&&( r_a_owner) ? i_ack   : 1'b0;\n\t\tassign o_b_ack   = (o_cyc)&&(!r_a_owner) ? i_ack   : 1'b0;\n\t\tassign o_a_stall = (o_cyc)&&( r_a_owner) ? i_stall : 1'b1;\n\t\tassign o_b_stall = (o_cyc)&&(!r_a_owner) ? i_stall : 1'b1;\n\t\tassign o_a_err   = (o_cyc)&&( r_a_owner) ? i_err : 1'b0;\n\t\tassign o_b_err   = (o_cyc)&&(!r_a_owner) ? i_err : 1'b0;\n\t\t// }}}\n\tend else begin : LOW_LOGIC\n\t\t// {{{\n\n\t\tassign o_stb = (r_a_owner) ? i_a_stb : i_b_stb;\n\t\tassign o_adr = (r_a_owner) ? i_a_adr : i_b_adr;\n\t\tassign o_dat = (r_a_owner) ? i_a_dat : i_b_dat;\n\t\tassign o_sel = (r_a_owner) ? i_a_sel : i_b_sel;\n\n\t\t// We cannot allow the return acknowledgement to ever go high if\n\t\t// the master in question does not own the bus.  Hence we force\n\t\t// it low if the particular master doesn't own the bus.\n\t\tassign\to_a_ack   = ( r_a_owner) ? i_ack   : 1'b0;\n\t\tassign\to_b_ack   = (!r_a_owner) ? i_ack   : 1'b0;\n\n\t\t// Stall must be asserted on the same cycle the",
            "input master\n\t\t// asserts the bus, if the bus isn't granted to him.\n\t\tassign\to_a_stall = ( r_a_owner) ? i_stall : 1'b1;\n\t\tassign\to_b_stall = (!r_a_owner) ? i_stall : 1'b1;\n\n\t\t//\n\t\t//\n\t\tassign\to_a_err = ( r_a_owner) ? i_err : 1'b0;\n\t\tassign\to_b_err = (!r_a_owner) ? i_err : 1'b0;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, i_reset };\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\n`ifdef\tWBARBITER\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\tinitial\t`ASSUME(!i_a_cyc);\n\tinitial\t`ASSUME(!i_a_stb);\n\n\tinitial\t`ASSUME(!i_b_cyc);\n\tinitial\t`ASSUME(!i_b_stb);\n\n\tinitial\t`ASSUME(!i_ack);\n\tinitial\t`ASSUME(!i_err);\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(i_reset);\n\n\talways @(posedge i_clk)\n\tbegin\n\t\tif (o_cyc)\n\t\t\tassert((i_a_cyc)||(i_b_cyc));\n\t\tif ((f_past_valid)&&($past(o_cyc))&&(o_cyc))\n\t\t\tassert($past(r_a_owner) == r_a_owner);\n\tend\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.DW(DW), .AW(AW),\n\t\t.F_MAX_STALL(F_MAX_STALL),\n\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t.F_MAX_ACK_DELAY(F_MAX_ACK_DELAY),\n\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t.F_OPT_DISCONTINUOUS(1),\n\t\t.F_OPT_CLK2FFLOGIC(1'b0)\n\t\t// }}}\n\t) f_wbm (\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\to_cyc, o_stb, o_we, o_adr, o_dat, o_sel,\n\t\ti_ack, i_stall, 32'h0, i_err,\n\t\tf_nreqs, f_nacks, f_outstanding\n\t\t// }}}\n\t);\n\n\tfwb_slave  #(\n\t\t// {{{\n\t\t.DW(DW), .AW(AW),\n\t\t.F_MAX_STALL(0),\n\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t.F_MAX_ACK_DELAY(0),\n\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t.F_OPT_DISCONTINUOUS(1),\n\t\t.F_OPT_CLK2FFLOGIC(1'b0)\n\t\t// }}}\n\t) f_wba (\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\ti_a_cyc, i_a_stb, i_a_we, i_a_adr, i_a_dat, i_a_sel,\n\t\to_a_ack, o_a_stall, 32'h0, o_a_err,\n\t\tf_a_nreqs, f_a_nacks, f_a_outstanding\n\t\t// }}}\n\t);\n\n\tfwb_slave  #(\n\t\t// {{{\n\t\t.DW(DW), .AW(AW),\n\t\t.F_MAX_STALL(0),\n\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t.F_MAX_ACK_DELAY(0),\n\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t.F_OPT_DISCONTINUOUS(1),\n\t\t.F_OPT_CLK2FFLOGIC(1'b0)\n\t\t// }}}\n\t) f_wbb (\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\ti_b_cyc, i_b_stb, i_b_we, i_b_adr, i_b_dat, i_b_sel,\n\t\to_b_ack, o_b_stall, 32'h0, o_b_err,\n\t\tf_b_nreqs, f_b_nacks, f_b_outstanding\n\t\t// }}}\n\t);\n\n\t// Induction properties, relating nreqs and nacks to r_a_owner\n\t// {{{\n\talways @(posedge i_clk)\n\tif (r_a_owner)\n\tbegin\n\t\tassert(f_b_nreqs == 0);\n\t\tassert(f_b_nacks == 0);\n\t\tassert(f_a_outstanding == f_outstanding);\n\tend else begin\n\t\tassert(f_a_nreqs == 0);\n\t\tassert(f_a_nacks == 0);\n\t\tassert(f_b_outstanding == f_outstanding);\n\tend\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t\t&&($past(i_a_stb))&&(!$past(i_b_cyc)))\n\t\tassert(r_a_owner);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t\t&&(!$past(i_a_cyc))&&($past(i_b_stb)))\n\t\tassert(!r_a_owner);\n\n\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(r_a_owner != $past(r_a_owner)))\n\t\t\tassert(!$past(o_cyc));\n\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "wbdblpriarb.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/ex/wbdblpriarb.v",
        "chunks": [
            "logic , and the second comparison\n//\tnow has time to complete.\n//\n//\tSo let me try to explain this again.  To use this arbiter, one of the\n//\ttwo masters sets CYC and STB before, only the master determines which\n//\tof two address spaces the CYC and STB apply to before the clock and\n//\tonly sets the appropriate CYC and STB lines.  Then, on the clock tick,\n//\tthe arbiter determines who gets *both* busses, as they both share every\n//\tother WB line. Thus, only one of CYC_A and CYC_B going out will ever\n//\tbe high at a given time.\n//\n//\tHopefully this makes more sense than it sounds. If not, check out the\n//\tcode below for a better explanation.\n//\n//\t20150919 -- Added supported for the WB error signal.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module wbdblpriarb #(\n\t\t// {{{",
            "parameter DW=32, AW=32,\n\t\t// OPT_ZERO_ON_IDLE\n\t\t// {{{\n\t\t// OPT_ZERO_ON_IDLE uses more",
            "logic than the alternative.  It\n\t\t// should be useful for reducing power, as these circuits tend\n\t\t// to drive",
            "wire s all the way across the design, but it may also\n\t\t// slow down the master clock.  I've used it as an option when\n\t\t// using VER1LATOR, 'cause zeroing things on idle can make them\n\t\t// stand out all the more when staring at",
            "wire s and dumps and\n\t\t// such.",
            "parameter [0:0]\t\tOPT_ZERO_ON_IDLE = 1'b0\n\t\t// }}}\n`ifdef FORMAL\n\t\t// Parameters used in the formal proof only\n\t\t,",
            "parameter F_LGDEPTH = 3,",
            "parameter F_MAX_STALL = 0,",
            "parameter F_MAX_ACK_DELAY=0\n`endif\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Bus A\n\t\t// {{{",
            "input ",
            "wire i_a_cyc_a, i_a_cyc_b,\n\t\t\t\t\t\ti_a_stb_a, i_a_stb_b, i_a_we,",
            "input ",
            "wire [(AW-1):0]\ti_a_adr,",
            "input ",
            "wire [(DW-1):0]\ti_a_dat,",
            "input ",
            "wire [(DW/8-1):0]\ti_a_sel,",
            "output ",
            "wire o_a_stall, o_a_ack, o_a_err,\n\t\t// }}}\n\t\t// Bus B\n\t\t// {{{",
            "input ",
            "wire i_b_cyc_a, i_b_cyc_b,\n\t\t\t\t\t\ti_b_stb_a, i_b_stb_b, i_b_we,",
            "input ",
            "wire [(AW-1):0]\ti_b_adr,",
            "input ",
            "wire [(DW-1):0]\ti_b_dat,",
            "input ",
            "wire [(DW/8-1):0]\ti_b_sel,",
            "output ",
            "wire o_b_stall, o_b_ack, o_b_err,\n\t\t// }}}\n\t\t// Both buses (i.e. the outgoing, arbitrated bus)\n\t\t// {{{",
            "output ",
            "wire o_cyc_a, o_cyc_b,\n\t\t\t\t\t\to_stb_a, o_stb_b, o_we,",
            "output ",
            "wire [(AW-1):0]\to_adr,",
            "output ",
            "wire [(DW-1):0]\to_dat,",
            "output ",
            "wire [(DW/8-1):0]\to_sel,",
            "input ",
            "wire i_stall, i_ack, i_err\n\t\t// }}}\n`ifdef\tFORMAL\n\t\t// {{{\n\t\t// These",
            "wire s are relics from when the ZipCPU was verified\n\t\t// with this arbiter internal to it.  Since this is no longer\n\t\t// the case, they're now no more than declarations\n\t\t,",
            "output ",
            "wire [(F_LGDEPTH-1):0]\n\t\t\tf_nreqs_a, f_nacks_a, f_outstanding_a,\n\t\t\tf_nreqs_b, f_nacks_b, f_outstanding_b,\n\t\t\tf_a_nreqs_a, f_a_nacks_a, f_a_outstanding_a,\n\t\t\tf_a_nreqs_b, f_a_nacks_b, f_a_outstanding_b,\n\t\t\tf_b_nreqs_a, f_b_nacks_a, f_b_outstanding_a,\n\t\t\tf_b_nreqs_b, f_b_nacks_b, f_b_outstanding_b\n\t\t// }}}\n`endif\n\t\t// }}}\n\t);\n\n\t// r_a_owner\n\t// {{{\n\t// All of our",
            "logic is really captured in the 'r_a_owner'",
            "reg ister.\n\t// This",
            "reg ister determines who owns the bus.  If no one is requesting\n\t// the bus, ownership goes to A on the next clock.  Otherwise, if B is\n\t// requesting the bus and A is not, then ownership goes to not A on\n\t// the next clock.  (Sounds simple ...)\n\t//\n\t// The CYC",
            "logic is here to make certain that, by the time we determine\n\t// who the bus owner is, we can do so based upon determined criteria.",
            "reg r_a_owner;\n\n\tinitial\tr_a_owner = 1'b1;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_a_owner <= 1'b1;\n\t/*\n\t// Remain with the \"last owner\" until 1) the other bus requests\n\t// access, and 2) the last owner no longer wants it.  This\n\t//",
            "logic \"idles\" on the last owner.\n\t//\n\t// This is an alternating bus owner strategy\n\t//\n\telse if ((!o_cyc_a)&&(!o_cyc_b))\n\t\tr_a_owner <= ((i_b_stb_a)||(i_b_stb_b))? 1'b0:1'b1;\n\t//\n\t// Expanding this out\n\t//\n\t// else if ((r_a_owner)&&((i_a_cyc_a)||(i_a_cyc_b)))\n\t//\t\tr_a_owner <= 1'b1;\n\t// else if ((!r_a_owner)&&((i_b_cyc_a)||(i_b_cyc_b)))\n\t//\t\tr_a_owner <= 1'b0;\n\t// else if ((r_a_owner)&&((i_b_stb_a)||(i_b_stb_b)))\n\t//\t\tr_a_owner <= 1'b0;\n\t// else if ((!r_a_owner)&&((i_a_stb_a)||(i_a_stb_b)))\n\t//\t\tr_a_owner <= 1'b0;\n\t//\n\t// Logic required:\n\t//\n\t//\tReset line\n\t//\t+ 9",
            "input s (data)\n\t//\t+ 9",
            "input s (CE)\n\t//\tCould be done with three LUTs\n\t//\t\tFirst two evaluate o_cyc_a and o_cyc_b (above)\n\t*/\n\t// Option 2:\n\t//\n\t// \"Idle\" on A as the owner.\n\t// If a request is made from B, AND A is idle, THEN\n\t// switch.  Otherwise, if B is ever idle, revert back to A\n\t//",
            "reg ardless of whether A wants it or not.\n\telse if ((!i_b_cyc_a)&&(!i_b_cyc_b))\n\t\tr_a_owner <= 1'b1;\n\telse if ((!i_a_cyc_a)&&(!i_a_cyc_b)\n\t\t\t&&((i_b_stb_a)||(i_b_stb_b)))\n\t\tr_a_owner <= 1'b0;\n\t// }}}\n\n\t// o_cyc*, o_stb*, o_we\n\t// {{{\n\t// Realistically, if neither master owns the bus, the",
            "output is a\n\t// don't care.  Thus we trigger off whether or not 'A' owns the bus.\n\t// If 'B' owns it all we care is that 'A' does not.  Likewise, if\n\t// neither owns the bus than the values on these various lines are\n\t// irrelevant.\n\n\tassign o_cyc_a = ((r_a_owner) ? i_a_cyc_a : i_b_cyc_a);\n\tassign o_cyc_b = ((r_a_owner) ? i_a_cyc_b : i_b_cyc_b);\n\tassign o_stb_a = (r_a_owner) ? i_a_stb_a : i_b_stb_a;\n\tassign o_stb_b = (r_a_owner) ? i_a_stb_b : i_b_stb_b;\n\tassign o_we    = (r_a_owner) ? i_a_we    : i_b_we;\n\t// }}}\n\n\t// Other bus",
            "output s and returns\n\t// {{{\n\tgenerate if (OPT_ZERO_ON_IDLE)\n\tbegin : OPT_LOWPOWER\n\t\t// {{{",
            "wire o_cyc, o_stb;\n\n\t\tassign\to_cyc     = ((o_cyc_a)||(o_cyc_b));\n\t\tassign\to_stb     = ((o_stb_a)||(o_stb_b));\n\t\tassign\to_adr     = (o_stb)?((r_a_owner) ? i_a_adr  : i_b_adr):0;\n\t\tassign\to_dat     = (o_stb)?((r_a_owner) ? i_a_dat  : i_b_dat):0;\n\t\tassign\to_sel     = (o_stb)?((r_a_owner) ? i_a_sel  : i_b_sel):0;\n\t\tassign\to_a_ack   = (o_cyc)&&( r_a_owner) ? i_ack   : 1'b0;\n\t\tassign\to_b_ack   = (o_cyc)&&(!r_a_owner) ? i_ack   : 1'b0;\n\t\tassign\to_a_stall = (o_cyc)&&( r_a_owner) ? i_stall : 1'b1;\n\t\tassign\to_b_stall = (o_cyc)&&(!r_a_owner) ? i_stall : 1'b1;\n\t\tassign\to_a_err   = (o_cyc)&&( r_a_owner) ? i_err : 1'b0;\n\t\tassign\to_b_err   = (o_cyc)&&(!r_a_owner) ? i_err : 1'b0;\n\t\t// }}}\n\tend else begin : OPT_LOWLOGIC\n\t\t// {{{\n\t\tassign o_adr   = (r_a_owner) ? i_a_adr   : i_b_adr;\n\t\tassign o_dat   = (r_a_owner) ? i_a_dat   : i_b_dat;\n\t\tassign o_sel   = (r_a_owner) ? i_a_sel   : i_b_sel;\n\n\t\t// We cannot allow the return acknowledgement to ever go high if\n\t\t// the master in question does not own the bus.  Hence we force it\n\t\t// low if the particular master doesn't own the bus.\n\t\tassign\to_a_ack   = ( r_a_owner) ? i_ack   : 1'b0;\n\t\tassign\to_b_ack   = (!r_a_owner) ? i_ack   : 1'b0;\n\n\t\t// Stall must be asserted on the same cycle the",
            "input master asserts\n\t\t// the bus, if the bus isn't granted to him.\n\t\tassign\to_a_stall = ( r_a_owner) ? i_stall : 1'b1;\n\t\tassign\to_b_stall = (!r_a_owner) ? i_stall : 1'b1;\n\n\t\t//\n\t\t//\n\t\tassign\to_a_err = ( r_a_owner) ? i_err : 1'b0;\n\t\tassign\to_b_err = (!r_a_owner) ? i_err : 1'b0;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n`define\tASSERT\tassert\n`ifdef\tWBDBLPRIARB\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\tinitial\t`ASSUME(i_reset);\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(i_reset);\n\n\tinitial\t`ASSUME(!i_a_cyc_a);\n\tinitial\t`ASSUME(!i_a_stb_a);\n\tinitial\t`ASSUME(!i_a_cyc_b);\n\tinitial\t`ASSUME(!i_a_stb_b);\n\n\tinitial\t`ASSUME(!i_b_cyc_a);\n\tinitial\t`ASSUME(!i_b_stb_a);\n\tinitial\t`ASSUME(!i_b_cyc_b);\n\tinitial\t`ASSUME(!i_b_stb_b);\n\n\tinitial\t`ASSUME(!i_ack);\n\tinitial\t`ASSUME(!i_err);\n\n\talways @(*)\n\t\t`ASSUME((!i_a_cyc_a)||(!i_a_cyc_b));\n\talways @(*)\n\t\t`ASSUME((!i_b_cyc_a)||(!i_b_cyc_b));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_a_cyc_a)))\n\t\t`ASSUME(!i_a_cyc_b);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_a_cyc_b)))\n\t\t`ASSUME(!i_a_cyc_a);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_b_cyc_a)))\n\t\t`ASSUME(!i_b_cyc_b);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_b_cyc_b)))\n\t\t`ASSUME(!i_b_cyc_a);",
            "wire f_cyc, f_stb;\n\tassign\tf_cyc = (o_cyc_a)||(o_cyc_b);\n\tassign\tf_stb = (o_stb_a)||(o_stb_b);\n\talways @(posedge i_clk)\n\tbegin\n\t\tif (o_cyc_a)\n\t\t\t`ASSERT((i_a_cyc_a)||(i_b_cyc_a));\n\t\tif (o_cyc_b)\n\t\t\t`ASSERT((i_a_cyc_b)||(i_b_cyc_b));\n\t\t`ASSERT((!o_cyc_a)||(!o_cyc_b));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset)))\n\tbegin\n\t\tif ($past(f_cyc))\n\t\tbegin\n\t\t\tif (($past(o_cyc_a))&&(o_cyc_a))\n\t\t\t\t`ASSERT($past(r_a_owner) == r_a_owner);\n\t\t\tif (($past(o_cyc_b))&&(o_cyc_b))\n\t\t\t\t`ASSERT($past(r_a_owner) == r_a_owner);\n\t\tend else begin\n\t\t\tif (($past(i_a_stb_a))||($past(i_a_stb_b)))\n\t\t\t\t`ASSERT(r_a_owner);\n\t\t\tif (($past(i_b_stb_a))||($past(i_b_stb_b)))\n\t\t\t\t`ASSERT(!r_a_owner);\n\t\tend\n\tend\n\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.AW(AW), .DW(DW),\n\t\t\t.F_MAX_STALL(F_MAX_STALL),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_MAX_ACK_DELAY(F_MAX_ACK_DELAY),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t\t.F_OPT_DISCONTINUOUS(1)\n\t\t// }}}\n\t) f_wbm_a (\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\t\to_cyc_a, o_stb_a, o_we, o_adr, o_dat, o_sel,\n\t\t\t(o_cyc_a)&&(i_ack), i_stall, 32'h0, (o_cyc_a)&&(i_err),\n\t\t\tf_nreqs_a, f_nacks_a, f_outstanding_a\n\t\t// }}}\n\t);\n\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.AW(AW), .DW(DW),\n\t\t\t.F_MAX_STALL(F_MAX_STALL),\n\t\t\t.F_MAX_ACK_DELAY(F_MAX_ACK_DELAY),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t\t.F_OPT_DISCONTINUOUS(1)\n\t\t// }}}\n\t) f_wbm_b(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\t\to_cyc_b, o_stb_b, o_we, o_adr, o_dat, o_sel,\n\t\t\t(o_cyc_b)&&(i_ack), i_stall, 32'h0, (o_cyc_b)&&(i_err),\n\t\t\tf_nreqs_b, f_nacks_b, f_outstanding_b\n\t\t// }}}\n\t);\n\n`ifdef\tWBDBLPRIARB\n`define\tF_SLAVE\tfwb_slave\n`else\n`define\tF_SLAVE\tfwb_counter\n`endif\n\n\t`F_SLAVE  #(\n\t\t// {{{\n\t\t.AW(AW), .DW(DW), .F_MAX_STALL(0),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_MAX_ACK_DELAY(0),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t\t.F_OPT_DISCONTINUOUS(1)\n\t\t// }}}\n\t) f_wba_a(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\t\ti_a_cyc_a, i_a_stb_a, i_a_we, i_a_adr, i_a_dat, i_a_sel,\n\t\t\t(o_cyc_a)&&(o_a_ack), o_a_stall, 32'h0, (o_cyc_a)&&(o_a_err),\n\t\t\tf_a_nreqs_a, f_a_nacks_a, f_a_outstanding_a\n\t\t// }}}\n\t);\n\n\t`F_SLAVE  #(\n\t\t// {{{\n\t\t.AW(AW), .DW(DW), .F_MAX_STALL(0),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_MAX_ACK_DELAY(0),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t\t.F_OPT_DISCONTINUOUS(1)\n\t\t// }}}\n\t) f_wba_b(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\t\ti_a_cyc_b, i_a_stb_b, i_a_we, i_a_adr, i_a_dat, i_a_sel,\n\t\t\t(o_cyc_b)&&(o_a_ack), o_a_stall, 32'h0, (o_cyc_b)&&(o_a_err),\n\t\t\tf_a_nreqs_b, f_a_nacks_b, f_a_outstanding_b\n\t\t// }}}\n\t);\n\n\t`F_SLAVE  #(\n\t\t// {{{\n\t\t.AW(AW), .DW(DW), .F_MAX_STALL(0),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_MAX_ACK_DELAY(0),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t\t.F_OPT_DISCONTINUOUS(1)\n\t\t// }}}\n\t) f_wbb_a(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\t\ti_b_cyc_a, i_b_stb_a, i_b_we, i_b_adr, i_b_dat, i_b_sel,\n\t\t\t(o_cyc_a)&&(o_b_ack), o_b_stall, 32'h0, (o_cyc_a)&&(o_b_err),\n\t\t\tf_b_nreqs_a, f_b_nacks_a, f_b_outstanding_a\n\t\t// }}}\n\t);\n\n\t`F_SLAVE  #(\n\t\t// {{{\n\t\t.AW(AW), .DW(DW), .F_MAX_STALL(0),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_MAX_ACK_DELAY(0),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1),\n\t\t\t.F_OPT_DISCONTINUOUS(1)\n\t\t// }}}\n\t) f_wbb_b(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\t\ti_b_cyc_b, i_b_stb_b, i_b_we, i_b_adr, i_b_dat, i_b_sel,\n\t\t\t(o_cyc_b)&&(o_b_ack), o_b_stall, 32'h0, (o_cyc_b)&&(o_b_err),\n\t\t\tf_b_nreqs_b, f_b_nacks_b, f_b_outstanding_b\n\t\t// }}}\n\t);\n\n\t// Induction properties, relating nreqs and nacks to r_a_owner\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset)))\n\tbegin\n\t\tif (r_a_owner)\n\t\tbegin : A_IS_OWNER\n\t\t\t// {{{\n\t\t\t`ASSERT(f_b_nreqs_a == 0);\n\t\t\t`ASSERT(f_b_nreqs_b == 0);\n\t\t\t//\n\t\t\t`ASSERT(f_b_nacks_a == 0);\n\t\t\t`ASSERT(f_b_nacks_b == 0);\n\t\t\t//\n\t\t\tif (i_a_cyc_a)\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_a_outstanding_a == f_outstanding_a);\n\t\t\t\t`ASSERT(f_a_outstanding_b == 0);\n\t\t\t\t`ASSERT(f_outstanding_b == 0);\n\t\t\t\t`ASSERT(f_a_nreqs_b == 0);\n\t\t\t\t`ASSERT(f_a_nacks_b == 0);\n\t\t\tend else if (i_a_cyc_b)\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_a_outstanding_b == f_outstanding_b);\n\t\t\t\t`ASSERT(f_a_outstanding_a == 0);\n\t\t\t\t`ASSERT(f_outstanding_a == 0);\n\t\t\t\t`ASSERT(f_a_nreqs_a == 0);\n\t\t\t\t`ASSERT(f_a_nacks_a == 0);\n\t\t\tend\n\t\t\t// }}}\n\t\tend else begin : B_IS_OWNER\n\t\t\t// {{{\n\t\t\t`ASSERT(f_a_nreqs_a == 0);\n\t\t\t`ASSERT(f_a_nreqs_b == 0);\n\t\t\t//\n\t\t\t`ASSERT(f_a_nacks_a == 0);\n\t\t\t`ASSERT(f_a_nacks_b == 0);\n\t\t\t//\n\t\t\tif (i_b_cyc_a)\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_b_outstanding_a == f_outstanding_a);\n\t\t\t\t`ASSERT(f_b_outstanding_b == 0);\n\t\t\t\t`ASSERT(f_outstanding_b == 0);\n\t\t\t\t`ASSERT(f_b_nreqs_b == 0);\n\t\t\t\t`ASSERT(f_b_nacks_b == 0);\n\t\t\tend else if (i_b_cyc_b)\n\t\t\tbegin\n\t\t\t\t`ASSERT(f_b_outstanding_b == f_outstanding_b);\n\t\t\t\t`ASSERT(f_b_outstanding_a == 0);\n\t\t\t\t`ASSERT(f_outstanding_a == 0);\n\t\t\t\t`ASSERT(f_b_nreqs_a == 0);\n\t\t\t\t`ASSERT(f_b_nacks_a == 0);\n\t\t\tend\n\t\t\t// }}}\n\t\tend\n\tend\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((r_a_owner)&&(i_b_cyc_a))\n\t\t`ASSUME((i_b_stb_a)&&(!i_b_stb_b));\n\n\talways @(posedge i_clk)\n\tif ((r_a_owner)&&(i_b_cyc_b))\n\t\t`ASSUME((i_b_stb_b)&&(!i_b_stb_a));\n\n\talways @(posedge i_clk)\n\tif ((!r_a_owner)&&(i_a_cyc_a))\n\t\t`ASSUME((i_a_stb_a)&&(!i_a_stb_b));\n\n\talways @(posedge i_clk)\n\tif ((!r_a_owner)&&(i_a_cyc_b))\n\t\t`ASSUME((i_a_stb_b)&&(!i_a_stb_a));\n\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "wbdmac.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/wbdmac.v",
        "chunks": [
            "module is controllable via the wishbone, and moves values from\n//\tone location in the wishbone address space to another.  The amount of\n//\tmemory moved at any given time can be up to 4kB, or equivalently 1kW.\n//\tFour",
            "reg isters control this DMA controller: a control/status",
            "reg ister,\n//\ta length",
            "reg ister, a source WB address and a destination WB address.\n//\tThese",
            "reg ister may be read at any time, but they may only be written\n//\tto when the controller is idle.\n//\n//\tThe meanings of three of the setup",
            "reg isters should be self explanatory:\n//\t\t- The length",
            "reg ister controls the total number of words to\n//\t\t\ttransfer.\n//\t\t- The source address",
            "reg ister controls where the DMA controller\n//\t\t\treads from.  This address may or may not be incremented\n//\t\t\tafter each read, depending upon the setting in the\n//\t\t\tcontrol/status",
            "reg ister.\n//\t\t- The destination address",
            "reg ister, which controls where the DMA\n//\t\t\tcontroller writes to.  This address may or may not be\n//\t\t\tincremented after each write, also depending upon the\n//\t\t\tsetting in the control/status",
            "reg ister.\n//\n//\tIt is the control/status",
            "reg ister, at local address zero, that needs\n//\tmore definition:\n//\n//\tBits:\n//\t31\tR\tWrite protect\tIf this is set to one, it means the\n//\t\t\t\twrite protect bit is set and the controller\n//\t\t\t\tis therefore idle.  This bit will be set upon\n//\t\t\t\tcompleting any transfer.\n//\t30\tR\tError.\t\tThe controller stopped mid-transfer\n//\t\t\t\t\tafter receiving a bus error.\n//\t29\tR/W\tinc_s_n\t\tIf set to one, the source address\n//\t\t\t\twill not increment from one read to the next.\n//\t28\tR/W\tinc_d_n\t\tIf set to one, the destination address\n//\t\t\t\twill not increment from one write to the next.\n//\t27\tR\tAlways 0\n//\t26..16\tR\tnread\t\tIndicates how many words have been read,\n//\t\t\t\tand not necessarily written (yet).  This\n//\t\t\t\tcombined with the cfg_len",
            "parameter should tell\n//\t\t\t\texactly where the controller is at mid-transfer.\n//\t27..16\tW\tWriteProtect\tWhen a 12'h3db is written to these\n//\t\t\t\tbits, the write protect bit will be cleared.\n//\n//\t15\tR/W\ton_dev_trigger\tWhen set to '1', the controller will\n//\t\t\t\twait for an external interrupt before starting.\n//\t14..10\tR/W\tdevice_id\tThis determines which external interrupt\n//\t\t\t\twill trigger a transfer.\n//\t9..0\tR/W\ttransfer_len\tHow many bytes to transfer at one time.\n//\t\t\t\tThe minimum transfer length is one, while zero\n//\t\t\t\tis mapped to a transfer length of 1kW.\n//\n//\tWrite 32'hffed00 to halt an ongoing transaction, completing anything\n//\tremaining, or 32'hafed00 to abort the current transaction leaving\n//\tany unfinished read/write in an undetermined state.\n//\n//\n//\tTo use this, follow this checklist:\n//\t1. Wait for any prior DMA operation to complete\n//\t\t(Read address 0, wait 'till either top bit is set or cfg_len==0)\n//\t2. Write values into length, source and destination address.\n//\t\t(writei(3, &vals) should be sufficient for this.)\n//\t3. Enable the DMAC interrupt in whatever interrupt controller is present\n//\t\ton the system.\n//\t4. Write the final start command to the setup/control/status",
            "reg ister:\n//\t\tSet inc_s_n, inc_d_n, on_dev_trigger, dev_trigger,\n//\t\t\tappropriately for your task\n//\t\tWrite 12'h3db to the upper word.\n//\t\tSet the lower word to either all zeros, or a smaller transfer\n//\t\tlength if desired.\n//\t5. wait() for the interrupt and the operation to complete.\n//\t\tPrior to completion, number of items successfully transferred\n//\t\tbe read from the length",
            "reg ister.  If the internal buffer is\n//\t\tbeing used, then you can read how much has been read into that\n//\t\tbuffer by reading from bits 25..16 of this control/status\n//",
            "reg ister.\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype none\n// }}}",
            "module wbdmac #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=30, LGMEMLEN = 10,",
            "parameter SLV_WIDTH=32,",
            "parameter BUS_WIDTH=32,",
            "localparam AW=ADDRESS_WIDTH\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Slave port\n\t\t// {{{\n\t\t// Slave/control wishbone",
            "input s",
            "input ",
            "wire i_swb_cyc, i_swb_stb, i_swb_we,",
            "input ",
            "wire [1:0]\ti_swb_addr,",
            "input ",
            "wire [(SLV_WIDTH-1):0]\ti_swb_data,\n\t\t// Slave/control wishbone",
            "output s",
            "output ",
            "wire o_swb_stall,",
            "output ",
            "reg o_swb_ack,",
            "output ",
            "reg [(SLV_WIDTH-1):0]\to_swb_data,\n\t\t// }}}\n\t\t// Master/DMA port\n\t\t// {{{",
            "output ",
            "wire o_mwb_cyc, o_mwb_stb, o_mwb_we,",
            "output ",
            "reg [(AW-1):0]\t\to_mwb_addr,",
            "output ",
            "reg [(BUS_WIDTH-1):0]\to_mwb_data,\n\t\t// Master/DMA wishbone responses from the bus",
            "input ",
            "wire i_mwb_stall, i_mwb_ack,",
            "input ",
            "wire [(BUS_WIDTH-1):0]\ti_mwb_data,",
            "input ",
            "wire i_mwb_err,\n\t\t// }}}\n\t\t// The interrupt device interrupt lines",
            "input ",
            "wire [31:0]\t\ti_dev_ints,\n\t\t// An interrupt to be set upon completion",
            "output ",
            "reg o_interrupt\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "localparam LGDV=5;",
            "localparam [2:0]\tDMA_IDLE\t= 3'b000,\n\t\t\t\tDMA_WAIT\t= 3'b001,\n\t\t\t\tDMA_READ_REQ\t= 3'b010,\n\t\t\t\tDMA_READ_ACK\t= 3'b011,\n\t\t\t\tDMA_PRE_WRITE\t= 3'b100,\n\t\t\t\tDMA_WRITE_REQ\t= 3'b101,\n\t\t\t\tDMA_WRITE_ACK\t= 3'b110;",
            "wire s_cyc, s_stb, s_we;",
            "wire [1:0]\t\ts_addr;",
            "wire [SLV_WIDTH-1:0]\ts_data;",
            "reg [2:0]\t\tdma_state;",
            "reg cfg_err, cfg_len_nonzero;",
            "reg [(AW-1):0]\tcfg_waddr, cfg_raddr, cfg_len;",
            "reg [(LGMEMLEN-1):0]\tcfg_blocklen_sub_one;",
            "reg cfg_incs, cfg_incd;",
            "reg [(LGDV-1):0]\tcfg_dev_trigger;",
            "reg cfg_on_dev_trigger;\n\n\t// Single block operations: We'll read, then write, up to a single\n\t// memory block here.",
            "reg [BUS_WIDTH-1:0]\tdma_mem\t[0:(((1<<LGMEMLEN))-1)];",
            "reg [(LGMEMLEN):0]\tnread, nwritten, nwacks, nracks;",
            "wire [(AW-1):0]\tbus_nracks;",
            "reg last_read_request, last_read_ack,\n\t\tlast_write_request, last_write_ack;",
            "reg trigger, abort, user_halt;",
            "wire [(LGMEMLEN):0]\tnext_nread;",
            "reg [(LGMEMLEN-1):0]\trdaddr;\n\t// }}}",
            "localparam [0:0]\tOPT_DELAY_BUS_ACCESS = 1;\n\n\tgenerate if (OPT_DELAY_BUS_ACCESS)\n\tbegin : DELAY_ACCESS\n\t\t// {{{",
            "reg r_s_cyc, r_s_stb, r_s_we;",
            "reg [1:0]\tr_s_addr;",
            "reg [SLV_WIDTH-1:0]\tr_s_data;\n\n\t\talways @(posedge i_clk)\n\t\t\tr_s_cyc <= i_swb_cyc;\n\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_s_stb <= 1'b0;\n\t\telse\n\t\t\tr_s_stb <= i_swb_stb;\n\n\t\talways @(posedge i_clk)\n\t\t\tr_s_we  <= i_swb_we;\n\t\talways @(posedge i_clk)\n\t\t\tr_s_addr<= i_swb_addr;\n\t\talways @(posedge i_clk)\n\t\t\tr_s_data<= i_swb_data;\n\n\t\tassign\ts_cyc = r_s_cyc;\n\t\tassign\ts_stb = r_s_stb;\n\t\tassign\ts_we  = r_s_we;\n\t\tassign\ts_addr= r_s_addr;\n\t\tassign\ts_data= r_s_data;\n\t\t// }}}\n\tend else begin : STRAIGHT_SLAVE_ACCESS\n\t\t// {{{\n\t\tassign\ts_cyc = i_swb_cyc;\n\t\tassign\ts_stb = i_swb_stb;\n\t\tassign\ts_we  = i_swb_we;\n\t\tassign\ts_addr= i_swb_addr;\n\t\tassign\ts_data= i_swb_data;\n\t\t// }}}\n\tend endgenerate\n\n\tassign\tbus_nracks = { {(AW-LGMEMLEN-1){1'b0}}, nracks };\n\n\t// Monster state machine\n\t// {{{\n\tinitial\tdma_state = DMA_IDLE;\n\tinitial\to_interrupt = 1'b0;\n\tinitial\tcfg_blocklen_sub_one = {(LGMEMLEN){1'b1}};\n\tinitial\tcfg_on_dev_trigger = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\t// {{{\n\t\tdma_state <= DMA_IDLE;\n\t\tcfg_on_dev_trigger <= 1'b0;\n\t\tcfg_incs  <= 1'b0;\n\t\tcfg_incd  <= 1'b0;\n\t\t// }}}\n\tend else case(dma_state)\n\tDMA_IDLE: begin\n\t\t// {{{\n\t\to_mwb_addr <= cfg_raddr;\n\n\t\t// When the slave wishbone writes, and we are in this\n\t\t// (ready) configuration, then allow the DMA to be controlled\n\t\t// and thus to start.\n\t\tif ((s_stb)&&(s_we))\n\t\tbegin\n\t\t\tcase(s_addr)\n\t\t\t2'b00: begin\n\t\t\t\tif ((s_data[27:16] == 12'hfed)\n\t\t\t\t\t&&(s_data[31:30] == 2'b00)\n\t\t\t\t\t\t&&(cfg_len_nonzero))\n\t\t\t\t\tdma_state <= DMA_WAIT;\n\t\t\t\tcfg_blocklen_sub_one\n\t\t\t\t\t<= s_data[(LGMEMLEN-1):0]\n\t\t\t\t\t+ {(LGMEMLEN){1'b1}};\n\t\t\t\t\t// i.e. -1;\n\t\t\t\tcfg_dev_trigger    <= s_data[14:10];\n\t\t\t\tcfg_on_dev_trigger <= s_data[15];\n\t\t\t\tcfg_incs  <= !s_data[29];\n\t\t\t\tcfg_incd  <= !s_data[28];\n\t\t\t\tend\n\t\t\t2'b01: begin end // This is done elsewhere\n\t\t\t2'b10: cfg_raddr <=  s_data[$clog2(BUS_WIDTH/8) +: AW];\n\t\t\t2'b11: cfg_waddr <=  s_data[$clog2(BUS_WIDTH/8) +: AW];\n\t\t\tendcase\n\t\tend end\n\t\t// }}}\n\tDMA_WAIT: begin\n\t\t// {{{\n\t\to_mwb_addr <= cfg_raddr;\n\t\tif (abort)\n\t\t\tdma_state <= DMA_IDLE;\n\t\telse if (user_halt)\n\t\t\tdma_state <= DMA_IDLE;\n\t\telse if (trigger)\n\t\t\tdma_state <= DMA_READ_REQ;\n\t\tend\n\t\t// }}}\n\tDMA_READ_REQ: begin\n\t\t// {{{\n\t\tif (!i_mwb_stall)\n\t\tbegin\n\t\t\t// Number of read acknowledgements needed\n\t\t\tif ((last_read_request)||(user_halt))\n\t//((nracks == {1'b0, cfg_blocklen_sub_one})||(bus_nracks == cfg_len-1))\n\t\t\t\t// Wishbone interruptus\n\t\t\t\tdma_state <= DMA_READ_ACK;\n\t\t\tif (cfg_incs)\n\t\t\t\to_mwb_addr <= o_mwb_addr\n\t\t\t\t\t\t+ {{(AW-1){1'b0}},1'b1};\n\t\tend\n\n\t\tif ((i_mwb_err)||(abort))\n\t\t\tdma_state <= DMA_IDLE;\n\t\telse if (i_mwb_ack)\n\t\tbegin\n\t\t\tif (cfg_incs)\n\t\t\t\tcfg_raddr  <= cfg_raddr\n\t\t\t\t\t\t+ {{(AW-1){1'b0}},1'b1};\n\t\t\tif (last_read_ack)\n\t\t\t\tdma_state <= DMA_PRE_WRITE;\n\t\tend end\n\t\t// }}}\n\tDMA_READ_ACK: begin\n\t\t// {{{\n\t\tif ((i_mwb_err)||(abort))\n\t\t\tdma_state <= DMA_IDLE;\n\t\telse if (i_mwb_ack)\n\t\tbegin\n\t\t\tif (last_read_ack) // (nread+1 == nracks)\n\t\t\t\tdma_state  <= DMA_PRE_WRITE;\n\t\t\tif (user_halt)\n\t\t\t\tdma_state <= DMA_IDLE;\n\t\t\tif (cfg_incs)\n\t\t\t\tcfg_raddr  <= cfg_raddr\n\t\t\t\t\t\t+ {{(AW-1){1'b0}},1'b1};\n\t\tend end\n\t\t// }}}\n\tDMA_PRE_WRITE: begin\n\t\t// {{{\n\t\to_mwb_addr <= cfg_waddr;\n\t\tdma_state <= (abort)? DMA_IDLE : DMA_WRITE_REQ;\n\t\tend\n\t\t// }}}\n\tDMA_WRITE_REQ: begin\n\t\t// {{{\n\t\tif (!i_mwb_stall)\n\t\tbegin\n\t\t\tif (last_write_request) // (nwritten == nread-1)\n\t\t\t\t// Wishbone interruptus\n\t\t\t\tdma_state <= DMA_WRITE_ACK;\n\t\t\tif (cfg_incd)\n\t\t\tbegin\n\t\t\t\to_mwb_addr <= o_mwb_addr\n\t\t\t\t\t\t+ {{(AW-1){1'b0}},1'b1};\n\t\t\t\tcfg_waddr  <= cfg_waddr\n\t\t\t\t\t\t+ {{(AW-1){1'b0}},1'b1};\n\t\t\tend\n\t\tend\n\n\t\tif ((i_mwb_err)||(abort))\n\t\t\tdma_state <= DMA_IDLE;\n\t\telse if ((i_mwb_ack)&&(last_write_ack))\n\t\t\tdma_state <= (cfg_len <= 1) ? DMA_IDLE: DMA_WAIT;\n\t\telse if (!cfg_len_nonzero)\n\t\t\tdma_state <= DMA_IDLE;\n\t\tend\n\t\t// }}}\n\tDMA_WRITE_ACK: begin\n\t\t// {{{\n\t\tif ((i_mwb_err)||(abort))\n\t\t\tdma_state <= DMA_IDLE;\n\t\telse if ((i_mwb_ack)&&(last_write_ack))\n\t\t\t// (nwacks+1 == nwritten)\n\t\t\tdma_state <= (cfg_len <= 1)? DMA_IDLE: DMA_WAIT;\n\t\telse if (!cfg_len_nonzero)\n\t\t\tdma_state <= DMA_IDLE;\n\t\tend\n\t\t// }}}\n\tdefault:\n\t\tdma_state <= DMA_IDLE;\n\tendcase\n\t// }}}\n\n\t// o_interrupt\n\t// {{{\n\tinitial\to_interrupt = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_interrupt <= 1'b0;\n\telse\n\t\to_interrupt <= ((dma_state == DMA_WRITE_ACK)&&(i_mwb_ack)\n\t\t\t\t\t&&(last_write_ack)\n\t\t\t\t\t&&(cfg_len == {{(AW-1){1'b0}},1'b1}))\n\t\t\t\t||((dma_state != DMA_IDLE)&&(i_mwb_err));\n\t// }}}\n\n\t// cfg_len, cfg_len_nonzero\n\t// {{{\n\tinitial\tcfg_len     = 0;\n\tinitial\tcfg_len_nonzero = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\tcfg_len <= 0;\n\t\tcfg_len_nonzero <= 1'b0;\n\tend else if ((dma_state == DMA_IDLE)\n\t\t\t&&(s_stb)&&(s_we)&&(s_addr == 2'b01))\n\tbegin\n\t\tcfg_len   <=  s_data[(AW-1):0];\n\t\tcfg_len_nonzero <= (|s_data[(AW-1):0]);\n\tend else if ((o_mwb_cyc)&&(o_mwb_we)&&(i_mwb_ack))\n\tbegin\n\t\tcfg_len <= cfg_len - 1'b1;\n\t\tcfg_len_nonzero <= (cfg_len > 1);\n\tend\n\t// }}}\n\n\t// nracks\n\t// {{{\n\tinitial\tnracks   = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tnracks <= 0;\n\telse if ((dma_state == DMA_IDLE)||(dma_state == DMA_WAIT))\n\t\tnracks <= 0;\n\telse if ((o_mwb_stb)&&(!o_mwb_we)&&(!i_mwb_stall))\n\t\tnracks <= nracks + 1'b1;\n\t// }}}\n\n\t// nread\n\t// {{{\n\tinitial\tnread   = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tnread <= 0;\n\telse if ((dma_state == DMA_IDLE)||(dma_state == DMA_WAIT))\n\t\tnread <= 0;\n\telse if ((!o_mwb_we)&&(i_mwb_ack))\n\t\tnread <= nread + 1'b1;\n\t// }}}\n\n\t// nwritten\n\t// {{{\n\tinitial\tnwritten = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tnwritten <= 0;\n\telse if ((!o_mwb_cyc)||(!o_mwb_we))\n\t\tnwritten <= 0;\n\telse if ((o_mwb_stb)&&(!i_mwb_stall))\n\t\tnwritten <= nwritten + 1'b1;\n\t// }}}\n\n\t// nwacks\n\t// {{{\n\tinitial\tnwacks   = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tnwacks <= 0;\n\telse if ((!o_mwb_cyc)||(!o_mwb_we))\n\t\tnwacks <= 0;\n\telse if (i_mwb_ack)\n\t\tnwacks <= nwacks + 1'b1;\n\t// }}}\n\n\t// cfg_err\n\t// {{{\n\tinitial\tcfg_err = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tcfg_err <= 1'b0;\n\telse if (dma_state == DMA_IDLE)\n\tbegin\n\t\tif ((s_stb)&&(s_we)&&(s_addr==2'b00))\n\t\t\tcfg_err <= 1'b0;\n\tend else if (((i_mwb_err)&&(o_mwb_cyc))||(abort))\n\t\tcfg_err <= 1'b1;\n\t// }}}\n\n\t// last_read_request\n\t// {{{\n\tinitial\tlast_read_request = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tlast_read_request <= 1'b0;\n\telse if ((dma_state == DMA_WAIT)||(dma_state == DMA_READ_REQ))\n\tbegin\n\t\tif ((!i_mwb_stall)&&(dma_state == DMA_READ_REQ))\n\t\tbegin\n\t\t\tlast_read_request <=\n\t\t\t(nracks + 1 == { 1'b0, cfg_blocklen_sub_one})\n\t\t\t\t||(bus_nracks == cfg_len-2);\n\t\tend else\n\t\t\tlast_read_request <=\n\t\t\t\t(nracks== { 1'b0, cfg_blocklen_sub_one})\n\t\t\t\t||(bus_nracks == cfg_len-1);\n\tend else\n\t\tlast_read_request <= 1'b0;\n\t// }}}\n\n\tassign\tnext_nread = nread + 1'b1;\n\n\t// last_read_ack\n\t// {{{\n\tinitial\tlast_read_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tlast_read_ack <= 0;\n\telse if (dma_state == DMA_READ_REQ)\n\tbegin\n\t\tif ((i_mwb_ack)&&((!o_mwb_stb)||(i_mwb_stall)))\n\t\t\tlast_read_ack <= (next_nread == { 1'b0, cfg_blocklen_sub_one });\n\t\telse\n\t\t\tlast_read_ack <= (nread == { 1'b0, cfg_blocklen_sub_one });\n\tend else if (dma_state == DMA_READ_ACK)\n\tbegin\n\t\tif ((i_mwb_ack)&&((!o_mwb_stb)||(i_mwb_stall)))\n\t\t\tlast_read_ack <= (nread+2 == nracks);\n\t\telse\n\t\t\tlast_read_ack <= (next_nread == nracks);\n\tend else\n\t\tlast_read_ack <= 1'b0;\n\t// }}}\n\n\t// last_write_request\n\t// {{{\n\tinitial\tlast_write_request = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tlast_write_request <= 1'b0;\n\telse if (dma_state == DMA_PRE_WRITE)\n\t\tlast_write_request <= (nread <= 1);\n\telse if (dma_state == DMA_WRITE_REQ)\n\tbegin\n\t\tif (i_mwb_stall)\n\t\t\tlast_write_request <= (nwritten >= nread-1);\n\t\telse\n\t\t\tlast_write_request <= (nwritten >= nread-2);\n\tend else\n\t\tlast_write_request <= 1'b0;\n\t// }}}\n\n\t// last_write_ack\n\t// {{{\n\tinitial\tlast_write_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tlast_write_ack <= 1'b0;\n\telse if((dma_state == DMA_WRITE_REQ)||(dma_state == DMA_WRITE_ACK))\n\tbegin\n\t\tif ((i_mwb_ack)&&((!o_mwb_stb)||(i_mwb_stall)))\n\t\t\tlast_write_ack <= (nwacks+2 == nwritten);\n\t\telse\n\t\t\tlast_write_ack <= (nwacks+1 == nwritten);\n\tend else\n\t\tlast_write_ack <= 1'b0;\n\t// }}}\n\n\tassign\to_mwb_cyc = (dma_state == DMA_READ_REQ)\n\t\t\t||(dma_state == DMA_READ_ACK)\n\t\t\t||(dma_state == DMA_WRITE_REQ)\n\t\t\t||(dma_state == DMA_WRITE_ACK);\n\n\tassign\to_mwb_stb = (dma_state == DMA_READ_REQ)\n\t\t\t||(dma_state == DMA_WRITE_REQ);\n\n\tassign\to_mwb_we = (dma_state == DMA_PRE_WRITE)\n\t\t\t||(dma_state == DMA_WRITE_REQ)\n\t\t\t||(dma_state == DMA_WRITE_ACK);\n\n\t// rdaddr\n\t// {{{\n\t// This is tricky.  In order for Vivado to consider dma_mem to be a\n\t// proper memory, it must have a simple address fed into it.  Hence\n\t// the read_address (rdaddr)",
            "reg ister.  The problem is that this\n\t//",
            "reg ister must always be one greater than the address we actually\n\t// want to read from, unless we are idling.  So ... the math is touchy.\n\t//\n\n\tinitial\trdaddr = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\trdaddr <= 0;\n\telse if((dma_state == DMA_IDLE)||(dma_state == DMA_WAIT)\n\t\t\t||(dma_state == DMA_WRITE_ACK))\n\t\trdaddr <= 0;\n\telse if ((dma_state == DMA_PRE_WRITE)\n\t\t\t||((dma_state == DMA_WRITE_REQ)&&(!i_mwb_stall)))\n\t\trdaddr <= rdaddr + {{(LGMEMLEN-1){1'b0}},1'b1};\n\t// }}}\n\n\t// o_mwb_data\n\t// {{{\n\talways @(posedge i_clk)\n\t// if (i_reset)\n\t//\to_mwb_data <= 0;\n\t// else\n\tif ((dma_state != DMA_WRITE_REQ)||(!i_mwb_stall))\n\t\to_mwb_data <= dma_mem[rdaddr];\n\n\talways @(posedge i_clk)\n\tif((dma_state == DMA_READ_REQ)||(dma_state == DMA_READ_ACK))\n\t\tdma_mem[nread[(LGMEMLEN-1):0]] <= i_mwb_data;\n\t// }}}\n\n\t// o_swb_data\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_swb_data <= 0;\n\telse casez(s_addr)\n\t\t2'b00: o_swb_data <= {\t(dma_state != DMA_IDLE), cfg_err,\n\t\t\t\t\t!cfg_incs, !cfg_incd,\n\t\t\t\t\t1'b0, nread,\n\t\t\t\t\tcfg_on_dev_trigger, cfg_dev_trigger,\n\t\t\t\t\tcfg_blocklen_sub_one\n\t\t\t\t\t};\n\t\t2'b01: o_swb_data <= { {(SLV_WIDTH-AW){1'b0}}, cfg_len  };\n\t\t2'b10: o_swb_data <= { {(SLV_WIDTH-$clog2(BUS_WIDTH/8)-AW){1'b0}}, cfg_raddr, {($clog2(BUS_WIDTH/8)){1'b0}} };\n\t\t2'b11: o_swb_data <= { {(SLV_WIDTH-$clog2(BUS_WIDTH/8)-AW){1'b0}}, cfg_waddr,  {($clog2(BUS_WIDTH/8)){1'b0}} };\n\tendcase\n\t// }}}\n\n\t// trigger\n\t// {{{\n\t// This causes us to wait a minimum of two clocks before starting: One\n\t// to go into the wait state, and then one while in the wait state to\n\t// develop the trigger.\n\tinitial\ttrigger = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\ttrigger <= 1'b0;\n\telse\n\t\ttrigger <=  (dma_state == DMA_WAIT)\n\t\t\t\t&&((!cfg_on_dev_trigger)\n\t\t\t\t\t||(i_dev_ints[cfg_dev_trigger]));\n\t// }}}\n\n\t// o_swb_ack\n\t// {{{\n\t// Ack any access.  We'll quietly ignore any access where we are busy,\n\t// but ack it anyway.  In other words, before writing to the device,\n\t// double check that it isn't busy, and then write.\n\tinitial\to_swb_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_swb_ack <= 1'b0;\n\telse if (!i_swb_cyc)\n\t\to_swb_ack <= 1'b0;\n\telse\n\t\to_swb_ack <= (s_stb);\n\t// }}}\n\n\tassign\to_swb_stall = 1'b0;\n\n\t// abort\n\t// {{{\n\tinitial\tabort = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tabort <= 1'b0;\n\telse if (dma_state == DMA_IDLE)\n\t\tabort <= 1'b0;\n\telse\n\t\tabort <= ((s_stb)&&(s_we)\n\t\t\t&&(s_addr == 2'b00)\n\t\t\t&&(s_data == 32'hffed0000));\n\t// }}}\n\n\t// user_halt\n\t// {{{\n\tinitial\tuser_halt = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tuser_halt <= 1'b0;\n\telse\n\t\tuser_halt <= ((user_halt)&&(dma_state != DMA_IDLE))\n\t\t\t||((s_stb)&&(s_we)&&(dma_state != DMA_IDLE)\n\t\t\t\t&&(s_addr == 2'b00)\n\t\t\t\t&&(s_data == 32'hafed0000));\n\t// }}}\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = s_cyc;\n\t// verilator lint_on  UNUSED\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "reg f_past_valid;",
            "wire [LGMEMLEN:0]\tf_npending;\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\t\tassert(dma_state == DMA_IDLE);\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "parameter F_SLV_LGDEPTH = 3;",
            "parameter F_MSTR_LGDEPTH = LGMEMLEN+1;",
            "wire [F_SLV_LGDEPTH-1:0] f_swb_nreqs, f_swb_nacks, f_swb_outstanding;",
            "wire [F_MSTR_LGDEPTH-1:0] f_mwb_nreqs, f_mwb_nacks, f_mwb_outstanding;\n\n\tfwb_slave #(\n\t\t// {{{\n\t\t.AW(2), .DW(SLV_WIDTH), .F_MAX_STALL(0), .F_MAX_ACK_DELAY(2),\n\t\t\t.F_LGDEPTH(F_SLV_LGDEPTH)\n\t\t// }}}\n\t) control_port(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\ti_swb_cyc, i_swb_stb, i_swb_we, i_swb_addr, i_swb_data,4'b1111,\n\t\t\to_swb_ack, o_swb_stall, o_swb_data, 1'b0,\n\t\t\tf_swb_nreqs, f_swb_nacks, f_swb_outstanding\n\t\t// }}}\n\t);\n\n\talways @(*)\n\t\tassert(o_swb_stall == 0);\n\n\tgenerate if (OPT_DELAY_BUS_ACCESS)\n\tbegin : F_DELAY_BUS\n\t\t// {{{\n\t\talways @(*)\n\t\tif ((!i_reset)&&(i_swb_cyc))\n\t\tbegin\n\t\t\tif ((!s_stb)&&(!o_swb_ack))\n\t\t\tbegin\n\t\t\t\tassert(f_swb_outstanding == 0);\n\t\t\tend else if ((s_stb)&&(!o_swb_ack))\n\t\t\tbegin\n\t\t\t\tassert(f_swb_outstanding == 1);\n\t\t\tend else if ((!s_stb)&&(o_swb_ack))\n\t\t\tbegin\n\t\t\t\tassert(f_swb_outstanding == 1);\n\t\t\tend else if ((s_stb)&&(o_swb_ack))\n\t\t\t\tassert(f_swb_outstanding == 2);\n\t\tend\n\t\t// }}}\n\tend else begin\n\t\t// {{{\n\t\talways @(*)\n\t\tif (!i_reset)\n\t\t\tassert(f_swb_outstanding == (o_swb_ack ? 1:0));\n\t\t// }}}\n\tend endgenerate\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.AW(AW), .DW(BUS_WIDTH), .F_MAX_STALL(4), .F_MAX_ACK_DELAY(8),\n\t\t\t.F_LGDEPTH(F_MSTR_LGDEPTH),\n\t\t\t.F_OPT_RMW_BUS_OPTION(1'b1),\n\t\t\t.F_OPT_DISCONTINUOUS(1'b0),\n\t\t\t.F_OPT_SOURCE(1'b1)\n\t\t// }}}\n\t) external_bus(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\to_mwb_cyc, o_mwb_stb, o_mwb_we, o_mwb_addr, o_mwb_data,\n\t\t\t{(BUS_WIDTH/8){1'b1}},\n\t\t\ti_mwb_ack, i_mwb_stall, i_mwb_data, i_mwb_err,\n\t\t\tf_mwb_nreqs, f_mwb_nacks, f_mwb_outstanding\n\t\t// }}}\n\t);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(dma_state == DMA_IDLE)))\n\t\tassert(o_mwb_cyc == 1'b0);\n\n\talways @(*)\n\tif ((o_mwb_cyc)&&(!o_mwb_we))\n\tbegin\n\t\tassert(nracks == f_mwb_nreqs);\n\t\tassert(nread == f_mwb_nacks);\n\tend\n\n\talways @(*)\n\tif ((o_mwb_cyc)&&(o_mwb_we))\n\tbegin\n\t\tassert(nwacks   == f_mwb_nacks);\n\t\tassert(nwritten == f_mwb_nreqs);\n\tend\n\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(abort))&&($past(dma_state != DMA_IDLE)))\n\t\tassert(dma_state == DMA_IDLE);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_mwb_cyc))&&(o_mwb_cyc)&&(\n\t\t\t((  !cfg_incs)&&(!o_mwb_we))\n\t\t\t||((!cfg_incd)&&( o_mwb_we))))\n\tbegin\n\t\tassert(o_mwb_addr == $past(o_mwb_addr));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_mwb_cyc))&&(\n\t\t\t((!cfg_incs)||($past(o_mwb_we))||(!$past(i_mwb_ack)))))\n\t\tassert(cfg_raddr == $past(cfg_raddr));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(dma_state == DMA_WRITE_REQ))\n\t\tassert(cfg_waddr == o_mwb_addr);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t\t&&($past(o_mwb_stb))&&(!$past(i_mwb_stall)))\n\tbegin\n\t\tassert(   ((!cfg_incs)&&(!$past(o_mwb_we)))\n\t\t\t||((!cfg_incd)&&( $past(o_mwb_we)))\n\t\t\t||(o_mwb_addr==$past(o_mwb_addr)+1'b1));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(o_mwb_cyc))&&(o_mwb_cyc))\n\tbegin\n\t\tif (o_mwb_we)\n\t\tbegin\n\t\t\tassert(o_mwb_addr == cfg_waddr);\n\t\tend else\n\t\t\tassert(o_mwb_addr == cfg_raddr);\n\tend\n\n\talways @(*)\n\t\tassert(cfg_len_nonzero == (cfg_len != 0));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_reset)))\n\tbegin\n\t\tassert(cfg_len == 0);\n\t\tassert(!cfg_len_nonzero);\n\tend else if ((f_past_valid)&&($past(o_mwb_cyc)))\n\tbegin\n\t\tif (($past(i_mwb_ack))&&($past(o_mwb_we)))\n\t\tbegin\n\t\t\tassert(cfg_len == $past(cfg_len)-1'b1);\n\t\tend else\n\t\t\tassert(cfg_len == $past(cfg_len));\n\tend else if ((f_past_valid)&&(($past(dma_state) != DMA_IDLE)\n\t\t\t||(!$past(s_stb))||(!$past(s_we))\n\t\t\t||($past(s_addr)!=2'b01)))\n\t\tassert(cfg_len == $past(cfg_len));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_mwb_cyc))&&($past(cfg_len == 0))\n\t\t\t&&(!$past(user_halt)))\n\tbegin\n\t\tassert(cfg_len == 0);\n\t\tassert((dma_state != $past(dma_state))||(!o_mwb_cyc));\n\tend\n\n\talways @(posedge i_clk)\n\tif (cfg_len == 0)\n\t\tassert(!o_mwb_stb);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(dma_state) != DMA_IDLE))\n\tbegin\n\t\tassert(cfg_incs == $past(cfg_incs));\n\t\tassert(cfg_incd == $past(cfg_incd));\n\t\tassert(cfg_blocklen_sub_one == $past(cfg_blocklen_sub_one));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(dma_state) == DMA_IDLE))\n\t\tassert(cfg_len_nonzero == (cfg_len != 0));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(o_mwb_cyc))||(!$past(o_mwb_we)))\n\t\tassert((nwritten == 0)&&(nwacks == 0));\n\talways @(posedge i_clk)\n\tif ((o_mwb_cyc)&&(!o_mwb_we))\n\t\tassert(bus_nracks <= cfg_len);\n\n\talways @(posedge i_clk)\n\tif ((o_mwb_cyc)&&(!o_mwb_we))\n\t\tassert(nread <= nracks);\n\n\talways @(posedge i_clk)\n\tif ((o_mwb_cyc)&&(o_mwb_we))\n\t\tassert(nwritten-nwacks\n\t\t\t+((o_mwb_stb)? 1'b1:1'b0)\n\t\t\t- f_mwb_outstanding\n\t\t\t// -((i_mwb_ack)? 1'b1:1'b0)\n\t\t\t<= cfg_len);\n\talways @(*)\n\t\tassert(f_mwb_outstanding\n\t\t\t+ ((o_mwb_stb)? 1'b1:1'b0) <= cfg_len);",
            "wire [LGMEMLEN:0]\tf_cfg_blocklen;\n\tassign\tf_cfg_blocklen = { 1'b0, cfg_blocklen_sub_one}  + 1'b1;\n\n\talways @(*)\n\tif (dma_state == DMA_WAIT)\n\t\tassert(cfg_len > 0);\n\n\talways @(*)\n\tif ((o_mwb_stb)&&(o_mwb_we))\n\t\tassert(nread == nracks);\n\n\talways @(*)\n\tif (o_mwb_stb)\n\t\tassert(nwritten <= cfg_blocklen_sub_one);\n\n\talways @(posedge i_clk)\n\t\tassert(nwritten <= f_cfg_blocklen);\n\n\talways @(*)\n\tif ((o_mwb_stb)&&(!o_mwb_we))\n\tbegin\n\t\tassert(nracks < f_cfg_blocklen);\n\tend else\n\t\tassert(nracks <= f_cfg_blocklen);\n\n\talways @(*)\n\tif ((o_mwb_cyc)&&(i_mwb_ack)&&(!o_mwb_we))\n\t\tassert(nread < f_cfg_blocklen);\n\n\talways @(*)\n\t\tassert(nread <= nracks);\n\n\talways @(*)\n\tif ((o_mwb_cyc)&&(o_mwb_we)&&(!user_halt))\n\t\tassert(nread == nracks);\n\n\talways @(*)\n\tif ((o_mwb_cyc)&&(o_mwb_we))\n\t\tassert(nwritten >= nwacks);\n\n\talways @(*)\n\tif (dma_state == DMA_WRITE_REQ)\n\t\tassert(last_write_request == (nwritten == nread-1));\n\n\talways @(*)\n\t\tassert(nwritten >= nwacks);\n\n\talways @(*)\n\t\tassert(nread >= nwritten);\n\n\talways @(*)\n\t\tassert(nracks >= nread);\n\n\tassign\tf_npending = nread-nwacks;\n\n\talways @(*)\n\tif (dma_state != DMA_IDLE)\n\t\tassert({ {(AW-LGMEMLEN-1){1'b0}}, f_npending} <= cfg_len);\n\n\talways @(posedge i_clk)\n\tbegin\n\t\tassert(cfg_len_nonzero == (cfg_len != 0));\n\t\tif ((f_past_valid)&&($past(dma_state != DMA_IDLE))&&($past(cfg_len == 0)))\n\t\t\tassert(cfg_len == 0);\n\tend\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "ziptimer.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/ziptimer.v",
        "chunks": [
            "reg ister for both control and value, and ...\n//\t\tThe reload value is set any time the timer data value is \"set\".\n//\t\tReading the",
            "reg ister returns the timer value.  Controls are\n//\t\tset so that writing a value to the timer automatically starts\n//\t\tit counting down.\n//\t2. Two",
            "reg isters, one for control one for value.\n//\t\tThe control",
            "reg ister would have the reload value in it.\n//\tOn the clock when the interface is set to zero the interrupt is set.\n//\t\tHence setting the timer to zero will disable the timer without\n//\t\tsetting any interrupts.  Thus setting it to five will count\n//\t\t5 clocks: 5, 4, 3, 2, 1, Interrupt.\n//\n//\n//\tControl bits:\n//\t\t(Start_n/Stop.  This bit has been dropped.  Writing to this\n//\t\t\ttimer any value but zero starts it.  Writing a zero\n//\t\t\tclears and stops it.)\n//\t\tAutoReload.  If set, then on reset the timer automatically\n//\t\t\tloads the last set value and starts over.  This is\n//\t\t\tuseful for distinguishing between a one-time interrupt\n//\t\t\ttimer, and a repetitive interval timer.\n//\t\t(INTEN.  Interrupt enable--reaching zero always creates an\n//\t\t\tinterrupt, so this control bit isn't needed.  The\n//\t\t\tinterrupt controller can be used to mask the interrupt.)\n//\t\t(COUNT-DOWN/UP: This timer is *only* a count-down timer.\n//\t\t\tThere is no means of setting it to count up.)\n//\tWatchDog\n//\t\tThis timer can be implemented as a watchdog timer simply by\n//\t\tconnecting the interrupt line to the reset line of the CPU.\n//\t\tWhen the timer then expires, it will trigger a CPU reset.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module ziptimer #(\n\t\t// {{{",
            "parameter BW = 32, VW = (BW-1),",
            "parameter [0:0]\tRELOADABLE = 1\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset, i_ce,\n\t\t// Wishbone",
            "input s",
            "input ",
            "wire i_wb_cyc, i_wb_stb, i_wb_we,",
            "input ",
            "wire [BW-1:0]\ti_wb_data,",
            "input ",
            "wire [BW/8-1:0]\ti_wb_sel,\n\t\t// Wishbone",
            "output s",
            "output ",
            "wire o_wb_stall,",
            "output ",
            "reg o_wb_ack,",
            "output ",
            "wire [BW-1:0]\to_wb_data,\n\t\t// Interrupt line",
            "output ",
            "reg o_int\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "reg r_running;",
            "reg r_zero  = 1'b1;",
            "reg [(VW-1):0]\tr_value;",
            "wire wb_write;",
            "wire auto_reload;",
            "wire [(VW-1):0]\tinterval_count;\n\t// }}}\n\n\tassign\twb_write = ((i_wb_stb)&&(i_wb_we));\n\n\t// r_running\n\t// {{{\n\tinitial\tr_running = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_running <= 1'b0;\n\telse if (wb_write)\n\t\tr_running <= (|i_wb_data[(VW-1):0]);\n\telse if ((r_zero)&&(!auto_reload))\n\t\tr_running <= 1'b0;\n\t// }}}\n\n\t// r_auto_reload, r_interval_count\n\t// {{{\n\tgenerate\n\tif (RELOADABLE != 0)\n\tbegin : GEN_RELOAD\n\t\t// {{{",
            "reg r_auto_reload;",
            "reg [(VW-1):0]\tr_interval_count;\n\n\t\t// r_auto_reload\n\t\t// {{{\n\t\tinitial\tr_auto_reload = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_auto_reload <= 1'b0;\n\t\telse if (wb_write)\n\t\t\tr_auto_reload <= (i_wb_data[(BW-1)])\n\t\t\t\t\t&&(|i_wb_data[(VW-1):0]);\n\t\t// }}}\n\n\t\tassign\tauto_reload = r_auto_reload;\n\n\t\t// r_interval_count\n\t\t// {{{\n\t\t// If setting auto-reload mode, and the value to other\n\t\t// than zero, set the auto-reload value\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_interval_count <= 0;\n\t\telse if (wb_write)\n\t\t\tr_interval_count <= i_wb_data[(VW-1):0];\n\t\t// }}}\n\n\t\tassign\tinterval_count = r_interval_count;\n\t\t// }}}\n\tend else begin : NO_AUTO_RELOAD\n\t\t// {{{\n\t\tassign\tauto_reload = 1'b0;\n\t\tassign\tinterval_count = 0;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// r_value\n\t// {{{\n\tinitial\tr_value = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_value <= 0;\n\telse if (wb_write)\n\t\tr_value <= i_wb_data[(VW-1):0];\n\telse if ((i_ce)&&(r_running))\n\tbegin\n\t\tif (!r_zero)\n\t\t\tr_value <= r_value - 1'b1;\n\t\telse if (auto_reload)\n\t\t\tr_value <= interval_count;\n\tend\n\t// }}}\n\n\t// r_zero\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_zero <= 1'b1;\n\telse if (wb_write)\n\t\tr_zero <= (i_wb_data[(VW-1):0] == 0);\n\telse if ((r_running)&&(i_ce))\n\tbegin\n\t\tif (r_value == { {(VW-1){1'b0}}, 1'b1 })\n\t\t\tr_zero <= 1'b1;\n\t\telse if ((r_zero)&&(auto_reload))\n\t\t\tr_zero <= 1'b0;\n\tend\n\t// }}}\n\n\t// o_int\n\t// {{{\n\t// Set the interrupt on our last tick, as we transition from one to\n\t// zero.\n\tinitial\to_int   = 1'b0;\n\talways @(posedge i_clk)\n\tif ((i_reset)||(wb_write)||(!i_ce))\n\t\to_int <= 1'b0;\n\telse // if (i_ce)\n\t\to_int <= (r_value == { {(VW-1){1'b0}}, 1'b1 });\n\t// }}}\n\n\t// o_wb_ack\n\t// {{{\n\tinitial\to_wb_ack = 1'b0;\n\talways @(posedge i_clk)\n\t\to_wb_ack <= (!i_reset)&&(i_wb_stb);\n\t// }}}\n\tassign\to_wb_stall = 1'b0;\n\n\t// o_wb_data\n\t// {{{\n\tgenerate if (VW < BW-1)\n\tbegin : GEN_TRIM\n\t\tassign\to_wb_data = { auto_reload, {(BW-1-VW){1'b0}}, r_value };\n\tend else begin : NO_TRIM\n\t\tassign\to_wb_data = { auto_reload, r_value };\n\tend endgenerate\n\t// }}}\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, i_wb_cyc, i_wb_data, i_wb_sel };\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\tinitial\tassume(i_reset);\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\tbegin\n\t\tassert(r_value     == 0);\n\t\tassert(r_running   == 0);\n\t\tassert(auto_reload == 0);\n\t\tassert(r_zero      == 1'b1);\n\tend\n\n\n\talways @(*)\n\tif (i_wb_stb)\n\t\tassume(i_wb_cyc);\n\n\talways @(*)\n\t\tassert(r_zero == (r_value == 0));\n\n\talways @(*)\n\tif (r_value != 0)\n\t\tassert(r_running);\n\n\talways @(*)\n\tif (auto_reload)\n\t\tassert(r_running);\n\n\talways @(*)\n\tif (!RELOADABLE)\n\t\tassert(auto_reload == 0);\n\n\talways @(*)\n\tif (auto_reload)\n\t\tassert(interval_count != 0);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(r_value)==0)\n\t\t\t&&(!$past(wb_write))&&(!$past(auto_reload)))\n\t\tassert(r_value == 0);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&(!$past(wb_write))\n\t\t\t&&($past(r_value)==0)&&($past(auto_reload)))\n\tbegin\n\t\tif ($past(i_ce))\n\t\tbegin\n\t\t\tassert(r_value == interval_count);\n\t\tend else\n\t\t\tassert(r_value == $past(r_value));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t\t&&(!$past(wb_write))&&($past(r_value)!=0))\n\tbegin\n\t\tif ($past(i_ce))\n\t\tbegin\n\t\t\tassert(r_value == $past(r_value)-1'b1);\n\t\tend else\n\t\t\tassert(r_value == $past(r_value));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(wb_write)))\n\t\tassert(r_value == $past(i_wb_data[(VW-1):0]));\n\n\t// Check auto_reload\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset) || !RELOADABLE)\n\tbegin\n\t\tassert(!auto_reload);\n\tend else if ($past(wb_write))\n\tbegin\n\t\tif (!$past(i_wb_data[BW-1]))\n\t\tbegin\n\t\t\tassert(!auto_reload);\n\t\tend else\n\t\t\tassert(auto_reload == $past(|i_wb_data[VW-1:0]));\n\tend else\n\t\tassert($stable(auto_reload));\n\t// }}}\n\n\talways @(posedge i_clk)\n\tif (!(f_past_valid)||($past(i_reset)))\n\tbegin\n\t\tassert(!o_int);\n\tend else if (($past(wb_write))||(!$past(i_ce)))\n\tbegin\n\t\tassert(!o_int);\n\tend else\n\t\tassert(o_int == ((r_running)&&(r_value == 0)));\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\tbegin\n\t\tassert(!o_wb_ack);\n\tend else if ($past(i_wb_stb))\n\t\tassert(o_wb_ack);\n\n\talways @(*)\n\t\tassert(!o_wb_stall);\n\talways @(*)\n\t\tassert(o_wb_data[BW-1] == auto_reload);\n\talways @(*)\n\t\tassert(o_wb_data[VW-1:0] == r_value);\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipjiffies.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/zipjiffies.v",
        "chunks": [
            "reg ister: a counter.  Reads from the\n//",
            "reg ister return the current value of the counter.  Writes within\n//\tthe (N-1) bit space following the current time set an interrupt.\n//\tWrites of values that occurred in the last 2^(N-1) ticks will be\n//\tignored.  The timer then interrupts when its value equals that time.\n//\tMultiple writes cause the jiffies timer to select the nearest possible\n//\tinterrupt.  Upon an interrupt, the next interrupt time/value is cleared\n//\tand will need to be reset if the CPU wants to get notified again.  With\n//\tonly the single interface, there is no way of knowing when the next\n//\tinterrupt is scheduled for, neither is there any way to slow down the\n//\tinterrupt timer in case you don't want it overflowing as often and you\n//\twish to wait more jiffies than it supports.  Thus, currently, if you\n//\thave a timer you wish to wait upon that is more than 2^31 into the\n//\tfuture, you would need to set timers along the way, wake up on those\n//\ttimers, and set further timer's until you finally get to your\n//\tdestination.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module zipjiffies #(",
            "parameter BW = 32\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset, i_ce,\n\t\t// Wishbone",
            "input s",
            "input ",
            "wire i_wb_cyc, i_wb_stb, i_wb_we,",
            "input ",
            "wire [(BW-1):0]\ti_wb_data,",
            "input ",
            "wire [BW/8-1:0]\ti_wb_sel,\n\t\t// Wishbone",
            "output s",
            "output ",
            "wire o_wb_stall,",
            "output ",
            "reg o_wb_ack,",
            "output ",
            "wire [(BW-1):0]\to_wb_data,\n\t\t// Interrupt line",
            "output ",
            "reg o_int\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "reg [(BW-1):0]\t\tr_counter;\n\t//",
            "reg int_set,  new_set, int_now;",
            "reg [(BW-1):0]\tint_when, new_when;",
            "reg signed\t[(BW-1):0]\ttill_wb,  till_when;\n\t// }}}\n\n\t// r_counter\n\t// {{{\n\t// Our counter",
            "logic : The counter is always counting up--it cannot\n\t// be stopped or altered.  It's really quite simple.  Okay, not quite.\n\t// We still support the clock enable line.  We do this in order to\n\t// support debugging, so that if we get everything running inside a\n\t// debugger, the timer's all slow down so that everything can be stepped\n\t// together, one clock at a time.\n\t//\n\tinitial\tr_counter = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_counter <= 0;\n\telse if (i_ce)\n\t\tr_counter <= r_counter+1;\n\t// }}}\n\n\t// int_now\n\t// {{{\n\tinitial\tint_now = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tint_now <= 0;\n\telse if (i_ce)\n\t\tint_now <= ((r_counter + 1) == (int_when));\n\telse\n\t\tint_now <= 1'b0;\n\t// }}}\n\n\t// new_set, new_when\n\t// {{{\n\t// Writes to the counter set an interrupt--but only if they are in the\n\t// future as determined by the signed result of an unsigned subtract.\n\t//\n\t// assign\ttill_when = int_when-r_counter;\n\t// assign\ttill_wb   = new_when-r_counter;\n\n\tinitial\tnew_set = 1'b0;\n\talways @(posedge i_clk)\n\tbegin\n\t\t// Delay WB commands (writes) by a clock to simplify our",
            "logic new_set <= (i_wb_stb && i_wb_we);\n\t\t// new_when is a don't care when new_set = 0, so don't worry\n\t\t// about setting it at all times.\n\t\tnew_when<= i_wb_data;\n\n\t\ttill_wb <= (i_wb_data - r_counter - (i_ce ? 1:0));\n\n\t\ttill_when <= (int_when - i_wb_data);\n\n\t\tif (i_reset)\n\t\t\tnew_set <= 1'b0;\n\tend\n\t// }}}\n\n\t// o_int, int_set\n\t// {{{\n\tinitial\to_int   = 1'b0;\n\tinitial\tint_set = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\t// {{{\n\t\to_int <= 0;\n\t\tint_set <= 0;\n\t\t// }}}\n\tend else begin\n\t\t// {{{\n\t\to_int <= 1'b0;\n\t\tif ((i_ce)&&(int_set)&&(r_counter == int_when))\n\t\t\t// Interrupts are self-clearing\n\t\t\to_int <= 1'b1;\t// Set the interrupt flag for one clock\n\t\telse if ((new_set)&&(till_wb <= 0))\n\t\t\to_int <= 1'b1;\n\n\t\tif ((new_set)&&(till_wb > 0))\n\t\t\tint_set <= 1'b1;\n\t\telse if (int_now)\n\t\t\tint_set <= 1'b0;\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// int_when\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((new_set)&&(till_wb > 0)&&((till_when[BW-1])||(!int_set)))\n\t\tint_when <= new_when;\n\t// }}}\n\n\t// o_wb_ack\n\t// {{{\n\t// Acknowledge any wishbone accesses -- everything we did took only\n\t// one clock anyway.\n\t//\n\tinitial\to_wb_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_wb_ack <= 1'b0;\n\telse\n\t\to_wb_ack <= i_wb_stb;\n\t// }}}\n\n\tassign\to_wb_data = r_counter;\n\tassign\to_wb_stall = 1'b0;\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, i_wb_cyc, i_wb_sel };\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions about our",
            "input s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// One basic WB assumtion\n\n\t// Anytime the stb is high, the cycle line must also be high\n\talways @(posedge i_clk)\n\t\tassume((!i_wb_stb)||(i_wb_cyc));\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about our bus",
            "output s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// We never stall the bus\n\talways @(*)\n\t\tassert(!o_wb_stall);\n\n\t// We always ack every transaction on the following clock\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_stb)))\n\tbegin\n\t\tassert(o_wb_ack);\n\tend else\n\t\tassert(!o_wb_ack);\n\t// }}}\n\t///////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions about our internal state and our",
            "output s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_reset)))\n\tbegin\n\t\tassert(!o_wb_ack);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_stb))\n\t\t\t&&($past(i_wb_we)))\n\t\tassert(new_when == $past(i_wb_data));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wb_stb))\n\t\t\t&&($past(i_wb_we)))\n\tbegin\n\t\tassert(new_set);\n\tend else\n\t\tassert(!new_set);\n\n\t//\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_reset)))\n\t\tassert(!o_int);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_reset)))\n\tbegin\n\t\tassert(!int_set);\n\t\tassert(!new_set);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(new_set))\n\t\t\t&&(!$past(till_wb[BW-1]))\n\t\t\t&&($past(till_wb) > 0))\n\t\tassert(int_set);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_ce))\n\t\t&&($past(r_counter)==$past(int_when)))\n\tbegin\n\t\tassert((o_int)||(!$past(int_set)));\n\t\t// assert((!int_set)||($past(new_set)));\t// !!!!!\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&(!$past(new_set))&&(!$past(int_set)))\n\t\tassert(!int_set);\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\tbegin\n\t\tassert(!o_int);\n\tend else if (($past(new_set))&&($past(till_wb) < 0))\n\t\tassert(o_int);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&\n\t\t\t((!$past(new_set))\n\t\t\t||($past(till_wb[BW-1]))\n\t\t\t||($past(till_wb == 0))))\n\t\tassert(int_when == $past(int_when));\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "zipmmu.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/zipmmu.v",
        "chunks": [
            "module .\n//\n// Design Goals:\n//\n//\tSince we're trying to design this for disadvantaged, limited CPUs,\n//\twe should be able to offer such CPUs only as much MMU as they want.\n//\tTherefore, it should be possible to scale the MMU up and/or down in\n//\tLUT space.\n//\n// Memory space:\n//\t1. On access via the memory bus, the MMU should provide for a speed\n//\t\tgoing through it such that any access is delayed by only one\n//\t\tclock cycle.  Further, multiple accesses to the same page\n//\t\tshould not take any longer than the one cycle delay.  Accesses\n//\t\tto other pages should take a minimum number of clocks.\n//\t\tAccesses from one page to the next, such as from one page to\n//\t\tthe next subsequent one, should cost no delays.\n//\n//\t2. One independent control word to set the current context\n//\n//\t  - When context = 0, virtual page = physical page, page table is an\n//\t\tunused pass through.\n//\t  - When context != 0, MMU translation is active anytime the GIE is\n//\t\tset.  Pages must match context, as well as virtual address.\n//\n//\t  - Contains 4 RdOnly bits indicating the log address size for the\n//\t\tmachine, offset by 17.  Thus, the build will have an address\n//\t\tbus of width (lgpage+17), or a memory space of (2^(lgpage+17)).\n//\t\tUnder this formula, the number of valid address bits can range\n//\t\tfrom 17 to 32.\n//\t  -  Contains 4 RdOnly bits indicating log_2 TLB table size.\n//\t  \tSize is given by (2^(lgsize)).  I'm considering sizes of 6,7&8\n//\t  -  Contains 4 RdOnly bits indicating the log page size, offset by\n//\t\teight.  Page sizes are therefore given by (2^(lgpage+8)), and\n//\t\tthe smallest page size is 256 words.\n//\t  - Contains 4 RdOnly bits indicating the log context size, offset by 1.\n//\t\tThe number of bits in the context word therefore run from 1 to\n//\t\t(lgcontext+1)-1, supporting between (2^1)-1=3 and\n//\t\t(2^16)-1 = 65535 contexts.  (The zero context is not being\n//\t\tcounted here, as it is special.)\n//\n//\t+------+------+------+------+--------------------+\n//\t|      |      |      |      |                    |\n//\t|  4b  |  4b  |  4b  |  4b  |       16-bit       |\n//\t| LGADR| LGTBL|LGPGSZ|LGCTXT|    Context word    |\n//\t|      |      |      |      |                    |\n//\t+------+------+------+------+--------------------+\n//\n//\tSupervisor *cannot* have page table entries, since there are no\n//\tinterrupts (page faults) allowed in supervisor context.\n//\n//\tTo be valid,\n//\t  Context Size (1..16), NFlags (    4) < Page Size (8-23 bits)\n//\t  Page size (8-23 bits)                > NFlags bits (4)\n//\n//\tSmall page sizes, then, mean fewer contexts are possible\n//\n//\t3. One status word, which contains the address that failed and some\n//\t\tflags:\n//\n//\tTop Virtual address bits indicate which page ... caused  a problem.\n//\t\tThese will be the top N bits of the word, where N is the size\n//\t\tof the virtual address bits.  (Bits are cleared upon any write.)\n//\n//\tFlags: (Up to 12 bits, all zeros means no fault.  Bits are cleared upon\n//\t\twrite)\n//\t\t- 4: Multiple page table matches\n//\t\t- 2: Attempt to write a read-only page\n//\t\t- 1: Page not found\n//\n//\t3. Two words per active page table entry, accessed through two bus\n//\t\taddresses.  This word contains:\n//\n//\t  16-bits\tPage context\n//\t  20-bits\tVirtual address\n//\t  20-bits\tPhysical address\n//\t\t\t\tA physical address of all ones means that the\n//\t\t\t\tpage does not exist, and any attempt to access\n//\t\t\t\tthe virtual address associated with this page\n//\t\t\t\tshould fault.\n//\n//\tFlags:\n//\t   1-bit\tRead-only / ~written (user set/read/written)\n//\t\t\t\tIf set, this page will cause a fault on any\n//\t\t\t\tattempt to write this memory.\n//\t   1-bit\tThis page may be executed\n//\t   1-bit\tCacheable\n//\t\t\t\tThis is not a hardware page, but a memory page.\n//\t\t\t\tTherefore, the values within this page may be\n//\t\t\t\tcached.\n//\t   1-bit\tAccessed\n//\t\t\t\tThis an be used to implement a least-recently\n//\t\t\t\tused measure.  The hardware will set this value\n//\t\t\t\twhen the page is accessed.  The user can also\n//\t\t\t\tset or clear this at will.\n//\n//\t\t(Loaded flag\tNot necessary, just map the physical page to 0)\n//\n//\tWe could equivalently do a 16-bit V&P addresses, for a 28-bit total\n//\taddress space, if we didn't want to support the entire 32-bit space.\n//\n//\n//\t4. Can read/write this word in two parts:\n//\n//\t\t(20-bit Virtual )(8-bits lower context)(4-bit flags), and\n//\t\t(20-bit Physical)(8-bits upper context)(4-bit flags)\n//\n//\t\tActual bit lengths will vary as the MMU configuration changes,\n//\t\thowever the flags will always be the low order four bits,\n//\t\tand the virtual/physical address flags will always consume\n//\t\t32 bits minus the page table size.  The context bits will\n//\t\talways be split into upper and lower context bits.  If there\n//\t\tare more context bits than can fit in the space, then the\n//\t\tupper bits of the context field will be filled with zeros.\n//\n//\t\tOn any write, the context bits will be set from the context\n//\t\tbits in the control",
            "reg ister.\n//\n//\t+----+----+-----+----+----+----+----+--+--+--+--+\n//\t|                         | Lower 8b| R| E| C| A|\n//\t|  20-bit Virtual page ID | Context | O| X| C| C|\n//\t|(top 20 bits of the addr)|   ID    | n| E| H| C|\n//\t|                         |         | W| F| E| S|\n//\t+----+----+-----+----+----+----+----+--+--+--+--+\n//\n//\t+----+----+-----+----+----+----+----+--+--+--+--+\n//\t|                         | Upper 8b| R| A| C| T|\n//\t|  20-bit Physical pg ID  | Context | O| C| C| H|\n//\t|(top 20 bits of the      |   ID    | n| C| H| S|\n//\t|    physical address)    |         | W| S| E| P|\n//\t+----+----+-----+----+----+----+----+--+--+--+--+\n//\n//\t5. PF Cache--handles words in both physical and virtual\n//\t- On any pf-read, the MMU returns the current pagetable/TBL mapping\n//\t\tThis consists of [Context,Va,Pa].\n//\t- The PF cache stores this with the address tag.  (If the PF is reading,\n//\t\tthe VP should match, only the physical page ID needs to be\n//\t\tsored ...)\n//\t- At the end of any cache line read, the page table/TBL mapping address\n//\t\twill have long been available, the \"Valid\" bit will be turned\n//\t\ton and associated with the physical mapping.\n//\t- On any data-write (pf doesn't write), MMU sends [Context,Va,Pa]\n//\t\tTLB mapping to the pf-cache.\n//\t- If the write matches any physical PF-cache addresses (???), the\n//\t\tpfcache declares that address line invalid, and just plain\n//\t\tclears the valid bit for that page.\n//\n//\tSince the cache lines sizes are smaller than the page table sizes,\n//\tfailure to match the address means ... what?\n//\n//\n//\t6. Normal operation and timing:\n//\t  - One clock lost if still on the same page as last time, or in the\n//\t\tsupervisor (physical pages only) context ...\n//\t  - Two clocks (1-more delay) if opening a new page.\n//\t\t(1-clock to look up the entry--comparing against all entries,\n//\t\t1-clock to read it, next clock the access goes forward.)\n//\t  - No more than two stalls for any access, pipelineable.  Thus, once\n//\t\tyou've stalled by both clocks, you'll not stall again during\n//\t\tany pipeline operation.\n//\n// Status:\n//\tAt one point, this MMU was partially integrated into the ZipCPU.  That\n//\tis, it was integrated far enough into the ZipSystem that a test might\n//\thave been written, but never into any of the other wrappers.  Since\n//\tthen, the ZipCPU has been refactored so that it can support multiple\n//\tbus structures and a",
            "parameter ized bus width.  This MMU now needs to\n//\tbe similarly refactored to match, so that it can integrate into the\n//\tZipCPU *between* the ZipCore and its memory access components--whether\n//\tinstruction or data memory access.  This refactor has not (yet) taken\n//\tplace, and until it does so this MMU implementation should be\n//\tconsidered ...\n//\n//\t*DEPRECATED*.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2016-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n//\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype\tnone\n//\n`define\tROFLAG\t3\t// Read-only flag\n`define\tEXEFLG\t2\t// No-execute flag (invalid for I-cache)\n`define\tCHFLAG\t1\t// Cachable flag\n`define\tAXFLAG\t0\t// Accessed flag\n// }}}",
            "module zipmmu(i_clk, i_reset, i_wbs_cyc_stb, i_wbs_we, i_wbs_addr,\n\t\t\t\ti_wbs_data, o_wbs_stall, o_wbs_ack, o_wbs_data,\n\t\ti_wbm_cyc, i_wbm_stb, i_wbm_we, i_wbm_exe,\n\t\t\ti_wbm_addr, i_wbm_data, i_wbm_sel, i_gie,\n\t\to_cyc, o_stb, o_we, o_addr, o_data, o_sel,\n\t\t\ti_stall, i_ack, i_err, i_data,\n\t\t\to_rtn_stall, o_rtn_ack, o_rtn_err,\n\t\t\t\to_rtn_miss, o_rtn_data,\n\t\tpf_return_stb, pf_return_we,\n\t\t\t\tpf_return_p, pf_return_v,\n\t\t\t\tpf_return_cachable);",
            "parameter // The size of the address bus.  Actual addressable\n\t\t\t// size will likely be 2^(ADDRESS_WIDTH+2) octets\n\t\t\tADDRESS_WIDTH=28,\n\t\t\t// Number of page table entries\n`ifdef\tFORMAL\n\t\t\tLGTBL=4'h2,\n`else\n\t\t\tLGTBL=4'h6,\n`endif\n\t\t\t// The requested log page size in 8-bit bytes\n\t\t\tPLGPGSZB=20,\n\t\t\t// Number of bits describing context\n`ifdef\tFORMAL\n\t\t\tPLGCTXT=2;\n`else\n\t\t\tPLGCTXT=16;\n`endif",
            "parameter [0:0] OPT_DELAY_RETURN = 1'b0;",
            "localparam // And for our derived",
            "parameter s (don't set these ...)\n\t\t\t// Width of the data bus is 32-bits.  This may be hard\n\t\t\t// to change.\n\t\t\tDW = 32,\n\t\t\t// AW is just shorthand for the name ADDRESS_WIDTH\n\t\t\tAW = ADDRESS_WIDTH,\n\t\t\t// Page sizes must allow for a minimum of one context\n\t\t\t// bit per page, plus four flag bits, hence the minimum\n\t\t\t// number of bits for an address within a page is 5\n\t\t\tLGPGSZB=(PLGPGSZB < 5)? 5:PLGPGSZB,\t// in bytes\n\t\t\tLGPGSZW=LGPGSZB-2,\t\t\t// in words\n\t\t\t// The context value for a given page can be split\n\t\t\t// across both virtual and physical words.  It cannot\n\t\t\t// have so many bits to it that it takes more bits\n\t\t\t// then are available.\n\t\t\tLGCTXT=((2*LGPGSZB-4)>PLGCTXT)?\n\t\t\t\tPLGCTXT:(2*LGPGSZB-4),\n\t\t\t// LGLCTX is the number of context bits in the low word\n\t\t\tLGLCTX=(LGCTXT > (LGPGSZB-4))?(LGPGSZB-4):LGCTXT,\n\t\t\t// LGHCTX is the number of context bits in the high word\n\t\t\tLGHCTX= (LGCTXT-LGLCTX>0)?(LGCTXT-LGLCTX):0,\n\t\t\tVAW=(DW-LGPGSZB), //  Virtual address width, in bytes\n\t\t\tPAW=(AW-LGPGSZW), // Physical address width, in words\n\t\t\tTBL_BITS = LGTBL,\t// Bits necessary to addr tbl\n\t\t\tTBL_SIZE=(1<<TBL_BITS);// Number of table entries",
            "input ",
            "wire i_clk, i_reset;\n\t//",
            "input ",
            "wire i_wbs_cyc_stb;",
            "input ",
            "wire i_wbs_we;",
            "input ",
            "wire [(LGTBL+1):0]\ti_wbs_addr;",
            "input ",
            "wire [(DW-1):0]\ti_wbs_data;",
            "output ",
            "wire o_wbs_stall;",
            "output ",
            "reg o_wbs_ack;",
            "output ",
            "reg [(DW-1):0]\to_wbs_data;\n\t//",
            "input ",
            "wire i_wbm_cyc, i_wbm_stb;\n\t//",
            "input ",
            "wire i_wbm_we, i_wbm_exe;",
            "input ",
            "wire [(DW-2-1):0]\ti_wbm_addr;",
            "input ",
            "wire [(DW-1):0]\t\ti_wbm_data;",
            "input ",
            "wire [(DW/8-1):0]\ti_wbm_sel;",
            "input ",
            "wire i_gie;\n\t//\n\t// Here's where we drive the slave side of the bus",
            "output ",
            "reg o_cyc;",
            "output ",
            "wire o_stb, o_we;",
            "output ",
            "reg [(AW-1):0]\to_addr;",
            "output ",
            "reg [(DW-1):0]\to_data;",
            "output ",
            "reg [(DW/8-1):0]\to_sel;\n\t// and get our return information from driving the slave ...",
            "input ",
            "wire i_stall, i_ack, i_err;",
            "input ",
            "wire [(DW-1):0]\ti_data;\n\t//\n\t// Here's where we return information on either our slave/control bus\n\t// or the memory bus we are controlled from.  Note that we share these\n\t//",
            "wire s ...",
            "output ",
            "wire o_rtn_stall;",
            "output ",
            "wire o_rtn_ack;",
            "output ",
            "wire o_rtn_err, o_rtn_miss;",
            "output ",
            "wire [(DW-1):0]\to_rtn_data;\n\t// Finally, to allow the prefetch to snoop on the MMU conversion ...",
            "output ",
            "wire pf_return_stb, // snoop data is valid\n\t\t\t\t\tpf_return_we; // snoop data is chnging",
            "output ",
            "wire [(PAW-1):0]\tpf_return_p;",
            "output ",
            "wire [(VAW-1):0]\tpf_return_v;",
            "output ",
            "wire pf_return_cachable;\n\t//\n\t//\n\n//\n//\n//",
            "reg [3:0]\t\t\ttlb_flags\t[0:(TBL_SIZE-1)];",
            "wire [3:0]\t\t\ts_tlb_flags;",
            "reg [(LGCTXT-1):0]\t\ttlb_cdata\t[0:(TBL_SIZE-1)];",
            "reg [(VAW-1):0]\t\ttlb_vdata\t[0:(TBL_SIZE-1)];",
            "reg [(PAW-1):0]\t\ttlb_pdata\t[0:(TBL_SIZE-1)];",
            "reg [(TBL_SIZE-1):0]\ttlb_valid, tlb_accessed;",
            "wire adr_control, adr_vtable, adr_ptable;",
            "wire wr_control, wr_vtable, wr_ptable;",
            "wire [(LGTBL-1):0]\twr_tlb_addr;\n\tassign\twr_tlb_addr= i_wbs_addr[(LGTBL):1]; // Leave bottom for V/P\n\tassign\tadr_control= (i_wbs_cyc_stb)&&(~i_wbs_addr[(LGTBL+1)])&&(~i_wbs_addr[0]);\n\tassign\tadr_vtable = (i_wbs_cyc_stb)&&( i_wbs_addr[(LGTBL+1)])&&(~i_wbs_addr[0]);\n\tassign\tadr_ptable = (i_wbs_cyc_stb)&&( i_wbs_addr[(LGTBL+1)])&&( i_wbs_addr[0]);\n\tassign\twr_control = (adr_control)&&(i_wbs_we);\n\tassign\twr_vtable  = (adr_vtable )&&(i_wbs_we);\n\tassign\twr_ptable  = (adr_ptable )&&(i_wbs_we);",
            "reg z_context;",
            "wire kernel_context;",
            "reg [(LGCTXT-1):0]\tr_context_word;\n\t//",
            "wire [31:0]\t\tw_control_data, w_ptable_",
            "reg ;",
            "reg [31:0]\t\tw_vtable_",
            "reg ;",
            "reg [31:0]\tstatus_word;\n\t//\n\t//",
            "reg r_pending, r_we, r_exe, r_valid,\n\t\t\t\tlast_page_valid, last_ro, last_exe;",
            "reg [(DW-3):0]\tr_addr;",
            "reg [(DW-1):0]\tr_data;",
            "wire [(VAW-1):0]\tvpage;",
            "wire [AW-LGPGSZW-1:0]\tppage;",
            "reg [(DW/8-1):0]\tr_sel;",
            "reg [(PAW-1):0]\tlast_ppage;",
            "reg [(VAW-1):0]\tlast_vpage;\n\t//",
            "wire [(TBL_SIZE-1):0]\tr_tlb_match;",
            "reg [(LGTBL-1):0]\t\ts_tlb_addr, last_tlb;",
            "reg s_tlb_miss, s_tlb_hit, s_pending;\n\t//",
            "wire ro_flag, exe_flag, simple_miss, ro_miss, exe_miss, table_err, cachable;",
            "reg pf_stb, pf_cachable;",
            "reg miss_pending;\n\t//",
            "reg rtn_err;",
            "wire this_page_valid, pending_page_valid;\n\tassign\tthis_page_valid = ((last_page_valid)\n\t\t\t\t&&(i_wbm_addr[(DW-3):(DW-2-VAW)]==last_vpage)\n\t\t\t\t&&((!last_ro)||(!i_wbm_we))\n\t\t\t\t&&((!last_exe)||(!i_wbm_exe)));\n\tassign\tpending_page_valid = ((s_pending)&&(s_tlb_hit)\n\t\t\t\t&&((!r_we)||(!ro_flag))\n\t\t\t\t&&((!r_exe)||(exe_flag)));\n\n\t//////////////////////////////////////////\n\t//\n\t//\n\t// Step one -- handle the control bus--i_wbs_cyc_stb\n\t//\n\t//\n\t//////////////////////////////////////////\n\talways @(posedge i_clk)\n\tbegin\n\t\t// Write to the Translation lookaside buffer\n\t\tif (wr_vtable)\n\t\t\ttlb_vdata[wr_tlb_addr]<=i_wbs_data[(DW-1):LGPGSZB];\n\t\tif (wr_ptable)\n\t\t\ttlb_pdata[wr_tlb_addr]<=i_wbs_data[(AW+1):LGPGSZB];\n\t\t// Set the context",
            "reg ister for the page\n\t\tif (wr_vtable)\n\t\t\ttlb_flags[wr_tlb_addr] <= { i_wbs_data[3:1], 1'b0 };\n\t\tif (wr_vtable)\n\t\t\ttlb_cdata[wr_tlb_addr][(LGLCTX-1):0]\n\t\t\t\t<= i_wbs_data[(LGLCTX+4-1):4];\n\tend\n\n\tinitial\ttlb_accessed = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\ttlb_accessed <= 0;\n\telse begin\n\t\tif (wr_vtable)\n\t\t\ttlb_accessed[wr_tlb_addr] <= 1'b0;\n\t\t// Otherwise, keep track of the accessed bit if we\n\t\t// ever access this page\n\t\telse if ((!kernel_context)&&(pending_page_valid))\n\t\t\ttlb_accessed[s_tlb_addr] <= 1'b1;\n\t\telse if ((!kernel_context)&&(this_page_valid))\n\t\t\ttlb_accessed[last_tlb] <= 1'b1;\n\tend\n\n\tgenerate if (LGHCTX > 0)\n\tbegin : HCTX\n\t\talways @(posedge i_clk)\n\t\tif (wr_ptable)\n\t\t\ttlb_cdata[wr_tlb_addr][(LGCTXT-1):LGLCTX]\n\t\t\t\t<= i_wbs_data[(LGHCTX+4-1):4];\n\tend endgenerate\n\n\t// Writing to the control word\n\tinitial z_context = 1'b1;\n\tinitial r_context_word = 0;\n\talways @(posedge i_clk)\n\tif (wr_control)\n\t\tbegin\n\t\tr_context_word <= i_wbs_data[(LGCTXT-1):0];\n\t\tz_context      <= (i_wbs_data[(LGCTXT-1):0] == {(LGCTXT){1'b0}});\n\t\tend\n\tassign\tkernel_context = (z_context)||(!i_gie);\n\t// Status words cannot be written to\n\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\ttlb_valid <= 0;\n\telse if (wr_ptable)\n\t\ttlb_valid[wr_tlb_addr]<=1'b1; //(i_wbs_data[(AW+1):LGPGSZB]!=0);\n\n\t/* v*rilator lint_off WIDTH */\n\tassign\tw_control_data[31:28] = AW[3:0]-4'd1;\n\tassign\tw_control_data[27:24] = LGTBL[3:0];\n\tassign\tw_control_data[23:20] = LGPGSZB[3:0]-4'd10;\n\tassign\tw_control_data[19:16] = LGCTXT[3:0]-1'b1;\n\t/* v*rilator lint_on WIDTH */\n\tassign\tw_control_data[15: 0] = {{(16-LGCTXT){1'b0}}, r_context_word};\n\t//\n\talways @(*)\n\tbegin\n\t\tw_vtable_",
            "reg = 0;\n\t\tw_vtable_",
            "reg [(DW-1):LGPGSZB] = tlb_vdata[wr_tlb_addr];\n\t\tw_vtable_",
            "reg [(LGLCTX+4-1):4] = { tlb_cdata[wr_tlb_addr][(LGLCTX-1):0] };\n\t\tw_vtable_",
            "reg [ 3:0]  = { tlb_flags[wr_tlb_addr][3:1],\n\t\t\t\t\ttlb_accessed[wr_tlb_addr] };\n\tend\n\t//\n\tassign\tw_ptable_",
            "reg [(DW-1):LGPGSZB] = { {(DW-PAW-LGPGSZB){1'b0}},\n\t\t\t\t\ttlb_pdata[wr_tlb_addr] };\n\tassign\tw_ptable_",
            "reg [ 3:0]  = 4'h0;\n\t//\n\tgenerate\n\t\tif (4+LGHCTX-1>4)\n\t\tbegin : PTABLE_REG_LIL\n\t\t\tassign\tw_ptable_",
            "reg [(4+LGHCTX-1):4] =  {\n\t\t\t\ttlb_cdata[wr_tlb_addr][(LGCTXT-1):LGLCTX] };\n\t\tend\n\n\t\tif (LGPGSZB > LGLCTX+4)\n\t\tbegin : VTABLE_REG\n\t\t\tassign\tw_vtable_",
            "reg [(LGPGSZB-1):(LGLCTX+4)] = 0;\n\t\tend\n\n\t\tif (LGPGSZB > LGHCTX+4)\n\t\tbegin : PTABLE_REG\n\t\t\tassign\tw_ptable_",
            "reg [(LGPGSZB-1):(LGHCTX+4)] = 0;\n\t\tend\n\tendgenerate\n\n\t//\n\t// Now, reading from the bus\n\t/*",
            "wire [(LGCTXT-1):0]\tw_ctable_",
            "reg ;\n\tassign\tw_ctable_",
            "reg = tlb_cdata[wr_tlb_addr];",
            "reg setup_this_page_flag;",
            "reg [(LGCTXT-1):0]\tsetup_page;\n\tinitial\tsetup_this_page_flag = 1'b0;\n\talways @(posedge i_clk)\n\t\tsetup_page <= w_ctable_",
            "reg ;\n\talways @(posedge i_clk)\n\t\tsetup_this_page_flag <= (!i_reset)&&(i_wbs_cyc_stb)&&(i_wbs_addr[LGTBL+1]);\n\t*/\n\n\n\n\t//////////////////////////////////////////\n\t//\n\t//\n\t// Step two -- handle the page lookup on the master bus\n\t//\n\t//\n\t//////////////////////////////////////////\n\n\t//\n\t//\n\t// First clock, and the r_",
            "reg ister, copies the bus data from the bus.\n\t// While this increases the bus latency, it also gives us a moment to\n\t// work.\n\t//\n\t//",
            "wire [(VAW-1):0]\tr_vpage;",
            "wire [(PAW-1):0]\tr_ppage;\n\tassign\tr_vpage = (r_addr[(DW-3):(DW-2-VAW)]);\n\tassign\tr_ppage = (o_addr[(AW-1):LGPGSZW]);\n\n\tinitial\ts_pending = 1'b0;\n\tinitial\tr_pending = 1'b0;\n\tinitial\tr_valid   = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\tr_pending <= 1'b0;\n\t\tr_valid   <= 1'b0;\n\t\to_addr    <= 0;\n\t\tr_we      <= 0;\n\t\tr_exe     <= 0;\n\t\tr_addr    <= 0;\n\t\tr_data    <= 0;\n\t\tr_sel     <= 0;\n\t\t//\n\t\ts_pending <= 1'b0;\n\tend else\n\tbegin\n\t\tif (!o_rtn_stall)\n\t\tbegin\n\t\t\tr_pending <= (i_wbm_stb)&&(!kernel_context)\n\t\t\t\t\t\t&&(!this_page_valid);\n\t\t\tr_we      <= i_wbm_we;\n\t\t\tr_exe     <= i_wbm_exe;\n\t\t\to_addr    <= { { (kernel_context)?\n\t\t\t\ti_wbm_addr[(AW-1):LGPGSZW] : last_ppage },\n\t\t\t\ti_wbm_addr[(LGPGSZW-1):0] };\n\t\t\tr_addr    <= i_wbm_addr;\n\t\t\tr_data    <= i_wbm_data;\n\t\t\tr_sel     <= i_wbm_sel;\n\t\t\tr_valid   <= (i_wbm_stb)&&((kernel_context)||(this_page_valid));\n\t\t\ts_pending <= 1'b0;\n\t\tend else if (!r_valid) begin\n\t\t\tr_valid <= (pending_page_valid);\n\t\t\to_addr <= { ppage , r_addr[(LGPGSZW-1):0] };\n\t\t\tr_pending<= (r_pending)&&(!pending_page_valid);\n\t\t\ts_pending <=(r_pending)&&(!pending_page_valid);\n\t\tend else begin\n\t\t\tr_pending <= 1'b0;\n\t\t\ts_pending <= 1'b0;\n\t\tend\n\n\t\tif ((!i_wbm_cyc)||(o_rtn_err)||((o_cyc)&&(i_err)))\n\t\tbegin\n\t\t\ts_pending <= 1'b0;\n\t\t\tr_pending <= 1'b0;\n\t\t\tr_valid   <= 1'b0;\n\t\tend\n\tend\n\n`ifdef\tFORMAL",
            "reg f_past_valid;\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(r_pending))&&(r_pending)&&($past(o_rtn_stall))&&(i_wbm_cyc)&&(!o_stb))\n\t\tassert(s_pending);\n`endif\n\n\t// Second clock: know which buffer entry this belong in.\n\t// If we don't already know, then the pipeline must be stalled for a\n\t// while ...\n\tgenvar k; // s;\n\tgenerate\n\tfor(k=0; k<TBL_SIZE; k = k + 1)\n\t\tassign r_tlb_match[k] =\n\t\t\t// The page  must be valid\n\t\t\t(tlb_valid[k])\n\t\t\t// Virtual address must match\n\t\t\t&&(tlb_vdata[k] == r_vpage)\n\t\t\t// Context must match as well\n\t\t\t&&(tlb_cdata[k][LGCTXT-1:1] == r_context_word[LGCTXT-1:1])\n\t\t\t&&((!tlb_cdata[k][0])||(r_context_word[0]));\n\tendgenerate\n\n\tinitial\ts_tlb_miss = 1'b0;\n\tinitial\ts_tlb_hit  = 1'b0;\n\tgenerate\n\t\tinteger i;\n\talways @(posedge i_clk)\n\tbegin // valid when s_ becomes valid\n\t\ts_tlb_addr <= {(LGTBL){1'b0}};\n\t\tfor(i=0; i<TBL_SIZE; i=i+1)\n\t\t\tif (r_tlb_match[i])\n\t\t\t\ts_tlb_addr <= i[(LGTBL-1):0];\n\t\ts_tlb_miss <= (r_pending)&&(r_tlb_match == 0);\n\t\ts_tlb_hit <= 1'b0;\n\t\tfor(i=0; i<TBL_SIZE; i=i+1)\n\t\t\tif (r_tlb_match == (1<<i))\n\t\t\t\ts_tlb_hit <= (r_pending)&&(!r_valid)&&(i_wbm_cyc);\n\tend endgenerate\n\n\t// Third clock: Read from the address the virtual table offset,\n\t// whether read-only, etc.\n\tassign\ts_tlb_flags = tlb_flags[s_tlb_addr];\n\tassign\tro_flag     = s_tlb_flags[`ROFLAG];\n\tassign\texe_flag    = s_tlb_flags[`EXEFLG];\n\tassign\tcachable    = s_tlb_flags[`CHFLAG];\n\tassign\tsimple_miss = (s_pending)&&(s_tlb_miss);\n\tassign\tro_miss     = (s_pending)&&(s_tlb_hit)&&(r_we)&&(ro_flag);\n\tassign\texe_miss    = (s_pending)&&(s_tlb_hit)&&(r_exe)&&(!exe_flag);\n\tassign\ttable_err   = (s_pending)&&(!s_tlb_miss)&&(!s_tlb_hit);\n\tassign\tvpage       = tlb_vdata[s_tlb_addr];\n\tassign\tppage\t    = tlb_pdata[s_tlb_addr];\n\n\tinitial\tpf_cachable = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tpf_cachable <= 1'b0;\n\telse\n\t\tpf_cachable <= cachable;\n\n\tinitial\tpf_stb = 1'b0;\n\tinitial\tlast_ppage = 0;\n\tinitial\tlast_vpage = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\tpf_stb <= 1'b0;\n\t\tlast_ppage <= 0;\n\t\tlast_vpage <= 0;\n\t\tlast_tlb   <= 0;\n\tend else if ((!kernel_context)&&(r_pending)&&(!last_page_valid))\n\tbegin\n\t\tlast_tlb   <= s_tlb_addr;\n\t\tlast_ppage <= ppage;\n\t\tlast_vpage <= vpage;\n\t\tlast_exe   <= exe_flag;\n\t\tlast_ro    <= ro_flag;\n\t\tpf_stb <= 1'b1;\n\tend else\n\t\tpf_stb <= 1'b0;\n\n\tinitial\tstatus_word = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tstatus_word <= 0;\n\telse if (wr_control)\n\t\tstatus_word <= 0;\n\telse if ((table_err)||(ro_miss)||(simple_miss)||(exe_miss))\n\t\tstatus_word <= { r_vpage,\n\t\t\t\t{(LGPGSZB-4){1'b0}},\n\t\t\t\t(table_err), (exe_miss),\n\t\t\t\t(ro_miss), (simple_miss) };\n\n\tinitial\tlast_page_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tlast_page_valid <= 1'b0;\n\telse if ((i_wbs_cyc_stb)&&(i_wbs_we))\n\t\tlast_page_valid <= 1'b0;\n\telse if (!kernel_context)\n\tbegin\n\t\tif (!o_rtn_stall)\n\t\t\t// A new bus request\n\t\t\tlast_page_valid <= (last_page_valid)\n\t\t\t\t&&(i_wbm_addr[(DW-3):(DW-2-VAW)] == last_vpage);\n\t\telse if ((r_pending)&&(!last_page_valid))\n\t\t\tlast_page_valid <= (s_pending)&&(s_tlb_hit);\n\tend",
            "parameter LGFIFO = 6;",
            "reg [LGFIFO-1:0]\tbus_outstanding;\n\tinitial\tbus_outstanding = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tbus_outstanding <= 0;\n\telse if (!o_cyc)\n\t\tbus_outstanding <= 0;\n\telse case({ (o_stb)&&(!i_stall), (i_ack)||(i_err) } )\n\t2'b01: bus_outstanding <= bus_outstanding - 1'b1;\n\t2'b10: bus_outstanding <= bus_outstanding + 1'b1;\n\tdefault: begin end\n\tendcase",
            "reg bus_pending;\n\tinitial\tbus_pending = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tbus_pending <= 0;\n\telse if (!o_cyc)\n\t\tbus_pending <= 1'b0;\n\telse case({ (o_stb)&&(!i_stall), ((i_ack)||(i_err)) })\n\t2'b01: bus_pending <= (bus_outstanding > 1);\n\t2'b10: bus_pending <= 1'b1;\n\tdefault: begin end\n\tendcase\n\n\tinitial\trtn_err = 1'b0;\n\tinitial\to_cyc   = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\to_cyc <= 1'b0;\n\t\trtn_err   <= 1'b0;\n\tend else begin\n\t\to_cyc <=  (i_wbm_cyc)&&(!o_rtn_err)&&((!i_err)||(!o_cyc)); /// &&((o_cyc)||(r_valid));\n\n\t\trtn_err  <= (i_wbm_cyc)&&(i_err)&&(o_cyc);\n\tend\n\n\tgenerate if (OPT_DELAY_RETURN)\n\tbegin : GEN_DELAYED_RETURN",
            "reg r_rtn_ack;",
            "reg [31:0]\tr_rtn_data;\n\n\t\tinitial\tr_rtn_data = 0;\n\t\tinitial\tr_rtn_ack  = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\tbegin\n\t\t\tr_rtn_ack  <= 0;\n\t\t\tr_rtn_data <= 0;\n\t\tend else begin\n\t\t\tr_rtn_ack  <= (i_wbm_cyc)&&(i_ack)&&(o_cyc);\n\t\t\tr_rtn_data <= i_data;\n\t\tend\n\n\t\tassign\to_rtn_ack  = r_rtn_ack;\n\t\tassign\to_rtn_data = r_rtn_data;\n\tend else begin : GEN_DIRECT_RETURN\n\n\t\tassign\to_rtn_ack  = (i_ack)&&(o_cyc);\n\t\tassign\to_rtn_data = i_data;\n\tend endgenerate\n\n\tassign\to_stb = (r_valid);\n\tassign\to_we  =  (r_we);\n\tassign\to_rtn_stall = (i_wbm_cyc)&&(\n\t\t\t(o_rtn_err)\n\t\t\t||((r_pending)&&(!r_valid))\n\t\t\t||((o_stb)&&(i_stall))\n\t\t\t||(miss_pending));\n\n\tinitial\tmiss_pending = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tmiss_pending <= 0;\n\telse if (!i_wbm_cyc)\n\t\tmiss_pending <= 0;\n\telse\n\t\tmiss_pending <= (i_wbm_cyc)&&(\n\t\t\t\t(simple_miss)||(ro_miss)||(exe_miss)\n\t\t\t\t||((s_pending)&&(!s_tlb_miss)&&(!s_tlb_hit)));\n\n\tassign\to_rtn_miss  = (miss_pending)&&(!bus_pending);\n\tassign\to_rtn_err   = (rtn_err);\n\n\tassign\to_sel  = r_sel;\n\tassign\to_data = r_data;\n\n\t//\n\tassign\to_wbs_stall = 1'b0;\n\tinitial\to_wbs_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_wbs_ack <= 1'b0;\n\telse\n\t\to_wbs_ack <= (i_wbs_cyc_stb);\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_wbs_data <= 0;\n\telse case({i_wbs_addr[LGTBL+1],i_wbs_addr[0]})\n\t2'b00: o_wbs_data <= w_control_data;\n\t2'b01: o_wbs_data <= status_word;\n\t2'b10: o_wbs_data <= w_vtable_",
            "reg ;\n\t2'b11: o_wbs_data <= w_ptable_",
            "reg ;\n\tendcase\n\n\t//\n\t// Bus snooping returns ...\n\t//\n\tassign\tpf_return_stb = pf_stb;\n\tassign\tpf_return_we = r_we;\n\tassign\tpf_return_p  = last_ppage;\n\tassign\tpf_return_v  = last_vpage;\n\tassign\tpf_return_cachable = pf_cachable;\n\n\t// Also requires being told when/if the page changed\n\t// So, on a page change,\n\t// pf_return_we = 1\n\t// pf_stb = 1\n\t// and pf_return_p has the physical address\n\n\t// Make verilator happy\n\t// verilator lint_off UNUSED",
            "wire [(PAW-1):0]\tunused;\n\tassign\tunused = r_ppage;\n\tgenerate if (4+LGCTXT < LGPGSZB)\n\tbegin : GEN_UNUSED",
            "wire unused_data;\n\t\tassign\tunused_data = { 1'b0, i_wbs_data[LGPGSZB-1:4+LGCTXT] };\n\tend endgenerate",
            "wire unused_always;\n\tassign\tunused_always = s_tlb_flags[0];\n\t// verilator lint_on  UNUSED\n\n`ifdef\tFORMAL\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\tinitial\tassume(i_reset);\n\talways @(*)\n\t\tif (!f_past_valid)\n\t\t\tassume(i_reset);\n\n\talways @(*)\n\t\tif (i_reset)\n\t\t\tassume(!i_wbs_cyc_stb);\n\talways @(posedge i_clk)\n\tif (f_past_valid)\n\t\tassert(o_wbs_ack == $past(i_wbs_cyc_stb));\n\talways @(*)\n\t\tassert(o_wbs_stall == 1'b0);\n\n\talways @(*)\n\t\tassume((!i_wbm_cyc)||(!i_wbs_cyc_stb));",
            "localparam F_LGDEPTH = 6;",
            "reg [F_LGDEPTH-1:0]\tfv_nreqs, fv_nacks, fv_outstanding,\n\t\t\tfp_nreqs, fp_nacks, fp_outstanding;",
            "localparam F_MAX_STALL = 3,\n\t\t\tF_MAX_WAIT  = 2,\n\t\t\tF_MAX_REQ   = 9;\n\n\t//\n\t// The stall period needs to be long enough to allow all in-progress\n\t// transactions to complete, as in the case of a page miss.  Hence,\n\t// the max stall amount depends upon the max wait time for the\n\t// physical half of the interaction.  It is artificially limited here\n\t// in order to limit the amount of proof time required.\n\t//\n\tfwb_slave #(\n\t\t// {{{\n\t\t.F_MAX_STALL(F_MAX_STALL+(F_MAX_WAIT*F_MAX_REQ)+2),\n\t\t\t.AW(DW-2),\n\t\t\t.F_MAX_ACK_DELAY(F_MAX_STALL+F_MAX_WAIT+5),\n\t\t\t.F_MAX_REQUESTS(F_MAX_REQ),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_OPT_MINCLOCK_DELAY(0)\n\t\t// }}}\n\t) busslave(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\t\t\ti_wbm_cyc, i_wbm_stb, i_wbm_we, i_wbm_addr,\n\t\t\t\t\ti_wbm_data, i_wbm_sel,\n\t\t\t\to_rtn_ack, o_rtn_stall, o_rtn_data,\n\t\t\t\t\to_rtn_err|o_rtn_miss,\n\t\t\t\tfv_nreqs, fv_nacks, fv_outstanding\n\t\t// }}}\n\t);\n\n\tfwb_master #(\n\t\t// {{{\n\t\t.F_MAX_STALL(F_MAX_STALL),\n\t\t\t.AW(ADDRESS_WIDTH),\n\t\t\t.F_MAX_ACK_DELAY(F_MAX_WAIT),\n\t\t\t.F_MAX_REQUESTS(F_MAX_REQ),\n\t\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t\t.F_OPT_MINCLOCK_DELAY(0)\n\t\t// }}}\n\t) busmaster(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\t\to_cyc, o_stb, o_we, o_addr,\n\t\t\t\to_data, o_sel,\n\t\t\ti_ack, i_stall, i_data, i_err,\n\t\t\tfp_nreqs, fp_nacks, fp_outstanding\n\t\t// }}}\n\t);\n\n\talways @(*)\n\t\tassert((!o_cyc)||(fp_outstanding == bus_outstanding));\n\n\talways @(*)\n\t\tassume(fv_nreqs < F_MAX_REQ);\n\talways @(*)\n\tif ((i_wbm_cyc)&&(o_cyc)&&(fv_outstanding == fp_outstanding))\n\t\tassert(fv_nreqs == fp_nreqs);\n\talways @(*)\n\tif ((i_wbm_cyc)&&(o_cyc))\n\tbegin\n\t\tassert(fp_nreqs <= fv_nreqs);\n\t\tassert(fp_nacks >= fv_nacks);\n\tend",
            "reg [F_LGDEPTH-1:0]\tf_expected, f_ex_nreqs, f_ex_nacks;\n\talways @(*)\n\tif (!i_wbm_cyc)\n\tbegin\n\t\tf_ex_nreqs = 0;\n\t\tf_ex_nacks = 0;\n\t\tf_expected = 0;\n\tend else if (OPT_DELAY_RETURN)\n\tbegin\n\t\tif (r_pending)\n\t\tbegin\n\t\t\tf_ex_nreqs = fp_nreqs + 1'b1;\n\t\t\tf_ex_nacks = fp_nacks + o_rtn_ack;\n\t\t\tf_expected = fp_outstanding + 1'b1\n\t\t\t\t\t\t+ o_rtn_ack;\n\t\tend else begin\n\t\t\tf_expected = fp_outstanding + (o_stb)\n\t\t\t\t+ (o_rtn_ack);\n\t\t\tf_ex_nreqs = fp_nreqs + o_stb;\n\t\t\tf_ex_nacks = fp_nacks + o_rtn_ack;\n\t\tend\n\tend else begin\n\t\tif (r_pending)\n\t\tbegin\n\t\t\tf_ex_nreqs = fp_nreqs + 1'b1;\n\t\t\tf_ex_nacks = fp_nacks;\n\t\t\tf_expected = fp_outstanding + 1'b1;\n\t\tend else begin\n\t\t\tf_ex_nreqs = fp_nreqs + o_stb;\n\t\t\tf_ex_nacks = fp_nacks;\n\t\t\tf_expected = fp_outstanding + (o_stb);\n\t\tend\n\tend",
            "reg f_kill_",
            "input ;\n\tinitial\tf_kill_",
            "input = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_kill_",
            "input <= (i_wbm_cyc)&&(\n\t\t\t(i_reset)\n\t\t\t||(o_rtn_miss)\n\t\t\t||(o_rtn_err));\n\talways @(*)\n\t\tif (f_kill_",
            "input )\n\t\t\tassume(!i_wbm_cyc);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_rtn_miss))&&($past(i_wbm_cyc)))\n\tbegin\n\t\tassume(!o_cyc);\n\t\tassume(!i_wbm_cyc);\n\tend",
            "wire fv_is_one, fp_is_zero;\n\tassign\tfv_is_one  = (fv_outstanding == 1);\n\tassign\tfp_is_zero = (fp_outstanding == 0);\n\talways @(*)\n\tif ((i_wbm_cyc)&&(o_cyc))\n\tbegin\n\t\tif (o_rtn_miss)\n\t\tbegin\n\t\t\tassert(fp_outstanding == 0);\n\t\t\tassert(fv_outstanding == 1);\n\t\t\tassert(fv_is_one);\n\t\t\tassert(fp_is_zero);\n\t\tend else begin\n\t\t\tassert(fv_nreqs == f_ex_nreqs);\n\t\t\tassert(fv_nacks == f_ex_nacks);\n\t\t\tassert(fv_outstanding >= fp_outstanding);\n\t\t\tassert(fv_outstanding == f_expected);\n\t\tend\n\tend\n\n\talways @(*)\n\t\tassert(z_context == (r_context_word == 0));\n\talways @(*)\n\t\tassert(kernel_context == ( ((r_context_word == 0)||(!i_gie)) ? 1'b1 : 1'b0));\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_wbs_cyc_stb)))\n\t\tassume(!i_wbm_cyc);\n\talways @(*)\n\tif (o_wbs_ack)\n\t\tassume(!i_wbm_cyc);\n\n\talways @(*)\n\t\tassert((!i_wbm_cyc)||(!o_wbs_ack));\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(r_pending)&&($past(kernel_context))\n\t\t\t&&($past(i_wbm_stb))&&(!$past(i_stall))&&(i_wbm_cyc)\n\t\t\t&&(!o_rtn_stall))\n\t\tassert(o_addr[(AW-1):0] == $past(i_wbm_addr[(AW-1):0]));\n\talways @(*)\n\t\tassert(bus_pending == (bus_outstanding > 0));\n\n\talways @(*)\n\tif ((s_pending)&&(!s_tlb_miss))\n\t\tassert(r_tlb_match[s_tlb_addr]);\n\n\t// Check out all of the criteria which should clear these flags\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(($past(i_reset))\n\t\t\t||(!$past(i_wbm_cyc))\n\t\t\t||(!$past(o_rtn_stall))))\n\tbegin\n\t\tassert(!simple_miss);\n\t\tassert(!ro_miss);\n\t\tassert(!exe_miss);\n\t\tassert(!table_err);\n\t\tif (!$past(i_wbm_we))\n\t\t\tassert(!ro_miss);\n\n\t\tif (!kernel_context)\n\t\tbegin\n\t\t\tassert((!o_stb)||(!(simple_miss|ro_miss|table_err)));\n\t\t\t// This doesn't belong on the clear list, but on the\n\t\t\t// should be set list\n\t\t\t// assert((!o_stb)||(!s_tlb_hit));\n\t\tend\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wbm_cyc))\n\t\t\t&&(!$past(o_rtn_stall)))\n\tbegin\n\t\tif ((!$past(kernel_context))&&(o_stb))\n\t\t\tassert((last_page_valid)||(s_tlb_hit));\n\tend",
            "reg [(LGTBL-1):0]\t\tf_last_page;\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!kernel_context)&&(r_pending)&&(!last_page_valid))\n\t\tf_last_page <= s_tlb_addr;",
            "wire [3:0]\ttlb_flag_last_page;\n\tassign\ttlb_flag_last_page = tlb_flags[f_last_page];\n\talways @(*)\n\tif (last_page_valid)\n\tbegin\n\t\tassert(tlb_valid[f_last_page]);\n\t\tassert(last_tlb   == f_last_page);\n\t\tassert(last_ppage == tlb_pdata[f_last_page]);\n\t\tassert(last_vpage == tlb_vdata[f_last_page]);\n\t\tassert(last_ro    == tlb_flag_last_page[`ROFLAG]);\n\t\tassert(last_exe   == tlb_flag_last_page[`EXEFLG]);\n\t\tassert(r_context_word[LGCTXT-1:1] == tlb_cdata[f_last_page][LGCTXT-1:1]);\n\t\tif (!r_context_word[0])\n\t\t\tassert(!tlb_cdata[f_last_page][0]);\n\t\tassert((!r_context_word[0])||(r_context_word[0]));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t\t&&($past(last_page_valid))&&(!$past(kernel_context))\n\t\t\t&&($past(o_stb))&&($past(i_wbm_cyc)))\n\t\tassert(tlb_accessed[$past(last_tlb)]);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t\t&&($past(pending_page_valid))&&(!$past(kernel_context))\n\t\t\t&&($past(o_stb))&&($past(i_wbm_cyc)))\n\t\tassert(tlb_accessed[$past(s_tlb_addr)]);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(kernel_context))&&(o_stb))\n\tbegin\n\t\tassert(last_page_valid);\n\t\tassert(r_ppage == last_ppage);\n\t\tassert((!last_ro)||(!o_we));\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_stb))&&(o_stb)&&(i_wbm_cyc))\n\t\tassert((last_page_valid)||(kernel_context));\n\n\talways @(*)\n\t\tassert((!s_tlb_hit)||(!s_tlb_miss));\n\t// always @(*)\n\t// if ((fp_outstanding > 0)&&(o_cyc)&&(!o_stb)&&(!r_pending)&&(!kernel_context))\n\t\t// assert(last_page_valid);\n\t// always @(*) assume(kernel_context);\n\talways @(*)\n\t\tassume((!i_wbs_cyc_stb)||(!i_gie));",
            "reg f_past_gie, f_past_wbm_cyc;\n\n\tinitial\tf_past_gie = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_gie <= i_gie;\n\n\tinitial\tf_past_wbm_cyc = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_wbm_cyc <= i_wbm_cyc;\n\talways @(*)\n\tif ((f_past_valid)&&(bus_pending))\n\t\tassume(i_gie == f_past_gie);\n\talways @(*)\n\tif ((f_past_wbm_cyc)&&(i_wbm_cyc))\n\t\tassume(i_gie == f_past_gie);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(i_wbm_cyc)&&($past(i_wbm_cyc)))\n\t\tassume(i_gie == $past(i_gie));\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_reset)))\n\t\tassume(!i_gie);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wbm_cyc))\n\t\t\t&&($past(!kernel_context))\n\t\t\t&&($past(r_pending))\n\t\t\t&&(!$past(last_page_valid)))\n\tbegin\n\t\tif (($past(s_tlb_hit))\n\t\t\t\t&&(!$past(ro_miss))\n\t\t\t\t&&(!$past(exe_miss)))\n\t\tbegin\n\t\t\tassert(last_vpage == $past(r_vpage));\n\t\t\tassert(last_page_valid);\n\t\t\tassert(!miss_pending);\n\t\t\tassert(tlb_accessed[s_tlb_addr]);\n\t\tend else if (($past(s_tlb_hit))&&($past(ro_miss)))\n\t\tbegin\n\t\t\tassert(miss_pending);\n\t\t\tassert(last_page_valid);\n\t\t\tassert(status_word[3:0] == 4'h2);\n\t\tend else if (($past(s_tlb_hit))&&($past(exe_miss)))\n\t\tbegin\n\t\t\tassert(miss_pending);\n\t\t\tassert(last_page_valid);\n\t\t\tassert(status_word[3:0] == 4'h4);\n\t\tend else if (($past(s_tlb_hit))&&($past(simple_miss)))\n\t\tbegin\n\t\t\tassert(miss_pending);\n\t\t\tassert(last_page_valid);\n\t\t\tassert(status_word[3:0] == 4'h1);\n\t\tend else if (!$past(s_tlb_hit))\n\t\tbegin\n\t\t\tassert(!last_page_valid);\n\t\tend\n\tend\n\n\talways @(*)\n\t\tassert((!ro_miss)||(!exe_miss)||(!simple_miss)||(!table_err));",
            "reg [4:0]\tf_tlb_pipe;\n\n\tinitial\tf_tlb_pipe = 5'h0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_tlb_pipe <= 5'h0;\n\telse if ((!r_pending)||(o_stb))\n\t\tf_tlb_pipe <= 5'h0;\n\telse if ((r_pending)&&(!r_valid)&&(!miss_pending))\n\t\tf_tlb_pipe <= { f_tlb_pipe[3:0], 1'b1 };\n\n\talways @(*)\n\t\tassert(f_tlb_pipe != 5'h1f);\n\n\talways @(*) // WE or EXE, never both\n\tassume((!i_wbm_stb)||(!i_wbm_we)||(!i_wbm_exe));\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_wbm_stb))&&($past(o_rtn_stall)))\n\t\tassume(i_wbm_exe == $past(i_wbm_exe));\n\n\talways @(*)\n\t\tassert((!r_pending)||(!o_stb));\n\talways @(*)\n\t\tassert((!s_pending)||(!o_stb));\n\talways @(*)\n\t\tassert((!s_pending)||(r_pending));\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(i_wbm_cyc)))\n\t\tassume(!i_wbs_cyc_stb);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(|status_word[3:0])&&(!$past(i_wbm_cyc)))\n\t\tassume(!i_gie);\n`endif",
            "endmodule "
        ]
    },
    {
        "file_name": "zipcounter.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/zipcounter.v",
        "chunks": [
            "module zipcounter #(\n\t\t// {{{",
            "parameter BW = 32\n`ifdef\tFORMAL\n\t\t,",
            "localparam F_LGDEPTH = 2\n`endif\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset, i_event,\n\t\t// Wishbone",
            "input s",
            "input ",
            "wire i_wb_cyc, i_wb_stb, i_wb_we,",
            "input ",
            "wire [(BW-1):0]\ti_wb_data,\n\t\t// Wishbone",
            "output s",
            "output ",
            "wire o_wb_stall,",
            "output ",
            "reg o_wb_ack,",
            "output ",
            "reg [(BW-1):0]\to_wb_data,\n\t\t// Interrupt line",
            "output ",
            "reg o_int\n\t\t// }}}\n\t);\n\n\t// o_int, o_wb_data\n\t// {{{\n\tinitial\to_int = 0;\n\tinitial\to_wb_data = 32'h00;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\t{ o_int, o_wb_data } <= 0;\n\telse if ((i_wb_stb)&&(i_wb_we))\n\t\t{ o_int, o_wb_data } <= { 1'b0, i_wb_data };\n\telse if (i_event)\n\t\t{ o_int, o_wb_data } <= o_wb_data+{{(BW-1){1'b0}},1'b1};\n\telse\n\t\to_int <= 1'b0;\n\t// }}}\n\n\t// o_wb_ack\n\t// {{{\n\tinitial\to_wb_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_wb_ack <= 1'b0;\n\telse\n\t\to_wb_ack <= i_wb_stb;\n\t// }}}\n\tassign\to_wb_stall = 1'b0;\n\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, i_wb_cyc };\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions about our",
            "input s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus interface properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// We never stall the bus\n\talways @(*)\n\t\tassert(!o_wb_stall);\n\n\t// We always ack every transaction on the following clock\n\talways @(posedge i_clk)\n\t\tassert(o_wb_ack == ((f_past_valid)&&(!$past(i_reset))\n\t\t\t\t\t\t&&($past(i_wb_stb))));",
            "wire [(F_LGDEPTH-1):0]\tf_nreqs, f_nacks, f_outstanding;\n\n\tfwb_slave #(\n\t\t// {{{\n\t\t.AW(1), .F_MAX_STALL(0),\n\t\t\t.F_MAX_ACK_DELAY(1), .F_LGDEPTH(F_LGDEPTH)\n\t\t// }}}\n\t) fwbi(\n\t\t// {{{\n\t\ti_clk, i_reset,\n\t\ti_wb_cyc, i_wb_stb, i_wb_we, 1'b0, i_wb_data, 4'hf,\n\t\t\to_wb_ack, o_wb_stall, o_wb_data, 1'b0,\n\t\tf_nreqs, f_nacks, f_outstanding\n\t\t// }}}\n\t);\n\n\talways @(*)\n\tif ((o_wb_ack)&&(i_wb_cyc))\n\tbegin\n\t\tassert(f_outstanding==1);\n\tend else\n\t\tassert(f_outstanding == 0);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions about our",
            "output s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Drop the interrupt line and reset the counter on any reset\n\t// {{{\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset))\n\t\tassert((!o_int)&&(o_wb_data == 0));\n\t// }}}\n\n\t// Clear the interrupt and set the counter on any write (other than\n\t// during a reset)\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))\n\t\t&&($past(i_wb_stb))&&($past(i_wb_we)))\n\t\tassert((!o_int)&&(o_wb_data == $past(i_wb_data)));\n\t// }}}\n\n\t// Normal",
            "logic of the routine itself\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&(!$past(i_wb_stb)))\n\tbegin\n\t\tif (!$past(i_event))\n\t\tbegin\n\t\t\t// If the CE line wasn't set on the last clock, then the\n\t\t\t// counter must not change, and the interrupt line must\n\t\t\t// be low.\n\t\t\tassert(o_wb_data == $past(o_wb_data));\n\t\t\tassert(!o_int);\n\t\tend else // if ($past(i_event))\n\t\tbegin\n\t\t\t// Otherwise, if the CE line was high on the last clock,\n\t\t\t// then our counter should have incremented.\n\t\t\tassert(o_wb_data == $past(o_wb_data) + 1'b1);\n\n\t\t\t// Likewise, if the counter rolled over, then the\n\t\t\t//",
            "output interrupt, o_int, should be true.\n\t\t\tif ($past(o_wb_data)=={(BW){1'b1}})\n\t\t\tbegin\n\t\t\t\tassert(o_int);\n\t\t\tend else\n\t\t\t\t// In all other circumstances it should be clear\n\t\t\t\tassert(!o_int);\n\t\tend\n\tend\n\t// ?}}}\n\n\t// The",
            "output interrupt should never be true two clocks in a row\n\t// {{{\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_int)))\n\t\tassert(!o_int);\n\t// }}}\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "icontrol.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/icontrol.v",
        "chunks": [
            "reg ister with this bit set and the global enable set.\n//\t\tTo disable this line, write to this",
            "reg ister with global enable\n//\t\tbit not set, but this bit set.  (Writing a zero to any of these\n//\t\tbits has no effect, either setting or unsetting them.)\n//\tBit 15 - This is the any interrupt pin.  If any interrupt is pending,\n//\t\tthis bit will be set.\n//\tBits 0-14\t- These are interrupt bits.  When set, an interrupt is\n//\t\tpending from the corresponding source--",
            "reg ardless of whether\n//\t\tit was enabled.  (If not enabled, it won't generate an\n//\t\tinterrupt, but it will still",
            "reg ister here.)  To clear any\n//\t\tof these bits, write a '1' to the corresponding bit.  Writing\n//\t\ta zero to any of these bits has no effect.\n//\n//\tThe peripheral also sports a",
            "parameter , IUSED, which can be set\n//\tto any value between 1 and (buswidth/2-1, or) 15 inclusive.  This will\n//\tbe the number of interrupts handled by this routine.  (Without the\n//",
            "parameter , Vivado was complaining about unused bits.  With it, we can\n//\tkeep the complaints down and still use the routine).\n//\n//\tTo get access to more than 15 interrupts, chain these together, so\n//\tthat one interrupt controller device feeds another.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module icontrol #(\n\t\t// {{{",
            "parameter IUSED = 12, DW=32\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,",
            "input ",
            "wire i_wb_cyc, i_wb_stb, i_wb_we,",
            "input ",
            "wire [DW-1:0]\ti_wb_data,",
            "input ",
            "wire [DW/8-1:0]\ti_wb_sel,",
            "output ",
            "wire o_wb_stall, o_wb_ack,",
            "output ",
            "reg [DW-1:0]\to_wb_data,",
            "input ",
            "wire [(IUSED-1):0]\ti_brd_ints,",
            "output ",
            "reg o_interrupt\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "reg [(IUSED-1):0]\tr_int_state;",
            "reg [(IUSED-1):0]\tr_int_enable;",
            "reg r_mie;",
            "wire w_any;",
            "wire wb_write, enable_ints, disable_ints;\n\t// }}}\n\tassign\twb_write     = (i_wb_stb)&&(i_wb_we);\n\tassign\tenable_ints  = (wb_write)&&( i_wb_data[15]);\n\tassign\tdisable_ints = (wb_write)&&(!i_wb_data[15]);\n\n\t// r_int_state\n\t// {{{\n\t// First step: figure out which interrupts have triggered.  An\n\t// interrupt \"triggers\" when the incoming interrupt",
            "wire is high, and\n\t// stays triggered until cleared by the bus.\n\tinitial\tr_int_state = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_int_state  <= 0;\n\telse if (wb_write)\n\t\tr_int_state <= i_brd_ints\n\t\t\t| (r_int_state & (~i_wb_data[(IUSED-1):0]));\n\telse\n\t\tr_int_state <= (r_int_state | i_brd_ints);\n\t// }}}\n\n\t// r_int_enable\n\t// {{{\n\t// Second step: determine which interrupts are enabled.\n\t// Only interrupts that are enabled will be propagated forward on\n\t// the global interrupt line.\n\tinitial\tr_int_enable = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_int_enable <= 0;\n\telse if (enable_ints)\n\t\tr_int_enable <= r_int_enable | i_wb_data[16 +: IUSED];\n\telse if (disable_ints)\n\t\tr_int_enable <= r_int_enable & (~ i_wb_data[16 +: IUSED]);\n\t// }}}\n\n\t// r_mie\n\t// {{{\n\t// Third step: The master (global) interrupt enable bit.\n\tinitial\tr_mie = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_mie <= 1'b0;\n\telse if (enable_ints && i_wb_data[DW-1])\n\t\tr_mie <= 1'b1;\n\telse if (disable_ints && i_wb_data[DW-1])\n\t\tr_mie <= 1'b0;\n\t// }}}\n\n\t//\n\t// Have \"any\" enabled interrupts triggered?\n\tassign\tw_any = ((r_int_state & r_int_enable) != 0);\n\n\t// o_interrupt\n\t// {{{\n\t// How then shall the interrupt",
            "wire be set?\n\tinitial\to_interrupt = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_interrupt <= 1'b0;\n\telse\n\t\to_interrupt <= (r_mie)&&(w_any);\n\t// }}}\n\n\t// o_wb_data\n\t// {{{\n\t// Create the",
            "output data.  Place this into the next clock, to keep\n\t// it synchronous with w_any.\n\tinitial\to_wb_data = 0;\n\talways @(posedge i_clk)\n\tbegin\n\t\to_wb_data <= 0;\n\t\to_wb_data[31] <= r_mie;\n\t\to_wb_data[15] <= w_any;\n\n\t\to_wb_data[16 +: IUSED] <= r_int_enable;\n\t\to_wb_data[ 0 +: IUSED] <= r_int_state;\n\tend\n\t// }}}\n\n\tassign\to_wb_ack = i_wb_stb;\n\tassign\to_wb_stall = 1'b0;\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED\n\tgenerate if (IUSED < 15)\n\tbegin : UNUSED_INTS",
            "wire unused_int;\n\t\tassign\tunused_int = &{ 1'b0, i_wb_data[32-2:(16+IUSED)],\n\t\t\t\ti_wb_data[16-2:IUSED] };\n\tend endgenerate",
            "wire unused;\n\tassign\tunused = &{ 1'b0, i_wb_cyc, i_wb_sel };\n\t// verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties section\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// {{{\n`ifdef\tICONTROL\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif",
            "reg f_past_valid;\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Reset handling\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tinitial\t`ASSUME(i_reset);\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(i_reset);\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\tbegin\n\t\tassert(r_int_state  == 0);\n\t\tassert(r_int_enable == 0);\n\t\tassert(w_any == 0);\n\t\tassert(o_interrupt == 0);\n\t\tassert(r_mie == 0);\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Formal contract\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// Rule #1: An interrupt should be able to set the r_int_state bits\n\t//\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset)))\n\t\tassert((r_int_state & $past(i_brd_ints))==$past(i_brd_ints));\n\n\t// Rule #2: An interrupt should be generated if received and enabled\n\t//\n\t// Make sure any enabled interrupt generates an outgoing interrupt\n\t// ... assuming the master interrupt enable is true and the\n\t// individual interrupt enable is true as well.\n\talways @(posedge i_clk)\n\tif (((f_past_valid)&&(!$past(i_reset)))\n\t\t\t&&(|$past(r_int_state & r_int_enable))\n\t\t\t&&($past(r_mie)) )\n\t\tassert(o_interrupt);\n\n\t// Rule #3: If the global interrupt enable bit is off, then no\n\t//\tinterrupts shall be asserted\n\t//\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(r_mie)))\n\t\tassert(!o_interrupt);\n\n\t// Rule #4: If no active interrupts are enabled, then no outgoing\n\t// \tinterrupt shall be asserted either\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(0 == |$past(r_int_state & r_int_enable)))\n\t\tassert(!o_interrupt);\n\n\t// Bus rules\n\t//\n\t// Rule #5: It should be possible to disable one (or all) interrupts\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(disable_ints)))\n\t\tassert(($past({i_wb_data[31],i_wb_data[16 +: IUSED]})\n\t\t\t& { r_mie, r_int_enable }) == 0);\n\n\t// Rule #6: It should be possible to enable one (or all) interrupts\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(enable_ints)))\n\t\tassert(($past({i_wb_data[31],i_wb_data[16 +: IUSED]})\n\t\t\t& { r_mie, r_int_enable })\n\t\t\t== $past({i_wb_data[31],i_wb_data[16 +: IUSED]}));\n\n\t// Rule #7: It shoule be possible to acknowledge an interrupt, and so\n\t//\tdeactivate it\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(wb_write)))\n\t\tassert(r_int_state == $past(i_brd_ints\n\t\t\t\t| (r_int_state & ~i_wb_data[IUSED-1:0])));\n\n\t// Rule #8: The interrupt enables should be stable without a write\n\talways @(posedge i_clk)\n\tif ((f_past_valid) && (!$past(i_reset)) && (!$past(wb_write)))\n\t\tassert($stable({r_mie, r_int_enable}));\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Bus properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//",
            "wire [1:0]\tf_nreqs, f_nacks, f_outstanding;",
            "reg past_stb;\n\n\talways @(*)\n\tif (i_wb_stb)\n\t\tassume(i_wb_cyc);\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid || $past(i_reset))\n\t\tassume(!i_wb_cyc);\n\n\n\tfwb_slave #(.DW(DW), .AW(1), .F_MAX_STALL(0), .F_MAX_ACK_DELAY(1),\n\t\t.F_LGDEPTH(2), .F_MAX_REQUESTS(1), .F_OPT_MINCLOCK_DELAY(0))\n\t\tfwb(i_clk, i_reset,\n\t\t\ti_wb_cyc, i_wb_stb, i_wb_we,\n\t\t\t1'b0, i_wb_data, 4'hf,\n\t\t\to_wb_ack, o_wb_stall, o_wb_data, 1'b0,\n\t\t\tf_nreqs, f_nacks, f_outstanding);\n\n\talways @(*)\n\t\tassert(f_outstanding == 0);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Other consistency",
            "logic // {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Without a write or a reset, past interrupts should remain\n\t// enabled.\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(wb_write))&&(!$past(i_reset)))\n\tbegin\n\t\tassert(($past(r_int_state)& ~r_int_state)==0);\n\t\tassert((!$past(w_any)) || w_any);\n\tend\n\n\t// The outgoing interrupt should never be high unless w_any\n\t// is also high\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(w_any)))\n\t\tassert(!o_interrupt);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(posedge i_clk)\n\t\tcover(o_interrupt);\n\n\talways @(posedge i_clk)\n\tif (!f_past_valid)\n\t\tcover($fell(w_any) && $stable(r_int_enable));\n\n\talways @(posedge i_clk)\n\tif (f_past_valid)\n\tbegin\n\t\tcover(!o_interrupt && $past(w_any));\n\t\tcover(!o_interrupt && $past(r_mie) && $past(|r_int_state));\n\tend\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "axilperiphs.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/axilperiphs.v",
        "chunks": [
            "module axilperiphs #(\n\t\t// {{{\n\t\t//\n\t\t// Size of the AXI-lite bus.  These are fixed, since 1) AXI-lite\n\t\t// is fixed at a width of 32-bits by Xilinx def'n, and 2) since\n\t\t// we only ever have 4 configuration words.",
            "parameter C_AXI_ADDR_WIDTH =  6,",
            "localparam C_AXI_DATA_WIDTH = 32,",
            "parameter [0:0]\tOPT_SKIDBUFFER = 1'b1,",
            "parameter [0:0]\tOPT_LOWPOWER = 0,",
            "parameter EXTERNAL_INTERRUPTS = 1,",
            "parameter [0:0]\tOPT_COUNTERS = 1,",
            "localparam ADDRLSB = $clog2(C_AXI_DATA_WIDTH)-3\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,\n\t\t// AXI-lite interface\n\t\t// {{{",
            "input ",
            "wire S_AXI_AWVALID,",
            "output ",
            "wire S_AXI_AWREADY,",
            "input ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\t\tS_AXI_AWADDR,",
            "input ",
            "wire [2:0]\t\t\t\tS_AXI_AWPROT,\n\t\t//",
            "input ",
            "wire S_AXI_WVALID,",
            "output ",
            "wire S_AXI_WREADY,",
            "input ",
            "wire [C_AXI_DATA_WIDTH-1:0]\t\tS_AXI_WDATA,",
            "input ",
            "wire [C_AXI_DATA_WIDTH/8-1:0]\tS_AXI_WSTRB,\n\t\t//",
            "output ",
            "wire S_AXI_BVALID,",
            "input ",
            "wire S_AXI_BREADY,",
            "output ",
            "wire [1:0]\t\t\t\tS_AXI_BRESP,\n\t\t//",
            "input ",
            "wire S_AXI_ARVALID,",
            "output ",
            "wire S_AXI_ARREADY,",
            "input ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\t\tS_AXI_ARADDR,",
            "input ",
            "wire [2:0]\t\t\t\tS_AXI_ARPROT,\n\t\t//",
            "output ",
            "wire S_AXI_RVALID,",
            "input ",
            "wire S_AXI_RREADY,",
            "output ",
            "wire [C_AXI_DATA_WIDTH-1:0]\t\tS_AXI_RDATA,",
            "output ",
            "wire [1:0]\t\t\t\tS_AXI_RRESP,\n\t\t// }}}",
            "input ",
            "wire i_cpu_reset,",
            "input ",
            "wire i_cpu_halted,",
            "input ",
            "wire i_cpu_gie,",
            "input ",
            "wire i_cpu_pfstall,",
            "input ",
            "wire i_cpu_opstall,",
            "input ",
            "wire i_cpu_icount,",
            "input ",
            "wire [EXTERNAL_INTERRUPTS-1:0]\ti_ivec,",
            "output ",
            "wire o_interrupt,",
            "output ",
            "wire o_watchdog_reset\n\t\t// }}}\n\t);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Register/",
            "wire signal declarations\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "localparam [3:0]\tADR_PIC\t\t= 4'h0,\n\t\t\t\tADR_WATCHDOG\t= 4'h1,\n\t\t\t\tADR_APIC\t= 4'h2;\n\t\t\t\t// No bus watchdog",
            "localparam [3:0]\tADR_TIMERA = 4'h4,\n\t\t\t\tADR_TIMERB = 4'h5,\n\t\t\t\tADR_TIMERC = 4'h6,\n\t\t\t\tADR_JIFFIES= 4'h7;",
            "localparam [3:0]\tADR_MCLOCKS = 4'h8,\n\t\t\t\tADR_MOPSTALL = 4'h9,\n\t\t\t\tADR_MPFSTALL = 4'ha,\n\t\t\t\tADR_MICOUNT  = 4'hb;",
            "localparam [3:0]\tADR_UCLOCKS = 4'hc,\n\t\t\t\tADR_UOPSTALL = 4'hd,\n\t\t\t\tADR_UPFSTALL = 4'he,\n\t\t\t\tADR_UICOUNT  = 4'hf;",
            "wire i_reset = !S_AXI_ARESETN;",
            "wire axil_write_ready;",
            "wire [C_AXI_ADDR_WIDTH-ADDRLSB-1:0]\tawskd_addr;\n\t//",
            "wire [C_AXI_DATA_WIDTH-1:0]\twskd_data;",
            "wire [C_AXI_DATA_WIDTH/8-1:0]\twskd_strb;",
            "reg axil_bvalid;\n\t//",
            "wire axil_read_ready;",
            "wire [C_AXI_ADDR_WIDTH-ADDRLSB-1:0]\tarskd_addr;",
            "reg [C_AXI_DATA_WIDTH-1:0]\taxil_read_data;",
            "reg axil_read_valid;",
            "wire pic_stall, pic_ack;",
            "wire [31:0]\tpic_data;",
            "wire wdog_stall, wdog_ack;",
            "wire [31:0]\twdog_data;",
            "wire apic_stall, apic_ack, apic_int;",
            "wire [31:0]\tapic_data;",
            "wire tmra_stall, tmra_ack, tmra_int;",
            "wire [31:0]\ttmra_data;",
            "wire tmrb_stall, tmrb_ack, tmrb_int;",
            "wire [31:0]\ttmrb_data;",
            "wire tmrc_stall, tmrc_ack, tmrc_int;",
            "wire [31:0]\ttmrc_data;",
            "wire jif_stall, jif_ack, jif_int;",
            "wire [31:0]\tjif_data;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI-lite signaling\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Write signaling\n\t//\n\t// {{{\n\n\tgenerate if (OPT_SKIDBUFFER)\n\tbegin : SKIDBUFFER_WRITE",
            "wire awskd_valid, wskd_valid;\n\n\t\tskidbuffer #(.OPT_OUTREG(0),\n\t\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t\t.DW(C_AXI_ADDR_WIDTH-ADDRLSB))\n\t\taxilawskid(//\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(i_reset),\n\t\t\t.i_valid(S_AXI_AWVALID), .o_ready(S_AXI_AWREADY),\n\t\t\t.i_data(S_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB]),\n\t\t\t.o_valid(awskd_valid), .i_ready(axil_write_ready),\n\t\t\t.o_data(awskd_addr));\n\n\t\tskidbuffer #(.OPT_OUTREG(0),\n\t\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t\t.DW(C_AXI_DATA_WIDTH+C_AXI_DATA_WIDTH/8))\n\t\taxilwskid(//\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(i_reset),\n\t\t\t.i_valid(S_AXI_WVALID), .o_ready(S_AXI_WREADY),\n\t\t\t.i_data({ S_AXI_WDATA, S_AXI_WSTRB }),\n\t\t\t.o_valid(wskd_valid), .i_ready(axil_write_ready),\n\t\t\t.o_data({ wskd_data, wskd_strb }));\n\n\t\tassign\taxil_write_ready = awskd_valid && wskd_valid\n\t\t\t\t&& (!S_AXI_BVALID || S_AXI_BREADY);\n\n\tend else begin : SIMPLE_WRITES",
            "reg axil_awready;\n\n\t\tinitial\taxil_awready = 1'b0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\taxil_awready <= 1'b0;\n\t\telse\n\t\t\taxil_awready <= !axil_awready\n\t\t\t\t&& (S_AXI_AWVALID && S_AXI_WVALID)\n\t\t\t\t&& (!S_AXI_BVALID || S_AXI_BREADY);\n\n\t\tassign\tS_AXI_AWREADY = axil_awready;\n\t\tassign\tS_AXI_WREADY  = axil_awready;\n\n\t\tassign \tawskd_addr = S_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB];\n\t\tassign\twskd_data  = S_AXI_WDATA;\n\t\tassign\twskd_strb  = S_AXI_WSTRB;\n\n\t\tassign\taxil_write_ready = axil_awready;\n\n\tend endgenerate\n\n\tinitial\taxil_bvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_reset)\n\t\taxil_bvalid <= 0;\n\telse if (axil_write_ready)\n\t\taxil_bvalid <= 1;\n\telse if (S_AXI_BREADY)\n\t\taxil_bvalid <= 0;\n\n\tassign\tS_AXI_BVALID = axil_bvalid;\n\tassign\tS_AXI_BRESP = 2'b00;\n\t// }}}\n\n\t//\n\t// Read signaling\n\t//\n\t// {{{\n\n\tgenerate if (OPT_SKIDBUFFER)\n\tbegin : SKIDBUFFER_READ",
            "wire arskd_valid;\n\n\t\tskidbuffer #(.OPT_OUTREG(0),\n\t\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t\t.DW(C_AXI_ADDR_WIDTH-ADDRLSB))\n\t\taxilarskid(//\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(i_reset),\n\t\t\t.i_valid(S_AXI_ARVALID), .o_ready(S_AXI_ARREADY),\n\t\t\t.i_data(S_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB]),\n\t\t\t.o_valid(arskd_valid), .i_ready(axil_read_ready),\n\t\t\t.o_data(arskd_addr));\n\n\t\tassign\taxil_read_ready = arskd_valid\n\t\t\t\t&& (!axil_read_valid || S_AXI_RREADY);\n\n\tend else begin : SIMPLE_READS",
            "reg axil_arready;\n\n\t\talways @(*)\n\t\t\taxil_arready = !S_AXI_RVALID;\n\n\t\tassign\tarskd_addr = S_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB];\n\t\tassign\tS_AXI_ARREADY = axil_arready;\n\t\tassign\taxil_read_ready = (S_AXI_ARVALID && S_AXI_ARREADY);\n\n\tend endgenerate\n\n\tinitial\taxil_read_valid = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_reset)\n\t\taxil_read_valid <= 1'b0;\n\telse if (axil_read_ready)\n\t\taxil_read_valid <= 1'b1;\n\telse if (S_AXI_RREADY)\n\t\taxil_read_valid <= 1'b0;\n\n\tassign\tS_AXI_RVALID = axil_read_valid;\n\tassign\tS_AXI_RDATA  = axil_read_data;\n\tassign\tS_AXI_RRESP = 2'b00;\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI-lite",
            "reg ister",
            "logic // {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Interrupt handling\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg [30:0]\tint_vector;\n\n\t// Generate the interrupt vector\n\t// {{{\n\tgenerate if (EXTERNAL_INTERRUPTS == 0)\n\tbegin : NO_EXTERNAL_INTERRUPTS\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tint_vector = 0;\n\t\t\tint_vector[5:0] = { apic_int, tmra_int, tmrb_int,\n\t\t\t\t\ttmrc_int, jif_int, 1'b0 };\n\t\tend\n\t\t// }}}\n\tend else if (EXTERNAL_INTERRUPTS == 1)\n\tbegin : SINGLE_EXTERNAL_INTERRUPT\n\t\t// {{{\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tint_vector = 0;\n\t\t\tint_vector[5:0] = { apic_int, tmra_int, tmrb_int,\n\t\t\t\t\ttmrc_int, jif_int, i_ivec[0] };\n\t\tend\n\t\t// }}}\n\tend else begin : MANY_EXTERNAL_INTERRUPTS\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tint_vector = 0;\n\t\t\tint_vector[5:0] = { apic_int, tmra_int, tmrb_int,\n\t\t\t\t\ttmrc_int, jif_int, i_ivec[0] };\n\t\t\tint_vector[EXTERNAL_INTERRUPTS+5-1:6]\n\t\t\t\t\t= i_ivec[EXTERNAL_INTERRUPTS-1:1];\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\ticontrol #(.IUSED(15))\n\tpic(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset),\n\t\t.i_wb_cyc(axil_write_ready),\n\t\t.i_wb_stb(axil_write_ready && awskd_addr == ADR_PIC),\n\t\t.i_wb_we(1'b1), .i_wb_data(wskd_data), .i_wb_sel(wskd_strb),\n\t\t.o_wb_stall(pic_stall), .o_wb_ack(pic_ack),.o_wb_data(pic_data),\n\t\t.i_brd_ints(int_vector[14:0]), .o_interrupt(o_interrupt)\n\t\t// }}}\n\t);\n\n\tziptimer #(32,31,0)\n\twatchdog(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset),\n\t\t.i_ce(!i_cpu_halted), .i_wb_cyc(1'b1),\n\t\t.i_wb_stb(axil_write_ready && awskd_addr == ADR_WATCHDOG),\n\t\t.i_wb_we(1'b1), .i_wb_data(wskd_data), .i_wb_sel(wskd_strb),\n\t\t.o_wb_stall(wdog_stall),\n\t\t.o_wb_ack(wdog_ack), .o_wb_data(wdog_data),\n\t\t.o_int(o_watchdog_reset)\n\t\t// }}}\n\t);\n\n\t// APIC\n\t// {{{\n\tgenerate if (EXTERNAL_INTERRUPTS > 15)\n\tbegin : APIC\n\n\t\ticontrol #(.IUSED(15))\n\t\tapic(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset),\n\t\t\t.i_wb_cyc(axil_write_ready),\n\t\t\t.i_wb_stb(axil_write_ready && awskd_addr == ADR_APIC),\n\t\t\t.i_wb_we(1'b1), .i_wb_data(wskd_data),\n\t\t\t\t.i_wb_sel(wskd_strb),\n\t\t\t.o_wb_stall(apic_stall), .o_wb_ack(apic_ack),\n\t\t\t\t.o_wb_data(apic_data),\n\t\t\t.i_brd_ints(int_vector[30:15]),\n\t\t\t.o_interrupt(o_interrupt)\n\t\t\t// }}}\n\t\t);\n\n\tend else begin : NO_APIC\n\n\t\tassign\tapic_data  = 0;\n\t\tassign\tapic_stall = 0;\n\t\tassign\tapic_ack   = 0;\n\t\tassign\tapic_int   = 0;\n\n\tend endgenerate\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Timers\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tziptimer\n\ttimer_a(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset),\n\t\t.i_ce(!i_cpu_halted), .i_wb_cyc(1'b1),\n\t\t.i_wb_stb(axil_write_ready && awskd_addr == ADR_TIMERA),\n\t\t.i_wb_we(1'b1), .i_wb_data(wskd_data), .i_wb_sel(wskd_strb),\n\t\t\t\t.o_wb_stall(tmra_stall),\n\t\t.o_wb_ack(tmra_ack), .o_wb_data(tmra_data), .o_int(tmra_int)\n\t\t// }}}\n\t);\n\n\tziptimer\n\ttimer_b(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset),\n\t\t.i_ce(!i_cpu_halted), .i_wb_cyc(1'b1),\n\t\t.i_wb_stb(axil_write_ready && awskd_addr == ADR_TIMERB),\n\t\t.i_wb_we(1'b1), .i_wb_data(wskd_data),  .i_wb_sel(wskd_strb),\n\t\t\t\t.o_wb_stall(tmrb_stall),\n\t\t.o_wb_ack(tmrb_ack), .o_wb_data(tmrb_data), .o_int(tmrb_int)\n\t\t// }}}\n\t);\n\n\tziptimer\n\ttimer_c(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset),\n\t\t.i_ce(!i_cpu_halted), .i_wb_cyc(1'b1),\n\t\t.i_wb_stb(axil_write_ready && awskd_addr == ADR_TIMERC),\n\t\t.i_wb_we(1'b1), .i_wb_data(wskd_data),  .i_wb_sel(wskd_strb),\n\t\t\t\t.o_wb_stall(tmrc_stall),\n\t\t.o_wb_ack(tmrc_ack), .o_wb_data(tmrc_data), .o_int(tmrc_int)\n\t\t// }}}\n\t);\n\n\tzipjiffies\n\tjiffies(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(i_cpu_reset),\n\t\t.i_ce(!i_cpu_halted), .i_wb_cyc(1'b1),\n\t\t.i_wb_stb(axil_write_ready && awskd_addr == ADR_JIFFIES),\n\t\t.i_wb_we(1'b1), .i_wb_data(wskd_data), .i_wb_sel(wskd_strb),\n\t\t\t\t.o_wb_stall(jif_stall),\n\t\t.o_wb_ack(jif_ack), .o_wb_data(jif_data), .o_int(jif_int)\n\t\t// }}}\n\t);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Optional performance counters\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "wire [31:0]\tmtask, mopstall, mpfstall, micount;",
            "wire [31:0]\tutask, uopstall, upfstall, uicount;\n\n\tgenerate if (OPT_COUNTERS)\n\tbegin : ACCOUNTING_COUNTERS\n\t\t// {{{",
            "reg [31:0]\tr_mtask, r_mopstall, r_mpfstall, r_micount;",
            "reg [31:0]\tr_utask, r_uopstall, r_upfstall, r_uicount;\n\n\t\tinitial\t{ r_mtask, r_mopstall, r_mpfstall, r_micount } = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (i_cpu_reset)\n\t\t\t{ r_mtask, r_mopstall, r_mpfstall, r_micount } <= 0;\n\t\telse begin\n\t\t\tif (!i_cpu_halted)\n\t\t\t\tr_mtask <= r_mtask + 1;\n\t\t\tif (i_cpu_opstall)\n\t\t\t\tr_mopstall <= mopstall + 1;\n\t\t\tif (i_cpu_pfstall)\n\t\t\t\tr_mpfstall <= r_mpfstall + 1;\n\t\t\tif (i_cpu_icount)\n\t\t\t\tr_micount <= r_micount + 1;\n\n\t\t\tif (axil_write_ready)\n\t\t\tcase(awskd_addr)\n\t\t\tADR_MCLOCKS: begin\n\t\t\t\t// {{{\n\t\t\t\tif(wskd_strb[0]) r_mtask[ 7: 0]<=wskd_data[ 7: 0];\n\t\t\t\tif(wskd_strb[1]) r_mtask[15: 8]<=wskd_data[15: 8];\n\t\t\t\tif(wskd_strb[2]) r_mtask[23:16]<=wskd_data[23:16];\n\t\t\t\tif(wskd_strb[3]) r_mtask[31:24]<=wskd_data[31:24];\n\t\t\t\tend\n\t\t\t\t// }}}\n\t\t\tADR_MOPSTALL: begin\n\t\t\t\t// {{{\n\t\t\t\tif(wskd_strb[0]) r_mopstall[ 7: 0]<=wskd_data[ 7: 0];\n\t\t\t\tif(wskd_strb[1]) r_mopstall[15: 8]<=wskd_data[15: 8];\n\t\t\t\tif(wskd_strb[2]) r_mopstall[23:16]<=wskd_data[23:16];\n\t\t\t\tif(wskd_strb[3]) r_mopstall[31:24]<=wskd_data[31:24];\n\t\t\t\tend\n\t\t\t\t// }}}\n\t\t\tADR_MPFSTALL: begin\n\t\t\t\t// {{{\n\t\t\t\tif(wskd_strb[0]) r_mpfstall[ 7: 0]<=wskd_data[ 7: 0];\n\t\t\t\tif(wskd_strb[1]) r_mpfstall[15: 8]<=wskd_data[15: 8];\n\t\t\t\tif(wskd_strb[2]) r_mpfstall[23:16]<=wskd_data[23:16];\n\t\t\t\tif(wskd_strb[3]) r_mpfstall[31:24]<=wskd_data[31:24];\n\t\t\t\tend\n\t\t\t\t// }}}\n\t\t\tADR_MICOUNT: begin\n\t\t\t\t// {{{\n\t\t\t\tif(wskd_strb[0]) r_micount[ 7: 0]<=wskd_data[ 7: 0];\n\t\t\t\tif(wskd_strb[1]) r_micount[15: 8]<=wskd_data[15: 8];\n\t\t\t\tif(wskd_strb[2]) r_micount[23:16]<=wskd_data[23:16];\n\t\t\t\tif(wskd_strb[3]) r_micount[31:24]<=wskd_data[31:24];\n\t\t\t\tend\n\t\t\t\t// }}}\n\t\t\tdefault: begin end\n\t\t\tendcase\n\t\tend\n\n\t\tinitial\t{ r_utask, r_uopstall, r_upfstall, r_uicount } = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (i_cpu_reset)\n\t\t\t{ r_utask, r_uopstall, r_upfstall, r_uicount } <= 0;\n\t\telse begin\n\t\t\tif (!i_cpu_halted && i_cpu_gie)\n\t\t\t\tr_utask <= r_utask + 1;\n\t\t\tif (i_cpu_opstall && i_cpu_gie)\n\t\t\t\tr_uopstall <= r_uopstall + 1;\n\t\t\tif (i_cpu_pfstall && i_cpu_gie)\n\t\t\t\tr_upfstall <= r_upfstall + 1;\n\t\t\tif (i_cpu_icount && i_cpu_gie)\n\t\t\t\tr_uicount <= r_uicount + 1;\n\n\t\t\tif (axil_write_ready)\n\t\t\tcase(awskd_addr)\n\t\t\tADR_UCLOCKS: begin\n\t\t\t\t// {{{\n\t\t\t\tif(wskd_strb[0]) r_utask[ 7: 0]<=wskd_data[ 7: 0];\n\t\t\t\tif(wskd_strb[1]) r_utask[15: 8]<=wskd_data[15: 8];\n\t\t\t\tif(wskd_strb[2]) r_utask[23:16]<=wskd_data[23:16];\n\t\t\t\tif(wskd_strb[3]) r_utask[31:24]<=wskd_data[31:24];\n\t\t\t\tend\n\t\t\t\t// }}}\n\t\t\tADR_UOPSTALL: begin\n\t\t\t\t// {{{\n\t\t\t\tif(wskd_strb[0]) r_uopstall[ 7: 0]<=wskd_data[ 7: 0];\n\t\t\t\tif(wskd_strb[1]) r_uopstall[15: 8]<=wskd_data[15: 8];\n\t\t\t\tif(wskd_strb[2]) r_uopstall[23:16]<=wskd_data[23:16];\n\t\t\t\tif(wskd_strb[3]) r_uopstall[31:24]<=wskd_data[31:24];\n\t\t\t\tend\n\t\t\t\t// }}}\n\t\t\tADR_UPFSTALL: begin\n\t\t\t\t// {{{\n\t\t\t\tif(wskd_strb[0]) r_upfstall[ 7: 0]<=wskd_data[ 7: 0];\n\t\t\t\tif(wskd_strb[1]) r_upfstall[15: 8]<=wskd_data[15: 8];\n\t\t\t\tif(wskd_strb[2]) r_upfstall[23:16]<=wskd_data[23:16];\n\t\t\t\tif(wskd_strb[3]) r_upfstall[31:24]<=wskd_data[31:24];\n\t\t\t\tend\n\t\t\t\t// }}}\n\t\t\tADR_UICOUNT: begin\n\t\t\t\t// {{{\n\t\t\t\tif(wskd_strb[0]) r_uicount[ 7: 0]<=wskd_data[ 7: 0];\n\t\t\t\tif(wskd_strb[1]) r_uicount[15: 8]<=wskd_data[15: 8];\n\t\t\t\tif(wskd_strb[2]) r_uicount[23:16]<=wskd_data[23:16];\n\t\t\t\tif(wskd_strb[3]) r_uicount[31:24]<=wskd_data[31:24];\n\t\t\t\tend\n\t\t\t\t// }}}\n\t\t\tdefault: begin end\n\t\t\tendcase\n\t\tend\n\n\t\tassign\t{ mtask, mopstall, mpfstall, micount } =\n\t\t\t\t{ r_mtask, r_mopstall, r_mpfstall, r_micount };\n\t\tassign\t{ utask, uopstall, upfstall, uicount } =\n\t\t\t\t{ r_utask, r_uopstall, r_upfstall, r_uicount };\n\n\t\t// }}}\n\tend else begin : NO_ACCOUNTING\n\n\t\tassign\t{ mtask, mopstall, mpfstall, micount } = 0;\n\t\tassign\t{ utask, uopstall, upfstall, uicount } = 0;\n\n\tend endgenerate\n\t// }}}\n\n\t// axil_read_data\n\t// {{{\n\tinitial\taxil_read_data = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\taxil_read_data <= 0;\n\telse if (!S_AXI_RVALID || S_AXI_RREADY)\n\tbegin\n\t\taxil_read_data\t<= 0;\n\t\tcase({ (OPT_COUNTERS & arskd_addr[3]), arskd_addr[2:0] })\n\t\tADR_PIC:\taxil_read_data\t<= pic_data;\n\t\tADR_WATCHDOG:\taxil_read_data\t<= wdog_data;\n\t\t// 3'b10:\taxil_read_data\t<= watchdog_data;\n\t\tADR_APIC:\taxil_read_data\t<= apic_data;\n\t\tADR_TIMERA:\taxil_read_data\t<= tmra_data;\n\t\tADR_TIMERB:\taxil_read_data\t<= tmrb_data;\n\t\tADR_TIMERC:\taxil_read_data\t<= tmrc_data;\n\t\tADR_JIFFIES:\taxil_read_data\t<= jif_data;\n\t\t// Supervisor counters\n\t\tADR_MCLOCKS:\taxil_read_data\t<= mtask;\n\t\tADR_MOPSTALL:\taxil_read_data\t<= mopstall;\n\t\tADR_MPFSTALL:\taxil_read_data\t<= mpfstall;\n\t\tADR_MICOUNT:\taxil_read_data\t<= micount;\n\t\t// User counters\n\t\tADR_UCLOCKS:\taxil_read_data\t<= utask;\n\t\tADR_UOPSTALL:\taxil_read_data\t<= uopstall;\n\t\tADR_UPFSTALL:\taxil_read_data\t<= upfstall;\n\t\tADR_UICOUNT:\taxil_read_data\t<= uicount;\n\t\tdefault: axil_read_data <= 0;\n\t\tendcase\n\n\t\tif (OPT_LOWPOWER && !axil_read_ready)\n\t\t\taxil_read_data <= 0;\n\tend\n\t// }}}\n\n\t// apply_wstrb\n\t// {{{\n\t// Verilator coverage_off\n\tfunction automatic [C_AXI_DATA_WIDTH-1:0]\tapply_wstrb;",
            "input [C_AXI_DATA_WIDTH-1:0]\t\tprior_data;",
            "input [C_AXI_DATA_WIDTH-1:0]\t\tnew_data;",
            "input [C_AXI_DATA_WIDTH/8-1:0]\twstrb;\n\n\t\tinteger\tk;\n\t\tfor(k=0; k<C_AXI_DATA_WIDTH/8; k=k+1)\n\t\tbegin\n\t\t\tapply_wstrb[k*8 +: 8]\n\t\t\t\t= wstrb[k] ? new_data[k*8 +: 8] : prior_data[k*8 +: 8];\n\t\tend\n\tendfunction\n\t// Verilator coverage_on\n\t// }}}\n\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, S_AXI_AWPROT, S_AXI_ARPROT,\n\t\t\tS_AXI_ARADDR[ADDRLSB-1:0],\n\t\t\tS_AXI_AWADDR[ADDRLSB-1:0], wskd_strb,\n\t\t\tint_vector[30:6], int_vector[0],\n\t\t\tpic_stall, wdog_stall, apic_stall,\n\t\t\tpic_ack, wdog_ack, apic_ack,\n\t\t\ttmra_stall, tmrb_stall, tmrc_stall, jif_stall,\n\t\t\ttmra_ack, tmrb_ack, tmrc_ack, jif_ack };\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n`ifdef\tFORMAL\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Formal properties used in verfiying this core\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\t\tf_past_valid <= 1;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The AXI-lite control interface\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{",
            "localparam F_AXIL_LGDEPTH = 4;",
            "wire [F_AXIL_LGDEPTH-1:0]\tfaxil_rd_outstanding,\n\t\t\t\t\tfaxil_wr_outstanding,\n\t\t\t\t\tfaxil_awr_outstanding;\n\n\tfaxil_slave #(\n\t\t// {{{\n\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),\n\t\t.F_LGDEPTH(F_AXIL_LGDEPTH),\n\t\t.F_AXI_MAXWAIT(2),\n\t\t.F_AXI_MAXDELAY(2),\n\t\t.F_AXI_MAXRSTALL(3),\n\t\t.F_OPT_COVER_BURST(4)\n\t\t// }}}\n\t) faxil(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN),\n\t\t//\n\t\t.i_axi_awvalid(S_AXI_AWVALID),\n\t\t.i_axi_awready(S_AXI_AWREADY),\n\t\t.i_axi_awaddr( S_AXI_AWADDR),\n\t\t.i_axi_awprot( S_AXI_AWPROT),\n\t\t//\n\t\t.i_axi_wvalid(S_AXI_WVALID),\n\t\t.i_axi_wready(S_AXI_WREADY),\n\t\t.i_axi_wdata( S_AXI_WDATA),\n\t\t.i_axi_wstrb( S_AXI_WSTRB),\n\t\t//\n\t\t.i_axi_bvalid(S_AXI_BVALID),\n\t\t.i_axi_bready(S_AXI_BREADY),\n\t\t.i_axi_bresp( S_AXI_BRESP),\n\t\t//\n\t\t.i_axi_arvalid(S_AXI_ARVALID),\n\t\t.i_axi_arready(S_AXI_ARREADY),\n\t\t.i_axi_araddr( S_AXI_ARADDR),\n\t\t.i_axi_arprot( S_AXI_ARPROT),\n\t\t//\n\t\t.i_axi_rvalid(S_AXI_RVALID),\n\t\t.i_axi_rready(S_AXI_RREADY),\n\t\t.i_axi_rdata( S_AXI_RDATA),\n\t\t.i_axi_rresp( S_AXI_RRESP),\n\t\t//\n\t\t.f_axi_rd_outstanding(faxil_rd_outstanding),\n\t\t.f_axi_wr_outstanding(faxil_wr_outstanding),\n\t\t.f_axi_awr_outstanding(faxil_awr_outstanding)\n\t\t// }}}\n\t\t);\n\n\talways @(*)\n\tif (OPT_SKIDBUFFER)\n\tbegin\n\t\tassert(faxil_awr_outstanding== (S_AXI_BVALID ? 1:0)\n\t\t\t+(S_AXI_AWREADY ? 0:1));\n\t\tassert(faxil_wr_outstanding == (S_AXI_BVALID ? 1:0)\n\t\t\t+(S_AXI_WREADY ? 0:1));\n\n\t\tassert(faxil_rd_outstanding == (S_AXI_RVALID ? 1:0)\n\t\t\t+(S_AXI_ARREADY ? 0:1));\n\tend else begin\n\t\tassert(faxil_wr_outstanding == (S_AXI_BVALID ? 1:0));\n\t\tassert(faxil_awr_outstanding == faxil_wr_outstanding);\n\n\t\tassert(faxil_rd_outstanding == (S_AXI_RVALID ? 1:0));\n\tend\n\n\t//\n\t// Check that our low-power only",
            "logic works by verifying that anytime\n\t// S_AXI_RVALID is inactive, then the outgoing data is also zero.\n\t//\n\talways @(*)\n\tif (OPT_LOWPOWER && !S_AXI_RVALID)\n\t\tassert(S_AXI_RDATA == 0);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover checks\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{\n\n\t// While there are already cover properties in the formal property\n\t// set above, you'll probably still want to cover something\n\t// application specific here\n\n\t// }}}\n\t// }}}\n`endif",
            "endmodule "
        ]
    },
    {
        "file_name": "wbwatchdog.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/rtl/peripherals/wbwatchdog.v",
        "chunks": [
            "input (that is assumed to be constant)\n//\t2. The counter returns to i_timer and the interrupt is cleared on any\n//\t\treset.\n//\t3. Between resets, the counter counts down to zero.  Once (and if) it\n//\t\thits zero, it will remain at zero until reset.\n//\t4. Any time the counter is at zero, and until the reset that resets\n//\t\tthe counter, the",
            "output interrupt will be set.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module wbwatchdog #(",
            "parameter BW = 32\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Inputs (these were at one time wishbone controlled ...)",
            "input ",
            "wire [(BW-1):0]\ti_timeout,\n\t\t// Interrupt line",
            "output ",
            "reg o_int\n\t\t// }}}\n\t);",
            "reg [(BW-1):0]\tr_value;\n\n\t// r_value\n\t// {{{\n\tinitial\tr_value = {(BW){1'b1}};\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_value <= i_timeout[(BW-1):0];\n\telse if (!o_int)\n\t\tr_value <= r_value + {(BW){1'b1}}; // r_value - 1;\n\t// }}}\n\n\t// Set the interrupt on our last tick.\n\t// {{{\n\tinitial\to_int   = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_int <= 1'b0;\n\telse if (!o_int)\n\t\to_int <= (r_value == { {(BW-1){1'b0}}, 1'b1 });\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "reg f_past_valid;\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions about our",
            "input s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\talways @(*)\n\t\tassume(i_timeout > 1);\n\n\talways @(posedge i_clk)\n\tif (f_past_valid)\n\t\tassume(i_timeout == $past(i_timeout));\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assertions about our internal state and our",
            "output s\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_int))&&(!$past(i_reset)))\n\t\tassert(o_int);\n\n\talways @(*)\n\t\tassert(o_int == (r_value == 0));\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&(!$past(o_int)))\n\tbegin\n\t\tassert(r_value == $past(r_value)-1'b1);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\tbegin\n\t\tif (!f_past_valid)\n\t\tbegin\n\t\t\tassert(r_value == {(BW){1'b1}});\n\t\tend else // if ($past(i_reset))\n\t\t\tassert(r_value == $past(i_timeout));\n\t\tassert(!o_int);\n\tend\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "wbdown.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/wbdown.v",
        "chunks": [
            "module wbdown #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH = 28, // Byte address width",
            "parameter WIDE_DW = 64,",
            "parameter SMALL_DW = 32,",
            "parameter [0:0]\tOPT_LITTLE_ENDIAN = 1'b0,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,",
            "parameter [0:0]\tOPT_LOWLOGIC = 1'b0,",
            "localparam WIDE_AW  = ADDRESS_WIDTH-$clog2(WIDE_DW/8),",
            "localparam SMALL_AW = ADDRESS_WIDTH-$clog2(SMALL_DW/8)\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Incoming wide port\n\t\t// {{{",
            "input ",
            "wire i_wcyc, i_wstb, i_wwe,",
            "input ",
            "wire [WIDE_AW-1:0]\ti_waddr,",
            "input ",
            "wire [WIDE_DW-1:0]\ti_wdata,",
            "input ",
            "wire [WIDE_DW/8-1:0]\ti_wsel,",
            "output ",
            "wire o_wstall,",
            "output ",
            "wire o_wack,",
            "output ",
            "wire [WIDE_DW-1:0]\to_wdata,",
            "output ",
            "wire o_werr,\n\t\t// }}}\n\t\t// Outgoing, small bus size, port\n\t\t// {{{",
            "output ",
            "wire o_cyc, o_stb, o_we,",
            "output ",
            "wire [SMALL_AW-1:0]\to_addr,",
            "output ",
            "wire [SMALL_DW-1:0]\to_data,",
            "output ",
            "wire [SMALL_DW/8-1:0]\to_sel,",
            "input ",
            "wire i_stall,",
            "input ",
            "wire i_ack,",
            "input ",
            "wire [SMALL_DW-1:0]\ti_data,",
            "input ",
            "wire i_err\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Verilator lint_off UNUSED",
            "localparam WBLSB = $clog2(WIDE_DW/SMALL_DW);\n\t// Verilator lint_on  UNUSED\n\tgenerate if (WIDE_DW == SMALL_DW)\n\tbegin : NO_ADJUSTMENT\n\t\t// {{{\n\t\tassign\to_cyc  = i_wcyc;\n\t\tassign\to_stb  = i_wstb;\n\t\tassign\to_we   = i_wwe;\n\t\tassign\to_addr = i_waddr;\n\t\tassign\to_data = i_wdata;\n\t\tassign\to_sel  = i_wsel;\n\n\t\tassign\to_wstall = i_stall;\n\t\tassign\to_wack   = i_ack;\n\t\tassign\to_wdata  = i_data;\n\t\tassign\to_werr   = i_err;\n\n\t\t// Keep Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused;\n\t\tassign\tunused = &{ 1'b0, i_clk, i_reset };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\t\t// }}}\n\tend else if (OPT_LOWLOGIC)\n\tbegin : CHEAP_DOWNSIZER\n\t\t// {{{\n\t\t// Local declarations\n\t\t// {{{",
            "localparam LGFIFO = 5;",
            "reg r_cyc, r_stb, r_we, r_ack, r_err;",
            "reg [SMALL_AW-1:0]\tr_addr;",
            "reg [WIDE_DW-1:0]\ts_data, r_data;",
            "reg [WIDE_DW/8-1:0]\ts_sel;",
            "reg [WBLSB:0]\ts_count;",
            "wire fifo_full, ign_fifo_empty, fifo_ack;",
            "wire [LGFIFO:0]\tign_fifo_fill;\n`ifdef\tFORMAL",
            "wire [LGFIFO:0]\tf_first_addr, f_second_addr;",
            "wire f_first_data, f_second_data;",
            "wire f_first_in_fifo, f_second_in_fifo;",
            "wire [LGFIFO:0]\tf_distance_to_first,\n\t\t\t\t\tf_distance_to_second;\n`endif\n\t\t// }}}\n\n\t\t// r_cyc\n\t\t// {{{\n\t\tinitial\tr_cyc = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wcyc ||(o_cyc && i_err) || o_werr)\n\t\t\tr_cyc <= 1'b0;\n\t\telse if (i_wcyc && i_wstb)\n\t\t\tr_cyc <= 1'b1;\n\t\t// }}}\n\n\t\tinitial\tr_stb   = 1'b0;\n\t\tinitial\tr_we    = 1'b0;\n\t\tinitial\tr_addr  = 0;\n\t\tinitial\ts_data  = 0;\n\t\tinitial\ts_sel   = 0;\n\t\tinitial\ts_count = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wcyc || o_werr || (o_cyc && i_err))\n\t\tbegin\n\t\t\t// {{{\n\t\t\tr_stb   <= 1'b0;\n\t\t\tr_we    <= 1'b0;\n\t\t\tr_addr  <= 0;\n\t\t\ts_data  <= 0;\n\t\t\ts_sel   <= 0;\n\t\t\ts_count <= 0;\n\t\t\t// }}}\n\t\tend else if (i_wstb && !o_wstall) // New request\n\t\tbegin\n\t\t\t// {{{\n\t\t\tr_stb  <= 1'b1;\n\t\t\tr_we   <= i_wwe;\n\t\t\tr_addr <= { i_waddr,\n\t\t\t\t\t{($clog2(WIDE_DW/SMALL_DW)){1'b0}} };\n\t\t\ts_data <= i_wdata;\n\t\t\ts_sel  <= i_wsel;\n\t\t\t// Verilator lint_off WIDTH\n\t\t\ts_count <= (WIDE_DW/SMALL_DW);\n\t\t\t// Verilator lint_on  WIDTH\n\t\t\t// }}}\n\t\tend else if (o_stb && !i_stall)\n\t\tbegin\n\t\t\t// {{{\n\t\t\ts_count <=  s_count - 1;\n\t\t\tr_stb   <= (s_count > 1);\n\t\t\tr_addr[$clog2(WIDE_DW/SMALL_DW)-1:0]\n\t\t\t\t<= r_addr[$clog2(WIDE_DW/SMALL_DW)-1:0] + 1;\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\t// Verilator coverage_off\n\t\t\t\ts_data <= s_data >> SMALL_DW;\n\t\t\t\ts_sel  <= s_sel >> (SMALL_DW/8);\n\t\t\t\t// Verilator coverage_on\n\t\t\tend else begin\n\t\t\t\ts_data <= s_data << SMALL_DW;\n\t\t\t\ts_sel  <= s_sel << (SMALL_DW/8);\n\t\t\tend\n\t\t\t// }}}\n\t\tend\n\n\t\tassign\to_cyc = r_cyc;\n\t\tassign\to_stb = r_stb && !fifo_full;\n\t\tassign\to_we  = r_we;\n\t\tassign\to_addr= r_addr;\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin : OPT_LILEND_DATA\n\t\t\t// Verilator coverage_off\n\t\t\tassign\to_data = s_data[SMALL_DW-1:0];\n\t\t\tassign\to_sel  = s_sel[SMALL_DW/8-1:0];\n\t\t\t// Verilator coverage_on\n\t\tend else begin : OPT_BIGEND_DATA\n\t\t\tassign\to_data =s_data[WIDE_DW-1:WIDE_DW-SMALL_DW];\n\t\t\tassign\to_sel  =s_sel[WIDE_DW/8-1:(WIDE_DW-SMALL_DW)/8];\n\t\tend\n\n\t\tsfifo #(\n\t\t\t.BW(1), .LGFLEN(LGFIFO),\n\t\t\t.OPT_WRITE_ON_FULL(1'b1), .OPT_READ_ON_EMPTY(1'b1)\n\t\t) u_fifo (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset || !i_wcyc),\n\t\t\t.i_wr(o_stb && !i_stall),\n\t\t\t\t.i_data({ (s_count == 1) ? 1'b1 : 1'b0 }),\n\t\t\t\t.o_full(fifo_full), .o_fill(ign_fifo_fill),\n\t\t\t.i_rd(i_ack), .o_data(fifo_ack),\n\t\t\t\t.o_empty(ign_fifo_empty)\n`ifdef\tFORMAL\n\t\t\t, .f_first_addr(f_first_addr),\n\t\t\t.f_second_addr(f_second_addr),\n\t\t\t.f_first_data(f_first_data),\n\t\t\t.f_second_data(f_second_data),\n\t\t\t.f_first_in_fifo(f_first_in_fifo),\n\t\t\t.f_second_in_fifo(f_second_in_fifo),\n\t\t\t.f_distance_to_first(f_distance_to_first),\n\t\t\t.f_distance_to_second(f_distance_to_second)\n`endif\n\t\t\t// }}}\n\t\t);\n\n\t\t// r_data\n\t\t// {{{\n\t\tinitial\tr_data = 0;\n\t\talways @(posedge i_clk)\n\t\tif (OPT_LOWPOWER && (!i_wcyc || !o_cyc || i_err))\n\t\t\tr_data <= 0;\n\t\telse if (i_ack)\n\t\tbegin\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\t\t// Verilator coverage_off\n\t\t\t\tr_data<= { i_data, r_data[WIDE_DW-1:SMALL_DW] };\n\t\t\t\t// Verilator coverage_on\n\t\t\telse\n\t\t\t\tr_data<={r_data[WIDE_DW-SMALL_DW-1:0], i_data };\n\t\tend\n\t\t// }}}\n\n\t\t// r_ack\n\t\t// {{{\n\t\tinitial\tr_ack = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wcyc || !o_cyc)\n\t\t\tr_ack <= 1'b0;\n\t\telse\n\t\t\tr_ack <= i_ack && fifo_ack;\n\t\t// }}}\n\n\t\t// r_err\n\t\t// {{{\n\t\tinitial\tr_err = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wcyc || !o_cyc)\n\t\t\tr_err <= 1'b0;\n\t\telse\n\t\t\tr_err <= i_err;\n\t\t// }}}\n\n\t\tassign\to_wdata = r_data;\n\t\tassign\to_wack  = r_ack;\n\t\tassign\to_werr  = r_err;\n\t\tassign\to_wstall = (r_stb && (fifo_full || i_stall))\n\t\t\t\t\t|| (s_count > 1);\n\n\t\t// Keep Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused;\n\t\tassign\tunused = &{ 1'b0, ign_fifo_fill, ign_fifo_empty };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t////////////////////////////////////////////////////////////////////////\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Formal properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t////////////////////////////////////////////////////////////////////////\n\t////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "parameter F_LGDEPTH = LGFIFO+1;",
            "reg f_past_valid;",
            "wire [F_LGDEPTH-1:0]\tfslv_nreqs, fslv_nacks,fslv_outstanding;",
            "wire [F_LGDEPTH-1:0]\tfmst_nreqs, fmst_nacks,fmst_outstanding;",
            "wire f_first_ack, f_second_ack;",
            "reg [LGFIFO:0]\tf_acks_in_fifo;",
            "reg [WBLSB-1:0]\tf_first_subaddr, f_second_subaddr,\n\t\t\t\t\tf_this_subaddr;",
            "reg [WIDE_DW/8-1:0]\tf_mask;",
            "reg f_subsequent;\n\n\t\tinitial\tf_past_valid = 0;\n\t\talways @(posedge i_clk)\n\t\t\tf_past_valid <= 1;\n\n\t\talways @(*)\n\t\tif (!f_past_valid)\n\t\t\tassume(i_reset);\n\n\t\tfwb_slave #(\n\t\t\t.AW(WIDE_AW), .DW(WIDE_DW),\n\t\t) fslv (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t//\n\t\t\t.i_wb_cyc(i_wcyc), .i_wb_stb(i_wstb), .i_wb_we(i_wwe),\n\t\t\t.i_wb_addr(i_waddr), .i_wb_data(i_wdata),\n\t\t\t\t.i_wb_sel(i_wsel),\n\t\t\t.i_wb_stall(o_wstall), .i_wb_ack(o_wack),\n\t\t\t\t.i_wb_idata(o_wdata), .i_wb_err(o_werr),\n\t\t\t//\n\t\t\t.f_nreqs(fslv_nreqs), .f_nacks(fslv_nacks),\n\t\t\t.f_outstanding(fslv_outstanding)\n\t\t\t// }}}\n\t\t);\n\n\t\tfwb_master #(\n\t\t\t.AW(SMALL_AW), .DW(SMALL_DW),\n\t\t) fmst (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t//\n\t\t\t.i_wb_cyc(o_cyc), .i_wb_stb(o_stb), .i_wb_we(o_we),\n\t\t\t.i_wb_addr(o_addr), .i_wb_data(o_data),\n\t\t\t\t.i_wb_sel(o_sel),\n\t\t\t.i_wb_stall(i_stall), .i_wb_ack(i_ack),\n\t\t\t\t.i_wb_idata(i_data), .i_wb_err(i_err),\n\t\t\t//\n\t\t\t.f_nreqs(fmst_nreqs), .f_nacks(fmst_nacks),\n\t\t\t.f_outstanding(fmst_outstanding)\n\t\t\t// }}}\n\t\t);\n\n\t\talways @(*)\n\t\tif (r_stb)\n\t\tbegin\n\t\t\tassert(s_count > 0);\n\t\tend else begin\n\t\t\tassert(s_count == 0);\n\t\tend\n\n\t\talways @(*)\n\t\tif (!i_reset && o_cyc && i_wcyc)\n\t\t\tassert(ign_fifo_fill == fmst_outstanding);\n\n\t\talways @(*)\n\t\tif (!i_reset && !o_cyc && i_wcyc && !o_werr)\n\t\t\tassert(ign_fifo_fill == 0);\n\n\t\talways @(*)\n\t\tif (!o_cyc)\n\t\t\tassert(!r_stb);\n\n\t\talways @(*)\n\t\tif ((r_stb || fslv_outstanding > 0) && i_wcyc && o_cyc)\n\t\t\tassert(o_we == i_wwe);\n\n\t\talways @(*)\n\t\tif (i_wcyc && fslv_outstanding > 0 && !o_werr)\n\t\t\tassert(o_cyc);\n\n\t\tinitial\tf_acks_in_fifo = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wcyc)\n\t\t\tf_acks_in_fifo <= 0;\n\t\telse case({ o_stb && !i_stall && (s_count == 1),\n\t\t\t\t(i_ack && fifo_ack) })\n\t\t2'b01: f_acks_in_fifo <= f_acks_in_fifo - 1;\n\t\t2'b10: f_acks_in_fifo <= f_acks_in_fifo + 1;\n\t\tendcase\n\n\t\talways @(*)\n\t\tif (!i_reset && i_wcyc && o_cyc)\n\t\tbegin\n\t\t\tassert(f_acks_in_fifo + (s_count > 0 ? 1:0)\n\t\t\t\t+ (o_wack ? 1:0) == fslv_outstanding);\n\n\t\t\tif (s_count == 0 && fslv_outstanding > (o_wack ? 1:0))\n\t\t\t\tassert(f_acks_in_fifo > 0);\n\t\tend\n\n\t\tassign\tf_first_ack  = f_first_data;\n\t\tassign\tf_second_ack = f_second_data;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\t// f_first_subaddr  = f_first_data[WBLSB-1:0];\n\t\t\t// f_second_subaddr = f_second_data[WBLSB-1:0];\n\n\t\t\tf_first_subaddr = (r_stb ? o_addr[WBLSB-1:0] : {(WBLSB){1'b0}})\n\t\t\t\t\t- ign_fifo_fill[WBLSB-1:0]\n\t\t\t\t\t+ f_distance_to_first[WBLSB-1:0];\n\n\t\t\tf_second_subaddr = (r_stb ? o_addr[WBLSB-1:0] : {(WBLSB){1'b0}})\n\t\t\t\t\t- ign_fifo_fill[WBLSB-1:0]\n\t\t\t\t\t+ f_distance_to_second[WBLSB-1:0];\n\n\t\t\tf_this_subaddr = (r_stb ? o_addr[WBLSB-1:0] : {(WBLSB){1'b0}})\n\t\t\t\t\t- ign_fifo_fill[WBLSB-1:0];\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tif (!i_reset && o_cyc && i_wcyc && f_first_in_fifo)\n\t\t\tbegin\n\t\t\t\tassert(f_first_ack == (&f_first_subaddr[WBLSB-1:0]));\n\t\t\tend\n\t\t\tif (!i_reset && o_cyc && i_wcyc && f_second_in_fifo)\n\t\t\tbegin\n\t\t\t\tassert(f_second_ack == (&f_second_subaddr[WBLSB-1:0]));\n\t\t\tend\n\t\t\tassert(f_acks_in_fifo <= ign_fifo_fill);\n\t\t\tassert(!ign_fifo_empty || f_acks_in_fifo == 0);\n\t\t\tassert(f_acks_in_fifo >=\n\t\t\t\t((f_first_in_fifo && f_first_ack) ? 1:0)\n\t\t\t\t+ ((f_second_in_fifo && f_second_ack) ? 1:0));\n\t\t\tassert(ign_fifo_fill - f_acks_in_fifo >=\n\t\t\t\t((f_first_in_fifo && !f_first_ack) ? 1:0)\n\t\t\t\t+ ((f_second_in_fifo && !f_second_ack) ? 1:0));\n\n\t\t\tif (o_cyc && f_first_in_fifo && f_distance_to_first == ign_fifo_fill - 1)\n\t\t\t\tassert(f_first_ack || s_count > 0);\n\t\t\tif (o_cyc && f_second_in_fifo && f_distance_to_second == ign_fifo_fill - 1)\n\t\t\t\tassert(f_second_ack || s_count > 0);\n\t\t\tif (!i_reset && i_wcyc && o_cyc\n\t\t\t\t\t&& ign_fifo_fill > 0 && s_count == 0)\n\t\t\t\tassert(f_acks_in_fifo > 0);\n\n\t\t\tif (o_cyc&& i_wcyc  && f_first_in_fifo && s_count == 0 && !o_werr\n\t\t\t\t&& f_distance_to_first + 1 < ign_fifo_fill)\n\t\t\t\tassert(f_acks_in_fifo > (f_first_ack ? 1:0));\n\n\t\t\tif (o_cyc && i_wcyc && f_second_in_fifo && s_count == 0 && !o_werr\n\t\t\t\t\t&& f_distance_to_second + 1 < ign_fifo_fill)\n\t\t\t\tassert(f_acks_in_fifo >\n\t\t\t\t\t((f_first_in_fifo && f_first_ack) ? 1:0)\n\t\t\t\t\t+ (f_second_ack ? 1:0));\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tif (f_second_in_fifo)\n\t\t\t\tf_subsequent = (f_distance_to_second + 1 < ign_fifo_fill);\n\t\t\telse if (f_first_in_fifo)\n\t\t\t\tf_subsequent = (f_distance_to_first + 1 < ign_fifo_fill);\n\t\t\telse\n\t\t\t\tf_subsequent = (f_acks_in_fifo > 0 && s_count == 0);\n\t\tend\n\n\t\talways @(*)\n\t\tif ((!f_first_in_fifo || f_distance_to_first > 0)\n\t\t\t&&(!f_second_in_fifo || f_distance_to_second > 0)\n\t\t\t&& !ign_fifo_empty)\n\t\tbegin\n\t\t\tassume(!fifo_ack || (f_acks_in_fifo >\n\t\t\t\t((f_subsequent) ? 1:0)\n\t\t\t\t+ ((f_first_in_fifo && f_first_ack) ? 1:0)\n\t\t\t\t+ ((f_second_in_fifo && f_second_ack) ? 1:0)));\n\t\t\tassume(fifo_ack || (ign_fifo_fill - f_acks_in_fifo >\n\t\t\t\t((f_first_in_fifo && !f_first_ack) ? 1:0)\n\t\t\t\t+ ((f_second_in_fifo && !f_second_ack) ? 1:0)));\n\t\t\tif (f_acks_in_fifo == 1 && s_count == 0 && ign_fifo_fill > 1)\n\t\t\t\tassume(!fifo_ack);\n\n\t\t\tassume(fifo_ack == (&f_this_subaddr));\n\t\tend\n\n\t\talways @(*)\n\t\tif (!i_reset && o_cyc && i_wcyc)\n\t\tbegin\n\t\t\tif (f_first_in_fifo && f_second_in_fifo)\n\t\t\tbegin\n\t\t\t\tassert(f_second_subaddr > f_first_subaddr\n\t\t\t\t\t|| f_first_ack);\n\t\t\tend else if (f_first_in_fifo && !f_first_ack)\n\t\t\tbegin\n\t\t\t\tassert(s_count > 0\n\t\t\t\t\t&& o_addr[WBLSB-1:0] > f_first_subaddr);\n\t\t\tend\n\t\tend\n\n\t\talways @(*)\n\t\tif (!i_reset && o_cyc && i_wcyc)\n\t\tbegin\n\t\t\tassert(s_count <= (1<<WBLSB));\n\t\t\tif (r_stb)\n\t\t\t\tassert(s_count+o_addr[WBLSB-1:0] == (1<<WBLSB));\n\t\tend\n\n\t\talways @(*)\n\t\tif (!i_reset && o_cyc && i_wcyc\n\t\t\t&& f_first_in_fifo && f_second_in_fifo)\n\t\tbegin\n\t\t\tassert(f_second_subaddr > f_first_subaddr\n\t\t\t\t|| f_first_ack);\n\t\tend\n\n\t\talways @(*)\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\t// Verilator coverage_off\n\t\t\tf_mask = {(WIDE_DW/8){1'b1}} >> (o_addr[WBLSB-1:0] * SMALL_DW/8);\n\t\t\t// Verilator coverage_on\n\t\telse\n\t\t\tf_mask = {(WIDE_DW/8){1'b1}} << (o_addr[WBLSB-1:0] * SMALL_DW/8);\n\n\t\talways @(*)\n\t\tif (s_count > 0)\n\t\tbegin\n\t\t\tassert((s_sel & (~f_mask)) == 0);\n\t\tend\n`endif\n\t// }}}\n\t\t// }}}\n\tend else begin : DOWNSIZE\n\t\t// {{{\n\t\t// Local declarations\n\t\t// {{{",
            "localparam LGFIFO = 5;",
            "reg r_cyc, r_stb, r_we, r_ack, r_err;",
            "reg [SMALL_AW-1:0]\tr_addr;",
            "reg s_null;",
            "reg [WIDE_DW-1:0]\ts_data, r_data, nxt_mask, nxt_data;",
            "wire [WIDE_DW/8-1:0]\ti_nxtsel, s_nxtsel;",
            "reg [WIDE_DW/8-1:0]\ts_sel;",
            "reg [WBLSB:0]\ts_count;",
            "wire [WBLSB-1:0]\tfifo_addr, i_subaddr,s_subaddr;",
            "wire fifo_full, fifo_empty, fifo_ack;",
            "wire [LGFIFO:0]\tign_fifo_fill;\n`ifdef\tFORMAL",
            "wire [LGFIFO:0]\tf_first_addr, f_second_addr;",
            "wire [WBLSB:0]\tf_first_data, f_second_data;",
            "wire f_first_in_fifo, f_second_in_fifo;",
            "wire [LGFIFO:0]\tf_distance_to_first,\n\t\t\t\t\tf_distance_to_second;\n`endif\n\t\t// }}}\n\n\t\t// r_cyc\n\t\t// {{{\n\t\tinitial\tr_cyc = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wcyc ||(o_cyc && i_err) || o_werr)\n\t\t\tr_cyc <= 1'b0;\n\t\telse if (i_wcyc && i_wstb)\n\t\t\tr_cyc <= 1'b1;\n\t\t// }}}\n\n\t\t// i_subaddr, s_subaddr, i_nxtsel, s_nxtsel\n\t\t// {{{\n\t\tassign\ti_subaddr = subaddr_fn(i_wsel);\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin : OPT_LILEND_SHIFT\n\t\t\tassign\ti_nxtsel = i_wsel >> (i_subaddr * SMALL_DW/8);\n\t\t\tassign\ts_subaddr= 1 + subaddr_fn({ {(SMALL_DW/8){1'b0}}, s_sel[WIDE_DW/8-1:SMALL_DW/8] });\n\t\t\tassign\ts_nxtsel = s_sel >> (s_subaddr * SMALL_DW/8);\n\t\tend else begin : OPT_BIGEND_SHIFT\n\t\t\tassign\ti_nxtsel = i_wsel << (i_subaddr * SMALL_DW/8);\n\t\t\tassign\ts_subaddr= 1 + subaddr_fn( { s_sel[WIDE_DW/8-SMALL_DW/8-1:0], {(SMALL_DW/8){1'b0}} } );\n\t\t\tassign\ts_nxtsel = s_sel << (s_subaddr * SMALL_DW/8);\n\t\tend\n\t\t// }}}\n\n\t\tinitial\tr_stb   = 1'b0;\n\t\tinitial\tr_we    = 1'b0;\n\t\tinitial\tr_addr  = 0;\n\t\tinitial\ts_data  = 0;\n\t\tinitial\ts_sel   = 0;\n\t\tinitial\ts_count = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wcyc || o_werr || (o_cyc && i_err))\n\t\tbegin\n\t\t\t// {{{\n\t\t\tr_stb   <= 1'b0;\n\t\t\tr_we    <= 1'b0;\n\t\t\tr_addr  <= 0;\n\t\t\ts_data  <= 0;\n\t\t\ts_sel   <= 0;\n\t\t\ts_count <= 0;\n\t\t\ts_null  <= 0;\n\t\t\t// }}}\n\t\tend else if (i_wstb && !o_wstall) // New request\n\t\tbegin\n\t\t\t// {{{\n\t\t\tr_stb  <= (i_wsel != 0);\n\t\t\tr_we   <= i_wwe;\n\t\t\tr_addr <= { i_waddr, i_subaddr };\n\n\t\t\ts_null <= (i_wsel == 0);\n\t\t\t// Verilator lint_off WIDTH\n\t\t\ts_count <= (WIDE_DW/SMALL_DW) - i_subaddr;\n\t\t\t// Verilator lint_on  WIDTH\n\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\t// Verilator coverage_off\n\t\t\t\ts_data <= i_wdata >> (i_subaddr * SMALL_DW);\n\t\t\t\ts_sel  <= i_nxtsel;\n\t\t\t\tif (i_nxtsel[WIDE_DW/8-1:SMALL_DW/8] == 0)\n\t\t\t\t\ts_count <= 1;\n\t\t\t\t// Verilator coverage_on\n\t\t\tend else begin\n\t\t\t\ts_data <= i_wdata << (i_subaddr * SMALL_DW);\n\t\t\t\ts_sel  <= i_nxtsel;\n\t\t\t\tif (i_nxtsel[WIDE_DW/8-SMALL_DW/8-1:0] == 0)\n\t\t\t\t\ts_count <= 1;\n\t\t\tend\n\n\t\t\tif (i_wsel == 0)\n\t\t\t\ts_count <= 0;\n\t\t\t// }}}\n\t\tend else if (o_stb && !i_stall)\n\t\tbegin\n\t\t\t// {{{\n\t\t\ts_count <=  s_count - s_subaddr;\n\t\t\tr_stb   <= (s_count > 1);\n\t\t\tr_addr[WBLSB-1:0] <= r_addr[WBLSB-1:0] + s_subaddr;\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\t// Verilator coverage_off\n\t\t\t\ts_data <= s_data >> (s_subaddr *SMALL_DW);\n\t\t\t\ts_sel  <= s_nxtsel;\n\t\t\t\tif (s_count > 1 && s_nxtsel[WIDE_DW/8-1:SMALL_DW/8] == 0)\n\t\t\t\t\ts_count <= 1;\n\t\t\t\t// Verilator coverage_on\n\t\t\tend else begin\n\t\t\t\ts_data <= s_data << (s_subaddr *SMALL_DW);\n\t\t\t\ts_sel  <= s_nxtsel;\n\t\t\t\tif (s_count > 1 && s_nxtsel[WIDE_DW/8-SMALL_DW/8-1:0] == 0)\n\t\t\t\t\ts_count <= 1;\n\t\t\tend\n\t\t\t// }}}\n\t\tend else if (fifo_empty)\n\t\t\ts_null <= 0;\n\n\t\tassign\to_cyc = r_cyc;\n\t\tassign\to_stb = r_stb && !fifo_full;\n\t\tassign\to_we  = r_we;\n\t\tassign\to_addr= r_addr;\n\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\tbegin : OPT_LILODATA\n\t\t\tassign\to_data = s_data[SMALL_DW-1:0];\n\t\t\tassign\to_sel  = s_sel[SMALL_DW/8-1:0];\n\t\tend else begin : OPT_BIGODATA\n\t\t\tassign\to_data =s_data[WIDE_DW-1:WIDE_DW-SMALL_DW];\n\t\t\tassign\to_sel  =s_sel[WIDE_DW/8-1:(WIDE_DW-SMALL_DW)/8];\n\t\tend\n\n\t\tsfifo #(\n\t\t\t.BW(1+WBLSB), .LGFLEN(LGFIFO),\n\t\t\t.OPT_WRITE_ON_FULL(1'b1), .OPT_READ_ON_EMPTY(1'b1)\n\t\t) u_fifo (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset || !i_wcyc),\n\t\t\t.i_wr(o_stb && !i_stall),\n\t\t\t\t.i_data({ {(s_count == 1) ? 1'b1 : 1'b0 },\n\t\t\t\t\to_addr[WBLSB-1:0] }),\n\t\t\t\t.o_full(fifo_full), .o_fill(ign_fifo_fill),\n\t\t\t.i_rd(i_ack),\n\t\t\t\t.o_data({ fifo_ack, fifo_addr }),\n\t\t\t\t.o_empty(fifo_empty)\n`ifdef\tFORMAL\n\t\t\t, .f_first_addr(f_first_addr),\n\t\t\t.f_second_addr(f_second_addr),\n\t\t\t.f_first_data(f_first_data),\n\t\t\t.f_second_data(f_second_data),\n\t\t\t.f_first_in_fifo(f_first_in_fifo),\n\t\t\t.f_second_in_fifo(f_second_in_fifo),\n\t\t\t.f_distance_to_first(f_distance_to_first),\n\t\t\t.f_distance_to_second(f_distance_to_second)\n`endif\n\t\t\t// }}}\n\t\t);\n\n\t\t// nxt_data, r_data\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tnxt_data = r_data;\n\t\t\tif (o_wack)\n\t\t\t\tnxt_data = 0;\n\t\t\tnxt_mask = {(WIDE_DW){1'b0}};\n\t\t\tif (i_ack)\n\t\t\tbegin\n\t\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\t\tbegin\n\t\t\t\t\t// Verilator coverage_off\n\t\t\t\t\tnxt_mask = { {(WIDE_DW-SMALL_DW){1'b0}}, {(SMALL_DW){1'b1}} };\n\t\t\t\t\tnxt_mask = nxt_mask << (fifo_addr * SMALL_DW);\n\t\t\t\t\tnxt_mask = ~nxt_mask;\n\t\t\t\t\tnxt_data = (nxt_data & nxt_mask)\n\t\t\t\t\t\t| ({ {(WIDE_DW-SMALL_DW){1'b0}}, i_data } << (fifo_addr * SMALL_DW));\n\t\t\t\t\t// Verilator coverage_on\n\t\t\t\tend else begin\n\t\t\t\t\tnxt_mask = { {(SMALL_DW){1'b1}}, {(WIDE_DW-SMALL_DW){1'b0}} };\n\t\t\t\t\tnxt_mask = nxt_mask >> (fifo_addr * SMALL_DW);\n\t\t\t\t\tnxt_mask = ~nxt_mask;\n\t\t\t\t\tnxt_data = (nxt_data & nxt_mask)\n\t\t\t\t\t\t| ({ i_data, {(WIDE_DW-SMALL_DW){1'b0}} } >> (fifo_addr * SMALL_DW));\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tinitial\tr_data = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wcyc || !o_cyc || i_err)\n\t\t\tr_data <= 0;\n\t\telse\n\t\t\tr_data <= nxt_data;\n\t\t// }}}\n\n\t\t// r_ack\n\t\t// {{{\n\t\tinitial\tr_ack = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wcyc || !o_cyc)\n\t\t\tr_ack <= 1'b0;\n\t\telse if (!fifo_empty)\n\t\t\tr_ack <= fifo_ack && i_ack;\n\t\telse\n\t\t\tr_ack <= s_null;\n\t\t// }}}\n\n\t\t// r_err\n\t\t// {{{\n\t\tinitial\tr_err = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wcyc || !o_cyc)\n\t\t\tr_err <= 0;\n\t\telse\n\t\t\tr_err <= i_err;\n\t\t// }}}\n\n\t\tassign\to_wdata = r_data;\n\t\tassign\to_wack  = r_ack;\n\t\tassign\to_werr  = r_err;\n\t\tassign\to_wstall= (r_stb && (fifo_full || i_stall))\n\t\t\t\t\t|| (s_null && !fifo_empty)\n\t\t\t\t\t|| (s_count > 1);\n\n\t\tfunction [WBLSB-1:0]\tsubaddr_fn(",
            "input [WIDE_DW/8-1:0] sel);\n\t\t\t// {{{\n\t\t\tinteger\tfnk, fm;\n\t\tbegin\n\t\t\tsubaddr_fn = 0;\n\t\t\tfor(fnk=0; fnk<WIDE_DW/SMALL_DW; fnk=fnk+1)\n\t\t\tbegin\n\t\t\t\tfm = WIDE_DW/SMALL_DW-1-fnk;\n\t\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\t\tbegin\n\t\t\t\t\t// Verilator coverage_off\n\t\t\t\t\tif (sel[fm*SMALL_DW/8 +: SMALL_DW/8] != 0)\n\t\t\t\t\t\tsubaddr_fn = fm[WBLSB-1:0];\n\t\t\t\t\t// Verilator coverage_on\n\t\t\t\tend else begin\n\t\t\t\t\tif (sel[fnk*SMALL_DW/8 +: SMALL_DW/8] != 0)\n\t\t\t\t\t\tsubaddr_fn = fm[WBLSB-1:0];\n\t\t\t\tend\n\t\t\tend\n\t\tend endfunction\n\t\t// }}}\n\n\t\t// Keep Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused;\n\t\tassign\tunused = &{ 1'b0, ign_fifo_fill, fifo_empty };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t////////////////////////////////////////////////////////////////////////\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Formal properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t////////////////////////////////////////////////////////////////////////\n\t////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "parameter F_LGDEPTH = LGFIFO+1;",
            "reg f_past_valid;",
            "wire [F_LGDEPTH-1:0]\tfslv_nreqs, fslv_nacks,fslv_outstanding;",
            "wire [F_LGDEPTH-1:0]\tfmst_nreqs, fmst_nacks,fmst_outstanding;",
            "wire f_first_ack, f_second_ack;",
            "reg [LGFIFO:0]\tf_acks_in_fifo;",
            "wire [WBLSB-1:0]\tf_first_subaddr, f_second_subaddr;",
            "reg [WIDE_DW/8-1:0]\tf_mask;",
            "reg f_subsequent;\n\n\n\t\tinitial\tf_past_valid = 0;\n\t\talways @(posedge i_clk)\n\t\t\tf_past_valid <= 1;\n\n\t\talways @(*)\n\t\tif (!f_past_valid)\n\t\t\tassume(i_reset);\n\n\t\tfwb_slave #(\n\t\t\t.AW(WIDE_AW), .DW(WIDE_DW),\n\t\t) fslv (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t//\n\t\t\t.i_wb_cyc(i_wcyc), .i_wb_stb(i_wstb), .i_wb_we(i_wwe),\n\t\t\t.i_wb_addr(i_waddr), .i_wb_data(i_wdata),\n\t\t\t\t.i_wb_sel(i_wsel),\n\t\t\t.i_wb_stall(o_wstall), .i_wb_ack(o_wack),\n\t\t\t\t.i_wb_idata(o_wdata), .i_wb_err(o_werr),\n\t\t\t//\n\t\t\t.f_nreqs(fslv_nreqs), .f_nacks(fslv_nacks),\n\t\t\t.f_outstanding(fslv_outstanding)\n\t\t\t// }}}\n\t\t);\n\n\t\tfwb_master #(\n\t\t\t.AW(SMALL_AW), .DW(SMALL_DW),\n\t\t) fmst (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t//\n\t\t\t.i_wb_cyc(o_cyc), .i_wb_stb(o_stb), .i_wb_we(o_we),\n\t\t\t.i_wb_addr(o_addr), .i_wb_data(o_data),\n\t\t\t\t.i_wb_sel(o_sel),\n\t\t\t.i_wb_stall(i_stall), .i_wb_ack(i_ack),\n\t\t\t\t.i_wb_idata(i_data), .i_wb_err(i_err),\n\t\t\t//\n\t\t\t.f_nreqs(fmst_nreqs), .f_nacks(fmst_nacks),\n\t\t\t.f_outstanding(fmst_outstanding)\n\t\t\t// }}}\n\t\t);\n\n\t\talways @(*)\n\t\tif (r_stb)\n\t\tbegin\n\t\t\tassert(s_count > 0);\n\t\t\tassert(o_sel  != 0);\n\t\tend else begin\n\t\t\tassert(s_sel   == 0);\n\t\t\tassert(s_count == 0);\n\t\tend\n\n\t\talways @(*)\n\t\t\tassert(!r_stb || !s_null);\n\n\t\talways @(*)\n\t\tif (r_stb)\n\t\tbegin\n\t\t\tassert(o_sel != 0);\n\n\t\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tbegin\n\t\t\t\tassert((s_count == 1) == (s_sel[WIDE_DW/8-1:SMALL_DW/8] == 0));\n\t\t\tend else begin\n\t\t\t\tassert((s_count == 1) == (s_sel[WIDE_DW/8-SMALL_DW/8-1:0] == 0));\n\t\t\tend\n\t\tend\n\n\t\talways @(*)\n\t\tif (!i_reset && o_cyc && i_wcyc)\n\t\t\tassert(ign_fifo_fill == fmst_outstanding);\n\n\t\talways @(*)\n\t\tif (!i_reset && !o_cyc && i_wcyc && !o_werr)\n\t\t\tassert(ign_fifo_fill == 0);\n\n\t\talways @(*)\n\t\tif (!o_cyc)\n\t\t\tassert(!r_stb);\n\n\t\talways @(*)\n\t\tif ((r_stb || fslv_outstanding > 0) && i_wcyc && o_cyc)\n\t\t\tassert(o_we == i_wwe);\n\n\t\talways @(*)\n\t\tif (i_wcyc && fslv_outstanding > 0 && !o_werr)\n\t\t\tassert(o_cyc);\n\n\t\talways @(*)\n\t\tif (i_wcyc && !o_wack && fmst_outstanding == 0 && s_count == 0)\n\t\t\tassert(r_data == 0);\n\n\t\tinitial\tf_acks_in_fifo = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_wcyc)\n\t\t\tf_acks_in_fifo <= 0;\n\t\telse case({ o_stb && !i_stall && (s_count == 1),\n\t\t\t\t(i_ack && fifo_ack) })\n\t\t2'b01: f_acks_in_fifo <= f_acks_in_fifo - 1;\n\t\t2'b10: f_acks_in_fifo <= f_acks_in_fifo + 1;\n\t\tendcase\n\n\t\talways @(*)\n\t\tif (!i_reset && i_wcyc && o_cyc)\n\t\tbegin\n\t\t\tassert(f_acks_in_fifo + (s_count > 0 ? 1:0)\n\t\t\t\t+ (s_null ? 1:0)\n\t\t\t\t+ (o_wack ? 1:0) == fslv_outstanding);\n\n\t\t\tif (s_count == 0 && fslv_outstanding > (s_null ? 1:0) + (o_wack ? 1:0))\n\t\t\t\tassert(f_acks_in_fifo > 0);\n\t\tend\n\n\t\tassign\tf_first_ack  = f_first_data[WBLSB];\n\t\tassign\tf_second_ack = f_second_data[WBLSB];\n\n\t\tassign\tf_first_subaddr  = f_first_data[WBLSB-1:0];\n\t\tassign\tf_second_subaddr = f_second_data[WBLSB-1:0];\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tassert(f_acks_in_fifo <= ign_fifo_fill);\n\t\t\tassert(!fifo_empty || f_acks_in_fifo == 0);\n\t\t\tassert(f_acks_in_fifo >=\n\t\t\t\t((f_first_in_fifo && f_first_ack) ? 1:0)\n\t\t\t\t+ ((f_second_in_fifo && f_second_ack) ? 1:0));\n\t\t\tassert(ign_fifo_fill - f_acks_in_fifo >=\n\t\t\t\t((f_first_in_fifo && !f_first_ack) ? 1:0)\n\t\t\t\t+ ((f_second_in_fifo && !f_second_ack) ? 1:0));\n\n\t\t\tif (o_cyc && f_first_in_fifo && f_distance_to_first == ign_fifo_fill - 1)\n\t\t\t\tassert(f_first_ack || s_count > 0);\n\t\t\tif (o_cyc && f_second_in_fifo && f_distance_to_second == ign_fifo_fill - 1)\n\t\t\t\tassert(f_second_ack || s_count > 0);\n\t\t\tif (!i_reset && i_wcyc && o_cyc\n\t\t\t\t\t&& ign_fifo_fill > 0 && s_count == 0)\n\t\t\t\tassert(f_acks_in_fifo > 0);\n\n\t\t\tif (o_cyc&& i_wcyc  && f_first_in_fifo && s_count == 0 && !o_werr\n\t\t\t\t&& f_distance_to_first + 1 < ign_fifo_fill)\n\t\t\t\tassert(f_acks_in_fifo > (f_first_ack ? 1:0));\n\n\t\t\tif (o_cyc && i_wcyc && f_second_in_fifo && s_count == 0 && !o_werr\n\t\t\t\t\t&& f_distance_to_second + 1 < ign_fifo_fill)\n\t\t\t\tassert(f_acks_in_fifo >\n\t\t\t\t\t((f_first_in_fifo && f_first_ack) ? 1:0)\n\t\t\t\t\t+ (f_second_ack ? 1:0));\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tif (f_second_in_fifo)\n\t\t\t\tf_subsequent = (f_distance_to_second + 1 < ign_fifo_fill);\n\t\t\telse if (f_first_in_fifo)\n\t\t\t\tf_subsequent = (f_distance_to_first + 1 < ign_fifo_fill);\n\t\t\telse\n\t\t\t\tf_subsequent = (f_acks_in_fifo > 0 && s_count == 0);\n\t\tend\n\n\t\talways @(*)\n\t\tif ((!f_first_in_fifo || f_distance_to_first > 0)\n\t\t\t&&(!f_second_in_fifo || f_distance_to_second > 0)\n\t\t\t&& !fifo_empty)\n\t\tbegin\n\t\t\tassume(!fifo_ack || (f_acks_in_fifo >\n\t\t\t\t((f_subsequent) ? 1:0)\n\t\t\t\t+ ((f_first_in_fifo && f_first_ack) ? 1:0)\n\t\t\t\t+ ((f_second_in_fifo && f_second_ack) ? 1:0)));\n\t\t\tassume(fifo_ack || (ign_fifo_fill - f_acks_in_fifo >\n\t\t\t\t((f_first_in_fifo && !f_first_ack) ? 1:0)\n\t\t\t\t+ ((f_second_in_fifo && !f_second_ack) ? 1:0)));\n\t\t\tif (f_acks_in_fifo == 1 && s_count == 0 && ign_fifo_fill > 1)\n\t\t\t\tassume(!fifo_ack);\n\t\tend\n\n\t\talways @(*)\n\t\tif (!i_reset && o_cyc && i_wcyc)\n\t\tbegin\n\t\t\tif (f_first_in_fifo && f_second_in_fifo)\n\t\t\tbegin\n\t\t\t\tassert(f_second_subaddr > f_first_subaddr\n\t\t\t\t\t|| f_first_ack);\n\t\t\tend else if (f_first_in_fifo && !f_first_ack)\n\t\t\tbegin\n\t\t\t\tassert(s_count > 0\n\t\t\t\t\t&& o_addr[WBLSB-1:0] > f_first_subaddr);\n\t\t\tend\n\t\tend\n\n\t\talways @(*)\n\t\tif (!i_reset && o_cyc && i_wcyc)\n\t\tbegin\n\t\t\tassert(s_count <= (1<<WBLSB));\n\t\t\tassert(s_count + o_addr[WBLSB-1:0] <= (1<<WBLSB));\n\t\t\tif (s_count > 1)\n\t\t\t\tassert(s_count + o_addr[WBLSB-1:0]==(1<<WBLSB));\n\t\tend\n\n\t\talways @(*)\n\t\tif (f_first_in_fifo && f_second_in_fifo)\n\t\tbegin\n\t\t\tassert(f_second_subaddr > f_first_subaddr\n\t\t\t\t|| f_first_ack);\n\t\tend\n\n\t\talways @(*)\n\t\tif (OPT_LITTLE_ENDIAN)\n\t\t\tf_mask = {(WIDE_DW/8){1'b1}} >> (o_addr[WBLSB-1:0] * SMALL_DW/8);\n\t\telse\n\t\t\tf_mask = {(WIDE_DW/8){1'b1}} << (o_addr[WBLSB-1:0] * SMALL_DW/8);\n\n\t\talways @(*)\n\t\tif (s_count > 0)\n\t\tbegin\n\t\t\tassert((s_sel & (~f_mask)) == 0);\n\t\tend\n`endif\n\t// }}}\n\t\t// }}}\n\tend endgenerate",
            "endmodule "
        ]
    },
    {
        "file_name": "addrdecode.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/addrdecode.v",
        "chunks": [
            "module addrdecode #(\n\t\t// {{{",
            "parameter NS=8,",
            "parameter AW = 32, DW=32+32/8+1+1,\n\t\t//\n\t\t// SLAVE_ADDR contains address assignments for each of the\n\t\t// various slaves we are adjudicating between.",
            "parameter [NS*AW-1:0]\tSLAVE_ADDR = {\n\t\t\t\t{ 3'b111,  {(AW-3){1'b0}} },\n\t\t\t\t{ 3'b110,  {(AW-3){1'b0}} },\n\t\t\t\t{ 3'b101,  {(AW-3){1'b0}} },\n\t\t\t\t{ 3'b100,  {(AW-3){1'b0}} },\n\t\t\t\t{ 3'b011,  {(AW-3){1'b0}} },\n\t\t\t\t{ 3'b010,  {(AW-3){1'b0}} },\n\t\t\t\t{ 4'b0010, {(AW-4){1'b0}} },\n\t\t\t\t{ 4'b0000, {(AW-4){1'b0}} }},\n\t\t//\n\t\t// SLAVE_MASK contains a mask of those address bits in\n\t\t// SLAVE_ADDR which are relevant.  It shall be true that if\n\t\t// !SLAVE_MASK[k] then !SLAVE_ADDR[k], for any bits of k",
            "parameter [NS*AW-1:0]\tSLAVE_MASK = (NS <= 1) ? 0\n\t\t\t: { {(NS-2){ 3'b111, {(AW-3){1'b0}} }},\n\t\t\t\t{(2){ 4'b1111, {(AW-4){1'b0}} }} },\n\t\t//\n\t\t// ACCESS_ALLOWED is a bit-wise mask indicating which slaves\n\t\t// may get access to the bus.  If ACCESS_ALLOWED[slave] is true,\n\t\t// then a master can connect to the slave via this method.  This\n\t\t//",
            "parameter is primarily here to support AXI (or other similar\n\t\t// buses) which may have separate accesses for both read and\n\t\t// write.  By using this, a read-only slave can be connected,\n\t\t// which would also naturally create an error on any attempt to\n\t\t// write to it.",
            "parameter [NS-1:0]\tACCESS_ALLOWED = -1,\n\t\t//\n\t\t// If OPT_REGISTERED is set, address decoding will take an extra\n\t\t// clock, and will",
            "reg ister the results of the decoding\n\t\t// operation.",
            "parameter [0:0]\tOPT_REGISTERED = 0,\n\t\t//\n\t\t// If OPT_LOWPOWER is set, then whenever the",
            "output is not\n\t\t// valid, any respective data linse will also be forced to zero\n\t\t// in an effort to minimize power.",
            "parameter [0:0]\tOPT_LOWPOWER = 0\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t//",
            "input ",
            "wire i_valid,",
            "output ",
            "reg o_stall,",
            "input ",
            "wire [AW-1:0]\ti_addr,",
            "input ",
            "wire [DW-1:0]\ti_data,\n\t\t//",
            "output ",
            "reg o_valid,",
            "input ",
            "wire i_stall,",
            "output ",
            "reg [NS:0]\t\to_decode,",
            "output ",
            "reg [AW-1:0]\to_addr,",
            "output ",
            "reg [DW-1:0]\to_data\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{\n\t//\n\t// OPT_NONESEL controls whether or not the address lines are fully\n\t// proscribed, or whether or not a \"no-slave identified\" slave should\n\t// be created.  To avoid a \"no-slave selected\"",
            "output , slave zero must\n\t// have no mask bits set (and therefore no address bits set), and it\n\t// must also allow access.",
            "localparam [0:0] OPT_NONESEL = (!ACCESS_ALLOWED[0])\n\t\t\t\t\t|| (SLAVE_MASK[AW-1:0] != 0);\n\t//",
            "wire [NS:0]\t\trequest;",
            "reg [NS-1:0]\tprerequest;\n\tinteger\t\t\tiM;\n\t// }}}\n\n\t// prerequest\n\t// {{{\n\talways @(*)\n\tfor(iM=0; iM<NS; iM=iM+1)\n\t\tprerequest[iM] = (((i_addr ^ SLAVE_ADDR[iM*AW +: AW])\n\t\t\t\t&SLAVE_MASK[iM*AW +: AW])==0)\n\t\t\t&&(ACCESS_ALLOWED[iM]);\n\t// }}}\n\n\t// request\n\t//  {{{\n\tgenerate if (OPT_NONESEL)\n\tbegin : NO_DEFAULT_REQUEST\n\t\t// {{{",
            "reg [NS-1:0]\tr_request;\n\n\t\t// Need to create a slave to describe when nothing is selected\n\t\t//\n\t\talways @(*)\n\t\tbegin\n\t\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\t\t\tr_request[iM] = i_valid && prerequest[iM];\n\t\t\tif (!OPT_NONESEL && (NS > 1 && |prerequest[NS-1:1]))\n\t\t\t\tr_request[0] = 1'b0;\n\t\tend\n\n\t\tassign\trequest[NS-1:0] = r_request;\n\t\t// }}}\n\tend else if (NS == 1)\n\tbegin : SINGLE_SLAVE\n\t\t// {{{\n\t\tassign request[0] = i_valid;\n\t\t// }}}\n\tend else begin : LCL_NOSEL\n\t\t// {{{",
            "reg [NS-1:0]\tr_request;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\t\t\tr_request[iM] = i_valid && prerequest[iM];\n\t\t\tif (!OPT_NONESEL && (NS > 1 && |prerequest[NS-1:1]))\n\t\t\t\tr_request[0] = 1'b0;\n\t\tend\n\n\t\tassign\trequest[NS-1:0] = r_request;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// request[NS]\n\t// {{{\n\tgenerate if (OPT_NONESEL)\n\tbegin : OPT_NONESEL_REQUEST",
            "reg r_request_NS, r_none_sel;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\t// Let's assume nothing's been selected, and then check\n\t\t\t// to prove ourselves wrong.\n\t\t\t//\n\t\t\t// Note that none_sel will be considered an error\n\t\t\t// condition in the follow-on processing.  Therefore\n\t\t\t// it's important to clear it if no request is pending.\n\t\t\tr_none_sel = i_valid && (prerequest == 0);\n\t\t\t//\n\t\t\t// request[NS] indicates a request for a non-existent\n\t\t\t// slave.  A request that should (eventually) return a\n\t\t\t// bus error\n\t\t\t//\n\t\t\tr_request_NS = r_none_sel;\n\t\tend\n\n\t\tassign request[NS] = r_request_NS;\n\tend else begin : NO_NONESEL_REQUEST\n\t\tassign request[NS] = 1'b0;\n\tend endgenerate\n\t// }}}\n\n\t// o_valid, o_addr, o_data, o_decode, o_stall\n\t// {{{\n\tgenerate if (OPT_REGISTERED)\n\tbegin : GEN_REGISTERED_OUTS\n\n\t\t// o_valid\n\t\t// {{{\n\t\tinitial\to_valid = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\to_valid <= 0;\n\t\telse if (!o_stall)\n\t\t\to_valid <= i_valid;\n\t\t// }}}\n\n\t\t// o_addr, o_data\n\t\t// {{{\n\t\tinitial\to_addr   = 0;\n\t\tinitial\to_data   = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset && OPT_LOWPOWER)\n\t\tbegin\n\t\t\to_addr   <= 0;\n\t\t\to_data   <= 0;\n\t\tend else if ((!o_valid || !i_stall)\n\t\t\t\t && (i_valid || !OPT_LOWPOWER))\n\t\tbegin\n\t\t\to_addr   <= i_addr;\n\t\t\to_data   <= i_data;\n\t\tend else if (OPT_LOWPOWER && !i_stall)\n\t\tbegin\n\t\t\to_addr   <= 0;\n\t\t\to_data   <= 0;\n\t\tend\n\t\t// }}}\n\n\t\t// o_decode\n\t\t// {{{\n\t\tinitial\to_decode = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\to_decode <= 0;\n\t\telse if ((!o_valid || !i_stall)\n\t\t\t\t && (i_valid || !OPT_LOWPOWER))\n\t\t\to_decode <= request;\n\t\telse if (OPT_LOWPOWER && !i_stall)\n\t\t\to_decode <= 0;\n\t\t// }}}\n\n\t\t// o_stall\n\t\t// {{{\n\t\talways @(*)\n\t\t\to_stall = (o_valid && i_stall);\n\t\t// }}}\n\tend else begin : COMB_OUTPUTS\n\n\t\talways @(*)\n\t\tbegin\n\t\t\to_valid = i_valid;\n\t\t\to_stall = i_stall;\n\t\t\to_addr  = i_addr;\n\t\t\to_data  = i_data;\n\n\t\t\to_decode = request;\n\t\tend\n\n\t\t// Make Verilator happy\n\t\t// {{{\n\t\t// verilator coverage_off\n\t\t// verilator lint_off UNUSED",
            "wire unused;\n\t\tassign\tunused = &{ 1'b0,\n`ifdef\tVERILATOR\n\t\t\t\t// Can't declare the clock as unused for formal,\n\t\t\t\t// lest it not be recognized as *the* clock\n\t\t\t\ti_clk,\n`endif\n\t\t\t\ti_reset };\n\t\t// verilator lint_on UNUSED\n\t\t// verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1;",
            "reg [AW+DW-1:0]\tf_idata;\n\talways @(*)\n\t\tf_idata = { i_addr, i_data };\n\n`ifdef\tADDRDECODE\n\talways @(posedge i_clk)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n`else\n\talways @(posedge i_clk)\n\tif (!f_past_valid)\n\t\tassert(i_reset);\n\n`endif\t// ADDRDECODE\n\talways @(posedge i_clk)\n\tif (OPT_REGISTERED && (!f_past_valid || $past(i_reset)))\n\tbegin\n\t\tassert(!o_valid);\n\t\tassert(o_decode == 0);\n\tend else if ($past(o_valid && i_stall) && OPT_REGISTERED)\n\tbegin\n\t\tassert($stable(o_addr));\n\t\tassert($stable(o_decode));\n\t\tassert($stable(o_data));\n\tend\n\n\t// If the",
            "output is ever valid, there must be at least one\n\t// decoded",
            "output always @(*)\n\t\tassert(o_valid == (o_decode != 0));\n\n\talways @(*)\n\tfor(iM=0; iM<NS; iM=iM+1)\n\tif (o_decode[iM])\n\tbegin\n\t\t// The address must match\n\t\tassert((((o_addr ^ SLAVE_ADDR[iM*AW +: AW])\n\t\t\t\t& SLAVE_MASK[iM*AW +: AW])==0)\n\t\t\t&& ACCESS_ALLOWED[iM]);\n\t\t//\n\t\t// And nothing else must match\n\t\tassert(o_decode == (1<<iM));\n\tend\n\n\talways @(*)\n\tfor(iM=0; iM<NS; iM=iM+1)\n\tif (!ACCESS_ALLOWED[iM])\n\t\tassert(!o_decode[iM]);\n\n\t// LOWPOWER check\n\t// {{{\n\tgenerate if (OPT_LOWPOWER && OPT_REGISTERED)\n\tbegin\n\t\talways @(*)\n\t\tif (!o_valid)\n\t\tbegin\n\t\t\tassert(o_addr   == 0);\n\t\t\tassert(o_decode == 0);\n\t\t\tassert(o_data   == 0);\n\t\tend\n\tend endgenerate\n\t// }}}\n\n\t//\n\t// The",
            "output decoded value may only ever have one value high,\n\t// never more--i.e. $onehot0\n\t// {{{\n`ifdef\tVERIFIC\n\talways @(*)\n\t\tassert($onehot0(request));\n`else",
            "reg onehot_request;\n\talways @(*)\n\tbegin\n\t\tonehot_request = 0;\n\t\tfor(iM=0; iM<NS+1; iM=iM+1)\n\t\tif ((request ^ (1<<iM))==0)\n\t\t\tonehot_request = 1;\n\tend\n\n\talways @(*)\n\tif (request != 0)\n\t\tassert(onehot_request);\n`endif\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Make sure all addresses are reachable\n\t//",
            "reg [NS:0]\tf_reached;\n\n\talways @(posedge i_clk)\n\t\tcover(i_valid);\n\n\talways @(posedge i_clk)\n\t\tcover(o_valid);\n\n\talways @(posedge i_clk)\n\t\tcover(o_valid && !i_stall);\n\n\tinitial\tf_reached = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_reached = 0;\n\telse if (o_valid)\n\t\tf_reached = f_reached | o_decode;\n\n\tgenerate if (!OPT_NONESEL && ACCESS_ALLOWED[0]\n\t\t\t&& SLAVE_MASK == 0 && NS == 1)\n\tbegin\n\t\t\n\t\talways @(*)\n\t\t\tcover(f_reached[0]);\n\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && $stable(o_valid))\n\t\t\tassert($stable(o_decode));\n\n\tend else begin\n\n\t\talways @(*)\n\t\t\tcover(&f_reached);\n\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && $stable(o_valid))\n\t\t\tcover($changed(o_decode));\n\n\tend endgenerate\n\t// }}}\n`endif\t// FORMAL\n// }}}",
            "endmodule `ifndef\tYOSYS\n`default_nettype",
            "wire `endif"
        ]
    },
    {
        "file_name": "axilxbar.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axilxbar.v",
        "chunks": [
            "module axilxbar #(\n\t\t// {{{",
            "parameter integer C_AXI_DATA_WIDTH = 32,",
            "parameter integer C_AXI_ADDR_WIDTH = 32,\n\t\t//\n\t\t// NM is the number of master interfaces this core supports",
            "parameter NM = 4,\n\t\t//\n\t\t// NS is the number of slave interfaces",
            "parameter NS = 8,\n\t\t//\n\t\t// AW, and DW, are short-hand abbreviations used locally.",
            "localparam AW = C_AXI_ADDR_WIDTH,",
            "localparam DW = C_AXI_DATA_WIDTH,\n\t\t// SLAVE_ADDR is a bit vector containing AW bits for each of the\n\t\t// slaves indicating the base address of the slave.  This\n\t\t// goes with SLAVE_MASK below.",
            "parameter [NS*AW-1:0]\tSLAVE_ADDR = {\n\t\t\t3'b111,  {(AW-3){1'b0}},\n\t\t\t3'b110,  {(AW-3){1'b0}},\n\t\t\t3'b101,  {(AW-3){1'b0}},\n\t\t\t3'b100,  {(AW-3){1'b0}},\n\t\t\t3'b011,  {(AW-3){1'b0}},\n\t\t\t3'b010,  {(AW-3){1'b0}},\n\t\t\t4'b0001, {(AW-4){1'b0}},\n\t\t\t4'b0000, {(AW-4){1'b0}} },\n\t\t//\n\t\t// SLAVE_MASK indicates which bits in the SLAVE_ADDR bit vector\n\t\t// need to be checked to determine if a given address request\n\t\t// maps to the given slave or not\n\t\t// Verilator lint_off WIDTH",
            "parameter [NS*AW-1:0]\tSLAVE_MASK =\n\t\t\t(NS <= 1) ? { 4'b1111, {(AW-4){1'b0}} }\n\t\t\t: { {(NS-2){ 3'b111, {(AW-3){1'b0}} }},\n\t\t\t\t{(2){ 4'b1111, {(AW-4){1'b0}} }} },\n\t\t// Verilator lint_on WIDTH\n\t\t//\n\t\t// If set, OPT_LOWPOWER will set all unused",
            "reg isters, both\n\t\t// internal and external, to zero anytime their corresponding\n\t\t// *VALID bit is clear",
            "parameter [0:0]\tOPT_LOWPOWER = 1,\n\t\t//\n\t\t// OPT_LINGER is the number of cycles to wait, following a\n\t\t// transaction, before tearing down the bus grant.",
            "parameter OPT_LINGER = 4,\n\t\t//\n\t\t// LGMAXBURST is the log (base two) of the maximum number of\n\t\t// requests that can be outstanding on any given channel at any\n\t\t// given time.  It is used within this core to control the\n\t\t// counters that are used to determine if a particular channel\n\t\t// grant must stay open, or if it may be closed.",
            "parameter LGMAXBURST = 5\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,\n\t\t// Incoming AXI4-lite slave port(s)\n\t\t// {{{",
            "input ",
            "wire [NM*C_AXI_ADDR_WIDTH-1:0]\tS_AXI_AWADDR,",
            "input ",
            "wire [NM*3-1:0]\t\t\tS_AXI_AWPROT,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_AWVALID,",
            "output ",
            "wire [NM-1:0]\t\t\tS_AXI_AWREADY,\n\t\t//",
            "input ",
            "wire [NM*C_AXI_DATA_WIDTH-1:0]\tS_AXI_WDATA,",
            "input ",
            "wire [NM*C_AXI_DATA_WIDTH/8-1:0]\tS_AXI_WSTRB,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_WVALID,",
            "output ",
            "wire [NM-1:0]\t\t\tS_AXI_WREADY,\n\t\t//",
            "output ",
            "wire [NM*2-1:0]\t\t\tS_AXI_BRESP,",
            "output ",
            "wire [NM-1:0]\t\t\tS_AXI_BVALID,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_BREADY,\n\t\t//",
            "input ",
            "wire [NM*C_AXI_ADDR_WIDTH-1:0]\tS_AXI_ARADDR,",
            "input ",
            "wire [NM*3-1:0]\t\t\tS_AXI_ARPROT,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_ARVALID,",
            "output ",
            "wire [NM-1:0]\t\t\tS_AXI_ARREADY,\n\t\t//",
            "output ",
            "wire [NM*C_AXI_DATA_WIDTH-1:0]\tS_AXI_RDATA,",
            "output ",
            "wire [NM*2-1:0]\t\t\tS_AXI_RRESP,",
            "output ",
            "wire [NM-1:0]\t\t\tS_AXI_RVALID,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_RREADY,\n\t\t// }}}\n\t\t// Outgoing AXI4-lite master port(s)\n\t\t// {{{",
            "output ",
            "wire [NS*C_AXI_ADDR_WIDTH-1:0]\tM_AXI_AWADDR,",
            "output ",
            "wire [NS*3-1:0]\t\t\tM_AXI_AWPROT,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_AWVALID,",
            "input ",
            "wire [NS-1:0]\t\t\tM_AXI_AWREADY,\n\t\t//",
            "output ",
            "wire [NS*C_AXI_DATA_WIDTH-1:0]\tM_AXI_WDATA,",
            "output ",
            "wire [NS*C_AXI_DATA_WIDTH/8-1:0]\tM_AXI_WSTRB,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_WVALID,",
            "input ",
            "wire [NS-1:0]\t\t\tM_AXI_WREADY,\n\t\t//",
            "input ",
            "wire [NS*2-1:0]\t\t\tM_AXI_BRESP,",
            "input ",
            "wire [NS-1:0]\t\t\tM_AXI_BVALID,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_BREADY,\n\t\t//",
            "output ",
            "wire [NS*C_AXI_ADDR_WIDTH-1:0]\tM_AXI_ARADDR,",
            "output ",
            "wire [NS*3-1:0]\t\t\tM_AXI_ARPROT,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_ARVALID,",
            "input ",
            "wire [NS-1:0]\t\t\tM_AXI_ARREADY,\n\t\t//",
            "input ",
            "wire [NS*C_AXI_DATA_WIDTH-1:0]\tM_AXI_RDATA,",
            "input ",
            "wire [NS*2-1:0]\t\t\tM_AXI_RRESP,",
            "input ",
            "wire [NS-1:0]\t\t\tM_AXI_RVALID,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_RREADY\n\t\t// }}}\n\t\t// }}}\n\t);\n\t//\n\t// Local",
            "parameter s, derived from those above\n\t// {{{",
            "localparam LGLINGER = (OPT_LINGER>1) ? $clog2(OPT_LINGER+1) : 1;\n\t//",
            "localparam LGNM = (NM>1) ? $clog2(NM) : 1;",
            "localparam LGNS = (NS>1) ? $clog2(NS+1) : 1;\n\t//\n\t// In order to use indexes, and hence fully balanced mux trees, it helps\n\t// to make certain that we have a power of two based lookup.  NMFULL\n\t// is the number of masters in this lookup, with potentially some\n\t// unused extra ones.  NSFULL is defined similarly.",
            "localparam NMFULL = (NM>1) ? (1<<LGNM) : 1;",
            "localparam NSFULL = (NS>1) ? (1<<LGNS) : 2;\n\t//",
            "localparam [1:0] INTERCONNECT_ERROR = 2'b11;",
            "localparam [0:0]\tOPT_SKID_INPUT = 0;",
            "localparam [0:0]\tOPT_BUFFER_DECODER = 1;\n\n\tgenvar\tN,M;\n\tinteger\tiN, iM;\n\t// }}}\n\n\t// {{{",
            "reg [NSFULL-1:0]\twrequest\t\t[0:NM-1];",
            "reg [NSFULL-1:0]\trrequest\t\t[0:NM-1];",
            "reg [NSFULL-1:0]\twrequested\t\t[0:NM];",
            "reg [NSFULL-1:0]\trrequested\t\t[0:NM];",
            "reg [NS:0]\t\twgrant\t\t\t[0:NM-1];",
            "reg [NS:0]\t\trgrant\t\t\t[0:NM-1];",
            "reg [NM-1:0]\tswgrant;",
            "reg [NM-1:0]\tsrgrant;",
            "reg [NS-1:0]\tmwgrant;",
            "reg [NS-1:0]\tmrgrant;\n\n\t// verilator lint_off UNUSED",
            "wire [LGMAXBURST-1:0]\tw_sawpending\t[0:NM-1];",
            "wire [LGMAXBURST-1:0]\tw_swpending\t[0:NM-1];",
            "wire [LGMAXBURST-1:0]\tw_srpending\t[0:NM-1];\n\t// verilator lint_on  UNUSED",
            "reg [NM-1:0]\t\tswfull;",
            "reg [NM-1:0]\t\tsrfull;",
            "reg [NM-1:0]\t\tswempty;",
            "reg [NM-1:0]\t\tsrempty;\n\t//",
            "wire [LGNS-1:0]\t\tswindex\t[0:NMFULL-1];",
            "wire [LGNS-1:0]\t\tsrindex\t[0:NMFULL-1];",
            "wire [LGNM-1:0]\t\tmwindex\t[0:NSFULL-1];",
            "wire [LGNM-1:0]\t\tmrindex\t[0:NSFULL-1];",
            "wire [NM-1:0]\t\twdata_expected;\n\n\t// The shadow buffers",
            "wire [NMFULL-1:0]\tm_awvalid, m_wvalid, m_arvalid;",
            "wire [NM-1:0]\tdcd_awvalid, dcd_arvalid;",
            "wire [C_AXI_ADDR_WIDTH-1:0]\t\tm_awaddr\t[0:NMFULL-1];",
            "wire [2:0]\t\t\t\tm_awprot\t[0:NMFULL-1];",
            "wire [C_AXI_DATA_WIDTH-1:0]\t\tm_wdata\t\t[0:NMFULL-1];",
            "wire [C_AXI_DATA_WIDTH/8-1:0]\tm_wstrb\t\t[0:NMFULL-1];",
            "wire [C_AXI_ADDR_WIDTH-1:0]\t\tm_araddr\t[0:NMFULL-1];",
            "wire [2:0]\t\t\t\tm_arprot\t[0:NMFULL-1];\n\t//",
            "wire [NM-1:0]\tskd_awvalid, skd_awstall, skd_wvalid;",
            "wire [NM-1:0]\tskd_arvalid, skd_arstall;",
            "wire [AW-1:0]\tskd_awaddr\t\t\t[0:NM-1];",
            "wire [3-1:0]\t\tskd_awprot\t\t\t[0:NM-1];",
            "wire [AW-1:0]\tskd_araddr\t\t\t[0:NM-1];",
            "wire [3-1:0]\t\tskd_arprot\t\t\t[0:NM-1];",
            "reg r_bvalid\t[0:NM-1];",
            "reg [1:0]\tr_bresp\t\t[0:NM-1];",
            "reg [NSFULL-1:0]\tm_axi_awvalid;",
            "reg [NSFULL-1:0]\tm_axi_awready;",
            "reg [NSFULL-1:0]\tm_axi_wvalid;",
            "reg [NSFULL-1:0]\tm_axi_wready;",
            "reg [NSFULL-1:0]\tm_axi_bvalid;\n`ifdef\tFORMAL",
            "reg [NSFULL-1:0]\tm_axi_bready;\n`endif",
            "reg [1:0]\t\tm_axi_bresp\t[0:NSFULL-1];",
            "reg [NSFULL-1:0]\tm_axi_arvalid;\n\t// Verilator lint_off UNUSED",
            "reg [NSFULL-1:0]\tm_axi_arready;\n\t// Verilator lint_on  UNUSED",
            "reg [NSFULL-1:0]\tm_axi_rvalid;\n\t// Verilator lint_off UNUSED",
            "reg [NSFULL-1:0]\tm_axi_rready;\n\t// Verilator lint_on  UNUSED",
            "reg r_rvalid\t[0:NM-1];",
            "reg [1:0]\t\tr_rresp\t\t[0:NM-1];",
            "reg [DW-1:0]\tr_rdata\t\t[0:NM-1];",
            "reg [DW-1:0]\tm_axi_rdata\t[0:NSFULL-1];",
            "reg [1:0]\t\tm_axi_rresp\t[0:NSFULL-1];",
            "reg [NM-1:0]\tslave_awaccepts;",
            "reg [NM-1:0]\tslave_waccepts;",
            "reg [NM-1:0]\tslave_raccepts;\n\t// }}}\n\n\t// m_axi_[aw|w|b]*\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tm_axi_awvalid = -1;\n\t\tm_axi_awready = -1;\n\t\tm_axi_wvalid = -1;\n\t\tm_axi_wready = -1;\n\t\tm_axi_bvalid = 0;\n\n\t\tm_axi_awvalid[NS-1:0] = M_AXI_AWVALID;\n\t\tm_axi_awready[NS-1:0] = M_AXI_AWREADY;\n\t\tm_axi_wvalid[NS-1:0]  = M_AXI_WVALID;\n\t\tm_axi_wready[NS-1:0]  = M_AXI_WREADY;\n\t\tm_axi_bvalid[NS-1:0]  = M_AXI_BVALID;\n\n\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\tbegin\n\t\t\tm_axi_bresp[iM] = M_AXI_BRESP[iM* 2 +:  2];\n\n\t\t\tm_axi_rdata[iM] = M_AXI_RDATA[iM*DW +: DW];\n\t\t\tm_axi_rresp[iM] = M_AXI_RRESP[iM* 2 +:  2];\n\t\tend\n\t\tfor(iM=NS; iM<NSFULL; iM=iM+1)\n\t\tbegin\n\t\t\tm_axi_bresp[iM] = INTERCONNECT_ERROR;\n\n\t\t\tm_axi_rdata[iM] = 0;\n\t\t\tm_axi_rresp[iM] = INTERCONNECT_ERROR;\n\t\tend\n\n`ifdef\tFORMAL\n\t\tm_axi_bready = -1;\n\t\tm_axi_bready[NS-1:0]  = M_AXI_BREADY;\n`endif\n\tend\n\t// }}}\n\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : DECODE_WRITE_REQUEST\n\t\t// {{{",
            "wire [NS:0]\t\twdecode;",
            "reg r_mawvalid, r_mwvalid;\n\n\t\t// awskid\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(AW+3), .OPT_OUTREG(OPT_SKID_INPUT)\n\t\t\t// }}}\n\t\t) awskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tS_AXI_AWVALID[N], S_AXI_AWREADY[N],\n\t\t\t{ S_AXI_AWADDR[N*AW +: AW], S_AXI_AWPROT[N*3 +: 3] },\n\t\t\tskd_awvalid[N], !skd_awstall[N],\n\t\t\t\t{ skd_awaddr[N], skd_awprot[N] }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// write address decoding\n\t\t// {{{\n\t\taddrdecode #(\n\t\t\t// {{{\n\t\t\t.AW(AW), .DW(3), .NS(NS),\n\t\t\t.SLAVE_ADDR(SLAVE_ADDR),\n\t\t\t.SLAVE_MASK(SLAVE_MASK),\n\t\t\t.OPT_REGISTERED(OPT_BUFFER_DECODER)\n\t\t\t// }}}\n\t\t) wraddr(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t\t.i_valid(skd_awvalid[N]), .o_stall(skd_awstall[N]),\n\t\t\t\t.i_addr(skd_awaddr[N]), .i_data(skd_awprot[N]),\n\t\t\t.o_valid(dcd_awvalid[N]),\n\t\t\t\t.i_stall(!dcd_awvalid[N]||!slave_awaccepts[N]),\n\t\t\t\t.o_decode(wdecode), .o_addr(m_awaddr[N]),\n\t\t\t\t.o_data(m_awprot[N])\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// wskid\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(DW+DW/8), .OPT_OUTREG(OPT_SKID_INPUT)\n\t\t\t// }}}\n\t\t) wskid\n\t\t\t// {{{\n\t\t\t(S_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tS_AXI_WVALID[N], S_AXI_WREADY[N],\n\t\t\t{ S_AXI_WDATA[N*DW +: DW], S_AXI_WSTRB[N*DW/8 +: DW/8]},\n\t\t\tskd_wvalid[N], (m_wvalid[N] && slave_waccepts[N]),\n\t\t\t\t\t{ m_wdata[N], m_wstrb[N] }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// slave_awaccepts\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tslave_awaccepts[N] = 1'b1;\n\t\t\tif (!swgrant[N])\n\t\t\t\tslave_awaccepts[N] = 1'b0;\n\t\t\tif (swfull[N])\n\t\t\t\tslave_awaccepts[N] = 1'b0;\n\t\t\tif (!wrequest[N][swindex[N]])\n\t\t\t\tslave_awaccepts[N] = 1'b0;\n\t\t\tif (!wgrant[N][NS]&&(m_axi_awvalid[swindex[N]] && !m_axi_awready[swindex[N]]))\n\t\t\t\tslave_awaccepts[N] = 1'b0;\n\t\t\t// ERRORs are always accepted\n\t\t\t//\tback pressure is handled in the write side\n\t\tend\n\t\t// }}}\n\n\t\t// slave_waccepts\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tslave_waccepts[N] = 1'b1;\n\t\t\tif (!swgrant[N])\n\t\t\t\tslave_waccepts[N] = 1'b0;\n\t\t\tif (!wdata_expected[N])\n\t\t\t\tslave_waccepts[N] = 1'b0;\n\t\t\tif (!wgrant[N][NS] &&(m_axi_wvalid[swindex[N]]\n\t\t\t\t\t\t&& !m_axi_wready[swindex[N]]))\n\t\t\t\tslave_waccepts[N] = 1'b0;\n\t\t\tif (wgrant[N][NS]&&(S_AXI_BVALID[N]&& !S_AXI_BREADY[N]))\n\t\t\t\tslave_waccepts[N] = 1'b0;\n\t\tend\n\t\t// }}}\n\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tr_mawvalid= dcd_awvalid[N] && !swfull[N];\n\t\t\tr_mwvalid = skd_wvalid[N];\n\t\t\twrequest[N]= 0;\n\t\t\tif (!swfull[N])\n\t\t\t\twrequest[N][NS:0] = wdecode;\n\t\tend\n\n\t\tassign\tm_awvalid[N] = r_mawvalid;\n\t\tassign\tm_wvalid[N] = r_mwvalid;\n\t\t// }}}\n\n\t\t// }}}\n\tend for (N=NM; N<NMFULL; N=N+1)\n\tbegin : UNUSED_WSKID_BUFFERS\n\t\t// {{{\n\t\tassign\tm_awvalid[N] = 0;\n\t\tassign\tm_awaddr[N] = 0;\n\t\tassign\tm_awprot[N] = 0;\n\t\tassign\tm_wdata[N] = 0;\n\t\tassign\tm_wstrb[N] = 0;\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : DECODE_READ_REQUEST\n\t\t// {{{",
            "wire [NS:0]\t\trdecode;",
            "reg r_marvalid;\n\n\t\t// arskid\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(AW+3), .OPT_OUTREG(OPT_SKID_INPUT)\n\t\t\t// }}}\n\t\t) arskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tS_AXI_ARVALID[N], S_AXI_ARREADY[N],\n\t\t\t{ S_AXI_ARADDR[N*AW +: AW], S_AXI_ARPROT[N*3 +: 3] },\n\t\t\tskd_arvalid[N], !skd_arstall[N],\n\t\t\t\t{ skd_araddr[N], skd_arprot[N] }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// Read address decoding\n\t\t// {{{\n\t\taddrdecode #(\n\t\t\t// {{{\n\t\t\t.AW(AW), .DW(3), .NS(NS),\n\t\t\t.SLAVE_ADDR(SLAVE_ADDR), .SLAVE_MASK(SLAVE_MASK),\n\t\t\t.OPT_REGISTERED(OPT_BUFFER_DECODER)\n\t\t\t// }}}\n\t\t) rdaddr(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t\t.i_valid(skd_arvalid[N]), .o_stall(skd_arstall[N]),\n\t\t\t\t.i_addr(skd_araddr[N]), .i_data(skd_arprot[N]),\n\t\t\t.o_valid(dcd_arvalid[N]),\n\t\t\t\t.i_stall(!m_arvalid[N] || !slave_raccepts[N]),\n\t\t\t\t.o_decode(rdecode), .o_addr(m_araddr[N]),\n\t\t\t\t.o_data(m_arprot[N])\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// m_arvalid[N]\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tr_marvalid = dcd_arvalid[N] && !srfull[N];\n\t\t\trrequest[N] = 0;\n\t\t\tif (!srfull[N])\n\t\t\t\trrequest[N][NS:0] = rdecode;\n\t\tend\n\n\t\tassign\tm_arvalid[N] = r_marvalid;\n\t\t// }}}\n\n\t\t// slave_raccepts\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tslave_raccepts[N] = 1'b1;\n\t\t\tif (!srgrant[N])\n\t\t\t\tslave_raccepts[N] = 1'b0;\n\t\t\tif (srfull[N])\n\t\t\t\tslave_raccepts[N] = 1'b0;\n\t\t\t// verilator lint_off  WIDTH\n\t\t\tif (!rrequest[N][srindex[N]])\n\t\t\t\tslave_raccepts[N] = 1'b0;\n\t\t\t// verilator lint_on  WIDTH\n\t\t\tif (!rgrant[N][NS])\n\t\t\tbegin\n\t\t\t\tif (m_axi_arvalid[srindex[N]] && !m_axi_arready[srindex[N]])\n\t\t\t\t\tslave_raccepts[N] = 1'b0;\n\t\t\tend else if (S_AXI_RVALID[N] && !S_AXI_RREADY[N])\n\t\t\t\tslave_raccepts[N] = 1'b0;\n\t\tend\n\t\t// }}}\n\n\t\t// }}}\n\tend for (N=NM; N<NMFULL; N=N+1)\n\tbegin : UNUSED_RSKID_BUFFERS\n\t\t// {{{\n\t\tassign\tm_arvalid[N] = 0;\n\t\tassign\tm_araddr[N] = 0;\n\t\tassign\tm_arprot[N] = 0;\n\t\t// }}}\n\tend endgenerate\n\n\t// wrequested\n\t// {{{\n\talways @(*)\n\tbegin : DECONFLICT_WRITE_REQUESTS\n\n\t\tfor(iN=1; iN<NM ; iN=iN+1)\n\t\t\twrequested[iN] = 0;\n\n\t\t// Vivado may complain about too many bits for wrequested.\n\t\t// This is (currrently) expected.  swindex is used to index\n\t\t// into wrequested, and swindex has LGNS bits, where LGNS\n\t\t// is $clog2(NS+1) rather than $clog2(NS).  The extra bits\n\t\t// are defined to be zeros, but the point is there are defined.\n\t\t// Therefore, no matter what swindex is, it will always\n\t\t// reference something valid.\n\t\twrequested[NM] = 0;\n\n\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\tbegin\n\t\t\twrequested[0][iM] = 1'b0;\n\t\t\tfor(iN=1; iN<NM ; iN=iN+1)\n\t\t\tbegin\n\t\t\t\t// Continue to request any channel with\n\t\t\t\t// a grant and pending operations\n\t\t\t\tif (wrequest[iN-1][iM] && wgrant[iN-1][iM])\n\t\t\t\t\twrequested[iN][iM] = 1;\n\t\t\t\tif (wrequest[iN-1][iM] && (!swgrant[iN-1]||swempty[iN-1]))\n\t\t\t\t\twrequested[iN][iM] = 1;\n\t\t\t\t// Otherwise, if it's already claimed, then\n\t\t\t\t// it can't be claimed again\n\t\t\t\tif (wrequested[iN-1][iM])\n\t\t\t\t\twrequested[iN][iM] = 1;\n\t\t\tend\n\t\t\twrequested[NM][iM] = wrequest[NM-1][iM] || wrequested[NM-1][iM];\n\t\tend\n\tend\n\t// }}}\n\n\t// rrequested\n\t// {{{\n\talways @(*)\n\tbegin : DECONFLICT_READ_REQUESTS\n\n\t\tfor(iN=0; iN<NM ; iN=iN+1)\n\t\t\trrequested[iN] = 0;\n\n\t\t// See the note above for wrequested.  This applies to\n\t\t// rrequested as well.\n\t\trrequested[NM] = 0;\n\n\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\tbegin\n\t\t\trrequested[0][iM] = 0;\n\t\t\tfor(iN=1; iN<NM ; iN=iN+1)\n\t\t\tbegin\n\t\t\t\t// Continue to request any channel with\n\t\t\t\t// a grant and pending operations\n\t\t\t\tif (rrequest[iN-1][iM] && rgrant[iN-1][iM])\n\t\t\t\t\trrequested[iN][iM] = 1;\n\t\t\t\tif (rrequest[iN-1][iM] && (!srgrant[iN-1] || srempty[iN-1]))\n\t\t\t\t\trrequested[iN][iM] = 1;\n\t\t\t\t// Otherwise, if it's already claimed, then\n\t\t\t\t// it can't be claimed again\n\t\t\t\tif (rrequested[iN-1][iM])\n\t\t\t\t\trrequested[iN][iM] = 1;\n\t\t\tend\n\t\t\trrequested[NM][iM] = rrequest[NM-1][iM] || rrequested[NM-1][iM];\n\t\tend\n\tend\n\t// }}}\n\n\t// mwgrant, mrgrant\n\t// {{{\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin\n\t\t// {{{\n\t\tinitial\tmwgrant[M] = 0;\n\t\talways @(*)\n\t\tbegin\n\t\t\tmwgrant[M] = 0;\n\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\tif (wgrant[iN][M])\n\t\t\t\tmwgrant[M] = 1;\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tmrgrant[M] = 0;\n\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\tif (rgrant[iN][M])\n\t\t\t\tmrgrant[M] = 1;\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : ARBITRATE_WRITE_REQUESTS\n\t\t// {{{\n\t\t// Declarations\n\t\t// {{{",
            "reg stay_on_channel;",
            "reg requested_channel_is_available;",
            "reg leave_channel;",
            "reg [LGNS-1:0]\trequested_index;\n\t\t// }}}\n\n\t\t// stay_on_channel\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tstay_on_channel = |(wrequest[N][NS:0] & wgrant[N]);\n\n\t\t\tif (swgrant[N] && !swempty[N])\n\t\t\t\tstay_on_channel = 1;\n\t\tend\n\t\t// }}}\n\n\t\t// requested_channel_is_available\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\trequested_channel_is_available =\n\t\t\t\t|(wrequest[N][NS-1:0] & ~mwgrant\n\t\t\t\t\t\t& ~wrequested[N][NS-1:0]);\n\t\t\tif (wrequest[N][NS])\n\t\t\t\trequested_channel_is_available = 1;\n\n\t\t\tif (NM < 2)\n\t\t\t\trequested_channel_is_available = m_awvalid[N];\n\t\tend\n\t\t// }}}",
            "wire linger;\n\t\tif (OPT_LINGER == 0)\n\t\tbegin : NO_LINGER\n\t\t\t// {{{\n\t\t\tassign\tlinger = 0;\n\t\t\t// }}}\n\t\tend else begin : WRITE_LINGER\n\t\t\t// {{{",
            "reg [LGLINGER-1:0]\tlinger_counter;",
            "reg r_linger;\n\n\t\t\tinitial\tr_linger = 0;\n\t\t\tinitial\tlinger_counter = 0;\n\t\t\talways @(posedge S_AXI_ACLK)\n\t\t\tif (!S_AXI_ARESETN || wgrant[N][NS])\n\t\t\tbegin\n\t\t\t\tr_linger <= 0;\n\t\t\t\tlinger_counter <= 0;\n\t\t\tend else if (!swempty[N] || S_AXI_BVALID[N])\n\t\t\tbegin\n\t\t\t\tlinger_counter <= OPT_LINGER;\n\t\t\t\tr_linger <= 1;\n\t\t\tend else if (linger_counter > 0)\n\t\t\tbegin\n\t\t\t\tr_linger <= (linger_counter > 1);\n\t\t\t\tlinger_counter <= linger_counter - 1;\n\t\t\tend else\n\t\t\t\tr_linger <= 0;\n\n\t\t\tassign\tlinger = r_linger;\n\n`ifdef\tFORMAL\n\t\t// {{{\n\t\t\talways @(*)\n\t\t\t\tassert(linger == (linger_counter != 0));\n\t\t// }}}\n`endif\n\t\t\t// }}}\n\t\tend\n\n\t\t// leave_channel\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tleave_channel = 0;\n\t\t\tif (!m_awvalid[N]\n\t\t\t\t&& (!linger || wrequested[NM][swindex[N]]))\n\t\t\t\t// Leave the channel after OPT_LINGER counts\n\t\t\t\t// of the channel being idle, or when someone\n\t\t\t\t// else asks for the channel\n\t\t\t\tleave_channel = 1;\n\t\t\tif (m_awvalid[N] && !wrequest[N][swindex[N]])\n\t\t\t\t// Need to leave this channel to connect\n\t\t\t\t// to any other channel\n\t\t\t\tleave_channel = 1;\n\t\tend\n\t\t// }}}\n\n\t\t// wgrant, swgrant\n\t\t// {{{\n\t\tinitial\twgrant[N]  = 0;\n\t\tinitial\tswgrant[N] = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\twgrant[N]  <= 0;\n\t\t\tswgrant[N] <= 0;\n\t\tend else if (!stay_on_channel)\n\t\tbegin\n\t\t\tif (requested_channel_is_available)\n\t\t\tbegin\n\t\t\t\t// Switching channels\n\t\t\t\tswgrant[N] <= 1'b1;\n\t\t\t\twgrant[N]  <= wrequest[N][NS:0];\n\t\t\tend else if (leave_channel)\n\t\t\tbegin\n\t\t\t\tswgrant[N] <= 1'b0;\n\t\t\t\twgrant[N]  <= 0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\t// requested_index\n\t\t// {{{\n\t\talways @(wrequest[N])\n\t\tbegin\n\t\t\trequested_index = 0;\n\t\t\tfor(iM=0; iM<=NS; iM=iM+1)\n\t\t\tif (wrequest[N][iM])\n\t\t\t\trequested_index= requested_index | iM[LGNS-1:0];\n\t\tend\n\t\t// }}}\n\n\t\t// Now for swindex\n\t\t// {{{",
            "reg [LGNS-1:0]\tr_swindex;\n\n\t\tinitial\tr_swindex = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!stay_on_channel && requested_channel_is_available)\n\t\t\tr_swindex <= requested_index;\n\n\t\tassign\tswindex[N] = r_swindex;\n\t\t// }}}\n\t\t// }}}\n\tend for (N=NM; N<NMFULL; N=N+1)\n\tbegin\n\t\t// {{{\n\t\tassign\tswindex[N] = 0;\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : ARBITRATE_READ_REQUESTS\n\t\t// {{{\n\t\t// Declarations\n\t\t// {{{",
            "reg stay_on_channel;",
            "reg requested_channel_is_available;",
            "reg leave_channel;",
            "reg [LGNS-1:0]\trequested_index;\n\t\t// }}}\n\n\t\t// stay_on_channel\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tstay_on_channel = |(rrequest[N][NS:0] & rgrant[N]);\n\n\t\t\tif (srgrant[N] && !srempty[N])\n\t\t\t\tstay_on_channel = 1;\n\t\tend\n\t\t// }}}\n\n\t\t// requested_channel_is_available\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\trequested_channel_is_available =\n\t\t\t\t|(rrequest[N][NS-1:0] & ~mrgrant\n\t\t\t\t\t\t& ~rrequested[N][NS-1:0]);\n\t\t\tif (rrequest[N][NS])\n\t\t\t\trequested_channel_is_available = 1;\n\n\t\t\tif (NM < 2)\n\t\t\t\trequested_channel_is_available = m_arvalid[N];\n\t\tend\n\t\t// }}}",
            "wire linger;\n\t\tif (OPT_LINGER == 0)\n\t\tbegin : NO_LINGER\n\t\t\t// {{{\n\t\t\tassign\tlinger = 0;\n\t\t\t// }}}\n\t\tend else begin : READ_LINGER\n\t\t\t// {{{",
            "reg [LGLINGER-1:0]\tlinger_counter;",
            "reg r_linger;\n\n\t\t\tinitial\tr_linger = 0;\n\t\t\tinitial\tlinger_counter = 0;\n\t\t\talways @(posedge S_AXI_ACLK)\n\t\t\tif (!S_AXI_ARESETN || rgrant[N][NS])\n\t\t\tbegin\n\t\t\t\tr_linger <= 0;\n\t\t\t\tlinger_counter <= 0;\n\t\t\tend else if (!srempty[N] || S_AXI_RVALID[N])\n\t\t\tbegin\n\t\t\t\tlinger_counter <= OPT_LINGER;\n\t\t\t\tr_linger <= 1;\n\t\t\tend else if (linger_counter > 0)\n\t\t\tbegin\n\t\t\t\tr_linger <= (linger_counter > 1);\n\t\t\t\tlinger_counter <= linger_counter - 1;\n\t\t\tend else\n\t\t\t\tr_linger <= 0;\n\n\t\t\tassign\tlinger = r_linger;\n`ifdef\tFORMAL\n\t\t\t// {{{\n\t\t\talways @(*)\n\t\t\t\tassert(linger == (linger_counter != 0));\n\t\t\t// }}}\n`endif\n\t\t\t// }}}\n\t\tend\n\n\t\t// leave_channel\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tleave_channel = 0;\n\t\t\tif (!m_arvalid[N]\n\t\t\t\t&& (!linger || rrequested[NM][srindex[N]]))\n\t\t\t\t// Leave the channel after OPT_LINGER counts\n\t\t\t\t// of the channel being idle, or when someone\n\t\t\t\t// else asks for the channel\n\t\t\t\tleave_channel = 1;\n\t\t\tif (m_arvalid[N] && !rrequest[N][srindex[N]])\n\t\t\t\t// Need to leave this channel to connect\n\t\t\t\t// to any other channel\n\t\t\t\tleave_channel = 1;\n\t\tend\n\t\t// }}}\n\n\t\t// rgrant, srgrant\n\t\t// {{{\n\t\tinitial\trgrant[N]  = 0;\n\t\tinitial\tsrgrant[N] = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\trgrant[N]  <= 0;\n\t\t\tsrgrant[N] <= 0;\n\t\tend else if (!stay_on_channel)\n\t\tbegin\n\t\t\tif (requested_channel_is_available)\n\t\t\tbegin\n\t\t\t\t// Switching channels\n\t\t\t\tsrgrant[N] <= 1'b1;\n\t\t\t\trgrant[N] <= rrequest[N][NS:0];\n\t\t\tend else if (leave_channel)\n\t\t\tbegin\n\t\t\t\tsrgrant[N] <= 1'b0;\n\t\t\t\trgrant[N]  <= 0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\t// requested_index\n\t\t// {{{\n\t\talways @(rrequest[N])\n\t\tbegin\n\t\t\trequested_index = 0;\n\t\t\tfor(iM=0; iM<=NS; iM=iM+1)\n\t\t\tif (rrequest[N][iM])\n\t\t\t\trequested_index = requested_index|iM[LGNS-1:0];\n\t\tend\n\t\t// }}}\n\n\t\t// Now for srindex\n\t\t// {{{",
            "reg [LGNS-1:0]\tr_srindex;\n\n\t\tinitial\tr_srindex = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!stay_on_channel && requested_channel_is_available)\n\t\t\tr_srindex <= requested_index;\n\n\t\tassign\tsrindex[N] = r_srindex;\n\t\t// }}}\n\t\t// }}}\n\tend for (N=NM; N<NMFULL; N=N+1)\n\tbegin : UNUSED_SRINDEX\n\t\t// {{{\n\t\tassign\tsrindex[N] = 0;\n\t\t// }}}\n\tend endgenerate\n\n\t// Calculate mwindex\n\tgenerate for (M=0; M<NS; M=M+1)\n\tbegin : SLAVE_WRITE_INDEX\n\t\t// {{{\n\t\tif (NM <= 1)\n\t\tbegin : SINGLE_MASTER\n\t\t\t// {{{\n\t\t\tassign mwindex[M] = 0;\n\t\t\t// }}}\n\t\tend else begin : MULTIPLE_MASTERS\n\t\t\t// {{{",
            "reg [LGNM-1:0]\t\treswindex;",
            "reg [LGNM-1:0]\tr_mwindex;\n\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\treswindex = 0;\n\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\tif ((!swgrant[iN] || swempty[iN])\n\t\t\t\t&&(wrequest[iN][M] && !wrequested[iN][M]))\n\t\t\t\t\treswindex = reswindex | iN[LGNM-1:0];\n\t\t\tend\n\n\t\t\talways @(posedge S_AXI_ACLK)\n\t\t\tif (!mwgrant[M])\n\t\t\t\tr_mwindex <= reswindex;\n\n\t\t\tassign\tmwindex[M] = r_mwindex;\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\tend for (M=NS; M<NSFULL; M=M+1)\n\tbegin : NO_WINDEX\n\t\t// {{{\n\t\tassign\tmwindex[M] = 0;\n\t\t// }}}\n\tend endgenerate\n\n\t// Calculate mrindex\n\tgenerate for (M=0; M<NS; M=M+1)\n\tbegin : SLAVE_READ_INDEX\n\t\t// {{{\n\t\tif (NM <= 1)\n\t\tbegin : SINGLE_MASTER\n\t\t\t// {{{\n\t\t\tassign mrindex[M] = 0;\n\t\t\t// }}}\n\t\tend else begin : MULTIPLE_MASTERS\n\t\t\t// {{{",
            "reg [LGNM-1:0]\tresrindex;",
            "reg [LGNM-1:0]\tr_mrindex;\n\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\tresrindex = 0;\n\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\tif ((!srgrant[iN] || srempty[iN])\n\t\t\t\t&&(rrequest[iN][M] && !rrequested[iN][M]))\n\t\t\t\t\tresrindex = resrindex | iN[LGNM-1:0];\n\t\t\tend\n\n\t\t\talways @(posedge S_AXI_ACLK)\n\t\t\tif (!mrgrant[M])\n\t\t\t\tr_mrindex <= resrindex;\n\n\t\t\tassign\tmrindex[M] = r_mrindex;\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\tend for (M=NS; M<NSFULL; M=M+1)\n\tbegin\n\t\t// {{{\n\t\tassign\tmrindex[M] = 0;\n\t\t// }}}\n\tend endgenerate\n\n\t// Assign",
            "output s to the various slaves\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : WRITE_SLAVE_OUTPUTS\n\t\t// {{{\n\n\t\t// Declarations\n\t\t// {{{",
            "reg axi_awvalid;",
            "reg [AW-1:0]\taxi_awaddr;",
            "reg [2:0]\t\taxi_awprot;",
            "reg axi_wvalid;",
            "reg [DW-1:0]\taxi_wdata;",
            "reg [DW/8-1:0]\taxi_wstrb;\n\t\t//",
            "reg axi_bready;",
            "wire sawstall, swstall, mbstall;\n\t\t// }}}\n\t\tassign\tsawstall= (M_AXI_AWVALID[M]&& !M_AXI_AWREADY[M]);\n\t\tassign\tswstall = (M_AXI_WVALID[M] && !M_AXI_WREADY[M]);\n\t\tassign\tmbstall = (S_AXI_BVALID[mwindex[M]] && !S_AXI_BREADY[mwindex[M]]);\n\n\t\t// axi_awvalid\n\t\t// {{{\n\t\tinitial\taxi_awvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || !mwgrant[M])\n\t\t\taxi_awvalid <= 0;\n\t\telse if (!sawstall)\n\t\tbegin\n\t\t\taxi_awvalid <= m_awvalid[mwindex[M]]\n\t\t\t\t&&(slave_awaccepts[mwindex[M]]);\n\t\tend\n\t\t// }}}\n\n\t\t// axi_awaddr, axi_awprot\n\t\t// {{{\n\t\tinitial\taxi_awaddr  = 0;\n\t\tinitial\taxi_awprot  = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\tbegin\n\t\t\taxi_awaddr  <= 0;\n\t\t\taxi_awprot  <= 0;\n\t\tend else if (OPT_LOWPOWER && !mwgrant[M])\n\t\tbegin\n\t\t\taxi_awaddr  <= 0;\n\t\t\taxi_awprot  <= 0;\n\t\tend else if (!sawstall)\n\t\tbegin\n\t\t\tif (!OPT_LOWPOWER||(m_awvalid[mwindex[M]]&&slave_awaccepts[mwindex[M]]))\n\t\t\tbegin\n\t\t\t\taxi_awaddr  <= m_awaddr[mwindex[M]];\n\t\t\t\taxi_awprot  <= m_awprot[mwindex[M]];\n\t\t\tend else begin\n\t\t\t\taxi_awaddr  <= 0;\n\t\t\t\taxi_awprot  <= 0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\t// axi_wvalid\n\t\t// {{{\n\t\tinitial\taxi_wvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || !mwgrant[M])\n\t\t\taxi_wvalid <= 0;\n\t\telse if (!swstall)\n\t\tbegin\n\t\t\taxi_wvalid <= (m_wvalid[mwindex[M]])\n\t\t\t\t\t&&(slave_waccepts[mwindex[M]]);\n\t\tend\n\t\t// }}}\n\n\t\t// axi_wdata, axi_wstrb\n\t\t// {{{\n\t\tinitial axi_wdata  = 0;\n\t\tinitial axi_wstrb  = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\tbegin\n\t\t\taxi_wdata  <= 0;\n\t\t\taxi_wstrb  <= 0;\n\t\tend else if (OPT_LOWPOWER && !mwgrant[M])\n\t\tbegin\n\t\t\taxi_wdata  <= 0;\n\t\t\taxi_wstrb  <= 0;\n\t\tend else if (!swstall)\n\t\tbegin\n\t\t\tif (!OPT_LOWPOWER || (m_wvalid[mwindex[M]]&&slave_waccepts[mwindex[M]]))\n\t\t\tbegin\n\t\t\t\taxi_wdata  <= m_wdata[mwindex[M]];\n\t\t\t\taxi_wstrb  <= m_wstrb[mwindex[M]];\n\t\t\tend else begin\n\t\t\t\taxi_wdata  <= 0;\n\t\t\t\taxi_wstrb  <= 0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\t// axi_bready\n\t\t// {{{\n\t\tinitial\taxi_bready = 1;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || !mwgrant[M])\n\t\t\taxi_bready <= 1;\n\t\telse if (!mbstall)\n\t\t\taxi_bready <= 1;\n\t\telse if (M_AXI_BVALID[M]) // && mbstall\n\t\t\taxi_bready <= 0;\n\t\t// }}}\n\n\t\t//\n\t\tassign\tM_AXI_AWVALID[M]         = axi_awvalid;\n\t\tassign\tM_AXI_AWADDR[M*AW +: AW] = axi_awaddr;\n\t\tassign\tM_AXI_AWPROT[M*3 +: 3]   = axi_awprot;\n\t\t//\n\t\t//\n\t\tassign\tM_AXI_WVALID[M]             = axi_wvalid;\n\t\tassign\tM_AXI_WDATA[M*DW +: DW]     = axi_wdata;\n\t\tassign\tM_AXI_WSTRB[M*DW/8 +: DW/8] = axi_wstrb;\n\t\t//\n\t\t//\n\t\tassign\tM_AXI_BREADY[M]             = axi_bready;\n\t\t//\n`ifdef\tFORMAL\n\t\t// {{{\n\t\tif (OPT_LOWPOWER)\n\t\tbegin\n\t\t\talways @(*)\n\t\t\tif (!axi_awvalid)\n\t\t\tbegin\n\t\t\t\tassert(axi_awaddr == 0);\n\t\t\t\tassert(axi_awprot == 0);\n\t\t\tend\n\n\t\t\talways @(*)\n\t\t\tif (!axi_wvalid)\n\t\t\tbegin\n\t\t\t\tassert(axi_wdata == 0);\n\t\t\t\tassert(axi_wstrb == 0);\n\t\t\tend\n\t\tend\n\t\t// }}}\n`endif\n\t\t// }}}\n\tend endgenerate\n\n\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : READ_SLAVE_OUTPUTS\n\t\t// {{{\n\t\t// Declarations\n\t\t// {{{",
            "reg axi_arvalid;",
            "reg [C_AXI_ADDR_WIDTH-1:0]\taxi_araddr;",
            "reg [2:0]\t\t\taxi_arprot;\n\t\t//",
            "reg axi_rready;",
            "wire arstall, srstall;\n\t\t// }}}\n\t\tassign\tarstall= (M_AXI_ARVALID[M]&& !M_AXI_ARREADY[M]);\n\t\tassign\tsrstall = (S_AXI_RVALID[mrindex[M]]\n\t\t\t\t\t\t&& !S_AXI_RREADY[mrindex[M]]);\n\n\t\t// axi_arvalid\n\t\t// {{{\n\t\tinitial\taxi_arvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || !mrgrant[M])\n\t\t\taxi_arvalid <= 0;\n\t\telse if (!arstall)\n\t\tbegin\n\t\t\taxi_arvalid <= m_arvalid[mrindex[M]] && slave_raccepts[mrindex[M]];\n\t\tend\n\t\t// }}}\n\n\t\t// axi_araddr, axi_arprot\n\t\t// {{{\n\t\tinitial\taxi_araddr  = 0;\n\t\tinitial\taxi_arprot  = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\tbegin\n\t\t\taxi_araddr  <= 0;\n\t\t\taxi_arprot  <= 0;\n\t\tend else if (OPT_LOWPOWER && !mrgrant[M])\n\t\tbegin\n\t\t\taxi_araddr  <= 0;\n\t\t\taxi_arprot  <= 0;\n\t\tend else if (!arstall)\n\t\tbegin\n\t\t\tif (!OPT_LOWPOWER || (m_arvalid[mrindex[M]] && slave_raccepts[mrindex[M]]))\n\t\t\tbegin\n\t\t\t\tif (NM == 1)\n\t\t\t\tbegin\n\t\t\t\t\taxi_araddr  <= m_araddr[0];\n\t\t\t\t\taxi_arprot  <= m_arprot[0];\n\t\t\t\tend else begin\n\t\t\t\t\taxi_araddr  <= m_araddr[mrindex[M]];\n\t\t\t\t\taxi_arprot  <= m_arprot[mrindex[M]];\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\taxi_araddr  <= 0;\n\t\t\t\taxi_arprot  <= 0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\t// axi_rready\n\t\t// {{{\n\t\tinitial\taxi_rready = 1;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || !mrgrant[M])\n\t\t\taxi_rready <= 1;\n\t\telse if (!srstall)\n\t\t\taxi_rready <= 1;\n\t\telse if (M_AXI_RVALID[M] && M_AXI_RREADY[M]) // && srstall\n\t\t\taxi_rready <= 0;\n\t\t// }}}\n\n\t\t//\n\t\tassign\tM_AXI_ARVALID[M]         = axi_arvalid;\n\t\tassign\tM_AXI_ARADDR[M*AW +: AW] = axi_araddr;\n\t\tassign\tM_AXI_ARPROT[M*3 +: 3]   = axi_arprot;\n\t\t//\n\t\tassign\tM_AXI_RREADY[M]          = axi_rready;\n\t\t//\n`ifdef\tFORMAL\n\t\t// {{{\n\t\tif (OPT_LOWPOWER)\n\t\tbegin\n\t\t\talways @(*)\n\t\t\tif (!axi_arvalid)\n\t\t\tbegin\n\t\t\t\tassert(axi_araddr == 0);\n\t\t\t\tassert(axi_arprot == 0);\n\t\t\tend\n\t\tend\n\t\t// }}}\n`endif\n\t// }}}\n\tend endgenerate\n\n\t// Return values\n\tgenerate for (N=0; N<NM; N=N+1)\n\tbegin : WRITE_RETURN_CHANNEL\n\t\t// {{{",
            "reg axi_bvalid;",
            "reg [1:0]\taxi_bresp;",
            "reg i_axi_bvalid;",
            "wire [1:0]\ti_axi_bresp;",
            "wire mbstall;\n\n\t\tinitial\ti_axi_bvalid = 1'b0;\n\t\talways @(*)\n\t\tif (wgrant[N][NS])\n\t\t\ti_axi_bvalid = m_wvalid[N] && slave_waccepts[N];\n\t\telse\n\t\t\ti_axi_bvalid = m_axi_bvalid[swindex[N]];\n\n\t\tassign\ti_axi_bresp = m_axi_bresp[swindex[N]];\n\n\t\tassign\tmbstall = S_AXI_BVALID[N] && !S_AXI_BREADY[N];\n\n\t\t// r_bvalid\n\t\t// {{{\n\t\tinitial\tr_bvalid[N] = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_bvalid[N] <= 0;\n\t\telse if (mbstall && !r_bvalid[N] && !wgrant[N][NS])\n\t\t\tr_bvalid[N] <= swgrant[N] && i_axi_bvalid;\n\t\telse if (!mbstall)\n\t\t\tr_bvalid[N] <= 1'b0;\n\t\t// }}}\n\n\t\t// r_bresp\n\t\t// {{{\n\t\tinitial\tr_bresp[N] = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\t\tr_bresp[N] <= 0;\n\t\telse if (OPT_LOWPOWER && (!swgrant[N] || S_AXI_BREADY[N]))\n\t\t\tr_bresp[N] <= 0;\n\t\telse if (!r_bvalid[N])\n\t\tbegin\n\t\t\tif (!OPT_LOWPOWER ||(i_axi_bvalid && !wgrant[N][NS] && mbstall))\n\t\t\tbegin\n\t\t\t\tr_bresp[N] <= i_axi_bresp;\n\t\t\tend else\n\t\t\t\tr_bresp[N] <= 0;\n\t\tend\n\t\t// }}}\n\n\t\t// axi_bvalid\n\t\t// {{{\n\t\tinitial\taxi_bvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\taxi_bvalid <= 0;\n\t\telse if (!mbstall)\n\t\t\taxi_bvalid <= swgrant[N] && (r_bvalid[N] || i_axi_bvalid);\n\t\t// }}}\n\n\t\t// axi_bresp\n\t\t// {{{\n\t\tinitial\taxi_bresp = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\t\taxi_bresp <= 0;\n\t\telse if (OPT_LOWPOWER && !swgrant[N])\n\t\t\taxi_bresp <= 0;\n\t\telse if (!mbstall)\n\t\tbegin\n\t\t\tif (r_bvalid[N])\n\t\t\t\taxi_bresp <= r_bresp[N];\n\t\t\telse if (!OPT_LOWPOWER || i_axi_bvalid)\n\t\t\t\taxi_bresp <= i_axi_bresp;\n\t\t\telse\n\t\t\t\taxi_bresp <= 0;\n\n\t\t\tif (wgrant[N][NS] && (!OPT_LOWPOWER || i_axi_bvalid))\n\t\t\t\taxi_bresp <= INTERCONNECT_ERROR;\n\t\tend\n\t\t// }}}\n\n\t\t//\n\t\tassign\tS_AXI_BVALID[N]       = axi_bvalid;\n\t\tassign\tS_AXI_BRESP[N*2 +: 2] = axi_bresp;\n`ifdef\tFORMAL\n\t\t// {{{\n\t\talways @(*)\n\t\tif (r_bvalid[N])\n\t\t\tassert(r_bresp[N] != 2'b01);\n\t\talways @(*)\n\t\tif (swgrant[N])\n\t\t\tassert(m_axi_bready[swindex[N]] == !r_bvalid[N]);\n\t\telse\n\t\t\tassert(!r_bvalid[N]);\n\t\talways @(*)\n\t\tif (OPT_LOWPOWER && !r_bvalid[N])\n\t\t\tassert(r_bresp[N]  == 0);\n\n\t\talways @(*)\n\t\tif (OPT_LOWPOWER && !axi_bvalid)\n\t\t\tassert(axi_bresp  == 0);\n\t\t// }}}\n`endif\n\t\t// }}}\n\tend endgenerate\n\n\t// m_axi_?r* values\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tm_axi_arvalid = 0;\n\t\tm_axi_arready = 0;\n\t\tm_axi_rvalid = 0;\n\t\tm_axi_rready = 0;\n\n\t\tm_axi_arvalid[NS-1:0] = M_AXI_ARVALID;\n\t\tm_axi_arready[NS-1:0] = M_AXI_ARREADY;\n\t\tm_axi_rvalid[NS-1:0]  = M_AXI_RVALID;\n\t\tm_axi_rready[NS-1:0]  = M_AXI_RREADY;\n\tend\n\t// }}}\n\n\t// Return values\n\tgenerate for (N=0; N<NM; N=N+1)\n\tbegin : READ_RETURN_CHANNEL\n\t\t// {{{",
            "reg axi_rvalid;",
            "reg [1:0]\t\taxi_rresp;",
            "reg [DW-1:0]\taxi_rdata;",
            "wire srstall;",
            "reg i_axi_rvalid;\n\n\t\tinitial\ti_axi_rvalid = 1'b0;\n\t\talways @(*)\n\t\tif (rgrant[N][NS])\n\t\t\ti_axi_rvalid = m_arvalid[N] && slave_raccepts[N];\n\t\telse\n\t\t\ti_axi_rvalid = m_axi_rvalid[srindex[N]];\n\n\t\tassign\tsrstall = S_AXI_RVALID[N] && !S_AXI_RREADY[N];\n\n\t\tinitial\tr_rvalid[N] = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_rvalid[N] <= 0;\n\t\telse if (srstall && !r_rvalid[N])\n\t\t\tr_rvalid[N] <= srgrant[N] && !rgrant[N][NS]&&i_axi_rvalid;\n\t\telse if (!srstall)\n\t\t\tr_rvalid[N] <= 0;\n\n\t\tinitial\tr_rresp[N] = 0;\n\t\tinitial\tr_rdata[N] = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\tbegin\n\t\t\tr_rresp[N] <= 0;\n\t\t\tr_rdata[N] <= 0;\n\t\tend else if (OPT_LOWPOWER && (!srgrant[N] || S_AXI_RREADY[N]))\n\t\tbegin\n\t\t\tr_rresp[N] <= 0;\n\t\t\tr_rdata[N] <= 0;\n\t\tend else if (!r_rvalid[N])\n\t\tbegin\n\t\t\tif (!OPT_LOWPOWER || (i_axi_rvalid && !rgrant[N][NS] && srstall))\n\t\t\tbegin\n\t\t\t\tif (NS == 1)\n\t\t\t\tbegin\n\t\t\t\t\tr_rresp[N] <= m_axi_rresp[0];\n\t\t\t\t\tr_rdata[N] <= m_axi_rdata[0];\n\t\t\t\tend else begin\n\t\t\t\t\tr_rresp[N] <= m_axi_rresp[srindex[N]];\n\t\t\t\t\tr_rdata[N] <= m_axi_rdata[srindex[N]];\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tr_rresp[N] <= 0;\n\t\t\t\tr_rdata[N] <= 0;\n\t\t\tend\n\t\tend\n\n\t\tinitial\taxi_rvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\taxi_rvalid <= 0;\n\t\telse if (!srstall)\n\t\t\taxi_rvalid <= srgrant[N] && (r_rvalid[N] || i_axi_rvalid);\n\n\t\tinitial\taxi_rresp = 0;\n\t\tinitial\taxi_rdata = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\tbegin\n\t\t\taxi_rresp <= 0;\n\t\t\taxi_rdata <= 0;\n\t\tend else if (OPT_LOWPOWER && !srgrant[N])\n\t\tbegin\n\t\t\taxi_rresp <= 0;\n\t\t\taxi_rdata <= 0;\n\t\tend else if (!srstall)\n\t\tbegin\n\t\t\tif (r_rvalid[N])\n\t\t\tbegin\n\t\t\t\taxi_rresp <= r_rresp[N];\n\t\t\t\taxi_rdata <= r_rdata[N];\n\t\t\tend else if (!OPT_LOWPOWER || i_axi_rvalid)\n\t\t\tbegin\n\t\t\t\tif (NS == 1)\n\t\t\t\tbegin\n\t\t\t\t\taxi_rresp <= m_axi_rresp[0];\n\t\t\t\t\taxi_rdata <= m_axi_rdata[0];\n\t\t\t\tend else begin\n\t\t\t\t\taxi_rresp <= m_axi_rresp[srindex[N]];\n\t\t\t\t\taxi_rdata <= m_axi_rdata[srindex[N]];\n\t\t\t\tend\n\n\t\t\t\tif (rgrant[N][NS])\n\t\t\t\t\taxi_rresp <= INTERCONNECT_ERROR;\n\t\t\tend else begin\n\t\t\t\taxi_rresp <= 0;\n\t\t\t\taxi_rdata <= 0;\n\t\t\tend\n\t\tend\n\n\t\tassign\tS_AXI_RVALID[N]        = axi_rvalid;\n\t\tassign\tS_AXI_RRESP[N*2  +: 2] = axi_rresp;\n\t\tassign\tS_AXI_RDATA[N*DW +: DW]= axi_rdata;\n`ifdef\tFORMAL\n\t\t// {{{\n\t\talways @(*)\n\t\tif (r_rvalid[N])\n\t\t\tassert(r_rresp[N] != 2'b01);\n\t\talways @(*)\n\t\tif (srgrant[N] && !rgrant[N][NS])\n\t\t\tassert(m_axi_rready[srindex[N]] == !r_rvalid[N]);\n\t\telse\n\t\t\tassert(!r_rvalid[N]);\n\t\talways @(*)\n\t\tif (OPT_LOWPOWER && !r_rvalid[N])\n\t\tbegin\n\t\t\tassert(r_rresp[N] == 0);\n\t\t\tassert(r_rdata[N] == 0);\n\t\tend\n\n\t\talways @(*)\n\t\tif (OPT_LOWPOWER && !axi_rvalid)\n\t\tbegin\n\t\t\tassert(axi_rresp == 0);\n\t\t\tassert(axi_rdata == 0);\n\t\tend\n\t\t// }}}\n`endif\n\t\t// }}}\n\tend endgenerate\n\n\t// Count pending transactions\n\tgenerate for (N=0; N<NM; N=N+1)\n\tbegin : COUNT_PENDING\n\t\t// {{{",
            "reg [LGMAXBURST-1:0]\twpending, awpending, rpending,\n\t\t\t\t\t\tmissing_wdata;\n\t\t//",
            "reg rempty, awempty; // wempty;",
            "reg r_wdata_expected;\n\n\t\tinitial\tawpending    = 0;\n\t\tinitial\tswempty[N]   = 1;\n\t\tinitial\tswfull[N]    = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\tawpending     <= 0;\n\t\t\tswempty[N]    <= 1;\n\t\t\tswfull[N]     <= 0;\n\t\tend else case ({(m_awvalid[N] && slave_awaccepts[N]),\n\t\t\t\t(S_AXI_BVALID[N] && S_AXI_BREADY[N])})\n\t\t2'b01: begin\n\t\t\tawpending     <= awpending - 1;\n\t\t\tswempty[N]    <= (awpending <= 1);\n\t\t\tswfull[N]     <= 0;\n\t\t\tend\n\t\t2'b10: begin\n\t\t\tawpending <= awpending + 1;\n\t\t\tswempty[N] <= 0;\n\t\t\tswfull[N]     <= &awpending[LGMAXBURST-1:1];\n\t\t\tend\n\t\tdefault: begin end\n\t\tendcase\n\n\t\tinitial\twpending = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\twpending <= 0;\n\t\telse case ({(m_wvalid[N] && slave_waccepts[N]),\n\t\t\t\t(S_AXI_BVALID[N] && S_AXI_BREADY[N])})\n\t\t2'b01: wpending <= wpending - 1;\n\t\t2'b10: wpending <= wpending + 1;\n\t\tdefault: begin end\n\t\tendcase\n\n\t\tinitial\tmissing_wdata = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tmissing_wdata <= 0;\n\t\telse begin\n\t\t\tmissing_wdata <= missing_wdata\n\t\t\t\t+((m_awvalid[N] && slave_awaccepts[N])? 1:0)\n\t\t\t\t-((m_wvalid[N] && slave_waccepts[N])? 1:0);\n\t\tend\n\n\t\tinitial\tr_wdata_expected = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_wdata_expected <= 0;\n\t\telse case({ m_awvalid[N] && slave_awaccepts[N],\n\t\t\t\tm_wvalid[N] && slave_waccepts[N] })\n\t\t2'b10: r_wdata_expected <= 1;\n\t\t2'b01: r_wdata_expected <= (missing_wdata > 1);\n\t\tdefault: begin end\n\t\tendcase\n\n\n\t\tinitial\trpending     = 0;\n\t\tinitial\tsrempty[N]   = 1;\n\t\tinitial\tsrfull[N]    = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\trpending  <= 0;\n\t\t\tsrempty[N]<= 1;\n\t\t\tsrfull[N] <= 0;\n\t\tend else case ({(m_arvalid[N] && slave_raccepts[N]),\n\t\t\t\t(S_AXI_RVALID[N] && S_AXI_RREADY[N])})\n\t\t2'b01: begin\n\t\t\trpending      <= rpending - 1;\n\t\t\tsrempty[N]    <= (rpending == 1);\n\t\t\tsrfull[N]     <= 0;\n\t\t\tend\n\t\t2'b10: begin\n\t\t\trpending      <= rpending + 1;\n\t\t\tsrfull[N]     <= &rpending[LGMAXBURST-1:1];\n\t\t\tsrempty[N]    <= 0;\n\t\t\tend\n\t\tdefault: begin end\n\t\tendcase\n\n\t\tassign\tw_sawpending[N] = awpending;\n\t\tassign\tw_swpending[N]  = wpending;\n\t\tassign\tw_srpending[N]  = rpending;\n\n\t\tassign\twdata_expected[N] = r_wdata_expected;\n\n`ifdef\tFORMAL\n\t\t// {{{",
            "reg [LGMAXBURST-1:0]\tf_missing_wdata;\n\n\t\talways @(*)\n\t\t\tassert(missing_wdata == awpending - wpending);\n\t\talways @(*)\n\t\t\tassert(r_wdata_expected == (missing_wdata > 0));\n\t\talways @(*)\n\t\t\tassert(awpending >= wpending);\n\t\t// }}}\n`endif\n\t\t// }}}\n\tend endgenerate\n\n\t// Property validation\n\t// {{{\n\tinitial begin\n\t\tif (NM == 0) begin\n                        $display(\"At least one master must be defined\");\n                        $stop;\n                end\n\n\t\tif (NS == 0) begin\n                        $display(\"At least one slave must be defined\");\n                        $stop;\n                end\n        end\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties used to verify this core\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Local declarations\n\t// {{{",
            "localparam F_LGDEPTH = LGMAXBURST+1;",
            "wire [F_LGDEPTH-1:0]\tfm_rd_outstanding\t[0:NM-1];",
            "wire [F_LGDEPTH-1:0]\tfm_wr_outstanding\t[0:NM-1];",
            "wire [F_LGDEPTH-1:0]\tfm_awr_outstanding\t[0:NM-1];",
            "wire [F_LGDEPTH-1:0]\tfs_rd_outstanding\t[0:NS-1];",
            "wire [F_LGDEPTH-1:0]\tfs_wr_outstanding\t[0:NS-1];",
            "wire [F_LGDEPTH-1:0]\tfs_awr_outstanding\t[0:NS-1];\n\n\tinitial\tassert(NS >= 1);\n\tinitial\tassert(NM >= 1);\n\t// }}}\n\n`ifdef\tVERIFIC",
            "reg f_past_valid;\n\n\tinitial\tf_past_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\t\tf_past_valid <= 1;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Initial value checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n`ifdef\tVERIFIC\n`define\tINITIAL_CHECK\tassume\n`else\n`define\tINITIAL_CHECK\tassert\n`endif // VERIFIC\n\talways @(*)\n\tif (!f_past_valid)\n\tbegin\n\t\t`INITIAL_CHECK(!S_AXI_ARESETN);\n\t\t`INITIAL_CHECK(S_AXI_BVALID == 0);\n\t\t`INITIAL_CHECK(S_AXI_RVALID == 0);\n\t\t`INITIAL_CHECK(swgrant == 0);\n\t\t`INITIAL_CHECK(srgrant == 0);\n\t\t`INITIAL_CHECK(swfull == 0);\n\t\t`INITIAL_CHECK(srfull == 0);\n\t\t`INITIAL_CHECK(&swempty);\n\t\t`INITIAL_CHECK(&srempty);\n\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\tbegin\n\t\t\t`INITIAL_CHECK(wgrant[iN] == 0);\n\t\t\tassume(swindex[iN] == 0);\n\n\t\t\t`INITIAL_CHECK(rgrant[iN] == 0);\n\t\t\tassume(srindex[iN] == 0);\n\n\t\t\t`INITIAL_CHECK(r_bvalid[iN] == 0);\n\t\t\t`INITIAL_CHECK(r_rvalid[iN] == 0);\n\t\t\t//\n\t\t\t`INITIAL_CHECK(r_bresp[iN]  == 0);\n\t\t\t//\n\t\t\t`INITIAL_CHECK(r_rresp[iN]  == 0);\n\t\t\t`INITIAL_CHECK(r_rdata[iN]  == 0);\n\t\tend\n\n\t\t`INITIAL_CHECK(M_AXI_AWVALID == 0);\n\t\t`INITIAL_CHECK(M_AXI_WVALID == 0);\n\t\t`INITIAL_CHECK(M_AXI_RVALID == 0);\n\tend\n`endif\n\t// }}}\n\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : CHECK_MASTER_GRANTS\n\t\t// {{{\n\n\t\t////////////////////////////////////////////////////////////////\n\t\t// Write grant checks\n\t\t// {{{\n\t\talways @(*)\n\t\tfor(iM=0; iM<=NS; iM=iM+1)\n\t\tbegin\n\t\t\tif (wgrant[N][iM])\n\t\t\tbegin\n\t\t\t\tassert((wgrant[N] ^ (1<<iM))==0);\n\t\t\t\tassert(swgrant[N]);\n\t\t\t\tassert(swindex[N] == iM);\n\t\t\t\tif (iM < NS)\n\t\t\t\tbegin\n\t\t\t\t\tassert(mwgrant[iM]);\n\t\t\t\t\tassert(mwindex[iM] == N);\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\talways @(*)\n\t\tif (swgrant[N])\n\t\t\tassert(wgrant[N] != 0);\n\n\t\talways @(*)\n\t\tif (wrequest[N][NS])\n\t\t\tassert(wrequest[N][NS-1:0] == 0);\n\n\t\t// }}}\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t// Read grant checking\n\t\t// {{{\n\t\talways @(*)\n\t\tfor(iM=0; iM<=NS; iM=iM+1)\n\t\tbegin\n\t\t\tif (rgrant[N][iM])\n\t\t\tbegin\n\t\t\t\tassert((rgrant[N] ^ (1<<iM))==0);\n\t\t\t\tassert(srgrant[N]);\n\t\t\t\tassert(srindex[N] == iM);\n\t\t\t\tif (iM < NS)\n\t\t\t\tbegin\n\t\t\t\t\tassert(mrgrant[iM]);\n\t\t\t\t\tassert(mrindex[iM] == N);\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\talways @(*)\n\t\tif (srgrant[N])\n\t\t\tassert(rgrant[N] != 0);\n\n\t\talways @(*)\n\t\tif (rrequest[N][NS])\n\t\t\tassert(rrequest[N][NS-1:0] == 0);\n\t\t// }}}\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : CHECK_MASTERS\n\t\t// {{{\n\t\tfaxil_slave #(\n\t\t\t.C_AXI_DATA_WIDTH(DW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t.F_OPT_ASSUME_RESET(1'b1),\n\t\t\t.F_AXI_MAXWAIT(0),\n\t\t\t.F_AXI_MAXDELAY(0),\n\t\t\t.F_LGDEPTH(F_LGDEPTH))\n\t\t  mstri(.i_clk(S_AXI_ACLK),\n\t\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t\t//\n\t\t\t.i_axi_awvalid(S_AXI_AWVALID[N]),\n\t\t\t.i_axi_awready(S_AXI_AWREADY[N]),\n\t\t\t.i_axi_awaddr(S_AXI_AWADDR[N*AW +: AW]),\n\t\t\t.i_axi_awprot(S_AXI_AWPROT[N*3 +: 3]),\n\t\t\t//\n\t\t\t.i_axi_wvalid(S_AXI_WVALID[N]),\n\t\t\t.i_axi_wready(S_AXI_WREADY[N]),\n\t\t\t.i_axi_wdata( S_AXI_WDATA[N*DW +: DW]),\n\t\t\t.i_axi_wstrb( S_AXI_WSTRB[N*DW/8 +: DW/8]),\n\t\t\t//\n\t\t\t.i_axi_bvalid(S_AXI_BVALID[N]),\n\t\t\t.i_axi_bready(S_AXI_BREADY[N]),\n\t\t\t.i_axi_bresp( S_AXI_BRESP[N*2 +: 2]),\n\t\t\t//\n\t\t\t.i_axi_arvalid(S_AXI_ARVALID[N]),\n\t\t\t.i_axi_arready(S_AXI_ARREADY[N]),\n\t\t\t.i_axi_araddr( S_AXI_ARADDR[N*AW +: AW]),\n\t\t\t.i_axi_arprot( S_AXI_ARPROT[N*3 +: 3]),\n\t\t\t//\n\t\t\t//\n\t\t\t.i_axi_rvalid(S_AXI_RVALID[N]),\n\t\t\t.i_axi_rready(S_AXI_RREADY[N]),\n\t\t\t.i_axi_rdata( S_AXI_RDATA[N*DW +: DW]),\n\t\t\t.i_axi_rresp( S_AXI_RRESP[N*2 +: 2]),\n\t\t\t//\n\t\t\t.f_axi_rd_outstanding( fm_rd_outstanding[N]),\n\t\t\t.f_axi_wr_outstanding( fm_wr_outstanding[N]),\n\t\t\t.f_axi_awr_outstanding(fm_awr_outstanding[N]));\n\n\t\t//\n\t\t// Check write counters\n\t\t//\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\tassert(fm_awr_outstanding[N] == { 1'b0, w_sawpending[N] }\n\t\t\t\t+((OPT_BUFFER_DECODER & dcd_awvalid[N]) ? 1:0)\n\t\t\t\t+ (S_AXI_AWREADY[N] ? 0:1));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\tassert(fm_wr_outstanding[N] == { 1'b0, w_swpending[N] }\n\t\t\t\t+ (S_AXI_WREADY[N] ? 0:1));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\t\tassert(fm_awr_outstanding[N] >=\n\t\t\t\t(S_AXI_AWREADY[N] ? 0:1)\n\t\t\t\t+((OPT_BUFFER_DECODER & dcd_awvalid[N]) ? 1:0)\n\t\t\t\t+ (S_AXI_BVALID[N]  ? 1:0));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\t\tassert(fm_wr_outstanding[N] >=\n\t\t\t\t(S_AXI_WREADY[N] ? 0:1)\n\t\t\t\t+ (S_AXI_BVALID[N]? 1:0));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\tassert(fm_wr_outstanding[N]-(S_AXI_WREADY[N] ? 0:1)\n\t\t\t<= fm_awr_outstanding[N]-(S_AXI_AWREADY[N] ? 0:1));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && wgrant[N][NS])\n\t\t\tassert(fm_wr_outstanding[N] == (S_AXI_WREADY[N] ? 0:1)\n\t\t\t\t+ (S_AXI_BVALID[N] ? 1:0));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !swgrant[N])\n\t\tbegin\n\t\t\tassert(!S_AXI_BVALID[N]);\n\n\t\t\tassert(fm_awr_outstanding[N]==(S_AXI_AWREADY[N] ? 0:1)\n\t\t\t\t+((OPT_BUFFER_DECODER & dcd_awvalid[N]) ? 1:0));\n\t\t\tassert(fm_wr_outstanding[N] == (S_AXI_WREADY[N] ? 0:1));\n\t\t\tassert(w_sawpending[N] == 0);\n\t\t\tassert(w_swpending[N] == 0);\n\t\tend\n\n\n\t\t//\n\t\t// Check read counters\n\t\t//\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\t\tassert(fm_rd_outstanding[N] >=\n\t\t\t\t(S_AXI_ARREADY[N] ? 0:1)\n\t\t\t\t+(S_AXI_RVALID[N] ? 1:0));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && (!srgrant[N] || rgrant[N][NS]))\n\t\t\tassert(fm_rd_outstanding[N] ==\n\t\t\t\t(S_AXI_ARREADY[N] ? 0:1)\n\t\t\t\t+((OPT_BUFFER_DECODER & dcd_arvalid[N]) ? 1:0)\n\t\t\t\t+(S_AXI_RVALID[N] ? 1:0));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\t\tassert(fm_rd_outstanding[N] == { 1'b0, w_srpending[N] }\n\t\t\t\t+((OPT_BUFFER_DECODER & dcd_arvalid[N]) ? 1:0)\n\t\t\t\t+ (S_AXI_ARREADY[N] ? 0:1));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && rgrant[N][NS])\n\t\t\tassert(fm_rd_outstanding[N] == (S_AXI_ARREADY[N] ? 0:1)\n\t\t\t\t+((OPT_BUFFER_DECODER & dcd_arvalid[N]) ? 1:0)\n\t\t\t\t+(S_AXI_RVALID[N] ? 1:0));\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && !srgrant[N])\n\t\tbegin\n\t\t\tassert(!S_AXI_RVALID[N]);\n\t\t\tassert(fm_rd_outstanding[N]== (S_AXI_ARREADY[N] ? 0:1)\n\t\t\t\t+((OPT_BUFFER_DECODER && dcd_arvalid[N])? 1:0));\n\t\t\tassert(w_srpending[N] == 0);\n\t\tend\n\n\t\t//\n\t\t// Check full/empty flags\n\t\t//",
            "localparam [LGMAXBURST-1:0] NEAR_THRESHOLD = -2;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tassert(swfull[N] == &w_sawpending[N]);\n\t\t\tassert(swempty[N] == (w_sawpending[N] == 0));\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tassert(srfull[N] == &w_srpending[N]);\n\t\t\tassert(srempty[N] == (w_srpending[N] == 0));\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : CHECK_SLAVES\n\t\t// {{{\n\t\tfaxil_master #(\n\t\t\t.C_AXI_DATA_WIDTH(DW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t.F_OPT_ASSUME_RESET(1'b1),\n\t\t\t.F_AXI_MAXRSTALL(0),\n\t\t\t.F_LGDEPTH(F_LGDEPTH))\n\t\t  slvi(.i_clk(S_AXI_ACLK),\n\t\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t\t//\n\t\t\t.i_axi_awvalid(M_AXI_AWVALID[M]),\n\t\t\t.i_axi_awready(M_AXI_AWREADY[M]),\n\t\t\t.i_axi_awaddr(M_AXI_AWADDR[M*AW +: AW]),\n\t\t\t.i_axi_awprot(M_AXI_AWPROT[M*3 +: 3]),\n\t\t\t//\n\t\t\t.i_axi_wvalid(M_AXI_WVALID[M]),\n\t\t\t.i_axi_wready(M_AXI_WREADY[M]),\n\t\t\t.i_axi_wdata( M_AXI_WDATA[M*DW +: DW]),\n\t\t\t.i_axi_wstrb( M_AXI_WSTRB[M*DW/8 +: DW/8]),\n\t\t\t//\n\t\t\t.i_axi_bvalid(M_AXI_BVALID[M]),\n\t\t\t.i_axi_bready(M_AXI_BREADY[M]),\n\t\t\t.i_axi_bresp( M_AXI_BRESP[M*2 +: 2]),\n\t\t\t//\n\t\t\t.i_axi_arvalid(M_AXI_ARVALID[M]),\n\t\t\t.i_axi_arready(M_AXI_ARREADY[M]),\n\t\t\t.i_axi_araddr( M_AXI_ARADDR[M*AW +: AW]),\n\t\t\t.i_axi_arprot( M_AXI_ARPROT[M*3 +: 3]),\n\t\t\t//\n\t\t\t//\n\t\t\t.i_axi_rvalid(M_AXI_RVALID[M]),\n\t\t\t.i_axi_rready(M_AXI_RREADY[M]),\n\t\t\t.i_axi_rdata( M_AXI_RDATA[M*DW +: DW]),\n\t\t\t.i_axi_rresp( M_AXI_RRESP[M*2 +: 2]),\n\t\t\t//\n\t\t\t.f_axi_rd_outstanding( fs_rd_outstanding[M]),\n\t\t\t.f_axi_wr_outstanding( fs_wr_outstanding[M]),\n\t\t\t.f_axi_awr_outstanding(fs_awr_outstanding[M]));\n\n\t\talways @(*)\n\t\tassert(fs_wr_outstanding[M] + (M_AXI_WVALID[M] ? 1:0)\n\t\t\t<= fs_awr_outstanding[M] + (M_AXI_AWVALID[M]? 1:0));\n\n\t\talways @(*)\n\t\tif (!mwgrant[M])\n\t\tbegin\n\t\t\tassert(fs_awr_outstanding[M] == 0);\n\t\t\tassert(fs_wr_outstanding[M] == 0);\n\t\tend\n\n\t\talways @(*)\n\t\tif (!mrgrant[M])\n\t\t\tassert(fs_rd_outstanding[M] == 0);\n\n\t\talways @(*)\n\t\t\tassert(fs_awr_outstanding[M] < { 1'b1, {(F_LGDEPTH-1){1'b0}} });\n\t\talways @(*)\n\t\t\tassert(fs_wr_outstanding[M] < { 1'b1, {(F_LGDEPTH-1){1'b0}} });\n\t\talways @(*)\n\t\t\tassert(fs_rd_outstanding[M] < { 1'b1, {(F_LGDEPTH-1){1'b0}} });\n\n\t\talways @(*)\n\t\tif (M_AXI_AWVALID[M])\n\t\t\tassert(((M_AXI_AWADDR[M*AW +: AW]\n\t\t\t\t^ SLAVE_ADDR[M*AW +: AW])\n\t\t\t\t& SLAVE_MASK[M*AW +: AW]) == 0);\n\n\t\talways @(*)\n\t\tif (M_AXI_ARVALID[M])\n\t\t\tassert(((M_AXI_ARADDR[M*AW +: AW]\n\t\t\t\t^ SLAVE_ADDR[M*AW +: AW])\n\t\t\t\t& SLAVE_MASK[M*AW +: AW]) == 0);\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : CORRELATE_OUTSTANDING\n\t\t// {{{\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN && (swgrant[N] && (swindex[N] < NS)))\n\t\tbegin\n\t\t\tassert((fm_awr_outstanding[N]\n\t\t\t\t- (S_AXI_AWREADY[N] ? 0:1)\n\t\t\t\t-((OPT_BUFFER_DECODER && dcd_awvalid[N]) ? 1:0)\n\t\t\t\t- (S_AXI_BVALID[N]  ? 1:0))\n\t\t\t\t== (fs_awr_outstanding[swindex[N]]\n\t\t\t\t\t+ (m_axi_awvalid[swindex[N]] ? 1:0)\n\t\t\t\t\t+ (m_axi_bready[swindex[N]] ? 0:1)));\n\n\t\t\tassert((fm_wr_outstanding[N]\n\t\t\t\t- (S_AXI_WREADY[N] ? 0:1)\n\t\t\t\t- (S_AXI_BVALID[N] ? 1:0))\n\t\t\t\t== (fs_wr_outstanding[swindex[N]]\n\t\t\t\t\t+ (m_axi_wvalid[swindex[N]] ? 1:0)\n\t\t\t\t\t+ (m_axi_bready[swindex[N]] ? 0:1)));\n\n\t\tend else if (S_AXI_ARESETN && (!swgrant[N] || (swindex[N]==NS)))\n\t\tbegin\n\t\t\tif (!swgrant[N])\n\t\t\t\tassert(fm_awr_outstanding[N] ==\n\t\t\t\t\t(S_AXI_AWREADY[N] ? 0:1)\n\t\t\t\t\t+((OPT_BUFFER_DECODER && dcd_awvalid[N]) ? 1:0)\n\t\t\t\t\t+(S_AXI_BVALID[N]  ? 1:0));\n\t\t\telse\n\t\t\t\tassert(fm_awr_outstanding[N] >=\n\t\t\t\t\t(S_AXI_AWREADY[N] ? 0:1)\n\t\t\t\t\t+((OPT_BUFFER_DECODER && dcd_awvalid[N]) ? 1:0)\n\t\t\t\t\t+(S_AXI_BVALID[N]  ? 1:0));\n\n\t\t\tassert(fm_wr_outstanding[N]  ==\n\t\t\t\t\t(S_AXI_WREADY[N]  ? 0:1)\n\t\t\t\t\t+(S_AXI_BVALID[N]  ? 1:0));\n\t\tend\n\n\t\talways @(*)\n\t\tif (srgrant[N] && (srindex[N] < NS))\n\t\tbegin\n\t\t\tassert((fm_rd_outstanding[N]//17\n\t\t\t\t- (S_AXI_ARREADY[N] ? 0:1)//1\n\t\t\t\t-((OPT_BUFFER_DECODER && dcd_arvalid[N]) ? 1:0)\n\t\t\t\t- (S_AXI_RVALID[N] ? 1:0))//0\n\t\t\t\t== (fs_rd_outstanding[srindex[N]]//16\n\t\t\t\t\t+ (m_axi_arvalid[srindex[N]] ? 1:0)//0\n\t\t\t\t\t+ (m_axi_rready[srindex[N]] ? 0:1)));//0\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// Can every master reach every slave?\n\t// Can things transition without dropping the request line(s)?\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : COVER_CONNECTIVITY_FROM_MASTER",
            "reg [3:0]\tw_returns, r_returns;",
            "reg err_wr_return, err_rd_return;",
            "reg [NS-1:0]\tw_every, r_every;",
            "reg was_wevery, was_revery, whsreturn, rhsreturn;\n\n\t\t// w_returns is a speed check: Can we return one write\n\t\t// acknowledgement per clock cycle?\n\t\tinitial\tw_returns = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tw_returns = 0;\n\t\telse begin\n\t\t\tw_returns <= { w_returns[2:0], 1'b0 };\n\t\t\tif (S_AXI_BVALID[N] && S_AXI_BREADY[N] && !wgrant[N][NS])\n\t\t\t\tw_returns[0] <= 1'b1;\n\t\tend\n\n\t\tinitial\twhsreturn = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\twhsreturn <= 0;\n\t\telse\n\t\t\twhsreturn <= whsreturn || (&w_returns);\n\n\t\t// w_every is a connectivity test: Can we get a return from\n\t\t// every slave?\n\t\tinitial\tw_every = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tw_every <= 0;\n\t\telse if (!S_AXI_AWVALID[N])\n\t\t\tw_every <= 0;\n\t\telse begin\n\t\t\tif (S_AXI_BVALID[N] && S_AXI_BREADY[N] && !wgrant[N][NS])\n\t\t\t\tw_every[swindex[N]] <= 1'b1;\n\t\tend\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (S_AXI_BVALID[N])\n\t\t\tassert($stable(swindex[N]));\n\n\t\tinitial\twas_wevery = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\twas_wevery <= 0;\n\t\telse\n\t\t\twas_wevery <= was_wevery || (&w_every);\n\n\t\t// err_wr_return is a test to make certain we can return a\n\t\t// bus error on the write channel.\n\t\tinitial\terr_wr_return = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\terr_wr_return = 0;\n\t\telse if (wgrant[N][NS] && S_AXI_BVALID[N]\n\t\t\t\t&& (S_AXI_BRESP[2*N+:2]==INTERCONNECT_ERROR))\n\t\t\terr_wr_return = 1;\n\n`ifndef\tVERILATOR\n\t\talways @(*)\n\t\t\tcover(!swgrant[N] && whsreturn);\n\t\talways @(*)\n\t\t\tcover(!swgrant[N] && was_wevery);\n\n\t\talways @(*)\n\t\t\tcover(S_AXI_ARESETN && wrequest[N][NS]);\n\t\talways @(*)\n\t\t\tcover(S_AXI_ARESETN && wrequest[N][NS] && slave_awaccepts[N]);\n\t\talways @(*)\n\t\t\tcover(err_wr_return);\n\t\talways @(*)\n\t\t\tcover(!swgrant[N] && err_wr_return);\n`endif\n\n\t\talways @(*)\n\t\tif (S_AXI_BVALID[N])\n\t\t\tassert(swgrant[N]);\n\n\t\t// r_returns is a speed check: Can we return one read\n\t\t// acknowledgment per clock cycle?\n\t\tinitial\tr_returns = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_returns = 0;\n\t\telse begin\n\t\t\tr_returns <= { r_returns[2:0], 1'b0 };\n\t\t\tif (S_AXI_RVALID[N] && S_AXI_RREADY[N])\n\t\t\t\tr_returns[0] <= 1'b1;\n\t\tend\n\n\t\tinitial\trhsreturn = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\trhsreturn <= 0;\n\t\telse\n\t\t\trhsreturn <= rhsreturn || (&r_returns);\n\n\n\t\t// r_every is a connectivity test: Can we get a read return from\n\t\t// every slave?\n\t\tinitial\tr_every = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_every = 0;\n\t\telse if (!S_AXI_ARVALID[N])\n\t\t\tr_every = 0;\n\t\telse begin\n\t\t\tif (S_AXI_RVALID[N] && S_AXI_RREADY[N])\n\t\t\t\tr_every[srindex[N]] <= 1'b1;\n\t\tend\n\n\t\t// was_revery is a return to idle check following the\n\t\t// connectivity test.  Since the connectivity test is cleared\n\t\t// if there's ever a drop in the valid line, we need a separate\n\t\t//",
            "wire to check that this master can return to idle again.\n\t\tinitial\twas_revery = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\twas_revery <= 0;\n\t\telse\n\t\t\twas_revery <= was_revery || (&r_every);\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (S_AXI_RVALID[N])\n\t\t\tassert($stable(srindex[N]));\n\n\t\tinitial\terr_rd_return = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\terr_rd_return = 0;\n\t\telse if (rgrant[N][NS] && S_AXI_RVALID[N]\n\t\t\t\t&& (S_AXI_RRESP[2*N+:2]==INTERCONNECT_ERROR))\n\t\t\terr_rd_return = 1;\n\n`ifndef\tVERILATOR\n\t\talways @(*)\n\t\t\tcover(!srgrant[N] && rhsreturn);\t// @26\n\t\talways @(*)\n\t\t\tcover(!srgrant[N] && was_revery);\t// @26\n\n\t\talways @(*)\n\t\t\tcover(S_AXI_ARVALID[N] && rrequest[N][NS]);\n\t\talways @(*)\n\t\t\tcover(rgrant[N][NS]);\n\t\talways @(*)\n\t\t\tcover(err_rd_return);\n\t\talways @(*)\n\t\t\tcover(!srgrant[N] && err_rd_return); //@!\n`endif\n\n\t\talways @(*)\n\t\tif (S_AXI_BVALID[N] && wgrant[N][NS])\n\t\t\tassert(S_AXI_BRESP[2*N+:2]==INTERCONNECT_ERROR);\n\t\talways @(*)\n\t\tif (S_AXI_RVALID[N] && rgrant[N][NS])\n\t\t\tassert(S_AXI_RRESP[2*N+:2]==INTERCONNECT_ERROR);\n\tend endgenerate",
            "reg multi_write_hit, multi_read_hit;\n\n\tinitial\tmulti_write_hit = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tmulti_write_hit <= 0;\n\telse if (fm_awr_outstanding[0] > 2 && !wgrant[0][NS])\n\t\tmulti_write_hit <= 1;\n\n\tinitial\tmulti_read_hit = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tmulti_read_hit <= 0;\n\telse if (fm_rd_outstanding[0] > 2 && !rgrant[0][NS])\n\t\tmulti_read_hit <= 1;\n\n\talways @(*)\n\t\tcover(multi_write_hit);\n\n\talways @(*)\n\t\tcover(multi_read_hit);\n\n\talways @(*)\n\t\tcover(S_AXI_ARESETN && multi_write_hit & mwgrant == 0 && M_AXI_BVALID == 0);\n\n\talways @(*)\n\t\tcover(S_AXI_ARESETN && multi_read_hit & mrgrant == 0 && M_AXI_RVALID == 0);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Negation check\n\t// {{{\n\t// Pick a particular value.  Assume the value doesn't show up on the\n\t//",
            "input .  Prove it doesn't show up on the",
            "output .  This will check for\n\t// ...\n\t// 1. Stuck bits on the",
            "output channel\n\t// 2. Cross-talk between channels\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t(* anyconst *)",
            "reg [LGNM-1:0]\tf_const_source;\n\t(* anyconst *)",
            "reg [AW-1:0]\tf_const_addr;\n\t(* anyconst *)",
            "reg [AW-1:0]\tf_const_addr_n;\n\t(* anyconst *)",
            "reg [DW-1:0]\tf_const_data_n;\n\t(* anyconst *)",
            "reg [DW/8-1:0]\tf_const_strb_n;\n\t(* anyconst *)",
            "reg [3-1:0]\t\tf_const_prot_n;\n\t(* anyconst *)",
            "reg [2-1:0]\t\tf_const_resp_n;",
            "reg [LGNS-1:0]\tf_const_slave;\n\n\talways @(*)\n\t\tassume(f_const_source < NM);\n\talways @(*)\n\tbegin\n\t\tf_const_slave = NS;\n\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\tbegin\n\t\t\tif (((f_const_addr ^ SLAVE_ADDR[iM*AW+:AW])\n\t\t\t\t\t&SLAVE_MASK[iM*AW+:AW])==0)\n\t\t\t\tf_const_slave = iM;\n\t\tend\n\n\t\tassume(f_const_slave < NS);\n\tend",
            "reg [AW-1:0]\tf_awaddr;",
            "reg [AW-1:0]\tf_araddr;\n\talways @(*)\n\t\tf_awaddr = S_AXI_AWADDR[f_const_source * AW +: AW];\n\talways @(*)\n\t\tf_araddr = S_AXI_ARADDR[f_const_source * AW +: AW];\n\n\t// The assumption check: assume our negated values are not found on\n\t// the",
            "input s\n\talways @(*)\n\tbegin\n\t\tif (S_AXI_AWVALID[f_const_source])\n\t\tbegin\n\t\t\tassume(f_awaddr != f_const_addr_n);\n\t\t\tassume(S_AXI_AWPROT[f_const_source*3+:3] != f_const_prot_n);\n\t\tend\n\t\tif (m_wvalid)\n\t\tbegin\n\t\t\tassume(m_wdata[f_const_source] != f_const_data_n);\n\t\t\tassume(m_wstrb[f_const_source] != f_const_strb_n);\n\t\tend\n\t\tif (S_AXI_ARVALID[f_const_source])\n\t\tbegin\n\t\t\tassume(f_araddr != f_const_addr_n);\n\t\t\tassume(S_AXI_ARPROT[f_const_source*3+:3] != f_const_prot_n);\n\t\tend\n\n\t\tif (M_AXI_BVALID[f_const_slave] && wgrant[f_const_source][f_const_slave])\n\t\tbegin\n\t\t\tassume(m_axi_bresp[f_const_slave] != f_const_resp_n);\n\t\tend\n\n\t\tif (M_AXI_RVALID[f_const_slave] && rgrant[f_const_source][f_const_slave])\n\t\tbegin\n\t\t\tassume(m_axi_rdata[f_const_slave] != f_const_data_n);\n\t\t\tassume(m_axi_rresp[f_const_slave] != f_const_resp_n);\n\t\tend\n\tend\n\n\t// Proof check: Prove these values are not found on our",
            "output s\n\talways @(*)\n\tbegin\n\t\tif (skd_awvalid[f_const_source])\n\t\tbegin\n\t\t\tassert(skd_awaddr[f_const_source] != f_const_addr_n);\n\t\t\tassert(skd_awprot[f_const_source] != f_const_prot_n);\n\t\tend\n\t\tif (dcd_awvalid[f_const_source])\n\t\tbegin\n\t\t\tassert(m_awaddr[f_const_source] != f_const_addr_n);\n\t\t\tassert(m_awprot[f_const_source] != f_const_prot_n);\n\t\tend\n\t\tif (M_AXI_AWVALID[f_const_slave] && wgrant[f_const_source][f_const_slave])\n\t\tbegin\n\t\t\tassert(M_AXI_AWADDR[f_const_slave*AW+:AW] != f_const_addr_n);\n\t\t\tassert(M_AXI_AWPROT[f_const_slave*3+:3] != f_const_prot_n);\n\t\tend\n\t\tif (M_AXI_WVALID[f_const_slave] && wgrant[f_const_source][f_const_slave])\n\t\tbegin\n\t\t\tassert(M_AXI_WDATA[f_const_slave*DW+:DW] != f_const_data_n);\n\t\t\tassert(M_AXI_WSTRB[f_const_slave*(DW/8)+:(DW/8)] != f_const_strb_n);\n\t\tend\n\t\tif (skd_arvalid[f_const_source])\n\t\tbegin\n\t\t\tassert(skd_araddr[f_const_source] != f_const_addr_n);\n\t\t\tassert(skd_arprot[f_const_source] != f_const_prot_n);\n\t\tend\n\t\tif (dcd_arvalid[f_const_source])\n\t\tbegin\n\t\t\tassert(m_araddr[f_const_source] != f_const_addr_n);\n\t\t\tassert(m_arprot[f_const_source] != f_const_prot_n);\n\t\tend\n\t\tif (M_AXI_ARVALID[f_const_slave] && rgrant[f_const_source][f_const_slave])\n\t\tbegin\n\t\t\tassert(M_AXI_ARADDR[f_const_slave*AW+:AW] != f_const_addr_n);\n\t\t\tassert(M_AXI_ARPROT[f_const_slave*3+:3] != f_const_prot_n);\n\t\tend\n\t\t//\n\t\tif (r_bvalid[f_const_source] && wgrant[f_const_source][f_const_slave])\n\t\t\tassert(r_bresp[f_const_source] != f_const_resp_n);\n\t\tif (S_AXI_BVALID[f_const_source] && wgrant[f_const_source][f_const_slave])\n\t\t\tassert(S_AXI_BRESP[f_const_source*2+:2] != f_const_resp_n);\n\t\tif (r_rvalid[f_const_source] && rgrant[f_const_source][f_const_slave])\n\t\tbegin\n\t\t\tassert(r_rresp[f_const_source] != f_const_resp_n);\n\t\t\tassert(r_rdata[f_const_source] != f_const_data_n);\n\t\tend\n\t\tif (S_AXI_RVALID[f_const_source] && rgrant[f_const_source][f_const_slave])\n\t\tbegin\n\t\t\tassert(S_AXI_RRESP[f_const_source*2+:2]!=f_const_resp_n);\n\t\t\tassert(S_AXI_RDATA[f_const_source*DW+:DW]!=f_const_data_n);\n\t\tend\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Careless) constraining assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin\n\n\tend endgenerate\n\t// }}}\n`endif\n// }}}",
            "endmodule `ifndef\tYOSYS\n`default_nettype",
            "wire `endif"
        ]
    },
    {
        "file_name": "zipdma_check.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/zipdma_check.v",
        "chunks": [
            "module zipdma_check #(",
            "parameter ADDRESS_WIDTH = 30,",
            "parameter BUS_WIDTH = 64\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t// High-speed, high width Wishbone test/data port\n\t\t// {{{",
            "input ",
            "wire i_wb_cyc, i_wb_stb,",
            "input ",
            "wire i_wb_we,",
            "input ",
            "wire [AW-1:0]\ti_wb_addr,",
            "input ",
            "wire [DW-1:0]\ti_wb_data,",
            "input ",
            "wire [DW/8-1:0]\ti_wb_sel,\n\t\t//\n\t\t// verilator coverage_off",
            "output ",
            "wire o_wb_stall,\n\t\t// verilator coverage_on",
            "output ",
            "reg o_wb_ack,",
            "output ",
            "wire [DW-1:0]\to_wb_data,\n\t\t// verilator coverage_off",
            "output ",
            "wire o_wb_err,\n\t\t// verilator coverage_on\n\t\t// }}}\n\t\t// Wishbone status port\n\t\t// {{{",
            "input ",
            "wire i_st_cyc, i_st_stb,",
            "input ",
            "wire i_st_we,",
            "input ",
            "wire i_st_addr,",
            "input ",
            "wire [31:0]\ti_st_data,",
            "input ",
            "wire [3:0]\ti_st_sel,\n\t\t//\n\t\t// verilator coverage_off",
            "output ",
            "wire o_st_stall,\n\t\t// verilator coverage_on",
            "output ",
            "reg o_st_ack,",
            "output ",
            "reg [31:0]\to_st_data,\n\t\t// verilator coverage_off",
            "output ",
            "wire o_st_err\n\t\t// verilator coverage_on\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "localparam DW = BUS_WIDTH;",
            "localparam AW = ADDRESS_WIDTH-$clog2(DW/8);",
            "localparam BW = DW/8;   // BIT_WIDTH",
            "reg [DW-1:0]\tlfsr_state;",
            "wire rd_data_en, wr_data_en;",
            "reg [11:0]\trd_count, wr_count;",
            "reg [11:0]\trd_count_",
            "reg , wr_count_",
            "reg ;\n\t// }}}\n\n\t// rd_data_en, wr_data_en\n\tassign rd_data_en = i_wb_stb && !i_wb_we && (i_wb_sel != 0);\n\tassign wr_data_en = i_wb_stb &&  i_wb_we && (i_wb_sel != 0);\n\n\t// Wishbone",
            "output s\n\tassign o_wb_stall = 1'b0;\n\tassign o_wb_err   = 1'b0;\n\tassign o_wb_data  = lfsr_state;\n\n\tassign o_st_stall = 1'b0;\n\tassign o_st_err   = 1'b0;\n\n\t// o_st_ack\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_st_ack <= 1'b0;\n\telse\n\t\to_st_ack <= i_st_stb;\n\n\t// lfsr_state\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tlfsr_state <= 0; // initial state\n\telse begin\n\t\tif (i_st_stb && i_st_we && (i_st_sel != 0))\n\t\tbegin // set an initial per-test state\n\t\t\tlfsr_state <= 0;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\tif (i_st_sel[i])\n\t\t\t\tlfsr_state[(DW-32) + (i*8) +: 8] <= i_st_data[(i*8) +: 8];\n\t\tend\n\n\t\t// feedback\n\t\tif (rd_data_en)\n\t\t\tlfsr_state <= {lfsr_state[DW-2:0], lfsr_state[DW-1] ^ lfsr_state[DW-2]};\n\tend\n\t// }}}\n\n\t// o_wb_ack\n\t// {{{\n\tinitial\to_wb_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_wb_ack <= 0;\n\telse\n\t\to_wb_ack <= i_wb_stb && !o_wb_stall;\n\t// }}}\n\n\t// rd_count, wr_count\n\t// {{{\n\talways @(*)\n\tbegin\n\t\trd_count = rd_count_",
            "reg ;\n\t\twr_count = wr_count_",
            "reg ;\n\n\t\t// reset counter after lfsr initialization\n\t\tif (i_st_stb && i_st_we && (i_st_sel != 0))\n\t\tbegin\n\t\t\trd_count = 0;\n\t\t\twr_count = 0;\n\t\tend else for (int i = 0; i < BW; i++)\n\t\tif (i_wb_sel[i])\n\t\tbegin\n\t\t\trd_count = rd_count + (rd_data_en ? 1 : 0);\n\t\t\twr_count = wr_count + (wr_data_en ? 1 : 0);\n\t\tend\n\tend\n\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\trd_count_",
            "reg <= 0;\n\t\twr_count_",
            "reg <= 0;\n\tend else begin\n\t\trd_count_",
            "reg <= rd_count;\n\t\twr_count_",
            "reg <= wr_count;\n\tend\n\t// }}}\n\n\t// o_st_data: Error detect\u0131on (might need more error flags)\n\t// {{{\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_st_data <= 32'b0;\n\telse begin\n\t\to_st_data[15:4]  <= rd_count;\n\t\to_st_data[31:20] <= wr_count;\n\n\t\tfor (int i = 0; i < BW; i++)\n\t\tif (wr_data_en && i_wb_sel[i])\n\t\tbegin\n\t\t\tif (i_wb_data[(i*8)+:8] != lfsr_state[(i*8)+:8])\n\t\t\t\to_st_data[0] <= 1'b1;\n\t\t\telse\n\t\t\t\to_st_data[0] <= 1'b0;\n\t\tend\n\n\t\tif (i_st_stb && i_st_we)\n\t\t\to_st_data[0] <= 1'b0;\n\tend\n\t// }}}\n\n\t// Keep Verilator happy\n\t// {{{\n\t// verilator coverage_off\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, i_wb_cyc, i_st_cyc, i_st_addr, i_wb_addr };\n\t// verilator lint_on UNUSED\n\t// verilator coverage_on\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "wbxbar.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/wbxbar.v",
        "chunks": [
            "input ports) and the number of slaves respectively.  You'll then\n//\twant to set the addresses for the slaves in the SLAVE_ADDR array,\n//\ttogether with the SLAVE_MASK array indicating which SLAVE_ADDRs\n//\tare valid.  Address and data widths should be adjusted at the same\n//\ttime.\n//\n//\tVoila, you are now set up!\n//\n//\tNow let's fine tune this:\n//\n//\tLGMAXBURST can be set to control the maximum number of outstanding\n//\ttransactions.  An LGMAXBURST of 6 will allow 63 outstanding\n//\ttransactions.\n//\n//\tOPT_TIMEOUT, if set to a non-zero value, is a number of clock periods\n//\tto wait for a slave to respond.  Should the timeout expire and the\n//\tslave not respond, a bus error will be returned and the slave will\n//\tbe issued a bus abort signal (CYC will be dropped).\n//\n//\tOPT_STARVATION_TIMEOUT, if set, applies the OPT_TIMEOUT counter to\n//\thow long a particular master waits for arbitration.  If the master is\n//\t\"starved\", a bus error will be returned.\n//\n//\tOPT_DBLBUFFER is used to increase clock speed by",
            "reg istering all\n//",
            "output s.\n//\n//\tOPT_LOWPOWER is an experimental feature that, if set, will cause any\n//\tunused FFs to be set to zero rather than flopping in the electronic\n//\twind, in an effort to minimize transitions over bus",
            "wire s.  This will\n//\tcost some extra",
            "logic , for ... an uncertain power savings.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2019-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype none\n// }}}",
            "module wbxbar #(\n\t\t// i_sstall, i_sack, i_sdata, i_serr);\n\t\t// {{{",
            "parameter NM = 4, NS=8,",
            "parameter AW = 32, DW=32,",
            "parameter [NS*AW-1:0]\tSLAVE_ADDR = {\n\t\t\t\t{ 3'b111, {(AW-3){1'b0}} },\n\t\t\t\t{ 3'b110, {(AW-3){1'b0}} },\n\t\t\t\t{ 3'b101, {(AW-3){1'b0}} },\n\t\t\t\t{ 3'b100, {(AW-3){1'b0}} },\n\t\t\t\t{ 3'b011, {(AW-3){1'b0}} },\n\t\t\t\t{ 3'b010, {(AW-3){1'b0}} },\n\t\t\t\t{ 4'b0010, {(AW-4){1'b0}} },\n\t\t\t\t{ 4'b0000, {(AW-4){1'b0}} } },",
            "parameter [NS*AW-1:0]\tSLAVE_MASK = (NS <= 1) ? 0\n\t\t\t: { {(NS-2){ 3'b111, {(AW-3){1'b0}} }},\n\t\t\t\t{(2){ 4'b1111, {(AW-4){1'b0}} }} },\n\t\t//\n\t\t// LGMAXBURST is the log_2 of the length of the longest burst\n\t\t// that might be seen.  It's used to set the size of the\n\t\t// internal counters that are used to make certain that the\n\t\t// cross bar doesn't switch while still waiting on a response.",
            "parameter LGMAXBURST=6,\n\t\t//\n\t\t// OPT_TIMEOUT is used to help recover from a misbehaving slave.\n\t\t// If set, this value will determine the number of clock cycles\n\t\t// to wait for a misbehaving slave before returning a bus error.\n\t\t// Alternatively, if set to zero, this functionality will be\n\t\t// removed.",
            "parameter OPT_TIMEOUT = 0, // 1023;\n\t\t//\n\t\t// If OPT_TIMEOUT is set, then OPT_STARVATION_TIMEOUT may also\n\t\t// be set.  The starvation timeout adds to the bus error timeout\n\t\t// generation the possibility that a master will wait\n\t\t// OPT_TIMEOUT counts without receiving the bus.  This may be\n\t\t// the case, for example, if one bus master is consuming a\n\t\t// peripheral to such an extent that there's no time/room for\n\t\t// another bus master to use it.  In that case, when the timeout\n\t\t// runs out, the waiting bus master will be given a bus error.",
            "parameter [0:0]\tOPT_STARVATION_TIMEOUT = 1'b0\n\t\t\t\t\t\t&& (OPT_TIMEOUT > 0),\n\t\t//\n\t\t// OPT_DBLBUFFER is used to",
            "reg ister all of the",
            "output s, and\n\t\t// thus avoid adding additional combinational latency through\n\t\t// the core that might require a slower clock speed.",
            "parameter [0:0]\tOPT_DBLBUFFER = 1'b0,\n\t\t//\n\t\t// OPT_LOWPOWER adds",
            "logic to try to force unused values to\n\t\t// zero, rather than to allow a variety of",
            "logic optimizations\n\t\t// that could be used to reduce the",
            "logic count of the device.\n\t\t// Hence, OPT_LOWPOWER will use more",
            "logic , but it won't drive\n\t\t// bus",
            "wire s unless there's a value to drive onto them.",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b1\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,\n\t\t//\n\t\t// Here are the bus",
            "input s from each of the WB bus masters",
            "input ",
            "wire [NM-1:0]\ti_mcyc, i_mstb, i_mwe,",
            "input ",
            "wire [NM*AW-1:0]\ti_maddr,",
            "input ",
            "wire [NM*DW-1:0]\ti_mdata,",
            "input ",
            "wire [NM*DW/8-1:0]\ti_msel,\n\t\t//\n\t\t// .... and their return data",
            "output ",
            "wire [NM-1:0]\to_mstall,",
            "output ",
            "wire [NM-1:0]\to_mack,",
            "output ",
            "reg [NM*DW-1:0]\to_mdata,",
            "output ",
            "wire [NM-1:0]\to_merr,\n\t\t//\n\t\t//\n\t\t// Here are the",
            "output ports, used to control each of the\n\t\t// various slave ports that we are connected to",
            "output ",
            "reg [NS-1:0]\to_scyc, o_sstb, o_swe,",
            "output ",
            "reg [NS*AW-1:0]\to_saddr,",
            "output ",
            "reg [NS*DW-1:0]\to_sdata,",
            "output ",
            "reg [NS*DW/8-1:0]\to_ssel,\n\t\t//\n\t\t// ... and their return data back to us.",
            "input ",
            "wire [NS-1:0]\ti_sstall, i_sack,",
            "input ",
            "wire [NS*DW-1:0]\ti_sdata,",
            "input ",
            "wire [NS-1:0]\ti_serr\n\t\t// }}}\n\t);\n\t//\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Register declarations\n\t// {{{\n\t//\n\t// TIMEOUT_WIDTH is the number of bits in counter used to check\n\t// on a timeout.",
            "localparam TIMEOUT_WIDTH = $clog2(OPT_TIMEOUT);\n\t//\n\t// LGNM is the log (base two) of the number of bus masters\n\t// connecting to this crossbar",
            "localparam LGNM = (NM>1) ? $clog2(NM) : 1;\n\t//\n\t// LGNS is the log (base two) of the number of slaves plus one\n\t// come out of the system.  The extra \"plus one\" is used for a\n\t// pseudo slave representing the case where the given address\n\t// doesn't connect to any of the slaves.  This address will\n\t// generate a bus error.",
            "localparam LGNS = $clog2(NS+1);\n\t// At one time I used o_macc and o_sacc to put into the outgoing\n\t// trace file, just enough",
            "logic to tell me if a transaction was\n\t// taking place on the given clock.\n\t//\n\t// assign\to_macc = (i_mstb & ~o_mstall);\n\t// assign\to_sacc = (o_sstb & ~i_sstall);\n\t//\n\t// These definitions work with Veri1ator, just not with Yosys\n\t//",
            "reg [NM-1:0][NS:0]\t\trequest;\n\t//",
            "reg [NM-1:0][NS-1:0]\trequested;\n\t//",
            "reg [NM-1:0][NS:0]\t\tgrant;\n\t//\n\t// These definitions work with both",
            "wire [NS:0]\t\t\trequest\t\t[0:NM-1];",
            "reg [NS-1:0]\t\trequested\t[0:NM-1];",
            "reg [NS:0]\t\t\tgrant\t\t[0:NM-1];",
            "reg [NM-1:0]\t\tmgrant;",
            "reg [NS-1:0]\t\tsgrant;\n\n\t// Verilator lint_off UNUSED",
            "wire [LGMAXBURST-1:0]\tw_mpending [0:NM-1];\n\t// Verilator lint_on  UNUSED",
            "reg [NM-1:0]\t\tmfull, mnearfull, mempty;",
            "wire [NM-1:0]\t\ttimed_out;",
            "localparam NMFULL = (NM > 1) ? (1<<LGNM) : 1;",
            "localparam NSFULL = (1<<LGNS);",
            "wire [LGNS-1:0]\tmindex\t\t[0:NMFULL-1];",
            "wire [LGNM-1:0]\tsindex\t\t[0:NSFULL-1];",
            "wire [NMFULL-1:0]\tm_cyc;",
            "wire [NMFULL-1:0]\tm_stb;",
            "wire [NMFULL-1:0]\tm_we;",
            "wire [AW-1:0]\tm_addr\t\t[0:NMFULL-1];",
            "wire [DW-1:0]\tm_data\t\t[0:NMFULL-1];",
            "wire [DW/8-1:0]\tm_sel\t\t[0:NMFULL-1];",
            "reg [NM-1:0]\tm_stall;\n\t//",
            "wire [NSFULL-1:0]\ts_stall;",
            "wire [DW-1:0]\ts_data\t\t[0:NSFULL-1];",
            "wire [NSFULL-1:0]\ts_ack;",
            "wire [NSFULL-1:0]\ts_err;",
            "wire [NM-1:0]\tdcd_stb;",
            "localparam [0:0]\tOPT_BUFFER_DECODER=(NS != 1 || SLAVE_MASK != 0);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Incoming signal arbitration\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenvar\tN, M;\n\tinteger\tiN, iM;\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : DECODE_REQUEST\n\t\t// {{{\n\t\t// Register declarations\n\t\t// {{{",
            "wire skd_stb, skd_stall;",
            "wire skd_we;",
            "wire [AW-1:0]\tskd_addr;",
            "wire [DW-1:0]\tskd_data;",
            "wire [DW/8-1:0]\tskd_sel;",
            "wire [NS:0]\t\tdecoded;",
            "wire iskd_ready;\n\t\t// }}}\n\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t// Can't run OPT_LOWPOWER here, less we mess up the\n\t\t\t// consistency in skd_we following\n\t\t\t//\n\t\t\t// .OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.DW(1+AW+DW+DW/8),\n`ifdef\tFORMAL\n\t\t\t.OPT_PASSTHROUGH(1),\n`endif\n\t\t\t.OPT_OUTREG(0)\n\t\t\t// }}}\n\t\t) iskid (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk),\n\t\t\t.i_reset(i_reset || !i_mcyc[N]),\n\t\t\t.i_valid(i_mstb[N]), .o_ready(iskd_ready),\n\t\t\t.i_data({ i_mwe[N], i_maddr[N*AW +: AW],\n\t\t\t\t\ti_mdata[N*DW +: DW],\n\t\t\t\t\ti_msel[N*DW/8 +: DW/8] }),\n\t\t\t.o_valid(skd_stb), .i_ready(!skd_stall),\n\t\t\t\t.o_data({ skd_we, skd_addr, skd_data, skd_sel })\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\to_mstall[N] = !iskd_ready;\n\n\t\taddrdecode #(\n\t\t\t// {{{\n\t\t\t// Can't run OPT_LOWPOWER here, less we mess up the\n\t\t\t// consistency in m_we following\n\t\t\t//\n\t\t\t// .OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.NS(NS), .AW(AW), .DW(DW+DW/8+1),\n\t\t\t.SLAVE_ADDR(SLAVE_ADDR),\n\t\t\t.SLAVE_MASK(SLAVE_MASK),\n\t\t\t.OPT_REGISTERED(OPT_BUFFER_DECODER)\n\t\t\t// }}}\n\t\t) adcd(\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t.i_valid(skd_stb && i_mcyc[N]), .o_stall(skd_stall),\n\t\t\t\t.i_addr(skd_addr),\n\t\t\t\t.i_data({ skd_we, skd_data, skd_sel }),\n\t\t\t.o_valid(dcd_stb[N]), .i_stall(m_stall[N]&&i_mcyc[N]),\n\t\t\t.o_decode(decoded), .o_addr(m_addr[N]),\n\t\t\t\t.o_data({ m_we[N], m_data[N], m_sel[N] })\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\trequest[N] = (m_cyc[N] && dcd_stb[N]) ? decoded : 0;\n\n\t\tassign\tm_cyc[N] = i_mcyc[N];\n\t\tassign\tm_stb[N] = i_mcyc[N] && dcd_stb[N] && !mfull[N];\n\t\t// }}}\n\tend for(N=NM; N<NMFULL; N=N+1)\n\tbegin : UNUSED_MASTER_SIGNALS\n\t\t// {{{\n\t\t// in case NM isn't one less than a power of two, complete\n\t\t// the set\n\t\tassign\tm_cyc[N] = 0;\n\t\tassign\tm_stb[N] = 0;\n\n\t\tassign\tm_we[N]   = 0;\n\t\tassign\tm_addr[N] = 0;\n\t\tassign\tm_data[N] = 0;\n\t\tassign\tm_sel[N]  = 0;\n\t\t// }}}\n\tend endgenerate\n\n\t// requested\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\tbegin\n\t\t\t// For each slave\n\t\t\trequested[0][iM] = 0;\n\t\t\tfor(iN=1; iN<NM; iN=iN+1)\n\t\t\tbegin\n\t\t\t\t// This slave has been requested if a prior\n\t\t\t\t// master has requested it\n\t\t\t\t//\n\t\t\t\t// This includes any master before the last one\n\t\t\t\trequested[iN][iM] = requested[iN-1][iM];\n\t\t\t\t//\n\t\t\t\t// As well as if the last master has requested\n\t\t\t\t// this slave.  Only count this request, though,\n\t\t\t\t// if this master could act upon it.\n\t\t\t\tif (request[iN-1][iM] &&\n\t\t\t\t\t(grant[iN-1][iM]\n\t\t\t\t\t|| (!mgrant[iN-1]||mempty[iN-1])))\n\t\t\t\t\trequested[iN][iM] = 1;\n\t\t\tend\n\t\tend\n\tend\n\t// }}}\n\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : SLAVE_GRANT\n\t\t// {{{\n`define\tREGISTERED_SGRANT\n`ifdef\tREGISTERED_SGRANT\n\t\t// {{{",
            "reg drop_sgrant;\n\n\t\t// drop_sgrant\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tdrop_sgrant = !m_cyc[sindex[M]];\n\t\t\tif (!request[sindex[M]][M] && m_stb[sindex[M]]\n\t\t\t\t&& mempty[sindex[M]])\n\t\t\t\tdrop_sgrant = 1;\n\t\t\tif (!sgrant[M])\n\t\t\t\tdrop_sgrant = 0;\n\t\t\tif (i_reset)\n\t\t\t\tdrop_sgrant = 1;\n\t\tend\n\t\t// }}}\n\n\t\t// sgrant\n\t\t// {{{\n\t\tinitial\tsgrant[M] = 0;\n\t\talways @(posedge i_clk)\n\t\tbegin\n\t\t\tsgrant[M] <= sgrant[M];\n\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\tif (request[iN][M] && (!mgrant[iN] || mempty[iN]))\n\t\t\t\tsgrant[M] <= 1;\n\t\t\tif (drop_sgrant)\n\t\t\t\tsgrant[M] <= 0;\n\t\tend\n\t\t// }}}\n\t\t// }}}\n`else\n\t\t// {{{\n\t\t// sgrant\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tsgrant[M] = 0;\n\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\tif (grant[iN][M])\n\t\t\t\tsgrant[M] = 1;\n\t\tend\n\t\t// }}}\n\t\t// }}}\n`endif\n\n\t\tassign\ts_data[M]  = i_sdata[M*DW +: DW];\n\t\tassign\ts_stall[M] = o_sstb[M] && i_sstall[M];\n\t\tassign\ts_ack[M]   = o_scyc[M] && i_sack[M];\n\t\tassign\ts_err[M]   = o_scyc[M] && i_serr[M];\n\n\t\t// }}}\n\tend for(M=NS; M<NSFULL; M=M+1)\n\tbegin : UNUSED_SLAVE_SIGNALS\n\t\t// {{{\n\t\tassign\ts_data[M]  = 0;\n\t\tassign\ts_stall[M] = 1;\n\t\tassign\ts_ack[M]   = 0;\n\t\tassign\ts_err[M]   = 1;\n\t\t// }}}\n\tend endgenerate\n\n\t//\n\t// Arbitrate among masters to determine who gets to access a given\n\t// channel\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : ARBITRATE_REQUESTS\n\t\t// {{{\n\n\t\t// Register declarations\n\t\t// {{{",
            "wire [NS:0]",
            "reg rant;",
            "wire [LGNS-1:0]\treindex;\n\n\t\t// This is done using a couple of variables.\n\t\t//\n\t\t// request[N][M]\n\t\t//\tThis is true if master N is requesting to access slave\n\t\t//\tM.  It is combinatorial, so it will be true if the\n\t\t//\trequest is being made on the current clock.\n\t\t//\n\t\t// requested[N][M]\n\t\t//\tTrue if some other master, prior to N, has requested\n\t\t//\tchannel M.  This creates a basic priority arbiter,\n\t\t//\tsuch that lower numbered masters have access before\n\t\t//\ta greater numbered master\n\t\t//\n\t\t// grant[N][M]\n\t\t//\tTrue if a grant has been made for master N to access\n\t\t//\tslave channel M\n\t\t//\n\t\t// mgrant[N]\n\t\t//\tTrue if master N has been granted access to some slave\n\t\t//\tchannel, any channel.\n\t\t//\n\t\t// mindex[N]\n\t\t//\tThis is the number of the slave channel that master\n\t\t//\tN has been given access to\n\t\t//\n\t\t// sgrant[M]\n\t\t//\tTrue if there exists some master, N, that has been\n\t\t// \tgranted access to this slave, hence grant[N][M] must\n\t\t//\talso be true\n\t\t//\n\t\t// sindex[M]\n\t\t//\tThis is the index of the master that has access to\n\t\t//\tslave M, assuming sgrant[M].  Hence, if sgrant[M]\n\t\t//\tthen grant[sindex[M]][M] must be true\n\t\t//",
            "reg stay_on_channel;",
            "reg requested_channel_is_available;\n\t\t// }}}\n\n\t\t// stay_on_channel\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tstay_on_channel = |(request[N] & grant[N]);\n\n\t\t\tif (mgrant[N] && !mempty[N])\n\t\t\t\tstay_on_channel = 1;\n\t\tend\n\t\t// }}}\n\n\t\t// requested_channel_is_available\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\trequested_channel_is_available =\n\t\t\t|(request[N][NS-1:0]& ~sgrant & ~requested[N][NS-1:0]);\n\n\t\t\tif (request[N][NS])\n\t\t\t\trequested_channel_is_available = 1;\n\n\t\t\tif (NM < 2)\n\t\t\t\trequested_channel_is_available = m_stb[N];\n\t\tend\n\t\t// }}}\n\n\t\t// grant, mgrant\n\t\t// {{{\n\t\tinitial\tgrant[N] = 0;\n\t\tinitial\tmgrant[N] = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_mcyc[N])\n\t\tbegin\n\t\t\tgrant[N] <= 0;\n\t\t\tmgrant[N] <= 0;\n\t\tend else if (!stay_on_channel)\n\t\tbegin\n\t\t\tif (requested_channel_is_available)\n\t\t\tbegin\n\t\t\t\tmgrant[N] <= 1'b1;\n\t\t\t\tgrant[N] <= request[N];\n\t\t\tend else if (m_stb[N])\n\t\t\tbegin\n\t\t\t\tmgrant[N] <= 1'b0;\n\t\t\t\tgrant[N]  <= 0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\tif (NS == 1)\n\t\tbegin : MINDEX_ONE_SLAVE\n\t\t\t// {{{\n\t\t\tassign\tmindex[N] = 0;\n\t\t\tassign",
            "reg rant = 0;\n\t\t\tassign\treindex = 0;\n\t\t\t// }}}\n\t\tend else begin : MINDEX_MULTIPLE_SLAVES\n\t\t\t// {{{",
            "reg [LGNS-1:0]\tr_mindex;\n\n`define\tNEW_MINDEX_CODE\n`ifdef\tNEW_MINDEX_CODE\n\t\t\t// {{{",
            "reg [NS:0]\t\tr_",
            "reg rant;",
            "reg [LGNS-1:0]\tr_reindex;\n\n\t\t\t// r_",
            "reg rant\n\t\t\t// {{{\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\tr_",
            "reg rant = 0;\n\t\t\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\t\t\tbegin\n\t\t\t\t\tif (grant[N][iM])\n\t\t\t\t\t\t// Maintain any open channels\n\t\t\t\t\t\tr_",
            "reg rant[iM] = 1'b1;\n\t\t\t\t\telse if (!sgrant[iM]&&!requested[N][iM])\n\t\t\t\t\t\tr_",
            "reg rant[iM] = 1'b1;\n\n\t\t\t\t\tif (!request[N][iM])\n\t\t\t\t\t\tr_",
            "reg rant[iM] = 1'b0;\n\t\t\t\tend\n\n\t\t\t\tif (grant[N][NS])\n\t\t\t\t\tr_",
            "reg rant[NS] = 1;\n\t\t\t\tif (!request[N][NS])\n\t\t\t\t\tr_",
            "reg rant[NS] = 0;\n\n\t\t\t\tif (mgrant[N] && !mempty[N])\n\t\t\t\t\tr_",
            "reg rant = 0;\n\t\t\tend\n\t\t\t// }}}\n\n\t\t\t// r_reindex\n\t\t\t// {{{\n\t\t\t// Verilator lint_off BLKSEQ\n\t\t\talways @(r_",
            "reg rant,",
            "reg rant)\n\t\t\tbegin\n\t\t\t\tr_reindex = 0;\n\t\t\t\tfor(iM=0; iM<=NS; iM=iM+1)\n\t\t\t\tif (r_",
            "reg rant[iM])\n\t\t\t\t\tr_reindex = r_reindex | iM[LGNS-1:0];\n\t\t\t\tif (",
            "reg rant == 0)\n\t\t\t\t\tr_reindex = r_mindex;\n\t\t\tend\n\t\t\t// Verilator lint_on  BLKSEQ\n\t\t\t// }}}\n\n\t\t\talways @(posedge i_clk)\n\t\t\t\tr_mindex <= reindex;\n\n\t\t\tassign\treindex = r_reindex;\n\t\t\tassign",
            "reg rant = r_",
            "reg rant;\n\t\t\t// }}}\n`else\n\t\t\t// {{{\n\t\t\talways @(posedge i_clk)\n\t\t\tif (!mgrant[N] || mempty[N])\n\t\t\tbegin\n\n\t\t\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\t\t\tbegin\n\t\t\t\t\tif (request[N][iM] && grant[N][iM])\n\t\t\t\t\tbegin\n\t\t\t\t\t\t// Maintain any open channels\n\t\t\t\t\t\tr_mindex <= iM;\n\t\t\t\t\tend else if (request[N][iM]\n\t\t\t\t\t\t\t&& !sgrant[iM]\n\t\t\t\t\t\t\t&& !requested[N][iM])\n\t\t\t\t\tbegin\n\t\t\t\t\t\t// Open a new channel\n\t\t\t\t\t\t// if necessary\n\t\t\t\t\t\tr_mindex <= iM;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t// }}}\n`endif // NEW_MINDEX_CODE\n\t\t\tassign\tmindex[N] = r_mindex;\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\tend for (N=NM; N<NMFULL; N=N+1)\n\tbegin : UNUSED_MINDEXES\n\t\t// {{{\n\t\tassign\tmindex[N] = 0;\n\t\t// }}}\n\tend endgenerate\n\n\t// Calculate sindex.  sindex[M] (indexed by slave ID)\n\t// references the master controlling this slave.  This makes for\n\t// faster/cheaper",
            "logic on the return path, since we can now use\n\t// a fully populated LUT rather than a priority based return scheme\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : GEN_SINDEX\n\t\t// {{{\n\t\tif (NM <= 1)\n\t\tbegin : SINDEX_SINGLE_MASTER\n\t\t\t// {{{\n\t\t\t// If there will only ever be one master, then we\n\t\t\t// can assume all slave indexes point to that master\n\t\t\tassign\tsindex[M] = 0;\n\t\t\t// }}}\n\t\tend else begin : SINDEX_MORE_THAN_ONE_MASTER\n\t\t\t// {{{",
            "reg [LGNM-1:0]\tr_sindex;\n`define\tNEW_SINDEX_CODE\n`ifdef\tNEW_SINDEX_CODE\n\t\t\t// {{{",
            "reg [NM-1:0]",
            "reg rant;",
            "reg [LGNM-1:0]\treindex;\n\n\t\t\talways @(*)\n\t\t\tbegin",
            "reg rant = 0;\n\t\t\t\tfor (iN=0; iN<NM; iN=iN+1)\n\t\t\t\tbegin\n\t\t\t\t\t// Each bit depends upon 6",
            "input s, so\n\t\t\t\t\t// one 6-LUT should be sufficient\n\t\t\t\t\tif (grant[iN][M])",
            "reg rant[iN] = 1;\n\t\t\t\t\telse if (!sgrant[M]&& !requested[iN][M])",
            "reg rant[iN] = 1;\n\n\t\t\t\t\tif (!request[iN][M])",
            "reg rant[iN] = 0;\n\t\t\t\t\tif (mgrant[iN] && !mempty[iN])",
            "reg rant[iN] = 0;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\treindex = 0;\n\t\t\t\t// Each bit in reindex depends upon all of the\n\t\t\t\t// bits in",
            "reg rant--should still be one LUT\n\t\t\t\t// per bit though\n\t\t\t\tif (",
            "reg rant == 0)\n\t\t\t\t\treindex = sindex[M];\n\t\t\t\telse for(iN=0; iN<NM; iN=iN+1)\n\t\t\t\t\tif (",
            "reg rant[iN])\n\t\t\t\t\t\treindex = reindex | iN[LGNM-1:0];\n\t\t\tend\n\n\t\t\talways @(posedge i_clk)\n\t\t\t\tr_sindex <= reindex;\n\n\t\t\tassign\tsindex[M] = r_sindex;\n\t\t\t// }}}\n`else\n\t\t\t// {{{\n\t\t\talways @(posedge i_clk)\n\t\t\tfor (iN=0; iN<NM; iN=iN+1)\n\t\t\tbegin\n\t\t\t\tif (!mgrant[iN] || mempty[iN])\n\t\t\t\tbegin\n\t\t\t\t\tif (request[iN][M] && grant[iN][M])\n\t\t\t\t\t\tr_sindex <= iN;\n\t\t\t\t\telse if (request[iN][M] && !sgrant[M]\n\t\t\t\t\t\t\t&& !requested[iN][M])\n\t\t\t\t\t\tr_sindex <= iN;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tassign\tsindex[M] = r_sindex;\n\t\t\t// }}}\n`endif\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\tend for(M=NS; M<NSFULL; M=M+1)\n\tbegin : UNUSED_SINDEXES\n\t\t// {{{\n\t\t// Assign the unused slave indexes to zero\n\t\t//\n\t\t// Remember, to full out a full 2^something set of slaves,\n\t\t// we may have more slave indexes than we actually have slaves\n\n\t\tassign\tsindex[M] = 0;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assign",
            "output s to the slaves\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Part one\n\t//\n\t// In this part, we assign the difficult",
            "output s: o_scyc and o_sstb\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : GEN_CYC_STB\n\t\t// {{{\n\t\tinitial\to_scyc[M] = 0;\n\t\tinitial\to_sstb[M] = 0;\n\t\talways @(posedge i_clk)\n\t\tbegin\n\t\t\tif (sgrant[M])\n\t\t\tbegin\n\n\t\t\t\tif (!i_mcyc[sindex[M]])\n\t\t\t\tbegin\n\t\t\t\t\to_scyc[M] <= 1'b0;\n\t\t\t\t\to_sstb[M] <= 1'b0;\n\t\t\t\tend else begin\n\t\t\t\t\to_scyc[M] <= 1'b1;\n\n\t\t\t\t\tif (!o_sstb[M] || !s_stall[M])\n\t\t\t\t\t\to_sstb[M]<=request[sindex[M]][M]\n\t\t\t\t\t\t  && !mfull[sindex[M]];\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\to_scyc[M]  <= 1'b0;\n\t\t\t\to_sstb[M]  <= 1'b0;\n\t\t\tend\n\n\t\t\tif (i_reset || s_err[M])\n\t\t\tbegin\n\t\t\t\to_scyc[M] <= 1'b0;\n\t\t\t\to_sstb[M] <= 1'b0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\t//\n\t// Part two\n\t//\n\t// These are the easy(er)",
            "output s, since there are fewer properties\n\t// riding on them\n\tgenerate if ((NM == 1) && (!OPT_LOWPOWER))\n\tbegin : ONE_MASTER\n\t\t// {{{",
            "reg r_swe;",
            "reg [AW-1:0]\tr_saddr;",
            "reg [DW-1:0]\tr_sdata;",
            "reg [DW/8-1:0]\tr_ssel;\n\n\t\t//\n\t\t// This is the low",
            "logic version of our bus data",
            "output s.\n\t\t// It only works if we only have one master.\n\t\t//\n\t\t// The basic idea here is that we share all of our bus",
            "output s\n\t\t// between all of the various slaves.  Since we only have one\n\t\t// bus master, this works.\n\t\t//\n\t\talways @(posedge i_clk)\n\t\tbegin\n\t\t\tr_swe   <= o_swe[0];\n\t\t\tr_saddr <= o_saddr[0+:AW];\n\t\t\tr_sdata <= o_sdata[0+:DW];\n\t\t\tr_ssel  <=o_ssel[0+:DW/8];\n\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tif (sgrant[mindex[0]] && !s_stall[mindex[0]])\n\t\t\t// Verilator lint_on  WIDTH\n\t\t\tbegin\n\t\t\t\tr_swe   <= m_we[0];\n\t\t\t\tr_saddr <= m_addr[0];\n\t\t\t\tr_sdata <= m_data[0];\n\t\t\t\tr_ssel  <= m_sel[0];\n\t\t\tend\n\t\tend\n\n\t\t//\n\t\t// The original version set o_s*[0] above, and then\n\t\t// combinatorially the rest of o_s* here below.  That broke\n\t\t// Veri1ator.  Hence, we're using r_s* and setting all of o_s*\n\t\t// here.\n\t\tfor(M=0; M<NS; M=M+1)\n\t\tbegin : FOREACH_SLAVE_PORT\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\to_swe[M]            = r_swe;\n\t\t\t\to_saddr[M*AW +: AW] = r_saddr[AW-1:0];\n\t\t\t\to_sdata[M*DW +: DW] = r_sdata[DW-1:0];\n\t\t\t\to_ssel[M*DW/8+:DW/8]= r_ssel[DW/8-1:0];\n\t\t\tend\n\t\tend\n\t\t// }}}\n\tend else begin : J\n\tfor(M=0; M<NS; M=M+1)\n\tbegin : GEN_DOWNSTREAM\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tbegin\n\t\t\tif (OPT_LOWPOWER && !sgrant[M])\n\t\t\tbegin\n\t\t\t\to_swe[M]              <= 1'b0;\n\t\t\t\to_saddr[M*AW   +: AW] <= 0;\n\t\t\t\to_sdata[M*DW   +: DW] <= 0;\n\t\t\t\to_ssel[M*(DW/8)+:DW/8]<= 0;\n\t\t\tend else if (!s_stall[M]) begin\n\t\t\t\to_swe[M]              <= m_we[sindex[M]];\n\t\t\t\to_saddr[M*AW   +: AW] <= m_addr[sindex[M]];\n\t\t\t\tif (OPT_LOWPOWER && !m_we[sindex[M]])\n\t\t\t\t\to_sdata[M*DW   +: DW] <= 0;\n\t\t\t\telse\n\t\t\t\t\to_sdata[M*DW   +: DW] <= m_data[sindex[M]];\n\t\t\t\to_ssel[M*(DW/8)+:DW/8]<= m_sel[sindex[M]];\n\t\t\tend\n\n\t\tend\n\t\t// }}}\n\tend end endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assign return values to the masters\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (OPT_DBLBUFFER)\n\tbegin : DOUBLE_BUFFERRED_STALL\n\t\t// {{{",
            "reg [NM-1:0]\tr_mack, r_merr;\n\n\t\tfor(N=0; N<NM; N=N+1)\n\t\tbegin : FOREACH_MASTER_PORT\n\t\t\t// m_stall isn't buffered, since it depends upon\n\t\t\t// the already existing buffer within the address\n\t\t\t// decoder\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\tif (grant[N][NS])\n\t\t\t\t\tm_stall[N] = 1;\n\t\t\t\telse if (mgrant[N] && request[N][mindex[N]])\n\t\t\t\t\tm_stall[N] = mfull[N] || s_stall[mindex[N]];\n\t\t\t\telse\n\t\t\t\t\tm_stall[N] = m_stb[N];\n\n\t\t\t\tif (o_merr[N])\n\t\t\t\t\tm_stall[N] = 0;\n\t\t\tend\n\n\t\t\tinitial\tr_mack[N]   = 0;\n\t\t\tinitial\tr_merr[N]   = 0;\n\t\t\talways @(posedge i_clk)\n\t\t\tbegin\n\t\t\t\t// Verilator lint_off WIDTH\n\t\t\t\tiM = mindex[N];\n\t\t\t\t// Verilator lint_on  WIDTH\n\t\t\t\tr_mack[N]   <= mgrant[N] && s_ack[mindex[N]];\n\t\t\t\tr_merr[N]   <= mgrant[N] && s_err[mindex[N]];\n\t\t\t\tif (OPT_LOWPOWER && !mgrant[N])\n\t\t\t\t\to_mdata[N*DW +: DW] <= 0;\n\t\t\t\telse\n\t\t\t\t\to_mdata[N*DW +: DW] <= s_data[mindex[N]];\n\n\t\t\t\tif (grant[N][NS]||(timed_out[N] && !o_mack[N]))\n\t\t\t\tbegin\n\t\t\t\t\tr_mack[N]   <= 1'b0;\n\t\t\t\t\tr_merr[N]   <= !o_merr[N];\n\t\t\t\tend\n\n\t\t\t\tif (i_reset || !i_mcyc[N] || o_merr[N])\n\t\t\t\tbegin\n\t\t\t\t\tr_mack[N]   <= 1'b0;\n\t\t\t\t\tr_merr[N]   <= 1'b0;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tassign\to_mack[N] = r_mack[N];\n\n\t\t\tassign\to_merr[N] = (!OPT_STARVATION_TIMEOUT || i_mcyc[N]) && r_merr[N];\n\n\t\tend\n\t\t// }}}\n\tend else if (NS == 1) // && !OPT_DBLBUFFER\n\tbegin : SINGLE_SLAVE\n\t\t// {{{\n\t\tfor(N=0; N<NM; N=N+1)\n\t\tbegin : FOREACH_MASTER_PORT",
            "reg r_mack, r_merr;\n\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\tm_stall[N] = !mgrant[N] || s_stall[0]\n\t\t\t\t\t|| (m_stb[N] && !request[N][0]);\n\t\t\t\tr_mack     =  mgrant[N] && i_sack[0];\n\t\t\t\tr_merr     =  mgrant[N] && i_serr[0];\n\t\t\t\to_mdata[N*DW +: DW]  = (!mgrant[N] && OPT_LOWPOWER)\n\t\t\t\t\t? 0 : i_sdata;\n\n\t\t\t\tif (mfull[N])\n\t\t\t\t\tm_stall[N] = 1'b1;\n\n\t\t\t\tif (timed_out[N] && !r_mack)\n\t\t\t\tbegin\n\t\t\t\t\tm_stall[N] = 1'b0;\n\t\t\t\t\tr_mack     = 1'b0;\n\t\t\t\t\tr_merr     = 1'b1;\n\t\t\t\tend\n\n\t\t\t\tif (grant[N][NS] && m_stb[N])\n\t\t\t\tbegin\n\t\t\t\t\tm_stall[N] = 1'b0;\n\t\t\t\t\tr_mack     = 1'b0;\n\t\t\t\t\tr_merr     = 1'b1;\n\t\t\t\tend\n\n\t\t\t\tif (!m_cyc[N])\n\t\t\t\tbegin\n\t\t\t\t\tr_mack = 1'b0;\n\t\t\t\t\tr_merr = 1'b0;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tassign\to_mack[N] = r_mack;\n\t\t\tassign\to_merr[N] = r_merr;\n\t\tend\n\t\t// }}}\n\tend else begin : SINGLE_BUFFER_STALL\n\t\t// {{{\n\t\tfor(N=0; N<NM; N=N+1)\n\t\tbegin : FOREACH_MASTER_PORT\n\t\t\t// initial\to_mstall[N] = 0;\n\t\t\t// initial\to_mack[N]   = 0;",
            "reg r_mack, r_merr;\n\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\tm_stall[N] = 1;\n\t\t\t\tr_mack     = mgrant[N] && s_ack[mindex[N]];\n\t\t\t\tr_merr     = mgrant[N] && s_err[mindex[N]];\n\t\t\t\tif (OPT_LOWPOWER && !mgrant[N])\n\t\t\t\t\to_mdata[N*DW +: DW] = 0;\n\t\t\t\telse\n\t\t\t\t\to_mdata[N*DW +: DW] = s_data[mindex[N]];\n\n\t\t\t\tif (mgrant[N])\n\t\t\t\t\t// Possibly lower the stall signal\n\t\t\t\t\tm_stall[N] = s_stall[mindex[N]]\n\t\t\t\t\t    || !request[N][mindex[N]];\n\n\t\t\t\tif (mfull[N])\n\t\t\t\t\tm_stall[N] = 1'b1;\n\n\t\t\t\tif (grant[N][NS] ||(timed_out[N] && !r_mack))\n\t\t\t\tbegin\n\t\t\t\t\tm_stall[N] = 1'b0;\n\t\t\t\t\tr_mack     = 1'b0;\n\t\t\t\t\tr_merr     = 1'b1;\n\t\t\t\tend\n\n\t\t\t\tif (!m_cyc[N])\n\t\t\t\tbegin\n\t\t\t\t\tr_mack    = 1'b0;\n\t\t\t\t\tr_merr     = 1'b0;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tassign\to_mack[N] = r_mack;\n\t\t\tassign\to_merr[N] = r_merr;\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\t//\n\t// Count the pending transactions per master\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : COUNT_PENDING_TRANSACTIONS\n\t\t// {{{",
            "reg [LGMAXBURST-1:0]\tlclpending;\n\t\tinitial\tlclpending  = 0;\n\t\tinitial\tmempty[N]    = 1;\n\t\tinitial\tmnearfull[N] = 0;\n\t\tinitial\tmfull[N]     = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset || !i_mcyc[N] || o_merr[N])\n\t\tbegin\n\t\t\tlclpending <= 0;\n\t\t\tmfull[N]    <= 0;\n\t\t\tmempty[N]   <= 1'b1;\n\t\t\tmnearfull[N]<= 0;\n\t\tend else case({ (m_stb[N] && !m_stall[N]), o_mack[N] })\n\t\t2'b01: begin\n\t\t\tlclpending <= lclpending - 1'b1;\n\t\t\tmnearfull[N]<= mfull[N];\n\t\t\tmfull[N]    <= 1'b0;\n\t\t\tmempty[N]   <= (lclpending == 1);\n\t\t\tend\n\t\t2'b10: begin\n\t\t\tlclpending <= lclpending + 1'b1;\n\t\t\tmnearfull[N]<= (&lclpending[LGMAXBURST-1:2])&&(lclpending[1:0] != 0);\n\t\t\tmfull[N]    <= mnearfull[N];\n\t\t\tmempty[N]   <= 1'b0;\n\t\t\tend\n\t\tdefault: begin end\n\t\tendcase\n\n\t\tassign w_mpending[N] = lclpending;\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate if (OPT_TIMEOUT > 0)\n\tbegin : CHECK_TIMEOUT\n\t\t// {{{\n\t\tfor(N=0; N<NM; N=N+1)\n\t\tbegin : FOREACH_MASTER_PORT",
            "reg [TIMEOUT_WIDTH-1:0]\tdeadlock_timer;",
            "reg r_timed_out;\n\n\t\t\tinitial\tdeadlock_timer = OPT_TIMEOUT;\n\t\t\tinitial\tr_timed_out = 0;\n\t\t\talways @(posedge i_clk)\n\t\t\tif (i_reset || !i_mcyc[N]\n\t\t\t\t\t||((w_mpending[N] == 0) && !m_stb[N])\n\t\t\t\t\t||(m_stb[N] && !m_stall[N])\n\t\t\t\t\t||(o_mack[N] || o_merr[N])\n\t\t\t\t\t||(!OPT_STARVATION_TIMEOUT&&!mgrant[N]))\n\t\t\tbegin\n\t\t\t\tdeadlock_timer <= OPT_TIMEOUT;\n\t\t\t\tr_timed_out <= 0;\n\t\t\tend else if (deadlock_timer > 0)\n\t\t\tbegin\n\t\t\t\tdeadlock_timer <= deadlock_timer - 1;\n\t\t\t\tr_timed_out <= (deadlock_timer <= 1);\n\t\t\tend\n\n\t\t\tassign\ttimed_out[N] = r_timed_out;\n\t\tend\n\t\t// }}}\n\tend else begin : NO_TIMEOUT\n\t\t// {{{\n\t\tassign\ttimed_out = 0;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Parameter consistency check\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tinitial\tbegin : PARAMETER_CONSISTENCY_CHECK\n\t\t// {{{\n\t\tif (NM == 0)\n\t\tbegin\n\t\t\t$display(\"ERROR: At least one master must be defined\");\n\t\t\t$stop;\n\t\tend\n\n\t\tif (NS == 0)\n\t\tbegin\n\t\t\t$display(\"ERROR: At least one slave must be defined\");\n\t\t\t$stop;\n\t\tend\n\n\t\tif (OPT_STARVATION_TIMEOUT != 0 && OPT_TIMEOUT == 0)\n\t\tbegin\n\t\t\t$display(\"ERROR: The starvation timeout is implemented as part of the",
            "reg ular timeout\");\n\t\t\t$display(\"  Without a timeout, the starvation timeout will not work\");\n\t\t\t$stop;\n\t\tend\n\t\t// }}}\n\tend\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties used to verify the core\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t// Register declarations\n\t// {{{",
            "localparam F_MAX_DELAY = 4;",
            "localparam F_LGDEPTH = LGMAXBURST;\n\t//",
            "reg f_past_valid;\n\t//\n\t// Our bus checker keeps track of the number of requests,\n\t// acknowledgments, and the number of outstanding transactions on\n\t// every channel, both the masters driving us",
            "wire [F_LGDEPTH-1:0]\tf_mreqs\t\t[0:NM-1];",
            "wire [F_LGDEPTH-1:0]\tf_macks\t\t[0:NM-1];",
            "wire [F_LGDEPTH-1:0]\tf_moutstanding\t[0:NM-1];\n\t//\n\t// as well as the slaves that we drive ourselves",
            "wire [F_LGDEPTH-1:0]\tf_sreqs\t\t[0:NS-1];",
            "wire [F_LGDEPTH-1:0]\tf_sacks\t\t[0:NS-1];",
            "wire [F_LGDEPTH-1:0]\tf_soutstanding\t[0:NS-1];\n\t// }}}\n\n\tinitial\tassert(!OPT_STARVATION_TIMEOUT || OPT_TIMEOUT > 0);\n\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid = 1'b1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : GRANT_CHECKING\n\t\t// {{{",
            "reg checkgrant;\n\n\t\talways @(*)\n\t\tif (f_past_valid)\n\t\tfor(iN=N+1; iN<NM; iN=iN+1)\n\t\t\t// Can't grant the same channel to two separate\n\t\t\t// masters.  This applies to all but the error or\n\t\t\t// no-slave-selected channel\n\t\t\tassert((grant[N][NS-1:0] & grant[iN][NS-1:0])==0);\n\n\t\tfor(M=1; M<=NS; M=M+1)\n\t\tbegin\n\t\t\t// Can't grant two channels to the same master\n\t\t\talways @(*)\n\t\t\tif (f_past_valid && grant[N][M])\n\t\t\t\tassert(grant[N][M-1:0] == 0);\n\t\tend\n\n\n\t\talways @(*)\n\t\tif (&w_mpending[N])\n\t\t\tassert(o_merr[N] || m_stall[N]);\n\n\t\talways @(*)\n\t\tif (f_past_valid)\n\t\tbegin\n\t\t\tcheckgrant = 0;\n\t\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\t\t\tif (grant[N][iM])\n\t\t\t\t\tcheckgrant = 1;\n\t\t\tif (grant[N][NS])\n\t\t\t\tcheckgrant = 1;\n\n\t\t\tassert(checkgrant == mgrant[N]);\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\t// Double check the grant mechanism and its dependent variables\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : CHECK_GRANTS\n\t\t// {{{\n\t\tfor(M=0; M<NS; M=M+1)\n\t\tbegin\n\t\t\talways @(*)\n\t\t\tif ((f_past_valid)&&grant[N][M])\n\t\t\tbegin\n\t\t\t\tassert(mgrant[N]);\n\t\t\t\tassert(mindex[N] == M);\n\t\t\t\tassert(sgrant[M]);\n\t\t\t\tassert(sindex[M] == N);\n\t\t\tend\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : CHECK_SGRANT\n\t\t// {{{",
            "reg f_sgrant;\n\n\t\talways @(*)\n\t\tif (sgrant[M])\n\t\t\tassert(grant[sindex[M]][M]);\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tf_sgrant = 0;\n\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\tif (grant[iN][M])\n\t\t\t\tf_sgrant = 1;\n\t\tend\n\n\t\talways @(*)\n\t\t\tassert(sgrant[M] == f_sgrant);\n\t\t// }}}\n\tend endgenerate\n\n\t// Double check the timeout flags for consistency\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : F_CHECK_TIMEOUT\n\t\t// {{{\n\t\talways @(*)\n\t\tif (f_past_valid)\n\t\tbegin\n\t\t\tassert(mempty[N] == (w_mpending[N] == 0));\n\t\t\tassert(mnearfull[N]==(&w_mpending[N][LGMAXBURST-1:1]));\n\t\t\tassert(mfull[N] == (&w_mpending[N]));\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n`ifdef\tVERIFIC\n\t// {{{\n\t// The Verific parser is currently broken, and doesn't allow\n\t// initial assumes or asserts.  The following lines get us around that\n\t//\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(sgrant == 0);\n\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin\n\t\talways @(*)\n\t\tif (!f_past_valid)\n\t\tbegin\n\t\t\tassume(o_scyc[M] == 0);\n\t\t\tassume(o_sstb[M] == 0);\n\t\t\tassume(sgrant[M] == 0);\n\t\tend\n\tend endgenerate\n\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin\n\t\talways @(*)\n\t\tif (!f_past_valid)\n\t\tbegin\n\t\t\tassume(grant[N] == 0);\n\t\t\tassume(mgrant[N] == 0);\n\t\tend\n\tend endgenerate\n\t// }}}\n`endif\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// BUS CHECK\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// Verify that every channel, whether master or slave, follows the rules\n\t// of the WB road.\n\t//\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : WB_SLAVE_CHECK\n\t\t// {{{\n\t\tfwb_slave #(\n\t\t\t.AW(AW), .DW(DW),\n\t\t\t.F_LGDEPTH(LGMAXBURST),\n\t\t\t.F_MAX_ACK_DELAY(0),\n\t\t\t.F_MAX_STALL(0)\n\t\t\t) slvi(i_clk, i_reset,\n\t\t\t\ti_mcyc[N], i_mstb[N], i_mwe[N],\n\t\t\t\ti_maddr[N*AW +: AW], i_mdata[N*DW +: DW],\n\t\t\t\ti_msel[N*(DW/8) +: (DW/8)],\n\t\t\to_mack[N], o_mstall[N], o_mdata[N*DW +: DW], o_merr[N],\n\t\t\tf_mreqs[N], f_macks[N], f_moutstanding[N]);\n\n\t\talways @(*)\n\t\tif ((f_past_valid)&&(grant[N][NS]))\n\t\t\tassert(f_moutstanding[N] <= 1);\n\n\t\talways @(*)\n\t\tif (f_past_valid && grant[N][NS] && i_mcyc[N])\n\t\t\tassert(m_stall[N] || o_merr[N]);\n\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && $past(!i_reset && i_mstb[N] && o_mstall[N]))\n\t\t\tassume($stable(i_mdata[N*DW +: DW]));\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : WB_MASTER_CHECK\n\t\t// {{{\n\t\tfwb_master #(\n\t\t\t.AW(AW), .DW(DW),\n\t\t\t.F_LGDEPTH(LGMAXBURST),\n\t\t\t.F_MAX_ACK_DELAY(F_MAX_DELAY),\n\t\t\t.F_MAX_STALL(2)\n\t\t\t) mstri(i_clk, i_reset,\n\t\t\t\to_scyc[M], o_sstb[M], o_swe[M],\n\t\t\t\to_saddr[M*AW +: AW], o_sdata[M*DW +: DW],\n\t\t\t\to_ssel[M*(DW/8) +: (DW/8)],\n\t\t\ti_sack[M], i_sstall[M], s_data[M], i_serr[M],\n\t\t\tf_sreqs[M], f_sacks[M], f_soutstanding[M]);\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Correlate outstanding numbers\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : CHECK_OUTSTANDING\n\t\t// {{{\n\t\talways @(*)\n\t\tif (mfull[N])\n\t\t\tassert(m_stall[N]);\n\n\t\talways @(posedge i_clk)\n\t\tif (i_mcyc[N])\n\t\t\tassert(f_moutstanding[N] == w_mpending[N]\n\t\t\t\t+((OPT_BUFFER_DECODER & dcd_stb[N]) ? 1:0));",
            "reg [LGMAXBURST:0]\tn_outstanding;\n\t\talways @(*)\n\t\tif (i_mcyc[N])\n\t\t\tassert(f_moutstanding[N] >=\n\t\t\t\t((OPT_BUFFER_DECODER && dcd_stb[N]) ? 1:0)\n\t\t\t\t+ (o_mack[N] && OPT_DBLBUFFER) ? 1:0);\n\n\t\talways @(*)\n\t\t\tn_outstanding = f_moutstanding[N]\n\t\t\t\t- ((OPT_BUFFER_DECODER && dcd_stb[N]) ? 1:0)\n\t\t\t\t- ((o_mack[N] && OPT_DBLBUFFER) ? 1:0);\n\n\t\talways @(posedge i_clk)\n\t\tif (i_mcyc[N] && !mgrant[N] && !o_merr[N])\n\t\t\tassert(f_moutstanding[N]\n\t\t\t\t== ((OPT_BUFFER_DECODER & dcd_stb[N]) ? 1:0));\n\n\t\telse if (i_mcyc[N] && mgrant[N] && !i_reset)\n\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\tif (grant[N][iM] && o_scyc[iM] && !i_serr[iM] && !o_merr[N])\n\t\t\tassert(n_outstanding\n\t\t\t\t== {1'b0,f_soutstanding[iM]}\n\t\t\t\t\t+(o_sstb[iM] ? 1:0));\n\n\t\talways @(*)\n\t\tif (!i_reset)\n\t\tbegin\n\t\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\t\tif (grant[N][iM] && i_mcyc[N])\n\t\t\tbegin\n\t\t\t\tif (f_soutstanding[iM] > 0)\n\t\t\t\t\tassert(i_mwe[N] == o_swe[iM]);\n\t\t\t\tif (o_sstb[iM])\n\t\t\t\t\tassert(i_mwe[N] == o_swe[iM]);\n\t\t\t\tif (o_mack[N])\n\t\t\t\t\tassert(i_mwe[N] == o_swe[iM]);\n\t\t\t\tif (o_scyc[iM] && i_sack[iM])\n\t\t\t\t\tassert(i_mwe[N] == o_swe[iM]);\n\t\t\t\tif (o_merr[N] && !timed_out[N])\n\t\t\t\t\tassert(i_mwe[N] == o_swe[iM]);\n\t\t\t\tif (o_scyc[iM] && i_serr[iM])\n\t\t\t\t\tassert(i_mwe[N] == o_swe[iM]);\n\t\t\tend\n\t\tend\n\n\t\talways @(*)\n\t\tif (!i_reset && OPT_BUFFER_DECODER && i_mcyc[N])\n\t\tbegin\n\t\t\tif (dcd_stb[N])\n\t\t\t\tassert(i_mwe[N] == m_we[N]);\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : ASSERT_NOT_CYC_WO_GRANT\n\t\t// {{{\n\t\talways @(posedge i_clk)\n\t\tif (!$past(sgrant[M]))\n\t\t\tassert(!o_scyc[M]);\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// CONTRACT SECTION\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// Here's the contract, in two parts:\n\t// {{{\n\t//\t1. Should ever a master (any master) wish to read from a slave\n\t//\t\t(any slave), he should be able to read a known value\n\t//\t\tfrom that slave (any value) from any arbitrary address\n\t//\t\the might wish to read from (any address)\n\t//\n\t//\t2. Should ever a master (any master) wish to write to a slave\n\t//\t\t(any slave), he should be able to write the exact\n\t//\t\tvalue he wants (any value) to the exact address he wants\n\t//\t\t(any address)\n\t//\n\t//\tspecial_master\tis an arbitrary constant chosen by the solver,\n\t//\t\twhich can reference *any* possible master\n\t//\tspecial_address\tis an arbitrary constant chosen by the solver,\n\t//\t\twhich can reference *any* possible address the master\n\t//\t\tmight wish to access\n\t//\tspecial_value\tis an arbitrary value (at least during\n\t//\t\tinduction) representing the current value within the\n\t//\t\tslave at the given address\n\t// }}}\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Now let's pay attention to a special bus master and a special\n\t// address referencing a special bus slave.  We'd like to assert\n\t// that we can access the values of every slave from every master.\n\t(* anyconst *)",
            "reg [(NM<=1)?0:(LGNM-1):0]\tspecial_master;",
            "reg [(NS<=1)?0:(LGNS-1):0]\tspecial_slave;\n\t(* anyconst *)",
            "reg [AW-1:0]\tspecial_address;",
            "reg [DW-1:0]\tspecial_value;\n\n\talways @(*)\n\tif (NM <= 1)\n\t\tassume(special_master == 0);\n\talways @(*)\n\tif (NS <= 1)\n\t\tassume(special_slave == 0);\n\n\t//\n\t// Decode the special address to discover the slave associated with it\n\talways @(*)\n\tbegin\n\t\tspecial_slave = NS;\n\t\tfor(iM=0; iM<NS; iM = iM+1)\n\t\tbegin\n\t\t\tif (((special_address ^ SLAVE_ADDR[iM*AW +: AW])\n\t\t\t\t\t&SLAVE_MASK[iM*AW +: AW]) == 0)\n\t\t\t\tspecial_slave = iM;\n\t\tend\n\tend\n\n\tgenerate if (NS > 1)\n\tbegin : DOUBLE_ADDRESS_CHECK\n\t\t// {{{\n\t\t//\n\t\t// Check that no slave address has been assigned twice.\n\t\t// This check only needs to be done once at the beginning\n\t\t// of the run, during the BMC section.",
            "reg address_found;\n\n\t\talways @(*)\n\t\tif (!f_past_valid)\n\t\tbegin\n\t\t\taddress_found = 0;\n\t\t\tfor(iM=0; iM<NS; iM = iM+1)\n\t\t\tbegin\n\t\t\t\tif (((special_address ^ SLAVE_ADDR[iM*AW +: AW])\n\t\t\t\t\t\t&SLAVE_MASK[iM*AW +: AW]) == 0)\n\t\t\t\tbegin\n\t\t\t\t\tassert(address_found == 0);\n\t\t\t\t\taddress_found = 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t// }}}\n\tend endgenerate\n\t//\n\t// Let's assume this slave will acknowledge any request on the next\n\t// bus cycle after the stall goes low.  Further, lets assume that\n\t// it never creates an error, and that it always responds to our special\n\t// address with the special data value given above.  To do this, we'll\n\t// also need to make certain that the special value will change\n\t// following any write.\n\t//\n\t// These are the \"assumptions\" associated with our fictitious slave.\n`ifdef\tVERIFIC\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(special_value == 0);\n`else\n\tinitial\tassume(special_value == 0);\n`endif\n\talways @(posedge i_clk)\n\tif (special_slave < NS)\n\tbegin\n\t\t// {{{\n\t\tif ($past(o_sstb[special_slave] && !i_sstall[special_slave]))\n\t\tbegin\n\t\t\tassume(i_sack[special_slave]);\n\n\t\t\tif ($past(!o_swe[special_slave])\n\t\t\t\t\t&&($past(o_saddr[special_slave*AW +: AW]) == special_address))\n\t\t\t\tassume(i_sdata[special_slave*DW+: DW]\n\t\t\t\t\t\t== special_value);\n\t\tend else\n\t\t\tassume(!i_sack[special_slave]);\n\t\tassume(!i_serr[special_slave]);\n\n\t\tif (o_scyc[special_slave])\n\t\t\tassert(f_soutstanding[special_slave]\n\t\t\t\t== i_sack[special_slave]);\n\n\t\tif (o_sstb[special_slave] && !i_sstall[special_slave]\n\t\t\t&& o_swe[special_slave])\n\t\tbegin\n\t\t\tfor(iM=0; iM < DW/8; iM=iM+1)\n\t\t\tif (o_ssel[special_slave * DW/8 + iM])\n\t\t\t\tspecial_value[iM*8 +: 8] <= o_sdata[special_slave * DW + iM*8 +: 8];\n\t\tend\n\t\t// }}}\n\tend\n\n\t//\n\t// Now its time to make some assertions.  Specifically, we want to\n\t// assert that any time we read from this special slave, the special\n\t// value is returned.",
            "reg [2:0]\tf_read_seq;",
            "reg f_read_ack, f_read_sstall;\n\n\tinitial\tf_read_sstall = 0;\n\talways @(posedge i_clk)\n\t\tf_read_sstall <= s_stall[special_slave];\n\n\talways @(*)\n\t\tf_read_ack = (f_read_seq[2] || ((!OPT_DBLBUFFER)&&f_read_seq[1]\n\t\t\t\t\t&& !f_read_sstall));\n\tinitial\tf_read_seq = 0;\n\talways @(posedge i_clk)\n\tif ((special_master < NM)&&(special_slave < NS)\n\t\t\t&&(i_mcyc[special_master])\n\t\t\t&&(!timed_out[special_master]))\n\tbegin\n\t\tf_read_seq <= 0;\n\t\tif ((grant[special_master][special_slave])\n\t\t\t&&(m_stb[special_master])\n\t\t\t&&(m_addr[special_master] == special_address)\n\t\t\t&&(!m_we[special_master])\n\t\t\t)\n\t\tbegin\n\t\t\tf_read_seq[0] <= 1;\n\t\tend\n\n\t\tif (|f_read_seq)\n\t\tbegin\n\t\t\tassert(grant[special_master][special_slave]);\n\t\t\tassert(mgrant[special_master]);\n\t\t\tassert(sgrant[special_slave]);\n\t\t\tassert(mindex[special_master] == special_slave);\n\t\t\tassert(sindex[special_slave] == special_master);\n\t\t\tassert(!o_merr[special_master]);\n\t\tend\n\n\t\tif (f_read_seq[0] && !$past(s_stall[special_slave]))\n\t\tbegin\n\t\t\tassert(o_scyc[special_slave]);\n\t\t\tassert(o_sstb[special_slave]);\n\t\t\tassert(!o_swe[special_slave]);\n\t\t\tassert(o_saddr[special_slave*AW +: AW] == special_address);\n\n\t\t\tf_read_seq[1] <= 1;\n\n\t\tend else if (f_read_seq[0] && $past(s_stall[special_slave]))\n\t\tbegin\n\t\t\tassert($stable(m_stb[special_master]));\n\t\t\tassert(!m_we[special_master]);\n\t\t\tassert(m_addr[special_master] == special_address);\n\n\t\t\tf_read_seq[0] <= 1;\n\t\tend\n\n\t\tif (f_read_seq[1] && $past(s_stall[special_slave]))\n\t\tbegin\n\t\t\tassert(o_scyc[special_slave]);\n\t\t\tassert(o_sstb[special_slave]);\n\t\t\tassert(!o_swe[special_slave]);\n\t\t\tassert(o_saddr[special_slave*AW +: AW] == special_address);\n\t\t\tf_read_seq[1] <= 1;\n\t\tend else if (f_read_seq[1] && !$past(s_stall[special_slave]))\n\t\tbegin\n\t\t\tassert(i_sack[special_slave]);\n\t\t\tassert(i_sdata[special_slave*DW +: DW] == $past(special_value));\n\t\t\tif (OPT_DBLBUFFER)\n\t\t\t\tf_read_seq[2] <= 1;\n\t\tend\n\n\t\tif (f_read_ack)\n\t\tbegin\n\t\t\tassert(o_mack[special_master]);\n\t\t\tassert(o_mdata[special_master * DW +: DW]\n\t\t\t\t== $past(special_value,2));\n\t\tend\n\tend else\n\t\tf_read_seq <= 0;\n\n\talways @(*)\n\t\tcover(i_mcyc[special_master] && f_read_ack);\n\n\t//\n\t// Let's try a write assertion now.  Specifically, on any request to\n\t// write to our special address, we want to assert that the special\n\t// value at that address can be written.",
            "reg [2:0]\tf_write_seq;",
            "reg f_write_ack, f_write_sstall;\n\n\tinitial\tf_write_sstall = 0;\n\talways @(posedge i_clk)\n\t\tf_write_sstall = s_stall[special_slave];\n\n\talways @(*)\n\t\tf_write_ack = (f_write_seq[2]\n\t\t\t\t|| ((!OPT_DBLBUFFER)&&f_write_seq[1]\n\t\t\t\t\t&& !f_write_sstall));\n\tinitial\tf_write_seq = 0;\n\talways @(posedge i_clk)\n\tif ((special_master < NM)&&(special_slave < NS)\n\t\t\t&&(i_mcyc[special_master])\n\t\t\t&&(!timed_out[special_master]))\n\tbegin\n\t\tf_write_seq <= 0;\n\t\tif ((grant[special_master][special_slave])\n\t\t\t&&(m_stb[special_master])\n\t\t\t&&(m_addr[special_master] == special_address)\n\t\t\t&&(m_we[special_master]))\n\t\tbegin\n\t\t\t// Our write sequence begins when our special master\n\t\t\t// has access to the bus, *and* he is trying to write\n\t\t\t// to our special address.\n\t\t\tf_write_seq[0] <= 1;\n\t\tend\n\n\t\tif (|f_write_seq)\n\t\tbegin\n\t\t\tassert(grant[special_master][special_slave]);\n\t\t\tassert(mgrant[special_master]);\n\t\t\tassert(sgrant[special_slave]);\n\t\t\tassert(mindex[special_master] == special_slave);\n\t\t\tassert(sindex[special_slave] == special_master);\n\t\t\tassert(!o_merr[special_master]);\n\t\tend\n\n\t\tif (f_write_seq[0] && !$past(s_stall[special_slave]))\n\t\tbegin\n\t\t\tassert(o_scyc[special_slave]);\n\t\t\tassert(o_sstb[special_slave]);\n\t\t\tassert(o_swe[special_slave]);\n\t\t\tassert(o_saddr[special_slave*AW +: AW] == special_address);\n\t\t\tassert(o_sdata[special_slave*DW +: DW]\n\t\t\t\t== $past(m_data[special_master]));\n\t\t\tassert(o_ssel[special_slave*DW/8 +: DW/8]\n\t\t\t\t== $past(m_sel[special_master]));\n\n\t\t\tf_write_seq[1] <= 1;\n\n\t\tend else if (f_write_seq[0] && $past(s_stall[special_slave]))\n\t\tbegin\n\t\t\tassert($stable(m_stb[special_master]));\n\t\t\tassert(m_we[special_master]);\n\t\t\tassert(m_addr[special_master] == special_address);\n\t\t\tassert($stable(m_data[special_master]));\n\t\t\tassert($stable(m_sel[special_master]));\n\n\t\t\tf_write_seq[0] <= 1;\n\t\tend\n\n\t\tif (f_write_seq[1] && $past(s_stall[special_slave]))\n\t\tbegin\n\t\t\tassert(o_scyc[special_slave]);\n\t\t\tassert(o_sstb[special_slave]);\n\t\t\tassert(o_swe[special_slave]);\n\t\t\tassert(o_saddr[special_slave*AW +: AW] == special_address);\n\t\t\tassert($stable(o_sdata[special_slave*DW +: DW]));\n\t\t\tassert($stable(o_ssel[special_slave*DW/8 +: DW/8]));\n\t\t\tf_write_seq[1] <= 1;\n\t\tend else if (f_write_seq[1] && !$past(s_stall[special_slave]))\n\t\tbegin\n\t\t\tfor(iM=0; iM<DW/8; iM=iM+1)\n\t\t\tbegin\n\t\t\t\tif ($past(o_ssel[special_slave * DW/8 + iM]))\n\t\t\t\t\tassert(special_value[iM*8 +: 8]\n\t\t\t\t\t\t== $past(o_sdata[special_slave*DW+iM*8 +: 8]));\n\t\t\tend\n\n\t\t\tassert(i_sack[special_slave]);\n\t\t\tif (OPT_DBLBUFFER)\n\t\t\t\tf_write_seq[2] <= 1;\n\t\tend\n\n\t\tif (f_write_seq[2] || ((!OPT_DBLBUFFER) && f_write_seq[1]\n\t\t\t\t\t&& !$past(s_stall[special_slave])))\n\t\t\tassert(o_mack[special_master]);\n\tend else\n\t\tf_write_seq <= 0;\n\n\talways @(*)\n\t\tcover(i_mcyc[special_master] && f_write_ack);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// COVER: Full connectivity check\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg [NM-1:0]\tf_m_ackd;",
            "reg [NS-1:0]\tf_s_ackd;",
            "reg f_cvr_aborted;\n\n\tinitial\tf_cvr_aborted = 0;\n\talways @(posedge i_clk)\n\tif (!f_past_valid || i_reset)\n\t\tf_cvr_aborted <= 0;\n\telse for(iN=0; iN<NM; iN=iN+1)\n\tbegin\n\t\tif (request[iN][NS])\n\t\t\tf_cvr_aborted = 1;\n\t\tif ($fell(i_mcyc[iN]))\n\t\tbegin\n\t\t\tif (f_macks[iN] != f_mreqs[iN])\n\t\t\t\tf_cvr_aborted = 1;\n\t\tend\n\tend\n\n\tinitial\tf_m_ackd = 0;\n\tgenerate for (N=0; N<NM; N=N+1)\n\tbegin : GEN_FM_ACKD\n\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tf_m_ackd[N] <= 0;\n\t\telse if (o_mack[N])\n\t\t\tf_m_ackd[N] <= 1'b1;\n\n\tend endgenerate\n\n\talways @(posedge i_clk)\n\t\tcover(!f_cvr_aborted && (&f_m_ackd));\n\n\tgenerate if (NM > 1)\n\tbegin\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(!f_cvr_aborted && (&f_m_ackd[1:0]));\n\n\tend endgenerate\n\n\tinitial\tf_s_ackd = 0;\n\tgenerate for (M=0; M<NS; M=M+1)\n\tbegin : GEN_FS_ACKD\n\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tf_s_ackd[M] <= 1'b0;\n\t\telse if (sgrant[M] && o_mack[sindex[M]])\n\t\t\tf_s_ackd[M] <= 1'b1;\n\n\tend endgenerate\n\n\talways @(posedge i_clk)\n\t\tcover(!f_cvr_aborted && (&f_s_ackd[NS-1:0]));\n\n\tgenerate if (NS > 1)\n\tbegin\n\n\t\talways @(posedge i_clk)\n\t\t\tcover(!f_cvr_aborted && (&f_s_ackd[NS-1:0]));\n\n\tend endgenerate\n\t// }}}\n`endif\n// }}}",
            "endmodule `ifndef\tYOSYS\n`default_nettype",
            "wire `endif"
        ]
    },
    {
        "file_name": "axilite2axi.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axilite2axi.v",
        "chunks": [
            "module axilite2axi #(\n\t\t// {{{",
            "parameter C_AXI_ID_WIDTH\t= 4,\n\t\t\t\tC_AXI_ADDR_WIDTH= 32,\n\t\t\t\tC_AXI_DATA_WIDTH= 32,",
            "parameter [C_AXI_ID_WIDTH-1:0]\tC_AXI_WRITE_ID = 0,\n\t\t\t\t\t\tC_AXI_READ_ID = 0\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire ACLK,",
            "input ",
            "wire ARESETN,\n\t\t// Slave AXI interface\n\t\t// {{{\n\t\t// Slave write signals",
            "input ",
            "wire S_AXI_AWVALID,",
            "output ",
            "wire S_AXI_AWREADY,",
            "input ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tS_AXI_AWADDR,\n\t\t// Verilator coverage_off",
            "input ",
            "wire [3-1:0]\t\t\tS_AXI_AWPROT,\n\t\t// Verilator coverage_on\n\t\t// Slave write data signals",
            "input ",
            "wire S_AXI_WVALID,",
            "output ",
            "wire S_AXI_WREADY,",
            "input ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tS_AXI_WDATA,",
            "input ",
            "wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,\n\t\t// Slave return write response",
            "output ",
            "wire S_AXI_BVALID,",
            "input ",
            "wire S_AXI_BREADY,",
            "output ",
            "wire [2-1:0]\t\t\tS_AXI_BRESP,\n\t\t// Slave read signals",
            "input ",
            "wire S_AXI_ARVALID,",
            "output ",
            "wire S_AXI_ARREADY,",
            "input ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tS_AXI_ARADDR,",
            "input ",
            "wire [3-1:0]\t\t\tS_AXI_ARPROT,\n\t\t// Slave read data signals",
            "output ",
            "wire S_AXI_RVALID,",
            "input ",
            "wire S_AXI_RREADY,",
            "output ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tS_AXI_RDATA,",
            "output ",
            "wire [2-1:0]\t\t\tS_AXI_RRESP,\n\t\t// }}}\n\t\t// Master AXI interface\n\t\t// {{{\n\t\t// Master interface write address",
            "output ",
            "wire M_AXI_AWVALID,",
            "input ",
            "wire M_AXI_AWREADY,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_AXI_AWID,\n\t\t// Verilator coverage_on",
            "output ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tM_AXI_AWADDR,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [8-1:0]\t\t\tM_AXI_AWLEN,",
            "output ",
            "wire [3-1:0]\t\t\tM_AXI_AWSIZE,",
            "output ",
            "wire [2-1:0]\t\t\tM_AXI_AWBURST,",
            "output ",
            "wire M_AXI_AWLOCK,",
            "output ",
            "wire [4-1:0]\t\t\tM_AXI_AWCACHE,",
            "output ",
            "wire [3-1:0]\t\t\tM_AXI_AWPROT,",
            "output ",
            "wire [4-1:0]\t\t\tM_AXI_AWQOS,\n\t\t// Verilator coverage_on\n\t\t// Master write data",
            "output ",
            "wire M_AXI_WVALID,",
            "input ",
            "wire M_AXI_WREADY,",
            "output ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_AXI_WDATA,",
            "output ",
            "wire [C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB,",
            "output ",
            "wire M_AXI_WLAST,\n\t\t// Master write response",
            "input ",
            "wire M_AXI_BVALID,",
            "output ",
            "wire M_AXI_BREADY,",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_AXI_BID,\n\t\t// Verilator coverage_off",
            "input ",
            "wire [1:0]\t\t\tM_AXI_BRESP,\n\t\t// Verilator coverage_on\n\t\t// Master interface read address",
            "output ",
            "wire M_AXI_ARVALID,",
            "input ",
            "wire M_AXI_ARREADY,",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_AXI_ARID,",
            "output ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tM_AXI_ARADDR,\n\t\t// Verilator coverage_off",
            "output ",
            "wire [8-1:0]\t\t\tM_AXI_ARLEN,",
            "output ",
            "wire [3-1:0]\t\t\tM_AXI_ARSIZE,",
            "output ",
            "wire [2-1:0]\t\t\tM_AXI_ARBURST,",
            "output ",
            "wire M_AXI_ARLOCK,",
            "output ",
            "wire [4-1:0]\t\t\tM_AXI_ARCACHE,",
            "output ",
            "wire [3-1:0]\t\t\tM_AXI_ARPROT,",
            "output ",
            "wire [4-1:0]\t\t\tM_AXI_ARQOS,\n\t\t// Verilator coverage_on\n\t\t// Master interface read data return",
            "input ",
            "wire M_AXI_RVALID,",
            "output ",
            "wire M_AXI_RREADY,\n\t\t// Verilator coverage_off",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tM_AXI_RID,\n\t\t// Verilator coverage_on",
            "input ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_AXI_RDATA,",
            "input ",
            "wire M_AXI_RLAST,",
            "input ",
            "wire [2-1:0]\t\t\tM_AXI_RRESP\n\t\t// }}}\n\t\t// }}}\n\t);",
            "localparam ADDRLSB = $clog2(C_AXI_DATA_WIDTH)-3;\n\tassign\tM_AXI_AWID    = C_AXI_WRITE_ID;\n\tassign\tM_AXI_AWADDR  = S_AXI_AWADDR;\n\tassign\tM_AXI_AWLEN   = 0;\n\tassign\tM_AXI_AWSIZE  = ADDRLSB[2:0];\n\tassign\tM_AXI_AWBURST = 0;\n\tassign\tM_AXI_AWLOCK  = 0;\n\tassign\tM_AXI_AWCACHE = 4'b0011; // As recommended by Xilinx UG1037\n\tassign\tM_AXI_AWPROT  = S_AXI_AWPROT;\n\tassign\tM_AXI_AWQOS   = 0;\n\tassign\tM_AXI_AWVALID = S_AXI_AWVALID;\n\tassign\tS_AXI_AWREADY = M_AXI_AWREADY;\n\t// Master write data\n\tassign\tM_AXI_WDATA   = S_AXI_WDATA;\n\tassign\tM_AXI_WLAST   = 1;\n\tassign\tM_AXI_WSTRB   = S_AXI_WSTRB;\n\tassign\tM_AXI_WVALID  = S_AXI_WVALID;\n\tassign\tS_AXI_WREADY  = M_AXI_WREADY;\n\t// Master write response\n\tassign\tS_AXI_BRESP   = M_AXI_BRESP;\n\tassign\tS_AXI_BVALID  = M_AXI_BVALID;\n\tassign\tM_AXI_BREADY  = S_AXI_BREADY;\n\t//\n\t//\n\tassign\tM_AXI_ARID    = C_AXI_READ_ID;\n\tassign\tM_AXI_ARADDR  = S_AXI_ARADDR;\n\tassign\tM_AXI_ARLEN   = 0;\n\tassign\tM_AXI_ARSIZE  = ADDRLSB[2:0];\n\tassign\tM_AXI_ARBURST = 0;\n\tassign\tM_AXI_ARLOCK  = 0;\n\tassign\tM_AXI_ARCACHE = 4'b0011; // As recommended by Xilinx UG1037\n\tassign\tM_AXI_ARPROT  = S_AXI_ARPROT;\n\tassign\tM_AXI_ARQOS   = 0;\n\tassign\tM_AXI_ARVALID = S_AXI_ARVALID;\n\tassign\tS_AXI_ARREADY = M_AXI_ARREADY;\n\t//\n\tassign\tS_AXI_RDATA   = M_AXI_RDATA;\n\tassign\tS_AXI_RRESP   = M_AXI_RRESP;\n\tassign\tS_AXI_RVALID  = M_AXI_RVALID;\n\tassign\tM_AXI_RREADY  = S_AXI_RREADY;\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, ACLK, ARESETN, M_AXI_RLAST, M_AXI_RID, M_AXI_BID };\n\t// Verilator lint_on UNUSED\n\t// Verilator coverage_on\n\t// }}}\n\n`ifdef\tFORMAL\n\t//\n\t// The following are some of the properties used to verify this design\n\t//",
            "localparam F_LGDEPTH = 10;",
            "wire [F_LGDEPTH-1:0]\tfaxil_awr_outstanding,\n\t\t\t\tfaxil_wr_outstanding, faxil_rd_outstanding;\n\n\tfaxil_slave #(\n\t\t\t.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),\n\t\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t\t.F_LGDEPTH(10),\n\t\t\t.F_AXI_MAXRSTALL(4),\n\t\t\t.F_AXI_MAXWAIT(9),\n\t\t\t.F_AXI_MAXDELAY(0)\n\t) faxil(.i_clk(ACLK), .i_axi_reset_n(ARESETN),\n\t\t//\n\t\t.i_axi_awvalid(S_AXI_AWVALID),\n\t\t.i_axi_awready(S_AXI_AWREADY),\n\t\t.i_axi_awaddr( S_AXI_AWADDR),\n\t\t.i_axi_awprot( S_AXI_AWPROT),\n\t\t//\n\t\t.i_axi_wvalid(S_AXI_WVALID),\n\t\t.i_axi_wready(S_AXI_WREADY),\n\t\t.i_axi_wdata( S_AXI_WDATA),\n\t\t.i_axi_wstrb( S_AXI_WSTRB),\n\t\t//\n\t\t.i_axi_bvalid(S_AXI_BVALID),\n\t\t.i_axi_bready(S_AXI_BREADY),\n\t\t.i_axi_bresp( S_AXI_BRESP),\n\t\t//\n\t\t.i_axi_arvalid(S_AXI_ARVALID),\n\t\t.i_axi_arready(S_AXI_ARREADY),\n\t\t.i_axi_araddr( S_AXI_ARADDR),\n\t\t.i_axi_arprot( S_AXI_ARPROT),\n\t\t//\n\t\t//\n\t\t.i_axi_rvalid(S_AXI_RVALID),\n\t\t.i_axi_rready(S_AXI_RREADY),\n\t\t.i_axi_rdata( S_AXI_RDATA),\n\t\t.i_axi_rresp( S_AXI_RRESP),\n\t\t//\n\t\t.f_axi_awr_outstanding(faxil_awr_outstanding),\n\t\t.f_axi_wr_outstanding(faxil_wr_outstanding),\n\t\t.f_axi_rd_outstanding(faxil_rd_outstanding));\n\n\t//\n\t// ...\n\t//\n\n\tfaxi_master #(\n\t\t\t.C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),\n\t\t\t.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),\n\t\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t\t.OPT_MAXBURST(0),\n\t\t\t.OPT_EXCLUSIVE(1'b0),\n\t\t\t.OPT_NARROW_BURST(1'b0),\n\t\t\t.F_OPT_NO_RESET(1'b1),\n\t\t\t.F_LGDEPTH(10),\n\t\t\t.F_AXI_MAXSTALL(4),\n\t\t\t.F_AXI_MAXRSTALL(0),\n\t\t\t.F_AXI_MAXDELAY(4)\n\t) faxi(.i_clk(ACLK), .i_axi_reset_n(ARESETN),\n\t\t//\n\t\t.i_axi_awready(M_AXI_AWREADY),\n\t\t.i_axi_awid(   M_AXI_AWID),\n\t\t.i_axi_awaddr( M_AXI_AWADDR),\n\t\t.i_axi_awlen(  M_AXI_AWLEN),\n\t\t.i_axi_awsize( M_AXI_AWSIZE),\n\t\t.i_axi_awburst(M_AXI_AWBURST),\n\t\t.i_axi_awlock( M_AXI_AWLOCK),\n\t\t.i_axi_awcache(M_AXI_AWCACHE),\n\t\t.i_axi_awprot( M_AXI_AWPROT),\n\t\t.i_axi_awqos(  M_AXI_AWQOS),\n\t\t.i_axi_awvalid(M_AXI_AWVALID),\n\t\t//\n\t\t.i_axi_wready(M_AXI_WREADY),\n\t\t.i_axi_wdata( M_AXI_WDATA),\n\t\t.i_axi_wstrb( M_AXI_WSTRB),\n\t\t.i_axi_wlast( M_AXI_WLAST),\n\t\t.i_axi_wvalid(M_AXI_WVALID),\n\t\t//\n\t\t.i_axi_bready(M_AXI_BREADY),\n\t\t.i_axi_bid(   M_AXI_BID),\n\t\t.i_axi_bresp( M_AXI_BRESP),\n\t\t.i_axi_bvalid(M_AXI_BVALID),\n\t\t//\n\t\t.i_axi_arready(M_AXI_ARREADY),\n\t\t.i_axi_arid(   M_AXI_ARID),\n\t\t.i_axi_araddr( M_AXI_ARADDR),\n\t\t.i_axi_arlen(  M_AXI_ARLEN),\n\t\t.i_axi_arsize( M_AXI_ARSIZE),\n\t\t.i_axi_arburst(M_AXI_ARBURST),\n\t\t.i_axi_arlock( M_AXI_ARLOCK),\n\t\t.i_axi_arcache(M_AXI_ARCACHE),\n\t\t.i_axi_arprot( M_AXI_ARPROT),\n\t\t.i_axi_arqos(  M_AXI_ARQOS),\n\t\t.i_axi_arvalid(M_AXI_ARVALID),\n\t\t//\n\t\t.i_axi_rid(   M_AXI_RID),\n\t\t.i_axi_rdata( M_AXI_RDATA),\n\t\t.i_axi_rready(M_AXI_RREADY),\n\t\t.i_axi_rresp( M_AXI_RRESP),\n\t\t.i_axi_rvalid(M_AXI_RVALID),\n\t\t//\n\t\t.f_axi_awr_nbursts(faxi_awr_nbursts),\n\t\t.f_axi_wr_pending(faxi_wr_pending),\n\t\t.f_axi_rd_nbursts(faxi_rd_nbursts),\n\t\t.f_axi_rd_outstanding(faxi_rd_outstanding)\n\t\t//\n\t\t// ...\n\t\t//\n\t\t);\n\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Induction rule checks\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// First rule: the AXI solver isn't permitted to have any more write\n\t// bursts outstanding than the AXI-lite interface has.\n\talways @(*)\n\t\tassert(faxi_awr_nbursts == faxil_awr_outstanding);\n\n\t//\n\t// Second: Since our bursts are limited to one value each, and since\n\t// we can't send address bursts ahead of their data counterparts,\n\t// (AXI property limitation) faxi_wr_pending can only ever be one or\n\t// zero, and the counters must match\n\talways @(*)\n\tbegin\n\t\t//\n\t\t// ...\n\t\t//\n\n\t\tif (faxil_awr_outstanding != 0)\n\t\tbegin\n\t\t\tassert((faxil_awr_outstanding == faxil_wr_outstanding)\n\t\t\t||(faxil_awr_outstanding-1 == faxil_wr_outstanding));\n\t\tend\n\n\t\tif (faxil_awr_outstanding == 0)\n\t\t\tassert(faxil_wr_outstanding == 0);\n\tend\n\n\t//\n\t// ...\n\t//\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Known \"bugs\"\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// These are really more limitations in the AXI properties than\n\t// bugs in the code, but they need to be documented here.\n\t//\n\tgenerate if (C_AXI_DATA_WIDTH > 8)\n\tbegin\n\t\t// The AXI-lite property checker doesn't validate WSTRB\n\t\t// values like it should.  If we don't force the AWADDR\n\t\t// LSBs to zero, the solver will pick an invalid WSTRB.\n\t\t//\n\t\talways @(*)\n\t\t\tassume(S_AXI_AWADDR[$clog2(C_AXI_DATA_WIDTH)-3:0] == 0);\n\t\talways @(*)\n\t\t\tassert(faxi_wr_addr[$clog2(C_AXI_DATA_WIDTH)-3:0] == 0);\n\tend endgenerate\n\n\t//\n\t// The AXI solver can't handle write transactions without either a\n\t// concurrent or proceeding write address burst.  Here we make that\n\t// plain.  It's not likely to cause any problems, but still worth\n\t// noting.\n\talways @(*)\n\tif (faxil_awr_outstanding == faxil_wr_outstanding)\n\t\tassume(S_AXI_AWVALID || !S_AXI_WVALID);\n\telse if (faxil_awr_outstanding > faxil_wr_outstanding)\n\t\tassume(!S_AXI_AWVALID);\n\n\t//\n\t// We need to make certain that our counters never overflow.  This is\n\t// an assertion within the property checkers, so we need an appropriate\n\t// matching assumption here.  In practice, F_LGDEPTH could be set\n\t// so arbitrarily large that this assumption would never get hit,\n\t// but the solver doesn't know that.\n\talways @(*)\n\tif (faxil_rd_outstanding >= {{(F_LGDEPTH-1){1'b1}}, 1'b0 })\n\t\tassume(!S_AXI_ARVALID);\n\n\talways @(*)\n\tif (faxil_awr_outstanding >= {{(F_LGDEPTH-1){1'b1}}, 1'b0 })\n\t\tassume(!S_AXI_AWVALID);\n\n`endif",
            "endmodule `ifndef\tYOSYS\n`default_nettype",
            "wire `endif"
        ]
    },
    {
        "file_name": "memdev.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/memdev.v",
        "chunks": [
            "module memdev #(\n\t\t// {{{",
            "parameter LGMEMSZ=15, DW=32, EXTRACLOCK= 1,",
            "parameter HEXFILE=\"\",",
            "parameter [0:0]\tOPT_ROM = 1'b0,",
            "localparam AW = LGMEMSZ - $clog2(DW/8)\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_clk, i_reset,",
            "input ",
            "wire i_wb_cyc, i_wb_stb, i_wb_we,",
            "input ",
            "wire [(AW-1):0]\ti_wb_addr,",
            "input ",
            "wire [(DW-1):0]\ti_wb_data,",
            "input ",
            "wire [(DW/8-1):0]\ti_wb_sel,",
            "output ",
            "wire o_wb_stall,",
            "output ",
            "reg o_wb_ack,",
            "output ",
            "reg [(DW-1):0]\to_wb_data\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{",
            "wire w_wstb, w_stb;",
            "wire [(DW-1):0]\tw_data;",
            "wire [(AW-1):0]\tw_addr;",
            "wire [(DW/8-1):0]\tw_sel;",
            "reg [(DW-1):0]\tmem\t[0:((1<<AW)-1)];\n\t// }}}\n\n\t// Pre-load the memory\n\t// {{{\n\tgenerate if (HEXFILE != 0)\n\tbegin : PRELOAD_MEMORY\n\n\t\tinitial $readmemh(HEXFILE, mem);\n\n\tend endgenerate\n\t// }}}\n\n\t// Delay request if necessary\n\t// {{{\n\tgenerate if (EXTRACLOCK == 0)\n\tbegin : NO_EXTRA_CLOCK\n\t\t// {{{\n\t\tassign\tw_wstb = (i_wb_stb)&&(i_wb_we);\n\t\tassign\tw_stb  = i_wb_stb;\n\t\tassign\tw_addr = i_wb_addr;\n\t\tassign\tw_data = i_wb_data;\n\t\tassign\tw_sel  = i_wb_sel;\n\t\t// }}}\n\tend else begin : EXTRA_MEM_CLOCK_CYCLE\n\t\t// {{{",
            "reg last_wstb, last_stb;",
            "reg [(AW-1):0]\tlast_addr;",
            "reg [(DW-1):0]\tlast_data;",
            "reg [(DW/8-1):0]\tlast_sel;\n\n\t\tinitial\tlast_wstb = 0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tlast_wstb <= 0;\n\t\telse\n\t\t\tlast_wstb <= (i_wb_stb)&&(i_wb_we);\n\n\t\tinitial\tlast_stb = 1'b0;\n\t\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tlast_stb <= 1'b0;\n\t\telse\n\t\t\tlast_stb <= (i_wb_stb);\n\n\t\talways @(posedge i_clk)\n\t\t\tlast_data <= i_wb_data;\n\t\talways @(posedge i_clk)\n\t\t\tlast_addr <= i_wb_addr;\n\t\talways @(posedge i_clk)\n\t\t\tlast_sel <= i_wb_sel;\n\n\t\tassign\tw_wstb = last_wstb;\n\t\tassign\tw_stb  = last_stb;\n\t\tassign\tw_addr = last_addr;\n\t\tassign\tw_data = last_data;\n\t\tassign\tw_sel  = last_sel;\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// Read from memory\n\t// {{{\n\talways @(posedge i_clk)\n\t\to_wb_data <= mem[w_addr];\n\t// }}}\n\n\t// Write to memory (if not a ROM)\n\t// {{{\n\tgenerate if (!OPT_ROM)\n\tbegin : WRITE_TO_MEMORY\n\t\t// {{{\n\t\tinteger\tik;\n\n\t\talways @(posedge i_clk)\n\t\tif (w_wstb)\n\t\tbegin\n\t\t\tfor(ik=0; ik<DW/8; ik=ik+1)\n\t\t\tif (w_sel[ik])\n\t\t\t\tmem[w_addr][ik*8 +: 8] <= w_data[ik*8 +: 8];\n\t\tend\n`ifdef\tVERILATOR\n\tend else begin : VERILATOR_ROM\n\n\t\t// Make Verilator happy\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire rom_unused;\n\t\tassign\trom_unused = &{ 1'b0, w_wstb, w_data, w_sel };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n`endif\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// o_wb_ack\n\t// {{{\n\tinitial\to_wb_ack = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_wb_ack <= 1'b0;\n\telse\n\t\to_wb_ack <= (w_stb)&&(i_wb_cyc);\n\t// }}}\n\n\tassign\to_wb_stall = 1'b0;\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = { 1'b0 };\n\t// verilator lint_on UNUSED\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "localparam F_LGDEPTH = 2;",
            "reg f_past_valid;",
            "wire [F_LGDEPTH-1:0]\tf_nreqs, f_nacks, f_outstanding;",
            "wire [(AW-1):0]\tf_addr;",
            "reg [31:0]\t\tf_data;\n\n\tinitial\tf_past_valid = 1'b0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(i_reset);\n\n\tfwb_slave #(\n\t\t.AW(AW), .DW(DW), .F_MAX_STALL(1), .F_MAX_ACK_DELAY(2),\n\t\t.F_OPT_DISCONTINUOUS(1), .F_LGDEPTH(F_LGDEPTH)\n\t) fwb(i_clk, i_reset, i_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr,\n\t\ti_wb_data, i_wb_sel, o_wb_ack, o_wb_stall, o_wb_data,\n\t\t1'b0, f_nreqs, f_nacks, f_outstanding);\n\n\tgenerate if (EXTRACLOCK)\n\tbegin\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(!i_reset)&&(i_wb_cyc)&&($past(i_wb_cyc)))\n\t\t\tassert((f_outstanding == 0)\n\t\t\t\t== ((!$past(w_stb))&&(!$past(i_wb_stb))));\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(!i_reset)&&(i_wb_cyc))\n\t\t\tassert((f_outstanding == 1)\n\t\t\t\t== ( (($past(w_stb))&&($past(i_wb_cyc)))\n\t\t\t\t\t^($past(i_wb_stb))));\n\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(!i_reset)&&(i_wb_cyc))\n\t\t\tassert((f_outstanding == 2'h2)\n\t\t\t\t== (($past(w_stb))&&($past(i_wb_cyc))\n\t\t\t\t\t&&($past(i_wb_stb))));\n\n\t\talways @(posedge i_clk)\n\t\t\tassert(f_outstanding <= 2);\n\n\tend else begin\n\n\t\talways @(posedge i_clk)\n\t\tif (f_outstanding > 0)\n\t\t\tassert(o_wb_ack);\n\n\t\talways @(posedge i_clk)\n\t\t\tassert(f_outstanding <= 1);\n\t\talways @(posedge i_clk)\n\t\tif ((f_past_valid)&&(!i_reset)&&(i_wb_cyc)&&($past(i_wb_stb)))\n\t\t\tassert(f_outstanding == 1);\n\n\tend endgenerate\n\n\talways @(*)\n\t\tassert(!o_wb_stall);\n\n\t(* anyconst *)",
            "wire [(AW-1):0]\tf_addr;\n\t(* anyconst *)",
            "wire [DW-1:0]\tf_first;",
            "reg [DW-1:0]\tf_data;\n\n\tgenerate if (OPT_ROM)\n\tbegin : F_MATCH_WRITES\n\t\t// This just guarantees *something* drives f_data.  Otherwise\n\t\t// it is held as 'x, and the assumptions below don't help us.\n\t\talways @(posedge i_clk)\n\t\tif (!f_past_valid)\n\t\t\tf_data <= f_first;\n\tend else if (EXTRACLOCK)\n\tbegin\n\t\tinteger\tfk;\n\n\t\talways @(posedge i_clk)\n\t\tif (f_past_valid && !$past(i_reset)\n\t\t\t\t&& $past(i_wb_stb && i_wb_we)\n\t\t\t\t\t&& $past(i_wb_addr == f_addr))\n\t\tbegin\n\t\t\tfor(fk=0; fk<DW/8; fk=fk+1)\n\t\t\tif ($past(i_wb_sel[fk]))\n\t\t\t\tf_data[8*fk +: 8] <= $past(i_wb_data[8*fk +: 8]);\n\t\tend\n\tend else begin\n\t\tinteger\tfk;\n\n\t\talways @(posedge i_clk)\n\t\tif (i_wb_stb && i_wb_we\n\t\t\t\t\t&& i_wb_addr == f_addr)\n\t\tbegin\n\t\t\tfor(fk=0; fk<DW/8; fk=fk+1)\n\t\t\tif (i_wb_sel[fk])\n\t\t\t\tf_data[8*fk +: 8] <= i_wb_data[8*fk +: 8];\n\t\tend\n\tend endgenerate\n\n\talways @(*)\n\tif (!f_past_valid)\n\tbegin\n\t\tassume(mem[f_addr] == f_data);\n\t\tassume(f_data == f_first);\n\tend else begin\n\t\tassert(mem[f_addr] == f_data);\n\tend\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(OPT_ROM))\n\t\tassert($stable(f_data));\n\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "axi_tb.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axi_tb.v",
        "chunks": [
            "module axi_tb #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH        = 28,\t//Width in bytes",
            "parameter BUS_WIDTH            = 32,\n\t\t// Verilator lint_off WIDTH",
            "parameter [0:0]\tOPT_ZIPAXIL          = 1'b1,",
            "parameter [0:0]\tOPT_PIPELINED        = 1'b1,",
            "parameter OPT_LGICACHE         = 12,",
            "parameter OPT_LGDCACHE         = 12,",
            "parameter OPT_MPY              = 3,",
            "parameter [0:0]\tOPT_DIV              = 1'b1,",
            "parameter [0:0]\tOPT_SHIFTS           = 1'b1,",
            "parameter [0:0]\tOPT_LOCK             = 1'b1,",
            "parameter [0:0]\tOPT_EARLY_BRANCHING  = 1'b1,",
            "parameter [0:0]\tOPT_LOWPOWER         = 1'b1,",
            "parameter [0:0]\tOPT_DISTRIBUTED_REGS = 1'b1,",
            "parameter [0:0]\tOPT_USERMODE         = 1'b1,",
            "parameter [0:0]\tOPT_CLKGATE          = 1'b1,",
            "parameter [0:0]\tOPT_DBGPORT          = 1'b1,",
            "parameter [0:0]\tOPT_TRACE_PORT       = 1'b1,",
            "parameter [0:0]\tOPT_CIS              = 1'b1,\n\t\t// verilator lint_off UNUSED",
            "parameter [0:0]\tOPT_WRAP             = 1'b1,\n\t\t// verilator lint_on UNUSED",
            "parameter OPT_SMP              = 1,",
            "parameter MEM_FILE = \"cput3st\",",
            "parameter CONSOLE_FILE = \"console.txt\",",
            "parameter ID_WIDTH = 4,",
            "localparam IW = ID_WIDTH,",
            "parameter LGMEMSZ = ADDRESS_WIDTH-2,\n\t\t// Verilator lint_off UNUSED",
            "parameter [0:0]\tDUMP_TO_VCD = 1'b0,",
            "parameter VCD_FILE = \"dump.vcd\"\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator lint_on  WIDTH\n\t\t// }}}\n\t) (\n\t\t// {{{\n`ifdef\tVERILATOR",
            "input ",
            "wire i_aclk, i_aresetn,\n\t\t// Sim control",
            "input (s)\n\t\t// {{{",
            "input ",
            "wire sim_awvalid,",
            "output ",
            "wire sim_awready,",
            "input ",
            "wire [ADDRESS_WIDTH:0]\tsim_awaddr,",
            "input ",
            "wire [2:0]\t\t\tsim_awprot,",
            "input ",
            "wire sim_wvalid,",
            "output ",
            "wire sim_wready,",
            "input ",
            "wire [31:0]\t\t\tsim_wdata,",
            "input ",
            "wire [3:0]\t\t\tsim_wstrb,",
            "output ",
            "wire sim_bvalid,",
            "input ",
            "wire sim_bready,",
            "output ",
            "wire [1:0]\t\t\tsim_bresp,",
            "input ",
            "wire sim_arvalid,",
            "output ",
            "wire sim_arready,",
            "input ",
            "wire [ADDRESS_WIDTH:0]\tsim_araddr,",
            "input ",
            "wire [2:0]\t\t\tsim_arprot,",
            "output ",
            "wire sim_rvalid,",
            "input ",
            "wire sim_rready,",
            "output ",
            "wire [31:0]\t\t\tsim_rdata,",
            "output ",
            "wire [1:0]\t\t\tsim_rresp,\n\t\t// }}}",
            "input ",
            "wire i_sim_int,\n\t\t//\n\t\t// \"Profiler\" support.  This is a simulation only port.\n\t\t// {{{",
            "output ",
            "wire o_prof_stb,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0]\to_prof_addr,",
            "output ",
            "wire [31:0]\t\t\to_prof_ticks\n\t\t// }}}\n`endif\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{\n\tgenvar\tgk;",
            "parameter [31:0]\tRESET_ADDRESS = { {(32-ADDRESS_WIDTH){1'b0}}, MEMORY_ADDR };",
            "localparam AW = ADDRESS_WIDTH;",
            "parameter [AW-1:0]\tSCOPE_ADDR   = { 4'b0001, {(AW-4){1'b0}} };",
            "parameter [AW-1:0]\tCONSOLE_ADDR = { 4'b0010, {(AW-4){1'b0}} };",
            "parameter [AW-1:0]\tSMP_BASE_ADDR= { 4'b0011, {(AW-4){1'b0}} };",
            "parameter [AW-1:0]\tMEMORY_ADDR  = { 2'b01, {(AW-2){1'b0}} };",
            "parameter [AW-1:0]\tAXILP_ADDR   = { {(AW-24){1'b1}},{(24){1'b0}} };",
            "localparam MIN_SMP = (OPT_SMP < 2) ? 1:OPT_SMP;",
            "parameter [OPT_SMP*AW-1:0]\tSMP_ADDR= SMP_ADDR_fn(MIN_SMP);",
            "parameter [OPT_SMP*AW-1:0]\tSMP_MASK= SMP_MASK_fn(MIN_SMP);\n\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED\n\tfunction automatic [OPT_SMP*AW-1:0] SMP_ADDR_fn(",
            "input integer min_smp);\n\t\t// {{{\n\t\tinteger\tik, offset;\n\tbegin\n\t\tSMP_ADDR_fn = {(OPT_SMP){SMP_BASE_ADDR}};\n\n\t\tfor(ik=1; ik<OPT_SMP; ik=ik+1)\n\t\tbegin\n\t\t\toffset = ik;\n\t\t\tSMP_ADDR_fn[ik * AW + 9 +: $clog2(OPT_SMP)+1]\n\t\t\t\t\t\t= offset[$clog2(OPT_SMP):0];\n\t\tend\n\n\tend endfunction\n\t// }}}\n\n\tfunction automatic [OPT_SMP*AW-1:0] SMP_MASK_fn(",
            "input integer min_smp);\n\t\t// {{{\n\t\tinteger\tik;\n\tbegin\n\t\tSMP_MASK_fn = {(OPT_SMP){ 4'b1111, {(AW-4){1'b0}} }};\n\n\t\tfor(ik=0; ik<OPT_SMP; ik=ik+1)\n\t\tbegin\n\t\t\tSMP_MASK_fn[ik * AW + 9 +: $clog2(OPT_SMP)+1]\n\t\t\t\t\t\t= {($clog2(OPT_SMP)+1){1'b1}};\n\t\tend\n\n\tend endfunction\n\t// }}}\n\t// Verilator coverage_on\n\t// Verilator lint_on  UNUSED\n\n\t//",
            "localparam LGFIFO = 4;\n\n\t// CPU declarations\n\t// {{{",
            "localparam RESET_DURATION = 10;",
            "localparam [0:0]\tOPT_SIM = 1'b1;\n`ifdef\tVERILATOR",
            "localparam [0:0]\tOPT_PROFILER = 1'b1;\n`else",
            "localparam [0:0]\tOPT_PROFILER = 1'b0;\n`endif\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire cpu_int;\n\t// Verilator lint_on  UNUSED",
            "wire scope_int;",
            "wire [31:0]\tcpu_trace;\n\t// Verilator coverage_on",
            "wire [OPT_SMP-1:0]\tcpu_reset;",
            "wire [OPT_SMP-1:0]\tcpu_halted;",
            "wire [OPT_SMP-1:0]\tcpu_gie;",
            "wire [OPT_SMP-1:0]\tcpu_op_stall, cpu_pf_stall, cpu_i_count;",
            "wire pic_interrupt, watchdog_reset;\n\n\t// dbg*\n\t// {{{",
            "wire dbg_awvalid, dbg_awready;",
            "wire [AW:0]\t\tdbg_awaddr;",
            "wire [2:0]\t\tdbg_awprot;",
            "wire dbg_wvalid, dbg_wready;",
            "wire [31:0]\t\tdbg_wdata;",
            "wire [3:0]\t\tdbg_wstrb;",
            "wire dbg_bvalid, dbg_bready;",
            "wire [1:0]\t\tdbg_bresp;",
            "wire dbg_arvalid, dbg_arready;",
            "wire [AW:0]\t\tdbg_araddr;",
            "wire [2:0]\t\tdbg_arprot;",
            "wire dbg_rvalid, dbg_rready;",
            "wire [31:0]\t\tdbg_rdata;",
            "wire [1:0]\t\tdbg_rresp;\n\t// }}}\n\n\t// cpui*\n\t// {{{",
            "wire [OPT_SMP-1:0]\t\tcpui_awvalid, cpui_awready;",
            "wire [OPT_SMP*IW-1:0]\tcpui_awid;",
            "wire [OPT_SMP*AW-1:0]\tcpui_awaddr;",
            "wire [OPT_SMP*8-1:0]\t\tcpui_awlen;",
            "wire [OPT_SMP*3-1:0]\t\tcpui_awsize;",
            "wire [OPT_SMP*2-1:0]\t\tcpui_awburst;",
            "wire [OPT_SMP-1:0]\t\tcpui_awlock;",
            "wire [OPT_SMP*4-1:0]\t\tcpui_awcache;",
            "wire [OPT_SMP*3-1:0]\t\tcpui_awprot;",
            "wire [OPT_SMP*4-1:0]\t\tcpui_awqos;",
            "wire [OPT_SMP-1:0]\t\tcpui_wvalid, cpui_wready;",
            "wire [OPT_SMP*BUS_WIDTH-1:0]\tcpui_wdata;",
            "wire [OPT_SMP*BUS_WIDTH/8-1:0]\tcpui_wstrb;",
            "wire [OPT_SMP-1:0]\t\tcpui_wlast;",
            "wire [OPT_SMP-1:0]\t\tcpui_bvalid, cpui_bready;",
            "wire [OPT_SMP*IW-1:0]\tcpui_bid;",
            "wire [OPT_SMP*2-1:0]\t\tcpui_bresp;",
            "wire [OPT_SMP-1:0]\t\tcpui_arvalid, cpui_arready;",
            "wire [OPT_SMP*IW-1:0]\tcpui_arid;",
            "wire [OPT_SMP*AW-1:0]\tcpui_araddr;",
            "wire [OPT_SMP*8-1:0]\t\tcpui_arlen;",
            "wire [OPT_SMP*3-1:0]\t\tcpui_arsize;",
            "wire [OPT_SMP*2-1:0]\t\tcpui_arburst;",
            "wire [OPT_SMP-1:0]\t\tcpui_arlock;",
            "wire [OPT_SMP*4-1:0]\t\tcpui_arcache;",
            "wire [OPT_SMP*3-1:0]\t\tcpui_arprot;",
            "wire [OPT_SMP*4-1:0]\t\tcpui_arqos;",
            "wire [OPT_SMP-1:0]\t\tcpui_rvalid, cpui_rready;",
            "wire [OPT_SMP*IW-1:0]\tcpui_rid;",
            "wire [OPT_SMP*BUS_WIDTH-1:0]\tcpui_rdata;",
            "wire [OPT_SMP*2-1:0]\t\tcpui_rresp;",
            "wire [OPT_SMP-1:0]\t\tcpui_rlast;\n\t// }}}\n\n\t// cpud*\n\t// {{{",
            "wire [OPT_SMP-1:0]\tcpud_awvalid, cpud_awready;",
            "wire [OPT_SMP*IW-1:0]\tcpud_awid;",
            "wire [OPT_SMP*AW-1:0]\tcpud_awaddr;",
            "wire [OPT_SMP*8-1:0]\t\tcpud_awlen;",
            "wire [OPT_SMP*3-1:0]\t\tcpud_awsize;",
            "wire [OPT_SMP*2-1:0]\t\tcpud_awburst;",
            "wire [OPT_SMP-1:0]\t\tcpud_awlock;",
            "wire [OPT_SMP*4-1:0]\t\tcpud_awcache;",
            "wire [OPT_SMP*3-1:0]\t\tcpud_awprot;",
            "wire [OPT_SMP*4-1:0]\t\tcpud_awqos;",
            "wire [OPT_SMP-1:0]\t\tcpud_wvalid, cpud_wready;",
            "wire [OPT_SMP*BUS_WIDTH-1:0]\tcpud_wdata;",
            "wire [OPT_SMP*BUS_WIDTH/8-1:0]\tcpud_wstrb;",
            "wire [OPT_SMP-1:0]\t\tcpud_wlast;",
            "wire [OPT_SMP-1:0]\t\tcpud_bvalid, cpud_bready;",
            "wire [OPT_SMP*IW-1:0]\tcpud_bid;",
            "wire [OPT_SMP*2-1:0]\t\tcpud_bresp;",
            "wire [OPT_SMP-1:0]\t\tcpud_arvalid, cpud_arready;",
            "wire [OPT_SMP*IW-1:0]\tcpud_arid;",
            "wire [OPT_SMP*AW-1:0]\tcpud_araddr;",
            "wire [OPT_SMP*8-1:0]\t\tcpud_arlen;",
            "wire [OPT_SMP*3-1:0]\t\tcpud_arsize;",
            "wire [OPT_SMP*2-1:0]\t\tcpud_arburst;",
            "wire [OPT_SMP-1:0]\t\tcpud_arlock;",
            "wire [OPT_SMP*4-1:0]\t\tcpud_arcache;",
            "wire [OPT_SMP*3-1:0]\t\tcpud_arprot;",
            "wire [OPT_SMP*4-1:0]\t\tcpud_arqos;",
            "wire [OPT_SMP-1:0]\t\tcpud_rvalid, cpud_rready;",
            "wire [OPT_SMP*IW-1:0]\tcpud_rid;",
            "wire [OPT_SMP*BUS_WIDTH-1:0]\tcpud_rdata;",
            "wire [OPT_SMP*2-1:0]\t\tcpud_rresp;",
            "wire [OPT_SMP-1:0]\t\tcpud_rlast;\n\t// }}}\n\n\t// smpfull*\n\t// {{{",
            "wire [OPT_SMP-1:0]\tsmpfull_awvalid, smpfull_awready;",
            "wire [OPT_SMP*IW-1:0]\tsmpfull_awid;",
            "wire [OPT_SMP*AW-1:0]\tsmpfull_awaddr;",
            "wire [OPT_SMP*8-1:0]\tsmpfull_awlen;",
            "wire [OPT_SMP*3-1:0]\tsmpfull_awsize;",
            "wire [OPT_SMP*2-1:0]\tsmpfull_awburst;",
            "wire [OPT_SMP-1:0]\tsmpfull_awlock;",
            "wire [OPT_SMP*4-1:0]\tsmpfull_awcache;",
            "wire [OPT_SMP*3-1:0]\tsmpfull_awprot;",
            "wire [OPT_SMP*4-1:0]\tsmpfull_awqos;",
            "wire [OPT_SMP-1:0]\t\tsmpfull_wvalid, smpfull_wready;",
            "wire [OPT_SMP*BUS_WIDTH-1:0]\tsmpfull_wdata;",
            "wire [OPT_SMP*BUS_WIDTH/8-1:0]\tsmpfull_wstrb;",
            "wire [OPT_SMP-1:0]\t\tsmpfull_wlast;",
            "wire [OPT_SMP-1:0]\tsmpfull_bvalid, smpfull_bready;",
            "wire [OPT_SMP*IW-1:0]\tsmpfull_bid;",
            "wire [OPT_SMP*2-1:0]\tsmpfull_bresp;",
            "wire [OPT_SMP-1:0]\tsmpfull_arvalid, smpfull_arready;",
            "wire [OPT_SMP*IW-1:0]\tsmpfull_arid;",
            "wire [OPT_SMP*AW-1:0]\tsmpfull_araddr;",
            "wire [OPT_SMP*8-1:0]\tsmpfull_arlen;",
            "wire [OPT_SMP*3-1:0]\tsmpfull_arsize;",
            "wire [OPT_SMP*2-1:0]\tsmpfull_arburst;",
            "wire [OPT_SMP-1:0]\tsmpfull_arlock;",
            "wire [OPT_SMP*4-1:0]\tsmpfull_arcache;",
            "wire [OPT_SMP*3-1:0]\tsmpfull_arprot;",
            "wire [OPT_SMP*4-1:0]\tsmpfull_arqos;",
            "wire [OPT_SMP-1:0]\tsmpfull_rvalid, smpfull_rready;",
            "wire [OPT_SMP*IW-1:0]\tsmpfull_rid;",
            "wire [OPT_SMP*BUS_WIDTH-1:0]\tsmpfull_rdata;",
            "wire [OPT_SMP*2-1:0]\tsmpfull_rresp;",
            "wire [OPT_SMP-1:0]\tsmpfull_rlast;\n\t// }}}\n\n\t// }}}\n\n\t// Memory declarations\n\t// {{{\n\tinteger\trk;",
            "wire ram_we, ram_rd;",
            "wire [LGMEMSZ-$clog2(BUS_WIDTH/8)-1:0]\tram_waddr, ram_raddr;",
            "wire [BUS_WIDTH-1:0]\tram_wdata;",
            "wire [BUS_WIDTH/8-1:0]\tram_wstrb;",
            "wire [BUS_WIDTH-1:0]\tram_rdata;",
            "wire [BUS_WIDTH-1:0]\tram_wdata_swap;",
            "reg [BUS_WIDTH-1:0]\tram_rdata_swap;",
            "wire [BUS_WIDTH/8-1:0]\tram_wstrb_swap;",
            "reg [BUS_WIDTH-1:0]\tram [0:(1<<(LGMEMSZ-$clog2(BUS_WIDTH/8)))-1];\n\n\t// mem*\n\t// {{{",
            "wire mem_awvalid, mem_awready;",
            "wire [IW-1:0]\tmem_awid;",
            "wire [AW-1:0]\tmem_awaddr;",
            "wire [7:0]\t\tmem_awlen;",
            "wire [2:0]\t\tmem_awsize;",
            "wire [1:0]\t\tmem_awburst;",
            "wire mem_awlock;",
            "wire [3:0]\t\tmem_awcache;",
            "wire [2:0]\t\tmem_awprot;",
            "wire [3:0]\t\tmem_awqos;",
            "wire mem_wvalid, mem_wready;",
            "wire [BUS_WIDTH-1:0]\tmem_wdata;",
            "wire [BUS_WIDTH/8-1:0]\tmem_wstrb;",
            "wire mem_wlast;",
            "wire mem_bvalid, mem_bready;",
            "wire [IW-1:0]\tmem_bid;",
            "wire [1:0]\t\tmem_bresp;",
            "wire mem_arvalid, mem_arready;",
            "wire [IW-1:0]\tmem_arid;",
            "wire [AW-1:0]\tmem_araddr;",
            "wire [7:0]\t\tmem_arlen;",
            "wire [2:0]\t\tmem_arsize;",
            "wire [1:0]\t\tmem_arburst;",
            "wire mem_arlock;",
            "wire [3:0]\t\tmem_arcache;",
            "wire [2:0]\t\tmem_arprot;",
            "wire [3:0]\t\tmem_arqos;",
            "wire mem_rvalid, mem_rready;",
            "wire [IW-1:0]\tmem_rid;",
            "wire [BUS_WIDTH-1:0]\t\tmem_rdata;",
            "wire [1:0]\t\tmem_rresp;",
            "wire mem_rlast;\n\t// }}}\n\n\t// }}}\n\n\t// Console declarations\n\t// {{{\n\n\t// con*\n\t// {{{",
            "wire con_awvalid, con_awready;",
            "wire [IW-1:0]\tcon_awid;",
            "wire [AW-1:0]\tcon_awaddr;",
            "wire [7:0]\t\tcon_awlen;",
            "wire [2:0]\t\tcon_awsize;",
            "wire [1:0]\t\tcon_awburst;",
            "wire con_awlock;",
            "wire [3:0]\t\tcon_awcache;",
            "wire [2:0]\t\tcon_awprot;",
            "wire [3:0]\t\tcon_awqos;",
            "wire con_wvalid, con_wready;",
            "wire [BUS_WIDTH-1:0]\tcon_wdata;",
            "wire [BUS_WIDTH/8-1:0]\tcon_wstrb;",
            "wire con_wlast;",
            "wire con_bvalid, con_bready;",
            "wire [IW-1:0]\tcon_bid;",
            "wire [1:0]\t\tcon_bresp;",
            "wire con_arvalid, con_arready;",
            "wire [IW-1:0]\tcon_arid;",
            "wire [AW-1:0]\tcon_araddr;",
            "wire [7:0]\t\tcon_arlen;",
            "wire [2:0]\t\tcon_arsize;",
            "wire [1:0]\t\tcon_arburst;",
            "wire con_arlock;",
            "wire [3:0]\t\tcon_arcache;",
            "wire [2:0]\t\tcon_arprot;",
            "wire [3:0]\t\tcon_arqos;",
            "wire con_rvalid, con_rready;",
            "wire [IW-1:0]\tcon_rid;",
            "wire [BUS_WIDTH-1:0]\tcon_rdata;",
            "wire [1:0]\t\tcon_rresp;",
            "wire con_rlast;\n\t// }}}\n\n\t// conl*\n\t// {{{",
            "wire conl_awvalid, conl_awready;",
            "wire [AW-4:0]\tconl_awaddr;",
            "wire [2:0]\t\tconl_awprot;",
            "wire conl_wvalid, conl_wready;",
            "wire [31:0]\t\tconl_wdata;",
            "wire [3:0]\t\tconl_wstrb;",
            "wire conl_bvalid, conl_bready;",
            "wire [1:0]\t\tconl_bresp;",
            "wire conl_arvalid, conl_arready;",
            "wire [AW-4:0]\tconl_araddr;",
            "wire [2:0]\t\tconl_arprot;",
            "wire conl_rvalid, conl_rready;",
            "wire [31:0]\t\tconl_rdata;",
            "wire [1:0]\t\tconl_rresp;\n\t// }}}\n\t// }}}\n\n\t// scope*\n\t// {{{",
            "wire scope_awvalid, scope_awready;",
            "wire [IW-1:0]\tscope_awid;",
            "wire [AW-1:0]\tscope_awaddr;",
            "wire [7:0]\t\tscope_awlen;",
            "wire [2:0]\t\tscope_awsize;",
            "wire [1:0]\t\tscope_awburst;",
            "wire scope_awlock;",
            "wire [3:0]\t\tscope_awcache;",
            "wire [2:0]\t\tscope_awprot;",
            "wire [3:0]\t\tscope_awqos;",
            "wire scope_wvalid, scope_wready;",
            "wire [BUS_WIDTH-1:0]\tscope_wdata;",
            "wire [BUS_WIDTH/8-1:0]\tscope_wstrb;",
            "wire scope_wlast;",
            "wire scope_bvalid, scope_bready;",
            "wire [IW-1:0]\tscope_bid;",
            "wire [1:0]\t\tscope_bresp;",
            "wire scope_arvalid, scope_arready;",
            "wire [IW-1:0]\tscope_arid;",
            "wire [AW-1:0]\tscope_araddr;",
            "wire [7:0]\t\tscope_arlen;",
            "wire [2:0]\t\tscope_arsize;",
            "wire [1:0]\t\tscope_arburst;",
            "wire scope_arlock;",
            "wire [3:0]\t\tscope_arcache;",
            "wire [2:0]\t\tscope_arprot;",
            "wire [3:0]\t\tscope_arqos;",
            "wire scope_rvalid, scope_rready;",
            "wire [IW-1:0]\tscope_rid;",
            "wire [BUS_WIDTH-1:0]\tscope_rdata;",
            "wire [1:0]\t\tscope_rresp;",
            "wire scope_rlast;\n\t// }}}\n\n\t// AXI Peripheral set declarations\n\t// {{{\n\n\t// axip_* - The AXI4 (full) connection to the peripheral set\n\t// {{{",
            "wire axip_awvalid, axip_awready;",
            "wire [IW-1:0]\taxip_awid;",
            "wire [AW-1:0]\taxip_awaddr;",
            "wire [7:0]\t\taxip_awlen;",
            "wire [2:0]\t\taxip_awsize;",
            "wire [1:0]\t\taxip_awburst;",
            "wire axip_awlock;",
            "wire [3:0]\t\taxip_awcache;",
            "wire [2:0]\t\taxip_awprot;",
            "wire [3:0]\t\taxip_awqos;",
            "wire axip_wvalid, axip_wready;",
            "wire [BUS_WIDTH-1:0]\taxip_wdata;",
            "wire [BUS_WIDTH/8-1:0]\taxip_wstrb;",
            "wire axip_wlast;",
            "wire axip_bvalid, axip_bready;",
            "wire [IW-1:0]\taxip_bid;",
            "wire [1:0]\t\taxip_bresp;",
            "wire axip_arvalid, axip_arready;",
            "wire [IW-1:0]\taxip_arid;",
            "wire [AW-1:0]\taxip_araddr;",
            "wire [7:0]\t\taxip_arlen;",
            "wire [2:0]\t\taxip_arsize;",
            "wire [1:0]\t\taxip_arburst;",
            "wire axip_arlock;",
            "wire [3:0]\t\taxip_arcache;",
            "wire [2:0]\t\taxip_arprot;",
            "wire [3:0]\t\taxip_arqos;",
            "wire axip_rvalid, axip_rready;",
            "wire [IW-1:0]\taxip_rid;",
            "wire [BUS_WIDTH-1:0]\taxip_rdata;",
            "wire [1:0]\t\taxip_rresp;",
            "wire axip_rlast;\n\n\n\t// }}}\n\n\t// axilp_* - The AXI-Lite connection to the peripheral set\n\t// {{{",
            "wire axilp_awvalid, axilp_awready;",
            "wire [AW-4:0]\taxilp_awaddr;",
            "wire [2:0]\t\taxilp_awprot;",
            "wire axilp_wvalid, axilp_wready;",
            "wire [31:0]\t\taxilp_wdata;",
            "wire [3:0]\t\taxilp_wstrb;",
            "wire axilp_bvalid, axilp_bready;",
            "wire [1:0]\t\taxilp_bresp;",
            "wire axilp_arvalid, axilp_arready;",
            "wire [AW-4:0]\taxilp_araddr;",
            "wire [2:0]\t\taxilp_arprot;",
            "wire axilp_rvalid, axilp_rready;",
            "wire [31:0]\t\taxilp_rdata;",
            "wire [1:0]\t\taxilp_rresp;\n\t// }}}\n\t// }}}\n\n`ifdef\tVERILATOR\n\t// simfull_*\n\t// {{{",
            "wire simfull_awvalid;",
            "wire simfull_awready;",
            "wire [IW-1:0]\t\tsimfull_awid;",
            "wire [ADDRESS_WIDTH:0]\tsimwide_awaddr;",
            "wire [ADDRESS_WIDTH-1:0]\tsimfull_awaddr;",
            "wire [7:0]\t\t\tsimfull_awlen;",
            "wire [2:0]\t\t\tsimfull_awsize;",
            "wire [1:0]\t\t\tsimfull_awburst;",
            "wire simfull_awlock;",
            "wire [3:0]\t\t\tsimfull_awcache;",
            "wire [2:0]\t\t\tsimfull_awprot;",
            "wire [3:0]\t\t\tsimfull_awqos;",
            "wire simfull_wvalid;",
            "wire simfull_wready;",
            "wire [BUS_WIDTH-1:0]\t\tsimfull_wdata;",
            "wire [BUS_WIDTH/8-1:0]\tsimfull_wstrb;",
            "wire simfull_wlast;",
            "wire simfull_bvalid;",
            "wire simfull_bready;",
            "wire [IW-1:0]\t\tsimfull_bid;",
            "wire [1:0]\t\t\tsimfull_bresp;",
            "wire simfull_arvalid;",
            "wire simfull_arready;",
            "wire [IW-1:0]\t\tsimfull_arid;",
            "wire [ADDRESS_WIDTH:0]\tsimwide_araddr;",
            "wire [ADDRESS_WIDTH-1:0]\tsimfull_araddr;",
            "wire [7:0]\t\t\tsimfull_arlen;",
            "wire [2:0]\t\t\tsimfull_arsize;",
            "wire [1:0]\t\t\tsimfull_arburst;",
            "wire simfull_arlock;",
            "wire [3:0]\t\t\tsimfull_arcache;",
            "wire [2:0]\t\t\tsimfull_arprot;",
            "wire [3:0]\t\t\tsimfull_arqos;",
            "wire simfull_rvalid;",
            "wire simfull_rready;",
            "wire [IW-1:0]\t\tsimfull_rid;",
            "wire [BUS_WIDTH-1:0]\t\tsimfull_rdata;",
            "wire simfull_rlast;",
            "wire [1:0]\t\t\tsimfull_rresp;\n\t// }}}\n`else\n\t// Traditional TB only declarations\n\t// {{{\n\t// sim*\n\t// {{{",
            "wire sim_awvalid;",
            "wire sim_awready;",
            "wire [ADDRESS_WIDTH-1:0]\tsim_awaddr;",
            "wire [2:0]\t\t\tsim_awprot;",
            "wire sim_wvalid;",
            "wire sim_wready;",
            "wire [31:0]\t\t\tsim_wdata;",
            "wire [3:0]\t\t\tsim_wstrb;",
            "wire sim_bvalid;",
            "wire sim_bready;",
            "wire [1:0]\t\t\tsim_bresp;",
            "wire sim_arvalid;",
            "wire sim_arready;",
            "wire [ADDRESS_WIDTH-1:0]\tsim_araddr;",
            "wire [2:0]\t\t\tsim_arprot;",
            "wire sim_rvalid;",
            "wire sim_rready;",
            "wire [31:0]\t\t\tsim_rdata;",
            "wire [1:0]\t\t\tsim_rresp;\n\t// }}}",
            "wire i_sim_int;",
            "wire o_prof_stb;\n\t//",
            "wire [31:0]\t\t\to_prof_addr;",
            "wire [ADDRESS_WIDTH-1:0]\to_prof_addr;",
            "wire [31:0]\t\t\to_prof_ticks;",
            "reg i_aclk, i_aresetn, reset_pipe;\n\t// }}}\n`endif\n\n\t// Watchdog timer\n\t// {{{",
            "localparam TB_WATCHDOG_TIMEOUT = 1_000_00;\t// 1ms",
            "reg [$clog2(TB_WATCHDOG_TIMEOUT+2)-1:0]\twatchdog_counter;\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Traditional TB support\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n`ifndef\tVERILATOR\n\tinitial\ti_aclk = 0;\n\talways\n\t\t#5 i_aclk = !i_aclk;\n\n\tinitial\t{ i_aresetn, reset_pipe } = 0;\n\talways @(posedge i_aclk)\n\t\t{ i_aresetn, reset_pipe } <= { reset_pipe, 1'b1 };\n\n\t// Tie off (unused) Sim control",
            "input (s)\n\t// {{{\n\tassign\tsim_awvalid = 1'b0;\n\tassign\tsim_awaddr  = 0;\n\tassign\tsim_awprot  = 0;\n\n\tassign\tsim_wvalid  = 1'b0;\n\tassign\tsim_wdata   = 0;\n\tassign\tsim_wstrb   = 0;\n\n\tassign\tsim_bready  = 1'b1;\n\n\tassign\tsim_arvalid = 1'b0;\n\tassign\tsim_araddr  = 0;\n\tassign\tsim_arprot  = 0;\n\n\tassign\tsim_rready  = 1'b1;\n\t// }}}\n\tassign\ti_sim_int  = 1'b0;\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// External sim port: Either controls ZipCPU or wide WB bus\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n`ifdef\tVERILATOR\n\t// Only required if we are using Verilator.  Other test benches won't\n\t// use this",
            "input port",
            "wire simsub_arvalid, simsub_arready;",
            "wire [31:0]\tsimsub_wdata, simsub_rdata;",
            "wire [3:0]\tsimsub_wstrb;\n\n\taxilxbar #(\n\t\t// {{{\n\t\t.NM(1), .NS(2),\n\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH+1),\n\t\t.C_AXI_DATA_WIDTH(32),\n\t\t.SLAVE_ADDR({\n\t\t\t{ 1'b0, {(ADDRESS_WIDTH){1'b0}} },\n\t\t\t{ 1'b1, {(ADDRESS_WIDTH){1'b0}} }}), // CPU\n\t\t.SLAVE_MASK({\n\t\t\t{ 1'b0, {(ADDRESS_WIDTH){1'b0}} },\n\t\t\t{ 1'b1, {(ADDRESS_WIDTH){1'b0}} }})  // CPU\n\t\t// }}}\n\t) simxbar (\n\t\t// {{{\n\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t// One master: the SIM bus",
            "input // {{{\n\t\t.S_AXI_AWVALID(sim_awvalid),\n\t\t.S_AXI_AWREADY(sim_awready),\n\t\t.S_AXI_AWADDR(sim_awaddr),\n\t\t.S_AXI_AWPROT(sim_awprot),\n\t\t//\n\t\t.S_AXI_WVALID(sim_wvalid),\n\t\t.S_AXI_WREADY(sim_wready),\n\t\t.S_AXI_WDATA(sim_wdata),\n\t\t.S_AXI_WSTRB(sim_wstrb),\n\t\t//\n\t\t.S_AXI_BVALID(sim_bvalid),\n\t\t.S_AXI_BREADY(sim_bready),\n\t\t.S_AXI_BRESP(sim_bresp),\n\t\t//\n\t\t.S_AXI_ARVALID(sim_arvalid),\n\t\t.S_AXI_ARREADY(sim_arready),\n\t\t.S_AXI_ARADDR(sim_araddr),\n\t\t.S_AXI_ARPROT(sim_arprot),\n\t\t//\n\t\t.S_AXI_RVALID(sim_rvalid),\n\t\t.S_AXI_RREADY(sim_rready),\n\t\t.S_AXI_RDATA(sim_rdata),\n\t\t.S_AXI_RRESP(sim_rresp),\n\t\t// }}}\n\t\t// Two slaves: The wide bus the ZipCPU masters, and the ZipCPU's\n\t\t// debug port\n\t\t// {{{\n\t\t.M_AXI_AWVALID({ simfull_awvalid, dbg_awvalid }),\n\t\t.M_AXI_AWREADY({ simfull_awready, dbg_awready }),\n\t\t.M_AXI_AWADDR({  simwide_awaddr,  dbg_awaddr  }),\n\t\t.M_AXI_AWPROT({  simfull_awprot,  dbg_awprot }),\n\t\t//\n\t\t.M_AXI_WVALID({ simfull_wvalid, dbg_wvalid }),\n\t\t.M_AXI_WREADY({ simfull_wready, dbg_wready }),\n\t\t.M_AXI_WDATA({  simsub_wdata,  dbg_wdata }),\n\t\t.M_AXI_WSTRB({  simsub_wstrb,  dbg_wstrb }),\n\t\t//\n\t\t.M_AXI_BVALID({ simfull_bvalid, dbg_bvalid }),\n\t\t.M_AXI_BREADY({ simfull_bready, dbg_bready }),\n\t\t.M_AXI_BRESP({  simfull_bresp,  dbg_bresp }),\n\t\t//\n\t\t.M_AXI_ARVALID({ simsub_arvalid, dbg_arvalid }),\n\t\t.M_AXI_ARREADY({ simsub_arready, dbg_arready }),\n\t\t.M_AXI_ARADDR({  simwide_araddr,  dbg_araddr }),\n\t\t.M_AXI_ARPROT({  simfull_arprot,  dbg_arprot }),\n\t\t//\n\t\t.M_AXI_RVALID({ simfull_rvalid, dbg_rvalid }),\n\t\t.M_AXI_RREADY({ simfull_rready, dbg_rready }),\n\t\t.M_AXI_RDATA({  simsub_rdata,  dbg_rdata }),\n\t\t.M_AXI_RRESP({  simfull_rresp,  dbg_rresp })\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\tassign\tsimfull_awid    = 0;\n\tassign\tsimfull_awaddr  = simwide_awaddr[ADDRESS_WIDTH-1:0];\n\tassign\tsimfull_awlen   = 0;\n\tassign\tsimfull_awsize  = 3'h2;\n\tassign\tsimfull_awburst = 2'b01;\n\tassign\tsimfull_awlock  = 1'b0;\n\tassign\tsimfull_awcache = 4'h3;\n\tassign\tsimfull_awqos   = 0;\n\n\tassign\tsimfull_wdata = {(BUS_WIDTH/32){simsub_wdata}};\n\tgenerate if (BUS_WIDTH == 32)\n\tbegin : GEN_SIMFULL\n\t\tassign\tsimfull_wstrb = simsub_wstrb;\n\tend else begin : GEN_SIMWIDE\n\t\tassign\tsimfull_wstrb = { {((BUS_WIDTH-32)/8){1'b0}},\n\t\t\t\t\t\t\tsimsub_wstrb }\n\t\t\t\t<< (simfull_awaddr[$clog2(BUS_WIDTH/8)-1:2]*4);\n\tend endgenerate\n\tassign\tsimfull_wlast   = 1;\n\n\tassign\tsimfull_arid    = 0;\n\tassign\tsimfull_araddr  = simwide_araddr[ADDRESS_WIDTH-1:0];\n\tassign\tsimfull_arlen   = 0;\n\tassign\tsimfull_arsize  = 3'h2;\n\tassign\tsimfull_arburst = 2'b01;\n\tassign\tsimfull_arlock  = 1'b0;\n\tassign\tsimfull_arcache = 4'h3;\n\tassign\tsimfull_arqos   = 0;\n\n\tgenerate if (BUS_WIDTH == 32)\n\tbegin : NO_RETURN_DATA_SHIFT\n\n\t\tassign\tsimfull_arvalid = simsub_arvalid;\n\t\tassign\tsimsub_arready  = simfull_arready;\n\t\tassign\tsimsub_rdata    = simfull_rdata;\n\n\tend else begin : SHIFT_RETURN_DATA\n\t\t// {{{",
            "localparam LGFIFO = 5;",
            "wire rfif_full, rfif_empty;",
            "wire [$clog2(BUS_WIDTH/32)-1:0]\trfif_shift;",
            "wire [LGFIFO:0]\t\t\trfif_fill;",
            "wire [BUS_WIDTH-1:0]\t\t\tshifted_rdata;\n\n\t\tsfifo #(\n\t\t\t.LGFLEN(LGFIFO),\n\t\t\t.BW($clog2(BUS_WIDTH/32))\n\t\t) rdata_addr_fifo (\n\t\t\t.i_clk(i_aclk), .i_reset(!i_aresetn),\n\t\t\t.i_wr(simfull_arvalid && simfull_arready),\n\t\t\t.i_data(simfull_araddr[$clog2(BUS_WIDTH/32)+1:2]),\n\t\t\t\t.o_full(rfif_full), .o_fill(rfif_fill),\n\t\t\t.i_rd(simfull_rvalid && simfull_rready),\n\t\t\t\t.o_data(rfif_shift), .o_empty(rfif_empty)\n\t\t);\n\n\t\tassign\tshifted_rdata = simfull_rdata >> (rfif_shift*32);\n\t\tassign\tsimsub_rdata = shifted_rdata[31:0];\n\t\tassign\tsimfull_arvalid = simsub_arvalid && !rfif_full;\n\t\tassign\tsimsub_arready  = !rfif_full && simfull_arready;\n\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_rfif;\n\t\tassign\tunused_rfif = &{ 1'b0, rfif_fill, rfif_empty,\n\t\t\t\t\tshifted_rdata[BUS_WIDTH-1:32] };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused_sim;\n\tassign\tunused_sim = &{ 1'b0,\n\t\t\t\tsimwide_awaddr[ADDRESS_WIDTH],\n\t\t\t\tsimwide_araddr[ADDRESS_WIDTH],\n\t\t\t\tsimfull_rlast, simfull_bid, simfull_rid,\n\t\t\t\tdbg_awaddr[AW:8], dbg_araddr[AW:8]\n\t\t\t};\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n`else\n\t// If we aren't using Verilator, then there's no external bus driver.\n\t// Cap off the debug port therefore.\n\t//\n\n\tassign\tdbg_awvalid= 1'b0;\n\tassign\tdbg_awaddr = 0;\n\tassign\tdbg_awprot = 0;\n\n\tassign\tdbg_wvalid= 1'b0;\n\tassign\tdbg_wdata = 0;\n\tassign\tdbg_wstrb = 0;\n\n\tassign\tdbg_bready = 1'b0;\n\n\tassign\tdbg_arvalid= 1'b0;\n\tassign\tdbg_araddr = 0;\n\tassign\tdbg_arprot = 0;\n\n\tassign\tdbg_rready = 1'b0;\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The CPU itself\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_ZIPAXIL)\n\tbegin : GEN_ZIPAXIL\n\t\t// Local declarations\n\t\t// {{{",
            "wire cpuil_awvalid, cpuil_awready;",
            "wire [AW-1:0]\tcpuil_awaddr;",
            "wire [2:0]\t\tcpuil_awprot;",
            "wire cpuil_wvalid, cpuil_wready;",
            "wire [BUS_WIDTH-1:0]\tcpuil_wdata;",
            "wire [BUS_WIDTH/8-1:0]\tcpuil_wstrb;",
            "wire cpuil_bvalid, cpuil_bready;",
            "wire [1:0]\t\tcpuil_bresp;",
            "wire cpuil_arvalid, cpuil_arready;",
            "wire [AW-1:0]\tcpuil_araddr;",
            "wire [2:0]\t\tcpuil_arprot;",
            "wire cpuil_rvalid, cpuil_rready;",
            "wire [BUS_WIDTH-1:0]\tcpuil_rdata;",
            "wire [1:0]\t\tcpuil_rresp;\n\t\t//",
            "wire cpudl_awvalid, cpudl_awready;",
            "wire [AW-1:0]\tcpudl_awaddr;",
            "wire [2:0]\t\tcpudl_awprot;",
            "wire cpudl_wvalid, cpudl_wready;",
            "wire [BUS_WIDTH-1:0]\tcpudl_wdata;",
            "wire [BUS_WIDTH/8-1:0]\tcpudl_wstrb;",
            "wire cpudl_bvalid, cpudl_bready;",
            "wire [1:0]\t\tcpudl_bresp;",
            "wire cpudl_arvalid, cpudl_arready;",
            "wire [AW-1:0]\tcpudl_araddr;",
            "wire [2:0]\t\tcpudl_arprot;",
            "wire cpudl_rvalid, cpudl_rready;",
            "wire [BUS_WIDTH-1:0]\tcpudl_rdata;",
            "wire [1:0]\t\tcpudl_rresp;\n\t\t// }}}\n\n\t\tzipaxil #(\n\t\t\t// {{{\n\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t\t.RESET_ADDRESS(RESET_ADDRESS[ADDRESS_WIDTH-1:0]),\n\t\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t\t.C_AXI_DATA_WIDTH(BUS_WIDTH),\n\t\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t\t.OPT_LGICACHE(OPT_LGICACHE),\n\t\t\t.OPT_LGDCACHE(OPT_LGDCACHE),\n\t\t\t.START_HALTED(1'b0),\n\t\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t\t.OPT_MPY(OPT_MPY),\n\t\t\t.OPT_DIV(OPT_DIV),\n\t\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t\t.OPT_LOCK(OPT_LOCK),\n\t\t\t.OPT_CIS(OPT_CIS),\n\t\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t\t.OPT_DBGPORT(OPT_DBGPORT),\n\t\t\t.OPT_TRACE_PORT(OPT_TRACE_PORT),\n\t\t\t.OPT_PROFILER(OPT_PROFILER),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_SIM(OPT_SIM),\n\t\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t\t.RESET_DURATION(RESET_DURATION)\n\t\t\t// }}}\n\t\t) u_cpu (\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t\t.i_interrupt(pic_interrupt),\n\t\t\t.i_cpu_reset(!i_aresetn || watchdog_reset),\n\t\t\t// Debug control port\n\t\t\t// {{{\n\t\t\t.S_DBG_AWVALID(dbg_awvalid),\n\t\t\t.S_DBG_AWREADY(dbg_awready),\n\t\t\t.S_DBG_AWADDR(dbg_awaddr[7:0]),\n\t\t\t.S_DBG_AWPROT(dbg_awprot),\n\t\t\t//\n\t\t\t.S_DBG_WVALID(dbg_wvalid),\n\t\t\t.S_DBG_WREADY(dbg_wready),\n\t\t\t.S_DBG_WDATA( dbg_wdata),\n\t\t\t.S_DBG_WSTRB( dbg_wstrb),\n\t\t\t//\n\t\t\t.S_DBG_BVALID(dbg_bvalid),\n\t\t\t.S_DBG_BREADY(dbg_bready),\n\t\t\t.S_DBG_BRESP( dbg_bresp),\n\t\t\t//\n\t\t\t.S_DBG_ARVALID(dbg_arvalid),\n\t\t\t.S_DBG_ARREADY(dbg_arready),\n\t\t\t.S_DBG_ARADDR(dbg_araddr[7:0]),\n\t\t\t.S_DBG_ARPROT(dbg_arprot),\n\t\t\t//\n\t\t\t.S_DBG_RVALID(dbg_rvalid),\n\t\t\t.S_DBG_RREADY(dbg_rready),\n\t\t\t.S_DBG_RDATA( dbg_rdata),\n\t\t\t.S_DBG_RRESP( dbg_rresp),\n\t\t\t// }}}\n\t\t\t// Master instruction bus\n\t\t\t// {{{\n\t\t\t.M_INSN_AWVALID(cpuil_awvalid),\n\t\t\t.M_INSN_AWREADY(cpuil_awready),\n\t\t\t.M_INSN_AWADDR(cpuil_awaddr),\n\t\t\t.M_INSN_AWPROT(cpuil_awprot),\n\t\t\t//\n\t\t\t.M_INSN_WVALID(cpuil_wvalid),\n\t\t\t.M_INSN_WREADY(cpuil_wready),\n\t\t\t.M_INSN_WDATA( cpuil_wdata),\n\t\t\t.M_INSN_WSTRB( cpuil_wstrb),\n\t\t\t//\n\t\t\t.M_INSN_BVALID(cpuil_bvalid),\n\t\t\t.M_INSN_BREADY(cpuil_bready),\n\t\t\t.M_INSN_BRESP( cpuil_bresp),\n\t\t\t//\n\t\t\t.M_INSN_ARVALID(cpuil_arvalid),\n\t\t\t.M_INSN_ARREADY(cpuil_arready),\n\t\t\t.M_INSN_ARADDR( cpuil_araddr),\n\t\t\t.M_INSN_ARPROT( cpuil_arprot),\n\t\t\t//\n\t\t\t.M_INSN_RVALID(cpuil_rvalid),\n\t\t\t.M_INSN_RREADY(cpuil_rready),\n\t\t\t.M_INSN_RDATA( cpuil_rdata),\n\t\t\t.M_INSN_RRESP( cpuil_rresp),\n\t\t\t// }}}\n\t\t\t// Master data bus\n\t\t\t// {{{\n\t\t\t.M_DATA_AWVALID(cpudl_awvalid),\n\t\t\t.M_DATA_AWREADY(cpudl_awready),\n\t\t\t.M_DATA_AWADDR( cpudl_awaddr),\n\t\t\t.M_DATA_AWPROT( cpudl_awprot),\n\t\t\t//\n\t\t\t.M_DATA_WVALID(cpudl_wvalid),\n\t\t\t.M_DATA_WREADY(cpudl_wready),\n\t\t\t.M_DATA_WDATA( cpudl_wdata),\n\t\t\t.M_DATA_WSTRB( cpudl_wstrb),\n\t\t\t//\n\t\t\t.M_DATA_BVALID(cpudl_bvalid),\n\t\t\t.M_DATA_BREADY(cpudl_bready),\n\t\t\t.M_DATA_BRESP( cpudl_bresp),\n\t\t\t//\n\t\t\t.M_DATA_ARVALID(cpudl_arvalid),\n\t\t\t.M_DATA_ARREADY(cpudl_arready),\n\t\t\t.M_DATA_ARADDR( cpudl_araddr),\n\t\t\t.M_DATA_ARPROT( cpudl_arprot),\n\t\t\t//\n\t\t\t.M_DATA_RVALID(cpudl_rvalid),\n\t\t\t.M_DATA_RREADY(cpudl_rready),\n\t\t\t.M_DATA_RDATA( cpudl_rdata),\n\t\t\t.M_DATA_RRESP( cpudl_rresp),\n\t\t\t// }}}\n\t\t\t.o_cpu_debug(cpu_trace),\n\t\t\t// Accounting",
            "output s\n\t\t\t// {{{\n\t\t\t.o_cmd_reset(cpu_reset[0]),\n\t\t\t.o_halted(   cpu_halted[0]),\n\t\t\t.o_gie(      cpu_gie[0]),\n\t\t\t.o_op_stall( cpu_op_stall[0]),\n\t\t\t.o_pf_stall( cpu_pf_stall[0]),\n\t\t\t.o_i_count(  cpu_i_count[0]),\n\t\t\t// }}}\n\t\t\t// (Optional) Profiler\n\t\t\t// {{{\n\t\t\t.o_prof_stb(  o_prof_stb),\n\t\t\t.o_prof_addr( o_prof_addr),\n\t\t\t.o_prof_ticks(o_prof_ticks)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\taxilite2axi #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t.C_AXI_DATA_WIDTH(BUS_WIDTH)\n\t\t\t// }}}\n\t\t) u_iaxi (\n\t\t\t.ACLK(i_aclk), .ARESETN(i_aresetn),\n\t\t\t// Slave interface, from CPU\n\t\t\t// {{{\n\t\t\t.S_AXI_AWVALID(cpuil_awvalid),\n\t\t\t.S_AXI_AWREADY(cpuil_awready),\n\t\t\t.S_AXI_AWADDR( cpuil_awaddr),\n\t\t\t.S_AXI_AWPROT( cpuil_awprot),\n\n\t\t\t.S_AXI_WVALID(cpuil_wvalid),\n\t\t\t.S_AXI_WREADY(cpuil_wready),\n\t\t\t.S_AXI_WDATA( cpuil_wdata),\n\t\t\t.S_AXI_WSTRB( cpuil_wstrb),\n\n\t\t\t.S_AXI_BVALID(cpuil_bvalid),\n\t\t\t.S_AXI_BREADY(cpuil_bready),\n\t\t\t.S_AXI_BRESP( cpuil_bresp),\n\n\t\t\t.S_AXI_ARVALID(cpuil_arvalid),\n\t\t\t.S_AXI_ARREADY(cpuil_arready),\n\t\t\t.S_AXI_ARADDR( cpuil_araddr),\n\t\t\t.S_AXI_ARPROT( cpuil_arprot),\n\n\t\t\t.S_AXI_RVALID(cpuil_rvalid),\n\t\t\t.S_AXI_RREADY(cpuil_rready),\n\t\t\t.S_AXI_RDATA( cpuil_rdata),\n\t\t\t.S_AXI_RRESP( cpuil_rresp),\n\t\t\t// }}}\n\t\t\t// Master interface, to the bus\n\t\t\t// {{{\n\t\t\t.M_AXI_AWVALID(cpui_awvalid[0]),\n\t\t\t.M_AXI_AWREADY(cpui_awready[0]),\n\t\t\t.M_AXI_AWID(   cpui_awid[IW-1:0]),\n\t\t\t.M_AXI_AWADDR( cpui_awaddr[AW-1:0]),\n\t\t\t.M_AXI_AWLEN(  cpui_awlen[7:0]),\n\t\t\t.M_AXI_AWSIZE( cpui_awsize[2:0]),\n\t\t\t.M_AXI_AWBURST(cpui_awburst[1:0]),\n\t\t\t.M_AXI_AWLOCK( cpui_awlock[0]),\n\t\t\t.M_AXI_AWCACHE(cpui_awcache[3:0]),\n\t\t\t.M_AXI_AWPROT( cpui_awprot[2:0]),\n\t\t\t.M_AXI_AWQOS(  cpui_awqos[3:0]),\n\n\t\t\t.M_AXI_WVALID(cpui_wvalid[0]),\n\t\t\t.M_AXI_WREADY(cpui_wready[0]),\n\t\t\t.M_AXI_WDATA( cpui_wdata[BUS_WIDTH-1:0]),\n\t\t\t.M_AXI_WSTRB( cpui_wstrb[BUS_WIDTH/8-1:0]),\n\t\t\t.M_AXI_WLAST( cpui_wlast[0]),\n\n\t\t\t.M_AXI_BVALID(cpui_bvalid[0]),\n\t\t\t.M_AXI_BREADY(cpui_bready[0]),\n\t\t\t.M_AXI_BID(   cpui_bid[IW-1:0]),\n\t\t\t.M_AXI_BRESP( cpui_bresp[1:0]),\n\n\t\t\t.M_AXI_ARVALID(cpui_arvalid[0]),\n\t\t\t.M_AXI_ARREADY(cpui_arready[0]),\n\t\t\t.M_AXI_ARID(   cpui_arid[IW-1:0]),\n\t\t\t.M_AXI_ARADDR( cpui_araddr[AW-1:0]),\n\t\t\t.M_AXI_ARLEN(  cpui_arlen[7:0]),\n\t\t\t.M_AXI_ARSIZE( cpui_arsize[2:0]),\n\t\t\t.M_AXI_ARBURST(cpui_arburst[1:0]),\n\t\t\t.M_AXI_ARLOCK( cpui_arlock[0]),\n\t\t\t.M_AXI_ARCACHE(cpui_arcache[3:0]),\n\t\t\t.M_AXI_ARPROT( cpui_arprot[2:0]),\n\t\t\t.M_AXI_ARQOS(  cpui_arqos[3:0]),\n\n\t\t\t.M_AXI_RVALID(cpui_rvalid[0]),\n\t\t\t.M_AXI_RREADY(cpui_rready[0]),\n\t\t\t.M_AXI_RID(   cpui_rid[IW-1:0]),\n\t\t\t.M_AXI_RDATA( cpui_rdata[BUS_WIDTH-1:0]),\n\t\t\t.M_AXI_RLAST( cpui_rlast[0]),\n\t\t\t.M_AXI_RRESP( cpui_rresp[1:0])\n\t\t\t// }}}\n\t\t);\n\n\t\taxilite2axi #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t.C_AXI_DATA_WIDTH(BUS_WIDTH)\n\t\t\t// }}}\n\t\t) u_daxi (\n\t\t\t.ACLK(i_aclk), .ARESETN(i_aresetn),\n\t\t\t// Slave interface, from CPU\n\t\t\t// {{{\n\t\t\t.S_AXI_AWVALID(cpudl_awvalid),\n\t\t\t.S_AXI_AWREADY(cpudl_awready),\n\t\t\t.S_AXI_AWADDR( cpudl_awaddr),\n\t\t\t.S_AXI_AWPROT( cpudl_awprot),\n\n\t\t\t.S_AXI_WVALID(cpudl_wvalid),\n\t\t\t.S_AXI_WREADY(cpudl_wready),\n\t\t\t.S_AXI_WDATA( cpudl_wdata),\n\t\t\t.S_AXI_WSTRB( cpudl_wstrb),\n\n\t\t\t.S_AXI_BVALID(cpudl_bvalid),\n\t\t\t.S_AXI_BREADY(cpudl_bready),\n\t\t\t.S_AXI_BRESP( cpudl_bresp),\n\n\t\t\t.S_AXI_ARVALID(cpudl_arvalid),\n\t\t\t.S_AXI_ARREADY(cpudl_arready),\n\t\t\t.S_AXI_ARADDR( cpudl_araddr),\n\t\t\t.S_AXI_ARPROT( cpudl_arprot),\n\n\t\t\t.S_AXI_RVALID(cpudl_rvalid),\n\t\t\t.S_AXI_RREADY(cpudl_rready),\n\t\t\t.S_AXI_RDATA( cpudl_rdata),\n\t\t\t.S_AXI_RRESP( cpudl_rresp),\n\t\t\t// }}}\n\t\t\t// Master interface, to the bus\n\t\t\t// {{{\n\t\t\t.M_AXI_AWVALID(cpud_awvalid[0]),\n\t\t\t.M_AXI_AWREADY(cpud_awready[0]),\n\t\t\t.M_AXI_AWID(   cpud_awid[IW-1:0]),\n\t\t\t.M_AXI_AWADDR( cpud_awaddr[AW-1:0]),\n\t\t\t.M_AXI_AWLEN(  cpud_awlen[7:0]),\n\t\t\t.M_AXI_AWSIZE( cpud_awsize[2:0]),\n\t\t\t.M_AXI_AWBURST(cpud_awburst[1:0]),\n\t\t\t.M_AXI_AWLOCK( cpud_awlock[0]),\n\t\t\t.M_AXI_AWCACHE(cpud_awcache[3:0]),\n\t\t\t.M_AXI_AWPROT( cpud_awprot[2:0]),\n\t\t\t.M_AXI_AWQOS(  cpud_awqos[3:0]),\n\n\t\t\t.M_AXI_WVALID(cpud_wvalid[0]),\n\t\t\t.M_AXI_WREADY(cpud_wready[0]),\n\t\t\t.M_AXI_WDATA( cpud_wdata[BUS_WIDTH-1:0]),\n\t\t\t.M_AXI_WSTRB( cpud_wstrb[BUS_WIDTH/8-1:0]),\n\t\t\t.M_AXI_WLAST( cpud_wlast[0]),\n\n\t\t\t.M_AXI_BVALID(cpud_bvalid[0]),\n\t\t\t.M_AXI_BREADY(cpud_bready[0]),\n\t\t\t.M_AXI_BID(   cpud_bid[IW-1:0]),\n\t\t\t.M_AXI_BRESP( cpud_bresp[1:0]),\n\n\t\t\t.M_AXI_ARVALID(cpud_arvalid[0]),\n\t\t\t.M_AXI_ARREADY(cpud_arready[0]),\n\t\t\t.M_AXI_ARID(   cpud_arid[IW-1:0]),\n\t\t\t.M_AXI_ARADDR( cpud_araddr[AW-1:0]),\n\t\t\t.M_AXI_ARLEN(  cpud_arlen[7:0]),\n\t\t\t.M_AXI_ARSIZE( cpud_arsize[2:0]),\n\t\t\t.M_AXI_ARBURST(cpud_arburst[1:0]),\n\t\t\t.M_AXI_ARLOCK( cpud_arlock[0]),\n\t\t\t.M_AXI_ARCACHE(cpud_arcache[3:0]),\n\t\t\t.M_AXI_ARPROT( cpud_arprot[2:0]),\n\t\t\t.M_AXI_ARQOS(  cpud_arqos[3:0]),\n\n\t\t\t.M_AXI_RVALID(cpud_rvalid[0]),\n\t\t\t.M_AXI_RREADY(cpud_rready[0]),\n\t\t\t.M_AXI_RID(   cpud_rid[IW-1:0]),\n\t\t\t.M_AXI_RDATA( cpud_rdata[BUS_WIDTH-1:0]),\n\t\t\t.M_AXI_RLAST( cpud_rlast[0]),\n\t\t\t.M_AXI_RRESP( cpud_rresp[1:0])\n\t\t\t// }}}\n\t\t);\n\n\tend else begin : GEN_ZIPAXI\n\n\t\tzipaxi #(\n\t\t\t// {{{\n\t\t\t.RESET_ADDRESS(RESET_ADDRESS[ADDRESS_WIDTH-1:0]),\n\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_DATA_WIDTH(BUS_WIDTH),\n\t\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t\t.OPT_LGICACHE(OPT_LGICACHE),\n\t\t\t.OPT_LGDCACHE(OPT_LGDCACHE),\n\t\t\t.START_HALTED(1'b0),\n\t\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t\t.OPT_MPY(OPT_MPY),\n\t\t\t.OPT_DIV(OPT_DIV),\n\t\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t\t.OPT_LOCK(OPT_LOCK),\n\t\t\t.OPT_CIS(OPT_CIS),\n\t\t\t.OPT_WRAP(OPT_WRAP),\n\t\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t\t.OPT_DBGPORT(OPT_DBGPORT),\n\t\t\t.OPT_TRACE_PORT(OPT_TRACE_PORT),\n\t\t\t.OPT_PROFILER(OPT_PROFILER),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_SIM(OPT_SIM),\n\t\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t\t.RESET_DURATION(RESET_DURATION)\n\t\t\t// }}}\n\t\t) u_cpu (\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t\t.i_interrupt(pic_interrupt),\n\t\t\t.i_cpu_reset(!i_aresetn || watchdog_reset),\n\t\t\t// Debug control port\n\t\t\t// {{{\n\t\t\t.S_DBG_AWVALID(dbg_awvalid),\n\t\t\t.S_DBG_AWREADY(dbg_awready),\n\t\t\t.S_DBG_AWADDR(dbg_awaddr[7:0]),\n\t\t\t.S_DBG_AWPROT(dbg_awprot),\n\t\t\t//\n\t\t\t.S_DBG_WVALID(dbg_wvalid),\n\t\t\t.S_DBG_WREADY(dbg_wready),\n\t\t\t.S_DBG_WDATA( dbg_wdata),\n\t\t\t.S_DBG_WSTRB( dbg_wstrb),\n\t\t\t//\n\t\t\t.S_DBG_BVALID(dbg_bvalid),\n\t\t\t.S_DBG_BREADY(dbg_bready),\n\t\t\t.S_DBG_BRESP( dbg_bresp),\n\t\t\t//\n\t\t\t.S_DBG_ARVALID(dbg_arvalid),\n\t\t\t.S_DBG_ARREADY(dbg_arready),\n\t\t\t.S_DBG_ARADDR(dbg_araddr[7:0]),\n\t\t\t.S_DBG_ARPROT(dbg_arprot),\n\t\t\t//\n\t\t\t.S_DBG_RVALID(dbg_rvalid),\n\t\t\t.S_DBG_RREADY(dbg_rready),\n\t\t\t.S_DBG_RDATA( dbg_rdata),\n\t\t\t.S_DBG_RRESP( dbg_rresp),\n\t\t\t// }}}\n\t\t\t// Master instruction bus\n\t\t\t// {{{\n\t\t\t.M_INSN_AWVALID(cpui_awvalid[0]),\n\t\t\t.M_INSN_AWREADY(cpui_awready[0]),\n\t\t\t.M_INSN_AWID(   cpui_awid[   0 +: IW]),\n\t\t\t.M_INSN_AWADDR( cpui_awaddr[ 0 +: AW]),\n\t\t\t.M_INSN_AWLEN(  cpui_awlen[  0 +: 8]),\n\t\t\t.M_INSN_AWSIZE( cpui_awsize[ 0 +: 3]),\n\t\t\t.M_INSN_AWBURST(cpui_awburst[0 +: 2]),\n\t\t\t.M_INSN_AWLOCK( cpui_awlock[ 0]),\n\t\t\t.M_INSN_AWCACHE(cpui_awcache[0 +: 4]),\n\t\t\t.M_INSN_AWPROT( cpui_awprot[ 0 +: 3]),\n\t\t\t.M_INSN_AWQOS(  cpui_awqos[  0 +: 4]),\n\t\t\t//\n\t\t\t.M_INSN_WVALID(cpui_wvalid[0]),\n\t\t\t.M_INSN_WREADY(cpui_wready[0]),\n\t\t\t.M_INSN_WDATA( cpui_wdata[0 +: BUS_WIDTH]),\n\t\t\t.M_INSN_WSTRB( cpui_wstrb[0 +: BUS_WIDTH/8]),\n\t\t\t.M_INSN_WLAST( cpui_wlast[0]),\n\t\t\t//\n\t\t\t.M_INSN_BVALID(cpui_bvalid[0]),\n\t\t\t.M_INSN_BREADY(cpui_bready[0]),\n\t\t\t.M_INSN_BID(   cpui_bid[  0*IW +: IW]),\n\t\t\t.M_INSN_BRESP( cpui_bresp[0*2  +: 2]),\n\t\t\t//\n\t\t\t.M_INSN_ARVALID(cpui_arvalid[0]),\n\t\t\t.M_INSN_ARREADY(cpui_arready[0]),\n\t\t\t.M_INSN_ARID(   cpui_arid[   0*IW +: IW]),\n\t\t\t.M_INSN_ARADDR( cpui_araddr[ 0*AW +: AW]),\n\t\t\t.M_INSN_ARLEN(  cpui_arlen[  0 *8 +: 8]),\n\t\t\t.M_INSN_ARSIZE( cpui_arsize[ 0 *3 +: 3]),\n\t\t\t.M_INSN_ARBURST(cpui_arburst[0 *2 +: 2]),\n\t\t\t.M_INSN_ARLOCK( cpui_arlock[ 0]),\n\t\t\t.M_INSN_ARCACHE(cpui_arcache[0 *4 +: 4]),\n\t\t\t.M_INSN_ARPROT( cpui_arprot[ 0 *3 +: 3]),\n\t\t\t.M_INSN_ARQOS(  cpui_arqos[  0 *4 +: 4]),\n\t\t\t//\n\t\t\t.M_INSN_RVALID(cpui_rvalid[0]),\n\t\t\t.M_INSN_RREADY(cpui_rready[0]),\n\t\t\t.M_INSN_RID(   cpui_rid[0*IW +: IW]),\n\t\t\t.M_INSN_RDATA( cpui_rdata[0*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t.M_INSN_RLAST( cpui_rlast[0]),\n\t\t\t.M_INSN_RRESP( cpui_rresp[0 *2 +: 2]),\n\t\t\t// }}}\n\t\t\t// Master data bus\n\t\t\t// {{{\n\t\t\t.M_DATA_AWVALID(cpud_awvalid[0]),\n\t\t\t.M_DATA_AWREADY(cpud_awready[0]),\n\t\t\t.M_DATA_AWID(   cpud_awid[0*IW +: IW]),\n\t\t\t.M_DATA_AWADDR( cpud_awaddr[0*AW +: AW]),\n\t\t\t.M_DATA_AWLEN(  cpud_awlen[0*8 +: 8]),\n\t\t\t.M_DATA_AWSIZE( cpud_awsize[0*3 +: 3]),\n\t\t\t.M_DATA_AWBURST(cpud_awburst[0*2 +: 2]),\n\t\t\t.M_DATA_AWLOCK( cpud_awlock[0]),\n\t\t\t.M_DATA_AWCACHE(cpud_awcache[0*4 +: 4]),\n\t\t\t.M_DATA_AWPROT( cpud_awprot[0*3 +: 3]),\n\t\t\t.M_DATA_AWQOS(  cpud_awqos[0*4 +: 4]),\n\t\t\t//\n\t\t\t.M_DATA_WVALID(cpud_wvalid[0]),\n\t\t\t.M_DATA_WREADY(cpud_wready[0]),\n\t\t\t.M_DATA_WDATA( cpud_wdata[0*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t.M_DATA_WSTRB( cpud_wstrb[0*BUS_WIDTH/8 +: BUS_WIDTH/8]),\n\t\t\t.M_DATA_WLAST( cpud_wlast[0]),\n\t\t\t//\n\t\t\t.M_DATA_BVALID(cpud_bvalid[0]),\n\t\t\t.M_DATA_BREADY(cpud_bready[0]),\n\t\t\t.M_DATA_BID(   cpud_bid[0*IW +: IW]),\n\t\t\t.M_DATA_BRESP( cpud_bresp[0*2 +: 2]),\n\t\t\t//\n\t\t\t.M_DATA_ARVALID(cpud_arvalid[0]),\n\t\t\t.M_DATA_ARREADY(cpud_arready[0]),\n\t\t\t.M_DATA_ARID(   cpud_arid[0*IW +: IW]),\n\t\t\t.M_DATA_ARADDR( cpud_araddr[0*AW +: AW]),\n\t\t\t.M_DATA_ARLEN(  cpud_arlen[0*8 +: 8]),\n\t\t\t.M_DATA_ARSIZE( cpud_arsize[0*3 +: 3]),\n\t\t\t.M_DATA_ARBURST(cpud_arburst[0*2 +: 2]),\n\t\t\t.M_DATA_ARLOCK( cpud_arlock[0]),\n\t\t\t.M_DATA_ARCACHE(cpud_arcache[0*4 +: 4]),\n\t\t\t.M_DATA_ARPROT( cpud_arprot[0*3 +: 3]),\n\t\t\t.M_DATA_ARQOS(  cpud_arqos[0*4 +: 4]),\n\t\t\t//\n\t\t\t.M_DATA_RVALID(cpud_rvalid[0]),\n\t\t\t.M_DATA_RREADY(cpud_rready[0]),\n\t\t\t.M_DATA_RID(   cpud_rid[0*IW +: IW]),\n\t\t\t.M_DATA_RDATA( cpud_rdata[0*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t.M_DATA_RLAST( cpud_rlast[0]),\n\t\t\t.M_DATA_RRESP( cpud_rresp[0*2 +: 2]),\n\t\t\t// }}}\n\t\t\t.o_cpu_debug(cpu_trace),\n\t\t\t// Accounting",
            "output s\n\t\t\t// {{{\n\t\t\t.o_cmd_reset(cpu_reset[0]),\n\t\t\t.o_halted(   cpu_halted[0]),\n\t\t\t.o_gie(      cpu_gie[0]),\n\t\t\t.o_op_stall( cpu_op_stall[0]),\n\t\t\t.o_pf_stall( cpu_pf_stall[0]),\n\t\t\t.o_i_count(  cpu_i_count[0]),\n\t\t\t// }}}\n\t\t\t// (Optional) Profiler\n\t\t\t// {{{\n\t\t\t.o_prof_stb(  o_prof_stb),\n\t\t\t.o_prof_addr( o_prof_addr),\n\t\t\t.o_prof_ticks(o_prof_ticks)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\tend endgenerate\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Extra CPU's, if running in multiprocessor mode (OPT_SMP > 1)\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Nothing at the first SMP control address\n\t// {{{\n\taxiempty #(\n\t\t// {{{\n\t\t.C_AXI_ID_WIDTH(IW),\n\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t.C_AXI_DATA_WIDTH(BUS_WIDTH)\n\t\t// }}}\n\t) u_nosmp (\n\t\t// {{{\n\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t//\n\t\t.S_AXI_AWVALID(smpfull_awvalid[0]),\n\t\t.S_AXI_AWREADY(smpfull_awready[0]),\n\t\t.S_AXI_AWID(   smpfull_awid[IW-1:0]),\n\t\t// .S_AXI_AWADDR( smpfull_awaddr),\n\t\t// .S_AXI_AWLEN(  smpfull_awlen),\n\t\t// .S_AXI_AWSIZE( smpfull_awsize),\n\t\t// .S_AXI_AWBURST(smpfull_awburst),\n\t\t// .S_AXI_AWLOCK( smpfull_awlock),\n\t\t// .S_AXI_AWCACHE(smpfull_awcache),\n\t\t// .S_AXI_AWPROT( smpfull_awprot),\n\t\t// .S_AXI_AWQOS(  smpfull_awqos),\n\t\t//\n\t\t.S_AXI_WVALID(smpfull_wvalid[0]),\n\t\t.S_AXI_WREADY(smpfull_wready[0]),\n\t\t// .S_AXI_WDATA( smpfull_wdata),\n\t\t// .S_AXI_WSTRB( smpfull_wstrb),\n\t\t.S_AXI_WLAST( smpfull_wlast[0]),\n\t\t//\n\t\t.S_AXI_BVALID(smpfull_bvalid[0]),\n\t\t.S_AXI_BREADY(smpfull_bready[0]),\n\t\t.S_AXI_BID(   smpfull_bid[IW-1:0]),\n\t\t.S_AXI_BRESP( smpfull_bresp[1:0]),\n\t\t//\n\t\t.S_AXI_ARVALID(smpfull_arvalid[0]),\n\t\t.S_AXI_ARREADY(smpfull_arready[0]),\n\t\t.S_AXI_ARID(   smpfull_arid[IW-1:0]),\n\t\t// .S_AXI_ARADDR( smpfull_araddr),\n\t\t.S_AXI_ARLEN(  smpfull_arlen[7:0]),\n\t\t// .S_AXI_ARSIZE( smpfull_arsize),\n\t\t// .S_AXI_ARBURST(smpfull_arburst),\n\t\t// .S_AXI_ARLOCK( smpfull_arlock),\n\t\t// .S_AXI_ARCACHE(smpfull_arcache),\n\t\t// .S_AXI_ARPROT( smpfull_arprot),\n\t\t// .S_AXI_ARQOS(  smpfull_arqos),\n\t\t//\n\t\t.S_AXI_RVALID(smpfull_rvalid[0]),\n\t\t.S_AXI_RREADY(smpfull_rready[0]),\n\t\t.S_AXI_RID(   smpfull_rid[IW-1:0]),\n\t\t.S_AXI_RDATA( smpfull_rdata[BUS_WIDTH-1:0]),\n\t\t.S_AXI_RRESP( smpfull_rresp[1:0]),\n\t\t.S_AXI_RLAST( smpfull_rlast[0])\n\t\t// }}}\n\t);\n\n\t// Keep Verilator happy for this set\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused_base_smp;\n\tassign\tunused_base_smp = &{ 1'b0,\n\t\t\tsmpfull_awaddr[AW-1:0], smpfull_awlen[7:0],\n\t\t\tsmpfull_awsize[2:0],    smpfull_awburst[1:0],\n\t\t\tsmpfull_awlock[0],      smpfull_awcache[3:0],\n\t\t\tsmpfull_awprot[2:0],    smpfull_awqos[3:0],\n\t\t\tsmpfull_wdata[BUS_WIDTH-1:0],\n\t\t\t\t\t\tsmpfull_wstrb[BUS_WIDTH/8-1:0],\n\t\t\tsmpfull_araddr[AW-1:0],\n\t\t\tsmpfull_arsize[2:0],    smpfull_arburst[1:0],\n\t\t\tsmpfull_arlock[0],      smpfull_arcache[3:0],\n\t\t\tsmpfull_arprot[2:0],    smpfull_arqos[3:0]\n\t\t\t};\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n\n\t// }}}\n\n\tgenerate for(gk=1; gk<OPT_SMP; gk=gk+1)\n\tbegin : GEN_SMPCPU\n\t\t// Local declarations\n\t\t// {{{",
            "wire [31:0]\t\t\tsmp_trace;",
            "wire smp_prof_stb;",
            "wire [ADDRESS_WIDTH-1:0]\tsmp_prof_addr;",
            "wire [31:0]\t\t\tsmp_prof_ticks;",
            "wire smp_awvalid, smp_awready;",
            "wire [8-1:0]\t\tsmp_awaddr;",
            "wire [3-1:0]\t\tsmp_awprot;",
            "wire smp_wvalid, smp_wready;",
            "wire [32-1:0]\tsmp_wdata;",
            "wire [4-1:0]\t\tsmp_wstrb;",
            "wire smp_bvalid, smp_bready;",
            "wire [2-1:0]\t\tsmp_bresp;",
            "wire smp_arvalid, smp_arready;",
            "wire [8-1:0]\t\tsmp_araddr;",
            "wire [3-1:0]\t\tsmp_arprot;",
            "wire smp_rvalid, smp_rready;",
            "wire [32-1:0]\tsmp_rdata;",
            "wire [2-1:0]\t\tsmp_rresp;\n\t\t// }}}\n\n\t\taxi2axilsub #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_ADDR_WIDTH(8),\n\t\t\t.C_S_AXI_DATA_WIDTH(BUS_WIDTH),\n\t\t\t.C_M_AXI_DATA_WIDTH(32),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER), .OPT_WRITES(1), .OPT_READS(1)\n\t\t\t// }}}\n\t\t) u_smpdown (\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t\t// The \"Wide\" slave connection\n\t\t\t// {{{\n\t\t\t.S_AXI_AWVALID(smpfull_awvalid[ gk]),\n\t\t\t.S_AXI_AWREADY(smpfull_awready[ gk]),\n\t\t\t.S_AXI_AWID(   smpfull_awid[    gk*IW +: IW]),\n\t\t\t.S_AXI_AWADDR( smpfull_awaddr[  gk*AW +:  8]),\n\t\t\t.S_AXI_AWLEN(  smpfull_awlen[   gk*8  +:  8]),\n\t\t\t.S_AXI_AWSIZE( smpfull_awsize[  gk*3  +:  3]),\n\t\t\t.S_AXI_AWBURST(smpfull_awburst[ gk*2  +:  2]),\n\t\t\t.S_AXI_AWLOCK( smpfull_awlock[  gk]),\n\t\t\t.S_AXI_AWCACHE(smpfull_awcache[ gk*4  +:  4]),\n\t\t\t.S_AXI_AWPROT( smpfull_awprot[  gk*3  +:  3]),\n\t\t\t.S_AXI_AWQOS(  smpfull_awqos[   gk*4  +:  4]),\n\n\t\t\t.S_AXI_WVALID(smpfull_wvalid[gk]),\n\t\t\t.S_AXI_WREADY(smpfull_wready[gk]),\n\t\t\t.S_AXI_WDATA( smpfull_wdata[ gk*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t.S_AXI_WSTRB( smpfull_wstrb[ gk*BUS_WIDTH/8 +: BUS_WIDTH/8]),\n\t\t\t.S_AXI_WLAST( smpfull_wlast[ gk]),\n\n\t\t\t.S_AXI_BVALID(smpfull_bvalid[gk]),\n\t\t\t.S_AXI_BREADY(smpfull_bready[gk]),\n\t\t\t.S_AXI_BID(   smpfull_bid[gk*IW +: IW]),\n\t\t\t.S_AXI_BRESP( smpfull_bresp[gk*2 +: 2]),\n\n\t\t\t.S_AXI_ARVALID(smpfull_arvalid[gk]),\n\t\t\t.S_AXI_ARREADY(smpfull_arready[gk]),\n\t\t\t.S_AXI_ARID(   smpfull_arid[   gk*IW +: IW]),\n\t\t\t.S_AXI_ARADDR( smpfull_araddr[ gk*AW +: 8]),\n\t\t\t.S_AXI_ARLEN(  smpfull_arlen[  gk*8 +:  8]),\n\t\t\t.S_AXI_ARSIZE( smpfull_arsize[ gk*3 +:  3]),\n\t\t\t.S_AXI_ARBURST(smpfull_arburst[gk*2 +:  2]),\n\t\t\t.S_AXI_ARLOCK( smpfull_arlock[ gk]),\n\t\t\t.S_AXI_ARCACHE(smpfull_arcache[gk*4 +:  4]),\n\t\t\t.S_AXI_ARPROT( smpfull_arprot[ gk*3 +:  3]),\n\t\t\t.S_AXI_ARQOS(  smpfull_arqos[  gk*4 +:  4]),\n\n\t\t\t.S_AXI_RVALID(smpfull_rvalid[gk]),\n\t\t\t.S_AXI_RREADY(smpfull_rready[gk]),\n\t\t\t.S_AXI_RID(   smpfull_rid[  gk*IW +: IW]),\n\t\t\t.S_AXI_RDATA( smpfull_rdata[gk*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t.S_AXI_RLAST( smpfull_rlast[gk]),\n\t\t\t.S_AXI_RRESP( smpfull_rresp[gk*2 +: 2]),\n\t\t\t// }}}\n\t\t\t// The downsized connection\n\t\t\t// {{{\n\t\t\t.M_AXI_AWVALID(smp_awvalid),\n\t\t\t.M_AXI_AWREADY(smp_awready),\n\t\t\t.M_AXI_AWADDR( smp_awaddr),\n\t\t\t.M_AXI_AWPROT( smp_awprot),\n\n\t\t\t.M_AXI_WVALID(smp_wvalid),\n\t\t\t.M_AXI_WREADY(smp_wready),\n\t\t\t.M_AXI_WDATA( smp_wdata),\n\t\t\t.M_AXI_WSTRB( smp_wstrb),\n\n\t\t\t.M_AXI_BVALID(smp_bvalid),\n\t\t\t.M_AXI_BREADY(smp_bready),\n\t\t\t.M_AXI_BRESP( smp_bresp),\n\n\t\t\t.M_AXI_ARVALID(smp_arvalid),\n\t\t\t.M_AXI_ARREADY(smp_arready),\n\t\t\t.M_AXI_ARADDR( smp_araddr),\n\t\t\t.M_AXI_ARPROT( smp_arprot),\n\n\t\t\t.M_AXI_RVALID(smp_rvalid),\n\t\t\t.M_AXI_RREADY(smp_rready),\n\t\t\t.M_AXI_RDATA( smp_rdata),\n\t\t\t.M_AXI_RRESP( smp_rresp)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\tif (OPT_ZIPAXIL)\n\t\tbegin : GEN_ZIPAXIL\n\t\t\t// Local declarations\n\t\t\t// {{{",
            "wire cpuil_awvalid, cpuil_awready;",
            "wire [AW-1:0]\tcpuil_awaddr;",
            "wire [2:0]\t\tcpuil_awprot;",
            "wire cpuil_wvalid, cpuil_wready;",
            "wire [BUS_WIDTH-1:0]\tcpuil_wdata;",
            "wire [BUS_WIDTH/8-1:0]\tcpuil_wstrb;",
            "wire cpuil_bvalid, cpuil_bready;",
            "wire [1:0]\t\tcpuil_bresp;",
            "wire cpuil_arvalid, cpuil_arready;",
            "wire [AW-1:0]\tcpuil_araddr;",
            "wire [2:0]\t\tcpuil_arprot;",
            "wire cpuil_rvalid, cpuil_rready;",
            "wire [BUS_WIDTH-1:0]\tcpuil_rdata;",
            "wire [1:0]\t\tcpuil_rresp;\n\t\t\t//",
            "wire cpudl_awvalid, cpudl_awready;",
            "wire [AW-1:0]\tcpudl_awaddr;",
            "wire [2:0]\t\tcpudl_awprot;",
            "wire cpudl_wvalid, cpudl_wready;",
            "wire [BUS_WIDTH-1:0]\tcpudl_wdata;",
            "wire [BUS_WIDTH/8-1:0]\tcpudl_wstrb;",
            "wire cpudl_bvalid, cpudl_bready;",
            "wire [1:0]\t\tcpudl_bresp;",
            "wire cpudl_arvalid, cpudl_arready;",
            "wire [AW-1:0]\tcpudl_araddr;",
            "wire [2:0]\t\tcpudl_arprot;",
            "wire cpudl_rvalid, cpudl_rready;",
            "wire [BUS_WIDTH-1:0]\tcpudl_rdata;",
            "wire [1:0]\t\tcpudl_rresp;\n\t\t\t// }}}\n\n\t\t\tzipaxil #(\n\t\t\t\t// {{{\n\t\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t\t\t.RESET_ADDRESS(RESET_ADDRESS[ADDRESS_WIDTH-1:0]),\n\t\t\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t\t\t.C_AXI_DATA_WIDTH(BUS_WIDTH),\n\t\t\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t\t\t.OPT_LGICACHE(OPT_LGICACHE),\n\t\t\t\t.OPT_LGDCACHE(OPT_LGDCACHE),\n\t\t\t\t.START_HALTED(1'b1),\n\t\t\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t\t\t.OPT_MPY(OPT_MPY),\n\t\t\t\t.OPT_DIV(OPT_DIV),\n\t\t\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t\t\t.OPT_LOCK(OPT_LOCK),\n\t\t\t\t.OPT_CIS(OPT_CIS),\n\t\t\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t\t\t.OPT_DBGPORT(1'b1 || OPT_DBGPORT),\n\t\t\t\t.OPT_TRACE_PORT(OPT_TRACE_PORT),\n\t\t\t\t.OPT_PROFILER(OPT_PROFILER),\n\t\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t\t.OPT_SIM(OPT_SIM),\n\t\t\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t\t\t.RESET_DURATION(RESET_DURATION)\n\t\t\t\t// }}}\n\t\t\t) u_cpu (\n\t\t\t\t// {{{\n\t\t\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t\t\t.i_interrupt(pic_interrupt),\n\t\t\t\t.i_cpu_reset(!i_aresetn || watchdog_reset),\n\t\t\t\t// Debug control port\n\t\t\t\t// {{{\n\t\t\t\t.S_DBG_AWVALID(smp_awvalid),\n\t\t\t\t.S_DBG_AWREADY(smp_awready),\n\t\t\t\t.S_DBG_AWADDR(smp_awaddr),\n\t\t\t\t.S_DBG_AWPROT(smp_awprot),\n\t\t\t\t//\n\t\t\t\t.S_DBG_WVALID(smp_wvalid),\n\t\t\t\t.S_DBG_WREADY(smp_wready),\n\t\t\t\t.S_DBG_WDATA( smp_wdata),\n\t\t\t\t.S_DBG_WSTRB( smp_wstrb),\n\t\t\t\t//\n\t\t\t\t.S_DBG_BVALID(smp_bvalid),\n\t\t\t\t.S_DBG_BREADY(smp_bready),\n\t\t\t\t.S_DBG_BRESP( smp_bresp),\n\t\t\t\t//\n\t\t\t\t.S_DBG_ARVALID(smp_arvalid),\n\t\t\t\t.S_DBG_ARREADY(smp_arready),\n\t\t\t\t.S_DBG_ARADDR(smp_araddr),\n\t\t\t\t.S_DBG_ARPROT(smp_arprot),\n\t\t\t\t//\n\t\t\t\t.S_DBG_RVALID(smp_rvalid),\n\t\t\t\t.S_DBG_RREADY(smp_rready),\n\t\t\t\t.S_DBG_RDATA( smp_rdata),\n\t\t\t\t.S_DBG_RRESP( smp_rresp),\n\t\t\t\t// }}}\n\t\t\t\t// Master instruction bus\n\t\t\t\t// {{{\n\t\t\t\t.M_INSN_AWVALID(cpuil_awvalid),\n\t\t\t\t.M_INSN_AWREADY(cpuil_awready),\n\t\t\t\t.M_INSN_AWADDR(cpuil_awaddr),\n\t\t\t\t.M_INSN_AWPROT(cpuil_awprot),\n\t\t\t\t//\n\t\t\t\t.M_INSN_WVALID(cpuil_wvalid),\n\t\t\t\t.M_INSN_WREADY(cpuil_wready),\n\t\t\t\t.M_INSN_WDATA( cpuil_wdata),\n\t\t\t\t.M_INSN_WSTRB( cpuil_wstrb),\n\t\t\t\t//\n\t\t\t\t.M_INSN_BVALID(cpuil_bvalid),\n\t\t\t\t.M_INSN_BREADY(cpuil_bready),\n\t\t\t\t.M_INSN_BRESP( cpuil_bresp),\n\t\t\t\t//\n\t\t\t\t.M_INSN_ARVALID(cpuil_arvalid),\n\t\t\t\t.M_INSN_ARREADY(cpuil_arready),\n\t\t\t\t.M_INSN_ARADDR( cpuil_araddr),\n\t\t\t\t.M_INSN_ARPROT( cpuil_arprot),\n\t\t\t\t//\n\t\t\t\t.M_INSN_RVALID(cpuil_rvalid),\n\t\t\t\t.M_INSN_RREADY(cpuil_rready),\n\t\t\t\t.M_INSN_RDATA( cpuil_rdata),\n\t\t\t\t.M_INSN_RRESP( cpuil_rresp),\n\t\t\t\t// }}}\n\t\t\t\t// Master data bus\n\t\t\t\t// {{{\n\t\t\t\t.M_DATA_AWVALID(cpudl_awvalid),\n\t\t\t\t.M_DATA_AWREADY(cpudl_awready),\n\t\t\t\t.M_DATA_AWADDR( cpudl_awaddr),\n\t\t\t\t.M_DATA_AWPROT( cpudl_awprot),\n\t\t\t\t//\n\t\t\t\t.M_DATA_WVALID(cpudl_wvalid),\n\t\t\t\t.M_DATA_WREADY(cpudl_wready),\n\t\t\t\t.M_DATA_WDATA( cpudl_wdata),\n\t\t\t\t.M_DATA_WSTRB( cpudl_wstrb),\n\t\t\t\t//\n\t\t\t\t.M_DATA_BVALID(cpudl_bvalid),\n\t\t\t\t.M_DATA_BREADY(cpudl_bready),\n\t\t\t\t.M_DATA_BRESP( cpudl_bresp),\n\t\t\t\t//\n\t\t\t\t.M_DATA_ARVALID(cpudl_arvalid),\n\t\t\t\t.M_DATA_ARREADY(cpudl_arready),\n\t\t\t\t.M_DATA_ARADDR( cpudl_araddr),\n\t\t\t\t.M_DATA_ARPROT( cpudl_arprot),\n\t\t\t\t//\n\t\t\t\t.M_DATA_RVALID(cpudl_rvalid),\n\t\t\t\t.M_DATA_RREADY(cpudl_rready),\n\t\t\t\t.M_DATA_RDATA( cpudl_rdata),\n\t\t\t\t.M_DATA_RRESP( cpudl_rresp),\n\t\t\t\t// }}}\n\t\t\t\t.o_cpu_debug(smp_trace),\n\t\t\t\t// Accounting",
            "output s\n\t\t\t\t// {{{\n\t\t\t\t.o_cmd_reset(cpu_reset[gk]),\n\t\t\t\t.o_halted(   cpu_halted[gk]),\n\t\t\t\t.o_gie(      cpu_gie[gk]),\n\t\t\t\t.o_op_stall( cpu_op_stall[gk]),\n\t\t\t\t.o_pf_stall( cpu_pf_stall[gk]),\n\t\t\t\t.o_i_count(  cpu_i_count[gk]),\n\t\t\t\t// }}}\n\t\t\t\t// (Optional) Profiler\n\t\t\t\t// {{{\n\t\t\t\t.o_prof_stb(  smp_prof_stb),\n\t\t\t\t.o_prof_addr( smp_prof_addr),\n\t\t\t\t.o_prof_ticks(smp_prof_ticks)\n\t\t\t\t// }}}\n\t\t\t\t// }}}\n\t\t\t);\n\n\t\t\taxilite2axi #(\n\t\t\t\t// {{{\n\t\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t\t.C_AXI_DATA_WIDTH(BUS_WIDTH)\n\t\t\t\t// }}}\n\t\t\t) u_iaxi (\n\t\t\t\t.ACLK(i_aclk), .ARESETN(i_aresetn),\n\t\t\t\t// Slave interface, from CPU\n\t\t\t\t// {{{\n\t\t\t\t.S_AXI_AWVALID(cpuil_awvalid),\n\t\t\t\t.S_AXI_AWREADY(cpuil_awready),\n\t\t\t\t.S_AXI_AWADDR( cpuil_awaddr),\n\t\t\t\t.S_AXI_AWPROT( cpuil_awprot),\n\n\t\t\t\t.S_AXI_WVALID(cpuil_wvalid),\n\t\t\t\t.S_AXI_WREADY(cpuil_wready),\n\t\t\t\t.S_AXI_WDATA( cpuil_wdata),\n\t\t\t\t.S_AXI_WSTRB( cpuil_wstrb),\n\n\t\t\t\t.S_AXI_BVALID(cpuil_bvalid),\n\t\t\t\t.S_AXI_BREADY(cpuil_bready),\n\t\t\t\t.S_AXI_BRESP( cpuil_bresp),\n\n\t\t\t\t.S_AXI_ARVALID(cpuil_arvalid),\n\t\t\t\t.S_AXI_ARREADY(cpuil_arready),\n\t\t\t\t.S_AXI_ARADDR( cpuil_araddr),\n\t\t\t\t.S_AXI_ARPROT( cpuil_arprot),\n\n\t\t\t\t.S_AXI_RVALID(cpuil_rvalid),\n\t\t\t\t.S_AXI_RREADY(cpuil_rready),\n\t\t\t\t.S_AXI_RDATA( cpuil_rdata),\n\t\t\t\t.S_AXI_RRESP( cpuil_rresp),\n\t\t\t\t// }}}\n\t\t\t\t// Master interface, to the bus\n\t\t\t\t// {{{\n\t\t\t\t.M_AXI_AWVALID(cpui_awvalid[gk]),\n\t\t\t\t.M_AXI_AWREADY(cpui_awready[gk]),\n\t\t\t\t.M_AXI_AWID(   cpui_awid[   gk*IW +: IW]),\n\t\t\t\t.M_AXI_AWADDR( cpui_awaddr[ gk*AW +: AW]),\n\t\t\t\t.M_AXI_AWLEN(  cpui_awlen[  gk*8  +:  8]),\n\t\t\t\t.M_AXI_AWSIZE( cpui_awsize[ gk*3  +:  3]),\n\t\t\t\t.M_AXI_AWBURST(cpui_awburst[gk*2  +:  2]),\n\t\t\t\t.M_AXI_AWLOCK( cpui_awlock[ gk]),\n\t\t\t\t.M_AXI_AWCACHE(cpui_awcache[gk*4  +:  4]),\n\t\t\t\t.M_AXI_AWPROT( cpui_awprot[ gk*3  +:  3]),\n\t\t\t\t.M_AXI_AWQOS(  cpui_awqos[  gk*4  +:  4]),\n\n\t\t\t\t.M_AXI_WVALID(cpui_wvalid[gk]),\n\t\t\t\t.M_AXI_WREADY(cpui_wready[gk]),\n\t\t\t\t.M_AXI_WDATA( cpui_wdata[gk * BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t.M_AXI_WSTRB( cpui_wstrb[gk * BUS_WIDTH/8 +: BUS_WIDTH/8]),\n\t\t\t\t.M_AXI_WLAST( cpui_wlast[gk]),\n\n\t\t\t\t.M_AXI_BVALID(cpui_bvalid[gk]),\n\t\t\t\t.M_AXI_BREADY(cpui_bready[gk]),\n\t\t\t\t.M_AXI_BID(   cpui_bid  [gk*IW +: IW]),\n\t\t\t\t.M_AXI_BRESP( cpui_bresp[gk*2  +:  2]),\n\n\t\t\t\t.M_AXI_ARVALID(cpui_arvalid[gk]),\n\t\t\t\t.M_AXI_ARREADY(cpui_arready[gk]),\n\t\t\t\t.M_AXI_ARID(   cpui_arid[   gk*IW +: IW]),\n\t\t\t\t.M_AXI_ARADDR( cpui_araddr[ gk*AW +: AW]),\n\t\t\t\t.M_AXI_ARLEN(  cpui_arlen[  gk*8  +:  8]),\n\t\t\t\t.M_AXI_ARSIZE( cpui_arsize[ gk*3  +:  3]),\n\t\t\t\t.M_AXI_ARBURST(cpui_arburst[gk*2  +:  2]),\n\t\t\t\t.M_AXI_ARLOCK( cpui_arlock[ gk]),\n\t\t\t\t.M_AXI_ARCACHE(cpui_arcache[gk*4  +:  4]),\n\t\t\t\t.M_AXI_ARPROT( cpui_arprot[ gk*3  +:  3]),\n\t\t\t\t.M_AXI_ARQOS(  cpui_arqos[  gk*4  +:  4]),\n\n\t\t\t\t.M_AXI_RVALID(cpui_rvalid[gk]),\n\t\t\t\t.M_AXI_RREADY(cpui_rready[gk]),\n\t\t\t\t.M_AXI_RID(   cpui_rid[gk * IW  +: IW]),\n\t\t\t\t.M_AXI_RDATA( cpui_rdata[gk * BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t.M_AXI_RLAST( cpui_rlast[gk]),\n\t\t\t\t.M_AXI_RRESP( cpui_rresp[gk*2  +:  2])\n\t\t\t\t// }}}\n\t\t\t);\n\n\t\t\taxilite2axi #(\n\t\t\t\t// {{{\n\t\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t\t.C_AXI_DATA_WIDTH(BUS_WIDTH)\n\t\t\t\t// }}}\n\t\t\t) u_daxi (\n\t\t\t\t.ACLK(i_aclk), .ARESETN(i_aresetn),\n\t\t\t\t// Slave interface, from CPU\n\t\t\t\t// {{{\n\t\t\t\t.S_AXI_AWVALID(cpudl_awvalid),\n\t\t\t\t.S_AXI_AWREADY(cpudl_awready),\n\t\t\t\t.S_AXI_AWADDR( cpudl_awaddr),\n\t\t\t\t.S_AXI_AWPROT( cpudl_awprot),\n\n\t\t\t\t.S_AXI_WVALID(cpudl_wvalid),\n\t\t\t\t.S_AXI_WREADY(cpudl_wready),\n\t\t\t\t.S_AXI_WDATA( cpudl_wdata),\n\t\t\t\t.S_AXI_WSTRB( cpudl_wstrb),\n\n\t\t\t\t.S_AXI_BVALID(cpudl_bvalid),\n\t\t\t\t.S_AXI_BREADY(cpudl_bready),\n\t\t\t\t.S_AXI_BRESP( cpudl_bresp),\n\n\t\t\t\t.S_AXI_ARVALID(cpudl_arvalid),\n\t\t\t\t.S_AXI_ARREADY(cpudl_arready),\n\t\t\t\t.S_AXI_ARADDR( cpudl_araddr),\n\t\t\t\t.S_AXI_ARPROT( cpudl_arprot),\n\n\t\t\t\t.S_AXI_RVALID(cpudl_rvalid),\n\t\t\t\t.S_AXI_RREADY(cpudl_rready),\n\t\t\t\t.S_AXI_RDATA( cpudl_rdata),\n\t\t\t\t.S_AXI_RRESP( cpudl_rresp),\n\t\t\t\t// }}}\n\t\t\t\t// Master interface, to the bus\n\t\t\t\t// {{{\n\t\t\t\t.M_AXI_AWVALID(cpud_awvalid[gk]),\n\t\t\t\t.M_AXI_AWREADY(cpud_awready[gk]),\n\t\t\t\t.M_AXI_AWID(   cpud_awid[   gk*IW +: IW]),\n\t\t\t\t.M_AXI_AWADDR( cpud_awaddr[ gk*AW +: AW]),\n\t\t\t\t.M_AXI_AWLEN(  cpud_awlen[  gk*8  +:  8]),\n\t\t\t\t.M_AXI_AWSIZE( cpud_awsize[ gk*3  +:  3]),\n\t\t\t\t.M_AXI_AWBURST(cpud_awburst[gk*2  +:  2]),\n\t\t\t\t.M_AXI_AWLOCK( cpud_awlock[ gk]),\n\t\t\t\t.M_AXI_AWCACHE(cpud_awcache[gk*4  +:  4]),\n\t\t\t\t.M_AXI_AWPROT( cpud_awprot[ gk*3  +:  3]),\n\t\t\t\t.M_AXI_AWQOS(  cpud_awqos[  gk*4  +:  4]),\n\n\t\t\t\t.M_AXI_WVALID(cpud_wvalid[gk]),\n\t\t\t\t.M_AXI_WREADY(cpud_wready[gk]),\n\t\t\t\t.M_AXI_WDATA( cpud_wdata[gk * BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t.M_AXI_WSTRB( cpud_wstrb[gk * BUS_WIDTH/8 +: BUS_WIDTH/8]),\n\t\t\t\t.M_AXI_WLAST( cpud_wlast[gk]),\n\n\t\t\t\t.M_AXI_BVALID(cpud_bvalid[gk]),\n\t\t\t\t.M_AXI_BREADY(cpud_bready[gk]),\n\t\t\t\t.M_AXI_BID(   cpud_bid[  gk*IW +: IW]),\n\t\t\t\t.M_AXI_BRESP( cpud_bresp[gk*2  +:  2]),\n\n\t\t\t\t.M_AXI_ARVALID(cpud_arvalid[gk]),\n\t\t\t\t.M_AXI_ARREADY(cpud_arready[gk]),\n\t\t\t\t.M_AXI_ARID(   cpud_arid[   gk*IW +: IW]),\n\t\t\t\t.M_AXI_ARADDR( cpud_araddr[ gk*AW +: AW]),\n\t\t\t\t.M_AXI_ARLEN(  cpud_arlen[  gk*8  +:  8]),\n\t\t\t\t.M_AXI_ARSIZE( cpud_arsize[ gk*3  +:  3]),\n\t\t\t\t.M_AXI_ARBURST(cpud_arburst[gk*2  +:  2]),\n\t\t\t\t.M_AXI_ARLOCK( cpud_arlock[ gk]),\n\t\t\t\t.M_AXI_ARCACHE(cpud_arcache[gk*4  +:  4]),\n\t\t\t\t.M_AXI_ARPROT( cpud_arprot[ gk*3  +:  3]),\n\t\t\t\t.M_AXI_ARQOS(  cpud_arqos[  gk*4  +:  4]),\n\n\t\t\t\t.M_AXI_RVALID(cpud_rvalid[gk]),\n\t\t\t\t.M_AXI_RREADY(cpud_rready[gk]),\n\t\t\t\t.M_AXI_RID(   cpud_rid[gk*IW +: IW]),\n\t\t\t\t.M_AXI_RDATA( cpud_rdata[gk * BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t.M_AXI_RLAST( cpud_rlast[gk]),\n\t\t\t\t.M_AXI_RRESP( cpud_rresp[gk*2 +: 2])\n\t\t\t\t// }}}\n\t\t\t);\n\n\t\tend else begin : GEN_ZIPAXI\n\n\t\t\tzipaxi #(\n\t\t\t\t// {{{\n\t\t\t\t.RESET_ADDRESS(RESET_ADDRESS[ADDRESS_WIDTH-1:0]),\n\t\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t\t.C_AXI_DATA_WIDTH(BUS_WIDTH),\n\t\t\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t\t\t.OPT_LGICACHE(OPT_LGICACHE),\n\t\t\t\t.OPT_LGDCACHE(OPT_LGDCACHE),\n\t\t\t\t.START_HALTED(1'b1),\n\t\t\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t\t\t.OPT_MPY(OPT_MPY),\n\t\t\t\t.OPT_DIV(OPT_DIV),\n\t\t\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t\t\t.OPT_LOCK(OPT_LOCK),\n\t\t\t\t.OPT_CIS(OPT_CIS),\n\t\t\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t\t\t.OPT_DBGPORT(1'b1 || OPT_DBGPORT),\n\t\t\t\t.OPT_TRACE_PORT(OPT_TRACE_PORT),\n\t\t\t\t.OPT_PROFILER(OPT_PROFILER),\n\t\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t\t.OPT_SIM(OPT_SIM),\n\t\t\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t\t\t.RESET_DURATION(RESET_DURATION)\n\t\t\t\t// }}}\n\t\t\t) u_cpu (\n\t\t\t\t// {{{\n\t\t\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t\t\t.i_interrupt(pic_interrupt),\n\t\t\t\t.i_cpu_reset(!i_aresetn || watchdog_reset),\n\t\t\t\t// Debug control port\n\t\t\t\t// {{{\n\t\t\t\t.S_DBG_AWVALID(smp_awvalid),\n\t\t\t\t.S_DBG_AWREADY(smp_awready),\n\t\t\t\t.S_DBG_AWADDR(smp_awaddr),\n\t\t\t\t.S_DBG_AWPROT(smp_awprot),\n\t\t\t\t//\n\t\t\t\t.S_DBG_WVALID(smp_wvalid),\n\t\t\t\t.S_DBG_WREADY(smp_wready),\n\t\t\t\t.S_DBG_WDATA( smp_wdata),\n\t\t\t\t.S_DBG_WSTRB( smp_wstrb),\n\t\t\t\t//\n\t\t\t\t.S_DBG_BVALID(smp_bvalid),\n\t\t\t\t.S_DBG_BREADY(smp_bready),\n\t\t\t\t.S_DBG_BRESP( smp_bresp),\n\t\t\t\t//\n\t\t\t\t.S_DBG_ARVALID(smp_arvalid),\n\t\t\t\t.S_DBG_ARREADY(smp_arready),\n\t\t\t\t.S_DBG_ARADDR(smp_araddr),\n\t\t\t\t.S_DBG_ARPROT(smp_arprot),\n\t\t\t\t//\n\t\t\t\t.S_DBG_RVALID(smp_rvalid),\n\t\t\t\t.S_DBG_RREADY(smp_rready),\n\t\t\t\t.S_DBG_RDATA( smp_rdata),\n\t\t\t\t.S_DBG_RRESP( smp_rresp),\n\t\t\t\t// }}}\n\t\t\t\t// Master instruction bus\n\t\t\t\t// {{{\n\t\t\t\t.M_INSN_AWVALID(cpui_awvalid[gk]),\n\t\t\t\t.M_INSN_AWREADY(cpui_awready[gk]),\n\t\t\t\t.M_INSN_AWID(   cpui_awid[   gk*IW +: IW]),\n\t\t\t\t.M_INSN_AWADDR( cpui_awaddr[ gk*AW +: AW]),\n\t\t\t\t.M_INSN_AWLEN(  cpui_awlen[  gk*8 +: 8]),\n\t\t\t\t.M_INSN_AWSIZE( cpui_awsize[ gk*3 +: 3]),\n\t\t\t\t.M_INSN_AWBURST(cpui_awburst[gk*2 +: 2]),\n\t\t\t\t.M_INSN_AWLOCK( cpui_awlock[ gk]),\n\t\t\t\t.M_INSN_AWCACHE(cpui_awcache[gk*4 +: 4]),\n\t\t\t\t.M_INSN_AWPROT( cpui_awprot[ gk*3 +: 3]),\n\t\t\t\t.M_INSN_AWQOS(  cpui_awqos[  gk*4 +: 4]),\n\t\t\t\t//\n\t\t\t\t.M_INSN_WVALID(cpui_wvalid[gk]),\n\t\t\t\t.M_INSN_WREADY(cpui_wready[gk]),\n\t\t\t\t.M_INSN_WDATA( cpui_wdata[gk*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t.M_INSN_WSTRB( cpui_wstrb[gk*BUS_WIDTH/8 +: BUS_WIDTH/8]),\n\t\t\t\t.M_INSN_WLAST( cpui_wlast[gk]),\n\t\t\t\t//\n\t\t\t\t.M_INSN_BVALID(cpui_bvalid[gk]),\n\t\t\t\t.M_INSN_BREADY(cpui_bready[gk]),\n\t\t\t\t.M_INSN_BID(   cpui_bid[gk*IW +: IW]),\n\t\t\t\t.M_INSN_BRESP( cpui_bresp[gk*2 +: 2]),\n\t\t\t\t//\n\t\t\t\t.M_INSN_ARVALID(cpui_arvalid[gk]),\n\t\t\t\t.M_INSN_ARREADY(cpui_arready[gk]),\n\t\t\t\t.M_INSN_ARID(   cpui_arid[   gk*IW +: IW]),\n\t\t\t\t.M_INSN_ARADDR( cpui_araddr[ gk*AW +: AW]),\n\t\t\t\t.M_INSN_ARLEN(  cpui_arlen[  gk*8 +: 8]),\n\t\t\t\t.M_INSN_ARSIZE( cpui_arsize[ gk*3 +: 3]),\n\t\t\t\t.M_INSN_ARBURST(cpui_arburst[gk*2 +: 2]),\n\t\t\t\t.M_INSN_ARLOCK( cpui_arlock[ gk]),\n\t\t\t\t.M_INSN_ARCACHE(cpui_arcache[gk*4 +: 4]),\n\t\t\t\t.M_INSN_ARPROT( cpui_arprot[ gk*3 +: 3]),\n\t\t\t\t.M_INSN_ARQOS(  cpui_arqos[  gk*4 +: 4]),\n\t\t\t\t//\n\t\t\t\t.M_INSN_RVALID(cpui_rvalid[gk]),\n\t\t\t\t.M_INSN_RREADY(cpui_rready[gk]),\n\t\t\t\t.M_INSN_RID(   cpui_rid[gk*IW +: IW]),\n\t\t\t\t.M_INSN_RDATA( cpui_rdata[gk*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t.M_INSN_RLAST( cpui_rlast[gk]),\n\t\t\t\t.M_INSN_RRESP( cpui_rresp[gk*2 +: 2]),\n\t\t\t\t// }}}\n\t\t\t\t// Master data bus\n\t\t\t\t// {{{\n\t\t\t\t.M_DATA_AWVALID(cpud_awvalid[gk]),\n\t\t\t\t.M_DATA_AWREADY(cpud_awready[gk]),\n\t\t\t\t.M_DATA_AWID(   cpud_awid[   gk*IW +: IW]),\n\t\t\t\t.M_DATA_AWADDR( cpud_awaddr[ gk*AW +: AW]),\n\t\t\t\t.M_DATA_AWLEN(  cpud_awlen[  gk*8 +: 8]),\n\t\t\t\t.M_DATA_AWSIZE( cpud_awsize[ gk*3 +: 3]),\n\t\t\t\t.M_DATA_AWBURST(cpud_awburst[gk*2 +: 2]),\n\t\t\t\t.M_DATA_AWLOCK( cpud_awlock[ gk]),\n\t\t\t\t.M_DATA_AWCACHE(cpud_awcache[gk*4 +: 4]),\n\t\t\t\t.M_DATA_AWPROT( cpud_awprot[ gk*3 +: 3]),\n\t\t\t\t.M_DATA_AWQOS(  cpud_awqos[  gk*4 +: 4]),\n\t\t\t\t//\n\t\t\t\t.M_DATA_WVALID(cpud_wvalid[gk]),\n\t\t\t\t.M_DATA_WREADY(cpud_wready[gk]),\n\t\t\t\t.M_DATA_WDATA( cpud_wdata[gk*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t.M_DATA_WSTRB( cpud_wstrb[gk*BUS_WIDTH/8 +: BUS_WIDTH/8]),\n\t\t\t\t.M_DATA_WLAST( cpud_wlast[gk]),\n\t\t\t\t//\n\t\t\t\t.M_DATA_BVALID(cpud_bvalid[gk]),\n\t\t\t\t.M_DATA_BREADY(cpud_bready[gk]),\n\t\t\t\t.M_DATA_BID(   cpud_bid[   gk*IW +: IW]),\n\t\t\t\t.M_DATA_BRESP( cpud_bresp[ gk*2 +: 2]),\n\t\t\t\t//\n\t\t\t\t.M_DATA_ARVALID(cpud_arvalid[gk]),\n\t\t\t\t.M_DATA_ARREADY(cpud_arready[gk]),\n\t\t\t\t.M_DATA_ARID(   cpud_arid[   gk*IW +: IW]),\n\t\t\t\t.M_DATA_ARADDR( cpud_araddr[ gk*AW +: AW]),\n\t\t\t\t.M_DATA_ARLEN(  cpud_arlen[  gk*8 +: 8]),\n\t\t\t\t.M_DATA_ARSIZE( cpud_arsize[ gk*3 +: 3]),\n\t\t\t\t.M_DATA_ARBURST(cpud_arburst[gk*2 +: 2]),\n\t\t\t\t.M_DATA_ARLOCK( cpud_arlock[ gk]),\n\t\t\t\t.M_DATA_ARCACHE(cpud_arcache[gk*4 +: 4]),\n\t\t\t\t.M_DATA_ARPROT( cpud_arprot[ gk*3 +: 3]),\n\t\t\t\t.M_DATA_ARQOS(  cpud_arqos[  gk*4 +: 4]),\n\t\t\t\t//\n\t\t\t\t.M_DATA_RVALID(cpud_rvalid[gk]),\n\t\t\t\t.M_DATA_RREADY(cpud_rready[gk]),\n\t\t\t\t.M_DATA_RID(   cpud_rid[gk*IW +: IW]),\n\t\t\t\t.M_DATA_RDATA( cpud_rdata[gk*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t.M_DATA_RLAST( cpud_rlast[gk]),\n\t\t\t\t.M_DATA_RRESP( cpud_rresp[gk*2 +: 2]),\n\t\t\t\t// }}}\n\t\t\t\t.o_cpu_debug(smp_trace),\n\t\t\t\t// Accounting",
            "output s\n\t\t\t\t// {{{\n\t\t\t\t.o_cmd_reset(cpu_reset[gk]),\n\t\t\t\t.o_halted(   cpu_halted[gk]),\n\t\t\t\t.o_gie(      cpu_gie[gk]),\n\t\t\t\t.o_op_stall( cpu_op_stall[gk]),\n\t\t\t\t.o_pf_stall( cpu_pf_stall[gk]),\n\t\t\t\t.o_i_count(  cpu_i_count[gk]),\n\t\t\t\t// }}}\n\t\t\t\t// (Optional) Profiler\n\t\t\t\t// {{{\n\t\t\t\t.o_prof_stb(  smp_prof_stb),\n\t\t\t\t.o_prof_addr( smp_prof_addr),\n\t\t\t\t.o_prof_ticks(smp_prof_ticks)\n\t\t\t\t// }}}\n\t\t\t\t// }}}\n\t\t\t);\n\n\t\tend\n\n\t\t// Keep Verilator happy with our unused ports\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_smp;\n\t\tassign\tunused_smp = &{ 1'b0, smp_prof_stb, smp_prof_addr,\n\t\t\t\t\tsmpfull_awaddr[gk*AW+8 +: (AW-8)],\n\t\t\t\t\tsmpfull_araddr[gk*AW+8 +: (AW-8)],\n\t\t\t\t\tsmp_prof_ticks, smp_trace,\n\t\t\t\t\tcpu_reset[gk],\n\t\t\t\t\tcpu_gie[gk], cpu_op_stall[gk],\n\t\t\t\t\tcpu_pf_stall[gk], cpu_i_count[gk] };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The wide bus interconnect\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\taxixbar #(\n\t\t// {{{\n`ifdef\tVERILATOR\n\t\t.NM(1+2*OPT_SMP),\n`else\n\t\t.NM(2*OPT_SMP),\t// ZipAXI(l) CPU is two masters each\n`endif\n\t\t.NS(4+OPT_SMP),\n\t\t.C_AXI_ID_WIDTH(IW),\n\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH), .C_AXI_DATA_WIDTH(BUS_WIDTH),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.SLAVE_ADDR({ AXILP_ADDR, SMP_ADDR, CONSOLE_ADDR, SCOPE_ADDR,\n\t\t\t\tMEMORY_ADDR }),\n\t\t.SLAVE_MASK({\n\t\t\t{ {(AW-24){1'b1}}, {(24){1'b0}} },\t// AXI-Lite Periph Set\n\t\t\tSMP_MASK,\t// SMP\n\t\t\t\t{   4'b1111, {(AW-4){1'b0}} },\t// Console\n\t\t\t\t{   4'b1111, {(AW-4){1'b0}} },\t// Scope\n\t\t\t\t{   2'b11,   {(AW-2){1'b0}} } }) // Memory\n\t\t// }}}\n\t) u_main_crossbar (\n\t\t// {{{\n\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t// Slave ports from the various bus masters\n\t\t// {{{\n`ifdef\tVERILATOR\n\t\t// Three bus masters: the external SIM",
            "input , and the CPU\n\t\t.S_AXI_AWVALID({ simfull_awvalid, cpui_awvalid, cpud_awvalid }),\n\t\t.S_AXI_AWREADY({ simfull_awready, cpui_awready, cpud_awready }),\n\t\t.S_AXI_AWID({    simfull_awid,    cpui_awid,    cpud_awid    }),\n\t\t.S_AXI_AWADDR({  simfull_awaddr,  cpui_awaddr,  cpud_awaddr  }),\n\t\t.S_AXI_AWLEN({   simfull_awlen,   cpui_awlen,   cpud_awlen   }),\n\t\t.S_AXI_AWSIZE({  simfull_awsize,  cpui_awsize,  cpud_awsize  }),\n\t\t.S_AXI_AWBURST({ simfull_awburst, cpui_awburst, cpud_awburst }),\n\t\t.S_AXI_AWLOCK({  simfull_awlock,  cpui_awlock,  cpud_awlock  }),\n\t\t.S_AXI_AWCACHE({ simfull_awcache, cpui_awcache, cpud_awcache }),\n\t\t.S_AXI_AWPROT({  simfull_awprot,  cpui_awprot,  cpud_awprot  }),\n\t\t.S_AXI_AWQOS({   simfull_awqos,   cpui_awqos,   cpud_awqos   }),\n\n\t\t.S_AXI_WVALID({ simfull_wvalid, cpui_wvalid, cpud_wvalid }),\n\t\t.S_AXI_WREADY({ simfull_wready, cpui_wready, cpud_wready }),\n\t\t.S_AXI_WDATA({  simfull_wdata,  cpui_wdata,  cpud_wdata  }),\n\t\t.S_AXI_WSTRB({  simfull_wstrb,  cpui_wstrb,  cpud_wstrb  }),\n\t\t.S_AXI_WLAST({  simfull_wlast,  cpui_wlast,  cpud_wlast  }),\n\n\t\t.S_AXI_BVALID({ simfull_bvalid, cpui_bvalid, cpud_bvalid }),\n\t\t.S_AXI_BREADY({ simfull_bready, cpui_bready, cpud_bready }),\n\t\t.S_AXI_BID({    simfull_bid,    cpui_bid,    cpud_bid    }),\n\t\t.S_AXI_BRESP({  simfull_bresp,  cpui_bresp,  cpud_bresp  }),\n\n\t\t.S_AXI_ARVALID({ simfull_arvalid, cpui_arvalid, cpud_arvalid }),\n\t\t.S_AXI_ARREADY({ simfull_arready, cpui_arready, cpud_arready }),\n\t\t.S_AXI_ARID({    simfull_arid,    cpui_arid,    cpud_arid    }),\n\t\t.S_AXI_ARADDR({  simfull_araddr,  cpui_araddr,  cpud_araddr  }),\n\t\t.S_AXI_ARLEN({   simfull_arlen,   cpui_arlen,   cpud_arlen   }),\n\t\t.S_AXI_ARSIZE({  simfull_arsize,  cpui_arsize,  cpud_arsize  }),\n\t\t.S_AXI_ARBURST({ simfull_arburst, cpui_arburst, cpud_arburst }),\n\t\t.S_AXI_ARLOCK({  simfull_arlock,  cpui_arlock,  cpud_arlock  }),\n\t\t.S_AXI_ARCACHE({ simfull_arcache, cpui_arcache, cpud_arcache }),\n\t\t.S_AXI_ARPROT({  simfull_arprot,  cpui_arprot,  cpud_arprot  }),\n\t\t.S_AXI_ARQOS({   simfull_arqos,   cpui_arqos,   cpud_arqos   }),\n\n\t\t.S_AXI_RVALID({ simfull_rvalid, cpui_rvalid, cpud_rvalid }),\n\t\t.S_AXI_RREADY({ simfull_rready, cpui_rready, cpud_rready }),\n\t\t.S_AXI_RID({    simfull_rid,    cpui_rid,    cpud_rid  }),\n\t\t.S_AXI_RDATA({  simfull_rdata,  cpui_rdata,  cpud_rdata  }),\n\t\t.S_AXI_RLAST({  simfull_rlast,  cpui_rlast,  cpud_rlast  }),\n\t\t.S_AXI_RRESP({  simfull_rresp,  cpui_rresp,  cpud_rresp  }),\n`else\n\t\t// With no external CPU",
            "input , there is no simulation port\n\t\t.S_AXI_AWVALID({ cpui_awvalid, cpud_awvalid }),\n\t\t.S_AXI_AWREADY({ cpui_awready, cpud_awready }),\n\t\t.S_AXI_AWID({    cpui_awid,    cpud_awid    }),\n\t\t.S_AXI_AWADDR({  cpui_awaddr,  cpud_awaddr  }),\n\t\t.S_AXI_AWLEN({   cpui_awlen,   cpud_awlen   }),\n\t\t.S_AXI_AWSIZE({  cpui_awsize,  cpud_awsize  }),\n\t\t.S_AXI_AWBURST({ cpui_awburst, cpud_awburst }),\n\t\t.S_AXI_AWLOCK({  cpui_awlock,  cpud_awlock  }),\n\t\t.S_AXI_AWCACHE({ cpui_awcache, cpud_awcache }),\n\t\t.S_AXI_AWPROT({  cpui_awprot,  cpud_awprot  }),\n\t\t.S_AXI_AWQOS({   cpui_awqos,   cpud_awqos   }),\n\n\t\t.S_AXI_WVALID({ cpui_wvalid, cpud_wvalid }),\n\t\t.S_AXI_WREADY({ cpui_wready, cpud_wready }),\n\t\t.S_AXI_WDATA({  cpui_wdata,  cpud_wdata  }),\n\t\t.S_AXI_WSTRB({  cpui_wstrb,  cpud_wstrb  }),\n\t\t.S_AXI_WLAST({  cpui_wlast,  cpud_wlast  }),\n\n\t\t.S_AXI_BVALID({ cpui_bvalid, cpud_bvalid }),\n\t\t.S_AXI_BREADY({ cpui_bready, cpud_bready }),\n\t\t.S_AXI_BID({    cpui_bid,    cpud_bid    }),\n\t\t.S_AXI_BRESP({  cpui_bresp,  cpud_bresp  }),\n\n\t\t.S_AXI_ARVALID({ cpui_arvalid, cpud_arvalid }),\n\t\t.S_AXI_ARREADY({ cpui_arready, cpud_arready }),\n\t\t.S_AXI_ARID({    cpui_arid,    cpud_arid    }),\n\t\t.S_AXI_ARADDR({  cpui_araddr,  cpud_araddr  }),\n\t\t.S_AXI_ARLEN({   cpui_arlen,   cpud_arlen   }),\n\t\t.S_AXI_ARSIZE({  cpui_arsize,  cpud_arsize  }),\n\t\t.S_AXI_ARBURST({ cpui_arburst, cpud_arburst }),\n\t\t.S_AXI_ARLOCK({  cpui_arlock,  cpud_arlock  }),\n\t\t.S_AXI_ARCACHE({ cpui_arcache, cpud_arcache }),\n\t\t.S_AXI_ARPROT({  cpui_arprot,  cpud_arprot  }),\n\t\t.S_AXI_ARQOS({   cpui_arqos,   cpud_arqos   }),\n\n\t\t.S_AXI_RVALID({ cpui_rvalid, cpud_rvalid }),\n\t\t.S_AXI_RREADY({ cpui_rready, cpud_rready }),\n\t\t.S_AXI_RID({    cpui_rid,    cpud_rid  }),\n\t\t.S_AXI_RDATA({  cpui_rdata,  cpud_rdata  }),\n\t\t.S_AXI_RLAST({  cpui_rlast,  cpud_rlast  }),\n\t\t.S_AXI_RRESP({  cpui_rresp,  cpud_rresp  }),\n`endif\n\t\t// }}}\n\t\t// Master port ... to control the slaves w/in this design\n\t\t// {{{\n\t\t.M_AXI_AWVALID({ axip_awvalid, smpfull_awvalid, con_awvalid, scope_awvalid,  mem_awvalid  }),\n\t\t.M_AXI_AWREADY({ axip_awready, smpfull_awready, con_awready, scope_awready,  mem_awready  }),\n\t\t.M_AXI_AWID({    axip_awid,    smpfull_awid,    con_awid,    scope_awid,     mem_awid  }),\n\t\t.M_AXI_AWADDR({  axip_awaddr,  smpfull_awaddr,  con_awaddr,  scope_awaddr,   mem_awaddr  }),\n\t\t.M_AXI_AWLEN({   axip_awlen,   smpfull_awlen,   con_awlen,   scope_awlen,    mem_awlen  }),\n\t\t.M_AXI_AWSIZE({  axip_awsize,  smpfull_awsize,  con_awsize,  scope_awsize,   mem_awsize  }),\n\t\t.M_AXI_AWBURST({ axip_awburst, smpfull_awburst, con_awburst, scope_awburst,  mem_awburst  }),\n\t\t.M_AXI_AWLOCK({  axip_awlock,  smpfull_awlock,  con_awlock,  scope_awlock,   mem_awlock  }),\n\t\t.M_AXI_AWCACHE({ axip_awcache, smpfull_awcache, con_awcache, scope_awcache,  mem_awcache  }),\n\t\t.M_AXI_AWPROT({  axip_awprot,  smpfull_awprot,  con_awprot,  scope_awprot,   mem_awprot  }),\n\t\t.M_AXI_AWQOS({   axip_awqos,   smpfull_awqos,   con_awqos,   scope_awqos,    mem_awqos  }),\n\t\t//\n\t\t.M_AXI_WVALID({ axip_wvalid, smpfull_wvalid, con_wvalid, scope_wvalid,  mem_wvalid  }),\n\t\t.M_AXI_WREADY({ axip_wready, smpfull_wready, con_wready, scope_wready,  mem_wready  }),\n\t\t.M_AXI_WDATA({  axip_wdata,  smpfull_wdata,  con_wdata,  scope_wdata,   mem_wdata  }),\n\t\t.M_AXI_WSTRB({  axip_wstrb,  smpfull_wstrb,  con_wstrb,  scope_wstrb,   mem_wstrb  }),\n\t\t.M_AXI_WLAST({  axip_wlast,  smpfull_wlast,  con_wlast,  scope_wlast,   mem_wlast  }),\n\t\t//\n\t\t.M_AXI_BVALID({ axip_bvalid, smpfull_bvalid, con_bvalid, scope_bvalid,  mem_bvalid  }),\n\t\t.M_AXI_BREADY({ axip_bready, smpfull_bready, con_bready, scope_bready,  mem_bready  }),\n\t\t.M_AXI_BID({    axip_bid,    smpfull_bid,    con_bid,    scope_bid,     mem_bid  }),\n\t\t.M_AXI_BRESP({  axip_bresp,  smpfull_bresp,  con_bresp,  scope_bresp,   mem_bresp  }),\n\t\t//\n\t\t.M_AXI_ARVALID({ axip_arvalid, smpfull_arvalid, con_arvalid, scope_arvalid,  mem_arvalid  }),\n\t\t.M_AXI_ARREADY({ axip_arready, smpfull_arready, con_arready, scope_arready,  mem_arready  }),\n\t\t.M_AXI_ARID({    axip_arid,    smpfull_arid,    con_arid,    scope_arid,     mem_arid  }),\n\t\t.M_AXI_ARADDR({  axip_araddr,  smpfull_araddr,  con_araddr,  scope_araddr,   mem_araddr  }),\n\t\t.M_AXI_ARLEN({   axip_arlen,   smpfull_arlen,   con_arlen,   scope_arlen,    mem_arlen  }),\n\t\t.M_AXI_ARSIZE({  axip_arsize,  smpfull_arsize,  con_arsize,  scope_arsize,   mem_arsize  }),\n\t\t.M_AXI_ARBURST({ axip_arburst, smpfull_arburst, con_arburst, scope_arburst,  mem_arburst  }),\n\t\t.M_AXI_ARLOCK({  axip_arlock,  smpfull_arlock,  con_arlock,  scope_arlock,   mem_arlock  }),\n\t\t.M_AXI_ARCACHE({ axip_arcache, smpfull_arcache, con_arcache, scope_arcache,  mem_arcache  }),\n\t\t.M_AXI_ARPROT({  axip_arprot,  smpfull_arprot,  con_arprot,  scope_arprot,   mem_arprot  }),\n\t\t.M_AXI_ARQOS({   axip_arqos,   smpfull_arqos,   con_arqos,   scope_arqos,    mem_arqos  }),\n\t\t//\n\t\t.M_AXI_RVALID({ axip_rvalid, smpfull_rvalid, con_rvalid, scope_rvalid,  mem_rvalid  }),\n\t\t.M_AXI_RREADY({ axip_rready, smpfull_rready, con_rready, scope_rready,  mem_rready  }),\n\t\t.M_AXI_RID({    axip_rid,    smpfull_rid,    con_rid,    scope_rid,     mem_rid  }),\n\t\t.M_AXI_RDATA({  axip_rdata,  smpfull_rdata,  con_rdata,  scope_rdata,   mem_rdata  }),\n\t\t.M_AXI_RLAST({  axip_rlast,  smpfull_rlast,  con_rlast,  scope_rlast,   mem_rlast  }),\n\t\t.M_AXI_RRESP({  axip_rresp,  smpfull_rresp,  con_rresp,  scope_rresp,   mem_rresp  })\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Memory\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tdemofull #(\n\t\t// {{{\n\t\t.C_S_AXI_ID_WIDTH(IW),\n\t\t.C_S_AXI_DATA_WIDTH(BUS_WIDTH),\n\t\t.C_S_AXI_ADDR_WIDTH(LGMEMSZ),\n\t\t.OPT_LOCK(1'b1)\n\t\t// }}}\n\t) u_memaxi (\n\t\t// {{{\n\t\t.o_we(ram_we),\n\t\t.o_waddr(ram_waddr),\n\t\t.o_wdata(ram_wdata),\n\t\t.o_wstrb(ram_wstrb),\n\t\t.o_rd(ram_rd),\n\t\t.o_raddr(ram_raddr),\n\t\t.i_rdata(ram_rdata),\n\t\t//\n\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t//\n\t\t.S_AXI_AWVALID(mem_awvalid),\n\t\t.S_AXI_AWREADY(mem_awready),\n\t\t.S_AXI_AWID(   mem_awid),\n\t\t.S_AXI_AWADDR( mem_awaddr[LGMEMSZ-1:0]),\n\t\t.S_AXI_AWLEN(  mem_awlen),\n\t\t.S_AXI_AWSIZE( mem_awsize),\n\t\t.S_AXI_AWBURST(mem_awburst),\n\t\t.S_AXI_AWLOCK( mem_awlock),\n\t\t.S_AXI_AWCACHE(mem_awcache),\n\t\t.S_AXI_AWPROT( mem_awprot),\n\t\t.S_AXI_AWQOS(  mem_awqos),\n\t\t//\n\t\t.S_AXI_WVALID(mem_wvalid),\n\t\t.S_AXI_WREADY(mem_wready),\n\t\t.S_AXI_WDATA( mem_wdata),\n\t\t.S_AXI_WSTRB( mem_wstrb),\n\t\t.S_AXI_WLAST( mem_wlast),\n\t\t//\n\t\t.S_AXI_BVALID(mem_bvalid),\n\t\t.S_AXI_BREADY(mem_bready),\n\t\t.S_AXI_BID(   mem_bid),\n\t\t.S_AXI_BRESP( mem_bresp),\n\t\t//\n\t\t.S_AXI_ARVALID(mem_arvalid),\n\t\t.S_AXI_ARREADY(mem_arready),\n\t\t.S_AXI_ARID(   mem_arid),\n\t\t.S_AXI_ARADDR( mem_araddr[LGMEMSZ-1:0]),\n\t\t.S_AXI_ARLEN(  mem_arlen),\n\t\t.S_AXI_ARSIZE( mem_arsize),\n\t\t.S_AXI_ARBURST(mem_arburst),\n\t\t.S_AXI_ARLOCK( mem_arlock),\n\t\t.S_AXI_ARCACHE(mem_arcache),\n\t\t.S_AXI_ARPROT( mem_arprot),\n\t\t.S_AXI_ARQOS(  mem_arqos),\n\t\t//\n\t\t.S_AXI_RVALID(mem_rvalid),\n\t\t.S_AXI_RREADY(mem_rready),\n\t\t.S_AXI_RID(   mem_rid),\n\t\t.S_AXI_RDATA( mem_rdata),\n\t\t.S_AXI_RLAST( mem_rlast),\n\t\t.S_AXI_RRESP( mem_rresp)\n\t\t// }}}\n\t);\n\n\tinitial\tbegin\n\t\t$display(\"MEM_FILE     = %s\", MEM_FILE);\n\t\t$display(\"CONSOLE_FILE = %s\", CONSOLE_FILE);\n\t\t$readmemh(MEM_FILE, ram);\n\tend\n\n\tgenerate for(gk=0; gk<BUS_WIDTH/32; gk=gk+1)\n\tbegin : SWAP_RAM_WORDS\n\t\t// The ZipCPU's AXI interface currently maintains a little\n\t\t// endian word order, while using big endian word order within\n\t\t// a word.\n\t\tassign\tram_wstrb_swap[ 4*gk +:  4] = ram_wstrb[ 4*(BUS_WIDTH/32-gk-1) +: 4];\n\t\tassign\tram_wdata_swap[32*gk +: 32] = ram_wdata[32*(BUS_WIDTH/32-gk-1) +:32];\n\n\t\tassign\tram_rdata[32*gk +: 32] = ram_rdata_swap[32*(BUS_WIDTH/32-gk-1) +:32];\n\tend endgenerate\n\n\talways @(posedge i_aclk)\n\tif (ram_we)\n\tfor(rk=0; rk<BUS_WIDTH/8; rk=rk+1)\n\tif (ram_wstrb_swap[rk])\n\t\tram[ram_waddr][rk*8 +: 8] <= ram_wdata_swap[rk*8 +: 8];\n\n\talways @(posedge i_aclk)\n\tif (ram_rd)\n\t\tram_rdata_swap <= ram[ram_raddr];\n\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused_mem;\n\tassign\tunused_mem = &{ 1'b0,\n\t\t\tmem_awaddr[AW-1:LGMEMSZ], mem_araddr[AW-1:LGMEMSZ]\n\t\t\t};\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Console\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\taxi2axilsub #(\n\t\t// {{{\n\t\t.C_AXI_ID_WIDTH(IW),\n\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH-3),\n\t\t.C_S_AXI_DATA_WIDTH(BUS_WIDTH),\n\t\t.C_M_AXI_DATA_WIDTH(32),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER), .OPT_WRITES(1), .OPT_READS(1)\n\t\t// }}}\n\t) u_condown (\n\t\t// {{{\n\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t// The \"Wide\" slave connection\n\t\t// {{{\n\t\t.S_AXI_AWVALID(con_awvalid),\n\t\t.S_AXI_AWREADY(con_awready),\n\t\t.S_AXI_AWID(   con_awid),\n\t\t.S_AXI_AWADDR( con_awaddr[AW-4:0]),\n\t\t.S_AXI_AWLEN(  con_awlen),\n\t\t.S_AXI_AWSIZE( con_awsize),\n\t\t.S_AXI_AWBURST(con_awburst),\n\t\t.S_AXI_AWLOCK( con_awlock),\n\t\t.S_AXI_AWCACHE(con_awcache),\n\t\t.S_AXI_AWPROT( con_awprot),\n\t\t.S_AXI_AWQOS(  con_awqos),\n\n\t\t.S_AXI_WVALID(con_wvalid),\n\t\t.S_AXI_WREADY(con_wready),\n\t\t.S_AXI_WDATA( con_wdata),\n\t\t.S_AXI_WSTRB( con_wstrb),\n\t\t.S_AXI_WLAST( con_wlast),\n\n\t\t.S_AXI_BVALID(con_bvalid),\n\t\t.S_AXI_BREADY(con_bready),\n\t\t.S_AXI_BID(   con_bid),\n\t\t.S_AXI_BRESP( con_bresp),\n\n\t\t.S_AXI_ARVALID(con_arvalid),\n\t\t.S_AXI_ARREADY(con_arready),\n\t\t.S_AXI_ARID(   con_arid),\n\t\t.S_AXI_ARADDR( con_araddr[AW-4:0]),\n\t\t.S_AXI_ARLEN(  con_arlen),\n\t\t.S_AXI_ARSIZE( con_arsize),\n\t\t.S_AXI_ARBURST(con_arburst),\n\t\t.S_AXI_ARLOCK( con_arlock),\n\t\t.S_AXI_ARCACHE(con_arcache),\n\t\t.S_AXI_ARPROT( con_arprot),\n\t\t.S_AXI_ARQOS(  con_arqos),\n\n\t\t.S_AXI_RVALID(con_rvalid),\n\t\t.S_AXI_RREADY(con_rready),\n\t\t.S_AXI_RID(   con_rid),\n\t\t.S_AXI_RDATA( con_rdata),\n\t\t.S_AXI_RLAST( con_rlast),\n\t\t.S_AXI_RRESP( con_rresp),\n\t\t// }}}\n\t\t// The downsized connection\n\t\t// {{{\n\t\t.M_AXI_AWVALID(conl_awvalid),\n\t\t.M_AXI_AWREADY(conl_awready),\n\t\t.M_AXI_AWADDR( conl_awaddr),\n\t\t.M_AXI_AWPROT( conl_awprot),\n\n\t\t.M_AXI_WVALID(conl_wvalid),\n\t\t.M_AXI_WREADY(conl_wready),\n\t\t.M_AXI_WDATA( conl_wdata),\n\t\t.M_AXI_WSTRB( conl_wstrb),\n\n\t\t.M_AXI_BVALID(conl_bvalid),\n\t\t.M_AXI_BREADY(conl_bready),\n\t\t.M_AXI_BRESP( conl_bresp),\n\n\t\t.M_AXI_ARVALID(conl_arvalid),\n\t\t.M_AXI_ARREADY(conl_arready),\n\t\t.M_AXI_ARADDR( conl_araddr),\n\t\t.M_AXI_ARPROT( conl_arprot),\n\n\t\t.M_AXI_RVALID(conl_rvalid),\n\t\t.M_AXI_RREADY(conl_rready),\n\t\t.M_AXI_RDATA( conl_rdata),\n\t\t.M_AXI_RRESP( conl_rresp)\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\taxilcon #(\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER), .OPT_SKIDBUFFER(1'b1),\n\t\t.CONSOLE_FILE(CONSOLE_FILE)\n\t) u_console (\n\t\t// {{{\n\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t// Slave bus connection(s)\n\t\t// {{{\n\t\t.S_AXI_AWVALID(conl_awvalid),\n\t\t.S_AXI_AWREADY(conl_awready),\n\t\t.S_AXI_AWADDR( conl_awaddr[3:0]),\n\t\t.S_AXI_AWPROT( conl_awprot),\n\n\t\t.S_AXI_WVALID(conl_wvalid),\n\t\t.S_AXI_WREADY(conl_wready),\n\t\t.S_AXI_WDATA( conl_wdata),\n\t\t.S_AXI_WSTRB( conl_wstrb),\n\n\t\t.S_AXI_BVALID(conl_bvalid),\n\t\t.S_AXI_BREADY(conl_bready),\n\t\t.S_AXI_BRESP( conl_bresp),\n\n\t\t.S_AXI_ARVALID(conl_arvalid),\n\t\t.S_AXI_ARREADY(conl_arready),\n\t\t.S_AXI_ARADDR( conl_araddr[3:0]),\n\t\t.S_AXI_ARPROT( conl_arprot),\n\n\t\t.S_AXI_RVALID(conl_rvalid),\n\t\t.S_AXI_RREADY(conl_rready),\n\t\t.S_AXI_RDATA( conl_rdata),\n\t\t.S_AXI_RRESP( conl_rresp)\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused_con;\n\tassign\tunused_con = &{ 1'b0,\n\t\t\tcon_awaddr[AW-1:AW-4], con_araddr[AW-1:AW-4],\n\t\t\tconl_awaddr[AW-4:4],   conl_araddr[AW-4:4]\n\t\t\t};\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI-Lite peripheral set (timers, counters, PIC, etc.)\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\taxi2axilsub #(\n\t\t// {{{\n\t\t.C_AXI_ID_WIDTH(IW),\n\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH-3),\n\t\t.C_S_AXI_DATA_WIDTH(BUS_WIDTH),\n\t\t.C_M_AXI_DATA_WIDTH(32),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER), .OPT_WRITES(1), .OPT_READS(1)\n\t\t// }}}\n\t) u_axilpdown (\n\t\t// {{{\n\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t// The \"Wide\" slave connection\n\t\t// {{{\n\t\t.S_AXI_AWVALID(axip_awvalid),\n\t\t.S_AXI_AWREADY(axip_awready),\n\t\t.S_AXI_AWID(   axip_awid),\n\t\t.S_AXI_AWADDR( axip_awaddr[AW-4:0]),\n\t\t.S_AXI_AWLEN(  axip_awlen),\n\t\t.S_AXI_AWSIZE( axip_awsize),\n\t\t.S_AXI_AWBURST(axip_awburst),\n\t\t.S_AXI_AWLOCK( axip_awlock),\n\t\t.S_AXI_AWCACHE(axip_awcache),\n\t\t.S_AXI_AWPROT( axip_awprot),\n\t\t.S_AXI_AWQOS(  axip_awqos),\n\n\t\t.S_AXI_WVALID(axip_wvalid),\n\t\t.S_AXI_WREADY(axip_wready),\n\t\t.S_AXI_WDATA( axip_wdata),\n\t\t.S_AXI_WSTRB( axip_wstrb),\n\t\t.S_AXI_WLAST( axip_wlast),\n\n\t\t.S_AXI_BVALID(axip_bvalid),\n\t\t.S_AXI_BREADY(axip_bready),\n\t\t.S_AXI_BID(   axip_bid),\n\t\t.S_AXI_BRESP( axip_bresp),\n\n\t\t.S_AXI_ARVALID(axip_arvalid),\n\t\t.S_AXI_ARREADY(axip_arready),\n\t\t.S_AXI_ARID(   axip_arid),\n\t\t.S_AXI_ARADDR( axip_araddr[AW-4:0]),\n\t\t.S_AXI_ARLEN(  axip_arlen),\n\t\t.S_AXI_ARSIZE( axip_arsize),\n\t\t.S_AXI_ARBURST(axip_arburst),\n\t\t.S_AXI_ARLOCK( axip_arlock),\n\t\t.S_AXI_ARCACHE(axip_arcache),\n\t\t.S_AXI_ARPROT( axip_arprot),\n\t\t.S_AXI_ARQOS(  axip_arqos),\n\n\t\t.S_AXI_RVALID(axip_rvalid),\n\t\t.S_AXI_RREADY(axip_rready),\n\t\t.S_AXI_RID(   axip_rid),\n\t\t.S_AXI_RDATA( axip_rdata),\n\t\t.S_AXI_RLAST( axip_rlast),\n\t\t.S_AXI_RRESP( axip_rresp),\n\t\t// }}}\n\t\t// The downsized connection\n\t\t// {{{\n\t\t.M_AXI_AWVALID(axilp_awvalid),\n\t\t.M_AXI_AWREADY(axilp_awready),\n\t\t.M_AXI_AWADDR( axilp_awaddr),\n\t\t.M_AXI_AWPROT( axilp_awprot),\n\n\t\t.M_AXI_WVALID(axilp_wvalid),\n\t\t.M_AXI_WREADY(axilp_wready),\n\t\t.M_AXI_WDATA( axilp_wdata),\n\t\t.M_AXI_WSTRB( axilp_wstrb),\n\n\t\t.M_AXI_BVALID(axilp_bvalid),\n\t\t.M_AXI_BREADY(axilp_bready),\n\t\t.M_AXI_BRESP( axilp_bresp),\n\n\t\t.M_AXI_ARVALID(axilp_arvalid),\n\t\t.M_AXI_ARREADY(axilp_arready),\n\t\t.M_AXI_ARADDR( axilp_araddr),\n\t\t.M_AXI_ARPROT( axilp_arprot),\n\n\t\t.M_AXI_RVALID(axilp_rvalid),\n\t\t.M_AXI_RREADY(axilp_rready),\n\t\t.M_AXI_RDATA( axilp_rdata),\n\t\t.M_AXI_RRESP( axilp_rresp)\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\taxilperiphs #(\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER), .OPT_SKIDBUFFER(1'b1),\n\t\t.OPT_COUNTERS(1'b1), .EXTERNAL_INTERRUPTS(2)\n\t) u_axilp (\n\t\t// {{{\n\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t// Slave bus connection(s)\n\t\t// {{{\n\t\t.S_AXI_AWVALID(axilp_awvalid),\n\t\t.S_AXI_AWREADY(axilp_awready),\n\t\t.S_AXI_AWADDR( axilp_awaddr[5:0]),\n\t\t.S_AXI_AWPROT( axilp_awprot),\n\n\t\t.S_AXI_WVALID(axilp_wvalid),\n\t\t.S_AXI_WREADY(axilp_wready),\n\t\t.S_AXI_WDATA( axilp_wdata),\n\t\t.S_AXI_WSTRB( axilp_wstrb),\n\n\t\t.S_AXI_BVALID(axilp_bvalid),\n\t\t.S_AXI_BREADY(axilp_bready),\n\t\t.S_AXI_BRESP( axilp_bresp),\n\n\t\t.S_AXI_ARVALID(axilp_arvalid),\n\t\t.S_AXI_ARREADY(axilp_arready),\n\t\t.S_AXI_ARADDR( axilp_araddr[5:0]),\n\t\t.S_AXI_ARPROT( axilp_arprot),\n\n\t\t.S_AXI_RVALID(axilp_rvalid),\n\t\t.S_AXI_RREADY(axilp_rready),\n\t\t.S_AXI_RDATA( axilp_rdata),\n\t\t.S_AXI_RRESP( axilp_rresp),\n\t\t// }}}\n\t\t.i_cpu_reset(cpu_reset[0]),\n\t\t.i_cpu_halted(cpu_halted[0]),\n\t\t.i_cpu_gie(cpu_gie[0]),\n\t\t.i_cpu_pfstall(cpu_pf_stall[0]),\n\t\t.i_cpu_opstall(cpu_op_stall[0]),\n\t\t.i_cpu_icount(cpu_i_count[0]),\n\t\t.i_ivec({ scope_int, i_sim_int }),\n\t\t.o_interrupt(pic_interrupt),\n\t\t.o_watchdog_reset(watchdog_reset)\n\t\t// }}}\n\t);\n\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused_axip;\n\tassign\tunused_axip = &{ 1'b0,\n\t\t\taxip_awaddr[AW-1:AW-4], axip_araddr[AW-1:AW-4],\n\t\t\taxilp_awaddr[AW-4:4],   axilp_araddr[AW-4:4]\n\t\t\t};\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Optional) AXIL Scope\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_TRACE_PORT)\n\tbegin : GEN_AXILSCOPE\n\t\t// {{{",
            "wire scopel_awvalid, scopel_awready;",
            "wire [AW-4:0]\tscopel_awaddr;",
            "wire [2:0]\t\tscopel_awprot;",
            "wire scopel_wvalid, scopel_wready;",
            "wire [BUS_WIDTH-1:0]\tscopel_wdata;",
            "wire [BUS_WIDTH/8-1:0]\tscopel_wstrb;",
            "wire scopel_bvalid, scopel_bready;",
            "wire [1:0]\t\tscopel_bresp;",
            "wire scopel_arvalid, scopel_arready;",
            "wire [AW-4:0]\tscopel_araddr;",
            "wire [2:0]\t\tscopel_arprot;",
            "wire scopel_rvalid, scopel_rready;",
            "wire [BUS_WIDTH-1:0]\tscopel_rdata;",
            "wire [1:0]\t\tscopel_rresp;\n\t\t//\n\n\t\taxi2axilsub #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH-3),\n\t\t\t.C_S_AXI_DATA_WIDTH(BUS_WIDTH),\n\t\t\t.C_M_AXI_DATA_WIDTH(32),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER), .OPT_WRITES(1), .OPT_READS(1)\n\t\t\t// }}}\n\t\t) u_scopedown (\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t\t// The \"Wide\" slave connection\n\t\t\t// {{{\n\t\t\t.S_AXI_AWVALID(scope_awvalid),\n\t\t\t.S_AXI_AWREADY(scope_awready),\n\t\t\t.S_AXI_AWID(   scope_awid),\n\t\t\t.S_AXI_AWADDR( scope_awaddr[AW-4:0]),\n\t\t\t.S_AXI_AWLEN(  scope_awlen),\n\t\t\t.S_AXI_AWSIZE( scope_awsize),\n\t\t\t.S_AXI_AWBURST(scope_awburst),\n\t\t\t.S_AXI_AWLOCK( scope_awlock),\n\t\t\t.S_AXI_AWCACHE(scope_awcache),\n\t\t\t.S_AXI_AWPROT( scope_awprot),\n\t\t\t.S_AXI_AWQOS(  scope_awqos),\n\n\t\t\t.S_AXI_WVALID(scope_wvalid),\n\t\t\t.S_AXI_WREADY(scope_wready),\n\t\t\t.S_AXI_WDATA( scope_wdata),\n\t\t\t.S_AXI_WSTRB( scope_wstrb),\n\t\t\t.S_AXI_WLAST( scope_wlast),\n\n\t\t\t.S_AXI_BVALID(scope_bvalid),\n\t\t\t.S_AXI_BREADY(scope_bready),\n\t\t\t.S_AXI_BID(   scope_bid),\n\t\t\t.S_AXI_BRESP( scope_bresp),\n\n\t\t\t.S_AXI_ARVALID(scope_arvalid),\n\t\t\t.S_AXI_ARREADY(scope_arready),\n\t\t\t.S_AXI_ARID(   scope_arid),\n\t\t\t.S_AXI_ARADDR( scope_araddr[AW-4:0]),\n\t\t\t.S_AXI_ARLEN(  scope_arlen),\n\t\t\t.S_AXI_ARSIZE( scope_arsize),\n\t\t\t.S_AXI_ARBURST(scope_arburst),\n\t\t\t.S_AXI_ARLOCK( scope_arlock),\n\t\t\t.S_AXI_ARCACHE(scope_arcache),\n\t\t\t.S_AXI_ARPROT( scope_arprot),\n\t\t\t.S_AXI_ARQOS(  scope_arqos),\n\n\t\t\t.S_AXI_RVALID(scope_rvalid),\n\t\t\t.S_AXI_RREADY(scope_rready),\n\t\t\t.S_AXI_RID(   scope_rid),\n\t\t\t.S_AXI_RDATA( scope_rdata),\n\t\t\t.S_AXI_RLAST( scope_rlast),\n\t\t\t.S_AXI_RRESP( scope_rresp),\n\t\t\t// }}}\n\t\t\t// The downsized connection\n\t\t\t// {{{\n\t\t\t.M_AXI_AWVALID(scopel_awvalid),\n\t\t\t.M_AXI_AWREADY(scopel_awready),\n\t\t\t.M_AXI_AWADDR( scopel_awaddr),\n\t\t\t.M_AXI_AWPROT( scopel_awprot),\n\n\t\t\t.M_AXI_WVALID(scopel_wvalid),\n\t\t\t.M_AXI_WREADY(scopel_wready),\n\t\t\t.M_AXI_WDATA( scopel_wdata),\n\t\t\t.M_AXI_WSTRB( scopel_wstrb),\n\n\t\t\t.M_AXI_BVALID(scopel_bvalid),\n\t\t\t.M_AXI_BREADY(scopel_bready),\n\t\t\t.M_AXI_BRESP( scopel_bresp),\n\n\t\t\t.M_AXI_ARVALID(scopel_arvalid),\n\t\t\t.M_AXI_ARREADY(scopel_arready),\n\t\t\t.M_AXI_ARADDR( scopel_araddr),\n\t\t\t.M_AXI_ARPROT( scopel_arprot),\n\n\t\t\t.M_AXI_RVALID(scopel_rvalid),\n\t\t\t.M_AXI_RREADY(scopel_rready),\n\t\t\t.M_AXI_RDATA( scopel_rdata),\n\t\t\t.M_AXI_RRESP( scopel_rresp)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\taxilscope #(\n\t\t\t.LGMEM(12)\n\t\t) u_scope (\n\t\t\t// {{{\n\t\t\t.i_data_clk(i_aclk), .i_ce(1'b1), .i_trigger(1'b0),\n\t\t\t.i_data(cpu_trace), .o_interrupt(scope_int),\n\t\t\t//\n\t\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\t\t\t// Slave bus connection(s)\n\t\t\t// {{{\n\t\t\t.S_AXI_AWVALID(scopel_awvalid),\n\t\t\t.S_AXI_AWREADY(scopel_awready),\n\t\t\t.S_AXI_AWADDR( scopel_awaddr[2:0]),\n\t\t\t.S_AXI_AWPROT( scopel_awprot),\n\n\t\t\t.S_AXI_WVALID(scopel_wvalid),\n\t\t\t.S_AXI_WREADY(scopel_wready),\n\t\t\t.S_AXI_WDATA( scopel_wdata),\n\t\t\t.S_AXI_WSTRB( scopel_wstrb),\n\n\t\t\t.S_AXI_BVALID(scopel_bvalid),\n\t\t\t.S_AXI_BREADY(scopel_bready),\n\t\t\t.S_AXI_BRESP( scopel_bresp),\n\n\t\t\t.S_AXI_ARVALID(scopel_arvalid),\n\t\t\t.S_AXI_ARREADY(scopel_arready),\n\t\t\t.S_AXI_ARADDR( scopel_araddr[2:0]),\n\t\t\t.S_AXI_ARPROT( scopel_arprot),\n\n\t\t\t.S_AXI_RVALID(scopel_rvalid),\n\t\t\t.S_AXI_RREADY(scopel_rready),\n\t\t\t.S_AXI_RDATA( scopel_rdata),\n\t\t\t.S_AXI_RRESP( scopel_rresp)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\tend else begin : NO_SCOPE\n\t\t// {{{\n\t\t// The (NULL) slave that does nothing but (validly) return bus\n\t\t// errors\n\t\taxiempty #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_DATA_WIDTH(BUS_WIDTH),\n\t\t\t.C_AXI_ADDR_WIDTH(ADDRESS_WIDTH)\n\t\t\t// }}}\n\t\t) u_noscope (\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(i_aclk), .S_AXI_ARESETN(i_aresetn),\n\n\t\t\t.S_AXI_AWVALID(scope_awvalid),\n\t\t\t.S_AXI_AWREADY(scope_awready),\n\t\t\t.S_AXI_AWID(   scope_awid),\n\n\t\t\t.S_AXI_WVALID(scope_wvalid),\n\t\t\t.S_AXI_WREADY(scope_wready),\n\t\t\t.S_AXI_WLAST( scope_wlast),\n\n\t\t\t.S_AXI_BVALID(scope_bvalid),\n\t\t\t.S_AXI_BREADY(scope_bready),\n\t\t\t.S_AXI_BID(   scope_bid),\n\t\t\t.S_AXI_BRESP( scope_bresp),\n\n\t\t\t.S_AXI_ARVALID(scope_arvalid),\n\t\t\t.S_AXI_ARREADY(scope_arready),\n\t\t\t.S_AXI_ARID(   scope_arid),\n\t\t\t.S_AXI_ARLEN(  scope_arlen),\n\n\t\t\t.S_AXI_RVALID(scope_rvalid),\n\t\t\t.S_AXI_RREADY(scope_rready),\n\t\t\t.S_AXI_RID(   scope_rid),\n\t\t\t.S_AXI_RDATA( scope_rdata),\n\t\t\t.S_AXI_RLAST( scope_rlast),\n\t\t\t.S_AXI_RRESP( scope_rresp)\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\tscope_int = 1'b0;\n\t\t// }}}\n\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_scope;\n\t\tassign\tunused_scope = &{ 1'b0,\n\t\t\t\tcpu_trace,\n\t\t\t\tscope_awaddr, scope_awlen, scope_awlock, scope_awburst, scope_awsize, scope_awcache, scope_awprot, scope_awqos,\n\t\t\t\tscope_wdata, scope_wstrb,\n\t\t\t\tscope_araddr, scope_arlen, scope_arlock, scope_arburst, scope_arsize, scope_arcache, scope_arprot, scope_arqos\n\t\t\t\t};\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\tend endgenerate\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Optional) VCD generation\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n`ifndef\tVERILATOR\n\tinitial if (DUMP_TO_VCD)\n\tbegin\n\t\t$dumpfile(VCD_FILE);\n\t\t$dumpvars(0, axi_tb);\n\tend\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Test bench watchdog\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Don't let the simulation hang.  Let's place a watchdog timeout on the\n\t// CPU's data bus.  If the databus becomes idle for too long, then\n\t// stop the simulation with an error.\n\n\tinitial\twatchdog_counter = 0;\n\talways @(posedge i_aclk)\n\t// if (!i_aresetn)\n\t//\twatchdog_counter <= 0;\n\t// else\n\tif (|(cpud_awvalid & cpud_awready)\n\t\t\t\t|| |(cpud_arvalid & cpud_arready))\n\t\twatchdog_counter <= 0;\n\telse\n\t\twatchdog_counter <= watchdog_counter + 1;\n\n\talways @(posedge i_aclk)\n\tif (watchdog_counter > TB_WATCHDOG_TIMEOUT)\n\tbegin\n\t\t$display(\"\\nERROR: Watchdog timeout!\");\n\t\t$finish;\n\tend\n\n\talways @(posedge i_aclk)\n\tif (i_aresetn && (&cpu_halted))\n\tbegin\n\t\t$display(\"\\nCPU Halted without error: PASS\\n\");\n\t\t$finish;\n\tend\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "wb_tb.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/wb_tb.v",
        "chunks": [
            "module wb_tb #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH        = 28,\t//Width in bytes",
            "parameter BUS_WIDTH            = 32,\n\t\t// Verilator lint_off WIDTH",
            "parameter [0:0]\tOPT_ZIPBONES         = 1'b1,",
            "parameter [0:0]\tOPT_PIPELINED        = 1'b1,",
            "parameter OPT_LGICACHE         = 12,",
            "parameter OPT_LGDCACHE         = 12,",
            "parameter OPT_MPY              = 3,",
            "parameter [0:0]\tOPT_DIV              = 1'b1,",
            "parameter [0:0]\tOPT_SHIFTS           = 1'b1,",
            "parameter [0:0]\tOPT_LOCK             = 1'b1,",
            "parameter [0:0]\tOPT_EARLY_BRANCHING  = 1'b1,",
            "parameter [0:0]\tOPT_LOWPOWER         = 1'b1,",
            "parameter [0:0]\tOPT_DISTRIBUTED_REGS = 1'b1,",
            "parameter [0:0]\tOPT_USERMODE         = 1'b1,",
            "parameter [0:0]\tOPT_CLKGATE          = 1'b1,",
            "parameter [0:0]\tOPT_DBGPORT          = 1'b1,",
            "parameter [0:0]\tOPT_TRACE_PORT       = 1'b1,",
            "parameter [0:0]\tOPT_CIS              = 1'b1,",
            "parameter [0:0]\tOPT_DMA              = 1'b1,",
            "parameter OPT_SMP              = 1, // Must be > 0",
            "parameter MEM_FILE = \"cputest\",",
            "parameter CONSOLE_FILE = \"console.txt\",",
            "parameter LGMEMSZ = ADDRESS_WIDTH-2,\n\t\t//",
            "parameter [0:0]\tDUMP_TO_VCD = 1'b0,",
            "parameter VCD_FILE = \"dump.vcd\"\n\t\t// Verilator lint_on  WIDTH\n\t\t// }}}\n\t) (\n\t\t// {{{\n`ifdef\tVERILATOR",
            "input ",
            "wire i_clk, i_reset,\n\t\t// Sim control",
            "input (s)\n\t\t// {{{",
            "input ",
            "wire i_sim_cyc, i_sim_stb, i_sim_we,",
            "input ",
            "wire [ADDRESS_WIDTH-2:0]\ti_sim_addr,",
            "input ",
            "wire [31:0]\t\t\ti_sim_data,",
            "input ",
            "wire [3:0]\t\t\ti_sim_sel,",
            "output ",
            "wire o_sim_stall,",
            "output ",
            "wire o_sim_ack,",
            "output ",
            "wire [31:0]\t\t\to_sim_data,",
            "output ",
            "wire o_sim_err,\n\t\t// }}}",
            "input ",
            "wire i_sim_int,\n\t\t//\n\t\t// \"Profiler\" support.  This is a simulation only port.\n\t\t// {{{",
            "output ",
            "wire o_prof_stb,",
            "output ",
            "wire [ADDRESS_WIDTH-1:0]\to_prof_addr,",
            "output ",
            "wire [31:0]\t\t\to_prof_ticks\n\t\t// }}}\n`endif\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{\n\tgenvar\t\tgk;",
            "localparam WBLSB = $clog2(BUS_WIDTH/8);",
            "parameter [31:0] RESET_ADDRESS = { {(32-ADDRESS_WIDTH){1'b0}}, MEMORY_ADDR, {(WBLSB){1'b0}} };",
            "localparam WAW = ADDRESS_WIDTH-WBLSB;",
            "parameter [WAW-1:0]\tSCOPE_ADDR   = { 4'b0001, {(WAW-4){1'b0}} };",
            "parameter [WAW-1:0]\tCONSOLE_ADDR = { 4'b0010, {(WAW-4){1'b0}} };",
            "parameter [WAW-1:0]\tSMP_BASE_ADDR = { 4'b0011, {(WAW-4){1'b0}} };",
            "parameter [WAW-1:0]\tZDMA_CHECK_ADDR = { 4'b0101, {(WAW-4){1'b0}} };",
            "parameter [WAW-1:0]\tZDMA_CHECKST_ADDR = { 4'b0110, {(WAW-4){1'b0}} };",
            "parameter [WAW-1:0]\tZSYS_ADDR = { {(ADDRESS_WIDTH-24){1'b1}}, {(24-WBLSB){1'b0}} };",
            "parameter [WAW-1:0]\tMEMORY_ADDR  = { 2'b01, {(WAW-2){1'b0}} };",
            "localparam LGFIFO = 4;",
            "localparam MIN_SMP = (OPT_SMP < 2) ? 1 : OPT_SMP;",
            "parameter [OPT_SMP*WAW-1:0]\tSMP_ADDR = SMP_ADDR_fn(MIN_SMP);",
            "parameter [OPT_SMP*WAW-1:0]\tSMP_MASK = SMP_MASK_fn(MIN_SMP);\n\n\t// Verilator lint_off UNUSED\n\tfunction [OPT_SMP*WAW-1:0]\tSMP_ADDR_fn(",
            "input integer min_smp);\n\t\t// {{{\n\t\tinteger\tik, offset;\n\tbegin\n\t\tSMP_ADDR_fn = {(OPT_SMP){SMP_BASE_ADDR}};\n\n\t\tfor(ik=1; ik < OPT_SMP; ik=ik+1)\n\t\tbegin\n\t\t\toffset = ik;\n\t\t\tSMP_ADDR_fn[ik*WAW+(9-WBLSB) +: $clog2(OPT_SMP)+1]\n\t\t\t\t= offset[$clog2(OPT_SMP):0];\n\t\tend\n\tend endfunction\n\t// }}}\n\n\tfunction [OPT_SMP*WAW-1:0]\tSMP_MASK_fn(",
            "input integer min_smp);\n\t\t// {{{\n\t\tinteger\tik;\n\tbegin\n\t\tSMP_MASK_fn = {(OPT_SMP){ 4'b1111, {(WAW-4){1'b0}} }};\n\n\t\tfor(ik=0; ik < OPT_SMP; ik=ik+1)\n\t\tbegin\n\t\t\tSMP_MASK_fn[ik*WAW+(9-WBLSB) +: $clog2(OPT_SMP)+1]\n\t\t\t\t= {($clog2(OPT_SMP)+1){1'b1}};\n\t\tend\n\tend endfunction\n\t// Verilator lint_on  UNUSED\n\t// }}}",
            "wire [OPT_SMP-1:0]\tcpu_int;\n\t// Verilator lint_off UNUSED",
            "wire [OPT_SMP-1:0]\tcpu_halted, cpu_op_stall, cpu_pf_stall,\n\t\t\t\tcpu_i_count, cpu_gie;\n\t// Verilator lint_on  UNUSED",
            "wire scope_int;",
            "wire [31:0]\t\tcpu_trace;",
            "wire dbg_cyc, dbg_stb, dbg_we, dbg_stall, dbg_ack, dbg_err;",
            "wire [ADDRESS_WIDTH+1-$clog2(32/8)-1:0]\tdbg_addr;",
            "wire [31:0]\tdbg_data, dbg_idata;",
            "wire [3:0]\tdbg_sel;",
            "wire [OPT_SMP-1:0]\t\tsmpw_cyc, smpw_stb, smpw_we,\n\t\t\t\t\tsmpw_stall, smpw_ack, smpw_err;",
            "wire [OPT_SMP*WAW-1:0]\tsmpw_addr;",
            "wire [OPT_SMP*BUS_WIDTH-1:0]\tsmpw_data, smpw_idata;",
            "wire [OPT_SMP*BUS_WIDTH/8-1:0]\tsmpw_sel;",
            "wire pic_int, timer_a_int, timer_b_int, timer_c_int,\n\t\t\tjiffies_int;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// CPU bus declarations\n\t// {{{",
            "wire [OPT_SMP-1:0]\t\tcpu_cyc, cpu_stb, cpu_we,\n\t\t\t\t\tcpu_ack, cpu_stall, cpu_err;",
            "wire [OPT_SMP*WAW-1:0]\tcpu_addr;",
            "wire [OPT_SMP*BUS_WIDTH-1:0]\tcpu_data, cpu_idata;",
            "wire [OPT_SMP*BUS_WIDTH/8-1:0]\tcpu_sel;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Memory bus declarations\n\t// {{{",
            "wire mem_cyc, mem_stb, mem_we, mem_ack, mem_stall, mem_err;",
            "wire [WAW-1:0]\t\tmem_addr;",
            "wire [BUS_WIDTH-1:0]\t\tmem_data, mem_idata;",
            "wire [BUS_WIDTH/8-1:0]\tmem_sel;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Console bus declarations\n\t// {{{",
            "wire conw_cyc, conw_stb, conw_we, conw_ack, conw_stall, conw_err;",
            "wire [WAW-1:0]\t\tconw_addr;",
            "wire [BUS_WIDTH-1:0]\t\tconw_data, conw_idata;",
            "wire [BUS_WIDTH/8-1:0]\tconw_sel;",
            "wire con_cyc, con_stb, con_we, con_ack, con_stall, con_err;",
            "wire [ADDRESS_WIDTH-3-$clog2(32/8)-1:0]\tcon_addr;",
            "wire [31:0]\tcon_data, con_idata;",
            "wire [3:0]\tcon_sel;",
            "reg r_con_ack;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// ZipCPU System bus declarations\n\t// {{{",
            "wire zsysw_cyc, zsysw_stb, zsysw_we,\n\t\t\t\t\tzsysw_ack, zsysw_stall, zsysw_err;",
            "wire [WAW-1:0]\t\tzsysw_addr;",
            "wire [BUS_WIDTH-1:0]\t\tzsysw_data, zsysw_idata;",
            "wire [BUS_WIDTH/8-1:0]\tzsysw_sel;",
            "wire zsys_cyc, zsys_stb, zsys_we,\n\t\t\t\t\tzsys_ack, zsys_stall, zsys_err;",
            "wire [WAW+WBLSB-$clog2(32/8)-5:0]\tzsys_addr;",
            "wire [31:0]\t\t\tzsys_data, zsys_idata;",
            "wire [3:0]\t\t\tzsys_sel;",
            "reg r_zsys_ack;",
            "reg [31:0]\t\t\tr_zsys_data;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Optional) DMA bus declarations\n\t// {{{",
            "wire dmac_cyc, dmac_stb, dmac_we;",
            "wire [WAW-1:0]\t\tdmac_addr;",
            "wire [BUS_WIDTH-1:0]\t\tdmac_data;",
            "wire [BUS_WIDTH/8-1:0]\tdmac_sel;\n\n\t// Verilator lint_off UNUSED",
            "wire dmac_int;",
            "wire dmac_ack, dmac_stall, dmac_err;",
            "wire [BUS_WIDTH-1:0]\t\tdmac_return;\n\t// Verilator lint_on  UNUSED\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Optional SCOPE\n\t// {{{",
            "wire scopew_cyc, scopew_stb, scopew_we, scopew_ack, scopew_stall,\n\t\tscopew_err;",
            "wire [ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)-1:0]\tscopew_addr;",
            "wire [BUS_WIDTH-1:0]\t\tscopew_data, scopew_idata;",
            "wire [BUS_WIDTH/8-1:0]\tscopew_sel;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Optional ZIPDMA_Check\n\t// {{{",
            "wire zdmacw_cyc, zdmacw_stb, zdmacw_we, zdmacw_ack, zdmacw_stall,\n\t\tzdmacw_err;",
            "wire [ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)-1:0]\tzdmacw_addr;",
            "wire [BUS_WIDTH-1:0]\t\tzdmacw_data, zdmacw_idata;",
            "wire [BUS_WIDTH/8-1:0]\tzdmacw_sel;",
            "wire zdmacstw_cyc, zdmacstw_stb, zdmacstw_we, zdmacstw_ack, zdmacstw_stall,\n\t\tzdmacstw_err;",
            "wire [ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)-1:0]\tzdmacstw_addr;",
            "wire [BUS_WIDTH-1:0]\tzdmacstw_data, zdmacstw_idata;",
            "wire [BUS_WIDTH/8-1:0]\tzdmacstw_sel;",
            "wire zdmacst_cyc, zdmacst_stb, zdmacst_we;",
            "wire [ADDRESS_WIDTH-3-$clog2(32/8)-1:0]\tzdmacst_addr;",
            "wire [31:0]\tzdmacst_data, zdmacst_idata;",
            "wire [3:0]\tzdmacst_sel;",
            "wire zdmacst_stall, zdmacst_ack, zdmacst_err;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// ZipSystem replacement(s)\n\t// {{{",
            "wire pic_stall, pic_ack;",
            "wire [31:0]\tpic_data;",
            "wire timer_a_stall, timer_b_stall, timer_c_stall,\n\t\t\tjiffies_stall;\t// Jiffies",
            "wire timer_a_ack, timer_b_ack, timer_c_ack,\n\t\t\tjiffies_ack;\t// Jiffies",
            "wire [31:0]\ttimer_a_data, timer_b_data, timer_c_data,\n\t\t\tjiffies_data;\t// Jiffies",
            "wire [31:0]\tdma_slv_data;",
            "wire [31:0]\tmtc_data, moc_data, mpc_data, mic_data;",
            "wire [31:0]\tutc_data, uoc_data, upc_data, uic_data;\n\n\t// Verilator lint_off UNUSED",
            "wire ign_mtc_stall, ign_moc_stall,\n\t\t\tign_mpc_stall, ign_mic_stall;",
            "wire ign_utc_stall, ign_uoc_stall,\n\t\t\tign_upc_stall, ign_uic_stall;",
            "wire ign_mtc_ack, ign_moc_ack,\n\t\t\tign_mpc_ack, ign_mic_ack;",
            "wire ign_utc_ack, ign_uoc_ack,\n\t\t\tign_upc_ack, ign_uic_ack;",
            "wire mtc_int, moc_int, mpc_int, mic_int;",
            "wire utc_int, uoc_int, upc_int, uic_int;\n\t// Verilator lint_on  UNUSED",
            "reg zsys_stb_d;",
            "reg [WAW+WBLSB-$clog2(32/8)-5:0]\tzsys_addr_d;\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Traditional TB support\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n`ifndef\tVERILATOR",
            "wire i_sim_cyc, i_sim_stb, i_sim_we;",
            "wire [ADDRESS_WIDTH-2:0]\ti_sim_addr;",
            "wire [31:0]\t\t\ti_sim_data;",
            "wire [3:0]\t\t\ti_sim_sel;",
            "wire o_sim_stall;",
            "wire o_sim_ack;",
            "wire [31:0]\t\t\to_sim_data;",
            "wire o_sim_err;",
            "wire i_sim_int;",
            "wire o_prof_stb;\n\t//",
            "wire [31:0]\t\t\to_prof_addr;",
            "wire [ADDRESS_WIDTH-1:0]\to_prof_addr;",
            "wire [31:0]\t\t\to_prof_ticks;",
            "reg i_clk, i_reset, reset_pipe;\n\n\tinitial\ti_clk = 0;\n\talways\n\t\t#5 i_clk = !i_clk;\n\n\tinitial\t{ i_reset, reset_pipe } = -1;\n\talways @(posedge i_clk)\n\t\t{ i_reset, reset_pipe } <= { reset_pipe, 1'b0 };\n\n\t// Tie off (unused) Sim control",
            "input (s)\n\t// {{{\n\tassign\ti_sim_cyc = 1'b0;\n\tassign\ti_sim_stb = 1'b0;\n\tassign\ti_sim_we  = 1'b0;\n\tassign\ti_sim_addr = 0;\n\tassign\ti_sim_data = 0;\n\tassign\ti_sim_sel  = 0;\n\t// }}}\n\tassign\ti_sim_int  = 1'b0;\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// External sim port: Either controls ZipCPU or wide WB bus\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n`ifdef\tVERILATOR\n\t// Only required if we are using Verilator.  Other test benches won't\n\t// use this",
            "input port",
            "wire sim_cyc, sim_stb, sim_we,\n\t\t\t\tsim_stall, sim_ack, sim_err;",
            "wire [ADDRESS_WIDTH+1-$clog2(32/8)-1:0]\tsim_addr;",
            "wire [31:0]\t\tsim_data, sim_idata;",
            "wire [32/8-1:0]\tsim_sel;",
            "wire simw_cyc, simw_stb, simw_we,\n\t\t\t\tsimw_stall, simw_ack, simw_err;",
            "wire [ADDRESS_WIDTH+1-$clog2(BUS_WIDTH/8)-1:0]\tsimw_addr;",
            "wire [BUS_WIDTH-1:0]\tsimw_data, simw_idata;",
            "wire [BUS_WIDTH/8-1:0]\tsimw_sel;\n\n\twbxbar #(\n\t\t// {{{\n\t\t.NM(1), .NS(2), .AW(ADDRESS_WIDTH+1-$clog2(32/8)), .DW(32),\n\t\t.SLAVE_ADDR({\n\t\t\t{ 1'b0, {(ADDRESS_WIDTH-$clog2(32/8)){1'b0}} },\n\t\t\t{ 1'b1, {(ADDRESS_WIDTH-$clog2(32/8)){1'b0}} }}), // CPU\n\t\t.SLAVE_MASK({\n\t\t\t{ 1'b0, {(ADDRESS_WIDTH-$clog2(32/8)){1'b0}} },\n\t\t\t{ 1'b1, {(ADDRESS_WIDTH-$clog2(32/8)){1'b0}} }})  // CPU\n\t\t// }}}\n\t) simxbar (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t// One master: the SIM bus",
            "input // {{{\n\t\t.i_mcyc(i_sim_cyc), .i_mstb(i_sim_stb), .i_mwe(i_sim_we),\n\t\t.i_maddr(i_sim_addr), .i_mdata(i_sim_data), .i_msel(i_sim_sel),\n\t\t//\n\t\t.o_mstall(o_sim_stall), .o_mack(o_sim_ack),.o_mdata(o_sim_data),\n\t\t\t.o_merr(o_sim_err),\n\t\t// }}}\n\t\t// Two slaves: The wide bus the ZipCPU masters, and the ZipCPU's\n\t\t// debug port\n\t\t// {{{\n\t\t.o_scyc({  sim_cyc, dbg_cyc  }),\n\t\t.o_sstb({  sim_stb, dbg_stb  }),\n\t\t.o_swe({   sim_we,  dbg_we   }),\n\t\t.o_saddr({ sim_addr,dbg_addr }),\n\t\t.o_sdata({ sim_data,dbg_data }),\n\t\t.o_ssel({  sim_sel, dbg_sel  }),\n\t\t//\n\t\t.i_sstall({ sim_stall, dbg_stall }),\n\t\t.i_sack({   sim_ack,   dbg_ack   }),\n\t\t.i_sdata({  sim_idata, dbg_idata }),\n\t\t.i_serr({   sim_err,   dbg_err   })\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\tassign\tsimw_cyc   = sim_cyc;\n\tassign\tsimw_we    = sim_we;\n\tassign\tsim_ack    = simw_ack;\n\tassign\tsim_err    = simw_err;\n\n\tgenerate if (BUS_WIDTH == 32)\n\tbegin : NO_EXPAND_SIMBUS\n\t\t// {{{\n\t\tassign\tsimw_stb  = sim_stb;\n\t\tassign\tsimw_addr = sim_addr;\n\t\tassign\tsimw_data = sim_data;\n\t\tassign\tsimw_sel  = sim_sel;\n\t\tassign\tsim_stall = simw_stall;\n\t\tassign\tsim_idata = simw_idata;\n\t\t// }}}\n\tend else begin : GEN_EXPAND_SIMBUS\n\t\t// {{{",
            "wire fifo_full, fifo_empty;",
            "wire [LGFIFO:0]\tfifo_fill;",
            "wire [$clog2(BUS_WIDTH/8)-$clog2(32/8)-1:0]\tfifo_addr;",
            "wire [BUS_WIDTH-1:0]\twide_idata;\n\n\t\tassign\tsimw_stb   = sim_stb    && !fifo_full;\n\t\tassign\tsim_stall  = simw_stall ||  fifo_full;\n\n\t\tassign\tsimw_addr = sim_addr[ADDRESS_WIDTH+1-$clog2(32/8)-1:$clog2(BUS_WIDTH/32)];\n\t\tassign\tsimw_sel  = { sim_sel, {(BUS_WIDTH/8-4){1'b0}} } >> (4*simw_addr[$clog2(BUS_WIDTH/8)-1:2]);\n\t\tassign\tsimw_data = { sim_data, {(BUS_WIDTH-32){1'b0}} } >> (32*simw_addr[$clog2(BUS_WIDTH/8)-1:2]);\n\n\t\tsfifo #(\n\t\t\t// {{{\n\t\t\t.LGFLEN(LGFIFO),\n\t\t\t.OPT_READ_ON_EMPTY(1'b1),\n\t\t\t.BW($clog2(BUS_WIDTH/32))\n\t\t\t// }}}\n\t\t) u_simaddr_fifo (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t.i_wr(simw_stb && !sim_stall),\n\t\t\t.i_data(simw_addr[$clog2(BUS_WIDTH/8)-1:2]),\n\t\t\t.o_full(fifo_full), .o_fill(fifo_fill),\n\t\t\t.i_rd(simw_ack), .o_data(fifo_addr),\n\t\t\t.o_empty(fifo_empty)\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\twide_idata = simw_idata << (32*fifo_addr);\n\t\tassign\tsim_idata  = wide_idata[BUS_WIDTH-1:BUS_WIDTH-32];\n\n\t\t// Keep Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_sim_expander;\n\t\tassign\tunused_sim_expander = &{ 1'b0,\n\t\t\tfifo_fill, fifo_empty, wide_idata[BUS_WIDTH-32-1:0],\n\t\t\tsim_addr[$clog2(BUS_WIDTH/32):0] };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\t\t// }}}\n\tend endgenerate\n`else\n\t// If we aren't using Verilator, then there's no external bus driver.\n\t// Cap off the debug port therefore.\n\t//\n\n\tassign\tdbg_cyc = 1'b0;\n\tassign\tdbg_stb = 1'b0;\n\tassign\tdbg_we  = 1'b0;\n\tassign\tdbg_data= 32'h0;\n\tassign\tdbg_sel = 4'h0;\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The CPU itself\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "localparam RESET_DURATION = 10;",
            "localparam [0:0]\tOPT_SIM = 1'b1;\n`ifdef\tVERILATOR",
            "localparam [0:0]\tOPT_PROFILER = 1'b1;\n`else",
            "localparam [0:0]\tOPT_PROFILER = 1'b0;\n`endif\n\n\tgenerate if (OPT_ZIPBONES)\n\tbegin : GEN_ZIPBONES\n\n\t\tzipbones #(\n\t\t\t// {{{\n\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t\t.RESET_ADDRESS(RESET_ADDRESS),\n\t\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t\t.OPT_LGICACHE(OPT_LGICACHE),\n\t\t\t.OPT_LGDCACHE(OPT_LGDCACHE),\n\t\t\t.START_HALTED(1'b0),\n\t\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t\t.OPT_MPY(OPT_MPY),\n\t\t\t.OPT_DIV(OPT_DIV),\n\t\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t\t.OPT_LOCK(OPT_LOCK),\n\t\t\t.OPT_CIS(OPT_CIS),\n\t\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t\t.OPT_DBGPORT(OPT_DBGPORT),\n\t\t\t.OPT_TRACE_PORT(OPT_TRACE_PORT),\n\t\t\t.OPT_PROFILER(OPT_PROFILER),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_SIM(OPT_SIM),\n\t\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t\t.RESET_DURATION(RESET_DURATION)\n\t\t\t// }}}\n\t\t) u_cpu (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t// Master bus\n\t\t\t// {{{\n\t\t\t.o_wb_cyc(cpu_cyc[0]), .o_wb_stb(cpu_stb[0]),\n\t\t\t.o_wb_we(cpu_we[0]),\n\t\t\t.o_wb_addr(cpu_addr[WAW-1:0]),\n\t\t\t\t.o_wb_data(cpu_data[BUS_WIDTH-1:0]),\n\t\t\t\t.o_wb_sel(cpu_sel[BUS_WIDTH/8-1:0]),\n\t\t\t.i_wb_stall(cpu_stall[0]), .i_wb_ack(cpu_ack[0]),\n\t\t\t\t.i_wb_data(cpu_idata[BUS_WIDTH-1:0]),\n\t\t\t\t.i_wb_err(cpu_err[0]),\n\t\t\t// }}}\n\t\t\t.i_ext_int(pic_int), .o_ext_int(cpu_int[0]),\n\t\t\t// Debug control port\n\t\t\t// {{{\n\t\t\t.i_dbg_cyc(dbg_cyc), .i_dbg_stb(dbg_stb),\n\t\t\t\t.i_dbg_we(dbg_we), .i_dbg_addr(dbg_addr[5:0]),\n\t\t\t\t.i_dbg_data(dbg_data), .i_dbg_sel(dbg_sel),\n\t\t\t.o_dbg_stall(dbg_stall), .o_dbg_ack(dbg_ack),\n\t\t\t\t.o_dbg_data(dbg_idata),\n\t\t\t// }}}\n\t\t\t.o_cpu_debug(cpu_trace),\n\t\t\t// (Optional) Profiler\n\t\t\t// {{{\n\t\t\t.o_prof_stb(o_prof_stb),\n\t\t\t.o_prof_addr(o_prof_addr),\n\t\t\t.o_prof_ticks(o_prof_ticks)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\tcpu_halted[0]   = u_cpu.cpu_has_halted;\n\t\tassign\tcpu_op_stall[0] = u_cpu.cpu_op_stall;\n\t\tassign\tcpu_pf_stall[0] = u_cpu.cpu_pf_stall;\n\t\tassign\tcpu_i_count[0]  = u_cpu.cpu_i_count;\n\t\tassign\tcpu_gie[0]      = u_cpu.cpu_dbg_cc[1];\n\n\tend else begin : GEN_ZIPSYSTEM\n\n\t\tzipsystem #(\n\t\t\t// {{{\n\t\t\t.RESET_ADDRESS(RESET_ADDRESS),\n\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t\t.OPT_LGICACHE(OPT_LGICACHE),\n\t\t\t.OPT_LGDCACHE(OPT_LGDCACHE),\n\t\t\t.START_HALTED(1'b0),\n\t\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t\t.OPT_MPY(OPT_MPY),\n\t\t\t.OPT_DIV(OPT_DIV),\n\t\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t\t.OPT_LOCK(OPT_LOCK),\n\t\t\t.OPT_CIS(OPT_CIS),\n\t\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t\t.OPT_DBGPORT(OPT_DBGPORT),\n\t\t\t.OPT_TRACE_PORT(OPT_TRACE_PORT),\n\t\t\t.OPT_PROFILER(OPT_PROFILER),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_SIM(OPT_SIM),\n\t\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t\t.RESET_DURATION(RESET_DURATION),\n\t\t\t// ZipSystem only",
            "parameter s\n\t\t\t.OPT_DMA(OPT_DMA),\n\t\t\t.OPT_ACCOUNTING(1'b1),\n\t\t\t.EXTERNAL_INTERRUPTS(1)\n\t\t\t// }}}\n\t\t) u_cpu (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t// Master bus\n\t\t\t// {{{\n\t\t\t.o_wb_cyc(cpu_cyc[0]), .o_wb_stb(cpu_stb[0]),\n\t\t\t.o_wb_we(cpu_we[0]),\n\t\t\t.o_wb_addr(cpu_addr[WAW-1:0]), .o_wb_data(cpu_data[BUS_WIDTH-1:0]),\n\t\t\t\t.o_wb_sel(cpu_sel[BUS_WIDTH/8-1:0]),\n\t\t\t.i_wb_stall(cpu_stall[0]), .i_wb_ack(cpu_ack[0]),\n\t\t\t\t.i_wb_data(cpu_idata[BUS_WIDTH-1:0]),\n\t\t\t\t.i_wb_err(cpu_err[0]),\n\t\t\t// }}}\n\t\t\t.i_ext_int({ i_sim_int }),\n\t\t\t.o_ext_int(cpu_int[0]),\n\t\t\t// Debug control port\n\t\t\t// {{{\n\t\t\t.i_dbg_cyc(dbg_cyc), .i_dbg_stb(dbg_stb),\n\t\t\t\t.i_dbg_we(dbg_we), .i_dbg_addr(dbg_addr[6:0]),\n\t\t\t\t.i_dbg_data(dbg_data), .i_dbg_sel(dbg_sel),\n\t\t\t.o_dbg_stall(dbg_stall), .o_dbg_ack(dbg_ack),\n\t\t\t\t.o_dbg_data(dbg_idata),\n\t\t\t// }}}\n\t\t\t.o_cpu_debug(cpu_trace),\n\t\t\t// (Optional) Profiler\n\t\t\t// {{{\n\t\t\t.o_prof_stb(o_prof_stb),\n\t\t\t.o_prof_addr(o_prof_addr),\n\t\t\t.o_prof_ticks(o_prof_ticks)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\tcpu_halted[0]   = u_cpu.cpu_has_halted;\n\t\tassign\tcpu_op_stall[0] = u_cpu.cpu_op_stall;\n\t\tassign\tcpu_pf_stall[0] = u_cpu.cpu_pf_stall;\n\t\tassign\tcpu_i_count[0]  = u_cpu.cpu_i_count;\n\t\tassign\tcpu_gie[0]      = u_cpu.cpu_gie;\n\n\t\t// Keep Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_zipsys;\n\t\tassign\tunused_zipsys = &{ 1'b0, pic_int };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\n\tassign\tdbg_err = 1'b0;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Extra CPU's, if running in multiprocessor mode (OPT_SMP > 1)\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// No slave connection\n\t// {{{",
            "reg r_smp_err;\n\n\tinitial\tr_smp_err = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_smp_err <= 1'b0;\n\telse\n\t\tr_smp_err <= smpw_stb[0];\n\n\tassign\tsmpw_stall[0] = 1'b0;\n\tassign\tsmpw_ack[0]   = 1'b0;\n\tassign\tsmpw_idata[BUS_WIDTH-1:0] = {(BUS_WIDTH){1'b0}};\n\tassign\tsmpw_err[0]   = r_smp_err;\n\n\t// Keep Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused_smpw;\n\tassign\tunused_smpw = &{ 1'b0, smpw_cyc[0], smpw_we[0],\n\t\t\t\tsmpw_addr[WAW-1:0],\n\t\t\t\tsmpw_data[BUS_WIDTH-1:0],\n\t\t\t\tsmpw_sel[BUS_WIDTH/8-1:0]\n\t\t\t\t};\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n\t// }}}\n\n\tgenerate for (gk=1; gk<OPT_SMP; gk=gk+1)\n\tbegin : GEN_SMPCPU\n\t\t// Local declarations\n\t\t// {{{",
            "wire [31:0]\t\tsmp_trace;",
            "wire smp_prof_stb;",
            "wire [ADDRESS_WIDTH-1:0]\tsmp_prof_addr;",
            "wire [31:0]\t\tsmp_prof_ticks;",
            "wire smp_cyc, smp_stb, smp_we;",
            "wire [6:0]\tsmp_addr;",
            "wire [31:0]\tsmp_data;",
            "wire [3:0]\tsmp_sel;",
            "wire smp_stall, smp_ack, smp_err;",
            "wire [31:0]\tsmp_idata;\n\t\t// }}}\n\n\t\twbdown #(\n\t\t\t// {{{\n\t\t\t.ADDRESS_WIDTH(9),\n\t\t\t.WIDE_DW(BUS_WIDTH), .SMALL_DW(32)\n\t\t\t// }}}\n\t\t) u_smpdown (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t// The \"Wide\" connection\n\t\t\t// {{{\n\t\t\t.i_wcyc(smpw_cyc[gk]), .i_wstb(smpw_stb[gk]), .i_wwe(smpw_we[gk]),\n\t\t\t.i_waddr(smpw_addr[gk * WAW +: (9-WBLSB)]),\n\t\t\t\t.i_wdata(smpw_data[gk*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t.i_wsel(smpw_sel[gk*BUS_WIDTH/8 +: BUS_WIDTH/8]),\n\t\t\t//\n\t\t\t.o_wstall(smpw_stall[gk]), .o_wack(smpw_ack[gk]),\n\t\t\t\t.o_wdata(smpw_idata[gk*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t.o_werr(smpw_err[gk]),\n\t\t\t// }}}\n\t\t\t// The downsized connection\n\t\t\t// {{{\n\t\t\t.o_cyc(smp_cyc), .o_stb(smp_stb), .o_we(smp_we),\n\t\t\t.o_addr(smp_addr), .o_data(smp_data), .o_sel(smp_sel),\n\t\t\t//\n\t\t\t.i_stall(smp_stall), .i_ack(smp_ack),\n\t\t\t\t.i_data(smp_idata),\n\t\t\t\t.i_err(smp_err)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\tsmp_err = 1'b0;\n\n\t\tif (OPT_ZIPBONES)\n\t\tbegin : GEN_ZIPBONES\n\n\t\t\tzipbones #(\n\t\t\t\t// {{{\n\t\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t\t\t.RESET_ADDRESS(RESET_ADDRESS),\n\t\t\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t\t\t.OPT_LGICACHE(OPT_LGICACHE),\n\t\t\t\t.OPT_LGDCACHE(OPT_LGDCACHE),\n\t\t\t\t.START_HALTED(1'b1),\n\t\t\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t\t\t.OPT_MPY(OPT_MPY),\n\t\t\t\t.OPT_DIV(OPT_DIV),\n\t\t\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t\t\t.OPT_LOCK(OPT_LOCK),\n\t\t\t\t.OPT_CIS(OPT_CIS),\n\t\t\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t\t\t.OPT_DBGPORT(OPT_DBGPORT),\n\t\t\t\t.OPT_TRACE_PORT(OPT_TRACE_PORT),\n\t\t\t\t.OPT_PROFILER(OPT_PROFILER),\n\t\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t\t.OPT_SIM(OPT_SIM),\n\t\t\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t\t\t.RESET_DURATION(RESET_DURATION)\n\t\t\t\t// }}}\n\t\t\t) u_smp (\n\t\t\t\t// {{{\n\t\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t\t// Master bus\n\t\t\t\t// {{{\n\t\t\t\t.o_wb_cyc(cpu_cyc[gk]),\n\t\t\t\t.o_wb_stb(cpu_stb[gk]),\n\t\t\t\t.o_wb_we(cpu_we[gk]),\n\t\t\t\t.o_wb_addr(cpu_addr[gk*WAW +: WAW]),\n\t\t\t\t.o_wb_data(cpu_data[gk*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t.o_wb_sel(cpu_sel[gk*BUS_WIDTH/8 +: BUS_WIDTH/8]),\n\t\t\t\t.i_wb_stall(cpu_stall[gk]),\n\t\t\t\t\t.i_wb_ack(cpu_ack[gk]),\n\t\t\t\t\t.i_wb_data(cpu_idata[gk*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t\t.i_wb_err(cpu_err[gk]),\n\t\t\t\t// }}}\n\t\t\t\t.i_ext_int(pic_int), .o_ext_int(cpu_int[gk]),\n\t\t\t\t// Debug control port\n\t\t\t\t// {{{\n\t\t\t\t.i_dbg_cyc(smp_cyc), .i_dbg_stb(smp_stb),\n\t\t\t\t\t.i_dbg_we(smp_we), .i_dbg_addr(smp_addr[5:0]),\n\t\t\t\t\t.i_dbg_data(smp_data), .i_dbg_sel(smp_sel),\n\t\t\t\t.o_dbg_stall(smp_stall), .o_dbg_ack(smp_ack),\n\t\t\t\t\t.o_dbg_data(smp_idata),\n\t\t\t\t// }}}\n\t\t\t\t.o_cpu_debug(smp_trace),\n\t\t\t\t// (Optional) Profiler\n\t\t\t\t// {{{\n\t\t\t\t.o_prof_stb(smp_prof_stb),\n\t\t\t\t.o_prof_addr(smp_prof_addr),\n\t\t\t\t.o_prof_ticks(smp_prof_ticks)\n\t\t\t\t// }}}\n\t\t\t\t// }}}\n\t\t\t);\n\n\t\t\tassign\tcpu_halted[gk]   = u_smp.cpu_has_halted;\n\t\t\tassign\tcpu_op_stall[gk] = u_smp.cpu_op_stall;\n\t\t\tassign\tcpu_pf_stall[gk] = u_smp.cpu_pf_stall;\n\t\t\tassign\tcpu_i_count[gk]  = u_smp.cpu_i_count;\n\t\t\tassign\tcpu_gie[gk]      = u_smp.cpu_dbg_cc[1];\n\n\t\tend else begin : GEN_ZIPSYSTEM\n\n\t\t\tzipsystem #(\n\t\t\t\t// {{{\n\t\t\t\t.RESET_ADDRESS(RESET_ADDRESS),\n\t\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t\t\t.BUS_WIDTH(BUS_WIDTH),\n\t\t\t\t.OPT_PIPELINED(OPT_PIPELINED),\n\t\t\t\t.OPT_EARLY_BRANCHING(OPT_EARLY_BRANCHING),\n\t\t\t\t.OPT_LGICACHE(OPT_LGICACHE),\n\t\t\t\t.OPT_LGDCACHE(OPT_LGDCACHE),\n\t\t\t\t.START_HALTED(1'b1),\n\t\t\t\t.OPT_DISTRIBUTED_REGS(OPT_DISTRIBUTED_REGS),\n\t\t\t\t.OPT_MPY(OPT_MPY),\n\t\t\t\t.OPT_DIV(OPT_DIV),\n\t\t\t\t.OPT_SHIFTS(OPT_SHIFTS),\n\t\t\t\t.OPT_LOCK(OPT_LOCK),\n\t\t\t\t.OPT_CIS(OPT_CIS),\n\t\t\t\t.OPT_USERMODE(OPT_USERMODE),\n\t\t\t\t.OPT_DBGPORT(1'b1),\n\t\t\t\t.OPT_TRACE_PORT(1'b0),\n\t\t\t\t.OPT_PROFILER(1'b0),\n\t\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t\t.OPT_SIM(OPT_SIM),\n\t\t\t\t.OPT_CLKGATE(OPT_CLKGATE),\n\t\t\t\t.RESET_DURATION(RESET_DURATION),\n\t\t\t\t// ZipSystem only",
            "parameter s\n\t\t\t\t.OPT_DMA(OPT_DMA),\n\t\t\t\t.OPT_ACCOUNTING(1'b1),\n\t\t\t\t.EXTERNAL_INTERRUPTS(1)\n\t\t\t\t// }}}\n\t\t\t) u_smp (\n\t\t\t\t// {{{\n\t\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t\t// Master bus\n\t\t\t\t// {{{\n\t\t\t\t.o_wb_cyc(cpu_cyc[gk]), .o_wb_stb(cpu_stb[gk]),\n\t\t\t\t\t.o_wb_we(cpu_we[gk]),\n\t\t\t\t.o_wb_addr(cpu_addr[gk*WAW +: WAW]),\n\t\t\t\t.o_wb_data(cpu_data[gk*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t\t.o_wb_sel(cpu_sel[gk*BUS_WIDTH/8 +: BUS_WIDTH/8]),\n\t\t\t\t.i_wb_stall(cpu_stall[gk]),\n\t\t\t\t\t.i_wb_ack(cpu_ack[gk]),\n\t\t\t\t\t.i_wb_data(cpu_idata[gk*BUS_WIDTH +: BUS_WIDTH]),\n\t\t\t\t\t.i_wb_err(cpu_err[gk]),\n\t\t\t\t// }}}\n\t\t\t\t.i_ext_int({ i_sim_int }),\n\t\t\t\t.o_ext_int(cpu_int[gk]),\n\t\t\t\t// Debug control port\n\t\t\t\t// {{{\n\t\t\t\t.i_dbg_cyc(smp_cyc), .i_dbg_stb(smp_stb),\n\t\t\t\t\t.i_dbg_we(smp_we), .i_dbg_addr(smp_addr[6:0]),\n\t\t\t\t\t.i_dbg_data(smp_data), .i_dbg_sel(smp_sel),\n\t\t\t\t.o_dbg_stall(smp_stall), .o_dbg_ack(smp_ack),\n\t\t\t\t\t.o_dbg_data(smp_idata),\n\t\t\t\t// }}}\n\t\t\t\t.o_cpu_debug(smp_trace),\n\t\t\t\t// (Optional) Profiler\n\t\t\t\t// {{{\n\t\t\t\t.o_prof_stb(smp_prof_stb),\n\t\t\t\t.o_prof_addr(smp_prof_addr),\n\t\t\t\t.o_prof_ticks(smp_prof_ticks)\n\t\t\t\t// }}}\n\t\t\t\t// }}}\n\t\t\t);\n\n\t\t\tassign\tcpu_halted[gk]   = u_smp.cpu_has_halted;\n\t\t\tassign\tcpu_op_stall[gk] = u_smp.cpu_op_stall;\n\t\t\tassign\tcpu_pf_stall[gk] = u_smp.cpu_pf_stall;\n\t\t\tassign\tcpu_i_count[gk]  = u_smp.cpu_i_count;\n\t\t\tassign\tcpu_gie[gk]      = u_smp.cpu_gie;\n\n\t\t\t// Keep Verilator happy\n\t\t\t// {{{\n\t\t\t// Verilator coverage_off\n\t\t\t// Verilator lint_off UNUSED",
            "wire unused_zipsys;\n\t\t\tassign\tunused_zipsys = &{ 1'b0, pic_int };\n\t\t\t// Verilator lint_on  UNUSED\n\t\t\t// Verilator coverage_on\n\t\t\t// }}}\n\t\tend\n\n\t\t// Keep Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_smp;\n\t\tassign\tunused_smp = &{ 1'b0, smp_prof_stb, smp_prof_addr,\n\t\t\t\tsmp_prof_ticks, smp_trace, cpu_int[gk],\n\t\t\t\tsmp_addr[6],\n\t\t\t\tsmpw_addr[gk*WAW + (9-WBLSB) +: (WAW-(9-WBLSB))]\n\t\t\t\t};\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The wide bus interconnect\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\twbxbar #(\n\t\t// {{{\n`ifdef\tVERILATOR\n\t\t.NM(1+1+OPT_SMP),\n`else\n\t\t.NM(1+OPT_SMP),\n`endif\n\t\t.NS(6+OPT_SMP),\n\t\t.AW(ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)), .DW(BUS_WIDTH),\n\t\t.SLAVE_ADDR({ ZSYS_ADDR, SMP_ADDR,\n\t\t\tZDMA_CHECKST_ADDR,\n\t\t\tZDMA_CHECK_ADDR,\n\t\t\tCONSOLE_ADDR,\n\t\t\tSCOPE_ADDR,\n\t\t\tMEMORY_ADDR }),\n\t\t.SLAVE_MASK({\n\t\t\t{ {(ADDRESS_WIDTH-24){1'b1}},{(24-WBLSB){1'b0}} }, // ZipSys\n\t\t\tSMP_MASK,\t// SMP\n\t\t\t{ 4'b1111, {(WAW-4){1'b0}} },\t// ZDMA_Check\n\t\t\t{ 4'b1111, {(WAW-4){1'b0}} },\t// ZDMA_Check Status\n\t\t\t{ 4'b1111, {(WAW-4){1'b0}} },\t// Console\n\t\t\t{ 4'b1111, {(WAW-4){1'b0}} },\t// Scope\n\t\t\t{ 2'b11,   {(WAW-2){1'b0}} } })\t// Memory\n\t\t// }}}\n\t) main_crossbar (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t// Slave ports from the various bus masters\n\t\t// {{{\n`ifdef\tVERILATOR\n\t\t// Two bus masters: the external SIM",
            "input , and the CPU\n\t\t.i_mcyc({   simw_cyc,   dmac_cyc, cpu_cyc }),\n\t\t.i_mstb({   simw_stb,   dmac_stb, cpu_stb }),\n\t\t.i_mwe({    simw_we,    dmac_we,  cpu_we }),\n\t\t.i_maddr({  simw_addr[ADDRESS_WIDTH-WBLSB-1:0], dmac_addr, cpu_addr }),\n\t\t.i_mdata({  simw_data,  dmac_data, cpu_data }),\n\t\t.i_msel({   simw_sel,   dmac_sel,  cpu_sel }),\n\t\t.o_mstall({ simw_stall, dmac_stall,cpu_stall }),\n\t\t.o_mack({   simw_ack,   dmac_ack,  cpu_ack }),\n\t\t.o_mdata({  simw_idata, dmac_return,cpu_idata }),\n\t\t.o_merr({   simw_err,   dmac_err,   cpu_err }),\n`else\n\t\t// With no external CPU",
            "input , there is no simulation port\n\t\t.i_mcyc({ dmac_cyc, cpu_cyc }),\n\t\t\t.i_mstb({  dmac_stb,  cpu_stb }),\n\t\t\t.i_mwe({   dmac_we,   cpu_we }),\n\t\t\t.i_maddr({ dmac_addr, cpu_addr }),\n\t\t\t.i_mdata({ dmac_data, cpu_data }),\n\t\t\t.i_msel({  dmac_sel,  cpu_sel }),\n\t\t.o_mstall({ dmac_stall, cpu_stall }),\n\t\t\t.o_mack({  dmac_ack,    cpu_ack }),\n\t\t\t.o_mdata({ dmac_return, cpu_idata }),\n\t\t\t.o_merr({  dmac_err,    cpu_err }),\n`endif\n\t\t// }}}\n\t\t// Master port ... to control the slaves w/in this design\n\t\t// {{{\n\t\t.o_scyc({   zsysw_cyc,  smpw_cyc,  zdmacstw_cyc,  zdmacw_cyc,  conw_cyc,  scopew_cyc,  mem_cyc  }),\n\t\t.o_sstb({   zsysw_stb,  smpw_stb,  zdmacstw_stb,  zdmacw_stb,  conw_stb,  scopew_stb,  mem_stb  }),\n\t\t.o_swe({    zsysw_we,   smpw_we,   zdmacstw_we,   zdmacw_we,   conw_we,   scopew_we,   mem_we   }),\n\t\t.o_saddr({  zsysw_addr, smpw_addr, zdmacstw_addr, zdmacw_addr, conw_addr, scopew_addr, mem_addr }),\n\t\t.o_sdata({  zsysw_data, smpw_data, zdmacstw_data, zdmacw_data, conw_data, scopew_data, mem_data }),\n\t\t.o_ssel({   zsysw_sel,  smpw_sel,  zdmacstw_sel,  zdmacw_sel,  conw_sel,  scopew_sel,  mem_sel  }),\n\t\t//\n\t\t.i_sstall({ zsysw_stall,smpw_stall, zdmacstw_stall, zdmacw_stall, conw_stall, scopew_stall, mem_stall }),\n\t\t.i_sack({   zsysw_ack,  smpw_ack,   zdmacstw_ack,   zdmacw_ack,   conw_ack,   scopew_ack,   mem_ack   }),\n\t\t.i_sdata({  zsysw_idata,smpw_idata, zdmacstw_idata, zdmacw_idata, conw_idata, scopew_idata, mem_idata }),\n\t\t.i_serr({   zsysw_err,  smpw_err,   zdmacstw_err,   zdmacw_err,   conw_err,   scopew_err,   mem_err   })\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Memory\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tmemdev #(\n\t\t// {{{\n\t\t.LGMEMSZ(LGMEMSZ),\n\t\t.DW(BUS_WIDTH),\n\t\t.HEXFILE(MEM_FILE),\n\t\t.OPT_ROM(1'b0)\n\t\t// }}}\n\t) u_mem (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_wb_cyc(mem_cyc), .i_wb_stb(mem_stb), .i_wb_we(mem_we),\n\t\t.i_wb_addr(mem_addr[LGMEMSZ-WBLSB-1:0]), .i_wb_data(mem_data),\n\t\t\t.i_wb_sel(mem_sel),\n\t\t.o_wb_stall(mem_stall), .o_wb_ack(mem_ack),\n\t\t.o_wb_data(mem_idata)\n\t\t// }}}\n\t);\n\n\tassign\tmem_err = 1'b0;\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Console\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg con_write_en;",
            "reg [7:0]\tcon_write_byte;\n\n\tinteger\tsim_console;\n\n\twbdown #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH-3),\n\t\t.WIDE_DW(BUS_WIDTH), .SMALL_DW(32)\n\t\t// }}}\n\t) u_condown (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t// The \"Wide\" connection\n\t\t// {{{\n\t\t.i_wcyc(conw_cyc), .i_wstb(conw_stb), .i_wwe(conw_we),\n\t\t.i_waddr(conw_addr[WAW-4:0]),\n\t\t\t.i_wdata(conw_data), .i_wsel(conw_sel),\n\t\t//\n\t\t.o_wstall(conw_stall), .o_wack(conw_ack), .o_wdata(conw_idata),\n\t\t\t.o_werr(conw_err),\n\t\t// }}}\n\t\t// The downsized connection\n\t\t// {{{\n\t\t.o_cyc(con_cyc), .o_stb(con_stb), .o_we(con_we),\n\t\t.o_addr(con_addr), .o_data(con_data), .o_sel(con_sel),\n\t\t//\n\t\t.i_stall(con_stall), .i_ack(con_ack), .i_data(con_idata),\n\t\t\t.i_err(con_err)\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\tassign\tcon_stall = 1'b0;\n\n\tinitial\tr_con_ack = 1'b0;\n\talways @(posedge i_clk)\n\t\tr_con_ack <= !i_reset && con_stb;\n\tassign\tcon_ack = r_con_ack;\n\n\tinitial\tbegin\n\t\tsim_console = $fopen(CONSOLE_FILE);\n\tend\n\n\t// Make sure we can read the outgoing console data from the trace\n\tinitial\tcon_write_en = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tcon_write_en <= 1'b0;\n\telse if (con_stb && con_we && con_addr[1:0] == 2'b11 && con_sel[0])\n\t\tcon_write_en <= 1'b1;\n\telse\n\t\tcon_write_en <= 1'b0;\n\n\tinitial\tcon_write_byte = 8'h0;\n\talways @(posedge i_clk)\n\tif (con_stb && con_we && con_addr[1:0] == 2'b11 && con_sel[0])\n\t\tcon_write_byte <= con_data[7:0];\n\n\talways @(posedge i_clk)\n\tif (!i_reset && con_write_en)\n\tbegin\n\t\t$fwrite(sim_console, \"%1s\", con_write_byte);\n\t\t$write(\"%1s\", con_write_byte);\n\tend\n\n\tassign\tcon_idata = 32'h0;\n\tassign\tcon_err   = 1'b0;\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Artificial ZipCPU System components, for when running with ZipBones\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\twbdown #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH-4),\n\t\t.WIDE_DW(BUS_WIDTH), .SMALL_DW(32)\n\t\t// }}}\n\t) u_zsysdown (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t// The \"Wide\" connection\n\t\t// {{{\n\t\t.i_wcyc(zsysw_cyc), .i_wstb(zsysw_stb), .i_wwe(zsysw_we),\n\t\t.i_waddr(zsysw_addr[WAW-5:0]),\n\t\t\t.i_wdata(zsysw_data), .i_wsel(zsysw_sel),\n\t\t//\n\t\t.o_wstall(zsysw_stall), .o_wack(zsysw_ack),\n\t\t\t.o_wdata(zsysw_idata), .o_werr(zsysw_err),\n\t\t// }}}\n\t\t// The downsized connection\n\t\t// {{{\n\t\t.o_cyc(zsys_cyc), .o_stb(zsys_stb), .o_we(zsys_we),\n\t\t.o_addr(zsys_addr), .o_data(zsys_data), .o_sel(zsys_sel),\n\t\t//\n\t\t.i_stall(zsys_stall), .i_ack(zsys_ack), .i_data(zsys_idata),\n\t\t\t.i_err(zsys_err)\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\tinitial\tzsys_stb_d = 1'b0;\n\talways @(posedge i_clk)\n\t\tzsys_stb_d <= !i_reset && zsys_stb;\n\n\talways @(posedge i_clk)\n\t\tzsys_addr_d <= zsys_addr;\n\n\tassign\tzsys_stall = 1'b0;\n\n\tinitial\tr_zsys_ack = 1'b0;\n\talways @(posedge i_clk)\n\t\tr_zsys_ack <= !i_reset && zsys_stb_d;\n\tassign\tzsys_ack = r_zsys_ack;\n\n\tassign\tzsys_idata = 32'h0;\n\tassign\tzsys_err   = 1'b0;\n\n\t// SMP[0] Master counters\n\t// {{{\n\tzipcounter\n\tmtask_ctr (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_event(!cpu_halted[0]),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h8),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data),\n\t\t.o_wb_stall(ign_mtc_stall),\n\t\t.o_wb_ack(ign_mtc_ack),\n\t\t.o_wb_data(mtc_data),\n\t\t.o_int(mtc_int)\n\t\t// }}}\n\t);\n\n\t/*\n\tzipcounter\n\tmmstall_ctr (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_event(!halt),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h8),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data),\n\t\t.o_wb_stall(ign_mtc_stall),\n\t\t.o_wb_ack(ign_mtc_ack),\n\t\t.o_wb_data(mtc_data),\n\t\t.o_int(mtc_int)\n\t\t// }}}\n\t);\n\t*/\n\tassign { ign_moc_ack, ign_moc_stall, moc_int, moc_data } = 35'h0;\n\n\t/*\n\tzipcounter\n\tmpstall_ctr (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_event(!halt),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h8),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data),\n\t\t.o_wb_stall(ign_mtc_stall),\n\t\t.o_wb_ack(ign_mtc_ack),\n\t\t.o_wb_data(mtc_data),\n\t\t.o_int(mtc_int)\n\t\t// }}}\n\t);\n\t*/\n\tassign { ign_mpc_ack, ign_mpc_stall, mpc_int, mpc_data } = 35'h0;\n\n\tzipcounter\n\tmins_ctr (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_event(cpu_i_count[0]),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'hb),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data),\n\t\t.o_wb_stall(ign_mic_stall),\n\t\t.o_wb_ack(ign_mic_ack),\n\t\t.o_wb_data(mic_data),\n\t\t.o_int(mic_int)\n\t\t// }}}\n\t);\n\t// }}}\n\n\t// SMP[0] User counters\n\t// {{{\n\tzipcounter\n\tutask_ctr (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_event(!cpu_halted[0]),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'hc),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data),\n\t\t.o_wb_stall(ign_utc_stall),\n\t\t.o_wb_ack(ign_utc_ack),\n\t\t.o_wb_data(utc_data),\n\t\t.o_int(utc_int)\n\t\t// }}}\n\t);\n\n\t/*\n\tzipcounter\n\tumstall_ctr (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_event(cpu_op_stall[0]),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'hd),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data),\n\t\t.o_wb_stall(ign_uoc_stall),\n\t\t.o_wb_ack(ign_uoc_ack),\n\t\t.o_wb_data(uoc_data),\n\t\t.o_int(uoc_int)\n\t\t// }}}\n\t);\n\t*/\n\tassign { ign_uoc_ack, ign_uoc_stall, uoc_int, uoc_data } = 35'h0;\n\n\t/*\n\tzipcounter\n\tmpstall_ctr (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_event(cpu_pf_stall[0]),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'he),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data),\n\t\t.o_wb_stall(ign_mpc_stall),\n\t\t.o_wb_ack(ign_mpc_ack),\n\t\t.o_wb_data(mpc_data),\n\t\t.o_int(mpc_int)\n\t\t// }}}\n\t);\n\t*/\n\tassign { ign_upc_ack, ign_upc_stall, upc_int, upc_data } = 35'h0;\n\n\tzipcounter\n\tuins_ctr (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_event(cpu_gie[0] && cpu_i_count[0]),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'hf),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data),\n\t\t.o_wb_stall(ign_uic_stall),\n\t\t.o_wb_ack(ign_uic_ack),\n\t\t.o_wb_data(uic_data),\n\t\t.o_int(uic_int)\n\t\t// }}}\n\t);\n\t// }}}\n\n\n\talways @(posedge i_clk)\n\tif (zsys_stb_d)\n\tbegin\n\t\tr_zsys_data <= 32'h0;\n\t\tcase(zsys_addr_d)\n\t\t 0: r_zsys_data <= pic_data;\t\t// PIC\n\t\t 1: begin end\t// Watchdog\n\t\t 2: begin end\t// APIC\n\t\t 3: begin end\t// Bus Watchdog\n\t\t 4: r_zsys_data <= timer_a_data;\t// Timer A\n\t\t 5: r_zsys_data <= timer_b_data;\t// Timer B\n\t\t 6: r_zsys_data <= timer_c_data;\t// Timer C\n\t\t 7: r_zsys_data <= jiffies_data;\t// Jiffies\n\t\t 8: r_zsys_data <= mtc_data;\n\t\t 9: r_zsys_data <= moc_data;\n\t\t10: r_zsys_data <= mpc_data;\n\t\t11: r_zsys_data <= mic_data;\n\t\t12: r_zsys_data <= utc_data;\n\t\t13: r_zsys_data <= uoc_data;\n\t\t14: r_zsys_data <= upc_data;\n\t\t15: r_zsys_data <= uic_data;\n\t\t16: r_zsys_data <= dma_slv_data;\n\t\t17: r_zsys_data <= dma_slv_data;\n\t\t18: r_zsys_data <= dma_slv_data;\n\t\t19: r_zsys_data <= dma_slv_data;\n\t\tendcase\n\tend else\n\t\tr_zsys_data <= 32'h0;\n\n\tassign\tzsys_idata = r_zsys_data;\n\n\ticontrol #(\n\t\t.IUSED(16)\n\t) u_pic (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h0),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data), .i_wb_sel(zsys_sel),\n\t\t.o_wb_stall(pic_stall),\n\t\t.o_wb_ack(pic_ack),\n\t\t.o_wb_data(pic_data),\n\t\t.i_brd_ints({ 9'h0, i_sim_int,\n\t\t\t1'b0, timer_a_int,\n\t\t\ttimer_b_int, timer_c_int, jiffies_int, dmac_int }),\n\t\t.o_interrupt(pic_int)\n\t\t// }}}\n\t);\n\n\tziptimer\n\tu_timer_a (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset), .i_ce(1'b1),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h4),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data), .i_wb_sel(zsys_sel),\n\t\t.o_wb_stall(timer_a_stall),\n\t\t.o_wb_ack(timer_a_ack),\n\t\t.o_wb_data(timer_a_data),\n\t\t.o_int(timer_a_int)\n\t\t// }}}\n\t);\n\n\tziptimer\n\tu_timer_b (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset), .i_ce(1'b1),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h5),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data), .i_wb_sel(zsys_sel),\n\t\t.o_wb_stall(timer_b_stall),\n\t\t.o_wb_ack(timer_b_ack),\n\t\t.o_wb_data(timer_b_data),\n\t\t.o_int(timer_b_int)\n\t\t// }}}\n\t);\n\n\tziptimer\n\tu_timer_c (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset), .i_ce(1'b1),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h6),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data), .i_wb_sel(zsys_sel),\n\t\t.o_wb_stall(timer_c_stall),\n\t\t.o_wb_ack(timer_c_ack),\n\t\t.o_wb_data(timer_c_data),\n\t\t.o_int(timer_c_int)\n\t\t// }}}\n\t);\n\n\tzipjiffies\n\tu_jiffies (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset), .i_ce(1'b1),\n\t\t.i_wb_cyc(zsys_cyc),\n\t\t.i_wb_stb(zsys_stb && zsys_addr[4:0] == 5'h7),\n\t\t.i_wb_we(zsys_we),\n\t\t.i_wb_data(zsys_data), .i_wb_sel(zsys_sel),\n\t\t.o_wb_stall(jiffies_stall),\n\t\t.o_wb_ack(jiffies_ack),\n\t\t.o_wb_data(jiffies_data),\n\t\t.o_int(jiffies_int)\n\t\t// }}}\n\t);\n\n\tgenerate if (OPT_ZIPBONES && OPT_DMA)\n\tbegin : GEN_BONES_DMA\n\t\t// {{{",
            "localparam DMA_LGMEM = 10;",
            "wire ign_dmac_stall, ign_dmac_ack;",
            "wire [31:0]\tdmac_int_vec;\n\n\t\tassign\tdmac_int_vec = { 16'h0, 9'h0, i_sim_int,\n\t\t\t1'b0, timer_a_int, timer_b_int,\n\t\t\ttimer_c_int, jiffies_int, 1'b0 };\n\n\t\tzipdma #(\n\t\t\t// {{{\n\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH), .LGMEMLEN(DMA_LGMEM),\n\t\t\t.BUS_WIDTH(BUS_WIDTH), .OPT_LITTLE_ENDIAN(1'b1)\n\t\t\t// }}}\n\t\t) u_dma (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t// Slave port\n\t\t\t// {{{\n\t\t\t.i_swb_cyc(zsys_cyc),\n\t\t\t\t.i_swb_stb(zsys_stb && zsys_addr[4:2]== 3'b100),\n\t\t\t\t.i_swb_we(zsys_we),\n\t\t\t\t.i_swb_addr(zsys_addr[1:0]),\n\t\t\t\t.i_swb_data(zsys_data),\n\t\t\t\t.i_swb_sel(zsys_sel),\n\t\t\t\t.o_swb_stall(ign_dmac_stall),\n\t\t\t\t.o_swb_ack(ign_dmac_ack),\n\t\t\t\t.o_swb_data(dma_slv_data),\n\t\t\t// }}}\n\t\t\t.o_mwb_cyc(dmac_cyc), .o_mwb_stb(dmac_stb),\n\t\t\t\t.o_mwb_we(dmac_we), .o_mwb_addr(dmac_addr),\n\t\t\t\t.o_mwb_data(dmac_data), .o_mwb_sel(dmac_sel),\n\t\t\t.i_mwb_stall(dmac_stall), .i_mwb_ack(dmac_ack),\n\t\t\t\t.i_mwb_data(dmac_return), .i_mwb_err(dmac_err),\n\t\t\t.i_dev_ints(dmac_int_vec),\n\t\t\t.o_interrupt(dmac_int)\n\t\t\t// }}}\n\t\t);\n\n\t\t// Keep Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_dmac;\n\t\tassign\tunused_dmac = &{ 1'b0, ign_dmac_stall, ign_dmac_ack };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\t\t// }}}\n\tend else begin : NO_EXTERNAL_DMA\n\n\t\tassign\tdmac_int = 1'b0;\n\t\tassign\tdma_slv_data = 0;\n\n\t\tassign\t{ dmac_cyc, dmac_stb, dmac_we } = 3'h0;\n\t\tassign\tdmac_addr = 0;\n\t\tassign\tdmac_data = 0;\n\t\tassign\tdmac_sel  = 0;\n\n\tend endgenerate\n\n\t// Keep Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused_zsys;\n\tassign\tunused_zsys = &{ 1'b0, pic_stall, pic_ack,\n\t\t\ttimer_a_stall, timer_a_ack,\n\t\t\ttimer_b_stall, timer_b_ack,\n\t\t\ttimer_c_stall, timer_c_ack,\n\t\t\tjiffies_stall, jiffies_ack\n\t\t};\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Optional) WB Scope\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_TRACE_PORT)\n\tbegin : GEN_WBSCOPE\n\t\t// {{{",
            "wire scope_cyc, scope_stb, scope_we;\n\t\t// Verilator lint_off UNUSED",
            "wire [ADDRESS_WIDTH-3-$clog2(32/8)-1:0]\tscope_addr;\n\t\t// Verilator lint_on  UNUSED",
            "wire [31:0]\tscope_data, scope_idata;",
            "wire [3:0]\tscope_sel;",
            "wire scope_stall, scope_ack, scope_err;\n\n\t\twbdown #(\n\t\t\t// {{{\n\t\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH-3),\n\t\t\t.WIDE_DW(BUS_WIDTH), .SMALL_DW(32)\n\t\t\t// }}}\n\t\t) u_scopedown (\n\t\t\t// {{{\n\t\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t\t// The \"Wide\" connection\n\t\t\t// {{{\n\t\t\t.i_wcyc(scopew_cyc), .i_wstb(scopew_stb), .i_wwe(scopew_we),\n\t\t\t.i_waddr(scopew_addr[WAW-4:0]),\n\t\t\t\t.i_wdata(scopew_data), .i_wsel(scopew_sel),\n\t\t\t//\n\t\t\t.o_wstall(scopew_stall), .o_wack(scopew_ack),\n\t\t\t\t.o_wdata(scopew_idata), .o_werr(scopew_err),\n\t\t\t// }}}\n\t\t\t// The downsized connection\n\t\t\t// {{{\n\t\t\t.o_cyc(scope_cyc), .o_stb(scope_stb), .o_we(scope_we),\n\t\t\t.o_addr(scope_addr), .o_data(scope_data),\n\t\t\t\t.o_sel(scope_sel),\n\t\t\t//\n\t\t\t.i_stall(scope_stall), .i_ack(scope_ack),\n\t\t\t\t.i_data(scope_idata), .i_err(scope_err)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\twbscope #(\n\t\t\t.LGMEM(12)\n\t\t) u_scope (\n\t\t\t// {{{\n\t\t\t.i_data_clk(i_clk), .i_trigger(1'b0), .i_ce(1'b1),\n\t\t\t.i_data(cpu_trace),\n\t\t\t//\n\t\t\t.i_wb_clk(i_clk),\n\t\t\t.i_wb_cyc(scope_cyc), .i_wb_stb(scope_stb),\n\t\t\t.i_wb_we(scope_we),   .i_wb_addr(scope_addr[0]),\n\t\t\t.i_wb_data(scope_data), .i_wb_sel(scope_sel),\n\t\t\t//\n\t\t\t.o_wb_stall(scope_stall),\n\t\t\t.o_wb_ack(scope_ack),\n\t\t\t.o_wb_data(scope_idata),\n\t\t\t//\n\t\t\t.o_interrupt(scope_int)\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\tscope_err = 1'b0;\n\t\t// }}}\n\tend else begin : NO_SCOPE\n\t\t// {{{",
            "reg r_scope_ack;\n\n\t\tinitial\tr_scope_ack = 1'b0;\n\t\talways @(posedge i_clk)\n\t\t\tr_scope_ack <= scopew_stb && !i_reset;\n\n\t\tassign\tscopew_stall = 1'b0;\n\t\tassign\tscopew_ack   = r_scope_ack;\n\t\tassign\tscopew_idata = {(BUS_WIDTH){1'b0}};\n\t\tassign\tscopew_err   = 1'b0;\n\n\t\tassign\tscope_int = 1'b0;\n\n\t\t// Keep Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_scope;\n\t\tassign\tunused_scope = &{ 1'b0, scopew_cyc, scopew_we,\n\t\t\t\t\tscopew_data, scopew_sel, cpu_trace };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Optional) ZIPDMA_Check\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\twbdown #(\n\t\t// {{{\n\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH-3),\n\t\t.WIDE_DW(BUS_WIDTH), .SMALL_DW(32)\n\t\t// }}}\n\t) u_zdmacstdown (\n\t\t// {{{\n\t\t.i_clk(i_clk), .i_reset(i_reset),\n\t\t// The \"Wide\" connection\n\t\t// {{{\n\t\t.i_wcyc(zdmacstw_cyc),\n\t\t.i_wstb(zdmacstw_stb),\n\t\t.i_wwe(zdmacstw_we),\n\t\t.i_waddr(zdmacstw_addr[WAW-4:0]),\n\t\t.i_wdata(zdmacstw_data),\n\t\t.i_wsel(zdmacstw_sel),\n\t\t//\n\t\t.o_wstall(zdmacstw_stall),\n\t\t.o_wack(zdmacstw_ack),\n\t\t.o_wdata(zdmacstw_idata),\n\t\t.o_werr(zdmacstw_err),\n\t\t// }}}\n\t\t// The downsized connection\n\t\t// {{{\n\t\t.o_cyc(zdmacst_cyc),\n\t\t.o_stb(zdmacst_stb),\n\t\t.o_we(zdmacst_we),\n\t\t.o_addr(zdmacst_addr),\n\t\t.o_data(zdmacst_data),\n\t\t.o_sel(zdmacst_sel),\n\t\t//\n\t\t.i_stall(zdmacst_stall),\n\t\t.i_ack(zdmacst_ack),\n\t\t.i_data(zdmacst_idata),\n\t\t.i_err(zdmacst_err)\n\t\t// }}}\n\t);\n\n\tzipdma_check #(\n\t\t.ADDRESS_WIDTH(ADDRESS_WIDTH),\n\t\t.BUS_WIDTH(BUS_WIDTH)\n\t) u_zipdma_check (\n\t\t// {{{\n\t\t.i_clk(i_clk),\n\t\t.i_reset(i_reset),\n\t\t// mm2s, s2mm\n\t\t.i_wb_cyc(zdmacw_cyc),\n\t\t.i_wb_stb(zdmacw_stb),\n\t\t.i_wb_we(zdmacw_we),\n\t\t.i_wb_addr(zdmacw_addr),\n\t\t.i_wb_data(zdmacw_data),\n\t\t.i_wb_sel(zdmacw_sel),\n\t\t//\n\t\t.o_wb_stall(zdmacw_stall),\n\t\t.o_wb_ack(zdmacw_ack),\n\t\t.o_wb_data(zdmacw_idata),\n\t\t.o_wb_err(zdmacw_err),\n\t\t// status\n\t\t.i_st_cyc(zdmacst_cyc),\n\t\t.i_st_stb(zdmacst_stb),\n\t\t.i_st_we(zdmacst_we),\n\t\t.i_st_addr(zdmacst_addr[0]),\n\t\t.i_st_data(zdmacst_data),\n\t\t.i_st_sel(zdmacst_sel),\n\t\t//\n\t\t.o_st_stall(zdmacst_stall),\n\t\t.o_st_ack(zdmacst_ack),\n\t\t.o_st_data(zdmacst_idata),\n\t\t.o_st_err(zdmacst_err)\n\t\t// }}}\n\t);\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Optional) VCD generation\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n`ifndef\tVERILATOR\n\tinitial if (DUMP_TO_VCD)\n\tbegin\n\t\t$dumpfile(VCD_FILE);\n\t\t$dumpvars(0, wb_tb);\n\tend\n`endif\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Test bench watchdog\n\t// {{{",
            "localparam TB_WATCHDOG_TIMEOUT = 1_000_00;\t// 1ms",
            "reg [$clog2(TB_WATCHDOG_TIMEOUT+2)-1:0]\twatchdog_counter;\n\n\tinitial\twatchdog_counter = 0;\n\talways @(posedge i_clk)\n\t// if (i_reset)\n\t//\twatchdog_counter <= 0;\n\t// else\n\tif (|(cpu_stb & ~cpu_stall))\n\t\twatchdog_counter <= 0;\n\telse\n\t\twatchdog_counter <= watchdog_counter + 1;\n\n\talways @(posedge i_clk)\n\tif (watchdog_counter > TB_WATCHDOG_TIMEOUT)\n\tbegin\n\t\t$display(\"\\nERROR: Watchdog timeout!\");\n\t\t$finish;\n\tend\n\n\talways @(posedge i_clk)\n\tif (!i_reset && cpu_int[0])\n\t\t$display(\"\\nCPU Halted without error: PASS\\n\");\n\t// }}}\n\n\t// Keep Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0,\n\t\tDUMP_TO_VCD, VCD_FILE,\n\t\tconw_addr, scopew_addr, zsysw_addr, zsysw_addr,\n`ifdef\tVERILATOR\n\t\tsimw_addr,\n`endif\n\t\tcon_addr,  zsys_addr, mem_addr, dbg_addr,\n\t\tcon_cyc, con_data[31:8], con_sel[3:1],\n\t\ttimer_a_int, timer_b_int, timer_c_int, jiffies_int,\n\t\ttimer_a_ack, timer_b_ack, timer_c_ack, jiffies_ack,\n\t\ttimer_a_stall, timer_b_stall, timer_c_stall, jiffies_stall,\n\t\tscope_int, zdmacst_addr[ADDRESS_WIDTH-3-$clog2(32/8)-1:1],\n\t\tzdmacstw_addr[ADDRESS_WIDTH-$clog2(BUS_WIDTH/8)-1-:3] };\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "axilempty.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axilempty.v",
        "chunks": [
            "module axilempty #(\n\t\t// {{{\n\t\t//\n\t\t// Size of the AXI-lite bus.  These are fixed, since 1) AXI-lite\n\t\t// is fixed at a width of 32-bits by Xilinx def'n, and 2) since\n\t\t// we only ever have 4 configuration words.\n\t\t// Verilator lint_off UNUSED",
            "parameter C_AXI_ADDR_WIDTH = 4,\n\t\t// Verilator lint_on  UNUSED",
            "localparam C_AXI_DATA_WIDTH = 32,",
            "parameter [0:0]\tOPT_SKIDBUFFER = 1'b0,",
            "parameter [0:0]\tOPT_LOWPOWER = 0\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,\n\t\t//",
            "input ",
            "wire S_AXI_AWVALID,",
            "output ",
            "wire S_AXI_AWREADY,\n\t\t//",
            "input ",
            "wire S_AXI_WVALID,",
            "output ",
            "wire S_AXI_WREADY,\n\t\t//",
            "output ",
            "wire S_AXI_BVALID,",
            "input ",
            "wire S_AXI_BREADY,",
            "output ",
            "wire [1:0]\t\t\t\tS_AXI_BRESP,\n\t\t//",
            "input ",
            "wire S_AXI_ARVALID,",
            "output ",
            "wire S_AXI_ARREADY,\n\t\t//",
            "output ",
            "wire S_AXI_RVALID,",
            "input ",
            "wire S_AXI_RREADY,",
            "output ",
            "wire [C_AXI_DATA_WIDTH-1:0]\t\tS_AXI_RDATA,",
            "output ",
            "wire [1:0]\t\t\t\tS_AXI_RRESP\n\t\t// }}}\n\t);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Register/",
            "wire signal declarations\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{",
            "wire i_reset = !S_AXI_ARESETN;",
            "wire axil_write_ready;\n\t//",
            "reg axil_bvalid;\n\t//",
            "wire axil_read_ready;",
            "reg axil_read_valid;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI-lite signaling\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{\n\n\t//\n\t// Write signaling\n\t//\n\t// {{{\n\n\tgenerate if (OPT_SKIDBUFFER)\n\tbegin : SKIDBUFFER_WRITE",
            "wire awskd_valid, wskd_valid, awskd_unused, wskd_unused;\n\n\t\tskidbuffer #(.OPT_OUTREG(0),\n\t\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER), .DW(1))\n\t\taxilawskid(//\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(i_reset),\n\t\t\t.i_valid(S_AXI_AWVALID), .o_ready(S_AXI_AWREADY),\n\t\t\t.i_data(1'b0),\n\t\t\t.o_valid(awskd_valid), .i_ready(axil_write_ready),\n\t\t\t.o_data(awskd_unused));\n\n`ifdef\tFORMAL\n\talways @(*)\n\tif (awskd_valid)\n\t\tassert(awskd_unused == 0);\n`endif\n\n\t\tskidbuffer #(.OPT_OUTREG(0), .OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t\t.DW(1))\n\t\taxilwskid(//\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(i_reset),\n\t\t\t.i_valid(S_AXI_WVALID), .o_ready(S_AXI_WREADY),\n\t\t\t.i_data({ 1'b0 }),\n\t\t\t.o_valid(wskd_valid), .i_ready(axil_write_ready),\n\t\t\t.o_data(wskd_unused));\n`ifdef\tFORMAL\n\talways @(*)\n\tif (wskd_valid)\n\t\tassert(wskd_unused == 0);\n`endif\n\n\t\tassign\taxil_write_ready = awskd_valid && wskd_valid\n\t\t\t\t&& (!S_AXI_BVALID || S_AXI_BREADY);\n\n\t\t// Verilator lint_off UNUSED",
            "wire unused;\n\t\tassign\tunused = &{ 1'b0, awskd_unused, wskd_unused };\n\t\t// Verilator lint_on  UNUSED\n\tend else begin : SIMPLE_WRITES",
            "reg axil_awready;\n\n\t\tinitial\taxil_awready = 1'b0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\taxil_awready <= 1'b0;\n\t\telse\n\t\t\taxil_awready <= !axil_awready\n\t\t\t\t&& (S_AXI_AWVALID && S_AXI_WVALID)\n\t\t\t\t&& (!S_AXI_BVALID || S_AXI_BREADY);\n\n\t\tassign\tS_AXI_AWREADY = axil_awready;\n\t\tassign\tS_AXI_WREADY  = axil_awready;\n\n\t\tassign\taxil_write_ready = axil_awready;\n\n\tend endgenerate\n\n\tinitial\taxil_bvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_reset)\n\t\taxil_bvalid <= 0;\n\telse if (axil_write_ready)\n\t\taxil_bvalid <= 1;\n\telse if (S_AXI_BREADY)\n\t\taxil_bvalid <= 0;\n\n\tassign\tS_AXI_BVALID = axil_bvalid;\n\tassign\tS_AXI_BRESP = 2'b11;\n\t// }}}\n\n\t//\n\t// Read signaling\n\t//\n\t// {{{\n\n\tgenerate if (OPT_SKIDBUFFER)\n\tbegin : SKIDBUFFER_READ",
            "wire arskd_valid, arskd_unused;\n\n\t\tskidbuffer #(.OPT_OUTREG(0),\n\t\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t\t.DW(1))\n\t\taxilarskid(//\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(i_reset),\n\t\t\t.i_valid(S_AXI_ARVALID), .o_ready(S_AXI_ARREADY),\n\t\t\t.i_data( 1'b0 ),\n\t\t\t.o_valid(arskd_valid), .i_ready(axil_read_ready),\n\t\t\t.o_data(arskd_unused));\n\n\t\tassign\taxil_read_ready = arskd_valid\n\t\t\t\t&& (!axil_read_valid || S_AXI_RREADY);\n\n`ifdef\tFORMAL\n\talways @(*)\n\tif (arskd_valid)\n\t\tassert(arskd_unused == 0);\n`endif\n\n\t\t// Verilator lint_off UNUSED",
            "wire unused;\n\t\tassign\tunused = &{ 1'b0, arskd_unused };\n\t\t// Verilator lint_on  UNUSED\n\tend else begin : SIMPLE_READS",
            "reg axil_arready;\n\n\t\talways @(*)\n\t\t\taxil_arready = !S_AXI_RVALID;\n\n\t\tassign\tS_AXI_ARREADY = axil_arready;\n\t\tassign\taxil_read_ready = (S_AXI_ARVALID && S_AXI_ARREADY);\n\n\tend endgenerate\n\n\tinitial\taxil_read_valid = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_reset)\n\t\taxil_read_valid <= 1'b0;\n\telse if (axil_read_ready)\n\t\taxil_read_valid <= 1'b1;\n\telse if (S_AXI_RREADY)\n\t\taxil_read_valid <= 1'b0;\n\n\tassign\tS_AXI_RVALID = axil_read_valid;\n\tassign\tS_AXI_RDATA  = 0;\n\tassign\tS_AXI_RRESP = 2'b11;\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI-lite",
            "reg ister",
            "logic //\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{\n\n\n\t// }}}\n\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0 };\n\t// Verilator lint_on  UNUSED\n\t// }}}\n`ifdef\tFORMAL\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Formal properties used in verfiying this core\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\t\tf_past_valid <= 1;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// The AXI-lite control interface\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{",
            "localparam F_AXIL_LGDEPTH = 4;",
            "wire [F_AXIL_LGDEPTH-1:0]\tfaxil_rd_outstanding,\n\t\t\t\t\tfaxil_wr_outstanding,\n\t\t\t\t\tfaxil_awr_outstanding;\n\n\tfaxil_slave #(\n\t\t// {{{\n\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),\n\t\t.F_LGDEPTH(F_AXIL_LGDEPTH),\n\t\t.F_AXI_MAXWAIT(2),\n\t\t.F_AXI_MAXDELAY(2),\n\t\t.F_AXI_MAXRSTALL(3),\n\t\t.F_OPT_COVER_BURST(0)\n\t\t// }}}\n\t) faxil(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN),\n\t\t//\n\t\t.i_axi_awvalid(S_AXI_AWVALID),\n\t\t.i_axi_awready(S_AXI_AWREADY),\n\t\t.i_axi_awaddr({(C_AXI_ADDR_WIDTH){1'b0}}),\n\t\t.i_axi_awprot( 3'h0),\n\t\t//\n\t\t.i_axi_wvalid(S_AXI_WVALID),\n\t\t.i_axi_wready(S_AXI_WREADY),\n\t\t.i_axi_wdata( {(C_AXI_DATA_WIDTH){1'b0}}),\n\t\t.i_axi_wstrb( {(C_AXI_DATA_WIDTH/8){1'b0}}),\n\t\t//\n\t\t.i_axi_bvalid(S_AXI_BVALID),\n\t\t.i_axi_bready(S_AXI_BREADY),\n\t\t.i_axi_bresp( S_AXI_BRESP),\n\t\t//\n\t\t.i_axi_arvalid(S_AXI_ARVALID),\n\t\t.i_axi_arready(S_AXI_ARREADY),\n\t\t.i_axi_araddr( {(C_AXI_ADDR_WIDTH){1'b0}}),\n\t\t.i_axi_arprot( 3'h0),\n\t\t//\n\t\t.i_axi_rvalid(S_AXI_RVALID),\n\t\t.i_axi_rready(S_AXI_RREADY),\n\t\t.i_axi_rdata( S_AXI_RDATA),\n\t\t.i_axi_rresp( S_AXI_RRESP),\n\t\t//\n\t\t.f_axi_rd_outstanding(faxil_rd_outstanding),\n\t\t.f_axi_wr_outstanding(faxil_wr_outstanding),\n\t\t.f_axi_awr_outstanding(faxil_awr_outstanding)\n\t\t// }}}\n\t\t);\n\n\talways @(*)\n\tif (OPT_SKIDBUFFER)\n\tbegin\n\t\tassert(faxil_awr_outstanding== (S_AXI_BVALID ? 1:0)\n\t\t\t+(S_AXI_AWREADY ? 0:1));\n\t\tassert(faxil_wr_outstanding == (S_AXI_BVALID ? 1:0)\n\t\t\t+(S_AXI_WREADY ? 0:1));\n\n\t\tassert(faxil_rd_outstanding == (S_AXI_RVALID ? 1:0)\n\t\t\t+(S_AXI_ARREADY ? 0:1));\n\tend else begin\n\t\tassert(faxil_wr_outstanding == (S_AXI_BVALID ? 1:0));\n\t\tassert(faxil_awr_outstanding == faxil_wr_outstanding);\n\n\t\tassert(faxil_rd_outstanding == (S_AXI_RVALID ? 1:0));\n\tend\n\n\t//\n\t// Check that our low-power only",
            "logic works by verifying that anytime\n\t// S_AXI_RVALID is inactive, then the outgoing data is also zero.\n\t//\n\talways @(*)\n\t\tassert(S_AXI_RDATA == 0);\n\talways @(*)\n\t\tassert(S_AXI_RRESP == 2'b11);\n\talways @(*)\n\t\tassert(S_AXI_BRESP == 2'b11);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover checks\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{\n\n\t// While there are already cover properties in the formal property\n\t// set above, you'll probably still want to cover something\n\t// application specific here\n\n\t// }}}\n\t// }}}\n`endif",
            "endmodule "
        ]
    },
    {
        "file_name": "axi2axilsub.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axi2axilsub.v",
        "chunks": [
            "module axi2axilsub #(\n\t\t// {{{",
            "parameter integer C_AXI_ID_WIDTH\t= 2,",
            "parameter integer C_S_AXI_DATA_WIDTH\t= 64,",
            "parameter integer C_M_AXI_DATA_WIDTH\t= 32,",
            "parameter integer C_AXI_ADDR_WIDTH\t= 6,",
            "parameter [0:0]\tOPT_LOWPOWER\t= 1,",
            "parameter [0:0]\tOPT_WRITES\t= 1,",
            "parameter [0:0]\tOPT_READS\t= 1,",
            "parameter SLVSZ = $clog2(C_S_AXI_DATA_WIDTH/8),",
            "parameter MSTSZ = $clog2(C_M_AXI_DATA_WIDTH/8),\n\t\t// Log (based two) of the maximum number of outstanding AXI\n\t\t// (not AXI-lite) transactions.  If you multiply 2^LGFIFO * 256,\n\t\t// you'll get the maximum number of outstanding AXI-lite\n\t\t// transactions",
            "parameter LGFIFO\t\t\t= 4\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,\n\t\t// AXI4 slave interface\n\t\t// {{{\n\t\t// Write address channel\n\t\t// {{{",
            "input ",
            "wire S_AXI_AWVALID,",
            "output ",
            "wire S_AXI_AWREADY,",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tS_AXI_AWID,",
            "input ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tS_AXI_AWADDR,",
            "input ",
            "wire [7:0]\t\t\tS_AXI_AWLEN,",
            "input ",
            "wire [2:0]\t\t\tS_AXI_AWSIZE,",
            "input ",
            "wire [1:0]\t\t\tS_AXI_AWBURST,",
            "input ",
            "wire S_AXI_AWLOCK,",
            "input ",
            "wire [3:0]\t\t\tS_AXI_AWCACHE,",
            "input ",
            "wire [2:0]\t\t\tS_AXI_AWPROT,",
            "input ",
            "wire [3:0]\t\t\tS_AXI_AWQOS,\n\t\t// }}}\n\t\t// Write data channel\n\t\t// {{{",
            "input ",
            "wire S_AXI_WVALID,",
            "output ",
            "wire S_AXI_WREADY,",
            "input ",
            "wire [C_S_AXI_DATA_WIDTH-1:0]\tS_AXI_WDATA,",
            "input ",
            "wire [(C_S_AXI_DATA_WIDTH/8)-1:0] S_AXI_WSTRB,",
            "input ",
            "wire S_AXI_WLAST,\n\t\t// }}}\n\t\t// Write return channel\n\t\t// {{{",
            "output ",
            "wire S_AXI_BVALID,",
            "input ",
            "wire S_AXI_BREADY,",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0]\tS_AXI_BID,",
            "output ",
            "wire [1:0]\t\t\tS_AXI_BRESP,\n\t\t// }}}\n\t\t// Read address channel\n\t\t// {{{",
            "input ",
            "wire S_AXI_ARVALID,",
            "output ",
            "wire S_AXI_ARREADY,",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tS_AXI_ARID,",
            "input ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tS_AXI_ARADDR,",
            "input ",
            "wire [7:0]\t\t\tS_AXI_ARLEN,",
            "input ",
            "wire [2:0]\t\t\tS_AXI_ARSIZE,",
            "input ",
            "wire [1:0]\t\t\tS_AXI_ARBURST,",
            "input ",
            "wire S_AXI_ARLOCK,",
            "input ",
            "wire [3:0]\t\t\tS_AXI_ARCACHE,",
            "input ",
            "wire [2:0]\t\t\tS_AXI_ARPROT,",
            "input ",
            "wire [3:0]\t\t\tS_AXI_ARQOS,\n\t\t// }}}\n\t\t// Read data channel\n\t\t// {{{",
            "output ",
            "wire S_AXI_RVALID,",
            "input ",
            "wire S_AXI_RREADY,",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0]\tS_AXI_RID,",
            "output ",
            "wire [C_S_AXI_DATA_WIDTH-1:0]\tS_AXI_RDATA,",
            "output ",
            "wire [1:0]\t\t\tS_AXI_RRESP,",
            "output ",
            "wire S_AXI_RLAST,\n\t\t// }}}\n\t\t// }}}\n\t\t// AXI-lite master interface\n\t\t// {{{\n\t\t// AXI-lite Write interface\n\t\t// {{{",
            "output ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tM_AXI_AWADDR,",
            "output ",
            "wire [2 : 0]\t\t\tM_AXI_AWPROT,",
            "output ",
            "wire M_AXI_AWVALID,",
            "input ",
            "wire M_AXI_AWREADY,",
            "output ",
            "wire [C_M_AXI_DATA_WIDTH-1:0]\tM_AXI_WDATA,",
            "output ",
            "wire [(C_M_AXI_DATA_WIDTH/8)-1:0] M_AXI_WSTRB,",
            "output ",
            "wire M_AXI_WVALID,",
            "input ",
            "wire M_AXI_WREADY,",
            "input ",
            "wire [1 : 0]\t\t\tM_AXI_BRESP,",
            "input ",
            "wire M_AXI_BVALID,",
            "output ",
            "wire M_AXI_BREADY,\n\t\t// }}}\n\t\t// AXI-lite read interface\n\t\t// {{{",
            "output ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tM_AXI_ARADDR,",
            "output ",
            "wire [2:0]\t\t\tM_AXI_ARPROT,",
            "output ",
            "wire M_AXI_ARVALID,",
            "input ",
            "wire M_AXI_ARREADY,\n\t\t//",
            "input ",
            "wire M_AXI_RVALID,",
            "output ",
            "wire M_AXI_RREADY,",
            "input ",
            "wire [C_M_AXI_DATA_WIDTH-1 : 0] M_AXI_RDATA,",
            "input ",
            "wire [1 : 0]\t\t\tM_AXI_RRESP\n\t\t// }}}\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Local",
            "parameter s,",
            "reg ister, and net declarations\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "localparam [1:0]\tOKAY   = 2'b00,\n\t\t\t\tEXOKAY = 2'b01,\n\t\t\t\tSLVERR = 2'b10;\n\t//",
            "localparam [1:0]\tDECERR = 2'b10;\n\n\t// Verilator lint_on UNUSED",
            "localparam AW = C_AXI_ADDR_WIDTH;",
            "localparam SLVDW = C_S_AXI_DATA_WIDTH;",
            "localparam MSTDW = C_M_AXI_DATA_WIDTH;",
            "localparam IW = C_AXI_ID_WIDTH;\n\t//",
            "localparam LSB = $clog2(C_AXI_DATA_WIDTH)-3;\n\t// }}}\n\t// Register declarations\n\t// {{{\n\t//\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Write",
            "logic // {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (OPT_WRITES && SLVDW == MSTDW)\n\tbegin : IMPLEMENT_AXI2AXILITE_WRITES\n\t\t// {{{\n\n\t\t// (Unused) signal declarations\n\t\t// {{{\n\t\t// Verilator lint_off UNUSED",
            "wire ign_arready, ign_rvalid,\n\t\t\t\t\t\tign_rlast,\n\t\t\t\t\t\tign_arvalid, ign_rready;",
            "wire [IW-1:0]\t\tign_rid;",
            "wire [SLVDW-1:0]\tign_rdata;",
            "wire [1:0]\t\t\tign_rresp;",
            "wire [AW-1:0]\tign_araddr;",
            "wire [2:0]\t\t\tign_arprot;\n\t\t// Verilator lint_on  UNUSED\n\t\t// }}}\n\n\t\taxi2axilite #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_DATA_WIDTH(SLVDW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t.OPT_WRITES(1),\n\t\t\t.OPT_READS(0),\n\t\t\t.LGFIFO(LGFIFO)\n\t\t\t// }}}\n\t\t) axilwrite (\n\t\t\t// {{{\n\t\t\t.S_AXI_ACLK(S_AXI_ACLK),\n\t\t\t.S_AXI_ARESETN(S_AXI_ARESETN),\n\t\t\t// AXI4 slave interface\n\t\t\t// {{{\n\t\t\t// Write address channel\n\t\t\t// {{{\n\t\t\t.S_AXI_AWVALID(S_AXI_AWVALID),\n\t\t\t.S_AXI_AWREADY(S_AXI_AWREADY),\n\t\t\t.S_AXI_AWID(   S_AXI_AWID),\n\t\t\t.S_AXI_AWADDR( S_AXI_AWADDR),\n\t\t\t.S_AXI_AWLEN(  S_AXI_AWLEN),\n\t\t\t.S_AXI_AWSIZE( S_AXI_AWSIZE),\n\t\t\t.S_AXI_AWBURST(S_AXI_AWBURST),\n\t\t\t.S_AXI_AWLOCK( S_AXI_AWLOCK),\n\t\t\t.S_AXI_AWCACHE(S_AXI_AWCACHE),\n\t\t\t.S_AXI_AWPROT( S_AXI_AWPROT),\n\t\t\t.S_AXI_AWQOS(  S_AXI_AWQOS),\n\t\t\t// }}}\n\t\t\t// Write data channel\n\t\t\t// {{{\n\t\t\t.S_AXI_WVALID(S_AXI_WVALID),\n\t\t\t.S_AXI_WREADY(S_AXI_WREADY),\n\t\t\t.S_AXI_WDATA( S_AXI_WDATA),\n\t\t\t.S_AXI_WSTRB( S_AXI_WSTRB),\n\t\t\t.S_AXI_WLAST( S_AXI_WLAST),\n\t\t\t// }}}\n\t\t\t// Write return channel\n\t\t\t// {{{\n\t\t\t.S_AXI_BVALID(S_AXI_BVALID),\n\t\t\t.S_AXI_BREADY(S_AXI_BREADY),\n\t\t\t.S_AXI_BID(   S_AXI_BID),\n\t\t\t.S_AXI_BRESP( S_AXI_BRESP),\n\t\t\t// }}}\n\t\t\t// Read address channel\n\t\t\t// {{{\n\t\t\t.S_AXI_ARVALID(1'b0),\n\t\t\t.S_AXI_ARREADY(ign_arready),\n\t\t\t.S_AXI_ARID(   {(IW){1'b0}}),\n\t\t\t.S_AXI_ARADDR( {(AW){1'b0}}),\n\t\t\t.S_AXI_ARLEN(  8'h0),\n\t\t\t.S_AXI_ARSIZE( 3'h0),\n\t\t\t.S_AXI_ARBURST(2'h0),\n\t\t\t.S_AXI_ARLOCK( 1'b0),\n\t\t\t.S_AXI_ARCACHE(4'h0),\n\t\t\t.S_AXI_ARPROT( 3'h0),\n\t\t\t.S_AXI_ARQOS(  4'h0),\n\t\t\t// }}}\n\t\t\t// Read data channel\n\t\t\t// {{{\n\t\t\t.S_AXI_RVALID(ign_rvalid),\n\t\t\t.S_AXI_RREADY(1'b1),\n\t\t\t.S_AXI_RID(   ign_rid),\n\t\t\t.S_AXI_RDATA( ign_rdata),\n\t\t\t.S_AXI_RRESP( ign_rresp),\n\t\t\t.S_AXI_RLAST( ign_rlast),\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t\t// AXI-lite master interface\n\t\t\t// {{{\n\t\t\t// AXI-lite Write interface\n\t\t\t// {{{\n\t\t\t.M_AXI_AWVALID(M_AXI_AWVALID),\n\t\t\t.M_AXI_AWREADY(M_AXI_AWREADY),\n\t\t\t.M_AXI_AWADDR(M_AXI_AWADDR),\n\t\t\t.M_AXI_AWPROT(M_AXI_AWPROT),\n\t\t\t//\n\t\t\t.M_AXI_WVALID(M_AXI_WVALID),\n\t\t\t.M_AXI_WREADY(M_AXI_WREADY),\n\t\t\t.M_AXI_WDATA(M_AXI_WDATA),\n\t\t\t.M_AXI_WSTRB(M_AXI_WSTRB),\n\t\t\t//\n\t\t\t.M_AXI_BVALID(M_AXI_BVALID),\n\t\t\t.M_AXI_BREADY(M_AXI_BREADY),\n\t\t\t.M_AXI_BRESP(M_AXI_BRESP),\n\t\t\t// }}}\n\t\t\t// AXI-lite read interface\n\t\t\t// {{{\n\t\t\t.M_AXI_ARVALID(ign_arvalid),\n\t\t\t.M_AXI_ARREADY(1'b1),\n\t\t\t.M_AXI_ARADDR(ign_araddr),\n\t\t\t.M_AXI_ARPROT(ign_arprot),\n\t\t\t//\n\t\t\t.M_AXI_RVALID(1'b0),\n\t\t\t.M_AXI_RREADY(ign_rready),\n\t\t\t.M_AXI_RDATA({(MSTDW){1'b0}}),\n\t\t\t.M_AXI_RRESP(2'b00)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\t// }}}\n\tend else begin : WDN\n\tif (OPT_WRITES)\n\tbegin : IMPLEMENT_WRITES\n\t\t// {{{\n\n\t\t// Register declarations\n\t\t// {{{",
            "localparam BIDFIFOBW = IW+1+(SLVSZ-MSTSZ+1);\n\n\t\t//\n\t\t// S_AXI_AW* skid buffer",
            "wire skids_awvalid;",
            "wire skids_awready;",
            "wire [IW-1:0]\tskids_awid;",
            "wire [AW-1:0]\tskids_awaddr;",
            "wire [7:0]\t\tskids_awlen;",
            "wire [2:0]\t\tskids_awsize;",
            "wire [1:0]\t\tskids_awburst;",
            "wire [2:0]\t\tskids_awprot;\n\t\t//\n\t\t// S_AXI_W* skid buffer",
            "wire skids_wvalid, skids_wready;",
            "wire [SLVDW-1:0]\tskids_wdata;",
            "wire [SLVDW/8-1:0]\tskids_wstrb;",
            "wire slv_awready, slv_wready;",
            "reg [SLVDW-1:0]\tslv_wdata;",
            "reg [SLVDW/8-1:0]\tslv_wstrb;",
            "reg [IW-1:0]\t\t\tslv_awid;",
            "reg [AW-1:0]\t\t\tslv_awaddr,\n\t\t\t\t\t\t\tslv_next_awaddr;",
            "reg [2:0]\t\t\t\tslv_awsize;",
            "reg [1:0]\t\t\t\tslv_awburst;",
            "reg [7:0]\t\t\t\tslv_awlen;",
            "reg [8:0]\t\t\t\tslv_wlen;",
            "reg slv_awlast;\n\n\t\t// Write",
            "reg isters",
            "reg m_axi_awvalid;",
            "reg bfifo_write, wfifo_wlast;",
            "reg [IW+1+SLVSZ-MSTSZ:0]\tbfifo_wdata;",
            "wire [LGFIFO:0]\t\twfifo_count;",
            "wire wfifo_full;",
            "wire wfifo_empty;",
            "wire [SLVSZ-MSTSZ:0]\t\twfifo_subcount;",
            "wire [IW-1:0]\t\twfifo_bid;",
            "reg [SLVSZ-MSTSZ:0]\t\tbcounts;",
            "reg [IW-1:0]\ts_axi_bid, bid;",
            "reg blast;",
            "reg [1:0]\t\t\ts_axi_bresp, bresp;",
            "reg s_axi_bvalid;",
            "reg b_return_stall;",
            "wire read_from_wrfifo;\n\t\t//\n\t\t// S_AXI_B* skid buffer isn't needed\n\t\t//\n\t\t// M_AXI_AW* skid buffer isn't needed\n\t\t//\n\t\t// M_AXI_W* skid buffer isn't needed\n\t\t//\n\t\t// M_AXI_B* skid buffer",
            "wire skidm_bvalid, skidm_bready;",
            "wire [1:0]\t\tskidm_bresp;",
            "reg m_axi_wvalid;",
            "reg [AW-1:0]\t\tmst_awaddr;",
            "reg [2:0]\t\t\tmst_awprot;",
            "reg [SLVSZ-MSTSZ:0]\t\tmst_awbeats,\n\t\t\t\t\t\tmst_wbeats, next_slv_beats;\n\t\t// }}}\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t// Incoming write address / data handling\n\t\t// {{{\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t//\n\n\t\t////////////////////////////////////////\n\t\t//\n\t\t// Clock #1: The skid buffer\n\t\t// {{{\n\n\t\t// The write address channel's skid buffer\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(IW+AW+8+3+2+3),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_OUTREG(0)\n\t\t\t// }}}\n\t\t) awskid(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t\t.i_valid(S_AXI_AWVALID), .o_ready(S_AXI_AWREADY),\n\t\t\t.i_data({ S_AXI_AWID, S_AXI_AWADDR, S_AXI_AWLEN,\n\t\t\t\tS_AXI_AWSIZE, S_AXI_AWBURST, S_AXI_AWPROT }),\n\t\t\t.o_valid(skids_awvalid), .i_ready(skids_awready),\n\t\t\t.o_data({ skids_awid, skids_awaddr, skids_awlen,\n\t\t\t\tskids_awsize, skids_awburst, skids_awprot })\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\t\t//\n\t\t// The write data channel's skid buffer (S_AXI_W*)\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(SLVDW+SLVDW/8),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_OUTREG(0)\n\t\t\t// }}}\n\t\t) wskid(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t\t.i_valid(S_AXI_WVALID), .o_ready(S_AXI_WREADY),\n\t\t\t.i_data({ S_AXI_WDATA, S_AXI_WSTRB }),\n\t\t\t.o_valid(skids_wvalid), .i_ready(skids_wready),\n\t\t\t.o_data({ skids_wdata, skids_wstrb })\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\tassign\tskids_awready = skids_wvalid && skids_wready\n\t\t\t\t\t&& slv_awlast;\n\n\t\tassign\tskids_wready = slv_wready;\n\t\t// }}}\n\t\t////////////////////////////////////////\n\t\t//\n\t\t// Clock 2: slv_* clock\n\t\t// {{{\n\n\t\t// When are we ready for a next SLAVE beat?\n\t\tassign\tslv_awready = (skids_wvalid && skids_wready);\n\n\t\t// slv_aw*\n\t\t// {{{\n\t\t// slv_awaddr is the address of the value *CURRENTLY* in the\n\t\t// buffer, *NOT* the next address.\n\t\tinitial\tslv_awlast = 1;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (skids_awvalid && skids_awready)\n\t\tbegin\n\t\t\tslv_awid    <= skids_awid;\n\t\t\tslv_awaddr  <= skids_awaddr;\n\t\t\tslv_awlen   <= skids_awlen;\n\t\t\tslv_awsize  <= skids_awsize;\n\t\t\tslv_awburst <= skids_awburst;\n\t\tend else if (slv_awready && slv_wlen > 0)\n\t\tbegin\n\t\t\t// Step forward a full beat -- but only when we have\n\t\t\t// the data to do so\n\t\t\tslv_awaddr <= slv_next_awaddr;\n\t\tend\n\t\t// }}}\n\n\t\t// slv_awlast\n\t\t// {{{\n\t\tinitial\tslv_awlast = 1;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tslv_awlast <= 1;\n\t\telse if (skids_awvalid && skids_awready)\n\t\t\tslv_awlast  <= (skids_awlen == 0);\n\t\telse if (skids_wvalid && skids_wready)\n\t\t\tslv_awlast <= (slv_wlen <= 2);\n\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\t\tassert(slv_awlast == (slv_wlen <= 1));\n`endif\n\t\t// }}}\n\n\t\t// slv_wlen = Number of beats remaining\n\t\t// {{{\n\t\t// ... in the slave's data space, to include the one we've\n\t\t// just ingested.  Therefore, this is a 1-up counter.  If\n\t\t// slv_wlen == 0, then we are idle.\n\t\tinitial\tslv_wlen = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tslv_wlen <= 0;\n\t\telse if (skids_awvalid && skids_awready)\n\t\tbegin\n\t\t\tslv_wlen <= skids_awlen + 1;\n\t\tend else if (skids_wvalid && skids_wready) // (slv_awready && slv_wlen > 0)\n\t\tbegin\n\t\t\tslv_wlen <= slv_wlen - 1;\n`ifdef\tFORMAL\n\t\t\tassert(slv_wlen > 0);\n`endif\n\t\tend else if (slv_wlen == 1 && slv_wready)\n\t\t\tslv_wlen <= 0;\n\t\t// }}}\n\n\t\t// next_slv_beats\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\t// Verilator lint_off WIDTH\n\t\t\tnext_slv_beats = (1<<(skids_awsize-MSTSZ[2:0]))\n\t\t\t\t  - (skids_awaddr[SLVSZ-1:0] >> skids_awsize);\n\t\t\tif (skids_awsize <= MSTSZ[2:0])\n\t\t\t\tnext_slv_beats = 1;\n\t\t\t// Verilator lint_on  WIDTH\n\t\tend\n\t\t// }}}\n\n\n\t\t// slv_next_awaddr\n\t\t// {{{\n\t\taxi_addr #(\n\t\t\t// {{{\n\t\t\t.AW(AW),\n\t\t\t.DW(SLVDW)\n\t\t\t// }}}\n\t\t) get_next_slave_addr (\n\t\t\t// {{{\n\t\t\t.i_last_addr(slv_awaddr),\n\t\t\t.i_size(slv_awsize),\n\t\t\t.i_burst(slv_awburst),\n\t\t\t.i_len(slv_awlen),\n\t\t\t.o_next_addr(slv_next_awaddr)\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\tassign\tslv_wready = (mst_awbeats <= (M_AXI_AWREADY ? 1:0))\n\t\t\t\t\t&& (mst_wbeats <= (M_AXI_WREADY ? 1:0))\n\t\t\t\t\t&& (!bfifo_write || !wfifo_full);\n\n\t\t// slv_wstrb, slv_wdata\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\t\t{ slv_wstrb, slv_wdata } <= 0;\n\t\telse if (skids_awready)\n\t\tbegin\n\t\t\tslv_wstrb <= skids_wstrb >> (skids_awaddr[SLVSZ-1:MSTSZ]*MSTDW/8);\n\t\t\tslv_wdata <= skids_wdata >> (skids_awaddr[SLVSZ-1:MSTSZ]*MSTDW);\n\t\t\tif (OPT_LOWPOWER && !skids_awvalid)\n\t\t\tbegin\n\t\t\t\tslv_wstrb <= 0;\n\t\t\t\tslv_wdata <= 0;\n\t\t\tend\n\t\tend else if (skids_wready)\n\t\tbegin\n\t\t\tslv_wstrb <= skids_wstrb >> (slv_next_awaddr[SLVSZ-1:MSTSZ]*MSTDW/8);\n\t\t\tslv_wdata <= skids_wdata >> (slv_next_awaddr[SLVSZ-1:MSTSZ]*MSTDW);\n\t\t\tif (OPT_LOWPOWER && !skids_wvalid)\n\t\t\tbegin\n\t\t\t\tslv_wstrb <= 0;\n\t\t\t\tslv_wdata <= 0;\n\t\t\tend\n\t\tend else if (M_AXI_WVALID && M_AXI_WREADY)\n\t\tbegin\n\t\t\tslv_wstrb <= slv_wstrb >> (MSTDW/8);\n\t\t\tslv_wdata <= slv_wdata >> (MSTDW);\n\t\tend\n\t\t// }}}\n\n\t\t// }}}\n\t\t////////////////////////////////////////\n\t\t//\n\t\t// Clock 2 (continued): mst_* = M_AXI_*\n\t\t// {{{\n\n\t\t// mst_awaddr, mst_awprot, mst_awbeats\n\t\t// {{{\n\t\tinitial\tmst_awaddr = 0;\n\t\tinitial\tmst_awprot = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tbegin\n\t\t\tif (!M_AXI_AWVALID || M_AXI_AWREADY)\n\t\t\tbegin\n\t\t\t\tif (skids_awvalid && skids_awready)\n\t\t\t\tbegin\n\t\t\t\t\tmst_awaddr <= skids_awaddr;\n\t\t\t\t\tmst_awprot <= skids_awprot;\n\t\t\t\t\tmst_awbeats<= next_slv_beats;\n\t\t\t\tend else if (skids_wvalid && skids_wready)\n\t\t\t\tbegin\n\t\t\t\t\tmst_awaddr <= slv_next_awaddr;\n\t\t\t\t\tmst_awbeats<= 1;\n\t\t\t\t\tif (slv_awsize >= MSTSZ[2:0])\n\t\t\t\t\t\tmst_awbeats <= (1<<(slv_awsize - MSTSZ[2:0]));\n\t\t\t\tend else begin\n\t\t\t\t\tif (mst_awbeats > 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tmst_awaddr <= mst_awaddr + (1<<MSTSZ);\n\t\t\t\t\t\tmst_awaddr[MSTSZ-1:0] <= 0;\n\t\t\t\t\tend else if (OPT_LOWPOWER)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tmst_awaddr <= 0;\n\t\t\t\t\tend\n\n\t\t\t\t\tif (mst_awbeats > 0)\n\t\t\t\t\t\tmst_awbeats <= mst_awbeats - 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif (!S_AXI_ARESETN)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\tmst_awbeats <= 0;\n\t\t\t\tif (OPT_LOWPOWER)\n\t\t\t\tbegin\n\t\t\t\t\tmst_awaddr  <= 0;\n\t\t\t\t\tmst_awprot  <= 0;\n\t\t\t\tend\n\t\t\t\t// }}}\n\t\t\tend\n\t\tend\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif(S_AXI_ARESETN && OPT_LOWPOWER && mst_awbeats == 0)\n\t\tbegin\n\t\t\tassert(mst_awaddr == 0);\n\t\tend\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\t\tassert(m_axi_awvalid == (mst_awbeats > 0));\n`endif\n\t\t// }}}\n\n\t\t// m_axi_awvalid\n\t\t// {{{\n\t\tinitial\tm_axi_awvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tm_axi_awvalid <= 0;\n\t\telse if (!M_AXI_AWVALID || M_AXI_AWREADY)\n\t\tbegin\n\t\t\tif (skids_wvalid && skids_wready)\n\t\t\t\tm_axi_awvalid <= 1'b1;\n\t\t\telse if (mst_awbeats == 1)\n\t\t\t\tm_axi_awvalid <= 1'b0;\n\t\tend\n\t\t// }}}\n\n\t\tassign\tM_AXI_AWVALID = m_axi_awvalid;\n\t\tassign\tM_AXI_AWVALID = m_axi_awvalid;\n\t\tassign\tM_AXI_AWADDR  = mst_awaddr;\n\t\tassign\tM_AXI_AWPROT  = mst_awprot;\n\n\t\t// M_AXI_WVALID, mst_wbeats\n\t\t// {{{\n\t\tinitial\tm_axi_wvalid = 0;\n\t\tinitial\tmst_wbeats   = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\tm_axi_wvalid <= 0;\n\t\t\tmst_wbeats   <= 0;\n\t\tend else if (!M_AXI_WVALID || M_AXI_WREADY)\n\t\tbegin\n\t\t\tif (skids_wvalid && skids_wready)\n\t\t\tbegin\n\t\t\t\tm_axi_wvalid <= 1'b1;\n\t\t\t\tif (skids_awvalid && skids_awready)\n\t\t\t\t\tmst_wbeats   <= next_slv_beats;\n\t\t\t\telse if (slv_awsize <= MSTSZ[2:0])\n\t\t\t\t\tmst_wbeats <= 1;\n\t\t\t\telse\n\t\t\t\t\tmst_wbeats <= (1<<(slv_awsize - MSTSZ[2:0]));\n\t\t\tend else begin\n\t\t\t\tif (mst_wbeats <= 1)\n\t\t\t\t\tm_axi_wvalid <= 1'b0;\n\t\t\t\tif (mst_wbeats > 0)\n\t\t\t\t\tmst_wbeats   <= mst_wbeats - 1;\n\t\t\tend\n\t\tend\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\t\tassert(M_AXI_WVALID == (mst_wbeats > 0));\n`endif\n\t\t// }}}\n\n\t\t// M_AXI_WDATA, M_AXI_WSTRB\n\t\t// {{{\n\t\tassign\tM_AXI_WDATA = slv_wdata[MSTDW-1:0];\n\t\tassign\tM_AXI_WSTRB = slv_wstrb[MSTDW/8-1:0];\n\t\t// }}}\n\n\t\tassign\tM_AXI_WVALID = m_axi_wvalid;\n\t\tassign\tM_AXI_WDATA  = slv_wdata[MSTDW-1:0];\n\t\tassign\tM_AXI_WSTRB  = slv_wstrb[MSTDW/8-1:0];\n\t\t// }}}\n\t\t////////////////////////////////////////\n\t\t//\n\t\t// Clock 3: The B FIFO\n\t\t// {{{\n\n\t\t// bfifo_write\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tbfifo_write <= 0;\n\t\telse if (!bfifo_write || !wfifo_full)\n\t\t\tbfifo_write <= skids_wvalid && skids_wready;\n\t\t// }}}\n\n\t\t// bfifo_wdata\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tbfifo_wdata <= 0;\n\t\telse if (skids_awvalid && skids_awready)\n\t\tbegin\n\t\t\tbfifo_wdata[SLVSZ-MSTSZ:0] <= next_slv_beats;\n\t\t\tbfifo_wdata[SLVSZ-MSTSZ+1] <= (skids_awlen == 0);\n\t\t\tbfifo_wdata[SLVSZ-MSTSZ+2 +: IW] <= skids_awid;\n`ifdef\tFORMAL\n\t\t\tassert(skids_wvalid && skids_wready);\n`endif\n\t\tend else if (skids_wvalid && skids_wready)\n\t\tbegin\n\t\t\tbfifo_wdata[SLVSZ-MSTSZ+2 +: IW] <= slv_awid;\n\t\t\tbfifo_wdata[SLVSZ-MSTSZ+1] <= (slv_wlen <= 2)\n\t\t\t\t\t\t? 1'b1 : 1'b0;\n\n\t\t\tif (slv_awsize <= MSTSZ[2:0])\n\t\t\t\tbfifo_wdata[SLVSZ-MSTSZ:0] <= 1;\n\t\t\telse\n\t\t\t\tbfifo_wdata[SLVSZ-MSTSZ:0]\n\t\t\t\t\t<= (1<<(slv_awsize - MSTSZ[2:0]));\n\t\tend\n\t\t// }}}\n\n\t\t// BFIFO\n\t\t// {{{\n\t\tsfifo\t#(\n\t\t\t// {{{\n\t\t\t.BW(BIDFIFOBW), .LGFLEN(LGFIFO)\n\t\t\t// }}}\n\t\t) bidlnfifo(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t\t.i_wr(bfifo_write), .i_data(bfifo_wdata),\n\t\t\t\t.o_full(wfifo_full), .o_fill(wfifo_count),\n\t\t\t.i_rd(read_from_wrfifo),\n\t\t\t.o_data({ wfifo_bid, wfifo_wlast,wfifo_subcount }),\n\t\t\t.o_empty(wfifo_empty)\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// read_from_wrfifo\n\t\t// {{{\n\t\tassign\tread_from_wrfifo = (bcounts <= 1)&&(!wfifo_empty)\n\t\t\t    &&(skidm_bvalid && skidm_bready);\n\t\t// }}}\n\t\t// }}}\n\t\t////////////////////////////////////////\n\t\t//\n\t\t// Return clock 1: the skid buffer\n\t\t// {{{\n\n\t\t//\n\t\t// The downstream AXI-lite response (M_AXI_B*) skid buffer\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(2),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_OUTREG(0)\n\t\t\t// }}}\n\t\t) bskid(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t\t.i_valid(M_AXI_BVALID), .o_ready(M_AXI_BREADY),\n\t\t\t\t.i_data({ M_AXI_BRESP }),\n\t\t\t.o_valid(skidm_bvalid), .i_ready(skidm_bready),\n\t\t\t\t.o_data({ skidm_bresp })\n\t\t\t// }}}\n\t\t);\n\n\t\tassign\tskidm_bready = ((bcounts > 0)||(!wfifo_empty))\n\t\t\t\t&& !b_return_stall;\n\t\t// }}}\n\t\t////////////////////////////////////////\n\t\t//\n\t\t// Return staging: Counting returns\n\t\t// {{{\n\n\t\t// bcounts\n\t\t// {{{\n\t\t// Return counts\n\t\tinitial\tbcounts = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tbcounts <= 0;\n\t\telse if (skidm_bvalid && skidm_bready)\n\t\tbegin\n\t\t\tif (read_from_wrfifo)\n\t\t\tbegin\n\t\t\t\t/*\n\t\t\t\tif (bcounts == 0 && wfifo_subcount <= 1\n\t\t\t\t\t\t&& wfifo_wlast)\n\t\t\t\t\t// Go straight to S_AXI_BVALID, no\n\t\t\t\t\t// more bursts to count here\n\t\t\t\t\tbcounts <= 0;\n\t\t\t\telse\n\t\t\t\t*/\n\t\t\t\t\tbcounts <= wfifo_subcount + bcounts - 1;\n\t\t\tend else\n\t\t\t\tbcounts <= bcounts - 1;\n\t\tend\n\t\t// }}}\n\n\t\t// blast\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (read_from_wrfifo)\n\t\t\tblast <= wfifo_wlast;\n\t\t// }}}\n\n\t\t// bid\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (read_from_wrfifo)\n\t\t\tbid <= wfifo_bid;\n\t\t// }}}\n\n\t\t// bresp\n\t\t// {{{\n\t\tinitial\tbresp = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tbresp <= OKAY;\n\t\telse if (!S_AXI_BVALID || S_AXI_BREADY)\n\t\t\tbresp <= OKAY;\n\t\telse if (skidm_bvalid && skidm_bready)\n\t\tbegin\n\t\t\t// Let SLVERR take priority over DECERR\n\t\t\tcasez({ bresp, skidm_bresp })\n\t\t\t4'b??0?: bresp <= bresp;\n\t\t\t4'b0?1?: bresp <= skidm_bresp;\n\t\t\t4'b1?10: bresp <= SLVERR;\n\t\t\t4'b1011: bresp <= SLVERR;\n\t\t\t4'b1111: bresp <= skidm_bresp;\n\t\t\tendcase\n\n\t\t\tif (blast)\n\t\t\t\tbresp <= OKAY;\n\t\tend\n\t\t// }}}\n\t\t// }}}\n\t\t////////////////////////////////////////\n\t\t//\n\t\t// Return clock 2: S_AXI_* returns\n\t\t// {{{\n\n\t\t// s_axi_bid\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_BVALID || S_AXI_BREADY)\n\t\tbegin\n\t\t\tif (bcounts > 0 && blast)\n\t\t\t\ts_axi_bid <= bid;\n\t\t\telse if (read_from_wrfifo)\n\t\t\t\ts_axi_bid <= wfifo_bid;\n\t\t\telse\n\t\t\t\ts_axi_bid <= bid;\n\t\tend\n\t\t// }}}\n\n\t\t// s_axi_bvalid, b_return_stall\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\t// Force simulation evaluation on reset\n\t\t\tif (!S_AXI_ARESETN)\n\t\t\t\tb_return_stall = 0;\n\n\t\t\t// Default: stalled if the",
            "output is stalled\n\t\t\tb_return_stall = S_AXI_BVALID && !S_AXI_BREADY;\n\n\t\t\tif (bcounts > 1)\n\t\t\t\tb_return_stall = 0;\n\t\t\telse if (bcounts == 1 && !blast)\n\t\t\t\tb_return_stall = 0;\n\t\t\telse if (bcounts == 0\n\t\t\t\t&& (wfifo_subcount > 1 || !wfifo_wlast))\n\t\t\t\tb_return_stall = 0;\n\t\tend\n\n\t\tinitial\ts_axi_bvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\ts_axi_bvalid <= 0;\n\t\telse if (!S_AXI_BVALID || S_AXI_BREADY)\n\t\tbegin\n\t\t\ts_axi_bvalid <= 0;\n\t\t\tif (skidm_bvalid && skidm_bready)\n\t\t\t\ts_axi_bvalid <= ((bcounts == 1)&& blast)\n\t\t\t\t\t||((bcounts == 0) && (!wfifo_empty)\n\t\t\t\t\t\t&& (wfifo_subcount <= 1)&& wfifo_wlast);\n\t\tend\n\t\t// }}}\n\n\t\t// s_axi_bresp\n\t\t// {{{\n\t\tinitial\ts_axi_bresp = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\ts_axi_bresp <= OKAY;\n\t\telse if (!S_AXI_BVALID || S_AXI_BREADY)\n\t\tbegin\n\t\t\tif (skidm_bvalid && skidm_bready)\n\t\t\tbegin\n\t\t\t\t// Let SLVERR take priority over DECERR\n\t\t\t\tcasez({ bresp, skidm_bresp[1] })\n\t\t\t\t3'b??0: s_axi_bresp <= s_axi_bresp;\n\t\t\t\t3'b0?1: s_axi_bresp <= skidm_bresp;\n\t\t\t\t3'b101: s_axi_bresp <= SLVERR;\n\t\t\t\t3'b111: s_axi_bresp <= skidm_bresp;\n\t\t\t\tendcase\n\t\t\tend else\n\t\t\t\ts_axi_bresp <= bresp;\n\t\tend\n\t\t// }}}\n\n\t\t// S_AXI_B* assignments\n\t\t// {{{\n\t\tassign\tS_AXI_BID    = s_axi_bid;\n\t\tassign\tS_AXI_BRESP  = s_axi_bresp;\n\t\tassign\tS_AXI_BVALID = s_axi_bvalid;\n\t\t// }}}\n\t\t// }}}\n\t\t// }}}\n\t\t// Make Verilator happy\n\t\t// {{{\n\t\t// Verilator lint_off UNUSED",
            "wire unused_write;\n\t\tassign\tunused_write = &{ 1'b0, wfifo_count, S_AXI_WLAST };\n\t\t// Verilator lint_on  UNUSED\n\t\t// }}}\n\t\t////////////////////////////////////////////////////////////////\n\t\t////////////////////////////////////////////////////////////////\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t// Formal properties, write half\n\t\t// {{{\n\t\t////////////////////////////////////////////////////////////////\n\t\t////////////////////////////////////////////////////////////////\n\t\t////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t\t// These are only a subset of the formal properties used to\n\t\t// verify this design.  While I will warrant that the full\n\t\t// property set will work, I don't really expect the below\n\t\t// properties to be sufficient or for that matter even\n\t\t// syntactically correct.\n\t\t//\n\t\t// Register declarations\n\t\t// {{{",
            "localparam F_LGDEPTH = LGFIFO+1+8;",
            "wire [F_LGDEPTH-1:0]\t\tfaxi_awr_nbursts;",
            "wire [9-1:0]\t\t\tfaxi_wr_pending;",
            "wire [F_LGDEPTH-1:0]\t\tfaxi_rd_nbursts;",
            "wire [F_LGDEPTH-1:0]\t\tfaxi_rd_outstanding;\n\n\t\t//\n\t\t// ...\n\t\t//",
            "localparam F_AXIL_LGDEPTH = F_LGDEPTH;",
            "wire [F_AXIL_LGDEPTH-1:0]\tfaxil_rd_outstanding,\n\t\t\t\t\t\tfaxil_wr_outstanding,\n\t\t\t\t\t\tfaxil_awr_outstanding;\n\t\t// }}}\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t// AXI channel properties\n\t\t// {{{\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t//\n\t\tfaxi_slave #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_DATA_WIDTH(SLVDW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t.F_LGDEPTH(F_AXIL_LGDEPTH),\n\t\t\t.OPT_EXCLUSIVE(0)\n\t\t\t// ...\n\t\t\t// }}}\n\t\t) faxi(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK),\n\t\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t\t// Write address\n\t\t\t// {{{\n\t\t\t.i_axi_awvalid(skids_awvalid),\n\t\t\t.i_axi_awready(skids_awready),\n\t\t\t.i_axi_awid(   skids_awid),\n\t\t\t.i_axi_awaddr( skids_awaddr),\n\t\t\t.i_axi_awlen(  skids_awlen),\n\t\t\t.i_axi_awsize( skids_awsize),\n\t\t\t.i_axi_awburst(skids_awburst),\n\t\t\t.i_axi_awlock( 0),\n\t\t\t.i_axi_awcache(0),\n\t\t\t.i_axi_awprot( skids_awprot),\n\t\t\t.i_axi_awqos(  0),\n\t\t\t// }}}\n\t\t\t// Write data\n\t\t\t// {{{\n\t\t\t.i_axi_wvalid( skids_wvalid),\n\t\t\t.i_axi_wready( skids_wready),\n\t\t\t.i_axi_wdata(  skids_wdata),\n\t\t\t.i_axi_wstrb(  skids_wstrb),\n\t\t\t.i_axi_wlast(  S_AXI_WLAST),\n\t\t\t// }}}\n\t\t\t// Write return response\n\t\t\t// {{{\n\t\t\t.i_axi_bvalid( S_AXI_BVALID),\n\t\t\t.i_axi_bready( S_AXI_BREADY),\n\t\t\t.i_axi_bid(    S_AXI_BID),\n\t\t\t.i_axi_bresp(  S_AXI_BRESP),\n\t\t\t// }}}\n\t\t\t// Read address\n\t\t\t// {{{\n\t\t\t.i_axi_arvalid(1'b0),\n\t\t\t.i_axi_arready(1'b0),\n\t\t\t.i_axi_arid(   skids_awid),\n\t\t\t.i_axi_araddr( skids_awaddr),\n\t\t\t.i_axi_arlen(  skids_awlen),\n\t\t\t.i_axi_arsize( skids_awsize),\n\t\t\t.i_axi_arburst(skids_awburst),\n\t\t\t.i_axi_arlock( 0),\n\t\t\t.i_axi_arcache(0),\n\t\t\t.i_axi_arprot( 0),\n\t\t\t.i_axi_arqos(  0),\n\t\t\t// }}}\n\t\t\t// Read response\n\t\t\t// {{{\n\t\t\t.i_axi_rvalid( 1'b0),\n\t\t\t.i_axi_rready( 1'b0),\n\t\t\t.i_axi_rid(    S_AXI_RID),\n\t\t\t.i_axi_rdata(  S_AXI_RDATA),\n\t\t\t.i_axi_rlast(  S_AXI_RLAST),\n\t\t\t.i_axi_rresp(  S_AXI_RRESP),\n\t\t\t// }}}\n\t\t\t// Formal property data\n\t\t\t// {{{\n\t\t\t.f_axi_awr_nbursts(   faxi_awr_nbursts),\n\t\t\t.f_axi_wr_pending(    faxi_wr_pending),\n\t\t\t.f_axi_rd_nbursts(    faxi_rd_nbursts),\n\t\t\t.f_axi_rd_outstanding(faxi_rd_outstanding)\n\t\t\t//\n\t\t\t// ...\n\t\t\t//\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\talways @(*)\n\t\tbegin\n\t\t\t// ...\n\t\t\tassert(faxi_rd_nbursts == 0);\n\t\tend\n\n\t\t// }}}\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t// AXI-lite properties\n\t\t// {{{\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t//\n\n\t\tfaxil_master #(\n\t\t\t// {{{\n\t\t\t.C_AXI_DATA_WIDTH(MSTDW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t.F_OPT_NO_RESET(1),\n\t\t\t.F_AXI_MAXWAIT(5),\n\t\t\t.F_AXI_MAXDELAY(4),\n\t\t\t.F_AXI_MAXRSTALL(0),\n\t\t\t.F_OPT_WRITE_ONLY(1),\n\t\t\t.F_OPT_READ_ONLY(1'b0),\n\t\t\t.F_LGDEPTH(F_AXIL_LGDEPTH)\n\t\t\t// }}}\n\t\t) faxil(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK),\n\t\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t\t// Write address channel\n\t\t\t// {{{\n\t\t\t.i_axi_awvalid(M_AXI_AWVALID),\n\t\t\t.i_axi_awready(M_AXI_AWREADY),\n\t\t\t.i_axi_awaddr( M_AXI_AWADDR),\n\t\t\t.i_axi_awprot( M_AXI_AWPROT),\n\t\t\t// }}}\n\t\t\t// Write data\n\t\t\t// {{{\n\t\t\t.i_axi_wvalid( M_AXI_WVALID),\n\t\t\t.i_axi_wready( M_AXI_WREADY),\n\t\t\t.i_axi_wdata(  M_AXI_WDATA),\n\t\t\t.i_axi_wstrb(  M_AXI_WSTRB),\n\t\t\t// }}}\n\t\t\t// Write response\n\t\t\t// {{{\n\t\t\t.i_axi_bvalid( skidm_bvalid),\n\t\t\t.i_axi_bready( skidm_bready),\n\t\t\t.i_axi_bresp(  skidm_bresp),\n\t\t\t// }}}\n\t\t\t// Read address\n\t\t\t// {{{\n\t\t\t.i_axi_arvalid(M_AXI_ARVALID),\n\t\t\t.i_axi_arready(M_AXI_ARREADY),\n\t\t\t.i_axi_araddr( M_AXI_ARADDR),\n\t\t\t.i_axi_arprot( M_AXI_ARPROT),\n\t\t\t// }}}\n\t\t\t// Read data return\n\t\t\t// {{{\n\t\t\t.i_axi_rvalid( 1'b0),\n\t\t\t.i_axi_rready( 1'b1),\n\t\t\t.i_axi_rdata(  {(C_M_AXI_DATA_WIDTH){1'b0}}),\n\t\t\t.i_axi_rresp(  2'b00),\n\t\t\t// }}}\n\t\t\t// Formal check variables\n\t\t\t// {{{\n\t\t\t.f_axi_rd_outstanding(faxil_rd_outstanding),\n\t\t\t.f_axi_wr_outstanding(faxil_wr_outstanding),\n\t\t\t.f_axi_awr_outstanding(faxil_awr_outstanding)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\tbegin\n\t\t\tassert(faxil_rd_outstanding == 0);\n\n\t\t\tassert(faxil_awr_outstanding\n\t\t\t\t+ ((mst_awbeats > 0) ? mst_awbeats : 0)\n\t\t\t\t== f_wfifo_beats\n\t\t\t\t+ (bfifo_write ? bfifo_wdata[SLVSZ-MSTSZ:0] : 0)\n\t\t\t\t+ bcounts);\n\n\t\t\tassert(faxil_wr_outstanding\n\t\t\t\t+ ((mst_wbeats > 0) ? mst_wbeats : 0)\n\t\t\t\t== f_wfifo_beats\n\t\t\t\t+ (bfifo_write ? bfifo_wdata[SLVSZ-MSTSZ:0] : 0)\n\t\t\t\t+ bcounts);\n\t\tend\n\n\n\t\talways @(*)\n\t\t\tassert(faxil_awr_outstanding <= { 1'b1, {(LGFIFO+8){1'b0}} } + bcounts);\n\t\talways @(*)\n\t\t\tassert(faxil_wr_outstanding  <= { 1'b1, {(LGFIFO+8){1'b0}} } + bcounts);\n\n\t\t// }}}\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t// BFIFO property checking\n\t\t// {{{\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t//\n\n\t\t//\n\t\t// ...\n\t\t//\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (S_AXI_ARESETN)\n\t\tbegin\n\t\t\tassert(faxi_awr_nbursts == f_bfifo_packets\n\t\t\t\t+ (slv_awvalid ? 1:0));\n\t\t\tassert(f_bfifo_packets <= wfifo_count);\n\n\t\t\t// ...\n\t\tend\n\n\t\t//\n\t\t// ...\n\t\t//\n\n\t\t// }}}\n`endif\n\t\t// }}}\n\t\t// }}}\n\tend else begin : NO_WRITE_SUPPORT\n\t\t// {{{\n\t\tassign\tS_AXI_AWREADY = 0;\n\t\tassign\tS_AXI_WREADY  = 0;\n\t\tassign\tS_AXI_BID     = 0;\n\t\tassign\tS_AXI_BRESP   = 2'b11;\n\t\tassign\tS_AXI_BVALID  = 0;\n\t\tassign\tS_AXI_BID     = 0;\n\n\t\t//\n\t\tassign\tM_AXI_AWVALID = 0;\n\t\tassign\tM_AXI_AWADDR  = 0;\n\t\tassign\tM_AXI_AWPROT  = 0;\n\t\t//\n\t\tassign\tM_AXI_WVALID  = 0;\n\t\tassign\tM_AXI_WDATA   = 0;\n\t\tassign\tM_AXI_WSTRB   = 0;\n\t\t//\n\t\tassign\tM_AXI_BREADY  = 0;\n\t\t// }}}\n\tend end endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read",
            "logic // {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (OPT_READS && SLVDW == MSTDW)\n\tbegin : IMPLEMENT_AXI2AXILITE_READS\n\t\t// {{{\n\n\t\t// (Unused) signal declarations\n\t\t// {{{\n\t\t// Verilator lint_off UNUSED",
            "wire ign_awready, ign_wready,\n\t\t\t\t\t\tign_bvalid;",
            "wire [IW-1:0]\tign_bid;",
            "wire [1:0]\t\t\tign_bresp;",
            "wire ign_awvalid, ign_wvalid,\n\t\t\t\t\t\tign_bready;",
            "wire [AW-1:0]\tign_awaddr;",
            "wire [2:0]\t\t\tign_awprot;",
            "wire [MSTDW-1:0]\tign_wdata;",
            "wire [MSTDW/8-1:0]\tign_wstrb;\n\t\t// Verilator lint_on  UNUSED\n\t\t// }}}\n\n\t\taxi2axilite #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_DATA_WIDTH(SLVDW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t.OPT_WRITES(0),\n\t\t\t.OPT_READS(1),\n\t\t\t.LGFIFO(LGFIFO)\n\t\t\t// }}}\n\t\t) axilread (\n\t\t// {{{\n\t\t\t.S_AXI_ACLK(S_AXI_ACLK),\n\t\t\t.S_AXI_ARESETN(S_AXI_ARESETN),\n\t\t\t// AXI4 slave interface\n\t\t\t// {{{\n\t\t\t// Write address channel\n\t\t\t// {{{\n\t\t\t.S_AXI_AWVALID(1'b0),\n\t\t\t.S_AXI_AWREADY(ign_awready),\n\t\t\t.S_AXI_AWID(   {(IW){1'b0}} ),\n\t\t\t.S_AXI_AWADDR( {(AW){1'b0}} ),\n\t\t\t.S_AXI_AWLEN(  8'h0),\n\t\t\t.S_AXI_AWSIZE( 3'h0),\n\t\t\t.S_AXI_AWBURST(2'h0),\n\t\t\t.S_AXI_AWLOCK( 1'b0),\n\t\t\t.S_AXI_AWCACHE(4'h0),\n\t\t\t.S_AXI_AWPROT( 3'h0),\n\t\t\t.S_AXI_AWQOS(  4'h0),\n\t\t\t// }}}\n\t\t\t// Write data channel\n\t\t\t// {{{\n\t\t\t.S_AXI_WVALID(1'b0),\n\t\t\t.S_AXI_WREADY(ign_wready),\n\t\t\t.S_AXI_WDATA( {(SLVDW){1'b0}}),\n\t\t\t.S_AXI_WSTRB( {(SLVDW/8){1'b0}}),\n\t\t\t.S_AXI_WLAST( 1'b0),\n\t\t\t// }}}\n\t\t\t// Write return channel\n\t\t\t// {{{\n\t\t\t.S_AXI_BVALID(ign_bvalid),\n\t\t\t.S_AXI_BREADY(1'b1),\n\t\t\t.S_AXI_BID(   ign_bid),\n\t\t\t.S_AXI_BRESP( ign_bresp),\n\t\t\t// }}}\n\t\t\t// Read address channel\n\t\t\t// {{{\n\t\t\t.S_AXI_ARVALID(S_AXI_ARVALID),\n\t\t\t.S_AXI_ARREADY(S_AXI_ARREADY),\n\t\t\t.S_AXI_ARID(   S_AXI_ARID),\n\t\t\t.S_AXI_ARADDR( S_AXI_ARADDR),\n\t\t\t.S_AXI_ARLEN(  S_AXI_ARLEN),\n\t\t\t.S_AXI_ARSIZE( S_AXI_ARSIZE),\n\t\t\t.S_AXI_ARBURST(S_AXI_ARBURST),\n\t\t\t.S_AXI_ARLOCK( S_AXI_ARLOCK),\n\t\t\t.S_AXI_ARCACHE(S_AXI_ARCACHE),\n\t\t\t.S_AXI_ARPROT( S_AXI_ARPROT),\n\t\t\t.S_AXI_ARQOS(  S_AXI_ARQOS),\n\t\t\t// }}}\n\t\t\t// Read data channel\n\t\t\t// {{{\n\t\t\t.S_AXI_RVALID(S_AXI_RVALID),\n\t\t\t.S_AXI_RREADY(S_AXI_RREADY),\n\t\t\t.S_AXI_RID(   S_AXI_RID),\n\t\t\t.S_AXI_RDATA( S_AXI_RDATA),\n\t\t\t.S_AXI_RRESP( S_AXI_RRESP),\n\t\t\t.S_AXI_RLAST( S_AXI_RLAST),\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t\t// AXI-lite master interface\n\t\t\t// {{{\n\t\t\t// AXI-lite Write interface\n\t\t\t// {{{\n\t\t\t.M_AXI_AWVALID(ign_awvalid),\n\t\t\t.M_AXI_AWREADY(1'b1),\n\t\t\t.M_AXI_AWADDR(ign_awaddr),\n\t\t\t.M_AXI_AWPROT(ign_awprot),\n\t\t\t//\n\t\t\t.M_AXI_WVALID(ign_wvalid),\n\t\t\t.M_AXI_WREADY(1'b1),\n\t\t\t.M_AXI_WDATA(ign_wdata),\n\t\t\t.M_AXI_WSTRB(ign_wstrb),\n\t\t\t//\n\t\t\t.M_AXI_BVALID(1'b0),\n\t\t\t.M_AXI_BREADY(ign_bready),\n\t\t\t.M_AXI_BRESP(2'b00),\n\t\t\t// }}}\n\t\t\t// AXI-lite read interface\n\t\t\t// {{{\n\t\t\t.M_AXI_ARVALID(M_AXI_ARVALID),\n\t\t\t.M_AXI_ARREADY(M_AXI_ARREADY),\n\t\t\t.M_AXI_ARADDR(M_AXI_ARADDR),\n\t\t\t.M_AXI_ARPROT(M_AXI_ARPROT),\n\t\t\t//\n\t\t\t.M_AXI_RVALID(M_AXI_RVALID),\n\t\t\t.M_AXI_RREADY(M_AXI_RREADY),\n\t\t\t.M_AXI_RDATA(M_AXI_RDATA),\n\t\t\t.M_AXI_RRESP(M_AXI_RRESP)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\t// }}}\n\tend else begin : RDN\n\tif (OPT_READS)\n\tbegin : IMPLEMENT_READS\n\t\t// {{{\n\n\t\t// Declarations\n\t\t// {{{",
            "wire slv_arvalid, slv_arready;",
            "reg [IW-1:0]\t\tslv_arid, mst_arid;",
            "reg [AW-1:0]\t\tslv_araddr, mst_araddr;",
            "wire [AW-1:0]\t\tslv_next_araddr;",
            "reg [7:0]\t\t\tslv_arlen;",
            "reg slv_arlast, mst_arlast,\n\t\t\t\t\t\tmst_arsublast;",
            "reg [2:0]\t\t\tslv_arprot, mst_arprot;",
            "reg [2:0]\t\t\tslv_arsize;",
            "reg [1:0]\t\t\tslv_arburst;",
            "reg [SLVSZ-MSTSZ:0]\t\tslv_arbeats, mst_arbeats;",
            "reg [8:0]\t\t\tslv_rlen;",
            "wire [SLVSZ-MSTSZ-1:0]\trfifo_addr;",
            "wire rfifo_end_of_beat,\n\t\t\t\t\t\trfifo_rlast;",
            "wire [4:0]\t\t\trfifo_count;\n\t\t//",
            "reg m_axi_arvalid;",
            "wire rfifo_full;",
            "wire rfifo_empty;",
            "reg s_axi_rvalid;",
            "reg [1:0]\t\t\ts_axi_rresp;",
            "reg [IW-1:0]\t\ts_axi_rid;",
            "wire [IW-1:0]\t\trfifo_rid;",
            "reg [SLVDW-1:0]\t\ts_axi_rdata, next_rdata;",
            "reg s_axi_rlast;",
            "reg [IW-1:0]\t\trid;",
            "wire read_from_rdfifo;\n\n\t\t//\n\t\t//\n\t\t// S_AXI_AR* skid buffer",
            "wire skids_arvalid, skids_arready;",
            "wire [IW-1:0]\tskids_arid;",
            "wire [AW-1:0]\tskids_araddr;",
            "wire [7:0]\t\tskids_arlen;",
            "wire [2:0]\t\tskids_arsize, skids_arprot;",
            "wire [1:0]\t\tskids_arburst;\n\t\t//\n\t\t// S_AXI_R* skid buffer isn't needed\n\t\t//\n\t\t// M_AXI_AR* skid buffer isn't needed\n\t\t// M_AXI_R* skid buffer",
            "wire skidm_rvalid, skidm_rready;",
            "wire [MSTDW-1:0]\tskidm_rdata;",
            "wire [1:0]\t\tskidm_rresp;\n\t\t// }}}\n\n\t\t// S_AXI_AR* skid buffer\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(IW+AW+8+3+2+3),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_OUTREG(0)\n\t\t\t// }}}\n\t\t) arskid(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t\t.i_valid(S_AXI_ARVALID), .o_ready(S_AXI_ARREADY),\n\t\t\t.i_data({ S_AXI_ARID, S_AXI_ARADDR, S_AXI_ARLEN,\n\t\t\t\tS_AXI_ARSIZE, S_AXI_ARBURST, S_AXI_ARPROT }),\n\t\t\t.o_valid(skids_arvalid), .i_ready(skids_arready),\n\t\t\t.o_data({ skids_arid, skids_araddr, skids_arlen,\n\t\t\t\tskids_arsize, skids_arburst, skids_arprot })\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\t\t// M_AXI_R* skid buffer\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(MSTDW+2),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_OUTREG(0)\n\t\t\t// }}}\n\t\t) rskid(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t\t.i_valid(M_AXI_RVALID), .o_ready(M_AXI_RREADY),\n\t\t\t\t.i_data({ M_AXI_RDATA, M_AXI_RRESP }),\n\t\t\t.o_valid(skidm_rvalid), .i_ready(skidm_rready),\n\t\t\t\t.o_data({ skidm_rdata, skidm_rresp })\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\tassign\tskids_arready = (slv_rlen <= (slv_arready ? 1:0))\n\t\t\t\t\t&&(mst_arbeats <=(M_AXI_ARREADY ? 1:0));\n\n\t\t// slv_*\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tbegin\n\t\t\tif (OPT_LOWPOWER && (slv_rlen <= (slv_arready ? 1:0)))\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\tslv_arid    <= 0;\n\t\t\t\tslv_araddr  <= 0;\n\t\t\t\tslv_arlen   <= 0;\n\t\t\t\tslv_arsize  <= 0;\n\t\t\t\tslv_arburst <= 0;\n\t\t\t\tslv_arprot  <= 0;\n\n\t\t\t\tslv_rlen    <= 0;\n\t\t\t\t// }}}\n\t\t\tend\n\n\t\t\tif (skids_arvalid && skids_arready)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\tslv_arid    <= skids_arid;\n\t\t\t\tslv_araddr  <= skids_araddr;\n\t\t\t\tslv_arlen   <= skids_arlen;\n\t\t\t\tslv_arsize  <= skids_arsize;\n\t\t\t\tslv_arburst <= skids_arburst;\n\t\t\t\tslv_arlast  <= (skids_arlen == 0);\n\t\t\t\tslv_arprot  <= skids_arprot;\n\n\t\t\t\tslv_rlen    <= skids_arlen+1;\n\t\t\t\t// }}}\n\t\t\tend else if (slv_arready && slv_rlen > 0)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\tslv_araddr  <= (!OPT_LOWPOWER || slv_rlen > 1)\n\t\t\t\t\t\t\t? slv_next_araddr : 0;\n\t\t\t\tslv_rlen    <= slv_rlen - 1;\n\t\t\t\tslv_arlast  <= (slv_rlen <= 2);\n\t\t\t\t// }}}\n\t\t\tend\n\n\t\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\tslv_arid    <= 0;\n\t\t\t\tslv_araddr  <= 0;\n\t\t\t\tslv_arlen   <= 0;\n\t\t\t\tslv_arsize  <= 0;\n\t\t\t\tslv_arburst <= 0;\n\t\t\t\tslv_arprot  <= 0;\n\n\t\t\t\tslv_arlast  <= 1;\n\t\t\t\t// }}}\n\t\t\tend\n\n\t\t\tif (!S_AXI_ARESETN)\n\t\t\t\tslv_rlen <= 0;\n\t\tend\n\n\t\tassign\tslv_arvalid = (slv_rlen > 0);\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\tbegin\n\t\t\tassert(slv_arlast == (slv_rlen <= 1));\n\t\t\tassert(slv_rlen <= (slv_arlen + 1));\n\t\tend\n`endif\n\t\t// }}}\n\n\t\t// slv_next_araddr\n\t\t// {{{\n\t\taxi_addr #(\n\t\t\t// {{{\n\t\t\t.AW(AW),\n\t\t\t.DW(SLVDW)\n\t\t\t// }}}\n\t\t) get_next_slave_addr (\n\t\t\t// {{{\n\t\t\t.i_last_addr(slv_araddr),\n\t\t\t.i_size(slv_arsize),\n\t\t\t.i_burst(slv_arburst),\n\t\t\t.i_len(slv_arlen),\n\t\t\t.o_next_addr(slv_next_araddr)\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// slv_arbeats\n\t\t// {{{\n\t\talways @(*)\n\t\tif (slv_rlen > 0)\n\t\tbegin\n\t\t\t// Master beats to turn this slave beat into\n\t\t\tif (slv_arsize >= MSTSZ[2:0])\n\t\t\t\tslv_arbeats = (1<<(slv_arsize-MSTSZ[2:0]))\n\t\t\t\t\t- (slv_araddr[MSTSZ-1:0] >> slv_arsize);\n\t\t\telse\n\t\t\t\tslv_arbeats = 1;\n\t\tend else\n\t\t\tslv_arbeats = 0;\n\t\t// }}}\n\n\t\t// mst_araddr, mst_arprot, mst_arbeats\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tbegin\n\t\t\tif (slv_arready)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\tmst_arid    <= slv_arid;\n\t\t\t\tmst_araddr  <= slv_araddr;\n\t\t\t\tmst_arprot  <= slv_arprot;\n\n\t\t\t\t// Beats to turn this beat into\n\t\t\t\tmst_arbeats <= slv_arbeats;\n\t\t\t\tmst_arlast  <= slv_arlast;\n\t\t\t\tmst_arsublast <= (slv_arbeats <= 1);\n\n\t\t\t\tif (OPT_LOWPOWER && slv_rlen == 0)\n\t\t\t\tbegin\n\t\t\t\t\tmst_arid   <= 0;\n\t\t\t\t\tmst_araddr <= 0;\n\t\t\t\t\tmst_arprot <= 0;\n\t\t\t\tend\n\t\t\t\t// }}}\n\t\t\tend else if ((mst_arbeats > 0)\n\t\t\t\t\t&&(M_AXI_ARVALID && M_AXI_ARREADY))\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\tmst_araddr <= mst_araddr + (1<<MSTSZ);\n\t\t\t\tmst_araddr[MSTSZ-1:0] <= 0;\n\t\t\t\tmst_arbeats <= mst_arbeats - 1;\n\n\t\t\t\tmst_arsublast <= (mst_arbeats <= 2);\n\t\t\t\t// }}}\n\t\t\tend\n\n\t\t\tif (!S_AXI_ARESETN)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\tmst_arbeats <= 0;\n\t\t\t\tif (OPT_LOWPOWER)\n\t\t\t\tbegin\n\t\t\t\t\tmst_arid    <= 0;\n\t\t\t\t\tmst_araddr  <= 0;\n\t\t\t\t\tmst_arprot  <= 0;\n\t\t\t\tend\n\t\t\t\t// }}}\n\t\t\tend\n\t\tend\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif(OPT_LOWPOWER && S_AXI_ARESETN && mst_arbeats == 0)\n\t\tbegin\n\t\t\tassert(mst_arid   == 0);\n\t\t\tassert(mst_araddr == 0);\n\t\t\tassert(mst_arprot == 0);\n\t\tend\n`endif\n\t\t// }}}\n\n\t\t// m_axi_arvalid\n\t\t// {{{\n\t\tinitial\tm_axi_arvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tm_axi_arvalid <= 0;\n\t\telse if (slv_arvalid && slv_arready)\n\t\t\tm_axi_arvalid <= 1;\n\t\telse if (M_AXI_ARVALID && M_AXI_ARREADY)\n\t\t\tm_axi_arvalid <= (mst_arbeats > 1);\n\n\t\tassign\tM_AXI_ARVALID = m_axi_arvalid;\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\t\tassert(M_AXI_ARVALID == (mst_arbeats > 0));\n`endif\n\t\t// }}}\n\n\t\tassign\tslv_arready = (mst_arbeats <= (M_AXI_ARREADY ? 1:0));\n\t\tassign\tread_from_rdfifo = skidm_rvalid && skidm_rready\n\t\t\t\t\t&&(!S_AXI_RVALID || S_AXI_RREADY);\n\n\t\t// Read ID FIFO\n\t\t// {{{\n\t\tsfifo\t#(\n\t\t\t// {{{\n\t\t\t.BW(IW+2+SLVSZ-MSTSZ),\n\t\t\t.LGFLEN(LGFIFO)\n\t\t\t// }}}\n\t\t) ridlnfifo(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t\t//\n\t\t\t.i_wr(M_AXI_ARVALID && M_AXI_ARREADY),\n\t\t\t.i_data({ mst_arid, mst_arlast, mst_arsublast,\n\t\t\t\tM_AXI_ARADDR[SLVSZ-1:MSTSZ] }),\n\t\t\t.o_full(rfifo_full), .o_fill(rfifo_count),\n\t\t\t//\n\t\t\t.i_rd(read_from_rdfifo),\n\t\t\t.o_data({ rfifo_rid, rfifo_rlast, rfifo_end_of_beat,\n\t\t\t\trfifo_addr }),\n\t\t\t.o_empty(rfifo_empty)\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\tassign\tskidm_rready = (!S_AXI_RVALID || S_AXI_RREADY)\n\t\t\t\t&& !rfifo_empty;\n\n\t\t// s_axi_rvalid\n\t\t// {{{\n\t\tinitial\ts_axi_rvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\ts_axi_rvalid <= 0;\n\t\telse if (skidm_rvalid && skidm_rready && rfifo_end_of_beat)\n\t\t\ts_axi_rvalid <= 1'b1;\n\t\telse if (S_AXI_RREADY)\n\t\t\ts_axi_rvalid <= 0;\n\t\t// }}}\n\n\t\t// s_axi_rdata\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tnext_rdata = s_axi_rdata;\n\t\t\tif (S_AXI_RVALID)\n\t\t\t\tnext_rdata = 0;\n\t\t\tif (skidm_rvalid)\n\t\t\t\tnext_rdata = next_rdata | ({ {(SLVDW-MSTDW){1'b0}}, skidm_rdata } << (rfifo_addr * MSTDW));\n\t\tend\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\t\ts_axi_rdata <= 0;\n\t\telse if (!S_AXI_RVALID || S_AXI_RREADY)\n\t\t\ts_axi_rdata <= next_rdata;\n\t\t// }}}\n\n\t\t// s_axi_rresp\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\ts_axi_rresp <= OKAY;\n\t\telse if (!S_AXI_RVALID || S_AXI_RREADY)\n\t\tbegin\n\t\t\tif (S_AXI_RVALID)\n\t\t\t\ts_axi_rresp <= (skidm_rvalid) ? skidm_rresp : OKAY;\n\t\t\telse if (skidm_rvalid)\n\t\t\tcasez({ s_axi_rresp, skidm_rresp[1] })\n\t\t\t// Let SLVERR take priority over DECERR\n\t\t\t3'b??0: s_axi_rresp <= s_axi_rresp;\n\t\t\t3'b0?1: s_axi_rresp <= skidm_rresp;\n\t\t\t3'b101: s_axi_rresp <= SLVERR;\n\t\t\t3'b111: s_axi_rresp <= skidm_rresp;\n\t\t\tendcase\n\t\tend\n\t\t// }}}\n\n\t\t// rid\n\t\t// {{{\n\t\tinitial\trid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (read_from_rdfifo)\n\t\t\trid <= rfifo_rid;\n\t\t// }}}\n\n\t\t// s_axi_rlast\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_RVALID || S_AXI_RREADY)\n\t\tbegin\n\t\t\tif (read_from_rdfifo)\n\t\t\t\ts_axi_rlast <= rfifo_rlast;\n\t\t\telse\n\t\t\t\ts_axi_rlast <= 0;\n\t\tend\n\t\t// }}}\n\n\t\t// s_axi_rid\n\t\t// {{{\n\t\tinitial\ts_axi_rid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif ((S_AXI_RVALID && S_AXI_RREADY && S_AXI_RLAST)\n\t\t\t\t||(!S_AXI_RVALID && rfifo_end_of_beat))\n\t\t\ts_axi_rid <= (read_from_rdfifo && rfifo_end_of_beat)?rfifo_rid : rid;\n\t\t// }}}\n\n\t\t// M_AXI_AR*\n\t\t// {{{\n\t\tassign\tM_AXI_ARVALID= m_axi_arvalid;\n\t\tassign\tM_AXI_ARADDR = mst_araddr;\n\t\tassign\tM_AXI_ARPROT = mst_arprot;\n\t\t// }}}\n\t\t// S_AXI_R*\n\t\t// {{{\n\t\tassign\tS_AXI_RVALID = s_axi_rvalid;\n\t\tassign\tS_AXI_RDATA  = s_axi_rdata;\n\t\tassign\tS_AXI_RRESP  = s_axi_rresp;\n\t\tassign\tS_AXI_RLAST  = s_axi_rlast;\n\t\tassign\tS_AXI_RID    = s_axi_rid;\n\t\t// }}}\n\t\t// Make Verilator happy\n\t\t// {{{\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_read;\n\t\tassign\tunused_read = &{ 1'b0,\n\t\t\t\t/*\n\t\t\t\tS_AXI_AWID, S_AXI_AWVALID,\n\t\t\t\tS_AXI_AWLEN, S_AXI_AWBURST, S_AXI_AWSIZE,\n\t\t\t\tS_AXI_AWADDR,\n\t\t\t\tS_AXI_WVALID, S_AXI_WDATA, S_AXI_WSTRB,\n\t\t\t\tS_AXI_WLAST, S_AXI_BREADY,\n\t\t\t\tM_AXI_AWREADY, M_AXI_WREADY,\n\t\t\t\tM_AXI_BRESP, M_AXI_BVALID,\n\t\t\t\t*/\n\t\t\t\trfifo_count, rfifo_full\n\t\t\t\t};\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\t\t////////////////////////////////////////////////////////////////\n\t\t////////////////////////////////////////////////////////////////\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t// Formal properties, read half\n\t\t// {{{\n\t\t////////////////////////////////////////////////////////////////\n\t\t////////////////////////////////////////////////////////////////\n\t\t////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t\t// As with the write half, the following is a subset of the\n\t\t// formal properties used to verify this section of the core.\n\t\t// It may, or may not, be syntactically correct.  I don't\n\t\t// warrant this version of the design.\n\t\t//\n\t\t// Register declarations\n\t\t// {{{",
            "localparam F_LGDEPTH = LGFIFO+1+8;",
            "wire [F_LGDEPTH-1:0]\t\tfaxi_awr_nbursts;",
            "wire [9-1:0]\t\t\tfaxi_wr_pending;",
            "wire [F_LGDEPTH-1:0]\t\tfaxi_rd_nbursts;",
            "wire [F_LGDEPTH-1:0]\t\tfaxi_rd_outstanding;\n\n\t\t//\n\t\t// ...\n\t\t//",
            "localparam F_AXIL_LGDEPTH = F_LGDEPTH;",
            "wire [F_AXIL_LGDEPTH-1:0]\tfaxil_rd_outstanding,\n\t\t\t\t\t\tfaxil_wr_outstanding,\n\t\t\t\t\t\tfaxil_awr_outstanding;\n\t\t// }}}\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t// AXI channel properties\n\t\t// {{{\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t//\n\t\tfaxi_slave #(\n\t\t\t// {{{\n\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_DATA_WIDTH(SLVDW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t.OPT_EXCLUSIVE(0)\n\t\t\t// ...\n\t\t\t// }}}\n\t\t) faxi(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK),\n\t\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t\t// Write address\n\t\t\t// {{{\n\t\t\t.i_axi_awvalid(1'b0),\n\t\t\t.i_axi_awready(1'b0),\n\t\t\t.i_axi_awid(   skids_arid),\n\t\t\t.i_axi_awaddr( skids_araddr),\n\t\t\t.i_axi_awlen(  8'h0),\n\t\t\t.i_axi_awsize( 3'h0),\n\t\t\t.i_axi_awburst(2'h0),\n\t\t\t.i_axi_awlock( 0),\n\t\t\t.i_axi_awcache(0),\n\t\t\t.i_axi_awprot( 0),\n\t\t\t.i_axi_awqos(  0),\n\t\t\t// }}}\n\t\t\t// Write data\n\t\t\t// {{{\n\t\t\t.i_axi_wvalid( 1'b0),\n\t\t\t.i_axi_wready( 1'b0),\n\t\t\t.i_axi_wdata(  {(C_S_AXI_DATA_WIDTH  ){1'b0}}),\n\t\t\t.i_axi_wstrb(  {(C_S_AXI_DATA_WIDTH/8){1'b0}}),\n\t\t\t.i_axi_wlast(  1'b0),\n\t\t\t// }}}\n\t\t\t// Write return response\n\t\t\t// {{{\n\t\t\t.i_axi_bvalid( 1'b0),\n\t\t\t.i_axi_bready( 1'b0),\n\t\t\t.i_axi_bid(    S_AXI_BID),\n\t\t\t.i_axi_bresp(  2'b00),\n\t\t\t// }}}\n\t\t\t// Read address\n\t\t\t// {{{\n\t\t\t.i_axi_arready(skids_arready),\n\t\t\t.i_axi_arid(   skids_arid),\n\t\t\t.i_axi_araddr( skids_araddr),\n\t\t\t.i_axi_arlen(  skids_arlen),\n\t\t\t.i_axi_arsize( skids_arsize),\n\t\t\t.i_axi_arburst(skids_arburst),\n\t\t\t.i_axi_arlock( 0),\n\t\t\t.i_axi_arcache(0),\n\t\t\t.i_axi_arprot( 0),\n\t\t\t.i_axi_arqos(  0),\n\t\t\t.i_axi_arvalid(skids_arvalid),\n\t\t\t// }}}\n\t\t\t// Read response\n\t\t\t// {{{\n\t\t\t.i_axi_rid(    S_AXI_RID),\n\t\t\t.i_axi_rresp(  S_AXI_RRESP),\n\t\t\t.i_axi_rvalid( S_AXI_RVALID),\n\t\t\t.i_axi_rdata(  S_AXI_RDATA),\n\t\t\t.i_axi_rlast(  S_AXI_RLAST),\n\t\t\t.i_axi_rready( S_AXI_RREADY),\n\t\t\t// }}}\n\t\t\t// Formal property data\n\t\t\t// {{{\n\t\t\t.f_axi_awr_nbursts(   faxi_awr_nbursts),\n\t\t\t.f_axi_wr_pending(    faxi_wr_pending),\n\t\t\t.f_axi_rd_nbursts(    faxi_rd_nbursts),\n\t\t\t.f_axi_rd_outstanding(faxi_rd_outstanding),\n\t\t\t//\n\t\t\t// ...\n\t\t\t//\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tassert(faxi_awr_nbursts == 0);\n\t\t\tassert(faxi_wr_pending == 0);\n\t\t\tassert(faxi_wr_ckvalid == 0);\n\t\tend\n\t\t// }}}\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t// AXI-lite properties\n\t\t// {{{\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t//\n\t\tfaxil_master #(\n\t\t\t// {{{\n\t\t\t.C_AXI_DATA_WIDTH(MSTDW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t.F_OPT_NO_RESET(1),\n\t\t\t.F_AXI_MAXWAIT(5),\n\t\t\t.F_AXI_MAXDELAY(4),\n\t\t\t.F_AXI_MAXRSTALL(0),\n\t\t\t.F_OPT_WRITE_ONLY(1'b0),\n\t\t\t.F_OPT_READ_ONLY(1'b1),\n\t\t\t.F_LGDEPTH(F_AXIL_LGDEPTH)\n\t\t\t// }}}\n\t\t) faxil(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK),\n\t\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t\t// Write address channel\n\t\t\t// {{{\n\t\t\t.i_axi_awvalid(1'b0),\n\t\t\t.i_axi_awready(1'b0),\n\t\t\t.i_axi_awaddr( M_AXI_AWADDR),\n\t\t\t.i_axi_awprot( 3'h0),\n\t\t\t// }}}\n\t\t\t// Write data\n\t\t\t// {{{\n\t\t\t.i_axi_wvalid( 1'b0),\n\t\t\t.i_axi_wready( 1'b0),\n\t\t\t.i_axi_wdata(  {(C_M_AXI_DATA_WIDTH  ){1'b0}}),\n\t\t\t.i_axi_wstrb(  {(C_M_AXI_DATA_WIDTH/8){1'b0}}),\n\t\t\t// }}}\n\t\t\t// Write response\n\t\t\t// {{{\n\t\t\t.i_axi_bvalid( 1'b0),\n\t\t\t.i_axi_bready( 1'b0),\n\t\t\t.i_axi_bresp(  2'b00),\n\t\t\t// }}}\n\t\t\t// Read address\n\t\t\t// {{{\n\t\t\t.i_axi_arvalid(M_AXI_ARVALID),\n\t\t\t.i_axi_arready(M_AXI_ARREADY),\n\t\t\t.i_axi_araddr( M_AXI_ARADDR),\n\t\t\t.i_axi_arprot( M_AXI_ARPROT),\n\t\t\t// }}}\n\t\t\t// Read data return\n\t\t\t// {{{\n\t\t\t.i_axi_rvalid( skidm_rvalid),\n\t\t\t.i_axi_rready( skidm_rready),\n\t\t\t.i_axi_rdata(  skidm_rdata),\n\t\t\t.i_axi_rresp(  skidm_rresp),\n\t\t\t// }}}\n\t\t\t// Formal check variables\n\t\t\t// {{{\n\t\t\t.f_axi_rd_outstanding(faxil_rd_outstanding),\n\t\t\t.f_axi_wr_outstanding(faxil_wr_outstanding),\n\t\t\t.f_axi_awr_outstanding(faxil_awr_outstanding)\n\t\t\t// }}}\n\t\t\t// }}}\n\t\t);\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tassert(faxil_awr_outstanding == 0);\n\t\t\tassert(faxil_wr_outstanding == 0);\n\t\tend\n\t\t// }}}\n`endif\n\t\t// }}}\n\t\t// }}}\n\tend else begin : NO_READ_SUPPORT // if (!OPT_READS)\n\t\t// {{{\n\t\tassign\tM_AXI_ARVALID= 0;\n\t\tassign\tM_AXI_ARADDR = 0;\n\t\tassign\tM_AXI_ARPROT = 0;\n\t\tassign\tM_AXI_RREADY = 0;\n\t\t//\n\t\tassign\tS_AXI_ARREADY= 0;\n\t\tassign\tS_AXI_RVALID = 0;\n\t\tassign\tS_AXI_RDATA  = 0;\n\t\tassign\tS_AXI_RRESP  = 0;\n\t\tassign\tS_AXI_RLAST  = 0;\n\t\tassign\tS_AXI_RID    = 0;\n\n\t\t// Make Verilator happy\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_read;\n\t\tassign\tunused_read = &{ 1'b0, M_AXI_ARREADY, M_AXI_RVALID,\n\t\t\t\tM_AXI_RDATA, M_AXI_RRESP, S_AXI_RREADY,\n\t\t\t\tS_AXI_ARLEN, S_AXI_ARSIZE, S_AXI_ARBURST,\n\t\t\t\tS_AXI_ARADDR, S_AXI_ARVALID, S_AXI_ARID\n\t\t\t\t};\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\tend end endgenerate\n\t// }}}\n\t// Minimal",
            "parameter validation\n\t// {{{\n\tinitial begin\n\t\tif (SLVDW < MSTDW)\n\t\tbegin\n\t\t\t$fatal;\t\t// Fatal elaboration error\n\t\t\t$stop;\t\t// Stop any simulation\n\t\tend\n\tend\n\t// }}}\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0,\n\t\tS_AXI_AWLOCK, S_AXI_AWCACHE, S_AXI_AWPROT, S_AXI_AWQOS,\n\t\t// skids_wlast, wfifo_count, rfifo_count\n\t\tS_AXI_ARLOCK, S_AXI_ARCACHE, S_AXI_ARPROT, S_AXI_ARQOS\n\t\t};\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assume that the two write channels stay within an appropriate\n\t// distance of each other.  This is to make certain that the property\n\t// file features are not violated, although not necessary true for\n\t// actual operation\n\t//\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Select only write or only read operation\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (!OPT_WRITES)\n\tbegin\n\t\talways @(*)\n\t\tbegin\n\t\t\tassume(!S_AXI_AWVALID);\n\t\t\tassume(!S_AXI_WVALID);\n\t\t\tassert(!M_AXI_AWVALID);\n\t\t\tassert(!M_AXI_WVALID);\n\t\t\tassume(!M_AXI_BVALID);\n\t\t\tassert(!S_AXI_BVALID);\n\t\tend\n\tend endgenerate\n\n\tgenerate if (!OPT_READS)\n\tbegin\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tassume(!S_AXI_ARVALID);\n\t\t\tassert(!M_AXI_ARVALID);\n\t\tend\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Lowpower assertions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_LOWPOWER)\n\tbegin : F_LOWPOWER\n\n\t\talways @(*)\n\t\tif (S_AXI_ARESETN)\n\t\tbegin\n\t\t\tif (!M_AXI_AWVALID)\n\t\t\tbegin\n\t\t\t\t// Not supported.\n\t\t\t\t// assert(M_AXI_AWADDR == 0);\n\t\t\t\t// assert(M_AXI_AWPROT == 0);\n\t\t\tend\n\n\t\t\tif (!M_AXI_WVALID)\n\t\t\tbegin\n\t\t\t\t// assert(M_AXI_WDATA == 0);\n\t\t\t\t// assert(M_AXI_WSTRB == 0);\n\t\t\tend\n\n\t\t\tif (!M_AXI_ARVALID)\n\t\t\tbegin\n\t\t\t\tassert(M_AXI_ARADDR == 0);\n\t\t\t\tassert(M_AXI_ARPROT == 0);\n\t\t\tend\n\n\t\t\tif (!S_AXI_RVALID)\n\t\t\tbegin\n\t\t\t\t// These items build over the course of a\n\t\t\t\t// returned burst, so they might not be\n\t\t\t\t// zero when RVALID is zero.\n\t\t\t\t//\n\t\t\t\t// assert(S_AXI_RLAST == 0);\n\t\t\t\t// assert(S_AXI_RDATA == 0);\n\t\t\t\t// assert(S_AXI_RID == 0);\n\t\t\tend\n\t\tend\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover statements, to show performance\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (OPT_READS)\n\tbegin\n\t\t// {{{",
            "reg [3:0]\tcvr_read_count, cvr_read_count_simple;\n\n\t\tinitial\tcvr_read_count_simple = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tcvr_read_count_simple <= 0;\n\t\telse if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN == 0)\n\t\t\tcvr_read_count_simple <= cvr_read_count_simple + 1;\n\n\t\tinitial\tcvr_read_count = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tcvr_read_count <= 0;\n\t\telse if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN > 2)\n\t\t\tcvr_read_count <= cvr_read_count + 1;\n\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// \"Careless\" assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\n\t// }}}\n`undef\tBMC_ASSERT\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "wbscope.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/wbscope.v",
        "chunks": [
            "logic analyzer.\n//\tThe general operation is such that this 'scope' can record and report\n//\ton any 32 bit value transiting through the FPGA.  Once started and\n//\treset, the scope records a copy of the",
            "input data every time the clock\n//\tticks with the circuit enabled.  That is, it records these values up\n//\tuntil the trigger.  Once the trigger goes high, the scope will record\n//\tfor br_holdoff more counts before stopping.  Values may then be read\n//\tfrom the buffer, oldest to most recent.  After reading, the scope may\n//\tthen be reset for another run.\n//\n//\tIn general, therefore, operation happens in this fashion:\n//\t\t1. A reset is issued.\n//\t\t2. Recording starts, in a circular buffer, and continues until\n//\t\t3. The trigger line is asserted.\n//\t\t\tThe scope",
            "reg isters the asserted trigger by setting\n//\t\t\tthe 'o_triggered'",
            "output flag.\n//\t\t4. A counter then ticks until the last value is written\n//\t\t\tThe scope",
            "reg isters that it has stopped recording by\n//\t\t\tsetting the 'o_stopped'",
            "output flag.\n//\t\t5. The scope recording is then paused until the next reset.\n//\t\t6. While stopped, the CPU can read the data from the scope\n//\t\t7. -- oldest to most recent\n//\t\t8. -- one value per i_rd&i_data_clk\n//\t\t9. Writes to the data",
            "reg ister reset the address to the\n//\t\t\tbeginning of the buffer\n//\n//\tAlthough the data width DW is",
            "parameter ized, it is not very changable,\n//\tsince the width is tied to the width of the data bus, as is the\n//\tcontrol word.  Therefore changing the data width would require changing\n//\tthe interface.  It's doable, but it would be a change to the interface.\n//\n//\tThe SYNCHRONOUS",
            "parameter turns on and off meta-stability\n//\tsynchronization.  Ideally a wishbone scope able to handle one or two\n//\tclocks would have a changing number of ports as this SYNCHRONOUS\n//",
            "parameter changed.  Other than running another script to modify\n//\tthis, I don't know how to do that so ... we'll just leave it running\n//\toff of two clocks or not.\n//\n//\n//\tInternal to this routine,",
            "reg isters and",
            "wire s are named with one of the\n//\tfollowing prefixes:\n//\n//\ti_\tAn",
            "input port to the routine\n//\to_\tAn",
            "output port of the routine\n//\tbr_\tA",
            "reg ister, controlled by the bus clock\n//\tdr_\tA",
            "reg ister, controlled by the data clock\n//\tbw_\tA",
            "wire /net, controlled by the bus clock\n//\tdw_\tA",
            "wire /net, controlled by the data clock\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module wbscope #(\n\t\t// {{{",
            "parameter [4:0]\t\t\tLGMEM = 5'd10,",
            "parameter BUSW = 32,",
            "parameter [0:0]\t\t\tSYNCHRONOUS=1,",
            "parameter HOLDOFFBITS = 20,",
            "parameter [(HOLDOFFBITS-1):0]\tDEFAULT_HOLDOFF = ((1<<(LGMEM-1))-4)\n\t\t// }}}\n\t) (\n\t\t// {{{\n\t\t// The",
            "input signals that we wish to record",
            "input ",
            "wire i_data_clk, i_ce, i_trigger,",
            "input ",
            "wire [(BUSW-1):0]\ti_data,\n\t\t// The WISHBONE bus for reading and configuring this scope\n\t\t// {{{",
            "input ",
            "wire i_wb_clk, i_wb_cyc,\n\t\t\t\t\t\ti_wb_stb, i_wb_we,",
            "input ",
            "wire i_wb_addr, // One address line only",
            "input ",
            "wire [(BUSW-1):0]\ti_wb_data,",
            "input ",
            "wire [(BUSW/8-1):0]\ti_wb_sel,",
            "output ",
            "wire o_wb_stall, o_wb_ack,",
            "output ",
            "wire [(BUSW-1):0]\to_wb_data,\n\t\t// }}}\n\t\t// And, finally, for a final flair --- offer to interrupt the\n\t\t// CPU after our trigger has gone off.  This line is equivalent\n\t\t// to the scope  being stopped.  It is not maskable here.",
            "output ",
            "wire o_interrupt\n\t\t// }}}\n\t);\n\n\t// Signal declarations\n\t// {{{",
            "wire bus_clock;",
            "wire read_from_data;",
            "wire write_stb;",
            "wire write_to_control;",
            "reg read_address;",
            "wire [31:0]\t\ti_bus_data;",
            "reg [(LGMEM-1):0]\traddr;",
            "reg [(BUSW-1):0]\tmem[0:((1<<LGMEM)-1)];",
            "wire bw_reset_request, bw_manual_trigger,\n\t\t\tbw_disable_trigger, bw_reset_complete;",
            "reg [2:0]\tbr_config;",
            "reg [(HOLDOFFBITS-1):0]\tbr_holdoff;",
            "wire dw_reset, dw_manual_trigger, dw_disable_trigger;",
            "reg dr_triggered, dr_primed;",
            "wire dw_trigger;\n\t(* ASYNC_REG=\"TRUE\" *)",
            "reg [(HOLDOFFBITS-1):0]\tcounter;",
            "reg dr_stopped;",
            "reg [(LGMEM-1):0]\twaddr;",
            "localparam STOPDELAY = 1;\t// Calibrated value--don't change this",
            "wire [(BUSW-1):0]\t\twr_piped_data;",
            "wire bw_stopped, bw_triggered, bw_primed;",
            "reg br_wb_ack, br_pre_wb_ack;",
            "wire bw_cyc_stb;",
            "reg [(LGMEM-1):0]\tthis_addr;",
            "reg [31:0]\t\tnxt_mem;",
            "wire [19:0]\t\tfull_holdoff;",
            "reg [31:0]\t\to_bus_data;",
            "wire [4:0]\t\tbw_lgmem;",
            "reg br_level_interrupt;\n\t// }}}\n\n\tassign\tbus_clock = i_wb_clk;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Decode and handle the bus signaling in a (somewhat) portable manner\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t///////////////////////////////////////////////////\n\t//\n\t//\n\n\tassign\ti_bus_data = i_wb_data;\n\tassign\to_wb_stall = 1'b0;\n\tassign\tread_from_data = i_wb_stb && !i_wb_we && i_wb_addr && (&i_wb_sel);\n\tassign\twrite_stb = (i_wb_stb)&&(i_wb_we);\n\tassign\twrite_to_control = write_stb && !i_wb_addr && (&i_wb_sel);\n\n\talways @(posedge bus_clock)\n\t\tread_address <= i_wb_addr;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Our status/config",
            "reg ister\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Now that we've finished reading/writing from the\n\t// bus, ... or at least acknowledging reads and\n\t// writes from and to the bus--even if they haven't\n\t// happened yet, now we implement our actual scope.\n\t// This includes implementing the actual reads/writes\n\t// from/to the bus.\n\t//\n\t// From here on down, is the heart of the scope itself.\n\t//\n\n\t// Our status/config",
            "reg ister\n\tinitial\tbr_config = 3'b0;\n\tinitial\tbr_holdoff = DEFAULT_HOLDOFF;\n\talways @(posedge bus_clock)\n\tbegin\n\t\tif (write_to_control)\n\t\tbegin\n\t\t\tbr_config[1:0] <= {\n\t\t\t\ti_bus_data[27],\n\t\t\t\ti_bus_data[26] };\n\t\t\tif (!i_bus_data[31] && br_config[2])\n\t\t\t\tbr_holdoff <= i_bus_data[(HOLDOFFBITS-1):0];\n\t\tend\n\n\t\t//\n\t\t// Reset",
            "logic if (bw_reset_complete)\n\t\t\t// Clear the reset request,",
            "reg ardless of the write\n\t\t\tbr_config[2] <= 1'b1;\n\t\telse if (!br_config[2])\n\t\t\t// Reset request is already pending--don't change it\n\t\t\tbr_config[2] <= 1'b0;\n\t\telse if (write_to_control && !i_bus_data[31])\n\t\t\t// Initiate a new reset request\n\t\t\t//   Note that we won't initiate a new reset request\n\t\t\t//   while one is already pending.  Once the pending\n\t\t\t//   one completes we'll be in the reset state anyway\n\t\t\tbr_config[2] <= 1'b0;\n\n\t\t// if (i_reset)\n\t\t//\tbr_config[2] <= 1'b0;\n\tend\n\tassign\tbw_reset_request   = (!br_config[2]);\n\tassign\tbw_manual_trigger  = (br_config[1]);\n\tassign\tbw_disable_trigger = (br_config[0]);\n\n\tgenerate\n\tif (SYNCHRONOUS > 0)\n\tbegin : GEN_SYNCHRONOUS\n\t\tassign\tdw_reset = bw_reset_request;\n\t\tassign\tdw_manual_trigger = bw_manual_trigger;\n\t\tassign\tdw_disable_trigger = bw_disable_trigger;\n\t\tassign\tbw_reset_complete = bw_reset_request;\n\tend else begin : GEN_ASYNC",
            "reg r_reset_complete;\n\t\t(* ASYNC_REG = \"TRUE\" *)",
            "reg [2:0]\tq_iflags;",
            "reg [2:0]\tr_iflags;\n\n\t\t// Resets are synchronous to the bus clock, not the data clock\n\t\t// so do a clock transfer here\n\t\tinitial\t{ q_iflags, r_iflags } = 6'h0;\n\t\tinitial\tr_reset_complete = 1'b0;\n\t\talways @(posedge i_data_clk)\n\t\tbegin\n\t\t\tq_iflags <= { bw_reset_request, bw_manual_trigger, bw_disable_trigger };\n\t\t\tr_iflags <= q_iflags;\n\t\t\tr_reset_complete <= (dw_reset);\n\t\tend\n\n\t\tassign\tdw_reset = r_iflags[2];\n\t\tassign\tdw_manual_trigger = r_iflags[1];\n\t\tassign\tdw_disable_trigger = r_iflags[0];\n\n\t\t(* ASYNC_REG = \"TRUE\" *)",
            "reg q_reset_complete,\n\t\t\t\t\t\tqq_reset_complete;\n\t\t// Pass an acknowledgement back from the data clock to the bus\n\t\t// clock that the reset has been accomplished\n\t\tinitial\tq_reset_complete = 1'b0;\n\t\tinitial\tqq_reset_complete = 1'b0;\n\t\talways @(posedge bus_clock)\n\t\tbegin\n\t\t\tq_reset_complete  <= r_reset_complete;\n\t\t\tqq_reset_complete <= q_reset_complete;\n\t\tend\n\n\t\tassign bw_reset_complete = qq_reset_complete;\n\n`ifdef\tFORMAL\n\t\talways @(posedge gbl_clk)\n\t\tif (f_past_valid_data)\n\t\tbegin\n\t\t\tif ($rose(r_reset_complete))\n\t\t\t\tassert(bw_reset_request);\n\t\tend\n\n\t\talways @(*)\n\t\tcase({ bw_reset_request, q_iflags[2], dw_reset, q_reset_complete, qq_reset_complete })\n\t\t5'h00: begin end\n\t\t5'h10: begin end\n\t\t5'h18: begin end\n\t\t5'h1c: begin end\n\t\t5'h1e: begin end\n\t\t5'h1f: begin end\n\t\t5'h0f: begin end\n\t\t5'h07: begin end\n\t\t5'h03: begin end\n\t\t5'h01: begin end\n\t\tdefault: assert(0);\n\t\tendcase\n`endif\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Set up the trigger\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// dw_trigger -- trigger",
            "wire , defined on the data clock\n\t// {{{\n\t// Write with the i_clk, or",
            "input clock.  All",
            "output s read with the\n\t// bus clock, or i_wb_clk as we've called it here.\n\tassign\tdw_trigger = (dr_primed)&&(\n\t\t\t\t((i_trigger)&&(!dw_disable_trigger))\n\t\t\t\t||(dw_manual_trigger));\n\t// }}}\n\n\t// dr_triggered\n\t// {{{\n\tinitial\tdr_triggered = 1'b0;\n\talways @(posedge i_data_clk)\n\tif (dw_reset)\n\t\tdr_triggered <= 1'b0;\n\telse if ((i_ce)&&(dw_trigger))\n\t\tdr_triggered <= 1'b1;\n\t// }}}\n\n\t//\n\t// Determine when memory is full and capture is complete\n\t//\n\t// Writes take place on the data clock\n\n\t// counter\n\t// {{{\n\t// The counter is unsigned\n\tinitial\tcounter = 0;\n\talways @(posedge i_data_clk)\n\tif (dw_reset)\n\t\tcounter <= 0;\n\telse if ((i_ce)&&(dr_triggered)&&(!dr_stopped))\n\t\tcounter <= counter + 1'b1;\n`ifdef\tFORMAL\n\talways @(*)\n\tif (!dw_reset && !bw_reset_request)\n\t\tassert(counter <= br_holdoff+1'b1);\n\talways @(posedge i_data_clk)\n\t\tassume(!(&br_holdoff));\n\talways @(posedge i_data_clk)\n\tif (!dr_triggered)\n\t\tassert(counter == 0);\n`endif\n\t// }}}\n\n\t// dr_stopped\n\t// {{{\n\tinitial\tdr_stopped = 1'b0;\n\talways @(posedge i_data_clk)\n\tif ((!dr_triggered)||(dw_reset))\n\t\tdr_stopped <= 1'b0;\n\telse if (!dr_stopped)\n\tbegin\n\t\tif (HOLDOFFBITS > 1) // if (i_ce)\n\t\t\tdr_stopped <= (counter >= br_holdoff);\n\t\telse if (HOLDOFFBITS <= 1)\n\t\t\tdr_stopped <= ((i_ce)&&(dw_trigger));\n\tend\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Write to memory\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\n\t//\n\t//\tActually do our writes to memory.  Record, via 'primed' when\n\t//\tthe memory is full.\n\t//\n\t//\tThe 'waddr' address that we are using really crosses two clock\n\t//\tdomains.  While writing and changing, it's in the data clock\n\t//\tdomain.  Once stopped, it becomes part of the bus clock domain.\n\t//\tThe clock transfer on the stopped line handles the clock\n\t//\ttransfer for these signals.\n\t//\n\n\t// waddr, dr_primed\n\t// {{{\n\tinitial\twaddr = {(LGMEM){1'b0}};\n\tinitial\tdr_primed = 1'b0;\n\talways @(posedge i_data_clk)\n\tif (dw_reset) // For simulation purposes, supply a valid value\n\tbegin\n\t\twaddr <= 0; // upon reset.\n\t\tdr_primed <= 1'b0;\n\tend else if (i_ce && !dr_stopped)\n\tbegin\n\t\t// mem[waddr] <= i_data;\n\t\twaddr <= waddr + {{(LGMEM-1){1'b0}},1'b1};\n\t\tif (!dr_primed)\n\t\t\tdr_primed <= (&waddr);\n\tend\n\t// }}}\n\n\t// wr_piped_data -- delay data to match the trigger\n\t// {{{\n\t// Delay the incoming data so that we can get our trigger\n\t//",
            "logic to line up with the data.  The goal is to have a\n\t// hold off of zero place the trigger in the last memory\n\t// address.\n\tgenerate\n\tif (STOPDELAY == 0)\n\tbegin : NO_STOPDLY\n\t\t// No delay ... just assign the",
            "wire s to our",
            "input lines\n\t\tassign\twr_piped_data = i_data;\n\tend else if (STOPDELAY == 1)\n\tbegin : GEN_ONE_STOPDLY\n\t\t//\n\t\t// Delay by one means just",
            "reg ister this once",
            "reg [(BUSW-1):0]\tdata_pipe;\n\t\talways @(posedge i_data_clk)\n\t\tif (i_ce)\n\t\t\tdata_pipe <= i_data;\n\n\t\tassign\twr_piped_data = data_pipe;\n\tend else begin : GEN_STOPDELAY\n\t\t// Arbitrary delay ... use a longer pipe",
            "reg [(STOPDELAY*BUSW-1):0]\tdata_pipe;\n\n\t\talways @(posedge i_data_clk)\n\t\tif (i_ce)\n\t\t\tdata_pipe <= { data_pipe[((STOPDELAY-1)*BUSW-1):0], i_data };\n\t\tassign\twr_piped_data = { data_pipe[(STOPDELAY*BUSW-1):((STOPDELAY-1)*BUSW)] };\n\tend endgenerate\n\t// }}}\n\n\t// mem[] <= wr_piped_data\n\t// {{{\n\talways @(posedge i_data_clk)\n\tif ((i_ce)&&(!dr_stopped))\n\t\tmem[waddr] <= wr_piped_data;\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Move the status signals back to the bus clock\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\tgenerate if (SYNCHRONOUS > 0)\n\tbegin : SYNCHRONOUS_RETURN\n\t\tassign\tbw_stopped   = dr_stopped;\n\t\tassign\tbw_triggered = dr_triggered;\n\t\tassign\tbw_primed    = dr_primed;\n\tend else begin : ASYNC_STATUS\n\t\t// {{{\n\t\t// These aren't a problem, since none of these are strobe\n\t\t// signals.  They goes from low to high, and then stays high\n\t\t// for many clocks.  Swapping is thus easy--two flip flops to\n\t\t// protect against meta-stability and we're done.\n\t\t//\n\t\t(* ASYNC_REG = \"TRUE\" *)",
            "reg [2:0]\tq_oflags;",
            "reg [2:0]\tr_oflags;\n\t\tinitial\tq_oflags = 3'h0;\n\t\tinitial\tr_oflags = 3'h0;\n\t\talways @(posedge bus_clock)\n\t\tif (bw_reset_request)\n\t\tbegin\n\t\t\tq_oflags <= 3'h0;\n\t\t\tr_oflags <= 3'h0;\n\t\tend else begin\n\t\t\tq_oflags <= { dr_stopped, dr_triggered, dr_primed };\n\t\t\tr_oflags <= q_oflags;\n\t\tend\n\n\t\tassign\tbw_stopped   = r_oflags[2];\n\t\tassign\tbw_triggered = r_oflags[1];\n\t\tassign\tbw_primed    = r_oflags[0];\n\t\t// }}}\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (!bw_reset_request)\n\t\tbegin\n\t\t\tif (bw_primed)\n\t\t\t\tassert(q_oflags[0] && dr_primed);\n\t\t\telse if (q_oflags[0])\n\t\t\t\tassert(dr_primed);\n\n\t\t\tif (bw_triggered)\n\t\t\t\tassert(q_oflags[1] && dr_triggered);\n\t\t\telse if (q_oflags[1])\n\t\t\t\tassert(dr_triggered);\n\n\t\t\tif (bw_stopped)\n\t\t\t\tassert(q_oflags[2] && dr_stopped);\n\t\t\telse if (q_oflags[2])\n\t\t\t\tassert(dr_stopped);\n\t\tend\n\t\t\n`endif\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read from the memory, using the bus clock.  Otherwise respond to bus\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Reads use the bus clock\n\tassign\tbw_cyc_stb = (i_wb_stb);\n\n\tinitial\tbr_pre_wb_ack = 1'b0;\n\tinitial\tbr_wb_ack = 1'b0;\n\talways @(posedge bus_clock)\n\tbegin\n\t\tif ((bw_reset_request)||(write_to_control))\n\t\t\traddr <= 0;\n\t\telse if ((read_from_data)&&(bw_stopped))\n\t\t\traddr <= raddr + 1'b1; // Data read, when stopped\n\n\t\tbr_pre_wb_ack <= bw_cyc_stb;\n\t\tbr_wb_ack <= (br_pre_wb_ack)&&(i_wb_cyc);\n\tend\n\n\tassign\to_wb_ack = (i_wb_cyc)&&(br_wb_ack);\n\n\talways @(posedge bus_clock)\n\tif (read_from_data)\n\t\tthis_addr <= raddr + waddr + 1'b1;\n\telse\n\t\tthis_addr <= raddr + waddr;\n\n\talways @(posedge bus_clock)\n\t\tnxt_mem <= mem[this_addr];\n\n\t// holdoff sub-",
            "reg ister\n\t// {{{\n\tassign full_holdoff[(HOLDOFFBITS-1):0] = br_holdoff;\n\tgenerate if (HOLDOFFBITS < 20)\n\tbegin : GEN_FULL_HOLDOFF\n\t\tassign full_holdoff[19:(HOLDOFFBITS)] = 0;\n\tend endgenerate\n\t// }}}\n\n\tassign\t\tbw_lgmem = LGMEM;\n\n\t// Bus read\n\t// {{{\n\talways @(posedge bus_clock)\n\tbegin\n\t\tif (!read_address) // Control",
            "reg ister read\n\t\t\to_bus_data <= { bw_reset_request,\n\t\t\t\t\tbw_stopped,\n\t\t\t\t\tbw_triggered,\n\t\t\t\t\tbw_primed,\n\t\t\t\t\tbw_manual_trigger,\n\t\t\t\t\tbw_disable_trigger,\n\t\t\t\t\t(raddr == {(LGMEM){1'b0}}),\n\t\t\t\t\tbw_lgmem,\n\t\t\t\t\tfull_holdoff  };\n\t\telse if (!bw_stopped) // read, prior to stopping\n\t\t\t//\n\t\t\t// *WARNING*: THIS READ IS NOT PROTECTED FROM\n\t\t\t// ASYNCHRONOUS COHERENCE ISSUES!\n\t\t\t//\n\t\t\to_bus_data <= i_data;\n\t\telse // if (i_wb_addr) // Read from FIFO memory\n\t\t\to_bus_data <= nxt_mem; // mem[raddr+waddr];\n\tend\n\t// }}}\n\n\tassign\to_wb_data = o_bus_data;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Interrupt generation\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tinitial\tbr_level_interrupt = 1'b0;\n\talways @(posedge bus_clock)\n\tif ((bw_reset_complete)||(bw_reset_request))\n\t\tbr_level_interrupt<= 1'b0;\n\telse\n\t\tbr_level_interrupt<= (bw_stopped)&&(!bw_disable_trigger);\n\n\tassign\to_interrupt = (bw_stopped)&&(!bw_disable_trigger)\n\t\t\t\t\t&&(!br_level_interrupt);\n\t// }}}\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator lint_off UNUSED",
            "wire unused;\n\tassign unused = &{ 1'b0, i_bus_data[30:28], i_bus_data[25:0],\n\t\t\ti_wb_sel };\n\t// verilator lint_on UNUSED\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "iscachable.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/iscachable.v",
        "chunks": [
            "module must be built of entirely combinatorial",
            "logic and nothing more.\n//\n//\tThis particular version is taylored to the test bench configuration\n//\tof the ZipCPU.\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2018-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module iscachable #(\n\t\t// {{{",
            "parameter ADDRESS_WIDTH=28,",
            "localparam AW = ADDRESS_WIDTH, // Just for ease of notation below",
            "parameter [AW-1:0] \tMEM_ADDR  = {4'b0100, {(ADDRESS_WIDTH-4){1'b0}} },",
            "parameter [AW-1:0] \tMEM_MASK  = {4'b1111, {(ADDRESS_WIDTH-4){1'b0}} }\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire [AW-1:0]\ti_addr,",
            "output ",
            "reg o_cachable\n\t\t// }}}\n\t);\n\n\n\talways @(*)\n\tbegin\n\t\to_cachable = 1'b0;\n\t\tif ((MEM_ADDR !=0)&&((i_addr & MEM_MASK)== MEM_ADDR))\n\t\t\to_cachable = 1'b1;\n\tend",
            "endmodule "
        ]
    },
    {
        "file_name": "axilcon.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axilcon.v",
        "chunks": [
            "module axilcon #(\n\t\t// {{{\n\t\t// Size of the AXI-lite bus.  These are fixed, since 1) AXI-lite\n\t\t// is fixed at a width of 32-bits by Xilinx def'n, and 2) since\n\t\t// we only ever have 4 configuration words.",
            "parameter C_AXI_ADDR_WIDTH = 4,",
            "localparam C_AXI_DATA_WIDTH = 32,",
            "parameter [0:0]\tOPT_SKIDBUFFER = 1'b0,",
            "parameter [0:0]\tOPT_LOWPOWER = 0,",
            "localparam ADDRLSB = $clog2(C_AXI_DATA_WIDTH)-3,",
            "parameter CONSOLE_FILE = 0\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,\n\t\t//",
            "input ",
            "wire S_AXI_AWVALID,",
            "output ",
            "wire S_AXI_AWREADY,",
            "input ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\t\tS_AXI_AWADDR,\n\t\t// verilator coverage_off",
            "input ",
            "wire [2:0]\t\t\t\tS_AXI_AWPROT,\n\t\t// verilator coverage_on\n\t\t//",
            "input ",
            "wire S_AXI_WVALID,",
            "output ",
            "wire S_AXI_WREADY,",
            "input ",
            "wire [C_AXI_DATA_WIDTH-1:0]\t\tS_AXI_WDATA,",
            "input ",
            "wire [C_AXI_DATA_WIDTH/8-1:0]\tS_AXI_WSTRB,\n\t\t//",
            "output ",
            "wire S_AXI_BVALID,",
            "input ",
            "wire S_AXI_BREADY,\n\t\t// verilator coverage_off",
            "output ",
            "wire [1:0]\t\t\t\tS_AXI_BRESP,\n\t\t// verilator coverage_on\n\t\t//",
            "input ",
            "wire S_AXI_ARVALID,",
            "output ",
            "wire S_AXI_ARREADY,",
            "input ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\t\tS_AXI_ARADDR,",
            "input ",
            "wire [2:0]\t\t\t\tS_AXI_ARPROT,\n\t\t//",
            "output ",
            "wire S_AXI_RVALID,",
            "input ",
            "wire S_AXI_RREADY,\n\t\t// verilator coverage_off",
            "output ",
            "wire [C_AXI_DATA_WIDTH-1:0]\t\tS_AXI_RDATA,",
            "output ",
            "wire [1:0]\t\t\t\tS_AXI_RRESP\n\t\t// verilator coverage_on\n\t\t// }}}\n\t);\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Register/",
            "wire signal declarations\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tinteger\t\t\t\tsim_console;",
            "wire i_reset = !S_AXI_ARESETN;",
            "wire axil_write_ready;",
            "wire [C_AXI_ADDR_WIDTH-ADDRLSB-1:0]\tawskd_addr;\n\t//",
            "wire [C_AXI_DATA_WIDTH-1:0]\twskd_data;",
            "wire [C_AXI_DATA_WIDTH/8-1:0]\twskd_strb;",
            "reg axil_bvalid;\n\t//",
            "wire axil_read_ready;",
            "wire [C_AXI_ADDR_WIDTH-ADDRLSB-1:0]\tarskd_addr;",
            "reg [C_AXI_DATA_WIDTH-1:0]\taxil_read_data;",
            "reg axil_read_valid;\n\t//\n\t//",
            "wire [31:0]\taxil_rx_data;",
            "wire [31:0]\taxil_tx_data;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI-lite signaling\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Write signaling\n\t//\n\t// {{{\n\n\tgenerate if (OPT_SKIDBUFFER)\n\tbegin : SKIDBUFFER_WRITE",
            "wire awskd_valid, wskd_valid;\n\n\t\tskidbuffer #(.OPT_OUTREG(0),\n\t\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t\t.DW(C_AXI_ADDR_WIDTH-ADDRLSB))\n\t\taxilawskid(//\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(i_reset),\n\t\t\t.i_valid(S_AXI_AWVALID), .o_ready(S_AXI_AWREADY),\n\t\t\t.i_data(S_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB]),\n\t\t\t.o_valid(awskd_valid), .i_ready(axil_write_ready),\n\t\t\t.o_data(awskd_addr));\n\n\t\tskidbuffer #(.OPT_OUTREG(0),\n\t\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t\t.DW(C_AXI_DATA_WIDTH+C_AXI_DATA_WIDTH/8))\n\t\taxilwskid(//\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(i_reset),\n\t\t\t.i_valid(S_AXI_WVALID), .o_ready(S_AXI_WREADY),\n\t\t\t.i_data({ S_AXI_WDATA, S_AXI_WSTRB }),\n\t\t\t.o_valid(wskd_valid), .i_ready(axil_write_ready),\n\t\t\t.o_data({ wskd_data, wskd_strb }));\n\n\t\tassign\taxil_write_ready = awskd_valid && wskd_valid\n\t\t\t\t&& (!S_AXI_BVALID || S_AXI_BREADY);\n\n\tend else begin : SIMPLE_WRITES",
            "reg axil_awready;\n\n\t\tinitial\taxil_awready = 1'b0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\taxil_awready <= 1'b0;\n\t\telse\n\t\t\taxil_awready <= !axil_awready\n\t\t\t\t&& (S_AXI_AWVALID && S_AXI_WVALID)\n\t\t\t\t&& (!S_AXI_BVALID || S_AXI_BREADY);\n\n\t\tassign\tS_AXI_AWREADY = axil_awready;\n\t\tassign\tS_AXI_WREADY  = axil_awready;\n\n\t\tassign \tawskd_addr = S_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB];\n\t\tassign\twskd_data  = S_AXI_WDATA;\n\t\tassign\twskd_strb  = S_AXI_WSTRB;\n\n\t\tassign\taxil_write_ready = axil_awready;\n\n\tend endgenerate\n\n\tinitial\taxil_bvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_reset)\n\t\taxil_bvalid <= 0;\n\telse if (axil_write_ready)\n\t\taxil_bvalid <= 1;\n\telse if (S_AXI_BREADY)\n\t\taxil_bvalid <= 0;\n\n\tassign\tS_AXI_BVALID = axil_bvalid;\n\tassign\tS_AXI_BRESP = 2'b00;\n\t// }}}\n\n\t//\n\t// Read signaling\n\t//\n\t// {{{\n\tgenerate if (OPT_SKIDBUFFER)\n\tbegin : SKIDBUFFER_READ",
            "wire arskd_valid;\n\n\t\tskidbuffer #(.OPT_OUTREG(0),\n\t\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t\t.DW(C_AXI_ADDR_WIDTH-ADDRLSB))\n\t\taxilarskid(//\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(i_reset),\n\t\t\t.i_valid(S_AXI_ARVALID), .o_ready(S_AXI_ARREADY),\n\t\t\t.i_data(S_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB]),\n\t\t\t.o_valid(arskd_valid), .i_ready(axil_read_ready),\n\t\t\t.o_data(arskd_addr));\n\n\t\t// High bandwidth reads\n\t\tassign\taxil_read_ready = arskd_valid\n\t\t\t\t&& (!axil_read_valid || S_AXI_RREADY);\n\n\tend else begin : SIMPLE_READS",
            "reg axil_arready;\n\n\t\tinitial\taxil_arready = 1;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\taxil_arready <= 1;\n\t\telse if (S_AXI_ARVALID && S_AXI_ARREADY)\n\t\t\taxil_arready <= 0;\n\t\telse if (S_AXI_RVALID && S_AXI_RREADY)\n\t\t\taxil_arready <= 1;\n\n\t\tassign\tarskd_addr = S_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB];\n\t\tassign\tS_AXI_ARREADY = axil_arready;\n\t\tassign\taxil_read_ready = (S_AXI_ARVALID && S_AXI_ARREADY);\n\n\tend endgenerate\n\n\tinitial\taxil_read_valid = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_reset)\n\t\taxil_read_valid <= 1'b0;\n\telse if (!S_AXI_RVALID || S_AXI_RREADY)\n\t\taxil_read_valid <= axil_read_ready;\n\n\tassign\tS_AXI_RVALID = axil_read_valid;\n\tassign\tS_AXI_RDATA  = axil_read_data;\n\tassign\tS_AXI_RRESP = 2'b00;\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI-lite",
            "reg ister",
            "logic // {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "localparam [1:0]\tUART_SETUP = 2'b00,\n\t\t\t\tUART_FIFO  = 2'b01,\n\t\t\t\tUART_RXREG = 2'b10,\n\t\t\t\tUART_TXREG = 2'b11;\n\n\tassign\taxil_rx_data = 32'h0;\n\n\tinitial if (CONSOLE_FILE != 0)\n\tbegin\n\t\tsim_console = $fopen(CONSOLE_FILE);\n\tend\n\n\talways @(posedge S_AXI_ACLK)\n\tif (axil_write_ready && awskd_addr == UART_TXREG && wskd_strb[0])\n\tbegin\n\t\tif (CONSOLE_FILE != 0)\n\t\tbegin\n\t\t\t$fwrite(sim_console, \"%1s\", wskd_data[7:0]);\n\t\t\tif (wskd_data[7:0] == 8'h0a)\n\t\t\t\t$fflush(sim_console);\n\t\tend\n\t\t$write(\"%1s\", wskd_data[7:0]);\n\tend\n\n\tassign\taxil_tx_data = 32'h0;\n\n\t// Finally, set the return data.  This data must be valid on the same\n\t// clock S_AXI_RVALID is high.  On all other clocks, it is\n\t// irrelelant--since no one cares, no one is reading it, it gets lost\n\t// in the mux in the interconnect, etc.  For this reason, we can just\n\t// simplify our",
            "logic .\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_RVALID || S_AXI_RREADY)\n\tbegin\n\t\tcasez(arskd_addr)\n\t\tUART_SETUP: axil_read_data <= 32'h0;\n\t\tUART_FIFO:  axil_read_data <= 32'h0;\n\t\tUART_RXREG: axil_read_data <= axil_rx_data;\n\t\tUART_TXREG: axil_read_data <= axil_tx_data;\n\t\tendcase\n\n\t\tif (OPT_LOWPOWER && !axil_read_ready)\n\t\t\taxil_read_data <= 0;\n\tend\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Veri1ator lint-check\n\t// {{{\n\t// verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, S_AXI_AWPROT, S_AXI_ARPROT,\n\t\t\tS_AXI_ARADDR[ADDRLSB-1:0],\n\t\t\tS_AXI_AWADDR[ADDRLSB-1:0],\n\t\t\twskd_data[31:8], wskd_strb[3:1] };\n\t// Verilator lint_on  UNUSED\n\t// verilator coverage_on\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "demofull.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/demofull.v",
        "chunks": [
            "module demofull #(\n\t\t// {{{",
            "parameter integer C_S_AXI_ID_WIDTH\t= 2,",
            "parameter integer C_S_AXI_DATA_WIDTH\t= 32,",
            "parameter integer C_S_AXI_ADDR_WIDTH\t= 6,",
            "parameter [0:0]\tOPT_LOCK     = 1'b0,",
            "parameter [0:0]\tOPT_LOCKID   = 1'b1,",
            "parameter [0:0]\tOPT_LOWPOWER = 1'b0,\n\t\t// Some useful short-hand definitions",
            "localparam LSB = $clog2(C_S_AXI_DATA_WIDTH)-3\n\t\t// }}}\n\t) (\n\t\t// {{{\n\t\t// User ports\n\t\t// {{{\n\t\t// A very basic protocol-independent peripheral interface\n\t\t// 1. A value will be written any time o_we is true\n\t\t// 2. A value will be read any time o_rd is true\n\t\t// 3. Such a slave might just as easily be written as:\n\t\t//\n\t\t//\talways @(posedge S_AXI_ACLK)\n\t\t//\tif (o_we)\n\t\t//\tbegin\n\t\t//\t    for(k=0; k<C_S_AXI_DATA_WIDTH/8; k=k+1)\n\t\t//\t    begin\n\t\t//\t\tif (o_wstrb[k])\n\t\t//\t\tmem[o_waddr][k*8+:8] <= o_wdata[k*8+:8]\n\t\t//\t    end\n\t\t//\tend\n\t\t//\n\t\t//\talways @(posedge S_AXI_ACLK)\n\t\t//\tif (o_rd)\n\t\t//\t\ti_rdata <= mem[o_raddr];\n\t\t//\n\t\t// 4. The rule on the",
            "input is that i_rdata must be",
            "reg istered,\n\t\t//    and that it must only change if o_rd is true.  Violating\n\t\t//    this rule will cause this core to violate the AXI\n\t\t//    protocol standard, as this value is not",
            "reg istered within\n\t\t//    this core",
            "output ",
            "reg o_we,",
            "output ",
            "reg [C_S_AXI_ADDR_WIDTH-LSB-1:0]\to_waddr,",
            "output ",
            "reg [C_S_AXI_DATA_WIDTH-1:0]\to_wdata,",
            "output ",
            "reg [C_S_AXI_DATA_WIDTH/8-1:0]\to_wstrb,\n\t\t//",
            "output ",
            "reg o_rd,",
            "output ",
            "reg [C_S_AXI_ADDR_WIDTH-LSB-1:0]\to_raddr,",
            "input ",
            "wire [C_S_AXI_DATA_WIDTH-1:0]\ti_rdata,\n\t\t//\n\t\t// User ports ends\n\t\t// }}}\n\t\t// Do not modify the ports beyond this line\n\t\t// AXI signals\n\t\t// {{{\n\t\t// Global Clock Signal",
            "input ",
            "wire S_AXI_ACLK,\n\t\t// Global Reset Signal. This Signal is Active LOW",
            "input ",
            "wire S_AXI_ARESETN,\n\n\t\t// Write address channel\n\t\t// {{{\n\t\t// Write Address ID",
            "input ",
            "wire [C_S_AXI_ID_WIDTH-1 : 0] S_AXI_AWID,\n\t\t// Write address",
            "input ",
            "wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR,\n\t\t// Burst length. The burst length gives the exact number of\n\t\t// transfers in a burst",
            "input ",
            "wire [7 : 0] S_AXI_AWLEN,\n\t\t// Burst size. This signal indicates the size of each transfer\n\t\t// in the burst",
            "input ",
            "wire [2 : 0] S_AXI_AWSIZE,\n\t\t// Burst type. The burst type and the size information,\n\t\t// determine how the address for each transfer within the burst\n\t\t// is calculated.",
            "input ",
            "wire [1 : 0] S_AXI_AWBURST,\n\t\t// Lock type. Provides additional information about the\n\t\t// atomic characteristics of the transfer.",
            "input ",
            "wire S_AXI_AWLOCK,\n\t\t// Memory type. This signal indicates how transactions\n\t\t// are required to progress through a system.",
            "input ",
            "wire [3 : 0] S_AXI_AWCACHE,\n\t\t// Verilator coverage_off\n\t\t// Protection type. This signal indicates the privilege\n\t\t// and security level of the transaction, and whether\n\t\t// the transaction is a data access or an instruction access.",
            "input ",
            "wire [2 : 0] S_AXI_AWPROT,\n\t\t// Quality of Service, QoS identifier sent for each\n\t\t// write transaction.",
            "input ",
            "wire [3 : 0] S_AXI_AWQOS,\n\t\t// Verilator coverage_on\n\t\t// Write address valid. This signal indicates that\n\t\t// the channel is signaling valid write address and\n\t\t// control information.",
            "input ",
            "wire S_AXI_AWVALID,\n\t\t// Write address ready. This signal indicates that\n\t\t// the slave is ready to accept an address and associated\n\t\t// control signals.",
            "output ",
            "wire S_AXI_AWREADY,\n\t\t// }}}\n\t\t// Write data channel\n\t\t// {{{\n\t\t// Write Data",
            "input ",
            "wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA,\n\t\t// Write strobes. This signal indicates which byte\n\t\t// lanes hold valid data. There is one write strobe\n\t\t// bit for each eight bits of the write data bus.",
            "input ",
            "wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB,\n\t\t// Write last. This signal indicates the last transfer\n\t\t// in a write burst.",
            "input ",
            "wire S_AXI_WLAST,\n\t\t// Optional User-defined signal in the write data channel.\n\t\t// Write valid. This signal indicates that valid write\n\t\t// data and strobes are available.",
            "input ",
            "wire S_AXI_WVALID,\n\t\t// Write ready. This signal indicates that the slave\n\t\t// can accept the write data.",
            "output ",
            "wire S_AXI_WREADY,\n\t\t// }}}\n\t\t// Write response channel\n\t\t// {{{\n\t\t// Response ID tag. This signal is the ID tag of the\n\t\t// write response.",
            "output ",
            "wire [C_S_AXI_ID_WIDTH-1 : 0] S_AXI_BID,\n\t\t// Write response. This signal indicates the status\n\t\t// of the write transaction.",
            "output ",
            "wire [1 : 0] S_AXI_BRESP,\n\t\t// Optional User-defined signal in the write response channel.\n\t\t// Write response valid. This signal indicates that the\n\t\t// channel is signaling a valid write response.",
            "output ",
            "wire S_AXI_BVALID,\n\t\t// Response ready. This signal indicates that the master\n\t\t// can accept a write response.",
            "input ",
            "wire S_AXI_BREADY,\n\t\t// }}}\n\t\t// Read address channel\n\t\t// {{{\n\t\t// Read address ID. This signal is the identification\n\t\t// tag for the read address group of signals.",
            "input ",
            "wire [C_S_AXI_ID_WIDTH-1 : 0] S_AXI_ARID,\n\t\t// Read address. This signal indicates the initial\n\t\t// address of a read burst transaction.",
            "input ",
            "wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR,\n\t\t// Burst length. The burst length gives the exact number of\n\t\t// transfers in a burst",
            "input ",
            "wire [7 : 0] S_AXI_ARLEN,\n\t\t// Burst size. This signal indicates the size of each transfer\n\t\t// in the burst",
            "input ",
            "wire [2 : 0] S_AXI_ARSIZE,\n\t\t// Burst type. The burst type and the size information,\n\t\t// determine how the address for each transfer within the\n\t\t// burst is calculated.",
            "input ",
            "wire [1 : 0] S_AXI_ARBURST,\n\t\t// Lock type. Provides additional information about the\n\t\t// atomic characteristics of the transfer.",
            "input ",
            "wire S_AXI_ARLOCK,\n\t\t// Memory type. This signal indicates how transactions\n\t\t// are required to progress through a system.",
            "input ",
            "wire [3 : 0] S_AXI_ARCACHE,\n\t\t//\n\t\t// Verilator coverage_off\n\t\t// Protection type. This signal indicates the privilege\n\t\t// and security level of the transaction, and whether\n\t\t// the transaction is a data access or an instruction access.",
            "input ",
            "wire [2 : 0] S_AXI_ARPROT,\n\t\t// Quality of Service, QoS identifier sent for each\n\t\t// read transaction.",
            "input ",
            "wire [3 : 0] S_AXI_ARQOS,\n\t\t// Verilator coverage_on\n\t\t//\n\t\t// Write address valid. This signal indicates that\n\t\t// the channel is signaling valid read address and\n\t\t// control information.",
            "input ",
            "wire S_AXI_ARVALID,\n\t\t// Read address ready. This signal indicates that\n\t\t// the slave is ready to accept an address and associated\n\t\t// control signals.",
            "output ",
            "wire S_AXI_ARREADY,\n\t\t// }}}\n\t\t// Read data (return) channel\n\t\t// {{{\n\t\t// Read ID tag. This signal is the identification tag\n\t\t// for the read data group of signals generated by the slave.",
            "output ",
            "wire [C_S_AXI_ID_WIDTH-1 : 0] S_AXI_RID,\n\t\t// Read Data",
            "output ",
            "wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA,\n\t\t// Read response. This signal indicates the status of\n\t\t// the read transfer.",
            "output ",
            "wire [1 : 0] S_AXI_RRESP,\n\t\t// Read last. This signal indicates the last transfer\n\t\t// in a read burst.",
            "output ",
            "wire S_AXI_RLAST,\n\t\t// Optional User-defined signal in the read address channel.\n\t\t// Read valid. This signal indicates that the channel\n\t\t// is signaling the required read data.",
            "output ",
            "wire S_AXI_RVALID,\n\t\t// Read ready. This signal indicates that the master can\n\t\t// accept the read data and response information.",
            "input ",
            "wire S_AXI_RREADY\n\t\t// }}}\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Local declarations\n\t// {{{\n\t// More useful shorthand definitions",
            "localparam AW = C_S_AXI_ADDR_WIDTH;",
            "localparam DW = C_S_AXI_DATA_WIDTH;",
            "localparam IW = C_S_AXI_ID_WIDTH;\n\t// Double buffer the write response channel only",
            "reg [IW-1 : 0]\tr_bid;",
            "reg r_bvalid;",
            "reg [IW-1 : 0]\taxi_bid;",
            "reg axi_bvalid;",
            "reg axi_awready, axi_wready;",
            "reg [AW-1:0]\twaddr;",
            "wire [AW-1:0]\tnext_wr_addr;\n\n\t// Vivado will warn about wlen only using 4-bits.  This is\n\t// to be expected, since the axi_addr",
            "module only needs to use\n\t// the bottom four bits of wlen to determine address increments",
            "reg [7:0]\t\twlen;\n\t// Vivado will also warn about the top bit of wsize being unused.\n\t// This is also to be expected for a DATA_WIDTH of 32-bits.",
            "reg [2:0]\t\twsize;",
            "reg [1:0]\t\twburst;",
            "wire m_awvalid, m_awlock;",
            "reg m_awready;",
            "wire [AW-1:0]\tm_awaddr;",
            "wire [1:0]\t\tm_awburst;",
            "wire [2:0]\t\tm_awsize;",
            "wire [7:0]\t\tm_awlen;",
            "wire [IW-1:0]\tm_awid;",
            "wire [AW-1:0]\tnext_rd_addr;\n\n\t// Vivado will warn about rlen only using 4-bits.  This is\n\t// to be expected, since for a DATA_WIDTH of 32-bits, the axi_addr\n\t//",
            "module only uses the bottom four bits of rlen to determine\n\t// address increments",
            "reg [7:0]\t\trlen;\n\t// Vivado will also warn about the top bit of wsize being unused.\n\t// This is also to be expected for a DATA_WIDTH of 32-bits.",
            "reg [2:0]\t\trsize;",
            "reg [1:0]\t\trburst;",
            "reg [IW-1:0]\trid;",
            "reg rlock;",
            "reg axi_arready;",
            "reg [8:0]\t\taxi_rlen;",
            "reg [AW-1:0]\traddr;\n\n\t// Read skid buffer",
            "reg rskd_valid, rskd_last, rskd_lock;",
            "wire rskd_ready;",
            "reg [IW-1:0]\trskd_id;\n\n\t// Exclusive address",
            "reg ister checking",
            "reg exclusive_write, block_write;",
            "wire write_lock_valid;",
            "reg axi_exclusive_write;\n\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AW Skid buffer\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tskidbuffer #(\n\t\t// {{{\n\t\t.DW(AW+2+3+1+8+IW),\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.OPT_OUTREG(1'b0)\n\t\t// }}}\n\t) awbuf(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t.i_valid(S_AXI_AWVALID), .o_ready(S_AXI_AWREADY),\n\t\t\t.i_data({ S_AXI_AWADDR, S_AXI_AWBURST, S_AXI_AWSIZE,\n\t\t\t\tS_AXI_AWLOCK, S_AXI_AWLEN, S_AXI_AWID }),\n\t\t.o_valid(m_awvalid), .i_ready(m_awready),\n\t\t\t.o_data({ m_awaddr, m_awburst, m_awsize,\n\t\t\t\tm_awlock, m_awlen, m_awid })\n\t\t// }}}\n\t);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Write processing\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// axi_awready, axi_wready\n\t// {{{\n\tinitial\taxi_awready = 1;\n\tinitial\taxi_wready  = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\tbegin\n\t\taxi_awready  <= 1;\n\t\taxi_wready   <= 0;\n\tend else if (m_awvalid && m_awready)\n\tbegin\n\t\taxi_awready <= 0;\n\t\taxi_wready  <= 1;\n\tend else if (S_AXI_WVALID && S_AXI_WREADY)\n\tbegin\n\t\taxi_awready <= (S_AXI_WLAST)&&(!S_AXI_BVALID || S_AXI_BREADY);\n\t\taxi_wready  <= (!S_AXI_WLAST);\n\tend else if (!axi_awready)\n\tbegin\n\t\tif (S_AXI_WREADY)\n\t\t\taxi_awready <= 1'b0;\n\t\telse if (r_bvalid && !S_AXI_BREADY)\n\t\t\taxi_awready <= 1'b0;\n\t\telse\n\t\t\taxi_awready <= 1'b1;\n\tend\n\t// }}}\n\n\t// Exclusive write calculation\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || !OPT_LOCK)\n\tbegin\n\t\texclusive_write <= 0;\n\t\tblock_write <= 0;\n\tend else if (m_awvalid && m_awready)\n\tbegin\n\t\texclusive_write <= 1'b0;\n\t\tblock_write     <= 1'b0;\n\t\tif (write_lock_valid)\n\t\t\texclusive_write <= 1'b1;\n\t\telse if (m_awlock)\n\t\t\tblock_write <= 1'b1;\n\tend else if (m_awready)\n\tbegin\n\t\texclusive_write <= 1'b0;\n\t\tblock_write     <= 1'b0;\n\tend\n\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || !OPT_LOCK)\n\t\taxi_exclusive_write <= 0;\n\telse if (!S_AXI_BVALID || S_AXI_BREADY)\n\tbegin\n\t\taxi_exclusive_write <= exclusive_write;\n\t\tif (OPT_LOWPOWER && (!S_AXI_WVALID || !S_AXI_WREADY || !S_AXI_WLAST)\n\t\t\t\t&& !r_bvalid)\n\t\t\taxi_exclusive_write <= 0;\n\tend\n\t// }}}\n\n\t// Next write address calculation\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (m_awready)\n\tbegin\n\t\twaddr    <= m_awaddr;\n\t\twburst   <= m_awburst;\n\t\twsize    <= m_awsize;\n\t\twlen     <= m_awlen;\n\tend else if (S_AXI_WVALID)\n\t\twaddr <= next_wr_addr;\n\n\taxi_addr #(\n\t\t// {{{\n\t\t.AW(AW), .DW(DW)\n\t\t// }}}\n\t) get_next_wr_addr(\n\t\t// {{{\n\t\twaddr, wsize, wburst, wlen,\n\t\t\tnext_wr_addr\n\t\t// }}}\n\t);\n\t// }}}\n\n\t// o_w*\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tbegin\n\t\to_we    <= (S_AXI_WVALID && S_AXI_WREADY);\n\t\to_waddr <= waddr[AW-1:LSB];\n\t\to_wdata <= S_AXI_WDATA;\n\t\tif (block_write)\n\t\t\to_wstrb <= 0;\n\t\telse\n\t\t\to_wstrb <= S_AXI_WSTRB;\n\n\t\tif (!S_AXI_ARESETN)\n\t\t\to_we <= 0;\n\t\tif (OPT_LOWPOWER && (!S_AXI_ARESETN || !S_AXI_WVALID\n\t\t\t\t\t|| !S_AXI_WREADY))\n\t\tbegin\n\t\t\to_waddr <= 0;\n\t\t\to_wdata <= 0;\n\t\t\to_wstrb <= 0;\n\t\tend\n\tend\n\t// }}}\n\n\t//\n\t// Write return path\n\t// {{{\n\t// r_bvalid\n\t// {{{\n\tinitial\tr_bvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tr_bvalid <= 1'b0;\n\telse if (S_AXI_WVALID && S_AXI_WREADY && S_AXI_WLAST\n\t\t\t&&(S_AXI_BVALID && !S_AXI_BREADY))\n\t\tr_bvalid <= 1'b1;\n\telse if (S_AXI_BREADY)\n\t\tr_bvalid <= 1'b0;\n\t// }}}\n\n\t// r_bid, axi_bid\n\t// {{{\n\tinitial\tr_bid = 0;\n\tinitial\taxi_bid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tbegin\n\t\tif (m_awready && (!OPT_LOWPOWER || m_awvalid))\n\t\t\tr_bid    <= m_awid;\n\n\t\tif (!S_AXI_BVALID || S_AXI_BREADY)\n\t\t\taxi_bid <= r_bid;\n\n\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\tbegin\n\t\t\tr_bid <= 0;\n\t\t\taxi_bid <= 0;\n\t\tend\n\tend\n\t// }}}\n\n\t// axi_bvalid\n\t// {{{\n\tinitial\taxi_bvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_bvalid <= 0;\n\telse if (S_AXI_WVALID && S_AXI_WREADY && S_AXI_WLAST)\n\t\taxi_bvalid <= 1;\n\telse if (S_AXI_BREADY)\n\t\taxi_bvalid <= r_bvalid;\n\t// }}}\n\n\t// m_awready\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tm_awready = axi_awready;\n\t\tif (S_AXI_WVALID && S_AXI_WREADY && S_AXI_WLAST\n\t\t\t&& (!S_AXI_BVALID || S_AXI_BREADY))\n\t\t\tm_awready = 1;\n\tend\n\t// }}}\n\n\t// At one time, axi_awready was the same as S_AXI_AWREADY.  Now, though,\n\t// with the extra write address skid buffer, this is no longer the case.\n\t// S_AXI_AWREADY is handled/created/managed by the skid buffer.\n\t//\n\t// assign S_AXI_AWREADY = axi_awready;\n\t//\n\t// The rest of these signals can be set according to their",
            "reg istered\n\t// values above.\n\tassign\tS_AXI_WREADY  = axi_wready;\n\tassign\tS_AXI_BVALID  = axi_bvalid;\n\tassign\tS_AXI_BID     = axi_bid;\n\t//\n\t// This core does not produce any bus errors, nor does it support\n\t// exclusive access, so 2'b00 will always be the correct response.\n\tassign\tS_AXI_BRESP = { 1'b0, axi_exclusive_write };\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read processing\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// axi_arready\n\t// {{{\n\tinitial axi_arready = 1;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_arready <= 1;\n\telse if (S_AXI_ARVALID && S_AXI_ARREADY)\n\t\taxi_arready <= (S_AXI_ARLEN==0)&&(o_rd);\n\telse if (o_rd)\n\t\taxi_arready <= (axi_rlen <= 1);\n\t// }}}\n\n\t// axi_rlen\n\t// {{{\n\tinitial\taxi_rlen = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_rlen <= 0;\n\telse if (S_AXI_ARVALID && S_AXI_ARREADY)\n\t\taxi_rlen <= S_AXI_ARLEN + (o_rd ? 0:1);\n\telse if (o_rd)\n\t\taxi_rlen <= axi_rlen - 1;\n\t// }}}\n\n\t// Next read address calculation\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (o_rd)\n\t\traddr <= next_rd_addr;\n\telse if (S_AXI_ARREADY)\n\tbegin\n\t\traddr <= S_AXI_ARADDR;\n\t\tif (OPT_LOWPOWER && !S_AXI_ARVALID)\n\t\t\traddr <= 0;\n\tend\n\n\t// r*\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (S_AXI_ARREADY)\n\tbegin\n\t\trburst   <= S_AXI_ARBURST;\n\t\trsize    <= S_AXI_ARSIZE;\n\t\trlen     <= S_AXI_ARLEN;\n\t\trid      <= S_AXI_ARID;\n\t\trlock    <= S_AXI_ARLOCK && S_AXI_ARVALID && OPT_LOCK;\n\n\t\tif (OPT_LOWPOWER && !S_AXI_ARVALID)\n\t\tbegin\n\t\t\trburst   <= 0;\n\t\t\trsize    <= 0;\n\t\t\trlen     <= 0;\n\t\t\trid      <= 0;\n\t\t\trlock    <= 0;\n\t\tend\n\tend\n\t// }}}\n\n\taxi_addr #(\n\t\t// {{{\n\t\t.AW(AW), .DW(DW)\n\t\t// }}}\n\t) get_next_rd_addr(\n\t\t// {{{\n\t\t(S_AXI_ARREADY ? S_AXI_ARADDR : raddr),\n\t\t(S_AXI_ARREADY  ? S_AXI_ARSIZE : rsize),\n\t\t(S_AXI_ARREADY  ? S_AXI_ARBURST: rburst),\n\t\t(S_AXI_ARREADY  ? S_AXI_ARLEN  : rlen),\n\t\tnext_rd_addr\n\t\t// }}}\n\t);\n\t// }}}\n\n\t// o_rd, o_raddr\n\t// {{{\n\talways @(*)\n\tbegin\n\t\to_rd = (S_AXI_ARVALID || !S_AXI_ARREADY);\n\t\tif (S_AXI_RVALID && !S_AXI_RREADY)\n\t\t\to_rd = 0;\n\t\tif (rskd_valid && !rskd_ready)\n\t\t\to_rd = 0;\n\t\to_raddr = (S_AXI_ARREADY ? S_AXI_ARADDR[AW-1:LSB] : raddr[AW-1:LSB]);\n\tend\n\t// }}}\n\n\t// rskd_valid\n\t// {{{\n\tinitial\trskd_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\trskd_valid <= 0;\n\telse if (o_rd)\n\t\trskd_valid <= 1;\n\telse if (rskd_ready)\n\t\trskd_valid <= 0;\n\t// }}}\n\n\t// rskd_id\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!rskd_valid || rskd_ready)\n\tbegin\n\t\tif (S_AXI_ARVALID && S_AXI_ARREADY)\n\t\t\trskd_id <= S_AXI_ARID;\n\t\telse\n\t\t\trskd_id <= rid;\n\tend\n\t// }}}\n\n\t// rskd_last\n\t// {{{\n\tinitial rskd_last   = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!rskd_valid || rskd_ready)\n\tbegin\n\t\trskd_last <= 0;\n\t\tif (o_rd && axi_rlen == 1)\n\t\t\trskd_last <= 1;\n\t\tif (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN == 0)\n\t\t\trskd_last <= 1;\n\tend\n\t// }}}\n\n\t// rskd_lock\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN || !OPT_LOCK)\n\t\trskd_lock <= 1'b0;\n\telse if (!rskd_valid || rskd_ready)\n\tbegin\n\t\trskd_lock <= 0;\n\t\tif (!OPT_LOWPOWER || o_rd)\n\t\tbegin\n\t\t\tif (S_AXI_ARVALID && S_AXI_ARREADY)\n\t\t\t\trskd_lock <= S_AXI_ARLOCK;\n\t\t\telse\n\t\t\t\trskd_lock <= rlock;\n\t\tend\n\tend\n\t// }}}\n\n\n\t// Outgoing read skidbuffer\n\t// {{{\n\tskidbuffer #(\n\t\t// {{{\n\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t.OPT_OUTREG(1),\n\t\t.DW(IW+2+DW)\n\t\t// }}}\n\t) rskid (\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t.i_valid(rskd_valid), .o_ready(rskd_ready),\n\t\t.i_data({ rskd_id, rskd_lock, rskd_last, i_rdata }),\n\t\t.o_valid(S_AXI_RVALID), .i_ready(S_AXI_RREADY),\n\t\t\t.o_data({ S_AXI_RID, S_AXI_RRESP[0], S_AXI_RLAST,\n\t\t\t\t\tS_AXI_RDATA })\n\t\t// }}}\n\t);\n\t// }}}\n\n\tassign\tS_AXI_RRESP[1] = 1'b0;\n\tassign\tS_AXI_ARREADY = axi_arready;\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Exclusive address caching\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate if (OPT_LOCK && !OPT_LOCKID)\n\tbegin : EXCLUSIVE_ACCESS_BLOCK\n\t\t// {{{\n\t\t// The AXI4 specification requires that we check one address\n\t\t// per ID.  This isn't that.  This algorithm checks one ID,\n\t\t// whichever the last ID was.  It's designed to be lighter on\n\t\t// the",
            "logic requirements, and (unnoticably) not (fully) spec\n\t\t// compliant.  (The difference, if noticed at all, will be in\n\t\t// performance when multiple masters try to perform an exclusive\n\t\t// transaction at once.)\n\n\t\t// Local declarations\n\t\t// {{{",
            "reg w_valid_lock_request, w_cancel_lock,\n\t\t\t\t\tw_lock_request,\n\t\t\t\t\tlock_valid, returned_lock_valid;",
            "reg [AW-LSB-1:0]\tlock_start, lock_end;",
            "reg [3:0]\t\tlock_len;",
            "reg [1:0]\t\tlock_burst;",
            "reg [2:0]\t\tlock_size;",
            "reg [IW-1:0]\tlock_id;",
            "reg w_write_lock_valid;\n\t\t// }}}\n\n\t\t// w_lock_request\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tw_lock_request = 0;\n\t\t\tif (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLOCK)\n\t\t\t\tw_lock_request = 1;\n\t\tend\n\t\t// }}}\n\n\t\t// w_valid_lock_request\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tw_valid_lock_request = 0;\n\t\t\tif (w_lock_request)\n\t\t\t\tw_valid_lock_request = 1;\n\t\t\tif (o_we && o_waddr == S_AXI_ARADDR[AW-1:LSB])\n\t\t\t\tw_valid_lock_request = 0;\n\t\tend\n\t\t// }}}\n\n\t\t// returned_lock_valid\n\t\t// {{{\n\t\tinitial\treturned_lock_valid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\treturned_lock_valid <= 0;\n\t\telse if (S_AXI_ARVALID && S_AXI_ARREADY\n\t\t\t\t\t&& S_AXI_ARLOCK && S_AXI_ARID== lock_id)\n\t\t\treturned_lock_valid <= 0;\n\t\telse if (w_cancel_lock)\n\t\t\treturned_lock_valid <= 0;\n\t\telse if (rskd_valid && rskd_lock && rskd_ready)\n\t\t\treturned_lock_valid <= lock_valid;\n\t\t// }}}\n\n\t\t// w_cancel_lock\n\t\t// {{{\n\t\talways @(*)\n\t\t\tw_cancel_lock = (lock_valid && w_lock_request)\n\t\t\t\t|| (lock_valid && o_we\n\t\t\t\t\t&& o_waddr >= lock_start\n\t\t\t\t\t&& o_waddr <= lock_end\n\t\t\t\t\t&& o_wstrb != 0);\n\t\t// }}}\n\n\t\t// lock_valid\n\t\t// {{{\n\t\tinitial\tlock_valid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || !OPT_LOCK)\n\t\t\tlock_valid <= 0;\n\t\telse begin\n\t\t\tif (S_AXI_ARVALID && S_AXI_ARREADY\n\t\t\t\t\t&& S_AXI_ARLOCK && S_AXI_ARID== lock_id)\n\t\t\t\tlock_valid <= 0;\n\t\t\tif (w_cancel_lock)\n\t\t\t\tlock_valid <= 0;\n\t\t\tif (w_valid_lock_request)\n\t\t\t\tlock_valid <= 1;\n\t\tend\n\t\t// }}}\n\n\t\t// lock_start, lock_end, lock_len, lock_size, lock_id\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (w_valid_lock_request)\n\t\tbegin\n\t\t\tlock_start <= S_AXI_ARADDR[C_S_AXI_ADDR_WIDTH-1:LSB];\n\t\t\tlock_end <= S_AXI_ARADDR[C_S_AXI_ADDR_WIDTH-1:LSB]\n\t\t\t\t\t+ ((S_AXI_ARBURST == 2'b00) ? 0 : S_AXI_ARLEN[3:0]);\n\t\t\tlock_len   <= S_AXI_ARLEN[3:0];\n\t\t\tlock_burst <= S_AXI_ARBURST;\n\t\t\tlock_size  <= S_AXI_ARSIZE;\n\t\t\tlock_id    <= S_AXI_ARID;\n\t\tend\n\t\t// }}}\n\n\t\t// w_write_lock_valid\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tw_write_lock_valid = returned_lock_valid;\n\t\t\tif (!m_awvalid || !m_awready || !m_awlock || !lock_valid)\n\t\t\t\tw_write_lock_valid = 0;\n\t\t\tif (m_awaddr[C_S_AXI_ADDR_WIDTH-1:LSB] != lock_start)\n\t\t\t\tw_write_lock_valid = 0;\n\t\t\tif (m_awid != lock_id)\n\t\t\t\tw_write_lock_valid = 0;\n\t\t\tif (m_awlen[3:0] != lock_len)\t// MAX transfer size is 16 beats\n\t\t\t\tw_write_lock_valid = 0;\n\t\t\tif (m_awburst != 2'b01 && lock_len != 0)\n\t\t\t\tw_write_lock_valid = 0;\n\t\t\tif (m_awsize != lock_size)\n\t\t\t\tw_write_lock_valid = 0;\n\t\tend\n\t\t// }}}\n\n\t\tassign\twrite_lock_valid = w_write_lock_valid;\n\t\t// }}}\n\tend else if (OPT_LOCK) // && OPT_LOCKID\n\tbegin : EXCLUSIVE_ACCESS_PER_ID\n\t\t// {{{\n\n\t\tgenvar\tgk;",
            "wire [(1<<IW)-1:0]\twrite_lock_valid_per_id;\n\n\t\tfor(gk=0; gk<(1<<IW); gk=gk+1)\n\t\tbegin : PER_ID_LOGIC\n\t\t// {{{\n\t\t\t// Local declarations\n\t\t\t// {{{",
            "reg w_valid_lock_request,\n\t\t\t\t\t\tw_cancel_lock,\n\t\t\t\t\t\tlock_valid, returned_lock_valid;\n\t\t\t//",
            "reg [1:0]\t\tlock_burst;",
            "reg [2:0]\t\tlock_size;",
            "reg [3:0]\t\tlock_len;",
            "reg [AW-LSB-1:0]\tlock_start, lock_end;",
            "reg w_write_lock_valid;\n\t\t\t// }}}\n\n\t\t\t// valid_lock_request\n\t\t\t// {{{\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\tw_valid_lock_request = 0;\n\t\t\t\tif (S_AXI_ARVALID && S_AXI_ARREADY\n\t\t\t\t\t\t&& S_AXI_ARID == gk[IW-1:0]\n\t\t\t\t\t\t&& S_AXI_ARLOCK)\n\t\t\t\t\tw_valid_lock_request = 1;\n\t\t\t\tif (o_we && o_waddr == S_AXI_ARADDR[AW-1:LSB])\n\t\t\t\t\tw_valid_lock_request = 0;\n\t\t\tend\n\t\t\t// }}}\n\n\t\t\t// returned_lock_valid\n\t\t\t// {{{\n\t\t\tinitial\treturned_lock_valid = 0;\n\t\t\talways @(posedge S_AXI_ACLK)\n\t\t\tif (!S_AXI_ARESETN)\n\t\t\t\treturned_lock_valid <= 0;\n\t\t\telse if (S_AXI_ARVALID && S_AXI_ARREADY\n\t\t\t\t\t&&S_AXI_ARLOCK&&S_AXI_ARID== gk[IW-1:0])\n\t\t\t\treturned_lock_valid <= 0;\n\t\t\telse if (w_cancel_lock)\n\t\t\t\treturned_lock_valid <= 0;\n\t\t\telse if (rskd_valid && rskd_lock && rskd_ready\n\t\t\t\t\t&& rskd_id == gk[IW-1:0])\n\t\t\t\treturned_lock_valid <= lock_valid;\n\t\t\t// }}}\n\n\t\t\t// w_cancel_lock\n\t\t\t// {{{\n\t\t\talways @(*)\n\t\t\t\tw_cancel_lock=(lock_valid&&w_valid_lock_request)\n\t\t\t\t\t|| (lock_valid && o_we\n\t\t\t\t\t\t&& o_waddr >= lock_start\n\t\t\t\t\t\t&& o_waddr <= lock_end\n\t\t\t\t\t\t&& o_wstrb != 0);\n\t\t\t// }}}\n\n\t\t\t// lock_valid\n\t\t\t// {{{\n\t\t\tinitial\tlock_valid = 0;\n\t\t\talways @(posedge S_AXI_ACLK)\n\t\t\tif (!S_AXI_ARESETN || !OPT_LOCK)\n\t\t\t\tlock_valid <= 0;\n\t\t\telse begin\n\t\t\t\tif (S_AXI_ARVALID && S_AXI_ARREADY\n\t\t\t\t\t\t&& S_AXI_ARLOCK\n\t\t\t\t\t\t&& S_AXI_ARID == gk[IW-1:0])\n\t\t\t\t\tlock_valid <= 0;\n\t\t\t\tif (w_cancel_lock)\n\t\t\t\t\tlock_valid <= 0;\n\t\t\t\tif (w_valid_lock_request)\n\t\t\t\t\tlock_valid <= 1;\n\t\t\tend\n\t\t\t// }}}\n\n\t\t\t// lock_start, lock_end, lock_len, lock_size\n\t\t\t// {{{\n\t\t\talways @(posedge S_AXI_ACLK)\n\t\t\tif (w_valid_lock_request)\n\t\t\tbegin\n\t\t\t\tlock_start <= S_AXI_ARADDR[C_S_AXI_ADDR_WIDTH-1:LSB];\n\t\t\t\t// Verilator lint_off WIDTH\n\t\t\t\tlock_end <= S_AXI_ARADDR[C_S_AXI_ADDR_WIDTH-1:LSB]\n\t\t\t\t\t+ ((S_AXI_ARBURST == 2'b00) ? 4'h0 : S_AXI_ARLEN[3:0]);\n\t\t\t\t// Verilator lint_on  WIDTH\n\t\t\t\tlock_len   <= S_AXI_ARLEN[3:0];\n\t\t\t\tlock_size  <= S_AXI_ARSIZE;\n\t\t\t\t// lock_burst <= S_AXI_ARBURST;\n\t\t\tend\n\t\t\t// }}}\n\n\t\t\t// w_write_lock_valid\n\t\t\t// {{{\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\tw_write_lock_valid = returned_lock_valid;\n\t\t\t\tif (!m_awvalid || !m_awready || !m_awlock || !lock_valid)\n\t\t\t\t\tw_write_lock_valid = 0;\n\t\t\t\tif (m_awaddr[C_S_AXI_ADDR_WIDTH-1:LSB] != lock_start)\n\t\t\t\t\tw_write_lock_valid = 0;\n\t\t\t\tif (m_awid[IW-1:0] != gk[IW-1:0])\n\t\t\t\t\tw_write_lock_valid = 0;\n\t\t\t\tif (m_awlen[3:0] != lock_len)\t// MAX transfer size is 16 beats\n\t\t\t\t\tw_write_lock_valid = 0;\n\t\t\t\tif (m_awburst != 2'b01 && lock_len != 0)\n\t\t\t\t\tw_write_lock_valid = 0;\n\t\t\t\tif (m_awsize != lock_size)\n\t\t\t\t\tw_write_lock_valid = 0;\n\t\t\tend\n\t\t\t// }}}\n\n\t\t\tassign\twrite_lock_valid_per_id[gk]= w_write_lock_valid;\n\t\t// }}}\n\t\tend\n\n\t\tassign\twrite_lock_valid = |write_lock_valid_per_id;\n\t\t// }}}\n\tend else begin : NO_LOCKING\n\t\t// {{{\n\n\t\tassign\twrite_lock_valid = 1'b0;\n\t\t// Verilator coverage_off\n\t\t// Verilator lint_off UNUSED",
            "wire unused_lock;\n\t\tassign\tunused_lock = &{ 1'b0, S_AXI_ARLOCK, S_AXI_AWLOCK };\n\t\t// Verilator lint_on  UNUSED\n\t\t// Verilator coverage_on\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0, S_AXI_AWCACHE, S_AXI_AWPROT, S_AXI_AWQOS,\n\t\tS_AXI_ARCACHE, S_AXI_ARPROT, S_AXI_ARQOS };\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t//\n\t// The following properties are only some of the properties used\n\t// to verify this core\n\t//",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\t\tf_past_valid <= 1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(!S_AXI_ARESETN);\n\n\tfaxi_slave\t#(\n\t\t// {{{\n\t\t.C_AXI_ID_WIDTH(C_S_AXI_ID_WIDTH),\n\t\t.C_AXI_DATA_WIDTH(C_S_AXI_DATA_WIDTH),\n\t\t.C_AXI_ADDR_WIDTH(C_S_AXI_ADDR_WIDTH))\n\t\t// ...\n\t\t// }}}\n\tf_slave(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK),\n\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t//\n\t\t// Address write channel\n\t\t// {{{\n\t\t.i_axi_awvalid(m_awvalid),\n\t\t.i_axi_awready(m_awready),\n\t\t.i_axi_awid(   m_awid),\n\t\t.i_axi_awaddr( m_awaddr),\n\t\t.i_axi_awlen(  m_awlen),\n\t\t.i_axi_awsize( m_awsize),\n\t\t.i_axi_awburst(m_awburst),\n\t\t.i_axi_awlock( m_awlock),\n\t\t.i_axi_awcache(4'h0),\n\t\t.i_axi_awprot( 3'h0),\n\t\t.i_axi_awqos(  4'h0),\n\t\t// }}}\n\t\t// Write Data Channel\n\t\t// {{{\n\t\t// Write Data\n\t\t.i_axi_wdata(S_AXI_WDATA),\n\t\t.i_axi_wstrb(S_AXI_WSTRB),\n\t\t.i_axi_wlast(S_AXI_WLAST),\n\t\t.i_axi_wvalid(S_AXI_WVALID),\n\t\t.i_axi_wready(S_AXI_WREADY),\n\t\t// }}}\n\t\t// Write response\n\t\t// {{{\n\t\t.i_axi_bvalid(S_AXI_BVALID),\n\t\t.i_axi_bready(S_AXI_BREADY),\n\t\t.i_axi_bid(   S_AXI_BID),\n\t\t.i_axi_bresp( S_AXI_BRESP),\n\t\t// }}}\n\t\t// Read address channel\n\t\t// {{{\n\t\t.i_axi_arvalid(S_AXI_ARVALID),\n\t\t.i_axi_arready(S_AXI_ARREADY),\n\t\t.i_axi_arid(   S_AXI_ARID),\n\t\t.i_axi_araddr( S_AXI_ARADDR),\n\t\t.i_axi_arlen(  S_AXI_ARLEN),\n\t\t.i_axi_arsize( S_AXI_ARSIZE),\n\t\t.i_axi_arburst(S_AXI_ARBURST),\n\t\t.i_axi_arlock( S_AXI_ARLOCK),\n\t\t.i_axi_arcache(S_AXI_ARCACHE),\n\t\t.i_axi_arprot( S_AXI_ARPROT),\n\t\t.i_axi_arqos(  S_AXI_ARQOS),\n\t\t// }}}\n\t\t// Read data return channel\n\t\t// {{{\n\t\t.i_axi_rvalid(S_AXI_RVALID),\n\t\t.i_axi_rready(S_AXI_RREADY),\n\t\t.i_axi_rid(S_AXI_RID),\n\t\t.i_axi_rdata(S_AXI_RDATA),\n\t\t.i_axi_rresp(S_AXI_RRESP),\n\t\t.i_axi_rlast(S_AXI_RLAST),\n\t\t// }}}\n\t\t//\n\t\t// ...\n\t\t// }}}\n\t);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Write induction properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\n\t//\n\t// ...\n\t//\n\n\talways @(*)\n\tif (r_bvalid)\n\t\tassert(S_AXI_BVALID);\n\n\talways @(*)\n\t\tassert(axi_awready == (!S_AXI_WREADY&& !r_bvalid));\n\n\talways @(*)\n\tif (axi_awready)\n\t\tassert(!S_AXI_WREADY);\n\n\n\t//\n\t// ...\n\t//\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read induction properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\n\t//\n\t// ...\n\t//\n\n\n\talways @(posedge S_AXI_ACLK)\n\tif (f_past_valid && axi_rlen == 0)\n\t\tassert(S_AXI_ARREADY);\n\n\talways @(posedge S_AXI_ACLK)\n\t\tassert(axi_rlen <= 256);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Lowpower checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (OPT_LOWPOWER && S_AXI_ARESETN)\n\tbegin\n\t\tif (!rskd_valid)\n\t\t\tassert(!rskd_lock);\n\t\tif (faxi_awr_nbursts == 0)\n\t\tbegin\n\t\t\tassert(S_AXI_BRESP == 2'b00);\n\t\t\t// assert(S_AXI_BID == 0);\n\t\tend\n\n\t\tif (!S_AXI_RVALID)\n\t\tbegin\n\t\t\tassert(S_AXI_RID   == 0);\n\t\t\tassert(S_AXI_RDATA == 0);\n\t\t\tassert(S_AXI_RRESP == 2'b00);\n\t\tend\n\n\t\tif (!o_we)\n\t\tbegin\n\t\t\tassert(o_waddr == 0);\n\t\t\tassert(o_wdata == 0);\n\t\t\tassert(o_wstrb == 0);\n\t\tend\n\tend\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// ...\n\t//\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg f_wr_cvr_valid, f_rd_cvr_valid;",
            "reg [4:0]\tf_dbl_rd_count, f_dbl_wr_count;\n\n\tinitial\tf_wr_cvr_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tf_wr_cvr_valid <= 0;\n\telse if (S_AXI_AWVALID && S_AXI_AWREADY && S_AXI_AWLEN > 4)\n\t\tf_wr_cvr_valid <= 1;\n\n\talways @(*)\n\t\tcover(!S_AXI_BVALID && axi_awready && !m_awvalid\n\t\t\t&& f_wr_cvr_valid /* && ... */));\n\n\tinitial\tf_rd_cvr_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tf_rd_cvr_valid <= 0;\n\telse if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN > 4)\n\t\tf_rd_cvr_valid <= 1;\n\n\talways @(*)\n\t\tcover(S_AXI_ARREADY && f_rd_cvr_valid /* && ... */);\n\n\t//\n\t// Generate cover statements associated with multiple successive bursts\n\t//\n\t// These will be useful for demonstrating the throughput of the core.\n\t//\n\n\tinitial\tf_dbl_wr_count = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tf_dbl_wr_count = 0;\n\telse if (S_AXI_AWVALID && S_AXI_AWREADY && S_AXI_AWLEN == 3)\n\tbegin\n\t\tif (!(&f_dbl_wr_count))\n\t\t\tf_dbl_wr_count <= f_dbl_wr_count + 1;\n\tend\n\n\talways @(*)\n\t\tcover(S_AXI_ARESETN && (f_dbl_wr_count > 1));\t//!\n\n\talways @(*)\n\t\tcover(S_AXI_ARESETN && (f_dbl_wr_count > 3));\t//!\n\n\talways @(*)\n\t\tcover(S_AXI_ARESETN && (f_dbl_wr_count > 3) && !m_awvalid\n\t\t\t&&(!S_AXI_AWVALID && !S_AXI_WVALID && !S_AXI_BVALID)\n\t\t\t&& (faxi_awr_nbursts == 0)\n\t\t\t&& (faxi_wr_pending == 0));\n\n\tinitial\tf_dbl_rd_count = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tf_dbl_rd_count = 0;\n\telse if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN == 3)\n\tbegin\n\t\tif (!(&f_dbl_rd_count))\n\t\t\tf_dbl_rd_count <= f_dbl_rd_count + 1;\n\tend\n\n\talways @(*)\n\t\tcover(!S_AXI_ARESETN && (f_dbl_rd_count > 3)\n\t\t\t/* && ... */\n\t\t\t&& !S_AXI_ARVALID && !S_AXI_RVALID);\n\n\tgenerate if (OPT_LOCK)\n\tbegin\n\t\talways @(*)\n\t\t\tcover(S_AXI_ARESETN && S_AXI_BVALID && S_AXI_BREADY\n\t\t\t\t&& S_AXI_BRESP == 2'b01);\n\tend endgenerate\n\n`ifdef\tVERIFIC\n\tcover property (@(posedge S_AXI_ACLK)\n\t\tdisable iff (!S_AXI_ARESETN)\n\t\t// Accept a burst request for 4 beats\n\t\t(S_AXI_ARVALID && S_AXI_ARREADY && (S_AXI_ARLEN == 3)\n\t\t\t##1 S_AXI_ARVALID [*3]) [*3]\n\t\t##1 1 [*0:12]\n\t\t// The return to idle\n\t\t##1 (!S_AXI_ARVALID && !o_rd && !rskd_valid && !S_AXI_RVALID)\n\t\t);\n`endif\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// \"Careless\" assumptions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// }}}\n`endif\n// }}}",
            "endmodule `ifndef\tYOSYS\n`default_nettype",
            "wire `endif"
        ]
    },
    {
        "file_name": "axilscope.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axilscope.v",
        "chunks": [
            "logic analyzer.\n//\tThe general operation is such that this 'scope' can record and report\n//\ton any 32 bit value transiting through the FPGA.  Once started and\n//\treset, the scope records a copy of the",
            "input data every time the clock\n//\tticks with the circuit enabled.  That is, it records these values up\n//\tuntil the trigger.  Once the trigger goes high, the scope will record\n//\tfor br_holdoff more counts before stopping.  Values may then be read\n//\tfrom the buffer, oldest to most recent.  After reading, the scope may\n//\tthen be reset for another run.\n//\n//\tIn general, therefore, operation happens in this fashion:\n//\t\t1. A reset is issued.\n//\t\t2. Recording starts, in a circular buffer, and continues until\n//\t\t3. The trigger line is asserted.\n//\t\t\tThe scope",
            "reg isters the asserted trigger by setting\n//\t\t\tthe 'o_triggered'",
            "output flag.\n//\t\t4. A counter then ticks until the last value is written\n//\t\t\tThe scope",
            "reg isters that it has stopped recording by\n//\t\t\tsetting the 'o_stopped'",
            "output flag.\n//\t\t5. The scope recording is then paused until the next reset.\n//\t\t6. While stopped, the CPU can read the data from the scope\n//\t\t7. -- oldest to most recent\n//\t\t8. -- one value per i_rd&i_data_clk\n//\t\t9. Writes to the data",
            "reg ister reset the address to the\n//\t\t\tbeginning of the buffer\n//\n//\tAlthough the data width DW is",
            "parameter ized, it is not very changable,\n//\tsince the width is tied to the width of the data bus, as is the\n//\tcontrol word.  Therefore changing the data width would require changing\n//\tthe interface.  It's doable, but it would be a change to the interface.\n//\n//\tThe SYNCHRONOUS",
            "parameter turns on and off meta-stability\n//\tsynchronization.  Ideally a wishbone scope able to handle one or two\n//\tclocks would have a changing number of ports as this SYNCHRONOUS\n//",
            "parameter changed.  Other than running another script to modify\n//\tthis, I don't know how to do that so ... we'll just leave it running\n//\toff of two clocks or not.\n//\n//\n//\tInternal to this routine,",
            "reg isters and",
            "wire s are named with one of the\n//\tfollowing prefixes:\n//\n//\ti_\tAn",
            "input port to the routine\n//\to_\tAn",
            "output port of the routine\n//\tbr_\tA",
            "reg ister, controlled by the bus clock\n//\tdr_\tA",
            "reg ister, controlled by the data clock\n//\tbw_\tA",
            "wire /net, controlled by the bus clock\n//\tdw_\tA",
            "wire /net, controlled by the data clock\n//\n//\tAnd, of course, since AXI wants to be particular about their port\n//\tnaming conventions, anything beginning with\n//\n//\tS_AXI_\n//\n//\tis a signal associated with this function as an AXI slave.\n//\t\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2015-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype\tnone\n// }}}",
            "module axilscope #(\n\t\t// {{{",
            "parameter [4:0]\tLGMEM = 5'd10,",
            "parameter SYNCHRONOUS=1,",
            "parameter HOLDOFFBITS = 20,",
            "parameter [(HOLDOFFBITS-1):0]\tDEFAULT_HOLDOFF\n\t\t\t\t\t\t= ((1<<(LGMEM-1))-4),",
            "localparam BUSW = 32,\n\t\t//\n\t\t// Width of S_AXI data bus",
            "localparam integer C_S_AXI_DATA_WIDTH\t= 32,\n\t\t// Width of S_AXI address bus",
            "parameter integer C_S_AXI_ADDR_WIDTH\t= 3,",
            "localparam ADDR_LSBS = $clog2(C_S_AXI_DATA_WIDTH)-3\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire i_data_clk, // The data clock, can be set to ACLK",
            "input ",
            "wire i_ce,\t// = '1' when recordable data is present",
            "input ",
            "wire i_trigger,// = '1' when interesting event hapns",
            "input ",
            "wire [31:0]\ti_data,",
            "output ",
            "wire o_interrupt,\t// ='1' when scope has stopped\n\t\t//\n\t\t// Global Clock Signal",
            "input ",
            "wire S_AXI_ACLK,\n\t\t// Global Reset Signal. This Signal is Active LOW",
            "input ",
            "wire S_AXI_ARESETN,\n\t\t// Write address (issued by master, acceped by Slave)",
            "input ",
            "wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR,\n\t\t// Write channel Protection type. This signal indicates the\n    \t\t// privilege and security level of the transaction, and whether\n    \t\t// the transaction is a data access or an instruction access.",
            "input ",
            "wire [2 : 0] S_AXI_AWPROT,\n\t\t// Write address valid. This signal indicates that the master\n    \t\t// signaling valid write address and control information.",
            "input ",
            "wire S_AXI_AWVALID,\n\t\t// Write address ready. This signal indicates that the slave\n    \t\t// is ready to accept an address and associated control signals.",
            "output ",
            "wire S_AXI_AWREADY,\n\t\t// Write data (issued by master, acceped by Slave)",
            "input ",
            "wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA,\n\t\t// Write strobes. This signal indicates which byte lanes hold\n    \t\t// valid data. There is one write strobe bit for each eight\n    \t\t// bits of the write data bus.",
            "input ",
            "wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB,\n\t\t// Write valid. This signal indicates that valid write\n    \t\t// data and strobes are available.",
            "input ",
            "wire S_AXI_WVALID,\n\t\t// Write ready. This signal indicates that the slave\n    \t\t// can accept the write data.",
            "output ",
            "wire S_AXI_WREADY,\n\t\t// Write response. This signal indicates the status\n    \t\t// of the write transaction.",
            "output ",
            "wire [1 : 0] S_AXI_BRESP,\n\t\t// Write response valid. This signal indicates that the channel\n    \t\t// is signaling a valid write response.",
            "output ",
            "wire S_AXI_BVALID,\n\t\t// Response ready. This signal indicates that the master\n    \t\t// can accept a write response.",
            "input ",
            "wire S_AXI_BREADY,\n\t\t// Read address (issued by master, acceped by Slave)",
            "input ",
            "wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR,\n\t\t// Protection type. This signal indicates the privilege\n    \t\t// and security level of the transaction, and whether the\n    \t\t// transaction is a data access or an instruction access.",
            "input ",
            "wire [2 : 0] S_AXI_ARPROT,\n\t\t// Read address valid. This signal indicates that the channel\n    \t\t// is signaling valid read address and control information.",
            "input ",
            "wire S_AXI_ARVALID,\n\t\t// Read address ready. This signal indicates that the slave is\n    \t\t// ready to accept an address and associated control signals.",
            "output ",
            "wire S_AXI_ARREADY,\n\t\t// Read data (issued by slave)",
            "output ",
            "wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA,\n\t\t// Read response. This signal indicates the status of the\n    \t\t// read transfer.",
            "output ",
            "wire [1 : 0] S_AXI_RRESP,\n\t\t// Read valid. This signal indicates that the channel is\n    \t\t// signaling the required read data.",
            "output ",
            "wire S_AXI_RVALID,\n\t\t// Read ready. This signal indicates that the master can\n    \t\t// accept the read data and response information.",
            "input ",
            "wire S_AXI_RREADY\n\t\t// }}}\n\t);\n\n\t// Signal declarations\n\t// {{{\n\t// AXI4LITE signals",
            "reg [C_S_AXI_ADDR_WIDTH-1 : 0] \taxi_awaddr;",
            "reg axi_awready;",
            "reg axi_wready;",
            "reg [C_S_AXI_DATA_WIDTH-1:0]\taxi_wdata;\n\t//",
            "reg [1 : 0] \taxi_bresp;",
            "reg axi_bvalid;\n\t//",
            "reg [C_S_AXI_ADDR_WIDTH-1 : 0] \taxi_araddr;",
            "reg axi_arready;\n\t//",
            "reg [1 : 0] \taxi_rresp;\n\n\t// Pseudo bus signals",
            "wire bus_clock;",
            "reg read_from_data;",
            "wire write_stb;",
            "wire write_to_control;",
            "reg [1:0]\tread_address;\n\t//",
            "reg read_address;",
            "wire [31:0]\t\ti_bus_data;",
            "reg [31:0]\t\to_bus_data;\n\n\t//",
            "reg [(LGMEM-1):0]\traddr, waddr;",
            "reg [(BUSW-1):0]\tmem[0:((1<<LGMEM)-1)];",
            "wire bw_reset_request, bw_manual_trigger,\n\t\t\t\tbw_disable_trigger, bw_reset_complete;",
            "reg [2:0]\t\tbr_config;",
            "reg [(HOLDOFFBITS-1):0]\tbr_holdoff;",
            "wire dw_reset, dw_manual_trigger, dw_disable_trigger;",
            "reg dr_triggered, dr_primed;",
            "wire dw_trigger;",
            "reg dr_stopped;\n\n\t(* ASYNC_REG=\"TRUE\" *)",
            "reg [(HOLDOFFBITS-1):0]\tcounter;",
            "localparam STOPDELAY = 1;\t// Calibrated value--don't change this",
            "wire [(BUSW-1):0]\twr_piped_data;",
            "wire bw_stopped, bw_triggered, bw_primed;",
            "reg [(LGMEM-1):0]\tthis_addr;",
            "reg [31:0]\t\tnxt_mem;",
            "wire [19:0]\t\tfull_holdoff;",
            "wire [4:0]\t\tbw_lgmem;",
            "reg br_level_interrupt;\n`ifdef\tFORMAL\n\t(* gclk *)",
            "reg gbl_clk;",
            "reg f_past_valid_bus, f_past_valid_gbl, f_past_valid_data;\n`endif\t// FORMAL",
            "wire i_reset;",
            "reg valid_write_data, valid_write_address,\n\t\t\twrite_response_stall;",
            "reg [1:0]\trvalid;\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Decode and handle the bus signaling in a (somewhat) portable manner\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t//\n\tassign\ti_reset = !S_AXI_ARESETN;\n\n\talways @(*)\n\tbegin\n\t\tvalid_write_address = (S_AXI_AWVALID || !S_AXI_AWREADY);\n\t\tvalid_write_data    = (S_AXI_WVALID  || !S_AXI_WREADY);\n\t\twrite_response_stall= (S_AXI_BVALID  && !S_AXI_BREADY);\n\tend\n\n\tinitial\taxi_awready = 1'b1;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_awready <= 1'b1;\n\telse if (write_response_stall)\n\t\taxi_awready <= !valid_write_address;\n\telse if (valid_write_data)\n\t\taxi_awready <= 1'b1;\n\telse\n\t\taxi_awready <= !valid_write_address;\n\n\tinitial\taxi_wready = 1'b1;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_wready <= 1'b1;\n\telse if (write_response_stall)\n\t\taxi_wready <= !valid_write_data;\n\telse if (valid_write_address)\n\t\taxi_wready <= 1'b1;\n\telse\n\t\taxi_wready <= !valid_write_data;\n\n\talways @(posedge S_AXI_ACLK)\n\tif (S_AXI_WREADY)\n\t\taxi_wdata <= S_AXI_WDATA;\n\n\tassign\tS_AXI_AWREADY = axi_awready;\n\tassign\tS_AXI_WREADY  = axi_wready;\n\n\talways @(posedge S_AXI_ACLK)\n\tif ((S_AXI_AWVALID)&&(S_AXI_AWREADY))\n\t\taxi_awaddr <= S_AXI_AWADDR;\n\n\tinitial\taxi_bvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_reset)\n\t\taxi_bvalid <= 0;\n\telse if (write_stb)\n\t\taxi_bvalid <= 1'b1;\n\telse if (S_AXI_BREADY)\n\t\taxi_bvalid <= 1'b0;\n\n\tassign\tS_AXI_BRESP = 2'b00;\t// An 'OKAY' response\n\tassign\tS_AXI_BVALID= axi_bvalid;\n\n\tassign\twrite_stb = valid_write_data && valid_write_address\n\t\t\t\t&& !write_response_stall;\n\n\tinitial\taxi_arready = 1'b1;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_reset)\n\t\taxi_arready <= 1'b1;\n\telse if ((&rvalid) && (S_AXI_RVALID && !S_AXI_RREADY))\n\t\taxi_arready <= axi_arready && !S_AXI_ARVALID;\n\telse\n\t\taxi_arready <= 1'b1;\n\n\t// always @(posedge S_AXI_ACLK)\n\t// if (axi_arready && S_AXI_ARVALID)\n\t//\taxi_araddr <= S_AXI_ARADDR;\n\n\tassign\tS_AXI_ARREADY = axi_arready;\n\n\tinitial\trvalid = 2'b00;\n\talways @(posedge S_AXI_ACLK)\n\tif (i_reset)\n\t\trvalid <= 2'b00;\n\telse begin\n\t\tif (!rvalid[0] || !rvalid[1] || S_AXI_RREADY)\n\t\t\trvalid[0] <= S_AXI_ARVALID || !axi_arready;\n\n\t\tif (rvalid[0])\n\t\t\trvalid[1] <= 1'b1;\n\t\telse if (S_AXI_RREADY)\n\t\t\trvalid[1] <= 1'b0;\n\tend\n\n\tassign\tS_AXI_RVALID = rvalid[1];\n\tassign\tS_AXI_RRESP  = 2'b00;\n\n\n\t///////////////////////////////////////////////////\n\t//\n\t// Final simplification of the AXI code\n\t//\n\t///////////////////////////////////////////////////\n\t//\n\t// Now that we've provided all of the bus signaling\n\t// above, can we make any sense of it?\n\t//\n\t// The following",
            "wire s are here to provide some\n\t// simplification of the complex bus protocol.  In\n\t// particular, are we reading or writing during this\n\t// clock?  The two *should* be mutually exclusive\n\t// (i.e., you *shouldn't* be able to both read and\n\t// write on the same clock) ... but Xilinx's default\n\t// implementation does nothing to ensure that this\n\t// would be the case.\n\t//\n\t// From here on down, Gisselquist Technology, LLC,\n\t// claims a copyright on the code.\n\t//\n\tassign\tbus_clock = S_AXI_ACLK;\n\n\tassign\twrite_to_control = (write_stb)\n\t\t\t&&(axi_awready ? !S_AXI_AWADDR[ADDR_LSBS]\n\t\t\t\t\t: !axi_awaddr[ADDR_LSBS]);\n\n\talways @(posedge bus_clock)\n\tbegin\n\t\tif (S_AXI_ARVALID && S_AXI_ARREADY)\n\t\t\tread_address[0] <= S_AXI_ARADDR[ADDR_LSBS];\n\t\tif (!rvalid[0] || !rvalid[1] || S_AXI_RREADY)\n\t\tbegin\n\t\t\tif (S_AXI_ARREADY)\n\t\t\t\tread_address[1] <= S_AXI_ARADDR[ADDR_LSBS];\n\t\t\telse\n\t\t\t\tread_address[1] <= read_address[0];\n\t\tend\n\tend\n\n\talways @(*)\n\tbegin\n\t\tif (S_AXI_ARREADY)\n\t\t\tread_from_data = S_AXI_ARVALID\n\t\t\t\t\t\t&& S_AXI_ARADDR[ADDR_LSBS];\n\t\telse\n\t\t\tread_from_data = read_address[0];\n\n\t\tif (rvalid[0] && rvalid[1] && !S_AXI_RREADY)\n\t\t\tread_from_data = 0;\n\tend\n\n\tassign\ti_bus_data = (S_AXI_WREADY ? S_AXI_WDATA : axi_wdata);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Our status/config",
            "reg ister\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Now that we've finished reading/writing from the\n\t// bus, ... or at least acknowledging reads and\n\t// writes from and to the bus--even if they haven't\n\t// happened yet, now we implement our actual scope.\n\t// This includes implementing the actual reads/writes\n\t// from/to the bus.\n\t//\n\t// From here on down, is the heart of the scope itself.\n\t//\n\tinitial\tbr_config = 3'b0;\n\tinitial\tbr_holdoff = DEFAULT_HOLDOFF;\n\talways @(posedge bus_clock)\n\tbegin\n\t\tif (write_to_control)\n\t\tbegin\n\t\t\tbr_config[1:0] <= {\n\t\t\t\ti_bus_data[27],\n\t\t\t\ti_bus_data[26] };\n\t\t\tif (!i_bus_data[31] && br_config[2])\n\t\t\t\tbr_holdoff <= i_bus_data[(HOLDOFFBITS-1):0];\n\t\tend\n\n\t\t//\n\t\t// Reset",
            "logic if (bw_reset_complete)\n\t\t\t// Clear the reset request,",
            "reg ardless of the write\n\t\t\tbr_config[2] <= 1'b1;\n\t\telse if (!br_config[2])\n\t\t\t// Reset request is already pending--don't change it\n\t\t\tbr_config[2] <= 1'b0;\n\t\telse if (write_to_control && !i_bus_data[31])\n\t\t\t// Initiate a new reset request\n\t\t\t//   Note that we won't initiate a new reset request\n\t\t\t//   while one is already pending.  Once the pending\n\t\t\t//   one completes we'll be in the reset state anyway\n\t\t\tbr_config[2] <= 1'b0;\n\n\t\tif (i_reset)\n\t\t\tbr_config[2] <= 1'b0;\n\tend\n\tassign\tbw_reset_request   = (!br_config[2]);\n\tassign\tbw_manual_trigger  = (br_config[1]);\n\tassign\tbw_disable_trigger = (br_config[0]);\n\n\tgenerate\n\tif (SYNCHRONOUS > 0)\n\tbegin : GEN_SYNCHRONOUS\n\t\tassign\tdw_reset = bw_reset_request;\n\t\tassign\tdw_manual_trigger = bw_manual_trigger;\n\t\tassign\tdw_disable_trigger = bw_disable_trigger;\n\t\tassign\tbw_reset_complete = bw_reset_request;\n\tend else begin : GEN_ASYNC",
            "reg r_reset_complete;\n\t\t(* ASYNC_REG = \"TRUE\" *)",
            "reg [2:0]\tq_iflags, r_iflags;\n\n\t\t// Resets are synchronous to the bus clock, not the data clock\n\t\t// so do a clock transfer here\n\t\tinitial\t{ q_iflags, r_iflags } = 6'h0;\n\t\tinitial\tr_reset_complete = 1'b0;\n\t\talways @(posedge i_data_clk or posedge i_reset)\n\t\tif (i_reset)\n\t\tbegin\n\t\t\t{ q_iflags, r_iflags } <= 6'h0;\n\t\t\tr_reset_complete <= 1'b0;\n\t\tend else begin\n\t\t\tq_iflags <= { bw_reset_request, bw_manual_trigger, bw_disable_trigger };\n\t\t\tr_iflags <= q_iflags;\n\t\t\tr_reset_complete <= (dw_reset);\n\t\tend\n\n\t\tassign\tdw_reset = r_iflags[2];\n\t\tassign\tdw_manual_trigger = r_iflags[1];\n\t\tassign\tdw_disable_trigger = r_iflags[0];\n\n\t\t(* ASYNC_REG = \"TRUE\" *)",
            "reg q_reset_complete,\n\t\t\t\t\t\tqq_reset_complete;\n\t\t// Pass an acknowledgement back from the data clock to the bus\n\t\t// clock that the reset has been accomplished\n\t\tinitial\tq_reset_complete = 1'b0;\n\t\tinitial\tqq_reset_complete = 1'b0;\n\t\talways @(posedge bus_clock or posedge i_reset)\n\t\tif (i_reset)\n\t\tbegin\n\t\t\tq_reset_complete  <= 1'b0;\n\t\t\tqq_reset_complete <= 1'b0;\n\t\tend else begin\n\t\t\tq_reset_complete  <= r_reset_complete;\n\t\t\tqq_reset_complete <= q_reset_complete;\n\t\tend\n\n\t\tassign bw_reset_complete = qq_reset_complete;\n\n`ifdef\tFORMAL\n\t\talways @(posedge gbl_clk)\n\t\tif (f_past_valid_data)\n\t\tbegin\n\t\t\tif ($rose(r_reset_complete))\n\t\t\t\tassert(bw_reset_request);\n\t\tend\n\n\t\talways @(*)\n\t\tcase({ bw_reset_request, q_iflags[2], dw_reset, q_reset_complete, qq_reset_complete })\n\t\t5'h00: begin end\n\t\t5'h10: begin end\n\t\t5'h18: begin end\n\t\t5'h1c: begin end\n\t\t5'h1e: begin end\n\t\t5'h1f: begin end\n\t\t5'h0f: begin end\n\t\t5'h07: begin end\n\t\t5'h03: begin end\n\t\t5'h01: begin end\n\t\tdefault: assert(0);\n\t\tendcase\n`endif\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Set up the trigger\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// dw_trigger -- trigger",
            "wire , defined on the data clock\n\t// {{{\n\t// Write with the i_clk, or",
            "input clock.  All",
            "output s read with the\n\t// bus clock, or bus_clock  as we've called it here.\n\tassign\tdw_trigger = (dr_primed)&&(\n\t\t\t\t((i_trigger)&&(!dw_disable_trigger))\n\t\t\t\t||(dw_manual_trigger));\n\t// }}}\n\n\t// dr_triggered\n\t// {{{\n\tinitial\tdr_triggered = 1'b0;\n\talways @(posedge i_data_clk)\n\tif (dw_reset)\n\t\tdr_triggered <= 1'b0;\n\telse if ((i_ce)&&(dw_trigger))\n\t\tdr_triggered <= 1'b1;\n\t// }}}\n\n\t//\n\t// Determine when memory is full and capture is complete\n\t//\n\t// Writes take place on the data clock\n\n\t// counter\n\t// {{{\n\t// The counter is unsigned\n\tinitial\tcounter = 0;\n\talways @(posedge i_data_clk)\n\tif (dw_reset)\n\t\tcounter <= 0;\n\telse if ((i_ce)&&(dr_triggered)&&(!dr_stopped))\n\t\tcounter <= counter + 1'b1;\n`ifdef\tFORMAL\n\talways @(*)\n\tif (!dw_reset && !bw_reset_request)\n\t\tassert(counter <= br_holdoff+1'b1);\n\talways @(posedge i_data_clk)\n\t\tassume(!(&br_holdoff));\n\talways @(posedge i_data_clk)\n\tif (!dr_triggered)\n\t\tassert(counter == 0);\n`endif\n\t// }}}\n\n\t// dr_stopped\n\t// {{{\n\tinitial\tdr_stopped = 1'b0;\n\talways @(posedge i_data_clk)\n\tif ((!dr_triggered)||(dw_reset))\n\t\tdr_stopped <= 1'b0;\n\telse if (!dr_stopped)\n\tbegin\n\t\tif (HOLDOFFBITS > 1) // if (i_ce)\n\t\t\tdr_stopped <= (counter >= br_holdoff);\n\t\telse if (HOLDOFFBITS <= 1)\n\t\t\tdr_stopped <= ((i_ce)&&(dw_trigger));\n\tend\n\t// }}}\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Write to memory\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\n\t//\n\t//\tActually do our writes to memory.  Record, via 'primed' when\n\t//\tthe memory is full.\n\t//\n\t//\tThe 'waddr' address that we are using really crosses two clock\n\t//\tdomains.  While writing and changing, it's in the data clock\n\t//\tdomain.  Once stopped, it becomes part of the bus clock domain.\n\t//\tThe clock transfer on the stopped line handles the clock\n\t//\ttransfer for these signals.\n\t//\n\n\t// waddr, dr_primed\n\t// {{{\n\tinitial\twaddr = {(LGMEM){1'b0}};\n\tinitial\tdr_primed = 1'b0;\n\talways @(posedge i_data_clk)\n\tif (dw_reset) // For simulation purposes, supply a valid value\n\tbegin\n\t\twaddr <= 0; // upon reset.\n\t\tdr_primed <= 1'b0;\n\tend else if (i_ce && !dr_stopped)\n\tbegin\n\t\t// mem[waddr] <= i_data;\n\t\twaddr <= waddr + {{(LGMEM-1){1'b0}},1'b1};\n\t\tif (!dr_primed)\n\t\t\tdr_primed <= (&waddr);\n\tend\n\t// }}}\n\n\t// wr_piped_data -- delay data to match the trigger\n\t// {{{\n\t// Delay the incoming data so that we can get our trigger\n\t//",
            "logic to line up with the data.  The goal is to have a\n\t// hold off of zero place the trigger in the last memory\n\t// address.\n\tgenerate\n\tif (STOPDELAY == 0)\n\tbegin : NO_STOPDLY\n\t\t// No delay ... just assign the",
            "wire s to our",
            "input lines\n\t\tassign\twr_piped_data = i_data;\n\tend else if (STOPDELAY == 1)\n\tbegin : GEN_ONE_STOPDLY\n\t\t//\n\t\t// Delay by one means just",
            "reg ister this once",
            "reg [(BUSW-1):0]\tdata_pipe;\n\t\talways @(posedge i_data_clk)\n\t\tif (i_ce)\n\t\t\tdata_pipe <= i_data;\n\n\t\tassign\twr_piped_data = data_pipe;\n\tend else begin : GEN_STOPDELAY\n\t\t// Arbitrary delay ... use a longer pipe",
            "reg [(STOPDELAY*BUSW-1):0]\tdata_pipe;\n\n\t\talways @(posedge i_data_clk)\n\t\tif (i_ce)\n\t\t\tdata_pipe <= { data_pipe[((STOPDELAY-1)*BUSW-1):0], i_data };\n\t\tassign\twr_piped_data = { data_pipe[(STOPDELAY*BUSW-1):((STOPDELAY-1)*BUSW)] };\n\tend endgenerate\n\t// }}}\n\n\t// mem[] <= wr_piped_data\n\t// {{{\n\talways @(posedge i_data_clk)\n\tif ((i_ce)&&(!dr_stopped))\n\t\tmem[waddr] <= wr_piped_data;\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Move the status signals back to the bus clock\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\tgenerate if (SYNCHRONOUS > 0)\n\tbegin : SYNCHRONOUS_RETURN\n\t\tassign\tbw_stopped   = dr_stopped;\n\t\tassign\tbw_triggered = dr_triggered;\n\t\tassign\tbw_primed    = dr_primed;\n\tend else begin : ASYNC_STATUS\n\t\t// {{{\n\t\t// These aren't a problem, since none of these are strobe\n\t\t// signals.  They goes from low to high, and then stays high\n\t\t// for many clocks.  Swapping is thus easy--two flip flops to\n\t\t// protect against meta-stability and we're done.\n\t\t//\n\t\t(* ASYNC_REG = \"TRUE\" *)",
            "reg [2:0]\tq_oflags;",
            "reg [2:0]\tr_oflags;\n\t\tinitial\tq_oflags = 3'h0;\n\t\tinitial\tr_oflags = 3'h0;\n\t\talways @(posedge bus_clock)\n\t\tif (bw_reset_request)\n\t\tbegin\n\t\t\tq_oflags <= 3'h0;\n\t\t\tr_oflags <= 3'h0;\n\t\tend else begin\n\t\t\tq_oflags <= { dr_stopped, dr_triggered, dr_primed };\n\t\t\tr_oflags <= q_oflags;\n\t\tend\n\n\t\tassign\tbw_stopped   = r_oflags[2];\n\t\tassign\tbw_triggered = r_oflags[1];\n\t\tassign\tbw_primed    = r_oflags[0];\n\t\t// }}}\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\tif (!bw_reset_request)\n\t\tbegin\n\t\t\tif (bw_primed)\n\t\t\t\tassert(q_oflags[0] && dr_primed);\n\t\t\telse if (q_oflags[0])\n\t\t\t\tassert(dr_primed);\n\n\t\t\tif (bw_triggered)\n\t\t\t\tassert(q_oflags[1] && dr_triggered);\n\t\t\telse if (q_oflags[1])\n\t\t\t\tassert(dr_triggered);\n\n\t\t\tif (bw_stopped)\n\t\t\t\tassert(q_oflags[2] && dr_stopped);\n\t\t\telse if (q_oflags[2])\n\t\t\t\tassert(dr_stopped);\n\t\tend\n\t\t\n`endif\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read from the memory, using the bus clock.  Otherwise respond to bus\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// Reads use the bus clock\n\tinitial\traddr = 0;\n\talways @(posedge bus_clock)\n\tbegin\n\t\tif ((bw_reset_request)||(write_to_control))\n\t\t\traddr <= 0;\n\t\telse if ((read_from_data)&&(bw_stopped))\n\t\t\traddr <= raddr + 1'b1; // Data read, when stopped\n\tend\n\n\talways @(posedge bus_clock)\n\tif (read_from_data)\n\t\tthis_addr <= raddr + waddr + 1'b1;\n\telse\n\t\tthis_addr <= raddr + waddr;\n\n\talways @(posedge bus_clock)\n\tif (read_from_data)\n\t\tnxt_mem <= mem[this_addr];\n\n\t// holdoff sub-",
            "reg ister\n\t// {{{\n\tassign full_holdoff[(HOLDOFFBITS-1):0] = br_holdoff;\n\tgenerate if (HOLDOFFBITS < 20)\n\tbegin : GEN_FULL_HOLDOFF\n\t\tassign full_holdoff[19:(HOLDOFFBITS)] = 0;\n\tend endgenerate\n\t// }}}\n\n\tassign\t\tbw_lgmem = LGMEM;\n\n\t// Bus read\n\t// {{{\n\talways @(posedge bus_clock)\n\tif (rvalid[0] && (!S_AXI_RVALID || S_AXI_RREADY))\n\tbegin\n\t\tif (!read_address[1]) // Control",
            "reg ister read\n\t\t\to_bus_data <= { bw_reset_request,\n\t\t\t\t\tbw_stopped,\n\t\t\t\t\tbw_triggered,\n\t\t\t\t\tbw_primed,\n\t\t\t\t\tbw_manual_trigger,\n\t\t\t\t\tbw_disable_trigger,\n\t\t\t\t\t(raddr == {(LGMEM){1'b0}}),\n\t\t\t\t\tbw_lgmem,\n\t\t\t\t\tfull_holdoff  };\n\t\telse if (!bw_stopped) // read, prior to stopping\n\t\t\t//\n\t\t\t// *WARNING*: THIS READ IS NOT PROTECTED FROM\n\t\t\t// ASYNCHRONOUS COHERENCE ISSUES!\n\t\t\t//\n\t\t\to_bus_data <= i_data;\n\t\telse // if (i_wb_addr) // Read from FIFO memory\n\t\t\to_bus_data <= nxt_mem; // mem[raddr+waddr];\n\tend\n\t// }}}\n\n\tassign\tS_AXI_RDATA = o_bus_data;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Interrupt generation\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tinitial\tbr_level_interrupt = 1'b0;\n\talways @(posedge bus_clock)\n\tif ((bw_reset_complete)||(bw_reset_request))\n\t\tbr_level_interrupt<= 1'b0;\n\telse\n\t\tbr_level_interrupt<= (bw_stopped)&&(!bw_disable_trigger);\n\n\tassign\to_interrupt = (bw_stopped)&&(!bw_disable_trigger)\n\t\t\t\t\t&&(!br_level_interrupt);\n\t// }}}\n\n\t// Make verilator happy\n\t// {{{\n\t// verilator lint_off UNUSED\n\t// Make verilator happy",
            "wire unused;\n\tassign unused = &{ 1'b0, S_AXI_WSTRB, S_AXI_ARPROT, S_AXI_AWPROT,\n\t\taxi_awaddr[ADDR_LSBS-1:0],\n\t\ti_bus_data[30:28], i_bus_data[25:0] };\n\t// verilator lint_on UNUSED\n\t// }}}\n`ifdef\tFORMAL\n\tgenerate if (SYNCHRONOUS)\n\tbegin : ASSUME_CLK\n\n\t\talways @(*)\n\t\t\tassume(i_data_clk == S_AXI_ACLK);\n\n\tend else begin : ASSUME_ASYN",
            "localparam CKSTEP_BITS = 3;",
            "localparam [CKSTEP_BITS-1:0]\n\t\t\t\tMAX_STEP = { 1'b0, {(CKSTEP_BITS-1){1'b1}} };\n\n\t\t// \"artificially\" generate two clocks\n\t\t(* anyconst *)",
            "wire [CKSTEP_BITS-1:0] f_data_step, f_bus_step;",
            "reg [CKSTEP_BITS-1:0]\tf_data_count, f_bus_count;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tassume(f_data_step > 0);\n\t\t\tassume(f_bus_step  > 0);\n\t\t\tassume(f_data_step <= MAX_STEP);\n\t\t\tassume(f_bus_step  <= MAX_STEP);\n\n\t\t\tassume((f_data_step == MAX_STEP)\n\t\t\t\t||(f_bus_step == MAX_STEP));\n\t\tend\n\n\t\talways @(posedge gbl_clk)\n\t\tbegin\n\t\t\tf_data_count <= f_data_count + f_data_step;\n\t\t\tf_bus_count  <= f_bus_count  + f_bus_step;\n\n\t\t\tassume(i_data_clk  == f_data_count[CKSTEP_BITS-1]);\n\t\t\tassume(bus_clock   == f_bus_count[CKSTEP_BITS-1]);\n\t\tend\n\n\t\talways @(posedge gbl_clk)\n\t\tif (!$rose(i_data_clk))\n\t\tbegin\n\t\t\tassume($stable(i_trigger));\n\t\t\tassume($stable(i_data));\n\t\tend\n\n\t\talways @(posedge gbl_clk)\n\t\tif (!$rose(S_AXI_ACLK))\n\t\tbegin\n\t\t\tassume($stable(S_AXI_ARESETN));\n\t\t\t//\n\t\t\tassume($stable(S_AXI_AWADDR));\n\t\t\tassume($stable(S_AXI_AWPROT));\n\t\t\tassume($stable(S_AXI_AWVALID));\n\t\t\t//\n\t\t\tassume($stable(S_AXI_WDATA));\n\t\t\tassume($stable(S_AXI_WSTRB));\n\t\t\tassume($stable(S_AXI_WVALID));\n\t\t\t//\n\t\t\tassume($stable(S_AXI_BREADY));\n\t\t\t//\n\t\t\tassume($stable(S_AXI_ARADDR));\n\t\t\tassume($stable(S_AXI_ARPROT));\n\t\t\tassume($stable(S_AXI_ARVALID));\n\t\t\t//\n\t\t\tassume($stable(S_AXI_RREADY));\n\t\t\t//\n\t\tend\n\n\t\talways @(posedge gbl_clk)\n\t\tif (!$rose(i_data_clk))\n\t\tbegin\n\t\t\tassume($stable(i_ce));\n\t\t\tassume($stable(i_trigger));\n\t\t\tassume($stable(i_data));\n\t\tend\n\n\t\talways @(*)\n\t\tif (!dw_reset && !bw_reset_request)\n\t\tbegin\n\t\t\tif (bw_triggered)\n\t\t\t\tassert(dr_triggered);\n\t\t\tif (bw_primed)\n\t\t\t\tassert(dr_primed);\n\t\t\tif (bw_stopped)\n\t\t\t\tassert(dr_stopped);\n\t\tend\n\tend endgenerate\n\n\tinitial\tf_past_valid_bus = 1'b0;\n\talways @(posedge S_AXI_ACLK)\n\t\tf_past_valid_bus <= 1'b1;\n\n\tgenerate if (!SYNCHRONOUS)\n\tbegin\n\t\tinitial { f_past_valid_gbl, f_past_valid_data }= 2'b0;\n\t\talways @(posedge gbl_clk)\n\t\t\tf_past_valid_gbl <= 1'b1;\n\n\t\talways @(posedge i_data_clk)\n\t\t\tf_past_valid_data = 1'b1;\n\n\t\talways @(posedge gbl_clk)\n\t\tif (f_past_valid_gbl && !$rose(bus_clock))\n\t\t\tassert($stable(o_interrupt));\n\n\t\talways @(posedge gbl_clk)\n\t\tif ((f_past_valid_gbl)&&(!$rose(S_AXI_ACLK)))\n\t\tbegin\n\t\t\tassert($stable(S_AXI_AWREADY));\n\t\t\tassert($stable(S_AXI_ARREADY));\n\t\t\tassert($stable(S_AXI_RDATA));\n\t\t\tassert($stable(S_AXI_RRESP));\n\t\t\tassert($stable(S_AXI_RVALID));\n\t\t\tassert($stable(S_AXI_WREADY));\n\t\t\tassert($stable(S_AXI_BRESP));\n\t\t\tassert($stable(S_AXI_BVALID));\n\t\tend\n\n\tend else begin\n\n\t\talways @(*)\n\t\t\tf_past_valid_data = f_past_valid_bus;\n\t\talways @(*)\n\t\t\tf_past_valid_gbl  = f_past_valid_bus;\n\n\tend endgenerate",
            "localparam F_LGDEPTH = 5;",
            "wire [F_LGDEPTH-1:0]\tf_axi_rd_outstanding,\n\t\t\t\tf_axi_wr_outstanding,\n\t\t\t\tf_axi_awr_outstanding;\n\n\tfaxil_slave #(\n\t\t// .C_S_AXI_DATA_WIDTH(C_S_AXI_DATA_WIDTH),\n\t\t// Width of S_AXI address bus\n\t\t.C_AXI_ADDR_WIDTH(C_S_AXI_ADDR_WIDTH),\n\t\t.F_LGDEPTH(F_LGDEPTH),\n\t\t.F_OPT_HAS_CACHE(1'b0),\n\t\t// .F_OPT_CLK2FFLOGIC(!SYNCHRONOUS),\n\t\t.F_AXI_MAXWAIT(5'h6),\n\t\t.F_AXI_MAXDELAY(5'h6)\n\t\t) faxil_slave(\n\t\t\t.i_clk(S_AXI_ACLK),\n\t\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t\t//\n\t\t\t.i_axi_awvalid(S_AXI_AWVALID),\n\t\t\t.i_axi_awready(S_AXI_AWREADY),\n\t\t\t.i_axi_awaddr(S_AXI_AWADDR),\n\t\t\t.i_axi_awprot(S_AXI_AWPROT),\n\t\t\t//\n\t\t\t.i_axi_wdata(S_AXI_WDATA),\n\t\t\t.i_axi_wstrb(S_AXI_WSTRB),\n\t\t\t.i_axi_wvalid(S_AXI_WVALID),\n\t\t\t.i_axi_wready(S_AXI_WREADY),\n\t\t\t//\n\t\t\t.i_axi_bvalid(S_AXI_BVALID),\n\t\t\t.i_axi_bready(S_AXI_BREADY),\n\t\t\t.i_axi_bresp(S_AXI_BRESP),\n\t\t\t//\n\t\t\t.i_axi_arvalid(S_AXI_ARVALID),\n\t\t\t.i_axi_arready(S_AXI_ARREADY),\n\t\t\t.i_axi_araddr(S_AXI_ARADDR),\n\t\t\t.i_axi_arprot(S_AXI_ARPROT),\n\t\t\t//\n\t\t\t.i_axi_rvalid(S_AXI_RVALID),\n\t\t\t.i_axi_rready(S_AXI_RREADY),\n\t\t\t.i_axi_rdata(S_AXI_RDATA),\n\t\t\t.i_axi_rresp(S_AXI_RRESP),\n\t\t\t//\n\t\t\t.f_axi_rd_outstanding(f_axi_rd_outstanding),\n\t\t\t.f_axi_wr_outstanding(f_axi_wr_outstanding),\n\t\t\t.f_axi_awr_outstanding(f_axi_awr_outstanding));\n\n\talways @(*)\n\tif (S_AXI_ARESETN)\n\tbegin\n\t\tassert(f_axi_awr_outstanding == (S_AXI_AWREADY ? 0:1)\n\t\t\t\t+ (S_AXI_BVALID ? 1:0));\n\t\tassert(f_axi_wr_outstanding == (S_AXI_WREADY ? 0:1)\n\t\t\t\t+ (S_AXI_BVALID ? 1:0));\n\n\t\tassert(f_axi_rd_outstanding == (axi_arready ? 0:1)\n\t\t\t\t+ (rvalid[0] ? 1:0) + (rvalid[1] ? 1:0));\n\tend\n\n\talways @(*)\n\tif (dr_triggered)\n\t\tassert(dr_primed);\n\n\talways @(*)\n\tif (dr_stopped)\n\t\tassert((dr_primed)&&(dr_triggered));\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t(* anyconst *)",
            "reg [(LGMEM-1):0]\tf_addr;",
            "reg [BUSW-1:0]\tf_data;",
            "reg f_filled,     f_nxtstopped, f_busstopped;",
            "reg [(LGMEM-1):0]\tf_busmemaddr, f_nxtaddr;",
            "reg [2:0]\t\tf_axi_addr;\n\n\tinitial\tf_filled = 1'b0;\n\talways @(posedge i_data_clk)\n\tif (dw_reset)\n\t\tf_filled <= 1'b0;\n\telse if ((i_ce)&&(!dr_stopped)&&(waddr == f_addr))\n\t\tf_filled <= 1'b1;\n\n\talways @(posedge i_data_clk)\n\tif (waddr > f_addr)\n\t\tassert(f_filled);\n\n\talways @(posedge i_data_clk)\n\tif (!f_filled)\n\t\tassert(!dr_primed);\n\n\talways @(posedge i_data_clk)\n\tif ((i_ce)&&(!dr_stopped)&&(waddr == f_addr))\n\t\tf_data <= wr_piped_data;\n\n\talways @(posedge i_data_clk)\n\tif (f_filled)\n\t\tassert(mem[f_addr] == f_data);\n\n\talways @(posedge bus_clock)\n\tif (f_past_valid_bus && $past(!bw_stopped))\n\t\tassert(raddr == 0);\n\n\talways @(posedge bus_clock)\n\tbegin\n\t\tif (!rvalid[0] || !rvalid[1] || S_AXI_RREADY)\n\t\t\tf_axi_addr[0] <= (S_AXI_ARREADY\n\t\t\t\t\t? S_AXI_ARADDR[ADDR_LSBS]\n\t\t\t\t\t: read_address[0]);\n\n\t\tif (!rvalid[1] || S_AXI_RREADY)\n\t\t\tf_axi_addr[1] <= f_axi_addr[0];\n\n\t\tif (f_past_valid_bus && !$past(read_from_data))\n\t\t\tassert(!$rose(rvalid[0] && f_axi_addr[0]));\n\t\tif (f_past_valid_bus && $past(!i_reset && read_from_data))\n\t\t\tassert(f_axi_addr[0] && rvalid[0]);\n\tend\n\n\talways @(*)\n\tif (rvalid[0])\n\t\tassert(f_axi_addr[0] == read_address[1]);\n\n\talways @(*)\n\tif (S_AXI_ARREADY && !S_AXI_ARVALID)\n\t\tassert(!read_from_data);\n\telse if (rvalid[0] && rvalid[1] && !S_AXI_RREADY)\n\t\tassert(!read_from_data);\n\telse if (!S_AXI_ARREADY)\n\t\tassert(read_from_data == read_address[0]);\n\telse if (S_AXI_ARVALID)\n\t\tassert(read_from_data == S_AXI_ARADDR[ADDR_LSBS]);\n\telse\n\t\tassert(!read_from_data);\n\n\tinitial\tf_nxtaddr = 0;\n\tinitial\tf_nxtstopped = 0;\n\talways @(posedge bus_clock)\n\tif (i_reset || bw_reset_request)\n\t\tf_nxtstopped <= 1'b0;\n\telse if (read_from_data)\n\t\tf_nxtstopped <= bw_stopped;\n\n\tinitial\tf_busstopped = 0;\n\talways @(posedge bus_clock)\n\tif (i_reset || bw_reset_request)\n\t\tf_busstopped <= 1'b0;\n\telse if (rvalid[0] && (!S_AXI_RVALID || S_AXI_RREADY))\n\t\tf_busstopped <= f_nxtstopped;\n\n\talways @(*)\n\tif (f_nxtstopped)\n\t\tassert(bw_stopped);\n\n\talways @(*)\n\tif (f_busstopped)\n\t\tassert(bw_stopped && f_nxtstopped);\n\n\talways @(posedge bus_clock)\n\tif (read_from_data)\n\t\tf_nxtaddr = this_addr;\n\n\talways @(posedge bus_clock)\n\tif (f_past_valid_bus && $past(f_past_valid_bus)\n\t\t&& $past(bw_stopped) && dr_stopped\n\t\t&& $past(bw_stopped && !write_to_control,2))\n\tbegin\n\t\tif ($past(read_from_data))\n\t\t\tassert(this_addr == $past(this_addr + 1'b1));\n\t\telse\n\t\t\tassert($stable(this_addr));\n\tend\n\n\talways @(*)\n\tif (!bw_reset_request && !dw_reset && rvalid[0]\n\t\t&& f_nxtstopped && f_nxtaddr == f_addr && f_axi_addr[0])\n\t\tassert(nxt_mem == mem[f_nxtaddr]);\n\n\talways @(posedge bus_clock)\n\tif (rvalid[0] && (!S_AXI_RVALID || S_AXI_RREADY))\n\t\tf_busmemaddr <= f_nxtaddr;\n\n\talways @(posedge bus_clock)\n\tif (f_past_valid_bus && $past(!i_reset && rvalid[0]\n\t\t\t&& !bw_reset_request\n\t\t\t&& (!S_AXI_RVALID || S_AXI_RREADY)\n\t\t\t&& f_axi_addr[0] && f_busstopped))\n\tbegin\n\t\tif (f_filled && f_busmemaddr == f_addr)\n\t\t\tassert(S_AXI_RDATA == f_data);\n\tend\n\n\talways @(*)\n\tif (S_AXI_RVALID && !f_axi_addr[1])\n\t\tassert(S_AXI_RDATA[24:20] == bw_lgmem);\n\n\talways @(*)\n\tif (dr_triggered)\n\t\tassert(dr_primed);\n\n\talways @(*)\n\tif (dr_stopped)\n\t\tassert(dr_triggered);\n\n`endif",
            "endmodule // `default_nettype",
            "wire "
        ]
    },
    {
        "file_name": "axiempty.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axiempty.v",
        "chunks": [
            "module axiempty #(\n\t\t// {{{",
            "parameter integer C_AXI_ID_WIDTH\t= 2,",
            "parameter integer C_AXI_DATA_WIDTH\t= 32,\n\t\t// Verilator lint_off UNUSED",
            "parameter integer C_AXI_ADDR_WIDTH\t= 6\n\t\t// Verilator lint_on  UNUSED\n\t\t// Some useful short-hand definitions\n\t\t//",
            "localparam AW = C_AXI_ADDR_WIDTH,\n\t\t//",
            "localparam DW = C_AXI_DATA_WIDTH\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,\n\t\t//",
            "input ",
            "wire S_AXI_AWVALID,",
            "output ",
            "wire S_AXI_AWREADY,",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tS_AXI_AWID,\n\t\t//",
            "input ",
            "wire S_AXI_WVALID,",
            "output ",
            "wire S_AXI_WREADY,",
            "input ",
            "wire S_AXI_WLAST,\n\t\t//",
            "output ",
            "wire S_AXI_BVALID,",
            "input ",
            "wire S_AXI_BREADY,",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0]\tS_AXI_BID,",
            "output ",
            "wire [1:0]\t\t\tS_AXI_BRESP,\n\t\t//",
            "input ",
            "wire S_AXI_ARVALID,",
            "output ",
            "wire S_AXI_ARREADY,",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tS_AXI_ARID,",
            "input ",
            "wire [7:0]\t\t\tS_AXI_ARLEN,\n\t\t//",
            "output ",
            "wire S_AXI_RVALID,",
            "input ",
            "wire S_AXI_RREADY,",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0]\tS_AXI_RID,",
            "output ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tS_AXI_RDATA,",
            "output ",
            "wire S_AXI_RLAST,",
            "output ",
            "wire [1:0]\t\t\tS_AXI_RRESP\n\t\t// }}}\n\t);",
            "localparam IW = C_AXI_ID_WIDTH;\n\t// Double buffer the write response channel only",
            "reg [IW-1 : 0]\taxi_bid;",
            "reg axi_bvalid;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Write",
            "logic // {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// Start with the two skid buffers\n\t// {{{",
            "wire m_awvalid, m_wvalid;",
            "wire m_awready, m_wready, m_wlast;",
            "wire [IW-1:0]\tm_awid;\n\t//\n\tskidbuffer #(.DW(IW), .OPT_OUTREG(1'b0))\n\tawskd(S_AXI_ACLK, !S_AXI_ARESETN,\n\t\tS_AXI_AWVALID, S_AXI_AWREADY, S_AXI_AWID,\n\t\tm_awvalid, m_awready, m_awid );\n\n\tskidbuffer #(.DW(1), .OPT_OUTREG(1'b0))\n\twskd(S_AXI_ACLK, !S_AXI_ARESETN,\n\t\tS_AXI_WVALID, S_AXI_WREADY, S_AXI_WLAST,\n\t\tm_wvalid, m_wready, m_wlast );\n\t// }}}\n\n\t// m_awready, m_wready\n\t// {{{\n\t// The",
            "logic here is pretty simple--accept a write address burst\n\t// into the skid buffer, then leave it there while the write data comes\n\t// on.  Once we get to the last write data element, accept both it and\n\t// the address.  This spares us the trouble of counting out the elements\n\t// in the write burst.\n\t//\n\tassign\tm_awready= (m_awvalid && m_wvalid && m_wlast)\n\t\t\t&& (!S_AXI_BVALID || S_AXI_BREADY);\n\tassign\tm_wready = !m_wlast || m_awready;\n\t// }}}\n\n\t// bvalid\n\t// {{{\n\t// As soon as m_awready above, a packet has come through successfully.\n\t// Acknowledge it with a bus error.\n\t//\n\tinitial\taxi_bvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_bvalid <= 1'b0;\n\telse if (m_awready)\n\t\taxi_bvalid <= 1'b1;\n\telse if (S_AXI_BREADY)\n\t\taxi_bvalid <= 1'b0;\n\t// }}}\n\n\t// bid\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (m_awready)\n\t\taxi_bid <= m_awid;\n\t// }}}\n\n\tassign\tS_AXI_BVALID = axi_bvalid;\n\tassign\tS_AXI_BID    = axi_bid;\n\tassign\tS_AXI_BRESP  = 2'b11;\t// An interconnect bus error\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read half\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//",
            "reg [IW-1:0]\trid, axi_rid;",
            "reg axi_arready, axi_rlast, axi_rvalid;",
            "reg [8:0]\t\taxi_rlen;\n\n\t// axi_arready\n\t// {{{\n\tinitial axi_arready = 1;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_arready <= 1;\n\telse if (S_AXI_ARVALID && S_AXI_ARREADY)\n\t\taxi_arready <= (S_AXI_ARLEN==0)&&(!S_AXI_RVALID|| S_AXI_RREADY);\n\telse if (!S_AXI_RVALID || S_AXI_RREADY)\n\tbegin\n\t\tif ((!axi_arready)&&(S_AXI_RVALID))\n\t\t\taxi_arready <= (axi_rlen <= 2);\n\tend\n\t// }}}\n\n\t// axi_rlen\n\t// {{{\n\tinitial\taxi_rlen = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_rlen <= 0;\n\telse if (S_AXI_ARVALID && S_AXI_ARREADY)\n\t\taxi_rlen <= (S_AXI_ARLEN+1)\n\t\t\t\t+ ((S_AXI_RVALID && !S_AXI_RREADY) ? 1:0);\n\telse if (S_AXI_RREADY && S_AXI_RVALID)\n\t\taxi_rlen <= axi_rlen - 1;\n\t// }}}\n\n\t// rid\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (S_AXI_ARREADY)\n\t\trid      <= S_AXI_ARID;\n\t// }}}\n\n\t// axi_rvalid\n\t// {{{\n\tinitial\taxi_rvalid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\taxi_rvalid <= 0;\n\telse if (S_AXI_ARVALID || (axi_rlen > 1))\n\t\taxi_rvalid <= 1;\n\telse if (S_AXI_RREADY)\n\t\taxi_rvalid <= 0;\n\t// }}}\n\n\t// axi_rid\n\t// {{{\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_RVALID || S_AXI_RREADY)\n\tbegin\n\t\tif (S_AXI_ARVALID && S_AXI_ARREADY)\n\t\t\taxi_rid <= S_AXI_ARID;\n\t\telse\n\t\t\taxi_rid <= rid;\n\tend\n\t// }}}\n\n\t// axi_rlast\n\t// {{{\n\tinitial axi_rlast   = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_RVALID || S_AXI_RREADY)\n\tbegin\n\t\tif (S_AXI_ARVALID && S_AXI_ARREADY)\n\t\t\taxi_rlast <= (S_AXI_ARLEN == 0);\n\t\telse if (S_AXI_RVALID)\n\t\t\taxi_rlast <= (axi_rlen == 2);\n\t\telse\n\t\t\taxi_rlast <= (axi_rlen == 1);\n\tend\n\t// }}}\n\n\t//\n\tassign\tS_AXI_ARREADY = axi_arready;\n\tassign\tS_AXI_RVALID  = axi_rvalid;\n\tassign\tS_AXI_RID     = axi_rid;\n\tassign\tS_AXI_RDATA   = 0;\n\tassign\tS_AXI_RRESP   = 2'b11;\n\tassign\tS_AXI_RLAST   = axi_rlast;\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = &{ 1'b0 };\n\t// Verilator lint_on  UNUSED\n\t// Verilator coverage_on\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL\n\t//\n\t// The following properties are only some of the properties used\n\t// to verify this core\n\t//",
            "reg f_past_valid;\n\tinitial\tf_past_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\t\tf_past_valid <= 1;\n\n\talways @(*)\n\tif (!f_past_valid)\n\t\tassume(!S_AXI_ARESETN);\n\n\tfaxi_slave\t#(\n\t\t// {{{\n\t\t.C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),\n\t\t.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),\n\t\t.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH)\n\t\t// }}}\n\tf_slave(\n\t\t// {{{\n\t\t.i_clk(S_AXI_ACLK),\n\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t//\n\t\t// Address write channel\n\t\t//\n\t\t.i_axi_awvalid(S_AXI_AWVALID),\n\t\t.i_axi_awready(S_AXI_AWREADY),\n\t\t.i_axi_awid(   S_AXI_AWID),\n\t\t.i_axi_awaddr( {(C_AXI_ADDR_WIDTH){1'b0}}),\n\t\t.i_axi_awlen(  S_AXI_AWLEN),\n\t\t.i_axi_awsize( LSB[2:0]),\n\t\t.i_axi_awburst(2'b0),\n\t\t.i_axi_awlock( 1'b0),\n\t\t.i_axi_awcache(4'h0),\n\t\t.i_axi_awprot( 3'h0),\n\t\t.i_axi_awqos(  4'h0),\n\t//\n\t//\n\t\t//\n\t\t// Write Data Channel\n\t\t//\n\t\t// Write Data\n\t\t.i_axi_wdata({(C_AXI_DATA_WIDTH){1'b0}}),\n\t\t.i_axi_wstrb({(C_AXI_DATA_WIDTH/8){1'b0}}),\n\t\t.i_axi_wlast(S_AXI_WLAST),\n\t\t.i_axi_wvalid(S_AXI_WVALID),\n\t\t.i_axi_wready(S_AXI_WREADY),\n\t//\n\t//\n\t\t// Response ID tag. This signal is the ID tag of the\n\t\t// write response.\n\t\t.i_axi_bvalid(S_AXI_BVALID),\n\t\t.i_axi_bready(S_AXI_BREADY),\n\t\t.i_axi_bid(   S_AXI_BID),\n\t\t.i_axi_bresp( S_AXI_BRESP),\n\t//\n\t//\n\t\t//\n\t\t// Read address channel\n\t\t//\n\t\t.i_axi_arvalid(S_AXI_ARVALID),\n\t\t.i_axi_arready(S_AXI_ARREADY),\n\t\t.i_axi_arid(   S_AXI_ARID),\n\t\t.i_axi_araddr( {(C_AXI_ADDR_WIDTH){1'b0}}),\n\t\t.i_axi_arlen(  S_AXI_ARLEN),\n\t\t.i_axi_arsize( LSB[2:0]),\n\t\t.i_axi_arburst(2'b00),\n\t\t.i_axi_arlock( 1'b0),\n\t\t.i_axi_arcache(4'h0),\n\t\t.i_axi_arprot( 3'h0),\n\t\t.i_axi_arqos(  4'h0),\n\t//\n\t//\n\t\t//\n\t\t// Read data return channel\n\t\t//\n\t\t.i_axi_rvalid(S_AXI_RVALID),\n\t\t.i_axi_rready(S_AXI_RREADY),\n\t\t.i_axi_rid(S_AXI_RID),\n\t\t.i_axi_rdata(S_AXI_RDATA),\n\t\t.i_axi_rresp(S_AXI_RRESP),\n\t\t.i_axi_rlast(S_AXI_RLAST),\n\t\t//\n\t\t// ...\n\t\t// }}}\n\t);\n\n\t//\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Write induction properties\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{\n\n\n\t//\n\t// ...\n\t//\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read induction properties\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{\n\n\t//\n\t// ...\n\t//\n\n\talways @(posedge S_AXI_ACLK)\n\tif (f_past_valid && $rose(S_AXI_RLAST))\n\t\tassert(S_AXI_ARREADY);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Contract checking\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{\n\n\t//\n\t// ...\n\t//\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// {{{",
            "reg f_wr_cvr_valid, f_rd_cvr_valid;\n\n\tinitial\tf_wr_cvr_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tf_wr_cvr_valid <= 0;\n\telse if (S_AXI_AWVALID && S_AXI_AWREADY && S_AXI_AWLEN > 4)\n\t\tf_wr_cvr_valid <= 1;\n\n\talways @(*)\n\t\tcover(!S_AXI_BVALID && axi_awready && !m_awvalid\n\t\t\t&& f_wr_cvr_valid /* && ... */));\n\n\tinitial\tf_rd_cvr_valid = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tf_rd_cvr_valid <= 0;\n\telse if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN > 4)\n\t\tf_rd_cvr_valid <= 1;\n\n\talways @(*)\n\t\tcover(S_AXI_ARREADY && f_rd_cvr_valid /* && ... */);\n\n\t//\n\t// Generate cover statements associated with multiple successive bursts\n\t//\n\t// These will be useful for demonstrating the throughput of the core.\n\t//",
            "reg [4:0]\tf_dbl_rd_count, f_dbl_wr_count;\n\n\tinitial\tf_dbl_wr_count = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tf_dbl_wr_count = 0;\n\telse if (S_AXI_AWVALID && S_AXI_AWREADY && S_AXI_AWLEN == 3)\n\tbegin\n\t\tif (!(&f_dbl_wr_count))\n\t\t\tf_dbl_wr_count <= f_dbl_wr_count + 1;\n\tend\n\n\talways @(*)\n\t\tcover(S_AXI_ARESETN && (f_dbl_wr_count > 1));\t//!\n\n\talways @(*)\n\t\tcover(S_AXI_ARESETN && (f_dbl_wr_count > 3));\t//!\n\n\talways @(*)\n\t\tcover(S_AXI_ARESETN && (f_dbl_wr_count > 3) && !m_awvalid\n\t\t\t&&(!S_AXI_AWVALID && !S_AXI_WVALID && !S_AXI_BVALID)\n\t\t\t&& (f_axi_awr_nbursts == 0)\n\t\t\t&& (f_axi_wr_pending == 0));\t//!!\n\n\tinitial\tf_dbl_rd_count = 0;\n\talways @(posedge S_AXI_ACLK)\n\tif (!S_AXI_ARESETN)\n\t\tf_dbl_rd_count = 0;\n\telse if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN == 3)\n\tbegin\n\t\tif (!(&f_dbl_rd_count))\n\t\t\tf_dbl_rd_count <= f_dbl_rd_count + 1;\n\tend\n\n\talways @(*)\n\t\tcover(!S_AXI_ARESETN && (f_dbl_rd_count > 3)\n\t\t\t/* && ... */\n\t\t\t&& !S_AXI_ARVALID && !S_AXI_RVALID);\n\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assumptions necessary to pass a formal check\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t//\n\t// No limiting assumptions at present, check is currently full and\n\t// complete\n\t//\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "axi_addr.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axi_addr.v",
        "chunks": [
            "logic //\tbelow captures it for every time it might be needed.\n//\n// 20200918 - modified to accommodate (potential) AXI3 burst lengths\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n//\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2019-2024, Gisselquist Technology, LLC\n// {{{\n// This program is free software (firmware): you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or (at\n// your option) any later version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or\n// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n// for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no\n// target there if the PDF file isn't present.)  If not, see\n// <http://www.gnu.org/licenses/> for a copy.\n// }}}\n// License:\tGPL, v3, as defined and found on www.gnu.org,\n// {{{\n//\t\thttp://www.gnu.org/licenses/gpl.html\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n`default_nettype none\n// }}}",
            "module axi_addr #(\n\t\t// {{{",
            "parameter AW = 32,\n\t\t\t\tDW = 32,\n\t\t//",
            "parameter [0:0]\tOPT_AXI3 = 1'b0,",
            "localparam LENB = 8\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire [AW-1:0]\ti_last_addr,",
            "input ",
            "wire [2:0]\t\ti_size, // 1b, 2b, 4b, 8b, etc",
            "input ",
            "wire [1:0]\t\ti_burst, // fixed, incr, wrap, reserved",
            "input ",
            "wire [LENB-1:0]\ti_len,",
            "output ",
            "reg [AW-1:0]\to_next_addr\n\t\t// }}}\n\t);\n\n\t// Parameter/",
            "reg ister declarations\n\t// {{{",
            "localparam DSZ = $clog2(DW)-3;",
            "localparam [1:0]\tFIXED     = 2'b00;\n\t//",
            "localparam [1:0]\tINCREMENT = 2'b01;\n\t//",
            "localparam [1:0]\tWRAP      = 2'b10;",
            "reg [AW-1:0]\twrap_mask, increment;\n\t// }}}\n\n\t// Address increment\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tincrement = 0;\n\t\tif (i_burst != 0)\n\t\tbegin\n\t\t\t// Addresses increment from one beat to the next\n\t\t\t// {{{\n\t\t\tif (DSZ == 0)\n\t\t\t\tincrement = 1;\n\t\t\telse if (DSZ == 1)\n\t\t\t\tincrement = (i_size[0]) ? 2 : 1;\n\t\t\telse if (DSZ == 2)\n\t\t\t\tincrement = (i_size[1]) ? 4 : ((i_size[0]) ? 2 : 1);\n\t\t\telse if (DSZ == 3)\n\t\t\t\tcase(i_size[1:0])\n\t\t\t\t2'b00: increment = 1;\n\t\t\t\t2'b01: increment = 2;\n\t\t\t\t2'b10: increment = 4;\n\t\t\t\t2'b11: increment = 8;\n\t\t\t\tendcase\n\t\t\telse\n\t\t\t\tincrement = (1<<i_size);\n\t\t\t// }}}\n\t\tend\n\tend\n\t// }}}\n\n\t// wrap_mask\n\t// {{{\n\t// The wrap_mask is used to determine which bits remain stable across\n\t// the burst, and which are allowed to change.  It is only used during\n\t// wrapped addressing.\n\talways @(*)\n\tbegin\n\t\t// Start with the default, minimum mask\n\t\twrap_mask = 1;\n\n\t\t/*\n\t\t// Here's the original code.  It works, but it's\n\t\t// not economical (uses too many LUTs)\n\t\t//\n\t\tif (i_len[3:0] == 1)\n\t\t\twrap_mask = (1<<(i_size+1));\n\t\telse if (i_len[3:0] == 3)\n\t\t\twrap_mask = (1<<(i_size+2));\n\t\telse if (i_len[3:0] == 7)\n\t\t\twrap_mask = (1<<(i_size+3));\n\t\telse if (i_len[3:0] == 15)\n\t\t\twrap_mask = (1<<(i_size+4));\n\t\twrap_mask = wrap_mask - 1;\n\t\t*/\n\n\t\t// Here's what we *want*\n\t\t//\n\t\t// wrap_mask[i_size:0] = -1;\n\t\t//\n\t\t// On the other hand, since we're already guaranteed that our\n\t\t// addresses are aligned, do we really care about\n\t\t// wrap_mask[i_size-1:0] ?\n\n\t\t// What we want:\n\t\t//\n\t\t// wrap_mask[i_size+3:i_size] |= i_len[3:0]\n\t\t//\n\t\t// We could simplify this to\n\t\t//\n\t\t// wrap_mask = wrap_mask | (i_len[3:0] << (i_size));\n\t\t//\n\t\t// But verilator complains about the left-hand side of\n\t\t// the shift having only 3 bits.\n\t\t//\n\t\tif (DSZ < 2)\n\t\t\twrap_mask = wrap_mask | ({{(AW-4){1'b0}},i_len[3:0]} << (i_size[0]));\n\t\telse if (DSZ < 4)\n\t\t\twrap_mask = wrap_mask | ({{(AW-4){1'b0}},i_len[3:0]} << (i_size[1:0]));\n\t\telse\n\t\t\twrap_mask = wrap_mask | ({{(AW-4){1'b0}},i_len[3:0]} << (i_size));\n\n\t\tif (AW > 12)\n\t\t\twrap_mask[(AW-1):((AW>12)? 12:(AW-1))] = 0;\n\tend\n\t// }}}\n\n\t// o_next_addr\n\t// {{{\n\talways @(*)\n\tbegin\n\t\to_next_addr = i_last_addr + increment;\n\t\tif (i_burst != FIXED)\n\t\tbegin\n\t\t\t// Align subsequent beats in any burst\n\t\t\t// {{{\n\t\t\t//\n\t\t\t// We use the bus size here to simplify the",
            "logic // required in case the bus is smaller than the\n\t\t\t// maximum.  This depends upon AxSIZE being less than\n\t\t\t// $clog2(DATA_WIDTH/8).\n\t\t\tif (DSZ < 2)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\t// Align any subsequent address\n\t\t\t\tif (i_size[0])\n\t\t\t\t\to_next_addr[0] = 0;\n\t\t\t\t// }}}\n\t\t\tend else if (DSZ < 4)\n\t\t\tbegin\n\t\t\t\t// {{{\n\t\t\t\t// Align any subsequent address\n\t\t\t\tcase(i_size[1:0])\n\t\t\t\t2'b00:  o_next_addr = o_next_addr;\n\t\t\t\t2'b01:  o_next_addr[  0] = 0;\n\t\t\t\t2'b10:  o_next_addr[(AW-1>1) ? 1 : (AW-1):0]= 0;\n\t\t\t\t2'b11:  o_next_addr[(AW-1>2) ? 2 : (AW-1):0]= 0;\n\t\t\t\tendcase\n\t\t\t\t// }}}\n\t\t\tend else begin\n\t\t\t\t// {{{\n\t\t\t\t// Align any subsequent address\n\t\t\t\tcase(i_size)\n\t\t\t\t3'b001:  o_next_addr[  0] = 0;\n\t\t\t\t3'b010:  o_next_addr[(AW-1>1) ? 1 : (AW-1):0]=0;\n\t\t\t\t3'b011:  o_next_addr[(AW-1>2) ? 2 : (AW-1):0]=0;\n\t\t\t\t3'b100:  o_next_addr[(AW-1>3) ? 3 : (AW-1):0]=0;\n\t\t\t\t3'b101:  o_next_addr[(AW-1>4) ? 4 : (AW-1):0]=0;\n\t\t\t\t3'b110:  o_next_addr[(AW-1>5) ? 5 : (AW-1):0]=0;\n\t\t\t\t3'b111:  o_next_addr[(AW-1>6) ? 6 : (AW-1):0]=0;\n\t\t\t\tdefault: o_next_addr = o_next_addr;\n\t\t\t\tendcase\n\t\t\t\t// }}}\n\t\t\tend\n\t\t\t// }}}\n\t\tend\n\n\t\t// WRAP addressing\n\t\t// {{{\n\t\tif (i_burst[1])\n\t\tbegin\n\t\t\t// WRAP!\n\t\t\to_next_addr[AW-1:0] = (i_last_addr & ~wrap_mask)\n\t\t\t\t\t| (o_next_addr & wrap_mask);\n\t\tend\n\t\t// }}}\n\n\t\t// Guarantee only the bottom 12 bits change\n\t\t// {{{\n\t\t// This is really a",
            "logic simplification.  AXI bursts aren't\n\t\t// allowed to cross 4kB boundaries.  Given that's the case,\n\t\t// we don't have to suffer from the propagation across all\n\t\t// AW bits, and can limit any address propagation to just the\n\t\t// lower 12 bits\n\t\tif (AW > 12)\n\t\t\to_next_addr[AW-1:((AW>12)? 12:(AW-1))]\n\t\t\t\t= i_last_addr[AW-1:((AW>12) ? 12:(AW-1))];\n\t\t// }}}\n\tend\n\t// }}}\n\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator coverage_off\n\t// Verilator lint_off UNUSED",
            "wire unused;\n\tassign\tunused = (LENB <= 4) ? &{1'b0, i_len[0] }\n\t\t\t\t: &{ 1'b0, i_len[LENB-1:4], i_len[0] };\n\t// Verilator lint_on UNUSED\n\t// Verilator coverage_on\n\t// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "axixbar.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axixbar.v",
        "chunks": [
            "module can be a challenge to",
            "wire up.\n//\n//\tIn order to keep the build lint clean, it's important that every\n//\tport be connected.  In order to be flexible",
            "reg arding the number of\n//\tports that can be connected, the various AXI signals, whether",
            "input //\tor",
            "output , have been concatenated together across either all masters\n//\tor all slaves.  This can make the design a lesson in tediousness to\n//",
            "wire up.\n//\n//\tI commonly",
            "wire this crossbar up using AutoFPGA--just to make certain\n//\tthat I do it right and don't make mistakes when wiring it up.  This\n//\talso handles the tediousness involved.\n//\n//\tI have also done this by hand.\n//\n//\n// Creator:\tDan Gisselquist, Ph.D.\n//\t\tGisselquist Technology, LLC\n// }}}\n////////////////////////////////////////////////////////////////////////////////\n// }}}\n// Copyright (C) 2019-2024, Gisselquist Technology, LLC\n// {{{\n// This file is part of the WB2AXIP project.\n//\n// The WB2AXIP project contains free software and gateware, licensed under the\n// Apache License, Version 2.0 (the \"License\").  You may not use this project,\n// or this file, except in compliance with the License.  You may obtain a copy\n// of the License at\n//\n//\thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n// License for the specific language governing permissions and limitations\n// under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n`default_nettype none\n// }}}",
            "module axixbar #(\n\t\t// {{{",
            "parameter integer C_AXI_DATA_WIDTH = 32,",
            "parameter integer C_AXI_ADDR_WIDTH = 32,",
            "parameter integer C_AXI_ID_WIDTH = 2,\n\t\t//\n\t\t// NM is the number of masters driving the incoming slave chnls",
            "parameter NM = 4,\n\t\t//\n\t\t// NS is the number of slaves connected to the crossbar, driven\n\t\t// by the master channels",
            "output from this IP.",
            "parameter NS = 8,\n\t\t//\n\t\t// SLAVE_ADDR is an array of addresses, describing each of\n\t\t// {{{\n\t\t// the slave channels.  It works tightly with SLAVE_MASK,\n\t\t// so that when (ADDR & MASK == ADDR), the channel in question\n\t\t// has been requested.\n\t\t//\n\t\t// It is an internal in the setup of this core to doubly map\n\t\t// an address, such that (addr & SLAVE_MASK[k])==SLAVE_ADDR[k]\n\t\t// for two separate values of k.\n\t\t//\n\t\t// Any attempt to access an address that is a hole in this\n\t\t// address list will result in a returned xRESP value of\n\t\t// INTERCONNECT_ERROR (2'b11)\n\t\t//\n\t\t// NOTE: This is only a nominal address set.  I expect that\n\t\t// any design using the crossbar will need to adjust both\n\t\t// SLAVE_ADDR and SLAVE_MASK, if not also NM and NS.",
            "parameter [NS*C_AXI_ADDR_WIDTH-1:0]\tSLAVE_ADDR = {\n\t\t\t3'b111,  {(C_AXI_ADDR_WIDTH-3){1'b0}},\n\t\t\t3'b110,  {(C_AXI_ADDR_WIDTH-3){1'b0}},\n\t\t\t3'b101,  {(C_AXI_ADDR_WIDTH-3){1'b0}},\n\t\t\t3'b100,  {(C_AXI_ADDR_WIDTH-3){1'b0}},\n\t\t\t3'b011,  {(C_AXI_ADDR_WIDTH-3){1'b0}},\n\t\t\t3'b010,  {(C_AXI_ADDR_WIDTH-3){1'b0}},\n\t\t\t4'b0001, {(C_AXI_ADDR_WIDTH-4){1'b0}},\n\t\t\t4'b0000, {(C_AXI_ADDR_WIDTH-4){1'b0}} },\n\t\t// }}}\n\t\t//\n\t\t// SLAVE_MASK: is an array, much like SLAVE_ADDR, describing\n\t\t// {{{\n\t\t// which of the bits in SLAVE_ADDR are relevant.  It is\n\t\t// important to maintain for every slave that\n\t\t// \t(~SLAVE_MASK[i] & SLAVE_ADDR[i]) == 0.\n\t\t//\n\t\t// NOTE: This value should be overridden by any implementation.\n\t\t// Verilator lint_off WIDTH",
            "parameter [NS*C_AXI_ADDR_WIDTH-1:0]\tSLAVE_MASK = {\n\t\t\t3'b111,  {(C_AXI_ADDR_WIDTH-3){1'b0}},\n\t\t\t3'b111,  {(C_AXI_ADDR_WIDTH-3){1'b0}},\n\t\t\t3'b111,  {(C_AXI_ADDR_WIDTH-3){1'b0}},\n\t\t\t3'b111,  {(C_AXI_ADDR_WIDTH-3){1'b0}},\n\t\t\t3'b111,  {(C_AXI_ADDR_WIDTH-3){1'b0}},\n\t\t\t3'b111,  {(C_AXI_ADDR_WIDTH-3){1'b0}},\n\t\t\t4'b1111, {(C_AXI_ADDR_WIDTH-4){1'b0}},\n\t\t\t4'b1111, {(C_AXI_ADDR_WIDTH-4){1'b0}} },\n\t\t// Verilator lint_on  WIDTH\n\t\t// }}}\n\t\t//\n\t\t// OPT_LOWPOWER: If set, it forces all unused values to zero,\n\t\t// {{{\n\t\t// preventing them from unnecessarily toggling.  This will\n\t\t// raise the",
            "logic count of the core, but might also lower\n\t\t// the power used by the interconnect and the bus driven",
            "wire s\n\t\t// which (in my experience) tend to have a high fan out.",
            "parameter [0:0]\tOPT_LOWPOWER = 0,\n\t\t// }}}\n\t\t//\n\t\t// OPT_LINGER: Set this to the number of clocks an idle\n\t\t// {{{\n\t\t// channel shall be left open before being closed.  Once\n\t\t// closed, it will take a minimum of two clocks before the\n\t\t// channel can be opened and data transmitted through it again.",
            "parameter OPT_LINGER = 4,\n\t\t// }}}\n\t\t//\n\t\t// [EXPERIMENTAL] OPT_QOS: If set, the QOS transmission values\n\t\t// {{{\n\t\t// will be honored when determining who wins arbitration for\n\t\t// accessing a given slave.  (This feature has not yet been\n\t\t// verified)",
            "parameter [0:0]\tOPT_QOS = 0,\n\t\t// }}}\n\t\t//\n\t\t// LGMAXBURST: Specifies the log based two of the maximum\n\t\t// {{{\n\t\t// number of bursts transactions that may be outstanding at any\n\t\t// given time.  This is different from the maximum number of\n\t\t// outstanding beats.",
            "parameter LGMAXBURST = 3\n\t\t// }}}\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,\n\t\t// Write slave channels from the controlling AXI masters\n\t\t// {{{",
            "input ",
            "wire [NM*C_AXI_ID_WIDTH-1:0]\t\tS_AXI_AWID,",
            "input ",
            "wire [NM*C_AXI_ADDR_WIDTH-1:0]\tS_AXI_AWADDR,",
            "input ",
            "wire [NM*8-1:0]\t\t\tS_AXI_AWLEN,",
            "input ",
            "wire [NM*3-1:0]\t\t\tS_AXI_AWSIZE,",
            "input ",
            "wire [NM*2-1:0]\t\t\tS_AXI_AWBURST,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_AWLOCK,",
            "input ",
            "wire [NM*4-1:0]\t\t\tS_AXI_AWCACHE,",
            "input ",
            "wire [NM*3-1:0]\t\t\tS_AXI_AWPROT,",
            "input ",
            "wire [NM*4-1:0]\t\t\tS_AXI_AWQOS,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_AWVALID,",
            "output ",
            "wire [NM-1:0]\t\t\tS_AXI_AWREADY,\n\t\t//",
            "input ",
            "wire [NM*C_AXI_DATA_WIDTH-1:0]\tS_AXI_WDATA,",
            "input ",
            "wire [NM*C_AXI_DATA_WIDTH/8-1:0]\tS_AXI_WSTRB,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_WLAST,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_WVALID,",
            "output ",
            "wire [NM-1:0]\t\t\tS_AXI_WREADY,\n\t\t//",
            "output ",
            "wire [NM*C_AXI_ID_WIDTH-1:0]\t\tS_AXI_BID,",
            "output ",
            "wire [NM*2-1:0]\t\t\tS_AXI_BRESP,",
            "output ",
            "wire [NM-1:0]\t\t\tS_AXI_BVALID,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_BREADY,\n\t\t// }}}\n\t\t// Read slave channels from the controlling AXI masters\n\t\t// {{{",
            "input ",
            "wire [NM*C_AXI_ID_WIDTH-1:0]\t\tS_AXI_ARID,",
            "input ",
            "wire [NM*C_AXI_ADDR_WIDTH-1:0]\tS_AXI_ARADDR,",
            "input ",
            "wire [NM*8-1:0]\t\t\tS_AXI_ARLEN,",
            "input ",
            "wire [NM*3-1:0]\t\t\tS_AXI_ARSIZE,",
            "input ",
            "wire [NM*2-1:0]\t\t\tS_AXI_ARBURST,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_ARLOCK,",
            "input ",
            "wire [NM*4-1:0]\t\t\tS_AXI_ARCACHE,",
            "input ",
            "wire [NM*3-1:0]\t\t\tS_AXI_ARPROT,",
            "input ",
            "wire [NM*4-1:0]\t\t\tS_AXI_ARQOS,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_ARVALID,",
            "output ",
            "wire [NM-1:0]\t\t\tS_AXI_ARREADY,\n\t\t//",
            "output ",
            "wire [NM*C_AXI_ID_WIDTH-1:0]\t\tS_AXI_RID,",
            "output ",
            "wire [NM*C_AXI_DATA_WIDTH-1:0]\tS_AXI_RDATA,",
            "output ",
            "wire [NM*2-1:0]\t\t\tS_AXI_RRESP,",
            "output ",
            "wire [NM-1:0]\t\t\tS_AXI_RLAST,",
            "output ",
            "wire [NM-1:0]\t\t\tS_AXI_RVALID,",
            "input ",
            "wire [NM-1:0]\t\t\tS_AXI_RREADY,\n\t\t// }}}\n\t\t// Write channel master",
            "output s to the connected AXI slaves\n\t\t// {{{",
            "output ",
            "wire [NS*C_AXI_ID_WIDTH-1:0]\t\tM_AXI_AWID,",
            "output ",
            "wire [NS*C_AXI_ADDR_WIDTH-1:0]\tM_AXI_AWADDR,",
            "output ",
            "wire [NS*8-1:0]\t\t\tM_AXI_AWLEN,",
            "output ",
            "wire [NS*3-1:0]\t\t\tM_AXI_AWSIZE,",
            "output ",
            "wire [NS*2-1:0]\t\t\tM_AXI_AWBURST,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_AWLOCK,",
            "output ",
            "wire [NS*4-1:0]\t\t\tM_AXI_AWCACHE,",
            "output ",
            "wire [NS*3-1:0]\t\t\tM_AXI_AWPROT,",
            "output ",
            "wire [NS*4-1:0]\t\t\tM_AXI_AWQOS,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_AWVALID,",
            "input ",
            "wire [NS-1:0]\t\t\tM_AXI_AWREADY,\n\t\t//\n\t\t//",
            "output ",
            "wire [NS*C_AXI_DATA_WIDTH-1:0]\tM_AXI_WDATA,",
            "output ",
            "wire [NS*C_AXI_DATA_WIDTH/8-1:0]\tM_AXI_WSTRB,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_WLAST,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_WVALID,",
            "input ",
            "wire [NS-1:0]\t\t\tM_AXI_WREADY,\n\t\t//",
            "input ",
            "wire [NS*C_AXI_ID_WIDTH-1:0]\t\tM_AXI_BID,",
            "input ",
            "wire [NS*2-1:0]\t\t\tM_AXI_BRESP,",
            "input ",
            "wire [NS-1:0]\t\t\tM_AXI_BVALID,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_BREADY,\n\t\t// }}}\n\t\t// Read channel master",
            "output s to the connected AXI slaves\n\t\t// {{{",
            "output ",
            "wire [NS*C_AXI_ID_WIDTH-1:0]\t\tM_AXI_ARID,",
            "output ",
            "wire [NS*C_AXI_ADDR_WIDTH-1:0]\tM_AXI_ARADDR,",
            "output ",
            "wire [NS*8-1:0]\t\t\tM_AXI_ARLEN,",
            "output ",
            "wire [NS*3-1:0]\t\t\tM_AXI_ARSIZE,",
            "output ",
            "wire [NS*2-1:0]\t\t\tM_AXI_ARBURST,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_ARLOCK,",
            "output ",
            "wire [NS*4-1:0]\t\t\tM_AXI_ARCACHE,",
            "output ",
            "wire [NS*4-1:0]\t\t\tM_AXI_ARQOS,",
            "output ",
            "wire [NS*3-1:0]\t\t\tM_AXI_ARPROT,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_ARVALID,",
            "input ",
            "wire [NS-1:0]\t\t\tM_AXI_ARREADY,\n\t\t//\n\t\t//",
            "input ",
            "wire [NS*C_AXI_ID_WIDTH-1:0]\t\tM_AXI_RID,",
            "input ",
            "wire [NS*C_AXI_DATA_WIDTH-1:0]\tM_AXI_RDATA,",
            "input ",
            "wire [NS*2-1:0]\t\t\tM_AXI_RRESP,",
            "input ",
            "wire [NS-1:0]\t\t\tM_AXI_RLAST,",
            "input ",
            "wire [NS-1:0]\t\t\tM_AXI_RVALID,",
            "output ",
            "wire [NS-1:0]\t\t\tM_AXI_RREADY\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Local",
            "parameter s, derived from those above\n\t// {{{\n\t// IW, AW, and DW, are short-hand abbreviations used locally.",
            "localparam IW = C_AXI_ID_WIDTH;",
            "localparam AW = C_AXI_ADDR_WIDTH;",
            "localparam DW = C_AXI_DATA_WIDTH;\n\t// LGLINGER tells us how many bits we need for counting how long\n\t// to keep an udle channel open.",
            "localparam LGLINGER = (OPT_LINGER>1) ? $clog2(OPT_LINGER+1) : 1;\n\t//",
            "localparam LGNM = (NM>1) ? $clog2(NM) : 1;",
            "localparam LGNS = (NS>1) ? $clog2(NS+1) : 1;\n\t//\n\t// In order to use indexes, and hence fully balanced mux trees, it helps\n\t// to make certain that we have a power of two based lookup.  NMFULL\n\t// is the number of masters in this lookup, with potentially some\n\t// unused extra ones.  NSFULL is defined similarly.",
            "localparam NMFULL = (NM>1) ? (1<<LGNM) : 1;",
            "localparam NSFULL = (NS>1) ? (1<<LGNS) : 2;\n\t//",
            "localparam [1:0] INTERCONNECT_ERROR = 2'b11;\n\t//\n\t// OPT_SKID_INPUT controls whether the",
            "input skid buffers",
            "reg ister\n\t// their",
            "output s or not.  If set, all skid buffers will cost one more\n\t// clock of latency.  It's not clear that there's a performance gain\n\t// to be had by setting this.",
            "localparam [0:0]\tOPT_SKID_INPUT = 0;\n\t//\n\t// OPT_BUFFER_DECODER determines whether or not the",
            "output s of the\n\t// address decoder will be buffered or not.  If buffered, there will\n\t// be an extra (",
            "reg istered) clock delay on each of the A* channels from\n\t// VALID to issue.",
            "localparam [0:0]\tOPT_BUFFER_DECODER = 1;\n\t//\n\t// OPT_AWW controls whether or not a W* beat may be issued to a slave\n\t// at the same time as the first AW* beat gets sent to the slave.  Set\n\t// to 1'b1 for lower latency, at the potential cost of a greater\n\t// combinatorial path length",
            "localparam OPT_AWW = 1'b1;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Internal signal declarations and definitions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenvar\tN,M;\n\tinteger\tiN, iM;",
            "reg [NSFULL-1:0]\twrequest\t\t[0:NM-1];",
            "reg [NSFULL-1:0]\trrequest\t\t[0:NM-1];",
            "reg [NSFULL-1:0]\twrequested\t\t[0:NM];",
            "reg [NSFULL-1:0]\trrequested\t\t[0:NM];",
            "reg [NS:0]\t\twgrant\t\t\t[0:NM-1];",
            "reg [NS:0]\t\trgrant\t\t\t[0:NM-1];",
            "reg [NM-1:0]\tmwgrant;",
            "reg [NM-1:0]\tmrgrant;",
            "reg [NS-1:0]\tswgrant;",
            "reg [NS-1:0]\tsrgrant;\n\n\t// verilator lint_off UNUSED",
            "wire [LGMAXBURST-1:0]\tw_mawpending\t[0:NM-1];",
            "wire [LGMAXBURST-1:0]\twlasts_pending\t[0:NM-1];",
            "wire [LGMAXBURST-1:0]\tw_mrpending\t[0:NM-1];\n\t// verilator lint_on  UNUSED",
            "reg [NM-1:0]\t\tmwfull;",
            "reg [NM-1:0]\t\tmrfull;",
            "reg [NM-1:0]\t\tmwempty;",
            "reg [NM-1:0]\t\tmrempty;\n\t//",
            "wire [LGNS-1:0]\t\tmwindex\t[0:NMFULL-1];",
            "wire [LGNS-1:0]\t\tmrindex\t[0:NMFULL-1];",
            "wire [LGNM-1:0]\t\tswindex\t[0:NSFULL-1];",
            "wire [LGNM-1:0]\t\tsrindex\t[0:NSFULL-1];",
            "wire [NM-1:0]\t\twdata_expected;\n\n\t// The shadow buffers",
            "wire [NMFULL-1:0]\tm_awvalid, m_arvalid;",
            "wire [NMFULL-1:0]\tm_wvalid;",
            "wire [NM-1:0]\tdcd_awvalid, dcd_arvalid;",
            "wire [C_AXI_ID_WIDTH-1:0]\t\tm_awid\t\t[0:NMFULL-1];",
            "wire [C_AXI_ADDR_WIDTH-1:0]\t\tm_awaddr\t[0:NMFULL-1];",
            "wire [7:0]\t\t\t\tm_awlen\t\t[0:NMFULL-1];",
            "wire [2:0]\t\t\t\tm_awsize\t[0:NMFULL-1];",
            "wire [1:0]\t\t\t\tm_awburst\t[0:NMFULL-1];",
            "wire [NMFULL-1:0]\t\t\tm_awlock;",
            "wire [3:0]\t\t\t\tm_awcache\t[0:NMFULL-1];",
            "wire [2:0]\t\t\t\tm_awprot\t[0:NMFULL-1];",
            "wire [3:0]\t\t\t\tm_awqos\t\t[0:NMFULL-1];\n\t//",
            "wire [C_AXI_DATA_WIDTH-1:0]\t\tm_wdata\t\t[0:NMFULL-1];",
            "wire [C_AXI_DATA_WIDTH/8-1:0]\tm_wstrb\t\t[0:NMFULL-1];",
            "wire [NMFULL-1:0]\t\t\tm_wlast;",
            "wire [C_AXI_ID_WIDTH-1:0]\t\tm_arid\t\t[0:NMFULL-1];",
            "wire [C_AXI_ADDR_WIDTH-1:0]\t\tm_araddr\t[0:NMFULL-1];",
            "wire [8-1:0]\t\t\t\tm_arlen\t\t[0:NMFULL-1];",
            "wire [3-1:0]\t\t\t\tm_arsize\t[0:NMFULL-1];",
            "wire [2-1:0]\t\t\t\tm_arburst\t[0:NMFULL-1];",
            "wire [NMFULL-1:0]\t\t\tm_arlock;",
            "wire [4-1:0]\t\t\t\tm_arcache\t[0:NMFULL-1];",
            "wire [2:0]\t\t\t\tm_arprot\t[0:NMFULL-1];",
            "wire [3:0]\t\t\t\tm_arqos\t\t[0:NMFULL-1];\n\t//\n\t//",
            "reg [NM-1:0]\t\t\tberr_valid;",
            "reg [IW-1:0]\t\t\tberr_id\t\t[0:NM-1];\n\t//",
            "reg [NM-1:0]\t\t\trerr_none;",
            "reg [NM-1:0]\t\t\trerr_last;",
            "reg [8:0]\t\t\t\trerr_outstanding [0:NM-1];",
            "reg [IW-1:0]\t\t\trerr_id\t\t [0:NM-1];",
            "wire [NM-1:0]\tskd_awvalid, skd_awstall;",
            "wire [NM-1:0]\tskd_arvalid, skd_arstall;",
            "wire [IW-1:0]\tskd_awid\t\t\t[0:NM-1];",
            "wire [AW-1:0]\tskd_awaddr\t\t\t[0:NM-1];",
            "wire [8-1:0]\t\tskd_awlen\t\t\t[0:NM-1];",
            "wire [3-1:0]\t\tskd_awsize\t\t\t[0:NM-1];",
            "wire [2-1:0]\t\tskd_awburst\t\t\t[0:NM-1];",
            "wire [NM-1:0]\tskd_awlock;",
            "wire [4-1:0]\t\tskd_awcache\t\t\t[0:NM-1];",
            "wire [3-1:0]\t\tskd_awprot\t\t\t[0:NM-1];",
            "wire [4-1:0]\t\tskd_awqos\t\t\t[0:NM-1];\n\t//",
            "wire [IW-1:0]\tskd_arid\t\t\t[0:NM-1];",
            "wire [AW-1:0]\tskd_araddr\t\t\t[0:NM-1];",
            "wire [8-1:0]\t\tskd_arlen\t\t\t[0:NM-1];",
            "wire [3-1:0]\t\tskd_arsize\t\t\t[0:NM-1];",
            "wire [2-1:0]\t\tskd_arburst\t\t\t[0:NM-1];",
            "wire [NM-1:0]\tskd_arlock;",
            "wire [4-1:0]\t\tskd_arcache\t\t\t[0:NM-1];",
            "wire [3-1:0]\t\tskd_arprot\t\t\t[0:NM-1];",
            "wire [4-1:0]\t\tskd_arqos\t\t\t[0:NM-1];\n\n\t// Verilator lint_off UNUSED",
            "reg [NSFULL-1:0]\tm_axi_awvalid;",
            "reg [NSFULL-1:0]\tm_axi_awready;",
            "reg [IW-1:0]\tm_axi_awid\t[0:NSFULL-1];",
            "reg [7:0]\t\tm_axi_awlen\t[0:NSFULL-1];",
            "reg [NSFULL-1:0]\tm_axi_wvalid;",
            "reg [NSFULL-1:0]\tm_axi_wready;",
            "reg [NSFULL-1:0]\tm_axi_bvalid;",
            "reg [NSFULL-1:0]\tm_axi_bready;\n\t// Verilator lint_on  UNUSED",
            "reg [1:0]\t\tm_axi_bresp\t[0:NSFULL-1];",
            "reg [IW-1:0]\tm_axi_bid\t[0:NSFULL-1];\n\n\t// Verilator lint_off UNUSED",
            "reg [NSFULL-1:0]\tm_axi_arvalid;",
            "reg [7:0]\t\tm_axi_arlen\t[0:NSFULL-1];",
            "reg [IW-1:0]\tm_axi_arid\t[0:NSFULL-1];",
            "reg [NSFULL-1:0]\tm_axi_arready;\n\t// Verilator lint_on  UNUSED",
            "reg [NSFULL-1:0]\tm_axi_rvalid;\n\t// Verilator lint_off UNUSED",
            "reg [NSFULL-1:0]\tm_axi_rready;\n\t// Verilator lint_on  UNUSED\n\t//",
            "reg [IW-1:0]\tm_axi_rid\t[0:NSFULL-1];",
            "reg [DW-1:0]\tm_axi_rdata\t[0:NSFULL-1];",
            "reg [NSFULL-1:0]\tm_axi_rlast;",
            "reg [2-1:0]\t\tm_axi_rresp\t[0:NSFULL-1];",
            "reg [NM-1:0]\tslave_awaccepts;",
            "reg [NM-1:0]\tslave_waccepts;",
            "reg [NM-1:0]\tslave_raccepts;",
            "reg [NM-1:0]\tbskd_valid;",
            "reg [NM-1:0]\trskd_valid, rskd_rlast;",
            "wire [NM-1:0]\tbskd_ready;",
            "wire [NM-1:0]\trskd_ready;\n\n\t// Verilator lint_off UNUSED",
            "wire [NMFULL-1:0]\twrite_qos_lockout,\n\t\t\t\tread_qos_lockout;\n\t// Verilator lint_on  UNUSED",
            "reg [NSFULL-1:0]\tslave_awready, slave_wready, slave_arready;\n\t// }}}\n\n\t// m_axi_* convenience signals (write side)\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tm_axi_awvalid = -1;\n\t\tm_axi_awready = -1;\n\t\tm_axi_wvalid = -1;\n\t\tm_axi_wready = -1;\n\t\tm_axi_bvalid = 0;\n\t\tm_axi_bready = -1;\n\n\t\tm_axi_awvalid[NS-1:0] = M_AXI_AWVALID;\n\t\tm_axi_awready[NS-1:0] = M_AXI_AWREADY;\n\t\tm_axi_wvalid[NS-1:0]  = M_AXI_WVALID;\n\t\tm_axi_wready[NS-1:0]  = M_AXI_WREADY;\n\t\tm_axi_bvalid[NS-1:0]  = M_AXI_BVALID;\n\t\tm_axi_bready[NS-1:0]  = M_AXI_BREADY;\n\n\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\tbegin\n\t\t\tm_axi_awid[iM]   = M_AXI_AWID[   iM*IW +: IW];\n\t\t\tm_axi_awlen[iM]  = M_AXI_AWLEN[  iM* 8 +:  8];\n\n\t\t\tm_axi_bid[iM]   = M_AXI_BID[iM* IW +:  IW];\n\t\t\tm_axi_bresp[iM] = M_AXI_BRESP[iM* 2 +:  2];\n\n\t\t\tm_axi_rid[iM]   = M_AXI_RID[  iM*IW +: IW];\n\t\t\tm_axi_rdata[iM] = M_AXI_RDATA[iM*DW +: DW];\n\t\t\tm_axi_rresp[iM] = M_AXI_RRESP[iM* 2 +:  2];\n\t\t\tm_axi_rlast[iM] = M_AXI_RLAST[iM];\n\t\tend\n\t\tfor(iM=NS; iM<NSFULL; iM=iM+1)\n\t\tbegin\n\t\t\tm_axi_awid[iM]   = 0;\n\t\t\tm_axi_awlen[iM]  = 0;\n\n\t\t\tm_axi_bresp[iM] = INTERCONNECT_ERROR;\n\t\t\tm_axi_bid[iM]   = 0;\n\n\t\t\tm_axi_rid[iM]   = 0;\n\t\t\tm_axi_rdata[iM] = 0;\n\t\t\tm_axi_rresp[iM] = INTERCONNECT_ERROR;\n\t\t\tm_axi_rlast[iM] = 1;\n\t\tend\n\tend\n\t// }}}\n\n\t// m_axi_* convenience signals (read side)\n\t// {{{\n\talways @(*)\n\tbegin\n\t\tm_axi_arvalid = 0;\n\t\tm_axi_arready = 0;\n\t\tm_axi_rvalid = 0;\n\t\tm_axi_rready = 0;\n\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\tbegin\n\t\t\tm_axi_arlen[iM] = M_AXI_ARLEN[iM* 8 +:  8];\n\t\t\tm_axi_arid[iM]  = M_AXI_ARID[ iM*IW +: IW];\n\t\tend\n\t\tfor(iM=NS; iM<NSFULL; iM=iM+1)\n\t\tbegin\n\t\t\tm_axi_arlen[iM] = 0;\n\t\t\tm_axi_arid[iM]  = 0;\n\t\tend\n\n\t\tm_axi_arvalid[NS-1:0] = M_AXI_ARVALID;\n\t\tm_axi_arready[NS-1:0] = M_AXI_ARREADY;\n\t\tm_axi_rvalid[NS-1:0]  = M_AXI_RVALID;\n\t\tm_axi_rready[NS-1:0]  = M_AXI_RREADY;\n\tend\n\t// }}}\n\n\t// slave_*ready convenience signals\n\t// {{{\n\talways @(*)\n\tbegin\n\t\t// These are designed to keep us from doing things like\n\t\t// m_axi_*[m?index[N]] && m_axi_*[m?index[N]] && .. etc\n\t\t//\n\t\t// First, we'll set bits for all slaves--to include those that\n\t\t// are undefined (but required by our static analysis tools).\n\t\tslave_awready = -1;\n\t\tslave_wready  = -1;\n\t\tslave_arready = -1;\n\t\t//\n\t\t// Here we do all of the combinatoric calculations, so the\n\t\t// master only needs to reference one bit of this signal\n\t\tslave_awready[NS-1:0] = (~M_AXI_AWVALID | M_AXI_AWREADY);\n\t\tslave_wready[NS-1:0]  = (~M_AXI_WVALID | M_AXI_WREADY);\n\t\tslave_arready[NS-1:0] = (~M_AXI_ARVALID | M_AXI_ARREADY);\n\tend\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Process our incoming signals: AW*, W*, and AR*\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : W1_DECODE_WRITE_REQUEST\n\t// {{{",
            "wire [NS:0]\twdecode;\n\n\t\t// awskid, the skidbuffer for the incoming AW* channel\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(IW+AW+8+3+2+1+4+3+4),\n\t\t\t.OPT_OUTREG(OPT_SKID_INPUT)\n\t\t\t// }}}\n\t\t) awskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tS_AXI_AWVALID[N], S_AXI_AWREADY[N],\n\t\t\t{ S_AXI_AWID[N*IW +: IW], S_AXI_AWADDR[N*AW +: AW],\n\t\t\t  S_AXI_AWLEN[N*8 +: 8], S_AXI_AWSIZE[N*3 +: 3],\n\t\t\t  S_AXI_AWBURST[N*2 +: 2], S_AXI_AWLOCK[N],\n\t\t\t  S_AXI_AWCACHE[N*4 +: 4], S_AXI_AWPROT[N*3 +: 3],\n\t\t\t  S_AXI_AWQOS[N*4 +: 4] },\n\t\t\tskd_awvalid[N], !skd_awstall[N],\n\t\t\t{ skd_awid[N], skd_awaddr[N], skd_awlen[N],\n\t\t\t  skd_awsize[N], skd_awburst[N], skd_awlock[N],\n\t\t\t  skd_awcache[N], skd_awprot[N], skd_awqos[N] }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// wraddr, decode the write channel's address request to a\n\t\t// particular slave index\n\t\t// {{{\n\t\taddrdecode #(\n\t\t\t// {{{\n\t\t\t.AW(AW), .DW(IW+8+3+2+1+4+3+4), .NS(NS),\n\t\t\t.SLAVE_ADDR(SLAVE_ADDR),\n\t\t\t.SLAVE_MASK(SLAVE_MASK),\n\t\t\t.OPT_REGISTERED(OPT_BUFFER_DECODER)\n\t\t\t// }}}\n\t\t) wraddr(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t\t.i_valid(skd_awvalid[N]), .o_stall(skd_awstall[N]),\n\t\t\t\t.i_addr(skd_awaddr[N]), .i_data({ skd_awid[N],\n\t\t\t\tskd_awlen[N], skd_awsize[N], skd_awburst[N],\n\t\t\t\tskd_awlock[N], skd_awcache[N], skd_awprot[N],\n\t\t\t\tskd_awqos[N] }),\n\t\t\t.o_valid(dcd_awvalid[N]),\n\t\t\t\t.i_stall(!dcd_awvalid[N]||!slave_awaccepts[N]),\n\t\t\t\t.o_decode(wdecode), .o_addr(m_awaddr[N]),\n\t\t\t\t.o_data({ m_awid[N], m_awlen[N], m_awsize[N],\n\t\t\t\t  m_awburst[N], m_awlock[N], m_awcache[N],\n\t\t\t\t  m_awprot[N], m_awqos[N]})\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// wskid, the skid buffer for the incoming W* channel\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(DW+DW/8+1),\n\t\t\t.OPT_OUTREG(OPT_SKID_INPUT || OPT_BUFFER_DECODER)\n\t\t\t// }}}\n\t\t) wskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tS_AXI_WVALID[N], S_AXI_WREADY[N],\n\t\t\t{ S_AXI_WDATA[N*DW +: DW], S_AXI_WSTRB[N*DW/8 +: DW/8],\n\t\t\t  S_AXI_WLAST[N] },\n\t\t\tm_wvalid[N], slave_waccepts[N],\n\t\t\t{ m_wdata[N], m_wstrb[N], m_wlast[N] }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// slave_awaccepts\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tslave_awaccepts[N] = 1'b1;\n\n\t\t\t// Cannot accept/forward a packet without a bus grant\n\t\t\t// This handles whether or not write data is still\n\t\t\t// pending.\n\t\t\tif (!mwgrant[N])\n\t\t\t\tslave_awaccepts[N] = 1'b0;\n\t\t\tif (write_qos_lockout[N])\n\t\t\t\tslave_awaccepts[N] = 1'b0;\n\t\t\tif (mwfull[N])\n\t\t\t\tslave_awaccepts[N] = 1'b0;\n\t\t\t// Don't accept a packet unless its to the same slave\n\t\t\t// the grant is issued for\n\t\t\tif (!wrequest[N][mwindex[N]])\n\t\t\t\tslave_awaccepts[N] = 1'b0;\n\t\t\tif (!wgrant[N][NS])\n\t\t\tbegin\n\t\t\t\tif (!slave_awready[mwindex[N]])\n\t\t\t\t\tslave_awaccepts[N] = 1'b0;\n\t\t\tend else if (berr_valid[N] && !bskd_ready[N])\n\t\t\tbegin\n\t\t\t\t// Can't accept an write address channel request\n\t\t\t\t// for the no-address-mapped channel if the\n\t\t\t\t// B* channel is stalled, lest we lose the ID\n\t\t\t\t// of the transaction\n\t\t\t\t//\n\t\t\t\t// !berr_valid[N] => we have to accept more\n\t\t\t\t//\twrite data before we can issue BVALID\n\t\t\t\tslave_awaccepts[N] = 1'b0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\t// slave_waccepts\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tslave_waccepts[N] = 1'b1;\n\t\t\tif (!mwgrant[N])\n\t\t\t\tslave_waccepts[N] = 1'b0;\n\t\t\tif (!wdata_expected[N] && (!OPT_AWW || !slave_awaccepts[N]))\n\t\t\t\tslave_waccepts[N] = 1'b0;\n\t\t\tif (!wgrant[N][NS])\n\t\t\tbegin\n\t\t\t\tif (!slave_wready[mwindex[N]])\n\t\t\t\t\tslave_waccepts[N] = 1'b0;\n\t\t\tend else if (berr_valid[N] && !bskd_ready[N])\n\t\t\t\tslave_waccepts[N] = 1'b0;\n\t\tend\n\t\t// }}}",
            "reg r_awvalid;\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tr_awvalid = dcd_awvalid[N] && !mwfull[N];\n\t\t\twrequest[N]= 0;\n\t\t\tif (!mwfull[N])\n\t\t\t\twrequest[N][NS:0] = wdecode;\n\t\tend\n\n\t\tassign\tm_awvalid[N] = r_awvalid;\n\n\t\t// QOS handling via write_qos_lockout\n\t\t// {{{\n\t\tif (!OPT_QOS || NM == 1)\n\t\tbegin : WRITE_NO_QOS\n\n\t\t\t// If we aren't using QOS, then never lock any packets\n\t\t\t// out from arbitration\n\t\t\tassign\twrite_qos_lockout[N] = 0;\n\n\t\tend else begin : WRITE_QOS\n\n\t\t\t// Lock out a master based upon a second master having\n\t\t\t// a higher QOS request level\n\t\t\t// {{{",
            "reg r_write_qos_lockout;\n\n\t\t\tinitial\tr_write_qos_lockout = 0;\n\t\t\talways @(posedge  S_AXI_ACLK)\n\t\t\tif (!S_AXI_ARESETN)\n\t\t\t\tr_write_qos_lockout <= 0;\n\t\t\telse begin\n\t\t\t\tr_write_qos_lockout <= 0;\n\n\t\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\t\tif (iN != N)\n\t\t\t\tbegin\n\t\t\t\t\tif (m_awvalid[N]\n\t\t\t\t\t\t&&(|(wrequest[iN][NS-1:0]\n\t\t\t\t\t\t\t& wdecode[NS-1:0]))\n\t\t\t\t\t\t&&(m_awqos[N] < m_awqos[iN]))\n\t\t\t\t\t\tr_write_qos_lockout <= 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tassign\twrite_qos_lockout[N] = r_write_qos_lockout;\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\n\tend for (N=NM; N<NMFULL; N=N+1)\n\tbegin : UNUSED_WSKID_BUFFERS\n\t// {{{\n\t\t// The following values are unused.  They need to be defined\n\t\t// so that our indexing scheme will work, but indexes should\n\t\t// never actually reference them\n\t\tassign\tm_awid[N]    = 0;\n\t\tassign\tm_awaddr[N]  = 0;\n\t\tassign\tm_awlen[N]   = 0;\n\t\tassign\tm_awsize[N]  = 0;\n\t\tassign\tm_awburst[N] = 0;\n\t\tassign\tm_awlock[N]  = 0;\n\t\tassign\tm_awcache[N] = 0;\n\t\tassign\tm_awprot[N]  = 0;\n\t\tassign\tm_awqos[N]   = 0;\n\n\t\tassign\tm_awvalid[N] = 0;\n\n\t\tassign\tm_wvalid[N]  = 0;\n\t\t//\n\t\tassign\tm_wdata[N] = 0;\n\t\tassign\tm_wstrb[N] = 0;\n\t\tassign\tm_wlast[N] = 0;\n\n\t\tassign\twrite_qos_lockout[N] = 0;\n\t// }}}\n\t// }}}\n\tend endgenerate\n\n\t// Read skid buffers and address decoding, slave_araccepts",
            "logic generate for(N=0; N<NM; N=N+1)\n\tbegin : R1_DECODE_READ_REQUEST\n\t// {{{",
            "reg r_arvalid;",
            "wire [NS:0]\trdecode;\n\n\t\t// arskid\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(IW+AW+8+3+2+1+4+3+4),\n\t\t\t.OPT_OUTREG(OPT_SKID_INPUT)\n\t\t\t// }}}\n\t\t) arskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tS_AXI_ARVALID[N], S_AXI_ARREADY[N],\n\t\t\t{ S_AXI_ARID[N*IW +: IW], S_AXI_ARADDR[N*AW +: AW],\n\t\t\t  S_AXI_ARLEN[N*8 +: 8], S_AXI_ARSIZE[N*3 +: 3],\n\t\t\t  S_AXI_ARBURST[N*2 +: 2], S_AXI_ARLOCK[N],\n\t\t\t  S_AXI_ARCACHE[N*4 +: 4], S_AXI_ARPROT[N*3 +: 3],\n\t\t\t  S_AXI_ARQOS[N*4 +: 4] },\n\t\t\tskd_arvalid[N], !skd_arstall[N],\n\t\t\t{ skd_arid[N], skd_araddr[N], skd_arlen[N],\n\t\t\t  skd_arsize[N], skd_arburst[N], skd_arlock[N],\n\t\t\t  skd_arcache[N], skd_arprot[N], skd_arqos[N] }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// Read address decoder\n\t\t// {{{\n\t\taddrdecode #(\n\t\t\t// {{{\n\t\t\t.AW(AW), .DW(IW+8+3+2+1+4+3+4), .NS(NS),\n\t\t\t.SLAVE_ADDR(SLAVE_ADDR),\n\t\t\t.SLAVE_MASK(SLAVE_MASK),\n\t\t\t.OPT_REGISTERED(OPT_BUFFER_DECODER)\n\t\t\t// }}}\n\t\t) rdaddr(\n\t\t\t// {{{\n\t\t\t.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),\n\t\t\t.i_valid(skd_arvalid[N]), .o_stall(skd_arstall[N]),\n\t\t\t\t.i_addr(skd_araddr[N]), .i_data({ skd_arid[N],\n\t\t\t\tskd_arlen[N], skd_arsize[N], skd_arburst[N],\n\t\t\t\tskd_arlock[N], skd_arcache[N], skd_arprot[N],\n\t\t\t\tskd_arqos[N] }),\n\t\t\t.o_valid(dcd_arvalid[N]),\n\t\t\t\t.i_stall(!m_arvalid[N] || !slave_raccepts[N]),\n\t\t\t\t.o_decode(rdecode), .o_addr(m_araddr[N]),\n\t\t\t\t.o_data({ m_arid[N], m_arlen[N], m_arsize[N],\n\t\t\t\t  m_arburst[N], m_arlock[N], m_arcache[N],\n\t\t\t\t  m_arprot[N], m_arqos[N]})\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tr_arvalid = dcd_arvalid[N] && !mrfull[N];\n\t\t\trrequest[N] = 0;\n\t\t\tif (!mrfull[N])\n\t\t\t\trrequest[N][NS:0] = rdecode;\n\t\tend\n\n\t\tassign\tm_arvalid[N] = r_arvalid;\n\n\t\t// slave_raccepts decoding\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\tslave_raccepts[N] = 1'b1;\n\t\t\tif (!mrgrant[N])\n\t\t\t\tslave_raccepts[N] = 1'b0;\n\t\t\tif (read_qos_lockout[N])\n\t\t\t\tslave_raccepts[N] = 1'b0;\n\t\t\tif (mrfull[N])\n\t\t\t\tslave_raccepts[N] = 1'b0;\n\t\t\t// If we aren't requesting access to the channel we've\n\t\t\t// been granted access to, then we can't accept this\n\t\t\t// verilator lint_off  WIDTH\n\t\t\tif (!rrequest[N][mrindex[N]])\n\t\t\t\tslave_raccepts[N] = 1'b0;\n\t\t\t// verilator lint_on  WIDTH\n\t\t\tif (!rgrant[N][NS])\n\t\t\tbegin\n\t\t\t\tif (!slave_arready[mrindex[N]])\n\t\t\t\t\tslave_raccepts[N] = 1'b0;\n\t\t\tend else if (!mrempty[N] || !rerr_none[N] || rskd_valid[N])\n\t\t\t\tslave_raccepts[N] = 1'b0;\n\t\tend\n\t\t// }}}\n\n\t\t// Read QOS",
            "logic // {{{\n\t\t// read_qos_lockout will get set if a master with a higher\n\t\t// QOS number is requesting a given slave.  It will not\n\t\t// affect existing outstanding packets, but will be used to\n\t\t// prevent further packets from being sent to a given slave.\n\t\tif (!OPT_QOS || NM == 1)\n\t\tbegin : READ_NO_QOS\n\n\t\t\t// If we aren't implementing QOS, then the lockout\n\t\t\t// signal is never set\n\t\t\tassign\tread_qos_lockout[N] = 0;\n\n\t\tend else begin : READ_QOS\n\t\t\t// {{{\n\t\t\t// We set lockout if another master (with a higher\n\t\t\t// QOS) is requesting this slave *and* the slave\n\t\t\t// channel is currently stalled.",
            "reg r_read_qos_lockout;\n\n\t\t\tinitial\tr_read_qos_lockout = 0;\n\t\t\talways @(posedge  S_AXI_ACLK)\n\t\t\tif (!S_AXI_ARESETN)\n\t\t\t\tr_read_qos_lockout <= 0;\n\t\t\telse begin\n\t\t\t\tr_read_qos_lockout <= 0;\n\n\t\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\t\tif (iN != N)\n\t\t\t\tbegin\n\t\t\t\t\tif (m_arvalid[iN]\n\t\t\t\t\t\t&& !slave_raccepts[N]\n\t\t\t\t\t\t&&(|(rrequest[iN][NS-1:0]\n\t\t\t\t\t\t\t& rdecode[NS-1:0]))\n\t\t\t\t\t\t&&(m_arqos[N] < m_arqos[iN]))\n\t\t\t\t\t\tr_read_qos_lockout <= 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tassign\tread_qos_lockout[N] = 0;\n\t\t\t// }}}\n\t\tend\n\t\t// }}}\n\n\tend for (N=NM; N<NMFULL; N=N+1)\n\tbegin : UNUSED_RSKID_BUFFERS\n\t// {{{\n\t\tassign\tm_arvalid[N] = 0;\n\t\tassign\tm_arid[N]    = 0;\n\t\tassign\tm_araddr[N]  = 0;\n\t\tassign\tm_arlen[N]   = 0;\n\t\tassign\tm_arsize[N]  = 0;\n\t\tassign\tm_arburst[N] = 0;\n\t\tassign\tm_arlock[N]  = 0;\n\t\tassign\tm_arcache[N] = 0;\n\t\tassign\tm_arprot[N]  = 0;\n\t\tassign\tm_arqos[N]   = 0;\n\n\t\tassign\tread_qos_lockout[N] = 0;\n\t// }}}\n\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Channel arbitration\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\t// wrequested\n\t// {{{\n\talways @(*)\n\tbegin : W2_DECONFLICT_WRITE_REQUESTS\n\n\t\tfor(iN=0; iN<=NM; iN=iN+1)\n\t\t\twrequested[iN] = 0;\n\n\t\t// Vivado may complain about too many bits for wrequested.\n\t\t// This is (currrently) expected.  mwindex is used to index\n\t\t// into wrequested, and mwindex has LGNS bits, where LGNS\n\t\t// is $clog2(NS+1) rather than $clog2(NS).  The extra bits\n\t\t// are defined to be zeros, but the point is they are defined.\n\t\t// Therefore, no matter what mwindex is, it will always\n\t\t// reference something valid.\n\t\twrequested[NM] = 0;\n\n\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\tbegin\n\t\t\twrequested[0][iM] = 1'b0;\n\t\t\tfor(iN=1; iN<NM ; iN=iN+1)\n\t\t\tbegin\n\t\t\t\t// Continue to request any channel with\n\t\t\t\t// a grant and pending operations\n\t\t\t\tif (wrequest[iN-1][iM] && wgrant[iN-1][iM])\n\t\t\t\t\twrequested[iN][iM] = 1;\n\t\t\t\tif (wrequest[iN-1][iM] && (!mwgrant[iN-1]||mwempty[iN-1]))\n\t\t\t\t\twrequested[iN][iM] = 1;\n\t\t\t\t// Otherwise, if it's already claimed, then\n\t\t\t\t// it can't be claimed again\n\t\t\t\tif (wrequested[iN-1][iM])\n\t\t\t\t\twrequested[iN][iM] = 1;\n\t\t\tend\n\t\t\twrequested[NM][iM] = wrequest[NM-1][iM] || wrequested[NM-1][iM];\n\t\tend\n\tend\n\t// }}}\n\n\t// rrequested\n\t// {{{\n\talways @(*)\n\tbegin : R2_DECONFLICT_READ_REQUESTS\n\n\t\tfor(iN=0; iN<NM ; iN=iN+1)\n\t\t\trrequested[iN] = 0;\n\n\t\t// See the note above for wrequested.  This applies to\n\t\t// rrequested as well.\n\t\trrequested[NM] = 0;\n\n\t\tfor(iM=0; iM<NS; iM=iM+1)\n\t\tbegin\n\t\t\trrequested[0][iM] = 0;\n\t\t\tfor(iN=1; iN<NM ; iN=iN+1)\n\t\t\tbegin\n\t\t\t\t// Continue to request any channel with\n\t\t\t\t// a grant and pending operations\n\t\t\t\tif (rrequest[iN-1][iM] && rgrant[iN-1][iM])\n\t\t\t\t\trrequested[iN][iM] = 1;\n\t\t\t\tif (rrequest[iN-1][iM] && (!mrgrant[iN-1] || mrempty[iN-1]))\n\t\t\t\t\trrequested[iN][iM] = 1;\n\t\t\t\t// Otherwise, if it's already claimed, then\n\t\t\t\t// it can't be claimed again\n\t\t\t\tif (rrequested[iN-1][iM])\n\t\t\t\t\trrequested[iN][iM] = 1;\n\t\t\tend\n\t\t\trrequested[NM][iM] = rrequest[NM-1][iM] || rrequested[NM-1][iM];\n\t\tend\n\tend\n\t// }}}\n\n\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : W3_ARBITRATE_WRITE_REQUESTS\n\t// {{{",
            "reg stay_on_channel;",
            "reg requested_channel_is_available;",
            "reg leave_channel;",
            "reg [LGNS-1:0]\trequested_index;",
            "wire linger;",
            "reg [LGNS-1:0]\tr_mwindex;\n\n\t\t// The basic",
            "logic :\n\t\t// 1. If we must stay_on_channel, then nothing changes\n\t\t// 2. If the requested channel isn't available, then no grant\n\t\t//   is issued\n\t\t// 3. Otherwise, if we need to leave this channel--such as if\n\t\t//   another master is requesting it, then we lose our grant\n\n\t\t// stay_on_channel\n\t\t// {{{\n\t\t// We must stay on the channel if we aren't done working with it\n\t\t// i.e. more writes requested, more acknowledgments expected,\n\t\t// etc.\n\t\talways @(*)\n\t\tbegin\n\t\t\tstay_on_channel = |(wrequest[N][NS:0] & wgrant[N]);\n\t\t\tif (write_qos_lockout[N])\n\t\t\t\tstay_on_channel = 0;\n\n\t\t\t// We must stay on this channel until we've received\n\t\t\t// our last acknowledgment signal.  Only then can we\n\t\t\t// switch grants\n\t\t\tif (mwgrant[N] && !mwempty[N])\n\t\t\t\tstay_on_channel = 1;\n\n\t\t\t// if berr_valid is true, we have a grant to the\n\t\t\t// internal slave-error channel.  While this grant\n\t\t\t// exists, we cannot issue any others.\n\t\t\tif (berr_valid[N])\n\t\t\t\tstay_on_channel = 1;\n\t\tend\n\t\t// }}}\n\n\t\t// requested_channel_is_available\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\t// The channel is available to us if 1) we want it,\n\t\t\t// 2) no one else is using it, and 3) no one earlier\n\t\t\t// has requested it\n\t\t\trequested_channel_is_available =\n\t\t\t\t|(wrequest[N][NS-1:0] & ~swgrant\n\t\t\t\t\t\t& ~wrequested[N][NS-1:0]);\n\n\t\t\t// Of course, the error pseudo-channel is *always*\n\t\t\t// available to us.\n\t\t\tif (wrequest[N][NS])\n\t\t\t\trequested_channel_is_available = 1;\n\n\t\t\t// Likewise, if we are the only master, then the\n\t\t\t// channel is always available on any request\n\t\t\tif (NM < 2)\n\t\t\t\trequested_channel_is_available = m_awvalid[N];\n\t\tend\n\t\t// }}}\n\n\t\t// Linger option, and setting the \"linger\" flag\n\t\t// {{{\n\t\t// If used, linger will hold on to a given channels grant\n\t\t// for some number of clock ticks after the channel has become\n\t\t// idle.  This will spare future requests from the same master\n\t\t// to the same slave from neding to go through the arbitration\n\t\t// clock cycle again--potentially saving a clock period.  If,\n\t\t// however, the master in question requests a different slave\n\t\t// or a different master requests this slave, then the linger\n\t\t// option is voided and the grant given up anyway.\n\t\tif (OPT_LINGER == 0)\n\t\tbegin : NO_LINGER\n\t\t\tassign\tlinger = 0;\n\t\tend else begin : WRITE_LINGER",
            "reg [LGLINGER-1:0]\tlinger_counter;",
            "reg r_linger;\n\n\t\t\tinitial\tr_linger = 0;\n\t\t\tinitial\tlinger_counter = 0;\n\t\t\talways @(posedge S_AXI_ACLK)\n\t\t\tif (!S_AXI_ARESETN || wgrant[N][NS])\n\t\t\tbegin\n\t\t\t\tr_linger <= 0;\n\t\t\t\tlinger_counter <= 0;\n\t\t\tend else if (!mwempty[N] || bskd_valid[N])\n\t\t\tbegin\n\t\t\t\t// While the channel is in use, we set the\n\t\t\t\t// linger counter\n\t\t\t\tlinger_counter <= OPT_LINGER;\n\t\t\t\tr_linger <= 1;\n\t\t\tend else if (linger_counter > 0)\n\t\t\tbegin\n\t\t\t\t// Otherwise, we decrement it until it reaches\n\t\t\t\t// zero\n\t\t\t\tr_linger <= (linger_counter > 1);\n\t\t\t\tlinger_counter <= linger_counter - 1;\n\t\t\tend else\n\t\t\t\tr_linger <= 0;\n\n\t\t\tassign\tlinger = r_linger;\n\t\tend\n\t\t// }}}\n\n\t\t// leave_channel\n\t\t// {{{\n\t\t// True of another master is requesting access to this slave,\n\t\t// or if we are requesting access to another slave.  If QOS\n\t\t// lockout is enabled, then we also leave the channel if a\n\t\t// request with a higher QOS has arrived\n\t\talways @(*)\n\t\tbegin\n\t\t\tleave_channel = 0;\n\t\t\tif (!m_awvalid[N]\n\t\t\t\t&& (!linger || wrequested[NM][mwindex[N]]))\n\t\t\t\t// Leave the channel after OPT_LINGER counts\n\t\t\t\t// of the channel being idle, or when someone\n\t\t\t\t// else asks for the channel\n\t\t\t\tleave_channel = 1;\n\t\t\tif (m_awvalid[N] && !wrequest[N][mwindex[N]])\n\t\t\t\t// Need to leave this channel to connect\n\t\t\t\t// to any other channel\n\t\t\t\tleave_channel = 1;\n\t\t\tif (write_qos_lockout[N])\n\t\t\t\t// Need to leave this channel for another higher\n\t\t\t\t// priority request\n\t\t\t\tleave_channel = 1;\n\t\tend\n\t\t// }}}\n\n\t\t// WRITE GRANT ALLOCATION\n\t\t// {{{\n\t\t// Now that we've done our homework, we can switch grants\n\t\t// if necessary\n\t\tinitial\twgrant[N]  = 0;\n\t\tinitial\tmwgrant[N] = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\twgrant[N]  <= 0;\n\t\t\tmwgrant[N] <= 0;\n\t\tend else if (!stay_on_channel)\n\t\tbegin\n\t\t\tif (requested_channel_is_available)\n\t\t\tbegin\n\t\t\t\t// Switch to a new channel\n\t\t\t\tmwgrant[N] <= 1'b1;\n\t\t\t\twgrant[N]  <= wrequest[N][NS:0];\n\t\t\tend else if (leave_channel)\n\t\t\tbegin\n\t\t\t\t// Revoke the given grant\n\t\t\t\tmwgrant[N] <= 1'b0;\n\t\t\t\twgrant[N]  <= 0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\t// mwindex (",
            "reg istered)\n\t\t// {{{\n\t\talways @(wrequest[N])\n\t\tbegin\n\t\t\trequested_index = 0;\n\t\t\tfor(iM=0; iM<=NS; iM=iM+1)\n\t\t\tif (wrequest[N][iM])\n\t\t\t\trequested_index= requested_index | iM[LGNS-1:0];\n\t\tend\n\n\t\t// Now for mwindex\n\t\tinitial\tr_mwindex = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!stay_on_channel && requested_channel_is_available)\n\t\t\tr_mwindex <= requested_index;\n\n\t\tassign\tmwindex[N] = r_mwindex;\n\t\t// }}}\n\n\tend for (N=NM; N<NMFULL; N=N+1)\n\tbegin\n\n\t\tassign\tmwindex[N] = 0;\n\t// }}}\n\tend endgenerate\n\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : R3_ARBITRATE_READ_REQUESTS\n\t// {{{",
            "reg stay_on_channel;",
            "reg requested_channel_is_available;",
            "reg leave_channel;",
            "reg [LGNS-1:0]\trequested_index;",
            "reg linger;",
            "reg [LGNS-1:0]\tr_mrindex;\n\n\n\t\t// The basic",
            "logic :\n\t\t// 1. If we must stay_on_channel, then nothing changes\n\t\t// 2. If the requested channel isn't available, then no grant\n\t\t//   is issued\n\t\t// 3. Otherwise, if we need to leave this channel--such as if\n\t\t//   another master is requesting it, then we lose our grant\n\n\t\t// stay_on_channel\n\t\t// {{{\n\t\t// We must stay on the channel if we aren't done working with it\n\t\t// i.e. more reads requested, more acknowledgments expected,\n\t\t// etc.\n\t\talways @(*)\n\t\tbegin\n\t\t\tstay_on_channel = |(rrequest[N][NS:0] & rgrant[N]);\n\t\t\tif (read_qos_lockout[N])\n\t\t\t\tstay_on_channel = 0;\n\n\t\t\t// We must stay on this channel until we've received\n\t\t\t// our last acknowledgment signal.  Only then can we\n\t\t\t// switch grants\n\t\t\tif (mrgrant[N] && !mrempty[N])\n\t\t\t\tstay_on_channel = 1;\n\n\t\t\t// if we have a grant to the internal slave-error\n\t\t\t// channel, then we cannot issue a grant to any other\n\t\t\t// while this grant is active\n\t\t\tif (rgrant[N][NS] && (!rerr_none[N] || rskd_valid[N]))\n\t\t\t\tstay_on_channel = 1;\n\t\tend\n\t\t// }}}\n\n\t\t// requested_channel_is_available\n\t\t// {{{\n\t\talways @(*)\n\t\tbegin\n\t\t\t// The channel is available to us if 1) we want it,\n\t\t\t// 2) no one else is using it, and 3) no one earlier\n\t\t\t// has requested it\n\t\t\trequested_channel_is_available =\n\t\t\t\t|(rrequest[N][NS-1:0] & ~srgrant\n\t\t\t\t\t\t& ~rrequested[N][NS-1:0]);\n\n\t\t\t// Of course, the error pseudo-channel is *always*\n\t\t\t// available to us.\n\t\t\tif (rrequest[N][NS])\n\t\t\t\trequested_channel_is_available = 1;\n\n\t\t\t// Likewise, if we are the only master, then the\n\t\t\t// channel is always available on any request\n\t\t\tif (NM < 2)\n\t\t\t\trequested_channel_is_available = m_arvalid[N];\n\t\tend\n\t\t// }}}\n\n\t\t// Linger option, and setting the \"linger\" flag\n\t\t// {{{\n\t\t// If used, linger will hold on to a given channels grant\n\t\t// for some number of clock ticks after the channel has become\n\t\t// idle.  This will spare future requests from the same master\n\t\t// to the same slave from neding to go through the arbitration\n\t\t// clock cycle again--potentially saving a clock period.  If,\n\t\t// however, the master in question requests a different slave\n\t\t// or a different master requests this slave, then the linger\n\t\t// option is voided and the grant given up anyway.\n\t\tif (OPT_LINGER == 0)\n\t\tbegin : NO_LONGER\n\t\t\talways @(*)\n\t\t\t\tlinger = 0;\n\t\tend else begin : READ_LINGER",
            "reg [LGLINGER-1:0]\tlinger_counter;\n\n\t\t\tinitial\tlinger = 0;\n\t\t\tinitial\tlinger_counter = 0;\n\t\t\talways @(posedge S_AXI_ACLK)\n\t\t\tif (!S_AXI_ARESETN || rgrant[N][NS])\n\t\t\tbegin\n\t\t\t\tlinger <= 0;\n\t\t\t\tlinger_counter <= 0;\n\t\t\tend else if (!mrempty[N] || rskd_valid[N])\n\t\t\tbegin\n\t\t\t\tlinger_counter <= OPT_LINGER;\n\t\t\t\tlinger <= 1;\n\t\t\tend else if (linger_counter > 0)\n\t\t\tbegin\n\t\t\t\tlinger <= (linger_counter > 1);\n\t\t\t\tlinger_counter <= linger_counter - 1;\n\t\t\tend else\n\t\t\t\tlinger <= 0;\n\n\t\tend\n\t\t// }}}\n\n\t\t// leave_channel\n\t\t// {{{\n\t\t// True of another master is requesting access to this slave,\n\t\t// or if we are requesting access to another slave.  If QOS\n\t\t// lockout is enabled, then we also leave the channel if a\n\t\t// request with a higher QOS has arrived\n\t\talways @(*)\n\t\tbegin\n\t\t\tleave_channel = 0;\n\t\t\tif (!m_arvalid[N]\n\t\t\t\t&& (!linger || rrequested[NM][mrindex[N]]))\n\t\t\t\t// Leave the channel after OPT_LINGER counts\n\t\t\t\t// of the channel being idle, or when someone\n\t\t\t\t// else asks for the channel\n\t\t\t\tleave_channel = 1;\n\t\t\tif (m_arvalid[N] && !rrequest[N][mrindex[N]])\n\t\t\t\t// Need to leave this channel to connect\n\t\t\t\t// to any other channel\n\t\t\t\tleave_channel = 1;\n\t\t\tif (read_qos_lockout[N])\n\t\t\t\tleave_channel = 1;\n\t\tend\n\t\t// }}}\n\n\n\t\t// READ GRANT ALLOCATION\n\t\t// {{{\n\t\tinitial\trgrant[N]  = 0;\n\t\tinitial\tmrgrant[N] = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\trgrant[N]  <= 0;\n\t\t\tmrgrant[N] <= 0;\n\t\tend else if (!stay_on_channel)\n\t\tbegin\n\t\t\tif (requested_channel_is_available)\n\t\t\tbegin\n\t\t\t\t// Switching channels\n\t\t\t\tmrgrant[N] <= 1'b1;\n\t\t\t\trgrant[N] <= rrequest[N][NS:0];\n\t\t\tend else if (leave_channel)\n\t\t\tbegin\n\t\t\t\tmrgrant[N] <= 1'b0;\n\t\t\t\trgrant[N]  <= 0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\t// mrindex (",
            "reg istered)\n\t\t// {{{\n\t\talways @(rrequest[N])\n\t\tbegin\n\t\t\trequested_index = 0;\n\t\t\tfor(iM=0; iM<=NS; iM=iM+1)\n\t\t\tif (rrequest[N][iM])\n\t\t\t\trequested_index = requested_index|iM[LGNS-1:0];\n\t\tend\n\n\t\tinitial\tr_mrindex = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!stay_on_channel && requested_channel_is_available)\n\t\t\tr_mrindex <= requested_index;\n\n\t\tassign\tmrindex[N] = r_mrindex;\n\t\t// }}}\n\n\tend for (N=NM; N<NMFULL; N=N+1)\n\tbegin\n\n\t\tassign\tmrindex[N] = 0;\n\t// }}}\n\tend endgenerate\n\n\t// Calculate swindex (",
            "reg istered)\n\tgenerate for (M=0; M<NS; M=M+1)\n\tbegin : W4_SLAVE_WRITE_INDEX\n\t// {{{\n\t\t// swindex is a per slave index, containing the index of the\n\t\t// master that has currently won write arbitration and so\n\t\t// has permission to access this slave\n\t\tif (NM <= 1)\n\t\tbegin : SINGLE_MASTER\n\n\t\t\t// If there's only ever one master, that index is\n\t\t\t// always the index of the one master.\n\t\t\tassign\tswindex[M] = 0;\n\n\t\tend else begin : MULTIPLE_MASTERS",
            "reg [LGNM-1:0]\treqwindex, r_swindex;\n\n\t\t\t// In the case of multiple masters, we follow the",
            "logic // of the arbiter to generate the appropriate index\n\t\t\t// here, and",
            "reg ister it on the next clock cycle.  If\n\t\t\t// no slave has arbitration, the index will remain zero\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\treqwindex = 0;\n\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\tif ((!mwgrant[iN] || mwempty[iN])\n\t\t\t\t&&(wrequest[iN][M] && !wrequested[iN][M]))\n\t\t\t\t\treqwindex = reqwindex | iN[LGNM-1:0];\n\t\t\tend\n\n\t\t\talways @(posedge S_AXI_ACLK)\n\t\t\tif (!swgrant[M])\n\t\t\t\tr_swindex <= reqwindex;\n\n\t\t\tassign\tswindex[M] = r_swindex;\n\t\tend\n\n\tend for (M=NS; M<NSFULL; M=M+1)\n\tbegin : W4_UNUSED_MASTERS\n\n\t\tassign\tswindex[M] = 0;\n\t// }}}\n\tend endgenerate\n\n\t// Calculate srindex (",
            "reg istered)\n\tgenerate for (M=0; M<NS; M=M+1)\n\tbegin : R4_SLAVE_READ_INDEX\n\t// {{{\n\t\t// srindex is an index to the master that has currently won\n\t\t// read arbitration to the given slave.\n\n\t\tif (NM <= 1)\n\t\tbegin : SINGLE_MASTER\n\t\t\t// If there's only one master, srindex can always\n\t\t\t// point to that master--no longic required\n\t\t\tassign\tsrindex[M] = 0;\n\n\t\tend else begin : MULTIPLE_MASTERS",
            "reg [LGNM-1:0]\treqrindex, r_srindex;\n\n\t\t\t// In the case of multiple masters, we'll follow the\n\t\t\t// read arbitration",
            "logic to generate the index--first\n\t\t\t// combinatorially, then we'll",
            "reg ister it.\n\t\t\talways @(*)\n\t\t\tbegin\n\t\t\t\treqrindex = 0;\n\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\tif ((!mrgrant[iN] || mrempty[iN])\n\t\t\t\t&&(rrequest[iN][M] && !rrequested[iN][M]))\n\t\t\t\t\treqrindex = reqrindex | iN[LGNM-1:0];\n\t\t\tend\n\n\t\t\talways @(posedge S_AXI_ACLK)\n\t\t\tif (!srgrant[M])\n\t\t\t\tr_srindex <= reqrindex;\n\n\t\t\tassign\tsrindex[M] = r_srindex;\n\t\tend\n\n\tend for (M=NS; M<NSFULL; M=M+1)\n\tbegin : R4_UNUSED_MASTERS\n\n\t\tassign\tsrindex[M] = 0;\n\t// }}}\n\tend endgenerate\n\n\t// swgrant and srgrant (combinatorial)\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : SGRANT\n\t// {{{\n\n\t\t// s?grant is a convenience to tell a slave that some master\n\t\t// has won arbitration and so has a grant to that slave.\n\n\t\t// swgrant: write arbitration\n\t\tinitial\tswgrant = 0;\n\t\talways @(*)\n\t\tbegin\n\t\t\tswgrant[M] = 0;\n\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\tif (wgrant[iN][M])\n\t\t\t\tswgrant[M] = 1;\n\t\tend\n\n\t\tinitial\tsrgrant = 0;\n\t\t// srgrant: read arbitration\n\t\talways @(*)\n\t\tbegin\n\t\t\tsrgrant[M] = 0;\n\t\t\tfor(iN=0; iN<NM; iN=iN+1)\n\t\t\tif (rgrant[iN][M])\n\t\t\t\tsrgrant[M] = 1;\n\t\tend\n\t// }}}\n\tend endgenerate\n\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Generate the signals for the various slaves--the forward channel\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assign",
            "output s to the various slaves\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : W5_WRITE_SLAVE_OUTPUTS\n\t// {{{",
            "reg axi_awvalid;",
            "reg [IW-1:0]\taxi_awid;",
            "reg [AW-1:0]\taxi_awaddr;",
            "reg [7:0]\t\taxi_awlen;",
            "reg [2:0]\t\taxi_awsize;",
            "reg [1:0]\t\taxi_awburst;",
            "reg axi_awlock;",
            "reg [3:0]\t\taxi_awcache;",
            "reg [2:0]\t\taxi_awprot;",
            "reg [3:0]\t\taxi_awqos;",
            "reg axi_wvalid;",
            "reg [DW-1:0]\taxi_wdata;",
            "reg [DW/8-1:0]\taxi_wstrb;",
            "reg axi_wlast;\n\t\t//",
            "reg axi_bready;",
            "reg sawstall, swstall;",
            "reg awaccepts;\n\n\t\t// Control the slave's AW* channel\n\t\t// {{{\n\n\t\t// Personalize the slave_awaccepts signal\n\t\talways @(*)\n\t\t\tawaccepts = slave_awaccepts[swindex[M]];\n\n\t\talways @(*)\n\t\t\tsawstall= (M_AXI_AWVALID[M]&& !M_AXI_AWREADY[M]);\n\n\t\tinitial\taxi_awvalid = 0;\n\t\talways @(posedge  S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || !swgrant[M])\n\t\t\taxi_awvalid <= 0;\n\t\telse if (!sawstall)\n\t\tbegin\n\t\t\taxi_awvalid <= m_awvalid[swindex[M]] &&(awaccepts);\n\t\tend\n\n\t\tinitial\taxi_awid    = 0;\n\t\tinitial\taxi_awaddr  = 0;\n\t\tinitial\taxi_awlen   = 0;\n\t\tinitial\taxi_awsize  = 0;\n\t\tinitial\taxi_awburst = 0;\n\t\tinitial\taxi_awlock  = 0;\n\t\tinitial\taxi_awcache = 0;\n\t\tinitial\taxi_awprot  = 0;\n\t\tinitial\taxi_awqos   = 0;\n\t\talways @(posedge  S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && (!S_AXI_ARESETN || !swgrant[M]))\n\t\tbegin\n\t\t\t// Under the OPT_LOWPOWER option, we clear all signals\n\t\t\t// we aren't using\n\t\t\taxi_awid    <= 0;\n\t\t\taxi_awaddr  <= 0;\n\t\t\taxi_awlen   <= 0;\n\t\t\taxi_awsize  <= 0;\n\t\t\taxi_awburst <= 0;\n\t\t\taxi_awlock  <= 0;\n\t\t\taxi_awcache <= 0;\n\t\t\taxi_awprot  <= 0;\n\t\t\taxi_awqos   <= 0;\n\t\tend else if (!sawstall)\n\t\tbegin\n\t\t\tif (!OPT_LOWPOWER||(m_awvalid[swindex[M]]&&awaccepts))\n\t\t\tbegin\n\t\t\t\t// swindex[M] is defined as 0 above in the\n\t\t\t\t// case where NM <= 1\n\t\t\t\taxi_awid    <= m_awid[   swindex[M]];\n\t\t\t\taxi_awaddr  <= m_awaddr[ swindex[M]];\n\t\t\t\taxi_awlen   <= m_awlen[  swindex[M]];\n\t\t\t\taxi_awsize  <= m_awsize[ swindex[M]];\n\t\t\t\taxi_awburst <= m_awburst[swindex[M]];\n\t\t\t\taxi_awlock  <= m_awlock[ swindex[M]];\n\t\t\t\taxi_awcache <= m_awcache[swindex[M]];\n\t\t\t\taxi_awprot  <= m_awprot[ swindex[M]];\n\t\t\t\taxi_awqos   <= m_awqos[  swindex[M]];\n\t\t\tend else begin\n\t\t\t\taxi_awid    <= 0;\n\t\t\t\taxi_awaddr  <= 0;\n\t\t\t\taxi_awlen   <= 0;\n\t\t\t\taxi_awsize  <= 0;\n\t\t\t\taxi_awburst <= 0;\n\t\t\t\taxi_awlock  <= 0;\n\t\t\t\taxi_awcache <= 0;\n\t\t\t\taxi_awprot  <= 0;\n\t\t\t\taxi_awqos   <= 0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\t// Control the slave's W* channel\n\t\t// {{{\n\t\talways @(*)\n\t\t\tswstall = (M_AXI_WVALID[M] && !M_AXI_WREADY[M]);\n\n\t\tinitial\taxi_wvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || !swgrant[M])\n\t\t\taxi_wvalid <= 0;\n\t\telse if (!swstall)\n\t\tbegin\n\t\t\taxi_wvalid <= (m_wvalid[swindex[M]])\n\t\t\t\t\t&&(slave_waccepts[swindex[M]]);\n\t\tend\n\n\t\tinitial axi_wdata  = 0;\n\t\tinitial axi_wstrb  = 0;\n\t\tinitial axi_wlast  = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && !S_AXI_ARESETN)\n\t\tbegin\n\t\t\taxi_wdata  <= 0;\n\t\t\taxi_wstrb  <= 0;\n\t\t\taxi_wlast  <= 0;\n\t\tend else if (OPT_LOWPOWER && !swgrant[M])\n\t\tbegin\n\t\t\taxi_wdata  <= 0;\n\t\t\taxi_wstrb  <= 0;\n\t\t\taxi_wlast  <= 0;\n\t\tend else if (!swstall)\n\t\tbegin\n\t\t\tif (!OPT_LOWPOWER || (m_wvalid[swindex[M]]&&slave_waccepts[swindex[M]]))\n\t\t\tbegin\n\t\t\t\t// If NM <= 1, swindex[M] is already defined\n\t\t\t\t// to be zero above\n\t\t\t\taxi_wdata  <= m_wdata[swindex[M]];\n\t\t\t\taxi_wstrb  <= m_wstrb[swindex[M]];\n\t\t\t\taxi_wlast  <= m_wlast[swindex[M]];\n\t\t\tend else begin\n\t\t\t\taxi_wdata  <= 0;\n\t\t\t\taxi_wstrb  <= 0;\n\t\t\t\taxi_wlast  <= 0;\n\t\t\tend\n\t\tend\n\t\t// }}}\n\n\t\t//\n\t\talways @(*)\n\t\tif (!swgrant[M])\n\t\t\taxi_bready = 1;\n\t\telse\n\t\t\taxi_bready = bskd_ready[swindex[M]];\n\n\t\t// Combinatorial assigns\n\t\t// {{{\n\t\tassign\tM_AXI_AWVALID[M]          = axi_awvalid;\n\t\tassign\tM_AXI_AWID[   M*IW +: IW] = axi_awid;\n\t\tassign\tM_AXI_AWADDR[ M*AW +: AW] = axi_awaddr;\n\t\tassign\tM_AXI_AWLEN[  M* 8 +:  8] = axi_awlen;\n\t\tassign\tM_AXI_AWSIZE[ M* 3 +:  3] = axi_awsize;\n\t\tassign\tM_AXI_AWBURST[M* 2 +:  2] = axi_awburst;\n\t\tassign\tM_AXI_AWLOCK[ M]          = axi_awlock;\n\t\tassign\tM_AXI_AWCACHE[M* 4 +:  4] = axi_awcache;\n\t\tassign\tM_AXI_AWPROT[ M* 3 +:  3] = axi_awprot;\n\t\tassign\tM_AXI_AWQOS[  M* 4 +:  4] = axi_awqos;\n\t\t//\n\t\t//\n\t\tassign\tM_AXI_WVALID[M]             = axi_wvalid;\n\t\tassign\tM_AXI_WDATA[M*DW +: DW]     = axi_wdata;\n\t\tassign\tM_AXI_WSTRB[M*DW/8 +: DW/8] = axi_wstrb;\n\t\tassign\tM_AXI_WLAST[M]              = axi_wlast;\n\t\t//\n\t\t//\n\t\tassign\tM_AXI_BREADY[M]             = axi_bready;\n\t\t// }}}\n\t\t//\n\t// }}}\n\tend endgenerate\n\n\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : R5_READ_SLAVE_OUTPUTS\n\t// {{{",
            "reg axi_arvalid;",
            "reg [IW-1:0]\t\taxi_arid;",
            "reg [AW-1:0]\t\taxi_araddr;",
            "reg [7:0]\t\t\taxi_arlen;",
            "reg [2:0]\t\t\taxi_arsize;",
            "reg [1:0]\t\t\taxi_arburst;",
            "reg axi_arlock;",
            "reg [3:0]\t\t\taxi_arcache;",
            "reg [2:0]\t\t\taxi_arprot;",
            "reg [3:0]\t\t\taxi_arqos;\n\t\t//",
            "reg axi_rready;",
            "reg arstall;\n\n\t\talways @(*)\n\t\t\tarstall= axi_arvalid && !M_AXI_ARREADY[M];\n\n\t\tinitial\taxi_arvalid = 0;\n\t\talways @(posedge  S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN || !srgrant[M])\n\t\t\taxi_arvalid <= 0;\n\t\telse if (!arstall)\n\t\t\taxi_arvalid <= m_arvalid[srindex[M]] && slave_raccepts[srindex[M]];\n\t\telse if (M_AXI_ARREADY[M])\n\t\t\taxi_arvalid <= 0;\n\n\t\tinitial axi_arid    = 0;\n\t\tinitial axi_araddr  = 0;\n\t\tinitial axi_arlen   = 0;\n\t\tinitial axi_arsize  = 0;\n\t\tinitial axi_arburst = 0;\n\t\tinitial axi_arlock  = 0;\n\t\tinitial axi_arcache = 0;\n\t\tinitial axi_arprot  = 0;\n\t\tinitial axi_arqos   = 0;\n\t\talways @(posedge  S_AXI_ACLK)\n\t\tif (OPT_LOWPOWER && (!S_AXI_ARESETN || !srgrant[M]))\n\t\tbegin\n\t\t\taxi_arid    <= 0;\n\t\t\taxi_araddr  <= 0;\n\t\t\taxi_arlen   <= 0;\n\t\t\taxi_arsize  <= 0;\n\t\t\taxi_arburst <= 0;\n\t\t\taxi_arlock  <= 0;\n\t\t\taxi_arcache <= 0;\n\t\t\taxi_arprot  <= 0;\n\t\t\taxi_arqos   <= 0;\n\t\tend else if (!arstall)\n\t\tbegin\n\t\t\tif (!OPT_LOWPOWER || (m_arvalid[srindex[M]] && slave_raccepts[srindex[M]]))\n\t\t\tbegin\n\t\t\t\t// If NM <=1, srindex[M] is defined to be zero\n\t\t\t\taxi_arid    <= m_arid[   srindex[M]];\n\t\t\t\taxi_araddr  <= m_araddr[ srindex[M]];\n\t\t\t\taxi_arlen   <= m_arlen[  srindex[M]];\n\t\t\t\taxi_arsize  <= m_arsize[ srindex[M]];\n\t\t\t\taxi_arburst <= m_arburst[srindex[M]];\n\t\t\t\taxi_arlock  <= m_arlock[ srindex[M]];\n\t\t\t\taxi_arcache <= m_arcache[srindex[M]];\n\t\t\t\taxi_arprot  <= m_arprot[ srindex[M]];\n\t\t\t\taxi_arqos   <= m_arqos[  srindex[M]];\n\t\t\tend else begin\n\t\t\t\taxi_arid    <= 0;\n\t\t\t\taxi_araddr  <= 0;\n\t\t\t\taxi_arlen   <= 0;\n\t\t\t\taxi_arsize  <= 0;\n\t\t\t\taxi_arburst <= 0;\n\t\t\t\taxi_arlock  <= 0;\n\t\t\t\taxi_arcache <= 0;\n\t\t\t\taxi_arprot  <= 0;\n\t\t\t\taxi_arqos   <= 0;\n\t\t\tend\n\t\tend\n\n\t\talways @(*)\n\t\tif (!srgrant[M])\n\t\t\taxi_rready = 1;\n\t\telse\n\t\t\taxi_rready = rskd_ready[srindex[M]];\n\n\t\t//\n\t\tassign\tM_AXI_ARVALID[M]          = axi_arvalid;\n\t\tassign\tM_AXI_ARID[   M*IW +: IW] = axi_arid;\n\t\tassign\tM_AXI_ARADDR[ M*AW +: AW] = axi_araddr;\n\t\tassign\tM_AXI_ARLEN[  M* 8 +:  8] = axi_arlen;\n\t\tassign\tM_AXI_ARSIZE[ M* 3 +:  3] = axi_arsize;\n\t\tassign\tM_AXI_ARBURST[M* 2 +:  2] = axi_arburst;\n\t\tassign\tM_AXI_ARLOCK[ M]          = axi_arlock;\n\t\tassign\tM_AXI_ARCACHE[M* 4 +:  4] = axi_arcache;\n\t\tassign\tM_AXI_ARPROT[ M* 3 +:  3] = axi_arprot;\n\t\tassign\tM_AXI_ARQOS[  M* 4 +:  4] = axi_arqos;\n\t\t//\n\t\tassign\tM_AXI_RREADY[M]          = axi_rready;\n\t\t//\n\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Generate the signals for the various masters--the return channel\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Return values\n\tgenerate for (N=0; N<NM; N=N+1)\n\tbegin : W6_WRITE_RETURN_CHANNEL\n\t// {{{",
            "reg [1:0]\ti_axi_bresp;",
            "reg [IW-1:0] i_axi_bid;\n\n\t\t// Write error (no slave selected) state machine\n\t\t// {{{\n\t\tinitial\tberr_valid[N] = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tberr_valid[N] <= 0;\n\t\telse if (wgrant[N][NS] && m_wvalid[N] && m_wlast[N]\n\t\t\t\t&& slave_waccepts[N])\n\t\t\tberr_valid[N] <= 1;\n\t\telse if (bskd_ready[N])\n\t\t\tberr_valid[N] <= 0;\n\n\t\talways @(*)\n\t\tif (berr_valid[N])\n\t\t\tbskd_valid[N] = 1;\n\t\telse\n\t\t\tbskd_valid[N] = mwgrant[N]&&m_axi_bvalid[mwindex[N]];\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (m_awvalid[N] && slave_awaccepts[N])\n\t\t\tberr_id[N] <= m_awid[N];\n\n\t\talways @(*)\n\t\tif (wgrant[N][NS])\n\t\tbegin\n\t\t\ti_axi_bid   = berr_id[N];\n\t\t\ti_axi_bresp = INTERCONNECT_ERROR;\n\t\tend else begin\n\t\t\ti_axi_bid   = m_axi_bid[mwindex[N]];\n\t\t\ti_axi_bresp = m_axi_bresp[mwindex[N]];\n\t\tend\n\t\t// }}}\n\n\t\t// bskid, the B* channel skidbuffer\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(IW+2),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_OUTREG(1)\n\t\t\t// }}}\n\t\t) bskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tbskd_valid[N], bskd_ready[N],\n\t\t\t{ i_axi_bid, i_axi_bresp },\n\t\t\tS_AXI_BVALID[N], S_AXI_BREADY[N],\n\t\t\t{ S_AXI_BID[N*IW +: IW], S_AXI_BRESP[N*2 +: 2] }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\t// }}}\n\tend endgenerate\n\n\t// Return values\n\tgenerate for (N=0; N<NM; N=N+1)\n\tbegin : R6_READ_RETURN_CHANNEL\n\t// {{{",
            "reg [DW-1:0]\ti_axi_rdata;",
            "reg [IW-1:0]\ti_axi_rid;",
            "reg [2-1:0]\t\ti_axi_rresp;\n\n\t\t// generate the read response\n\t\t// {{{\n\t\t// Here we have two choices.  We can either generate our\n\t\t// response from the slave itself, or from our internally\n\t\t// generated (no-slave exists) FSM.\n\t\talways @(*)\n\t\tif (rgrant[N][NS])\n\t\t\trskd_valid[N] = !rerr_none[N];\n\t\telse\n\t\t\trskd_valid[N] = mrgrant[N] && m_axi_rvalid[mrindex[N]];\n\n\t\talways @(*)\n\t\tif (rgrant[N][NS])\n\t\tbegin\n\t\t\ti_axi_rid   = rerr_id[N];\n\t\t\ti_axi_rdata = 0;\n\t\t\trskd_rlast[N] = rerr_last[N];\n\t\t\ti_axi_rresp = INTERCONNECT_ERROR;\n\t\tend else begin\n\t\t\ti_axi_rid   = m_axi_rid[mrindex[N]];\n\t\t\ti_axi_rdata = m_axi_rdata[mrindex[N]];\n\t\t\trskd_rlast[N]= m_axi_rlast[mrindex[N]];\n\t\t\ti_axi_rresp = m_axi_rresp[mrindex[N]];\n\t\tend\n\t\t// }}}\n\n\t\t// rskid, the outgoing read skidbuffer\n\t\t// {{{\n\t\t// Since our various read signals are all combinatorially\n\t\t// determined, we'll throw them into an outgoing skid buffer\n\t\t// to",
            "reg ister them (per spec) and to make it easier to meet\n\t\t// timing.\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(IW+DW+1+2),\n\t\t\t.OPT_LOWPOWER(OPT_LOWPOWER),\n\t\t\t.OPT_OUTREG(1)\n\t\t\t// }}}\n\t\t) rskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\trskd_valid[N], rskd_ready[N],\n\t\t\t{ i_axi_rid, i_axi_rdata, rskd_rlast[N], i_axi_rresp },\n\t\t\tS_AXI_RVALID[N], S_AXI_RREADY[N],\n\t\t\t{ S_AXI_RID[N*IW +: IW], S_AXI_RDATA[N*DW +: DW],\n\t\t\t  S_AXI_RLAST[N], S_AXI_RRESP[N*2 +: 2] }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Count pending transactions\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate for (N=0; N<NM; N=N+1)\n\tbegin : W7_COUNT_PENDING_WRITES\n\t// {{{",
            "reg [LGMAXBURST-1:0]\tawpending, wpending;",
            "reg r_wdata_expected;\n\n\t\t// awpending, and the associated flags mwempty and mwfull\n\t\t// {{{\n\t\t// awpending is a count of all of the AW* packets that have\n\t\t// been forwarded to the slave, but for which the slave has\n\t\t// yet to return a B* response.  This number can be as large\n\t\t// as (1<<LGMAXBURST)-1.  The two associated flags, mwempty\n\t\t// and mwfull, are there to keep us from checking awempty==0\n\t\t// and &awempty respectively.\n\t\tinitial\tawpending    = 0;\n\t\tinitial\tmwempty[N]   = 1;\n\t\tinitial\tmwfull[N]    = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\tawpending     <= 0;\n\t\t\tmwempty[N]    <= 1;\n\t\t\tmwfull[N]     <= 0;\n\t\tend else case ({(m_awvalid[N] && slave_awaccepts[N]),\n\t\t\t\t(bskd_valid[N] && bskd_ready[N])})\n\t\t2'b01: begin\n\t\t\tawpending     <= awpending - 1;\n\t\t\tmwempty[N]    <= (awpending <= 1);\n\t\t\tmwfull[N]     <= 0;\n\t\t\tend\n\t\t2'b10: begin\n\t\t\tawpending <= awpending + 1;\n\t\t\tmwempty[N] <= 0;\n\t\t\tmwfull[N]     <= &awpending[LGMAXBURST-1:1];\n\t\t\tend\n\t\tdefault: begin end\n\t\tendcase\n\n\t\t// Just so we can access this counter elsewhere, let's make\n\t\t// it available outside of this generate block.  (The formal\n\t\t// section uses this.)\n\t\tassign\tw_mawpending[N] = awpending;\n\t\t// }}}\n\n\t\t// r_wdata_expected and wdata_expected\n\t\t// {{{\n\t\t// This section keeps track of whether or not we are expecting\n\t\t// more W* data from the given burst.  It's designed to keep us\n\t\t// from accepting new W* information before the AW* portion\n\t\t// has been routed to the new slave.\n\t\t//\n\t\t// Addition: wpending.  wpending counts the number of write\n\t\t// bursts that are pending, based upon the write channel.\n\t\t// Bursts are counted from AWVALID & AWREADY, and decremented\n\t\t// once we see the WVALID && WREADY signal.  Packets should\n\t\t// not be accepted without a prior (or concurrent)\n\t\t// AWVALID && AWREADY.\n\t\tinitial\tr_wdata_expected = 0;\n\t\tinitial\twpending = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\tr_wdata_expected <= 0;\n\t\t\twpending <= 0;\n\t\tend else case ({(m_awvalid[N] && slave_awaccepts[N]),\n\t\t\t\t(m_wvalid[N]&&slave_waccepts[N] && m_wlast[N])})\n\t\t2'b01: begin\n\t\t\tr_wdata_expected <= (wpending > 1);\n\t\t\twpending <= wpending - 1;\n\t\t\tend\n\t\t2'b10: begin\n\t\t\twpending <= wpending + 1;\n\t\t\tr_wdata_expected <= 1;\n\t\t\tend\n\t\tdefault: begin end\n\t\tendcase\n\n\t\tassign\twdata_expected[N] = r_wdata_expected;\n\n\t\tassign wlasts_pending[N] = wpending;\n\t\t// }}}\n\t// }}}\n\tend endgenerate\n\n\tgenerate for (N=0; N<NM; N=N+1)\n\tbegin : R7_COUNT_PENDING_READS\n\t// {{{",
            "reg [LGMAXBURST-1:0]\trpending;\n\n\t\t// rpending, and its associated mrempty and mrfull\n\t\t// {{{\n\t\t// rpending counts the number of read transactions that have\n\t\t// been accepted, but for which rlast has yet to be returned.\n\t\t// This specifically counts grants to valid slaves.  The error\n\t\t// slave is excluded from this count.  mrempty and mrfull have\n\t\t// analogous definitions to mwempty and mwfull, being equal to\n\t\t// rpending == 0 and (&rpending) respectfully.\n\t\tinitial\trpending     = 0;\n\t\tinitial\tmrempty[N]   = 1;\n\t\tinitial\tmrfull[N]    = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\trpending  <= 0;\n\t\t\tmrempty[N]<= 1;\n\t\t\tmrfull[N] <= 0;\n\t\tend else case ({(m_arvalid[N] && slave_raccepts[N] && !rgrant[N][NS]),\n\t\t\t\t(rskd_valid[N] && rskd_ready[N]\n\t\t\t\t\t&& rskd_rlast[N] && !rgrant[N][NS])})\n\t\t2'b01: begin\n\t\t\trpending      <= rpending - 1;\n\t\t\tmrempty[N]    <= (rpending == 1);\n\t\t\tmrfull[N]     <= 0;\n\t\t\tend\n\t\t2'b10: begin\n\t\t\trpending      <= rpending + 1;\n\t\t\tmrfull[N]     <= &rpending[LGMAXBURST-1:1];\n\t\t\tmrempty[N]    <= 0;\n\t\t\tend\n\t\tdefault: begin end\n\t\tendcase\n\n\t\tassign\tw_mrpending[N]  = rpending;\n\t\t// }}}\n\n\t\t// Read error state machine, rerr_outstanding and rerr_id\n\t\t// {{{\n\t\t// rerr_outstanding is the count of read *beats* that remain\n\t\t// to be returned to a master from a non-existent slave.\n\t\t// rerr_last is true on the last of these read beats,\n\t\t// equivalent to rerr_outstanding == 1, and rerr_none is true\n\t\t// when the error state machine is idle\n\t\tinitial\trerr_outstanding[N] = 0;\n\t\tinitial\trerr_last[N] = 0;\n\t\tinitial\trerr_none[N] = 1;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\tbegin\n\t\t\trerr_outstanding[N] <= 0;\n\t\t\trerr_last[N] <= 0;\n\t\t\trerr_none[N] <= 1;\n\t\tend else if (!rerr_none[N])\n\t\tbegin\n\t\t\tif (!rskd_valid[N] || rskd_ready[N])\n\t\t\tbegin\n\t\t\t\trerr_none[N] <= (rerr_outstanding[N] == 1);\n\t\t\t\trerr_last[N] <= (rerr_outstanding[N] == 2);\n\t\t\t\trerr_outstanding[N] <= rerr_outstanding[N] - 1;\n\t\t\tend\n\t\tend else if (m_arvalid[N] && rrequest[N][NS]\n\t\t\t\t\t\t&& slave_raccepts[N])\n\t\tbegin\n\t\t\trerr_none[N] <= 0;\n\t\t\trerr_last[N] <= (m_arlen[N] == 0);\n\t\t\trerr_outstanding[N] <= m_arlen[N] + 1;\n\t\tend\n\n\t\t// rerr_id is the ARID field of the currently outstanding\n\t\t// error.  It's used when generating a read response to a\n\t\t// non-existent slave.\n\t\tinitial\trerr_id[N] = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN && OPT_LOWPOWER)\n\t\t\trerr_id[N] <= 0;\n\t\telse if (m_arvalid[N] && slave_raccepts[N])\n\t\tbegin\n\t\t\tif (rrequest[N][NS] || !OPT_LOWPOWER)\n\t\t\t\t// A low-",
            "logic definition\n\t\t\t\trerr_id[N] <= m_arid[N];\n\t\t\telse\n\t\t\t\trerr_id[N] <= 0;\n\t\tend else if (OPT_LOWPOWER && rerr_last[N]\n\t\t\t\t&& (!rskd_valid[N] || rskd_ready[N]))\n\t\t\trerr_id[N] <= 0;\n\t\t// }}}\n\n`ifdef\tFORMAL\n\t\talways @(*)\n\t\t\tassert(rerr_none[N] ==  (rerr_outstanding[N] == 0));\n\t\talways @(*)\n\t\t\tassert(rerr_last[N] ==  (rerr_outstanding[N] == 1));\n\t\talways @(*)\n\t\tif (OPT_LOWPOWER && rerr_none[N])\n\t\t\tassert(rerr_id[N] ==  0);\n`endif\n\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// (Partial) Parameter validation\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tinitial begin\n\t\tif (NM == 0) begin\n                        $display(\"At least one master must be defined\");\n                        $stop;\n                end\n\n\t\tif (NS == 0) begin\n                        $display(\"At least one slave must be defined\");\n                        $stop;\n                end\n        end\n\t// }}}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal property verification section\n// {{{\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "localparam F_LGDEPTH = LGMAXBURST+9;\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Declare signals used for formal checking\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t//\n\t// ...\n\t//\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Initial/reset value checking\n\t// {{{\n\tinitial\tassert(NS >= 1);\n\tinitial\tassert(NM >= 1);\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Check the arbiter signals for consistency\n\t// {{{\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : F1_CHECK_MASTER_GRANTS\n\t// {{{\n\t\t// Write grants\n\t\talways @(*)\n\t\tfor(iM=0; iM<=NS; iM=iM+1)\n\t\tbegin\n\t\t\tif (wgrant[N][iM])\n\t\t\tbegin\n\t\t\t\tassert((wgrant[N] ^ (1<<iM))==0);\n\t\t\t\tassert(mwgrant[N]);\n\t\t\t\tassert(mwindex[N] == iM);\n\t\t\t\tif (iM < NS)\n\t\t\t\tbegin\n\t\t\t\t\tassert(swgrant[iM]);\n\t\t\t\t\tassert(swindex[iM] == N);\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\talways @(*)\n\t\tif (mwgrant[N])\n\t\t\tassert(wgrant[N] != 0);\n\n\t\talways @(*)\n\t\tif (wrequest[N][NS])\n\t\t\tassert(wrequest[N][NS-1:0] == 0);\n\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (S_AXI_ARESETN && f_past_valid && bskd_valid[N])\n\t\tbegin\n\t\t\tassert($stable(wgrant[N]));\n\t\t\tassert($stable(mwindex[N]));\n\t\tend\n\n\t\t////////////////////////////////////////////////////////////////\n\t\t//\n\t\t// Read grant checking\n\t\t//\n\t\talways @(*)\n\t\tfor(iM=0; iM<=NS; iM=iM+1)\n\t\tbegin\n\t\t\tif (rgrant[N][iM])\n\t\t\tbegin\n\t\t\t\tassert((rgrant[N] ^ (1<<iM))==0);\n\t\t\t\tassert(mrgrant[N]);\n\t\t\t\tassert(mrindex[N] == iM);\n\t\t\t\tif (iM < NS)\n\t\t\t\tbegin\n\t\t\t\t\tassert(srgrant[iM]);\n\t\t\t\t\tassert(srindex[iM] == N);\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\talways @(*)\n\t\tif (mrgrant[N])\n\t\t\tassert(rgrant[N] != 0);\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (S_AXI_ARESETN && f_past_valid && S_AXI_RVALID[N])\n\t\tbegin\n\t\t\tassert($stable(rgrant[N]));\n\t\t\tassert($stable(mrindex[N]));\n\t\t\tif (!rgrant[N][NS])\n\t\t\t\tassert(!mrempty[N]);\n\t\tend\n\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI signaling check, (incoming) master side\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : F2_CHECK_MASTERS\n\t// {{{\n\t\tfaxi_slave #(\n\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_DATA_WIDTH(DW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t.F_OPT_ASSUME_RESET(1'b1),\n\t\t\t.F_AXI_MAXSTALL(0),\n\t\t\t.F_AXI_MAXRSTALL(2),\n\t\t\t.F_AXI_MAXDELAY(0),\n\t\t\t.F_OPT_READCHECK(0),\n\t\t\t.F_OPT_NO_RESET(1),\n\t\t\t.F_LGDEPTH(F_LGDEPTH))\n\t\t  mstri(.i_clk(S_AXI_ACLK),\n\t\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t\t//\n\t\t\t.i_axi_awid(   S_AXI_AWID[   N*IW +:IW]),\n\t\t\t.i_axi_awaddr( S_AXI_AWADDR[ N*AW +:AW]),\n\t\t\t.i_axi_awlen(  S_AXI_AWLEN[  N* 8 +: 8]),\n\t\t\t.i_axi_awsize( S_AXI_AWSIZE[ N* 3 +: 3]),\n\t\t\t.i_axi_awburst(S_AXI_AWBURST[N* 2 +: 2]),\n\t\t\t.i_axi_awlock( S_AXI_AWLOCK[ N]),\n\t\t\t.i_axi_awcache(S_AXI_AWCACHE[N* 4 +: 4]),\n\t\t\t.i_axi_awprot( S_AXI_AWPROT[ N* 3 +: 3]),\n\t\t\t.i_axi_awqos(  S_AXI_AWQOS[  N* 4 +: 4]),\n\t\t\t.i_axi_awvalid(S_AXI_AWVALID[N]),\n\t\t\t.i_axi_awready(S_AXI_AWREADY[N]),\n\t\t\t//\n\t\t\t.i_axi_wdata( S_AXI_WDATA[ N*DW   +: DW]),\n\t\t\t.i_axi_wstrb( S_AXI_WSTRB[ N*DW/8 +: DW/8]),\n\t\t\t.i_axi_wlast( S_AXI_WLAST[ N]),\n\t\t\t.i_axi_wvalid(S_AXI_WVALID[N]),\n\t\t\t.i_axi_wready(S_AXI_WREADY[N]),\n\t\t\t//\n\t\t\t.i_axi_bid(   S_AXI_BID[   N*IW +:IW]),\n\t\t\t.i_axi_bresp( S_AXI_BRESP[ N*2 +: 2]),\n\t\t\t.i_axi_bvalid(S_AXI_BVALID[N]),\n\t\t\t.i_axi_bready(S_AXI_BREADY[N]),\n\t\t\t//\n\t\t\t.i_axi_arid(   S_AXI_ARID[   N*IW +:IW]),\n\t\t\t.i_axi_arready(S_AXI_ARREADY[N]),\n\t\t\t.i_axi_araddr( S_AXI_ARADDR[ N*AW +:AW]),\n\t\t\t.i_axi_arlen(  S_AXI_ARLEN[  N* 8 +: 8]),\n\t\t\t.i_axi_arsize( S_AXI_ARSIZE[ N* 3 +: 3]),\n\t\t\t.i_axi_arburst(S_AXI_ARBURST[N* 2 +: 2]),\n\t\t\t.i_axi_arlock( S_AXI_ARLOCK[ N]),\n\t\t\t.i_axi_arcache(S_AXI_ARCACHE[N* 4 +: 4]),\n\t\t\t.i_axi_arprot( S_AXI_ARPROT[ N* 3 +: 3]),\n\t\t\t.i_axi_arqos(  S_AXI_ARQOS[  N* 4 +: 4]),\n\t\t\t.i_axi_arvalid(S_AXI_ARVALID[N]),\n\t\t\t//\n\t\t\t//\n\t\t\t.i_axi_rid(   S_AXI_RID[   N*IW +: IW]),\n\t\t\t.i_axi_rdata( S_AXI_RDATA[ N*DW +: DW]),\n\t\t\t.i_axi_rresp( S_AXI_RRESP[ N* 2 +: 2]),\n\t\t\t.i_axi_rlast( S_AXI_RLAST[ N]),\n\t\t\t.i_axi_rvalid(S_AXI_RVALID[N]),\n\t\t\t.i_axi_rready(S_AXI_RREADY[N]),\n\t\t\t//\n\t\t\t// ...\n\t\t\t//\n\t\t\t);\n\n\t\t//\n\t\t// ...\n\t\t//\n\n\t\t//\n\t\t// Check full/empty flags\n\t\t//\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tassert(mwfull[N] == &w_mawpending[N]);\n\t\t\tassert(mwempty[N] == (w_mawpending[N] == 0));\n\t\tend\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tassert(mrfull[N] == &w_mrpending[N]);\n\t\t\tassert(mrempty[N] == (w_mrpending[N] == 0));\n\t\tend\n\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI signaling check, (outgoing) slave side\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\tgenerate for(M=0; M<NS; M=M+1)\n\tbegin : F3_CHECK_SLAVES\n\t// {{{\n\t\tfaxi_master #(\n\t\t\t.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_DATA_WIDTH(DW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t.F_OPT_ASSUME_RESET(1'b1),\n\t\t\t.F_AXI_MAXSTALL(2),\n\t\t\t.F_AXI_MAXRSTALL(0),\n\t\t\t.F_AXI_MAXDELAY(2),\n\t\t\t.F_OPT_READCHECK(0),\n\t\t\t.F_OPT_NO_RESET(1),\n\t\t\t.F_LGDEPTH(F_LGDEPTH))\n\t\t  slvi(.i_clk(S_AXI_ACLK),\n\t\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t\t//\n\t\t\t.i_axi_awid(   M_AXI_AWID[   M*IW+:IW]),\n\t\t\t.i_axi_awaddr( M_AXI_AWADDR[ M*AW +: AW]),\n\t\t\t.i_axi_awlen(  M_AXI_AWLEN[  M*8 +: 8]),\n\t\t\t.i_axi_awsize( M_AXI_AWSIZE[ M*3 +: 3]),\n\t\t\t.i_axi_awburst(M_AXI_AWBURST[M*2 +: 2]),\n\t\t\t.i_axi_awlock( M_AXI_AWLOCK[ M]),\n\t\t\t.i_axi_awcache(M_AXI_AWCACHE[M*4 +: 4]),\n\t\t\t.i_axi_awprot( M_AXI_AWPROT[ M*3 +: 3]),\n\t\t\t.i_axi_awqos(  M_AXI_AWQOS[  M*4 +: 4]),\n\t\t\t.i_axi_awvalid(M_AXI_AWVALID[M]),\n\t\t\t.i_axi_awready(M_AXI_AWREADY[M]),\n\t\t\t//\n\t\t\t.i_axi_wready(M_AXI_WREADY[M]),\n\t\t\t.i_axi_wdata( M_AXI_WDATA[ M*DW   +: DW]),\n\t\t\t.i_axi_wstrb( M_AXI_WSTRB[ M*DW/8 +: DW/8]),\n\t\t\t.i_axi_wlast( M_AXI_WLAST[ M]),\n\t\t\t.i_axi_wvalid(M_AXI_WVALID[M]),\n\t\t\t//\n\t\t\t.i_axi_bid(   M_AXI_BID[   M*IW +: IW]),\n\t\t\t.i_axi_bresp( M_AXI_BRESP[ M*2 +: 2]),\n\t\t\t.i_axi_bvalid(M_AXI_BVALID[M]),\n\t\t\t.i_axi_bready(M_AXI_BREADY[M]),\n\t\t\t//\n\t\t\t.i_axi_arid(   M_AXI_ARID[   M*IW +:IW]),\n\t\t\t.i_axi_araddr( M_AXI_ARADDR[ M*AW +:AW]),\n\t\t\t.i_axi_arlen(  M_AXI_ARLEN[  M*8  +: 8]),\n\t\t\t.i_axi_arsize( M_AXI_ARSIZE[ M*3  +: 3]),\n\t\t\t.i_axi_arburst(M_AXI_ARBURST[M*2  +: 2]),\n\t\t\t.i_axi_arlock( M_AXI_ARLOCK[ M]),\n\t\t\t.i_axi_arcache(M_AXI_ARCACHE[M* 4 +: 4]),\n\t\t\t.i_axi_arprot( M_AXI_ARPROT[ M* 3 +: 3]),\n\t\t\t.i_axi_arqos(  M_AXI_ARQOS[  M* 4 +: 4]),\n\t\t\t.i_axi_arvalid(M_AXI_ARVALID[M]),\n\t\t\t.i_axi_arready(M_AXI_ARREADY[M]),\n\t\t\t//\n\t\t\t//\n\t\t\t.i_axi_rresp( M_AXI_RRESP[ M*2 +: 2]),\n\t\t\t.i_axi_rvalid(M_AXI_RVALID[M]),\n\t\t\t.i_axi_rdata( M_AXI_RDATA[ M*DW +: DW]),\n\t\t\t.i_axi_rready(M_AXI_RREADY[M]),\n\t\t\t.i_axi_rlast( M_AXI_RLAST[ M]),\n\t\t\t.i_axi_rid(   M_AXI_RID[   M*IW +: IW]),\n\t\t\t//\n\t\t\t// ...\n\t\t\t//\n\t\t\t);\n\n\t\t\t//\n\t\t\t// ...\n\t\t\t//\n\n\t\talways @(*)\n\t\tif (M_AXI_AWVALID[M])\n\t\t\tassert(((M_AXI_AWADDR[M*AW +:AW]^SLAVE_ADDR[M*AW +:AW])\n\t\t\t\t& SLAVE_MASK[M*AW +: AW]) == 0);\n\n\t\talways @(*)\n\t\tif (M_AXI_ARVALID[M])\n\t\t\tassert(((M_AXI_ARADDR[M*AW +:AW]^SLAVE_ADDR[M*AW +:AW])\n\t\t\t\t& SLAVE_MASK[M*AW +: AW]) == 0);\n\t// }}}\n\tend endgenerate\n\t// }}}\n\n\t// m_axi_* convenience signals\n\t// {{{\n\t// ...\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// ...\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : // ...\n\t// {{{\n\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Double buffer checks\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : F4_DOUBLE_BUFFER_CHECKS\n\t// {{{\n\t// ...\n\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Can every master reach every slave?\n\t// Can things transition without dropping the request line(s)?\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : F5_COVER_CONNECTIVITY_FROM_MASTER\n\t// {{{\n\t// ...\n\t// }}}\n\tend endgenerate\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Focused check: How fast can one master talk to each of the slaves?\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// ...\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Focused check: How fast can one master talk to a particular slave?\n\t// We'll pick master 1 and slave 1.\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// ...\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Poor man's cover check\n\t// {{{\n\t// ...\n\t// }}}\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Negation check\n\t// {{{\n\t// Pick a particular value.  Assume the value doesn't show up on the\n\t//",
            "input .  Prove it doesn't show up on the",
            "output .  This will check for\n\t// ...\n\t// 1. Stuck bits on the",
            "output channel\n\t// 2. Cross-talk between channels\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// ...\n\t// }}}\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Artificially constraining assumptions\n\t// {{{\n\t// Ideally, this section should be empty--there should be no\n\t// assumptions here.  The existence of these assumptions should\n\t// give you an idea of where I'm at with this project.\n\t//\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate for(N=0; N<NM; N=N+1)\n\tbegin : F6_LIMITING_ASSUMPTIONS\n\n\t\tif (!OPT_WRITES)\n\t\tbegin\n\t\t\talways @(*)\n\t\t\t\tassume(S_AXI_AWVALID[N] == 0);\n\t\t\talways @(*)\n\t\t\t\tassert(wgrant[N] == 0);\n\t\t\talways @(*)\n\t\t\t\tassert(mwgrant[N] == 0);\n\t\t\talways @(*)\n\t\t\t\tassert(S_AXI_BVALID[N]== 0);\n\t\tend\n\n\t\tif (!OPT_READS)\n\t\tbegin\n\t\t\talways @(*)\n\t\t\t\tassume(S_AXI_ARVALID [N]== 0);\n\t\t\talways @(*)\n\t\t\t\tassert(rgrant[N] == 0);\n\t\t\talways @(*)\n\t\t\t\tassert(S_AXI_RVALID[N] == 0);\n\t\tend\n\n\tend endgenerate\n\n\talways@(*)\n\t\tassert(OPT_READS | OPT_WRITES);\n\t// }}}\n`endif\n// }}}",
            "endmodule "
        ]
    },
    {
        "file_name": "axi2axilite.v",
        "file_path": "/Users/frankliu/Desktop/fa24/Takehome/bronco-zipcpu/sim/rtl/axi2axilite.v",
        "chunks": [
            "module axi2axilite #(\n\t\t// {{{",
            "parameter integer C_AXI_ID_WIDTH\t= 2,",
            "parameter integer C_AXI_DATA_WIDTH\t= 32,",
            "parameter integer C_AXI_ADDR_WIDTH\t= 6,",
            "parameter [0:0]\tOPT_WRITES\t= 1,",
            "parameter [0:0]\tOPT_READS\t= 1,",
            "parameter [0:0]\tOPT_LOWPOWER    = 0,\n\t\t// Log (based two) of the maximum number of outstanding AXI\n\t\t// (not AXI-lite) transactions.  If you multiply 2^LGFIFO * 256,\n\t\t// you'll get the maximum number of outstanding AXI-lite\n\t\t// transactions",
            "parameter LGFIFO\t\t\t= 4\n\t\t// }}}\n\t) (\n\t\t// {{{",
            "input ",
            "wire S_AXI_ACLK,",
            "input ",
            "wire S_AXI_ARESETN,\n\t\t// AXI4 slave interface\n\t\t// {{{\n\t\t// Write address channel\n\t\t// {{{",
            "input ",
            "wire S_AXI_AWVALID,",
            "output ",
            "wire S_AXI_AWREADY,",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tS_AXI_AWID,",
            "input ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tS_AXI_AWADDR,",
            "input ",
            "wire [7:0]\t\t\tS_AXI_AWLEN,",
            "input ",
            "wire [2:0]\t\t\tS_AXI_AWSIZE,",
            "input ",
            "wire [1:0]\t\t\tS_AXI_AWBURST,",
            "input ",
            "wire S_AXI_AWLOCK,",
            "input ",
            "wire [3:0]\t\t\tS_AXI_AWCACHE,",
            "input ",
            "wire [2:0]\t\t\tS_AXI_AWPROT,",
            "input ",
            "wire [3:0]\t\t\tS_AXI_AWQOS,\n\t\t// }}}\n\t\t// Write data channel\n\t\t// {{{",
            "input ",
            "wire S_AXI_WVALID,",
            "output ",
            "wire S_AXI_WREADY,",
            "input ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tS_AXI_WDATA,",
            "input ",
            "wire [(C_AXI_DATA_WIDTH/8)-1:0] S_AXI_WSTRB,",
            "input ",
            "wire S_AXI_WLAST,\n\t\t// }}}\n\t\t// Write return channel\n\t\t// {{{",
            "output ",
            "wire S_AXI_BVALID,",
            "input ",
            "wire S_AXI_BREADY,",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0]\tS_AXI_BID,",
            "output ",
            "wire [1:0]\t\t\tS_AXI_BRESP,\n\t\t// }}}\n\t\t// Read address channel\n\t\t// {{{",
            "input ",
            "wire S_AXI_ARVALID,",
            "output ",
            "wire S_AXI_ARREADY,",
            "input ",
            "wire [C_AXI_ID_WIDTH-1:0]\tS_AXI_ARID,",
            "input ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tS_AXI_ARADDR,",
            "input ",
            "wire [7:0]\t\t\tS_AXI_ARLEN,",
            "input ",
            "wire [2:0]\t\t\tS_AXI_ARSIZE,",
            "input ",
            "wire [1:0]\t\t\tS_AXI_ARBURST,",
            "input ",
            "wire S_AXI_ARLOCK,",
            "input ",
            "wire [3:0]\t\t\tS_AXI_ARCACHE,",
            "input ",
            "wire [2:0]\t\t\tS_AXI_ARPROT,",
            "input ",
            "wire [3:0]\t\t\tS_AXI_ARQOS,\n\t\t// }}}\n\t\t// Read data channel\n\t\t// {{{",
            "output ",
            "wire S_AXI_RVALID,",
            "input ",
            "wire S_AXI_RREADY,",
            "output ",
            "wire [C_AXI_ID_WIDTH-1:0] S_AXI_RID,",
            "output ",
            "wire [C_AXI_DATA_WIDTH-1:0] S_AXI_RDATA,",
            "output ",
            "wire [1:0]\t\t\tS_AXI_RRESP,",
            "output ",
            "wire S_AXI_RLAST,\n\t\t// }}}\n\t\t// }}}\n\t\t// AXI-lite master interface\n\t\t// {{{\n\t\t// AXI-lite Write interface\n\t\t// {{{",
            "output ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tM_AXI_AWADDR,",
            "output ",
            "wire [2 : 0]\t\t\tM_AXI_AWPROT,",
            "output ",
            "wire M_AXI_AWVALID,",
            "input ",
            "wire M_AXI_AWREADY,",
            "output ",
            "wire [C_AXI_DATA_WIDTH-1:0]\tM_AXI_WDATA,",
            "output ",
            "wire [(C_AXI_DATA_WIDTH/8)-1:0] M_AXI_WSTRB,",
            "output ",
            "wire M_AXI_WVALID,",
            "input ",
            "wire M_AXI_WREADY,",
            "input ",
            "wire [1 : 0]\t\t\tM_AXI_BRESP,",
            "input ",
            "wire M_AXI_BVALID,",
            "output ",
            "wire M_AXI_BREADY,\n\t\t// }}}\n\t\t// AXI-lite read interface\n\t\t// {{{",
            "output ",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tM_AXI_ARADDR,",
            "output ",
            "wire [2:0]\t\t\tM_AXI_ARPROT,",
            "output ",
            "wire M_AXI_ARVALID,",
            "input ",
            "wire M_AXI_ARREADY,\n\t\t//",
            "input ",
            "wire M_AXI_RVALID,",
            "output ",
            "wire M_AXI_RREADY,",
            "input ",
            "wire [C_AXI_DATA_WIDTH-1 : 0] M_AXI_RDATA,",
            "input ",
            "wire [1 : 0]\t\t\tM_AXI_RRESP\n\t\t// }}}\n\t\t// }}}\n\t\t// }}}\n\t);\n\n\t// Local",
            "parameter s,",
            "reg ister, and net declarations\n\t// {{{",
            "localparam [1:0]\tSLVERR = 2'b10;\n\t//",
            "localparam [1:0]\tOKAY   = 2'b00,\n\t//\t\t\tEXOKAY = 2'b01,\n\t//\t\t\tDECERR = 2'b10;",
            "localparam AW = C_AXI_ADDR_WIDTH;",
            "localparam DW = C_AXI_DATA_WIDTH;",
            "localparam IW = C_AXI_ID_WIDTH;\n\t// }}}\n\t// Register declarations\n\t// {{{\n\t//\n\t// Write",
            "reg isters",
            "wire s_axi_wready;",
            "reg [C_AXI_ADDR_WIDTH-1:0]\taxi_awaddr;",
            "wire [7:0]\t\t\taxi_awlen;",
            "reg [1:0]\t\t\taxi_awburst;",
            "reg [2:0]\t\t\taxi_awsize;",
            "wire [4:0]\t\t\twfifo_count;",
            "wire wfifo_full;",
            "wire wfifo_empty;",
            "wire [7:0]\t\t\twfifo_bcount;",
            "wire [IW-1:0]\t\twfifo_bid;",
            "wire [8:0]\t\t\tbcounts;",
            "wire read_from_wrfifo;\n\t//\n\t// Read",
            "reg ister",
            "wire [4:0]\t\t\trfifo_count;",
            "wire rfifo_full;",
            "wire rfifo_empty;",
            "wire [7:0]\t\t\taxi_arlen;",
            "wire [IW-1:0]\t\trid;\n\n\t//\n\t// S_AXI_AW* skid buffer",
            "wire skids_awvalid, skids_awready;",
            "wire [IW-1:0]\tskids_awid;",
            "wire [AW-1:0]\tskids_awaddr;",
            "wire [7:0]\t\tskids_awlen;",
            "wire [2:0]\t\tskids_awsize;",
            "wire [1:0]\t\tskids_awburst;\n\t//\n\t// S_AXI_W* skid buffer",
            "wire skids_wvalid, skids_wready, skids_wlast;",
            "wire [DW-1:0]\tskids_wdata;",
            "wire [DW/8-1:0]\tskids_wstrb;\n\t//\n\t// S_AXI_B* skid buffer isn't needed\n\t//\n\t// M_AXI_AW* skid buffer isn't needed\n\t//\n\t// M_AXI_W* skid buffer",
            "wire skidm_wvalid, skidm_wready;",
            "wire [DW-1:0]\tskidm_wdata;",
            "wire [DW/8-1:0]\tskidm_wstrb;\n\t//\n\t// M_AXI_B* skid buffer",
            "wire skidm_bvalid, skidm_bready;",
            "wire [1:0]\t\tskidm_bresp;\n\t//\n\t//\n\t//\n\t// S_AXI_AR* skid buffer",
            "wire skids_arvalid, skids_arready;",
            "wire [IW-1:0]\tskids_arid;",
            "wire [AW-1:0]\tskids_araddr;",
            "wire [7:0]\t\tskids_arlen;",
            "wire [2:0]\t\tskids_arsize;",
            "wire [1:0]\t\tskids_arburst;\n\t//\n\t// S_AXI_R* skid buffer isn't needed\n\t//\n\t// M_AXI_AR* skid buffer isn't needed\n\t// M_AXI_R* skid buffer",
            "wire skidm_rvalid, skidm_rready;",
            "wire [DW-1:0]\tskidm_rdata;",
            "wire [1:0]\t\tskidm_rresp;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Write",
            "logic // {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (OPT_WRITES)\n\tbegin : IMPLEMENT_WRITES\n\t\t// {{{",
            "reg s_axi_bvalid;",
            "reg [1:0]\t\t\tr_axi_bresp;",
            "wire [1:0]\t\t\taxi_bresp;",
            "reg [C_AXI_ID_WIDTH-1:0]\tr_axi_bid, r_bid;",
            "wire [C_AXI_ID_WIDTH-1:0]\taxi_bid, bid;",
            "reg [8:0]\t\t\tr_bcounts;",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tnext_write_addr;",
            "reg [7:0]\t\t\tr_axi_awlen, axi_blen;",
            "reg r_axi_wready;",
            "reg m_axi_awvalid;\n\n\t\t// The write address channel's skid buffer\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(IW+AW+8+3+2), .OPT_LOWPOWER(0), .OPT_OUTREG(0)\n\t\t\t// }}}\n\t\t) awskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tS_AXI_AWVALID, S_AXI_AWREADY,\n\t\t\t{ S_AXI_AWID, S_AXI_AWADDR, S_AXI_AWLEN, S_AXI_AWSIZE,\n\t\t\t\tS_AXI_AWBURST },\n\t\t\tskids_awvalid, skids_awready,\n\t\t\t{ skids_awid, skids_awaddr, skids_awlen, skids_awsize,\n\t\t\t\tskids_awburst }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\t\t//\n\t\t// The write data channel's skid buffer (S_AXI_W*)\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(DW+DW/8+1), .OPT_LOWPOWER(0), .OPT_OUTREG(0)\n\t\t\t// }}}\n\t\t) wskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tS_AXI_WVALID, S_AXI_WREADY,\n\t\t\t{ S_AXI_WDATA, S_AXI_WSTRB, S_AXI_WLAST },\n\t\t\tskids_wvalid, skids_wready,\n\t\t\t{ skids_wdata, skids_wstrb, skids_wlast }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\t\t//\n\t\t// The downstream AXI-lite write data (M_AXI_W*) skid buffer\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(DW+DW/8), .OPT_LOWPOWER(0), .OPT_OUTREG(1)\n\t\t\t// }}}\n\t\t) mwskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tskidm_wvalid, skidm_wready, { skidm_wdata, skidm_wstrb },\n\t\t\tM_AXI_WVALID,M_AXI_WREADY,{ M_AXI_WDATA, M_AXI_WSTRB }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\t\t//\n\t\t// The downstream AXI-lite response (M_AXI_B*) skid buffer\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(2), .OPT_LOWPOWER(0), .OPT_OUTREG(0)\n\t\t\t// }}}\n\t\t) bskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tM_AXI_BVALID, M_AXI_BREADY, { M_AXI_BRESP },\n\t\t\tskidm_bvalid, skidm_bready, { skidm_bresp }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// m_axi_awvalid\n\t\t// {{{\n\t\tinitial\tm_axi_awvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tm_axi_awvalid <= 0;\n\t\telse if (skids_awvalid & skids_awready)\n\t\t\tm_axi_awvalid <= 1;\n\t\telse if (M_AXI_AWREADY && axi_awlen == 0)\n\t\t\tm_axi_awvalid <= 0;\n\n\t\tassign\tM_AXI_AWVALID = m_axi_awvalid;\n\t\t// }}}\n\n\t\t// skids_awready\n\t\t// {{{\n\t\tassign\tskids_awready = (!M_AXI_AWVALID\n\t\t\t\t|| ((axi_awlen == 0)&&M_AXI_AWREADY))\n\t\t\t\t&& !wfifo_full\n\t\t\t\t&&(!s_axi_wready || (skids_wvalid && skids_wlast && skids_wready));\n\t\t// }}}\n\n\t\t// Address processing\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (skids_awvalid && skids_awready)\n\t\tbegin\n\t\t\taxi_awaddr <= skids_awaddr;\n\t\t\taxi_blen   <= skids_awlen;\n\t\t\taxi_awburst<= skids_awburst;\n\t\t\taxi_awsize <= skids_awsize;\n\t\tend else if (M_AXI_AWVALID && M_AXI_AWREADY)\n\t\t\taxi_awaddr <= next_write_addr;\n\t\t// }}}\n\n\t\t// axi_awlen\n\t\t// {{{\n\t\tinitial\tr_axi_awlen = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_axi_awlen <= 0;\n\t\telse if (skids_awvalid && skids_awready)\n\t\t\tr_axi_awlen <= skids_awlen;\n\t\telse if (M_AXI_AWVALID && M_AXI_AWREADY && axi_awlen > 0)\n\t\t\tr_axi_awlen <= r_axi_awlen - 1;\n\n\t\tassign\taxi_awlen = r_axi_awlen;\n\t\t// }}}\n\n\t\t// axi_addr\n\t\t// {{{\n\t\taxi_addr #(\n\t\t\t// {{{\n\t\t\t.AW(C_AXI_ADDR_WIDTH), .DW(C_AXI_DATA_WIDTH)\n\t\t\t// }}}\n\t\t) calcwraddr(\n\t\t\t// {{{\n\t\t\taxi_awaddr, axi_awsize, axi_awburst,\n\t\t\taxi_blen, next_write_addr\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// s_axi_wready\n\t\t// {{{\n\t\t// We really don't need to do anything special to the write\n\t\t// channel.\n\t\tinitial\tr_axi_wready = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_axi_wready <= 0;\n\t\telse if (skids_awvalid && skids_awready)\n\t\t\tr_axi_wready <= 1;\n\t\telse if (skids_wvalid && skids_wready && skids_wlast)\n\t\t\tr_axi_wready <= 0;\n\t\tassign\ts_axi_wready = r_axi_wready;\n\t\t// }}}\n\n\t\t// skidm*, and read_from_wrfifo\n\t\t// {{{\n\t\tassign\tskidm_wdata  = skids_wdata;\n\t\tassign\tskidm_wstrb  = skids_wstrb;\n\t\tassign\tskidm_wvalid = skids_wvalid && s_axi_wready;\n\t\tassign\tskids_wready = s_axi_wready && skidm_wready;\n\n\t\tassign\tread_from_wrfifo = (bcounts <= 1)&&(!wfifo_empty)\n\t\t\t    &&(skidm_bvalid && skidm_bready);\n\t\t// }}}\n\n\t\t// BFIFO\n\t\t// {{{\n\t\tsfifo\t#(\n\t\t\t.BW(C_AXI_ID_WIDTH+8), .LGFLEN(LGFIFO)\n\t\t) bidlnfifo(\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tskids_awvalid && skids_awready,\n\t\t\t{ skids_awid, skids_awlen },\n\t\t\twfifo_full, wfifo_count,\n\t\t\tread_from_wrfifo,\n\t\t\t{ wfifo_bid, wfifo_bcount }, wfifo_empty);\n\t\t// }}}\n\n\t\t// bcounts\n\t\t// {{{\n\t\t// Return counts\n\t\tinitial\tr_bcounts = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_bcounts <= 0;\n\t\telse if (read_from_wrfifo)\n\t\tbegin\n\t\t\tr_bcounts <= wfifo_bcount + bcounts;\n\t\tend else if (skidm_bvalid && skidm_bready)\n\t\t\tr_bcounts <= bcounts - 1;\n\t\tassign\tbcounts = r_bcounts;\n\t\t// }}}\n\n\t\t// bid\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (read_from_wrfifo)\n\t\t\tr_bid <= wfifo_bid;\n\t\tassign\tbid = r_bid;\n\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_BVALID || S_AXI_BREADY)\n\t\t\tr_axi_bid <= (read_from_wrfifo && bcounts==0) ? wfifo_bid : bid;\n\t\tassign\taxi_bid = r_axi_bid;\n\t\t// }}}\n\n\t\t// s_axi_bvalid\n\t\t// {{{\n\t\tinitial\ts_axi_bvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\ts_axi_bvalid <= 0;\n\t\telse if (skidm_bvalid && skidm_bready)\n\t\t\ts_axi_bvalid <= (bcounts == 1)\n\t\t\t\t||((bcounts == 0) && (!wfifo_empty) && (wfifo_bcount == 0));\n\t\telse if (S_AXI_BREADY)\n\t\t\ts_axi_bvalid <= 0;\n\t\t// }}}\n\n\t\t// axi_bresp\n\t\t// {{{\n\t\tinitial\tr_axi_bresp = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_axi_bresp <= 0;\n\t\telse if (S_AXI_BVALID && S_AXI_BREADY)\n\t\tbegin\n\t\t\tif (skidm_bvalid && skidm_bready)\n\t\t\t\tr_axi_bresp <= skidm_bresp;\n\t\t\telse\n\t\t\t\tr_axi_bresp <= 0;\n\t\tend else if (skidm_bvalid && skidm_bready)\n\t\tbegin\n\t\t\t// Let SLVERR take priority over DECERR\n\t\t\tcasez({ S_AXI_BRESP, skidm_bresp })\n\t\t\t4'b??0?: r_axi_bresp <= S_AXI_BRESP;\n\t\t\t4'b0?1?: r_axi_bresp <= skidm_bresp;\n\t\t\t4'b1?10: r_axi_bresp <= SLVERR;\n\t\t\t4'b1011: r_axi_bresp <= SLVERR;\n\t\t\t4'b1111: r_axi_bresp <= skidm_bresp;\n\t\t\tendcase\n\t\tend\n\n\t\tassign\taxi_bresp = r_axi_bresp;\n\t\t// /}}}\n\n\t\t// M_AXI_AW*\n\t\t// {{{\n\t\tassign\tM_AXI_AWVALID= m_axi_awvalid;\n\t\tassign\tM_AXI_AWADDR = axi_awaddr;\n\t\tassign\tM_AXI_AWPROT = 0;\n\t\t// }}}\n\n\t\t// skidm_bready, S_AXI_B*\n\t\t// {{{\n\t\tassign\tskidm_bready = ((bcounts > 0)||(!wfifo_empty))&&(!S_AXI_BVALID | S_AXI_BREADY);\n\t\tassign\tS_AXI_BID    = axi_bid;\n\t\tassign\tS_AXI_BRESP  = axi_bresp;\n\t\tassign\tS_AXI_BVALID = s_axi_bvalid;\n\t\t// }}}\n\t\t// }}}\n\tend else begin : NO_WRITE_SUPPORT\n\t\t// {{{\n\t\tassign\tS_AXI_AWREADY = 0;\n\t\tassign\tS_AXI_WREADY  = 0;\n\t\tassign\tS_AXI_BID     = 0;\n\t\tassign\tS_AXI_BRESP   = 2'b11;\n\t\tassign\tS_AXI_BVALID  = 0;\n\t\tassign\tS_AXI_BID     = 0;\n\n\t\t//\n\t\tassign\tM_AXI_AWVALID = 0;\n\t\tassign\tM_AXI_AWADDR  = 0;\n\t\tassign\tM_AXI_AWPROT  = 0;\n\t\t//\n\t\tassign\tM_AXI_WVALID  = 0;\n\t\tassign\tM_AXI_WDATA   = 0;\n\t\tassign\tM_AXI_WSTRB   = 0;\n\t\t//\n\t\tassign\tM_AXI_BREADY  = 0;\n\n\t\tassign\taxi_awaddr = 0;\n\t\tassign\taxi_awlen  = 0;\n\t\t// Verilator lint_off WIDTH\n\t\tassign\taxi_awsize = $clog2(C_AXI_DATA_WIDTH/8);\n\t\t// Verilator lint_on  WIDTH\n\t\tassign\taxi_awburst= 2'b01;\n\t\t//\n\t\t// S_AXI_AW* skid buffer\n\t\tassign\tskids_awvalid = 0;\n\t\tassign\tskids_awready = 0;\n\t\tassign\tskids_awid    = 0;\n\t\tassign\tskids_awaddr  = 0;\n\t\tassign\tskids_awlen   = 0;\n\t\tassign\tskids_awsize  = 0;\n\t\tassign\tskids_awburst = 0;\n\t\t//\n\t\t// S_AXI_W* skid buffer\n\t\tassign\tskids_wvalid = S_AXI_WVALID;\n\t\tassign\tskids_wready = S_AXI_WREADY;\n\t\tassign\tskids_wdata  = S_AXI_WDATA;\n\t\tassign\tskids_wstrb  = S_AXI_WSTRB;\n\t\tassign\tskids_wlast  = S_AXI_WLAST;\n\t\t//\n\t\t// S_AXI_B* skid buffer isn't needed\n\t\t//\n\t\t// M_AXI_AW* skid buffer isn't needed\n\t\t//\n\t\t// M_AXI_W* skid buffer\n\t\tassign\tskidm_wvalid = M_AXI_WVALID;\n\t\tassign\tskidm_wready = M_AXI_WREADY;\n\t\tassign\tskidm_wdata  = M_AXI_WDATA;\n\t\tassign\tskidm_wstrb  = M_AXI_WSTRB;\n\t\t//\n\t\t// M_AXI_B* skid buffer\n\t\tassign\tskidm_bvalid = M_AXI_BVALID;\n\t\tassign\tskidm_bready = M_AXI_BREADY;\n\t\tassign\tskidm_bresp  = M_AXI_BRESP;\n\t\t//\n\t\t//\n\t\tassign\ts_axi_wready = 0;\n\t\tassign\taxi_awlen    = 0;\n\t\tassign\tbcounts = 0;\n\n\t\tassign\twfifo_full  = 0;\n\t\tassign\twfifo_empty = 1;\n\t\tassign\twfifo_bid   = 0;\n\t\tassign\twfifo_count = 0;\n\t\tassign\twfifo_bcount= 0;\n\t\tassign\tread_from_wrfifo = 0;\n\n\t\t// Make Verilator happy\n\t\t// {{{\n\t\t// Verilator lint_off UNUSED",
            "wire unused_write_signals;\n\t\tassign\tunused_write_signals = &{ 1'b0,\n\t\t\t\tS_AXI_AWVALID, S_AXI_AWID, S_AXI_AWADDR,\n\t\t\t\t\tS_AXI_AWLEN,\n\t\t\t\t\tS_AXI_AWSIZE, S_AXI_AWBURST,\n\t\t\t\tM_AXI_AWREADY,\n\t\t\t\tM_AXI_WREADY, S_AXI_BREADY,\n\t\t\t\tM_AXI_BVALID, M_AXI_BREADY,\n\t\t\t\tread_from_wrfifo, wfifo_full,\n\t\t\t\tbcounts,\n\t\t\t\twfifo_bcount, wfifo_bid, wfifo_empty,\n\t\t\t\tskidm_wvalid, skidm_wready, skidm_wdata,\n\t\t\t\t\tskidm_wstrb,\n\t\t\t\ts_axi_wready,\n\t\t\t\taxi_awaddr, axi_awlen, axi_awsize, axi_awburst,\n\t\t\t\tskids_awvalid, skids_awready, skids_awid,\n\t\t\t\t\tskids_awaddr, skids_awlen,\n\t\t\t\t\tskids_awburst, skids_awsize,\n\t\t\t\tskids_wvalid, skids_wready, skids_wdata,\n\t\t\t\t\tskids_wstrb,\n\t\t\t\tskidm_bvalid, skidm_bready, skidm_bresp\n\t\t\t\t};\n\t\t// Verilator lint_on  UNUSED\n\t\t// }}}\n\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read",
            "logic // {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (OPT_READS)\n\tbegin : IMPLEMENT_READS\n\t\t// {{{",
            "reg m_axi_arvalid;",
            "reg [C_AXI_ID_WIDTH-1:0]\ts_axi_rid;",
            "wire [C_AXI_ID_WIDTH-1:0]\trfifo_rid;",
            "reg [IW-1:0]\t\tr_rid;",
            "wire read_from_rdfifo;",
            "reg [C_AXI_DATA_WIDTH-1:0]\ts_axi_rdata;",
            "reg s_axi_rlast;",
            "reg [C_AXI_ADDR_WIDTH-1:0]\taxi_araddr;",
            "reg [7:0]\t\t\tr_axi_arlen, axi_rlen;",
            "reg [1:0]\t\t\taxi_arburst;",
            "reg [2:0]\t\t\taxi_arsize;",
            "wire [C_AXI_ADDR_WIDTH-1:0]\tnext_read_addr;",
            "reg s_axi_rvalid;",
            "reg [1:0]\t\t\ts_axi_rresp;",
            "reg [8:0]\t\t\tr_rcounts;",
            "wire [8:0]\t\t\trcounts;",
            "wire [7:0]\t\t\trfifo_rcount;\n\n\t\t// S_AXI_AR* skid buffer\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(IW+AW+8+3+2), .OPT_LOWPOWER(0), .OPT_OUTREG(0)\n\t\t\t// }}}\n\t\t) arskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tS_AXI_ARVALID, S_AXI_ARREADY,\n\t\t\t{ S_AXI_ARID, S_AXI_ARADDR, S_AXI_ARLEN, S_AXI_ARSIZE,\n\t\t\t\tS_AXI_ARBURST },\n\t\t\tskids_arvalid, skids_arready,\n\t\t\t{ skids_arid, skids_araddr, skids_arlen, skids_arsize,\n\t\t\t\tskids_arburst }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\t\t// M_AXI_R* skid buffer\n\t\t// {{{\n\t\tskidbuffer #(\n\t\t\t// {{{\n\t\t\t.DW(DW+2), .OPT_LOWPOWER(0), .OPT_OUTREG(0)\n\t\t\t// }}}\n\t\t) rskid(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tM_AXI_RVALID, M_AXI_RREADY,{ M_AXI_RDATA, M_AXI_RRESP },\n\t\t\tskidm_rvalid,skidm_rready,{ skidm_rdata, skidm_rresp }\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\t\t// m_axi_arvalid\n\t\t// {{{\n\t\tinitial\tm_axi_arvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tm_axi_arvalid <= 0;\n\t\telse if (skids_arvalid && skids_arready)\n\t\t\tm_axi_arvalid <= 1;\n\t\telse if (M_AXI_ARREADY && axi_arlen == 0)\n\t\t\tm_axi_arvalid <= 0;\n\t\t// }}}\n\n\t\t// Read address processing\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (skids_arvalid && skids_arready)\n\t\tbegin\n\t\t\taxi_araddr  <= skids_araddr;\n\t\t\taxi_arburst <= skids_arburst;\n\t\t\taxi_arsize  <= skids_arsize;\n\t\t\taxi_rlen    <= skids_arlen;\n\t\tend else if (M_AXI_ARREADY)\n\t\tbegin\n\t\t\taxi_araddr <= next_read_addr;\n\t\t\tif (OPT_LOWPOWER && axi_arlen == 0)\n\t\t\t\taxi_araddr <= 0;\n\t\tend\n\n\t\taxi_addr #(\n\t\t\t// {{{\n\t\t\t.AW(C_AXI_ADDR_WIDTH), .DW(C_AXI_DATA_WIDTH)\n\t\t\t// }}}\n\t\t) calcrdaddr(\n\t\t\t// {{{\n\t\t\taxi_araddr, axi_arsize, axi_arburst,\n\t\t\taxi_rlen, next_read_addr\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\t// axi_arlen, Read length processing\n\t\t// {{{\n\t\tinitial\tr_axi_arlen = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_axi_arlen <= 0;\n\t\telse if (skids_arvalid && skids_arready)\n\t\t\tr_axi_arlen <= skids_arlen;\n\t\telse if (M_AXI_ARVALID && M_AXI_ARREADY && axi_arlen > 0)\n\t\t\tr_axi_arlen <= axi_arlen - 1;\n\n\t\tassign\taxi_arlen = r_axi_arlen;\n\t\t// }}}\n\n\t\tassign\tskids_arready = (!M_AXI_ARVALID ||\n\t\t\t\t((axi_arlen == 0) && M_AXI_ARREADY))\n\t\t\t\t&& !rfifo_full;\n\n\t\tassign\tread_from_rdfifo = skidm_rvalid && skidm_rready\n\t\t\t\t\t&& (rcounts <= 1) && !rfifo_empty;\n\n\t\t// Read ID FIFO\n\t\t// {{{\n\t\tsfifo\t#(\n\t\t\t// {{{\n\t\t\t.BW(C_AXI_ID_WIDTH+8), .LGFLEN(LGFIFO)\n\t\t\t// }}}\n\t\t) ridlnfifo(\n\t\t\t// {{{\n\t\t\tS_AXI_ACLK, !S_AXI_ARESETN,\n\t\t\tskids_arvalid && skids_arready,\n\t\t\t{ skids_arid, skids_arlen },\n\t\t\trfifo_full, rfifo_count,\n\t\t\tread_from_rdfifo,\n\t\t\t{ rfifo_rid, rfifo_rcount }, rfifo_empty\n\t\t\t// }}}\n\t\t);\n\t\t// }}}\n\n\t\tassign\tskidm_rready = (!S_AXI_RVALID || S_AXI_RREADY);\n\n\t\t// s_axi_rvalid\n\t\t// {{{\n\t\tinitial\ts_axi_rvalid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\ts_axi_rvalid <= 0;\n\t\telse if (skidm_rvalid && skidm_rready)\n\t\t\ts_axi_rvalid <= 1;\n\t\telse if (S_AXI_RREADY)\n\t\t\ts_axi_rvalid <= 0;\n\t\t// }}}\n\n\t\t// s_axi_rresp, s_axi_rdata\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (skidm_rvalid && skidm_rready)\n\t\tbegin\n\t\t\ts_axi_rresp <= skidm_rresp;\n\t\t\ts_axi_rdata <= skidm_rdata;\n\t\tend else if (S_AXI_RREADY)\n\t\tbegin\n\t\t\ts_axi_rresp <= 0;\n\t\t\ts_axi_rdata <= 0;\n\t\tend\n\t\t// }}}\n\n\t\t// rcounts, Return counts\n\t\t// {{{\n\t\tinitial\tr_rcounts = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tr_rcounts <= 0;\n\t\telse if (read_from_rdfifo)\n\t\t\tr_rcounts <= rfifo_rcount + rcounts;\n\t\telse if (skidm_rvalid && skidm_rready)\n\t\t\tr_rcounts <= rcounts - 1;\n\n\t\tassign\trcounts = r_rcounts;\n\t\t// }}}\n\n\t\t// rid\n\t\t// {{{\n\t\tinitial\tr_rid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (read_from_rdfifo)\n\t\t\tr_rid <= rfifo_rid;\n\t\tassign\trid = r_rid;\n\t\t// }}}\n\n\t\t// s_axi_rlast\n\t\t// {{{\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_RVALID || S_AXI_RREADY)\n\t\tbegin\n\t\t\t// if (rcounts == 1) s_axi_rlast <= 1; else\n\t\t\tif (read_from_rdfifo)\n\t\t\t\ts_axi_rlast <= (rfifo_rcount == 0);\n\t\t\telse\n\t\t\t\ts_axi_rlast <= 0;\n\n\t\t\tif (rcounts == 1)\n\t\t\t\ts_axi_rlast <= 1;\n\t\tend\n\t\t// }}}\n\n\t\t// s_axi_rid\n\t\t// {{{\n\t\tinitial\ts_axi_rid = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif ((S_AXI_RVALID && S_AXI_RREADY && S_AXI_RLAST)\n\t\t\t\t||(!S_AXI_RVALID && rcounts == 0))\n\t\t\ts_axi_rid <= (read_from_rdfifo)&&(rcounts == 0)?rfifo_rid : rid;\n\t\t// }}}\n\n\t\t// M_AXI_AR*\n\t\t// {{{\n\t\tassign\tM_AXI_ARVALID= m_axi_arvalid;\n\t\tassign\tM_AXI_ARADDR = axi_araddr;\n\t\tassign\tM_AXI_ARPROT = 0;\n\t\t// }}}\n\t\t// S_AXI_R*\n\t\t// {{{\n\t\tassign\tS_AXI_RVALID = s_axi_rvalid;\n\t\tassign\tS_AXI_RDATA  = s_axi_rdata;\n\t\tassign\tS_AXI_RRESP  = s_axi_rresp;\n\t\tassign\tS_AXI_RLAST  = s_axi_rlast;\n\t\tassign\tS_AXI_RID    = s_axi_rid;\n\t\t// }}}\n\t\t// }}}\n\tend else begin : NO_READ_SUPPORT // if (!OPT_READS)\n\t\t// {{{\n\t\tassign\tM_AXI_ARVALID= 0;\n\t\tassign\tM_AXI_ARADDR = 0;\n\t\tassign\tM_AXI_ARPROT = 0;\n\t\tassign\tM_AXI_RREADY = 0;\n\t\t//\n\t\tassign\tS_AXI_ARREADY= 0;\n\t\tassign\tS_AXI_RVALID = 0;\n\t\tassign\tS_AXI_RDATA  = 0;\n\t\tassign\tS_AXI_RRESP  = 0;\n\t\tassign\tS_AXI_RLAST  = 0;\n\t\tassign\tS_AXI_RID    = 0;\n\n\t\t//\n\t\tassign\tskids_arvalid = S_AXI_ARVALID;\n\t\tassign\tskids_arready = S_AXI_ARREADY;\n\t\tassign\tskids_arid    = S_AXI_ARID;\n\t\tassign\tskids_araddr  = S_AXI_ARADDR;\n\t\tassign\tskids_arlen   = S_AXI_ARLEN;\n\t\tassign\tskids_arsize  = S_AXI_ARSIZE;\n\t\tassign\tskids_arburst = S_AXI_ARBURST;\n\t\t//\n\t\tassign\tskidm_rvalid  = M_AXI_RVALID;\n\t\tassign\tskidm_rready  = M_AXI_RREADY;\n\t\tassign\tskidm_rdata   = M_AXI_RDATA;\n\t\tassign\tskidm_rresp   = M_AXI_RRESP;\n\t\t//\n\t\t//\n\t\tassign\taxi_arlen = 0;\n\t\t// assign\trcounts   = 0;\n\t\tassign\trid       = 0;\n\t\tassign\trfifo_empty = 1;\n\t\tassign\trfifo_full  = 0;\n\t\tassign\trfifo_count = 0;\n\n\t\t// Make Verilator happy\n\t\t// {{{\n\t\t// Verilator lint_off UNUSED",
            "wire unused_read_signals;\n\t\tassign\tunused_read_signals = &{ 1'b0,\n\t\t\t\trid, rfifo_empty, rfifo_count, rfifo_full,\n\t\t\t\taxi_arlen,\n\t\t\t\tskids_arvalid, skids_arready, skids_arid, skids_araddr, skids_arlen, skids_arsize, skids_arburst,\n\t\t\t\tskidm_rvalid, skidm_rready,\n\t\t\t\t\tskidm_rdata, skidm_rresp,\n\t\t\t\tM_AXI_ARREADY, S_AXI_RREADY };\n\t\t// Verilator lint_on  UNUSED\n\t\t// }}}\n\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t// Make Verilator happy\n\t// {{{\n\t// Verilator lint_off UNUSED",
            "wire [35-1:0]\tunused;\n\tassign\tunused = {\n\t\tS_AXI_AWLOCK, S_AXI_AWCACHE, S_AXI_AWPROT, S_AXI_AWQOS,\n\t\tskids_wlast, wfifo_count,\n\t\tS_AXI_ARLOCK, S_AXI_ARCACHE, S_AXI_ARPROT, S_AXI_ARQOS,\n\t\trfifo_count };\n\t// Verilator lint_on  UNUSED\n\t// }}}\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//\n// Formal properties\n// {{{\n// The following are a subset of the formal properties used to verify this core\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n`ifdef\tFORMAL",
            "localparam F_LGDEPTH = LGFIFO+1+8;\n\n\t//\n\t// ...\n\t//\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI channel properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tfaxi_slave #(.C_AXI_ID_WIDTH(IW),\n\t\t\t.C_AXI_DATA_WIDTH(DW),\n\t\t\t.C_AXI_ADDR_WIDTH(AW),\n\t\t\t//\n\t\t\t)\n\t\tfaxi(.i_clk(S_AXI_ACLK),\n\t\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t\t// Write address\n\t\t\t.i_axi_awready(skids_awready),\n\t\t\t.i_axi_awid(   skids_awid),\n\t\t\t.i_axi_awaddr( skids_awaddr),\n\t\t\t.i_axi_awlen(  skids_awlen),\n\t\t\t.i_axi_awsize( skids_awsize),\n\t\t\t.i_axi_awburst(skids_awburst),\n\t\t\t.i_axi_awlock( 0),\n\t\t\t.i_axi_awcache(0),\n\t\t\t.i_axi_awprot( 0),\n\t\t\t.i_axi_awqos(  0),\n\t\t\t.i_axi_awvalid(skids_awvalid),\n\t\t\t// Write data\n\t\t\t.i_axi_wready( skids_wready),\n\t\t\t.i_axi_wdata(  skids_wdata),\n\t\t\t.i_axi_wstrb(  skids_wstrb),\n\t\t\t.i_axi_wlast(  skids_wlast),\n\t\t\t.i_axi_wvalid( skids_wvalid),\n\t\t\t// Write return response\n\t\t\t.i_axi_bid(    S_AXI_BID),\n\t\t\t.i_axi_bresp(  S_AXI_BRESP),\n\t\t\t.i_axi_bvalid( S_AXI_BVALID),\n\t\t\t.i_axi_bready( S_AXI_BREADY),\n\t\t\t// Read address\n\t\t\t.i_axi_arready(skids_arready),\n\t\t\t.i_axi_arid(   skids_arid),\n\t\t\t.i_axi_araddr( skids_araddr),\n\t\t\t.i_axi_arlen(  skids_arlen),\n\t\t\t.i_axi_arsize( skids_arsize),\n\t\t\t.i_axi_arburst(skids_arburst),\n\t\t\t.i_axi_arlock( 0),\n\t\t\t.i_axi_arcache(0),\n\t\t\t.i_axi_arprot( 0),\n\t\t\t.i_axi_arqos(  0),\n\t\t\t.i_axi_arvalid(skids_arvalid),\n\t\t\t// Read response\n\t\t\t.i_axi_rid(    S_AXI_RID),\n\t\t\t.i_axi_rresp(  S_AXI_RRESP),\n\t\t\t.i_axi_rvalid( S_AXI_RVALID),\n\t\t\t.i_axi_rdata(  S_AXI_RDATA),\n\t\t\t.i_axi_rlast(  S_AXI_RLAST),\n\t\t\t.i_axi_rready( S_AXI_RREADY),\n\t\t\t//\n\t\t\t// Formal property data\n\t\t\t.f_axi_awr_nbursts(   faxi_awr_nbursts),\n\t\t\t.f_axi_wr_pending(    faxi_wr_pending),\n\t\t\t.f_axi_rd_nbursts(    faxi_rd_nbursts),\n\t\t\t.f_axi_rd_outstanding(faxi_rd_outstanding),\n\t\t\t//\n\t\t\t// ...\n\t\t\t);\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// AXI-lite properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tfaxil_master #(.C_AXI_DATA_WIDTH(DW), .C_AXI_ADDR_WIDTH(AW),\n\t\t\t.F_OPT_NO_RESET(1),\n\t\t\t.F_AXI_MAXWAIT(5),\n\t\t\t.F_AXI_MAXDELAY(4),\n\t\t\t.F_AXI_MAXRSTALL(0),\n\t\t\t.F_OPT_WRITE_ONLY(OPT_WRITES && !OPT_READS),\n\t\t\t.F_OPT_READ_ONLY(!OPT_WRITES &&  OPT_READS),\n\t\t\t.F_LGDEPTH(F_AXIL_LGDEPTH))\n\t\tfaxil(.i_clk(S_AXI_ACLK),\n\t\t\t.i_axi_reset_n(S_AXI_ARESETN),\n\t\t\t// Write address channel\n\t\t\t.i_axi_awvalid(M_AXI_AWVALID),\n\t\t\t.i_axi_awready(M_AXI_AWREADY),\n\t\t\t.i_axi_awaddr( M_AXI_AWADDR),\n\t\t\t.i_axi_awprot( M_AXI_AWPROT),\n\t\t\t// Write data\n\t\t\t.i_axi_wready( skidm_wready),\n\t\t\t.i_axi_wdata(  skidm_wdata),\n\t\t\t.i_axi_wstrb(  skidm_wstrb),\n\t\t\t.i_axi_wvalid( skidm_wvalid),\n\t\t\t// Write response\n\t\t\t.i_axi_bresp(  skidm_bresp),\n\t\t\t.i_axi_bvalid( skidm_bvalid),\n\t\t\t.i_axi_bready( skidm_bready),\n\t\t\t// Read address\n\t\t\t.i_axi_arvalid(M_AXI_ARVALID),\n\t\t\t.i_axi_arready(M_AXI_ARREADY),\n\t\t\t.i_axi_araddr( M_AXI_ARADDR),\n\t\t\t.i_axi_arprot( M_AXI_ARPROT),\n\t\t\t// Read data return\n\t\t\t.i_axi_rvalid( skidm_rvalid),\n\t\t\t.i_axi_rready( skidm_rready),\n\t\t\t.i_axi_rdata(  skidm_rdata),\n\t\t\t.i_axi_rresp(  skidm_rresp),\n\t\t\t//\n\t\t\t// Formal check variables\n\t\t\t.f_axi_rd_outstanding(faxil_rd_outstanding),\n\t\t\t.f_axi_wr_outstanding(faxil_wr_outstanding),\n\t\t\t.f_axi_awr_outstanding(faxil_awr_outstanding));\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Assume that the two write channels stay within an appropriate\n\t// distance of each other.  This is to make certain that the property\n\t// file features are not violated, although not necessary true for\n\t// actual operation\n\t//\n\talways @(*)\n\t\tassert(s_axi_wready == (OPT_WRITES && faxi_wr_pending > 0));\n\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Write induction properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// These are extra properties necessary to pass write induction\n\t//\n\n\talways @(*)\n\tif ((bcounts == 0)&&(!read_from_wrfifo))\n\t\tassert(!skidm_bvalid || !skidm_bready);\n\n\talways @(*)\n\tif (axi_awlen > 0)\n\tbegin\n\t\tassert(m_axi_awvalid);\n\t\tif (axi_awlen > 1)\n\t\tbegin\n\t\t\tassert(!skids_awready);\n\t\tend else if (wfifo_full)\n\t\tbegin\n\t\t\tassert(!skids_awready);\n\t\tend else if (M_AXI_AWVALID && !M_AXI_AWREADY)\n\t\t\tassert(!skids_awready);\n\tend\n\n\n\talways @(*)\n\t\tassert(axi_bresp != EXOKAY);",
            "reg [F_LGDEPTH-1:0]\tf_wfifo_bursts, f_wfifo_bursts_minus_one,\n\t\t\t\tf_wfifo_within,\n\t\t\t\tf_wfiid_bursts, f_wfiid_bursts_minus_one;",
            "reg [IW-1:0]\tf_awid;\n\talways @(posedge S_AXI_ACLK)\n\tif (skids_awvalid && skids_awready)\n\t\tf_awid = skids_awid;\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Read induction properties\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\n\talways @(*)\n\tif (!S_AXI_RVALID && rcounts > 0)\n\t\tassert(rid == S_AXI_RID);\n\n\talways @(*)\n\tif (S_AXI_RVALID && !S_AXI_RLAST)\n\t\tassert(rid == S_AXI_RID);\n\n\talways @(*)\n\tif ((rcounts == 0)&&(!read_from_rdfifo))\n\t\tassert(!skidm_rvalid || !skidm_rready);\n\n\talways @(*)\n\tif (axi_arlen > 0)\n\tbegin\n\t\tassert(m_axi_arvalid);\n\t\tassert(!skids_arready);\n\tend\n\n\t//\n\t// ...\n\t//\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Select only write or only read operation\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (!OPT_WRITES)\n\tbegin\n\t\talways @(*)\n\t\tbegin\n\t\t\tassume(!skids_awvalid);\n\t\t\tassume(!skids_wvalid);\n\t\t\tassert(M_AXI_AWVALID == 0);\n\t\t\tassert(faxil_awr_outstanding == 0);\n\t\t\tassert(faxil_wr_outstanding == 0);\n\t\t\tassert(!skidm_bvalid);\n\t\t\tassert(!S_AXI_BVALID);\n\t\tend\n\tend endgenerate\n\n\tgenerate if (!OPT_READS)\n\tbegin\n\n\t\talways @(*)\n\t\tbegin\n\t\t\tassume(!S_AXI_ARVALID);\n\t\t\tassert(M_AXI_ARVALID == 0);\n\t\t\tassert(faxil_rd_outstanding == 0);\n\t\tend\n\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// Cover statements, to show performance\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t//\n\tgenerate if (OPT_WRITES)\n\tbegin\n\t\t// {{{",
            "reg [3:0]\tcvr_write_count, cvr_write_count_simple;\n\n\t\tinitial\tcvr_write_count = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tcvr_write_count_simple <= 0;\n\t\telse if (S_AXI_AWVALID && S_AXI_AWREADY && S_AXI_AWLEN == 0)\n\t\t\tcvr_write_count_simple <= cvr_write_count_simple + 1;\n\n\t\tinitial\tcvr_write_count = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tcvr_write_count <= 0;\n\t\telse if (S_AXI_AWVALID && S_AXI_AWREADY && S_AXI_AWLEN > 2)\n\t\t\tcvr_write_count <= cvr_write_count + 1;\n\n\t\talways @(*)\n\t\t\tcover(cvr_write_count_simple > 6 && /* ... */ !S_AXI_BVALID);\n\t\talways @(*)\n\t\t\tcover(cvr_write_count > 2 && /* ... */ !S_AXI_BVALID);\n\t\t// }}}\n\tend endgenerate\n\n\tgenerate if (OPT_READS)\n\tbegin\n\t\t// {{{",
            "reg [3:0]\tcvr_read_count, cvr_read_count_simple;\n\n\t\tinitial\tcvr_read_count_simple = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tcvr_read_count_simple <= 0;\n\t\telse if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN == 0)\n\t\t\tcvr_read_count_simple <= cvr_read_count_simple + 1;\n\n\t\tinitial\tcvr_read_count = 0;\n\t\talways @(posedge S_AXI_ACLK)\n\t\tif (!S_AXI_ARESETN)\n\t\t\tcvr_read_count <= 0;\n\t\telse if (S_AXI_ARVALID && S_AXI_ARREADY && S_AXI_ARLEN > 2)\n\t\t\tcvr_read_count <= cvr_read_count + 1;\n\n\t\talways @(*)\n\t\t\tcover(cvr_read_count_simple > 6 && /* ... */ !S_AXI_RVALID);\n\t\talways @(*)\n\t\t\tcover(cvr_read_count > 2 && /* ... */ !S_AXI_RVALID);\n\t\t// }}}\n\tend endgenerate\n\t// }}}\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// ...\n\t// {{{\n\t////////////////////////////////////////////////////////////////////////\n\t//\n\t// }}}\n`undef\tBMC_ASSERT\n`endif\n// }}}",
            "endmodule "
        ]
    }
]